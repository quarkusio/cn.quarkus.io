# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-06-26 15:18+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: title
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy, no-wrap
msgid "Inspecting the Quarkus Native call path universe with Neo4j"
msgstr "用Neo4j检查Quarkus Native调用路径宇宙"

#. type: YAML Front Matter: synopsis
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy, no-wrap
msgid "Inspect the call paths that get included into a Quarkus Native app with Neo4j"
msgstr "用Neo4j检查包含在Quarkus Native应用中的调用路径"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"This blog post is the culmination of an idea that Sanne (Grinovero) floated to me during some lunch,\n"
"back at a time when we, remote engineers, would occasionally meet face to face and have the opportunity to share ideas spontaneously.\n"
"I'm unsure if the lunch was in Neuchâtel or Barcelona,\n"
"but essentially Sanne was diagnosing an issue and he struggled with GraalVM's native image analysis call tree text output.\n"
"He wondered whether that data could instead be formatted differently and imported into a graph database for easier inspection.\n"
"I'm happy to announce that the GraalVM and Mandrel 21.3.0 releases include improvements to address this particular issue."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"Essentially, they bring much needed improvements for analysing code paths that get included in the native binary.\n"
"Debugging these code paths aims to answer questions such as:"
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "why does this code path get included in the native binary?"
msgstr "为什么这个代码路径被包含在本地二进制文件中？"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"These code paths can be optionally reported when enabling printing of the analysis call tree.\n"
"With Quarkus, this is achieved by passing in the `-Dquarkus.native.enable-reports` option."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"Before 21.3.0, when Quarkus instructed a GraalVM distribution to print out the call tree,\n"
"the resulting output would be a single text file representing the call tree in a https://www.graalvm.org/reference-manual/native-image/Reports[custom tree format].\n"
"This text file would contain a lot of duplicated information and could be as big as several gigabytes in size."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"GraalVM 21.3.0 introduces the possibility of representing call trees as CSV files instead of a single text file.\n"
"These CSV files contain method information and different connections between them\n"
"(e.g. direct calls, virtual calls, overrides, etc).\n"
"One immediate benefit is that there's no information duplication,\n"
"so the CSV files can be several times smaller in size compared to the corresponding text file.\n"
"In some situations, they can be as much as several thousands times smaller.\n"
"However, the main reason why this feature was implemented was\n"
"to make it easier to feed the call tree to other tools, like graph databases such as\n"
"https://neo4j.com/[Neo4j].\n"
"Once imported, a user can execute graph queries over the call tree,\n"
"which makes it easier to extract relevant information and answer questions like the one above."
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "In this blog post, you will learn how to:"
msgstr "在这篇博文中，你将学习如何。"

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Instruct a Quarkus application to generate call tree CSV files."
msgstr "指导Quarkus应用程序生成呼叫树CSV文件。"

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Run a Neo4j graph database within a container"
msgstr "在容器中运行Neo4j图形数据库"

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Import those CSV files into a Neo4j graph database."
msgstr "将这些CSV文件导入Neo4j图形数据库。"

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Run Neo4j cypher queries against the graph database to understand the call paths in the Quarkus application."
msgstr "针对图数据库运行Neo4j cypher查询，以了解Quarkus应用程序中的调用路径。"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"This blog post uses the\n"
"https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-orm-quickstart[Quarkus Hibernate ORM quickstart]\n"
"as a sample Quarkus application.\n"
"Download the application and execute:"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"./mvnw package -DskipTests -Pnative \\\n"
"    -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:21.3-java11 \\\n"
"    -Dquarkus.native.enable-reports"
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "The above command will generate a native binary and the CSV files mentioned above."
msgstr "上述命令将生成一个本地二进制文件和上述的CSV文件。"

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Next, start Neo4j in a container:"
msgstr "接下来，在一个容器中启动Neo4j。"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"$ export NEO_PASS=...\n"
"$ podman run \\\n"
"    --detach \\\n"
"    --rm \\\n"
"    --name testneo4j \\\n"
"    -p7474:7474 -p7687:7687 \\\n"
"    --env NEO4J_AUTH=neo4j/${NEO_PASS} \\\n"
"    neo4j:latest"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"Once the container is running,\n"
"you can access the Neo4j browser via http://localhost:7474[http://localhost:7474].\n"
"Use `neo4j` as the username and the value of `NEO_PASS` as the password to log in."
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "To import the CSV files, we need the following cypher script which will import the data within the CSV files and create graph database nodes and edges:"
msgstr "为了导入CSV文件，我们需要以下Cypher脚本，它将导入CSV文件内的数据，并创建图数据库的节点和边。"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"You can download the cypher script from\n"
"link:/assets/examples/posts/quarkus-native-neo4j-call-tree/import.cypher[this link]\n"
"or copy and paste it in a file called `import.cypher`."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"The script above is generic enough to work with any Quarkus application,\n"
"but it will only work with Mandrel 21.3.0.Final.\n"
"GraalVM CE 21.3.0.Final lacks the symbolic links to make the `csv` file references work,\n"
"so if you're on this GraalVM CE, you'll have to modify the CSV file names with project specific, timestamped, file names."
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Next, copy the import cypher script and CSV files into Neo4j's import folder:"
msgstr "接下来，将导入的cypher脚本和CSV文件复制到Neo4j的导入文件夹。"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"$ podman cp target/*-native-image-source-jar/reports testneo4j:/var/lib/neo4j/import\n"
"$ podman cp import.cypher testneo4j:/var/lib/neo4j"
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "After copying all the files, invoke the import script:"
msgstr "拷贝完所有文件后，调用导入脚本。"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid "$ podman exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} -f import.cypher"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"If you need to reimport the data,\n"
"you'll need to clear the previously imported data,\n"
"otherwise you'll get errors.\n"
"You can clear the previously imported data by executing:"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"$ podman exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \"MATCH(n) DETACH DELETE n\"\n"
"$ podman exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \"DROP CONSTRAINT unique_vm_id\"\n"
"$ podman exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \"DROP CONSTRAINT unique_method_id\""
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"Once the import completes (shouldn't take more than a couple of minutes),\n"
"go to the Neo4j browser and you'll be able to observe a small summary of the data in the graph:"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"The data above shows that there are ~100000 methods,\n"
"and just over ~300000 edges between them."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"Next, let's try out some cypher queries to explore the call graph.\n"
"I don't know anything about the Quarkus application itself,\n"
"but given it's a Hibernate ORM application,\n"
"I can assume that some sort of `persist` method will be called.\n"
"Go into the browser and type a query for this:"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"We got some hits,\n"
"but the default style for the nodes presented is not very readable.\n"
"We can however tweak the stylesheet as shown by\n"
"https://neo4j.com/developer/neo4j-browser/#browser-styling-adv[this guide].\n"
"Two useful modifications for this use case is to increase the default `node` `diameter` value to say, `150px`.\n"
"The other modification is to switch `node.Method` `caption` value to `\"{display}\"`."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"`display` is a field within each method that shows a shortened id of the method,\n"
"that includes package and classname (only the first letter of each),\n"
"and the method name in camel case with single letters.\n"
"E.g. `j.p.EM.persist` would be the `display` for the `persist` method in `javax.persistence.EntityManager`."
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Let's repeat the query after modifying the browser style and moving the nodes to clearly view them:"
msgstr "让我们在修改浏览器样式和移动节点以清楚地查看它们之后重复查询。"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"We can see above that one of the `persist` is to `javax.persistence.EntityManager`.\n"
"This is the JPA method for persisting entities and the one we'll be exploring further.\n"
"Let's narrow the query down to that one to have a clearer view:"
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Note that if we hover over the node we get information about the method itself."
msgstr "请注意，如果我们将鼠标悬停在节点上，就会得到关于方法本身的信息。"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"Going back to the original question,\n"
"we wanted to find out why a given code path gets included.\n"
"One way to do it is to start by the method itself,\n"
"and then walk backwards to find what links\n"
"(e.g. direct calls, virtual calls, overrides...etc)\n"
"exist to that method within a certain depth.\n"
"For example, let's try to find what other methods have a direct link to the `persist` method:"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"Aha, so there's only one path and that's a virtual call (i.e., an interface call) that comes from the `create` method in the `org.acme.hibernate.orm.FruitResource` class,\n"
"which takes a `org.acme.hibernate.orm.Fruit` parameter and returns a `javax.ws.rs.core.Response`."
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
#, fuzzy
msgid "Next, let's expand the query further and try to find all links with a depth of 2 to the `persist` method:"
msgstr "接下来，让我们进一步扩大查询范围，尝试找到所有深度为2的链接， `persist` 。"

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"As we peel further back,\n"
"we start to see some generated classes that invoke the `create` method in `org.acme.hibernate.orm.FruitResource`.\n"
"`org.acme.hibernate.orm.FruitResource_ClientProxy` and `org.acme.hibernate.orm.FruitResource_Subclass` both directly call the method.\n"
"One more interesting call comes from the `FruitResource_create_d0...` method in `com.oracle.svm.core.reflect.ReflectionAccessorHolder`.\n"
"This essentially means that the `create` method has been registered in GraalVM for access via reflection."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"If we query for a depth of 3, we'll find that the reflection access is an entry point.\n"
"So, we've found the shortest path to the `persist` method,\n"
"but that's not necessarily the only path:"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"You can continue going up layers,\n"
"but unfortunately if you reach a depth with too many nodes,\n"
"the Neo4j browser will be unable to visualize them all.\n"
"When that happens, you can alternatively run the queries directly against the cypher shell. E.g."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"$ podman exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \\\n"
"    \"match (m:Method) <- [*1..10] - (o) where m.name = 'persist' and m.type =~ '.*EntityManager' return *\""
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid "After you are done with the exploration don't forget to shut down (`kill`) the `testneo4j` container:"
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid "$ podman kill testneo4j"
msgstr ""

#. type: Plain text
#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid "Note that this will also remove the container (since we used `--rm` when we created it)."
msgstr ""

#: _posts/2021-11-30-quarkus-native-neo4j-call-tree.adoc
msgid ""
"We've only just started exploring the possibilities of Neo4j for this use case,\n"
"and so we still have to learn all the tips and tricks to make the most out of it.\n"
"As we learn more we'll share any tips or query templates with the community."
msgstr ""
