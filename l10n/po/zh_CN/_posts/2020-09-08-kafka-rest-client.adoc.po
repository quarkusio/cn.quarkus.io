# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr ""

#. type: YAML Front Matter: date
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:1
#, no-wrap
msgid "2020-09-08"
msgstr ""

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:1
#, no-wrap
msgid "post"
msgstr ""

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:1
#, no-wrap
msgid "How to combine reactive messaging, Kafka and the Rest client"
msgstr ""

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:1
#, no-wrap
msgid "reactive kafka rest mutiny http"
msgstr ""

#. type: YAML Front Matter: title
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:1
#, no-wrap
msgid "Combining Apache Kafka and the Rest client"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:13
msgid "Another week, another interesting question.  This week, someone asks me about combining Kafka and the Rest Client.  That is a recurring subject, and most of the time, the goal is to achieve the following process:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:15
msgid "image:/assets/images/posts/kafka-rest-client/kafka-rest-architecture.png[]"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:21
msgid "In other words, we want to call a remote service for each Kafka message we receive.  Therefore, we have a first topic (\"in\") containing the data we are consuming, for instance, \"transactions\".  Then, we have the central piece of the architecture: the processing component.  It consumes the incoming transactions, and for each of them, calls a remote service.  It also writes the response (produced by the remote service) to another Kafka topic \"out\"."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:24
msgid "Implementing this with Quarkus is straightforward, and that's what we will cover in this post.  Thanks to Reactive Messaging and the Rest Client, this should not take more than 20 lines of code!"
msgstr ""

#. type: Title ==
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:25
#, no-wrap
msgid "The Remote Service"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:29
msgid "Let's start with the remote service.  Quarkus offers multiple ways to invoke a remote HTTP service, but let's use the Rest Client as it provides an excellent way to interact with HTTP services without having to handle the low-level details of HTTP."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:31
msgid "You can use any HTTP API, but to simplify, let's consider a straightforward remote service, something like:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:38
#, no-wrap
msgid ""
"@RegisterRestClient(configKey = \"transaction-service\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public interface TransactionService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:42
#, no-wrap
msgid ""
"    @Path(\"/transactions\")\n"
"    @POST \n"
"    TransactionResult postSync(Transaction transaction);\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:46
#, no-wrap
msgid ""
"    @Path(\"/transactions\")\n"
"    @POST \n"
"    Uni<TransactionResult> postAsync(Transaction transaction);\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:48
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:92
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:116
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:147
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:56
msgid "This service contains two methods calling the same HTTP endpoint.  The first one is synchronous, and so blocks the caller thread until the response is received.  The second is asynchronous, and the returned `Uni` gets the response when received.  In this case, the caller thread is not blocked and can do something else.  We are going to see how to use these methods later, but first, a bit of configuration.  In the `application.properties` add:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:61
#, no-wrap
msgid ""
"# Configure the transaction-service (rest client)\n"
"transaction-service/mp-rest/url=http://localhost:8080\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:65
msgid "Of course, update the URL.  The https://quarkus.io/guides/rest-client[https://quarkus.io/guides/rest-client] guide gives more details about the usage and configuration of the Rest Client."
msgstr ""

#. type: Title ==
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:66
#, no-wrap
msgid "Invoking the service for each incoming transaction"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:73
msgid "Ok, we can call our service, but remember, we want to invoke it for every incoming transaction, and these transactions come from a Kafka topic.  With Reactive Messaging, there is no need to handle Kafka right now.  We can focus on the logic.  Let's say we have a *channel* (a stream of data), in which to transit our transactions.  We call this first channel `in`."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:77
msgid "We also want to write the responses from the remote service into another Kafka topic.  Again, no need to handle Kafka right now.  Let's say we write the responses into a channel named `out`."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:79
msgid "So, we have the following (incomplete) code:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:84
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:102
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:134
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class TransactionProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:90
#, no-wrap
msgid ""
"    @Incoming(\"in\") // The first channel - we read from it\n"
"    @Outgoing(\"out\") // The second channel - we write to it\n"
"    public TransactionResult sendToTransactionService(Transaction transaction) {\n"
"       // Need to call our service here\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:97
msgid "`@Incoming` configures the read channel.  `@Outgoing` configures the written channel.  But, something is missing... we need to call our remote service:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:104
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:136
#, no-wrap
msgid "    private static final Logger LOGGER = Logger.getLogger(\"TransactionProcessor\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:106
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:138
#, no-wrap
msgid "    @Inject @RestClient TransactionService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:114
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @Outgoing(\"out\")\n"
"    @Blocking\n"
"    public TransactionResult sendToTransactionService(Transaction transaction) {\n"
"        LOGGER.infof(\"Sending %s transaction service\", transaction);\n"
"        return service.postSync(transaction);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:120
msgid "First, we inject the Rest Client.  Then, we just invoke it in our method."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:125
msgid "You may wonder about `@Blocking`.  With reactive messaging, you need to indicate when you are using blocking code, as by default, it uses an event loop architecture.  While convenient, you should not abuse `@Blocking`, as it relies on a thread pool limiting your concurrency.  But, it keeps your logic synchronous."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:127
msgid "### Using Asynchronous operations"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:129
msgid "We can get rid of `@Blocking` annotation by using the second method provided by the `TransactionService`: `postAsync:`"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:145
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @Outgoing(\"out\")\n"
"    public Uni<TransactionResult> sendToTransactionService(Transaction transaction) {\n"
"        LOGGER.infof(\"Sending %s transaction service\", transaction);\n"
"        return service.postAsync(transaction);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:152
msgid "Using the *async* variant of the `post` method allows us to remove `@Blocking`.  We return the `Uni` directly.  When that `Uni` receives the remote service's response, it writes the value to the `out` channel."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:154
msgid "### Mapping channel to Kafka"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:160
msgid "So far, so good.  It's time to connect our code with Kafka.  With Reactive Messaging, we map channels to _connectors_, here Kafka.  So, we just need to configure the application to indicate that the `in` and `out` channels are Kafka topics.  Once again, edit the `application.properties` file, and add:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:167
msgid "``` mp.messaging.incoming.in.connector=smallrye-kafka mp.messaging.incoming.in.topic=transactions mp.messaging.incoming.in.value.deserializer=org.acme.model.TransactionDeserializer mp.messaging.incoming.in.auto.offset.reset=earliest mp.messaging.incoming.in.enable.auto.commit=false"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:172
msgid "mp.messaging.outgoing.out.connector=smallrye-kafka mp.messaging.outgoing.out.topic=output mp.messaging.outgoing.out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer ```"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:177
msgid "The first block is about the `in` channel.  It's connected to the `transactions` Kafka topic.  The data is deserialized with a https://github.com/cescoffier/quarkus-kafka-rest-client-demo/blob/master/src/main/java/org/acme/model/TransactionDeserializer.java[custom deserializer].  The last other properties disable the auto-commit (Reactive Messaging is handling commits for you) and read the data since the last committed offset."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:181
msgid "The second block configures the `out` channel.  We connect it with the `output` Kafka topic and configure the value serializer.  For this simple example, we write the data as JSON."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:183
msgid "So, when a transaction is written to the Kafka `transaction` topic, it gets received by our processing component, sent to the remote service, and the result is written to the `output` Kafka topic:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:190
#, no-wrap
msgid ""
"2020-08-27 10:04:44,141 INFO  [TransactionProcessor] (vert.x-eventloop-thread-0) Sending Transaction{name='MacroHard', amount=20} transaction service\n"
"2020-08-27 10:04:44,196 INFO  [TransactionResource] (executor-thread-2) Handling transaction MacroHard / 20\n"
"2020-08-27 10:04:44,240 INFO  [TransactionProcessor] (vert.x-eventloop-thread-0) Sending Transaction{name='BlueHat', amount=10} transaction service\n"
"2020-08-27 10:04:44,245 INFO  [TransactionResource] (executor-thread-2) Handling transaction BlueHat / 10\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:193
msgid "If you look inside the `output` topic, you will see the `TransactionResult` flowing:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:195
msgid "image:/assets/images/posts/kafka-rest-client/output.png[]"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:197
msgid "### We are done!"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:199
msgid "With a few lines of code and a bit of configuration, we can read data from a Kafka topic, call a remote service, and write the result to another Kafka topic. Plain simple."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:202
msgid "Want to try by yourself? Check out the code in this https://github.com/cescoffier/quarkus-kafka-rest-client-demo[GitHub repository] and follow the instructions from the readme."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:204
msgid "Reactive Messaging and the Rest client contain other gems, check the related guides and documentation to learn more about them:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:206
msgid "https://quarkus.io/guides/rest-client[Using the Rest Client]"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:207
msgid "https://quarkus.io/guides/kafka[Interacting with Kafka]"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:207
msgid "https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.2/kafka/kafka.html[The Kafka Connector documentation]"
msgstr ""
