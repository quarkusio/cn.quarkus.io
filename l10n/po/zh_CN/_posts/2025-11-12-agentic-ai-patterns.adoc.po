msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "Agentic AI Patterns: one size does not fit all"
msgstr "代理人工智能模式：不能一刀切"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "At the beginning of 2025, we began experimenting with agentic AI using Quarkus and its LangChain4j extension. These efforts led to the publication of a three-part blog post series on the topic: the first https://quarkus.io/blog/agentic-ai-with-quarkus/[introduced agentic AI and workflow patterns], the second https://quarkus.io/blog/agentic-ai-with-quarkus-p2/[explored purely AI-orchestrated agentic patterns], and the third https://quarkus.io/blog/agentic-ai-with-quarkus-p3/[examined the differences between these two approaches] through a practical example, highlighting their respective pros and cons."
msgstr "2025 年初，我们开始使用 Quarkus 及其 LangChain4j 扩展尝试代理人工智能。通过这些努力，我们发表了由三部分组成的博文系列：第一部分 link:https://quarkus.io/blog/agentic-ai-with-quarkus/[介绍了代理人工智能和工作流模式] ，第二部分 link:https://quarkus.io/blog/agentic-ai-with-quarkus-p2/[探讨了纯粹由人工智能协调的代理模式] ，第三部分通过一个实际例子 link:https://quarkus.io/blog/agentic-ai-with-quarkus-p3/[探讨了这两种方法之间的差异] ，强调了它们各自的优缺点。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "Only a few months have passed since those articles were published, yet the AI ecosystem and the possibilities it unlocks have evolved at an incredible pace. Keeping up with the constant stream of novelties and changes has become increasingly challenging. In fact, the initial experiments from that series now seem to belong to a different era, even though they laid the essential groundwork for exploring the agentic AI landscape."
msgstr "自这些文章发表以来，仅仅过去了几个月的时间，但人工智能生态系统及其所带来的可能性却以惊人的速度发展着。跟上不断涌现的新事物和新变化已变得越来越具有挑战性。事实上，该系列文章中的最初实验现在似乎已经属于另一个时代，尽管它们为探索代理人工智能领域奠定了重要基础。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "These experiments and explorations led to the implementation of a https://docs.langchain4j.dev/tutorials/agents/[new agentic module] in LangChain4j, designed to provide a comprehensive toolkit for building agentic AI systems. The module also includes a set of predefined agentic patterns that serve as building blocks for coordinating agents in different ways. However, as we continued experimenting and, more importantly, discussing our findings with the LangChain4j community, it became clear that believing this set of patterns could fully cover all possible use cases was somewhat naive. In reality, the landscape is far more complex and nuanced."
msgstr "这些实验和探索促使我们在 LangChain4j 中实施了一个 link:https://docs.langchain4j.dev/tutorials/agents/[新的代理模块] ，旨在为构建代理人工智能系统提供一个全面的工具包。该模块还包括一组预定义的代理模式，可作为以不同方式协调代理的构建模块。然而，随着我们不断尝试，更重要的是与 LangChain4j 社区讨论我们的发现，我们逐渐发现，认为这套模式可以完全涵盖所有可能的用例有些天真。实际上，情况要复杂得多，也细致得多。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "Agentic AI at Devoxx Belgium 2025"
msgstr "2025 年比利时 Devoxx 展会上的代理人工智能"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "Agentic AI was, by far, one of the most discussed topics at Devoxx Belgium 2025, and we had the opportunity to present the agentic AI patterns implemented in LangChain4j. In fact, we delivered both a https://www.youtube.com/watch?v=X9baI7RBhqk[talk] showcasing practical examples of how these patterns work and how to use them, and a https://www.youtube.com/watch?v=mtWHfYTLeKE[session] that delved deeper into the journey behind implementing the agentic framework, including the key decisions we made and the mistakes we learned from along the way."
msgstr "到目前为止，代理人工智能是 2025 年比利时 Devoxx 大会上讨论最多的话题之一，我们有机会展示了在 LangChain4j 中实现的代理人工智能模式。事实上，我们既发表了 link:https://www.youtube.com/watch?v=X9baI7RBhqk[演讲] ，展示了这些模式如何工作以及如何使用它们的实际例子，又举行了一场 link:https://www.youtube.com/watch?v=mtWHfYTLeKE[会议] ，深入探讨了实施代理框架背后的历程，包括我们做出的关键决定以及我们在这一过程中学到的错误。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "As always at Devoxx, what mattered even more than attending the countless talks on agentic AI was the opportunity to meet so many people working in this field, exchanging ideas, sharing experiences, and discussing challenges and solutions."
msgstr "一如既往，在 Devoxx 上，比参加无数关于代理人工智能的演讲更重要的是，我们有机会结识许多在这一领域工作的人，交流思想、分享经验、讨论挑战和解决方案。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "We learned a great deal from these interactions and returned home with one clear realization: we will never find a definitive pattern for agent orchestration. Not only is this beyond our specific area of expertise, but more importantly, such a universal pattern simply doesn’t exist. The variety and complexity of tasks that an agentic system may need to handle mean that no single approach can work in every situation: there is no one-size-fits-all solution for agentic AI orchestration."
msgstr "我们从这些互动中学到了很多东西，回国后，我们清楚地认识到：我们永远也找不到一个明确的代理协调模式。这不仅超出了我们的专业领域，更重要的是，这种通用模式根本不存在。代理系统需要处理的任务种类繁多，复杂程度高，这意味着没有一种方法可以适用于所有情况：代理人工智能协调没有放之四海而皆准的解决方案。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "In reality, there is a broad spectrum of agentic patterns, ranging from reliable and deterministic yet rigid workflows, where agents follow predefined code and flow paths, to flexible yet unpredictable pure agentic orchestrations, where LLMs autonomously determine the sequence of actions and maintain control over task execution. Between these two extremes lies what might be the most interesting space: one that balances reliability and flexibility. And since precisely defining that middle ground is challenging, why not give users the ability to shape it according to their specific needs?"
msgstr "实际上，代理模式的范围很广，从可靠、确定但僵化的工作流（代理遵循预定义的代码和流程路径），到灵活但不可预测的纯代理协调（LLM 自主决定行动顺序并保持对任务执行的控制）。在这两个极端之间，可能存在着最有趣的空间：一个兼顾可靠性和灵活性的空间。既然精确定义中间地带具有挑战性，为什么不赋予用户根据自己的具体需求塑造中间地带的能力呢？"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "A generic architecture for agentic AI patterns"
msgstr "代理人工智能模式的通用架构"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "The natural outcome of these reflections was the decision to design a generic architecture for agentic AI patterns: one flexible enough to support a wide variety of use cases, while still allowing these patterns to function as modular building blocks that can be seamlessly combined and complement one another."
msgstr "这些思考的自然结果就是决定为代理人工智能模式设计一个通用架构：一个足够灵活的架构，以支持各种各样的用例，同时还允许这些模式作为模块化构件发挥作用，可以无缝组合并相互补充。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "To ensure maximum flexibility, we needed to identify the simplest and most minimal abstraction capable of doing the job. This led us to realize that an agentic pattern, at its core, is the specification of an execution plan for the subagents it coordinates. Such a plan can be defined by implementing the following `Planner` interface:"
msgstr "为了确保最大限度的灵活性，我们需要找出能够完成这项工作的最简单、最小的抽象概念。这使我们认识到，代理模式的核心是为其协调的子代理指定一个执行计划。这种计划可以通过实现以下 `Planner` 接口来定义："

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "This interface, that still has to be considered experimental and could be enriched or modified in other ways with subsequent revisions, defines a method for initializing the planner, along with two methods responsible for determining the first action to execute and all subsequent ones. The method that returns the first action is optional; by default, it simply delegates to the method that returns the next action, which is the only one that must be implemented. The `Action` class returned by these methods represents the next step to be taken by the agentic pattern. It can either specify one or more subagents to be invoked next or signal that the execution has completed."
msgstr "该接口定义了一个用于初始化规划器的方法，以及两个负责确定第一个要执行的操作和所有后续操作的方法。返回第一个操作的方法是可选的，默认情况下，它只是委托给返回下一个操作的方法，这也是唯一必须执行的方法。这些方法返回的 `Action` 类代表了代理模式要执行的下一步操作。它既可以指定下一步要调用的一个或多个子代理，也可以发出执行已完成的信号。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "In essence, the architecture of the LangChain4j agentic framework can be seen as a two-layered system, where the planner layer is responsible for determining the sequence of agent invocations, while the execution layer handles the actual execution of these agents based on the planner's directives. Both layers are designed to be easily extensible, allowing users to implement custom planners and execution frameworks like Quarkus to adapt some runtime aspects, like the thread pool used to run the different agents, to its needs. The `AgenticScope` acts as the shared context between these two layers, maintaining the state of the entire agentic system throughout its execution."
msgstr "从本质上讲，LangChain4j 代理框架的架构可以看作是一个双层系统，其中规划层负责确定代理调用的顺序，而执行层则根据规划者的指令处理这些代理的实际执行。这两层的设计都很容易扩展，允许用户实施定制的规划器和执行框架（如 Quarkus），以适应运行时的某些方面，如用于运行不同代理的线程池。 `AgenticScope` 充当这两层之间的共享上下文，在整个执行过程中维护整个代理系统的状态。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "The planner and execution layers of the LangChain4j agentic architecture"
msgstr "LangChain4j 代理架构的规划层和执行层"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "All the built-in agentic patterns provided out of the box by the `langchain4j-agentic` module have been rewritten using this new `Planner` abstraction. The pull requests implementing this architecture have already been merged, and this article won’t go into much detail about their internals here, as you can find a full explanation in https://github.com/langchain4j/langchain4j/pull/3929[its description]."
msgstr "`langchain4j-agentic` 模块提供的所有内置代理模式都使用新的 `Planner` 抽象进行了重写。实现这一架构的拉取请求已被合并，本文将不再详细介绍其内部结构，因为您可以在 link:https://github.com/langchain4j/langchain4j/pull/3929[其描述] 中找到完整的解释。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "Another important aspect to consider is that this new architecture not only allows users to implement their own agentic patterns but also makes it easy to combine them with any other pattern, whether provided by LangChain4j or created by users themselves. Since all patterns are now defined in terms of a `Planner`, any pattern can serve as a subagent within another, opening the door to an almost infinite variety of combinations. The following example illustrates this concept in practice."
msgstr "另一个需要考虑的重要方面是，这种新架构不仅允许用户实现自己的代理模式，还可以轻松地将它们与任何其他模式相结合，无论是由LangChain4j提供的模式，还是用户自己创建的模式。由于现在所有模式都是通过 `Planner` 来定义的，因此任何模式都可以作为另一种模式的子代理，从而为几乎无限的组合打开了大门。下面的示例展示了这一概念的实际应用。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "Mixing multiple agentic patterns"
msgstr "混合多种代理模式"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "One of the examples included in the pull request mentioned earlier illustrates this new architecture by showing how to create a custom agentic pattern based on a goal-oriented strategy. This approach determines the sequence of agents to be invoked to accomplish a specific complex task."
msgstr "前面提到的拉取请求中包含的一个示例通过展示如何根据面向目标的策略创建自定义代理模式来说明这种新架构。这种方法确定了为完成特定复杂任务而调用的代理序列。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "To put this approach into practice, the entire agentic system must define a final goal, and each subagent must declare its own preconditions, the requirements needed to perform its task,  and postconditions, which describe the outcomes guaranteed once execution is complete. However, in agentic LangChain4j, all this information is already implicitly available: the preconditions and postconditions correspond to each agent’s required inputs and produced outputs, while the final goal represents the desired outputs of the entire agentic system."
msgstr "要将这种方法付诸实践，整个代理系统必须定义一个最终目标，而每个子代理必须声明自己的前置条件（执行任务所需的要求）和后置条件（描述执行完成后的保证结果）。然而，在代理式 LangChain4j 中，所有这些信息都已隐式提供：前置条件和后置条件对应于每个代理所需的输入和产生的输出，而最终目标则代表整个代理系统的预期输出。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "Following this idea, we can calculate a dependency graph of all the subagents participating in the agentic system. Based on that graph, it’s then possible to implement a `Planner` capable of analyzing the initial state of the `AgenticScope`, comparing it with the desired goal, and determining the sequence of agent invocations that can lead to achieving that goal."
msgstr "按照这一思路，我们可以计算出参与代理系统的所有子代理的依赖关系图。基于该图，我们就可以实现一个 `Planner` ，它能够分析 `AgenticScope` 的初始状态，将其与预期目标进行比较，并确定能够实现该目标的代理调用序列。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "As mentioned earlier, in this example, the goal corresponds to the final output of the planner-based agentic pattern itself. The path from the initial state to that goal is computed using a graph built by analyzing the input and output keys of all subagents. The sequence of agents to invoke is then determined as the shortest path on that graph, connecting the current state to the desired goal."
msgstr "如前所述，在本例中，目标对应于基于计划器的代理模式本身的最终输出。从初始状态到目标的路径是通过分析所有子代理的输入和输出键建立的图计算出来的。然后，根据图中连接当前状态和预期目标的最短路径，确定要调用的代理序列。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "The example discussed in the pull request to demonstrate this pattern in action is an agentic system that generates horoscope-based write-ups. The complete source code is available https://github.com/langchain4j/langchain4j/tree/main/langchain4j-agentic-patterns/src/test/java/dev/langchain4j/agentic/patterns/goap/horoscope[here]. This system is composed of several subagents, each responsible for a specific task, such as extracting user data from the prompt, fetching horoscope information from an external source, generating content based on that data, and formatting the final write-up. In this setup, the graph of agent dependencies, which also determines the sequence of their activations, is as follows:"
msgstr "拉取请求中讨论的用于演示这种模式的示例是一个代理系统，它可以生成基于星座的文章。完整的源代码可在 link:https://github.com/langchain4j/langchain4j/tree/main/langchain4j-agentic-patterns/src/test/java/dev/langchain4j/agentic/patterns/goap/horoscope[此处] 获取。该系统由多个子代理组成，每个子代理负责一项特定任务，例如从提示中提取用户数据、从外部来源获取星座信息、根据这些数据生成内容，以及格式化最终的文章。在这种情况下，代理依赖关系图（也决定了它们的激活顺序）如下："

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "The GOAP-determined sequence of agents invocation to generate an horoscope-based writeup"
msgstr "为生成基于星座的文章而调用代理的 GOAP 确定的顺序"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "The primary advantage of this goal-oriented strategy is that it deterministically identifies the shortest sequence of steps necessary to transition from the initial state to the final goal. However, in some cases, a sequence of agent invocations calculated purely along the optimal path in the dependency graph can become a limitation. For instance, by definition, a shortest path contains no loops, yet in practice, a loop may be necessary to allow an agent to reflect on its own work and iteratively refine its output."
msgstr "这种以目标为导向的策略的主要优势在于，它能确定从初始状态过渡到最终目标所需的最短步骤序列。不过，在某些情况下，纯粹沿着依赖关系图中的最优路径计算的代理调用序列可能会受到限制。例如，根据定义，最短路径不包含循环，但在实际操作中，可能需要一个循环来让代理反思自己的工作并迭代改进其输出。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "As mentioned earlier, the LangChain4j agentic framework overcomes this limitation by allowing seamless integration of the goal-oriented system with any other agentic pattern, whether provided by the framework or custom-built. For example, the final agent responsible for generating the write-up could be complemented by a reflection loop, using another agent that evaluates and scores the generated content."
msgstr "如前所述，LangChain4j 代理框架克服了这一限制，允许将目标导向系统与任何其他代理模式（无论是框架提供的还是客户定制的）进行无缝集成。例如，负责生成文章的最终代理可以辅以一个反射循环，使用另一个代理对生成的内容进行评估和评分。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "In this setup, the single `Writer` agent can be replaced by a reflection loop, allowing the final agentic system to overcome one of the typical limitations of the goal-oriented strategy. The resulting system can then be defined as follows:"
msgstr "在这种情况下， `Writer` ，单个代理可由一个反射回路取代，从而使最终的代理系统克服了目标导向策略的一个典型局限。由此产生的系统可定义如下："

#: _posts/2025-11-12-agentic-ai-patterns.adoc
msgid "Conclusion"
msgstr "解决方案"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "An agentic system composed of multiple small, specialized agents can often outperform a single large language model–based AI service, and do so at a fraction of the cost. However, using many interoperating agents introduces the challenge of coordinating them effectively to accomplish complex tasks. Different agentic patterns present distinct trade-offs between reliability and flexibility, and no single approach is suitable for all scenarios. This is why a customizable architecture that enables users to define and combine diverse agentic patterns is essential for building truly adaptable AI systems."
msgstr "由多个小型专业代理组成的代理系统，其性能往往优于基于语言模型的单一大型人工智能服务，而且成本仅为后者的一小部分。然而，使用多个互操作代理会带来如何有效协调它们以完成复杂任务的挑战。不同的代理模式会在可靠性和灵活性之间做出不同的权衡，没有一种方法适合所有场景。这就是为什么要建立真正适应性强的人工智能系统，就必须要有一个可定制的架构，让用户能够定义和组合不同的代理模式。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "By introducing a generic `Planner` interface, LangChain4j empowers users to design their own agentic patterns and seamlessly integrate them with existing ones. This flexibility enables the creation of sophisticated, purpose-driven agentic systems that balance the strengths of different orchestration strategies to meet specific needs."
msgstr "通过引入通用的 `Planner` 界面，LangChain4j 使用户能够设计自己的代理模式，并将其与现有模式无缝集成。这种灵活性使用户能够创建复杂的、目的驱动的代理系统，平衡不同协调策略的优势，以满足特定需求。"

#: _posts/2025-11-12-agentic-ai-patterns.adoc
#, fuzzy
msgid "This also opens the door for users to contribute to the LangChain4j agentic ecosystem by sharing their own `Planner` implementations. To support this, a https://github.com/langchain4j/langchain4j/tree/main/langchain4j-agentic-patterns[new dedicated module], named langchain4j-agentic-patterns, has been added to the LangChain4j project. Its goal is to collect and maintain a growing set of reusable agentic patterns that can serve as building blocks for creating complex, robust agentic systems."
msgstr "这也为用户通过分享自己的 `Planner` 实现为 LangChain4j 代理生态系统做出贡献打开了大门。为此，LangChain4j 项目新增了一个名为 langchain4j-agentic-patterns 的 link:https://github.com/langchain4j/langchain4j/tree/main/langchain4j-agentic-patterns[专用模块] 。该模块的目标是收集和维护不断增加的可重复使用的代理模式，这些模式可以作为创建复杂、健壮的代理系统的构建模块。"
