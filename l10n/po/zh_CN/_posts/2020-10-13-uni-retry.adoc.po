# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-10-13-uni-retry.adoc:1
#, fuzzy, no-wrap
msgid "cescoffier"
msgstr "鹤壁市"

#. type: YAML Front Matter: date
#: upstream/_posts/2020-10-13-uni-retry.adoc:1
#, fuzzy, no-wrap
msgid "2020-10-13"
msgstr "2020-10-13"

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-10-13-uni-retry.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "职位"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-10-13-uni-retry.adoc:1
#, fuzzy, no-wrap
msgid "How does `retry` actually work?"
msgstr " `retry` 实际上是如何工作的？"

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-10-13-uni-retry.adoc:1
#, fuzzy, no-wrap
msgid "reactive mutiny retry"
msgstr "反应式叛变重试"

#. type: YAML Front Matter: title
#: upstream/_posts/2020-10-13-uni-retry.adoc:1
#, fuzzy, no-wrap
msgid "Mutiny - How does retry... retries?"
msgstr "叛变--重试......如何重试？"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:17
#, fuzzy
msgid "Last week, David, a Quarkus user, asked me about retrying an asynchronous operation.  David has a _picky_ remote HTTP service, which sometimes misbehaves.  Easy answer! Just do: `uni.onFailure().retry().atMost(x)`.  But, David is curious, and asked me a second question: how does retry work? Well, that’s simple; it just retries...  As you can imagine, that did not satisfy David’s curiosity."
msgstr "上周，Quarkus用户David问我关于重试一个异步操作的问题。David有一个 _挑剔的_ 远程HTTP服务，它有时会表现不佳。答案很简单!只要做： `uni.onFailure().retry().atMost(x)` 。但是，David很好奇，他问了我第二个问题：重试是如何进行的？嗯，这很简单；它只是重试......你可以想象，这并没有满足大卫的好奇心。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:20
#, fuzzy
msgid "While I was answering to David, I realized that retrying is not that simple and deserves more explanation.  That’s what we are going to see in this blog post."
msgstr "在我回答David的时候，我意识到重试并不那么简单，应该有更多的解释。这就是我们将在这篇博文中看到的内容。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:22
#, fuzzy
msgid "## Disclaimer about retries"
msgstr "关于重试的声明\n"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:29
#, fuzzy
msgid "Okay, if you are the kind of reader who skips the terms and conditions, you can jump to the next section.  But, for others, I need to warn you about retries.  Retries may not be the solution to your problem, as it can be terrible.  Retrying can only be done if your system can handle duplicated requests or messages.  In other words, you can only retry if your system is idempotent, i.e., sending a request or a message multiple times does not change the overall state.  In doubt, check before implementing a retry, as it can harm your system."
msgstr "好吧，如果你是那种会跳过条款和条件的读者，你可以跳到下一节。但是，对于其他人，我需要警告你关于重试的问题。重试可能不是解决你问题的办法，因为它可能很糟糕。只有当你的系统能够处理重复的请求或信息时，才能进行重试。换句话说，只有当你的系统是空闲的，也就是说，多次发送请求或消息不会改变整体状态时，你才能重试。如有疑问，请在实施重试前检查，因为它可能会损害你的系统。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:31
#, fuzzy
msgid "Disclaimer said! Let’s look under the hood of retry."
msgstr "免责声明说!让我们来看看重试的引擎盖下。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:33
#, fuzzy
msgid "## Retry is about resubscribing"
msgstr "重试是关于重新订阅的问题\n"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:35
#, fuzzy
msgid "Let’s imagine you have a `Uni` representing your asynchronous action, like in David’s case, an invocation of a remote service:"
msgstr "让我们想象一下，你有一个 `Uni` ，代表你的异步操作，比如在David的案例中，是对一个远程服务的调用。"

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:39
#, no-wrap
msgid "Uni<String> uni = invokePickyService(client);\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:45
#, fuzzy
msgid "Unis are lazy.  Until someone subscribes to them, nothing happens.  In our case, the request is only sent to the remote service when someone subscribes to the `uni`.  So to execute the request, we need to subscribe:"
msgstr "大学是懒惰的。在有人订阅它们之前，什么都不会发生。在我们的例子中，只有当有人订阅了 `uni` ，请求才会被发送到远程服务。所以要执行请求，我们需要订阅。"

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:53
#, no-wrap
msgid ""
"Uni<String> uni = invokePickyService(client);\n"
"uni.subscribe().with(\n"
"    resp -> System.out.println(\"Success: \" + resp),\n"
"    failure -> System.out.println(\"Failed: \" + failure.getMessage())\n"
");\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:57
#, fuzzy
msgid "In Quarkus, most of the time, you return the `Uni`, and Quarkus subscribes to it.  So, don't be mistaken, there is a subscription, you may not see it."
msgstr "在Quarkus中，大多数时候，你返回 `Uni` ，Quarkus就会订阅它。所以，不要搞错了，有一个订阅，你可能看不到它。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:60
#, fuzzy
msgid "This laziness is the retry secret.  In the following sequence diagram, you can see that the request is sent when we get a subscriber:"
msgstr "这种懒惰是重试的秘密。在下面的顺序图中，你可以看到，当我们得到一个用户时，就会发送请求。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:62
#, fuzzy
msgid "image:/assets/images/posts/mutiny-retry/subscription.png[]"
msgstr "image:/assets/images/posts/mutiny-retry/subscription.png[alt=\"subscription\"]"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:65
#, fuzzy
msgid "An interesting consequence of this is that if you subscribe twice, you emit two requests, and so get two responses:"
msgstr "一个有趣的结果是，如果你订阅了两次，你就会发出两个请求，因此得到两个回应。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:67
#, fuzzy
msgid "image:/assets/images/posts/mutiny-retry/double-subscription.png[]"
msgstr "image:/assets/images/posts/mutiny-retry/double-subscription.png[alt=\"double subscription\"]"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:72
#, fuzzy
msgid "But let’s go back to retry.  What’s a retry? A retry is a reaction to a failure, so you are going to write: `uni.onFailure().retry()`.  You also need to indicate how long do you want to retry:"
msgstr "但让我们回到重试的问题。什么是重试？重试是对失败的一种反应，所以你要写： `uni.onFailure().retry()` 。你还需要指出你要重试多长时间。"

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:80
#, no-wrap
msgid ""
"Uni<String> uni = invokePickyService(client)\n"
"    .onFailure().retry().indefinitely();\n"
"uni.subscribe().with(\n"
"        resp -> System.out.println(\"Success: \" + resp)\n"
");\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:83
#, fuzzy
msgid "In this snippet, we retry _indefinitely_ until we get a successful result."
msgstr "在这个片段中，我们 _无限期_ 地重试，直到得到一个成功的结果。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:87
#, fuzzy
msgid "But, how does it work under the hood? It’s quite simple.  If it gets a failure, it just re-subscribes:"
msgstr "但是，它是如何在引擎盖下工作的呢？这很简单。如果它得到一个失败，它只是重新订阅。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:89
#, fuzzy
msgid "image:/assets/images/posts/mutiny-retry/retry.png[]"
msgstr "image:/assets/images/posts/mutiny-retry/retry.png[alt=\"retry\"]"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:92
#, fuzzy
msgid "It resubscribes until it gets a successful response.  In other words, retrying is resubscribing."
msgstr "它重新订阅，直到它得到一个成功的回应。换句话说，重试就是重新订阅。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:94
#, fuzzy
msgid "## How many times should I retry?"
msgstr "我应该重试多少次？\n"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:99
#, fuzzy
msgid "That’s always a good question.  Should I retry _indefinitely_? Most probably, not.  Indefinitely can be very long, and it could never end if the called service fails continuously."
msgstr "这一直是个好问题。我应该 _无限期_ 地重试吗？最有可能的是，不应该。无限期可能很长，而且如果被调用的服务连续失败，它可能永远不会结束。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:101
#, fuzzy
msgid "You can configure the number of retries using `atMost`:"
msgstr "你可以使用 `atMost` ，配置重试的次数。"

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:111
#, no-wrap
msgid ""
" Uni<String> uni = invokePickyService(client)\n"
"    .onFailure().retry().atMost(2);\n"
"uni.subscribe().with(\n"
"        resp -> System.out.println(\"Success: \" + resp),\n"
"        failure -> System.out.println(\"Failure: \" + failure.getMessage())\n"
");\n"
"----        \n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:114
#, no-wrap
msgid ""
"`atMost` indicates that at most `n` attempts will be done before failing.\n"
"If we still get a failure after that number of resubscription, the last failure is sent to the subscriber.\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:116
#, no-wrap
msgid "image:/assets/images/posts/mutiny-retry/retry-failed.png[]\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:118
#, no-wrap
msgid "You can also use `until` and decide to retry by looking at the received failure:\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:120
#: upstream/_posts/2020-10-13-uni-retry.adoc:139
#, no-wrap
msgid "[source, java]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:123
#, fuzzy, no-wrap
msgid ""
"Uni<String> uni = invokePickyService(client)\n"
"    .onFailure().retry().until(failure -> ! (failure instanceof TooManyRequestsException));\n"
msgstr "Uni<String> uni = invokePickyService(client) .onFailure().retry().until(failure → !(failure instanceof TooManyRequestsException))。"

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:126
#, no-wrap
msgid "## Bonus: Exponential backoff\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:131
#, no-wrap
msgid ""
"So far, our retries happen immediately.\n"
"It might not be very wise, and separating a bit our retries may give better results, especially when facing intermittent failures due to the load or other external causes.\n"
"Using exponential backoff provides a reasonable tradeoff.\n"
"Retrying with exponential backoff:\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:137
#, no-wrap
msgid ""
"* retries after an initial delay,\n"
"* on every failure, it doubles the previous delay, with an optional maximum,\n"
"* it can use a jitter to add a random duration to the delay,\n"
"* it can have a max delay if needed,\n"
"* it is still constrained by `atMost` \n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:143
#, fuzzy, no-wrap
msgid ""
"Uni<String> uni = invokePickyService(client)\n"
"    .onFailure().retry()\n"
"        .withBackOff(Duration.ofSeconds(1)).withJitter(0.2).atMost(10);\n"
msgstr "Uni<String> uni = invokePickyService(client) .onFailure().retry() .withBackOff(Duration.ofSeconds(1)) .withJitter(0.2).atMost(10);"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:144
#, fuzzy, no-wrap
msgid "\n"
msgstr "\n"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:149
#, fuzzy
msgid "This last snippet configures the retry with exponential backoff.  The first retry happens after 1 second, and then it doubles every time without an upper limit.  Random jitter is applied to delays.  If, unfortunately, after ten attempts, it still fails, the failure is sent to the subscriber."
msgstr "这最后一个片段配置了指数退避的重试。第一次重试发生在1秒之后，然后每次重试都会加倍，没有上限。随机抖动被应用于延迟。如果不幸的是，在十次尝试之后，仍然失败，那么失败的信息将被发送给用户。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:151
#, fuzzy
msgid "## Demo time!"
msgstr "演示时间!\n"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:155
#, fuzzy
msgid "Ok, enough talking.  I’ve built a simple playground where you can adjust and try the various retry policies: https://gist.github.com/cescoffier/e9abce907a1c3d05d70bea3dae6dc3d5.  You can _jbang_ the script by downloading it and running `jbang Retry.java`, or just run:"
msgstr "好了，不说了。我建立了一个简单的游乐场，你可以在那里调整和尝试各种重试政策 https://gist.github.com/cescoffier/e9abce907a1c3d05d70bea3dae6dc3d5 你可以通过下载该脚本并运行 `jbang Retry.java` ，或者直接运行。"

#. type: delimited block -
#: upstream/_posts/2020-10-13-uni-retry.adoc:159
#, no-wrap
msgid "jbang https://gist.github.com/cescoffier/e9abce907a1c3d05d70bea3dae6dc3d5\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:162
#, fuzzy
msgid "The called service fails 50% of the time (well, it uses a random, so statistically 50% of the time)."
msgstr "被调用的服务有50%的时间是失败的（好吧，它使用的是随机的，所以统计上有50%的时间）。"

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:169
msgid "That concludes this blog post.  Again, before using retry, please verify that your system can support it.  Retrying is resubscribing.  You can configure how long, how many times, and when retrying should be attempted.  There are many more options offered by Mutiny, like `when` or using deadlines (`expireIn` and `expireAt`) when using exponential backoff.  You can try all these with the provided playground."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-13-uni-retry.adoc:170
msgid "Stay tuned! We have plenty of other gems to discuss here!"
msgstr ""
