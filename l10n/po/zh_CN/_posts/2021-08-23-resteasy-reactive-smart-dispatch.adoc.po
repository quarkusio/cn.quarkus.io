# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:1
#, fuzzy, no-wrap
msgid "cescoffier"
msgstr "鹤壁市"

#. type: YAML Front Matter: date
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:1
#, fuzzy, no-wrap
msgid "2021-08-25"
msgstr "2021-08-25"

#. type: YAML Front Matter: layout
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "职位"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:1
#, fuzzy, no-wrap
msgid "Quarkus 2.2 includes a new dispatching strategy to make RESTEasy Reactive even better."
msgstr "Quarkus 2.2包括一个新的调度策略，使RESTEasy Reactive更加出色。"

#. type: YAML Front Matter: tags
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:1
#, fuzzy, no-wrap
msgid "reactive rest"
msgstr "反应性休息"

#. type: YAML Front Matter: title
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:1
#, fuzzy, no-wrap
msgid "RESTEasy Reactive - To block or not to block"
msgstr "RESTEasy 反应性 - 阻止或不阻止"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:14
#, fuzzy
msgid "In January 2021, the Quarkus team announced RESTEasy Reactive, a novel way to serve HTTP API in Quarkus.  Since its introduction, RESTEasy Reactive adoption has been quite good, and we plan to make it the default approach to implement HTTP API shortly."
msgstr "2021年1月，Quarkus团队发布了RESTEasy Reactive，这是一种在Quarkus中提供HTTP API的新方法。自推出以来，RESTEasy Reactive的采用情况相当不错，我们计划不久后将其作为实现HTTP API的默认方法。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:17
#, fuzzy
msgid "But, wait a minute, what does that mean for my imperative APIs? Do I need to learn reactive programming to use Quarkus now? Let's be clear: **no**.  This blog post will look at a few changes we made in RESTEasy reactive to make the transition smooth and transparent."
msgstr "但是，等一下，这对我的命令式API意味着什么？我现在需要学习反应式编程来使用Quarkus吗？让我们把话说清楚： *不* 。这篇博文将介绍我们在RESTEasy reactive中做出的一些改变，以使过渡顺利而透明。"

#. type: Title ==
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:18
#, fuzzy, no-wrap
msgid "A brief history of HTTP APIs in Quarkus"
msgstr "Quarkus中HTTP APIs的简史"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:23
#, fuzzy
msgid "Quarkus has, since its genesis, has been able to serve HTTP API. The inclusion of https://resteasy.github.io/[RESTEasy] has been a major milestone of the first Quarkus beta releases.  With RESTEasy _classic_, you develop HTTP APIs using the well-known JAX-RS annotations such as `@GET`, `@Path`, `@POST`...  The following snippet shows a short _hello world_ example:"
msgstr "Quarkus自诞生以来，一直能够为HTTP API提供服务。纳入 link:https://resteasy.github.io/[RESTEasy] 是Quarkus第一批测试版的一个重要里程碑。使用RESTEasy _classic_ ，你可以使用著名的JAX-RS注解来开发HTTP API，如 `@GET` , `@Path` , `@POST` ...下面的片段显示了一个简短的 _hello world_ 例子。"

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:27
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:126
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:192
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:217
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:245
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:271
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:300
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:30
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:129
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:174
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:197
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:223
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:33
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:132
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:177
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:39
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:138
#, no-wrap
msgid ""
"   @GET\n"
"   public String hello() {\n"
"       return \"Hello\";\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:44
#, fuzzy
msgid "RESTEasy _classic_ invokes the HTTP endpoint (the `hello` method in the previous snippet) on a worker thread associated with the HTTP request.  It is a well-understood model, simple to understand.  However, relying on worker threads introduces a concurrency limit: the number of threads."
msgstr "RESTEasy _经典版_ 在一个与HTTP请求相关的工作线程上调用HTTP端点（即前面片段中的 `hello` 方法）。这是一个广为人知的模型，简单易懂。然而，依靠工人线程会引入一个并发限制：线程的数量。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:49
#, fuzzy
msgid "Even with the infusion of reactive at the core of Quarkus, RESTEasy _classic_ kept this dispatching strategy.  It was fragmenting the Quarkus ecosystem. On one side, we had the the imperative camp using RESTEasy _classic_, Hibernate ORM...  On the other side, we had the reactive camp using Reactive Routes, Vert.x APIs and other reactive extensions.  Both were using, under the hood, the reactive engine of Quarkus, but the reactive camp we using it in a more efficient way."
msgstr "即使在Quarkus的核心部分注入了反应式，RESTEasy _的经典之作_ 仍然保留了这种调度策略。这使得Quarkus的生态系统变得支离破碎。一边是使用RESTEasy _classic_ 、Hibernate ORM的命令式阵营。在另一边，我们有使用Reactive Routes、Vert.x APIs和其他反应式扩展的反应式阵营。两者都在使用Quarkus的反应式引擎，但反应式阵营以一种更有效的方式使用它。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:54
#, fuzzy
msgid "Following the unification of imperative and reactive idea, in Quarkus 1.11, we introduced RESTEasy _reactive_, a novel implementation of the JAX-RS model on top of the Quarkus reactive architecture.  It offers a similar development model and much better throughput.  I won't detail the RESTEasy _reactive_ architecture and benefits.  Georgios covered them in two posts: https://quarkus.io/blog/resteasy-reactive/[RESTEasy Reactive introduction] and https://quarkus.io/blog/resteasy-reactive-faq/[Massive performance without headaches]."
msgstr "在Quarkus 1.11中，我们引入了RESTEasy _reactive_ ，这是在Quarkus反应式架构之上对JAX-RS模型的一种新的实现，遵循了命令式和反应式的统一思想。它提供了一个类似的开发模型和更好的吞吐量。我不会详述RESTEasy _反应式_ 的架构和优点。Georgios在两篇文章中介绍了它们。 link:https://quarkus.io/blog/resteasy-reactive/[RESTEasy Reactive介绍] 》和《 link:https://quarkus.io/blog/resteasy-reactive-faq/[无需头痛的大规模性能] 》。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:56
#, fuzzy
msgid "From the user point of view, the main difference between RESTEasy _classic_ and _reactive_ is how they call the HTTP endpoint methods:"
msgstr "从用户的角度看，RESTEasy _经典_ 和 _反应式_ 的主要区别在于它们如何调用HTTP端点方法。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:58
#, fuzzy
msgid "_classic_ - always on a worker thread,"
msgstr " _经典_ --总是在一个工人线程上。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:59
#, fuzzy
msgid "_reactive_ - on the I/O thread or on a worker thread (and you, as the developer, have the choice)"
msgstr " _反应式_ --在I/O线程或工作线程上（而你，作为开发者，可以选择）。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:64
#, fuzzy
msgid "You may wonder why it's so important.  Threads are expensive, especially in containers or on the cloud where the resources are limited.  Using the I/O threads avoids creating additional threads (improving memory consumption) and avoids context switches (improving response time).  Emmanuel explained the benefits in the https://quarkus.io/blog/io-thread-benchmark/[A IO thread and a worker thread walk into a bar: a microbenchmark story] blog post."
msgstr "你可能想知道为什么它如此重要。线程是很昂贵的，尤其是在资源有限的容器或云上。使用I/O线程可以避免创建额外的线程（改善内存消耗）并避免上下文切换（改善响应时间）。Emmanuel在《 link:https://quarkus.io/blog/io-thread-benchmark/[一个IO线程和一个工作线程走进一个酒吧：一个微基准的故事] 》博文中解释了这些好处。"

#. type: Title ==
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:65
#, fuzzy, no-wrap
msgid "To block or not to block, that is the question."
msgstr "阻止或不阻止，这是一个问题。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:69
#, fuzzy
msgid "When we introduced RESTEasy _reactive_, we decided to use a non-blocking approach by default: if not stated otherwise, it calls the HTTP endpoint method on the I/O thread.  This model resulted in outstanding performance and was simple enough, thanks to the usage of the `@Blocking` annotation."
msgstr "当我们引入RESTEasy _反应式_ 时，我们决定默认使用非阻塞的方法：如果没有另外说明，它在I/O线程上调用HTTP端点方法。由于使用了 `@Blocking` 注释，这种模式带来了出色的性能，而且足够简单。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:73
#, fuzzy
msgid "In the last few months, the adoption of RESTEasy _reactive_ has been incredible! We have received many questions and, obviously, bug reports.  The central question is about the usage of Hibernate ORM."
msgstr "在过去的几个月里，RESTEasy _反应式_ 的采用情况令人难以置信!我们收到了许多问题，显然还有错误报告。核心问题是关于Hibernate ORM的使用。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:76
#, fuzzy
msgid "As Hibernate ORM _classic_ (we also have Hibernate _reactive_) is blocking, you can't use it with RESTEasy _reactive_ without using the `@Blocking` annotation.  This annotation changes the dispatching strategy to use a worker thread (instead of the I/O thread)."
msgstr "由于Hibernate ORM _classic_ （我们也有Hibernate _reactive_ ）是阻塞式的，如果不使用 `@Blocking` 注解，就不能在RESTEasy _reactive_ 中使用它。这个注解改变了调度策略，使用一个工作线程（而不是I/O线程）。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:78
#, fuzzy
msgid "While the resulting model looked efficient and straightforward for us, non-aware users have seen a lot of:"
msgstr "虽然所产生的模型对我们来说看起来很高效、很直接，但没有意识到的用户已经看到了很多。"

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:82
#, no-wrap
msgid "You have attempted to perform a blocking operation on a IO thread. This is not allowed, as blocking the IO thread will cause major performance issues with your application. If you want to perform blocking EntityManager operations make sure you are doing it from a worker thread.: java.lang.IllegalStateException: You have attempted to perform a blocking operation on a IO thread. This is not allowed, as blocking the IO thread will cause major performance issues with your application. If you want to perform blocking EntityManager operations make sure you are doing it from a worker thread.\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:86
#, fuzzy
msgid "The error message is explicit.  But, it rarely makes us happy when we have such a wall of text printed in our terminal."
msgstr "该错误信息是明确的。但是，当我们的终端上印有这样一堵文字墙时，很少会让我们感到高兴。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:90
#, fuzzy
msgid "You may say... “well, let's do blocking by default.” It's not that simple.  It's as dangerous to call reactive APIs expected to be called on an I/O thread on a worker thread than calling blocking APIs on the I/O thread."
msgstr "你可能会说...... \"好吧，让我们默认做阻断\"。其实没那么简单。在工作线程上调用预计在I/O线程上调用的反应式API，和在I/O线程上调用阻塞式API一样危险。"

#. type: Title ==
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:91
#, fuzzy, no-wrap
msgid "New world, new rules! "
msgstr "新世界，新规则!"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:95
#, fuzzy
msgid "In Quarkus 2.2.0, we introduced a new dispatching strategy based on the method signatures.  The Quarkus build-time approach lets us be wise and deduce if a method should be called on the I/O thread or a worker thread at build time, reducing the runtime overhead."
msgstr "在Quarkus 2.2.0中，我们引入了一种基于方法签名的新调度策略。Quarkus构建时的方法让我们明智地推断出一个方法在构建时应该在I/O线程还是工作线程上调用，从而减少运行时的开销。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:97
#, fuzzy
msgid "The following table summarizes the new set of rules:"
msgstr "下表总结了这套新规则。"

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:100
#, fuzzy, no-wrap
msgid "Method signature"
msgstr "方法签名"

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:102
#, fuzzy, no-wrap
msgid "Dispatching strategy"
msgstr "调度策略"

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:102
#, fuzzy, no-wrap
msgid "`T method(...)`"
msgstr " `T method(…​)` "

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:103
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:108
#, fuzzy, no-wrap
msgid "Worker thread"
msgstr "工作者线程"

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:103
#, fuzzy, no-wrap
msgid "`Uni<T> method(...)`"
msgstr " `Uni<T> method(…​)` "

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:104
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:105
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:106
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:107
#, fuzzy, no-wrap
msgid "I/O thread"
msgstr "I/O线程"

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:104
#, fuzzy, no-wrap
msgid "`CompletionStage<T> method(...)`"
msgstr " `CompletionStage<T> method(…​)` "

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:105
#, fuzzy, no-wrap
msgid "`Multi<T> method(...)`"
msgstr " `Multi<T> method(…​)` "

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:106
#, fuzzy, no-wrap
msgid "`Publisher<T> method(...)`"
msgstr " `Publisher<T> method(…​)` "

#. type: Table
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:107
#, fuzzy, no-wrap
msgid "`@Transactional CompletionStage<T>  method(...)`"
msgstr " `@Transactional CompletionStage<T> method(…​)` "

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:113
#, fuzzy
msgid "Basically: _synchronous methods default to worker threads, and asynchronous methods default to I/O threads, except if explicitly stated otherwise_.  Of course, you can override the behavior using the `@Blocking` and `@NonBlocking` annotations.  The `@Transactional` annotation is an exception to the default rules as it often means you are accessing blocking resources (such as an entity manager)."
msgstr "基本上： _同步方法默认为工作线程，而异步方法默认为I/O线程，除非另有明确说明_ 。当然，你可以使用 `@Blocking` 和 `@NonBlocking` 注解来覆盖这种行为。 `@Transactional` 注解是默认规则的一个例外，因为它通常意味着你正在访问阻塞资源（如实体管理器）。"

#. type: Title ==
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:114
#, fuzzy, no-wrap
msgid "What does that change for you? "
msgstr "这对你来说有什么变化？"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:117
#, fuzzy
msgid "Let’s discuss a few examples explaining how this new strategy improves the user experience without limiting efficiency and flexibility."
msgstr "让我们讨论几个例子，解释一下这个新策略如何在不限制效率和灵活性的情况下改善用户体验。"

#. type: Title ===
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:119
#, fuzzy, no-wrap
msgid "Hello RESTEasy Reactive"
msgstr "你好，RESTEasy Reactive"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:122
#, fuzzy
msgid "Using RESTEasy _reactive_ does not change the _hello_ example from above:"
msgstr "使用RESTEasy _reactive_ 并不改变上面的 _Hello_ 例子。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:124
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:145
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:190
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:215
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:243
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:269
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:298
#, fuzzy, no-wrap
msgid "[source, java]    \n"
msgstr "[source, java]    \n"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:143
#, fuzzy
msgid "That method is invoked on a worker thread because it has a synchronous signature.  Previously (before Quarkus 2.2), with RESTEasy _reactive_, it would have been called on the I/O thread.  To switch back to that behavior, add `@NonBlocking`:"
msgstr "该方法是在一个工作线程上调用的，因为它有一个同步签名。以前（在Quarkus 2.2之前），在RESTEasy _反应式_ 下，它是在I/O线程上被调用的。要切换回这种行为，可以添加 `@NonBlocking` 。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:147
#, fuzzy, no-wrap
msgid ""
"\n"
"package org.acme;\n"
msgstr "软件包 org.acme.com"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:149
#, fuzzy
msgid "import io.smallrye.common.annotation.NonBlocking;"
msgstr "import io.smallrye.common.annotation.NonBlocking.Annotation。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:152
#, fuzzy
msgid "import javax.ws.rs.GET; import javax.ws.rs.Path;"
msgstr "import javax.ws.rs.GET; import javax.ws.rs.Path。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:155
#, fuzzy
msgid "@Path(\"/hello\")  public class GreetingResource {"
msgstr "@Path(\"/hello\") public class GreetingResource {"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:162
#, fuzzy, no-wrap
msgid ""
"   @GET\n"
"   @NonBlocking\n"
"   public String hello() {\n"
"       return \"Hello\";\n"
"   }\n"
"}\n"
msgstr ""
"   @GET\n"
"   @NonBlocking\n"
"   public String hello() {\n"
"       返回 \"Hello\"。\n"
"   }\n"
"}"

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:165
#, no-wrap
msgid "Alternatively, you can return a `Uni`:    \n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:169
#, no-wrap
msgid ""
"[source, java]    \n"
"----    \n"
"package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:171
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:183
#, no-wrap
msgid ""
"   @GET\n"
"   public Uni<String> hello() {\n"
"       return Uni.createFrom().item(\"Hello\");\n"
"   }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:185
#, fuzzy, no-wrap
msgid "Integrating with Hibernate ORM"
msgstr "与Hibernate ORM集成"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:188
#, fuzzy
msgid "Following the feedback from users, let’s imagine you want to use Hibernate _classic_ with RESTEasy _reactive_:"
msgstr "根据用户的反馈，让我们设想一下，你想把Hibernate _经典_ 与RESTEasy _反应式_ 一起使用。"

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:194
#, no-wrap
msgid "import org.jboss.resteasy.reactive.RestQuery;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:200
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:226
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:255
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:281
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:311
#, no-wrap
msgid ""
"@Path(\"/fruit\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:206
#, no-wrap
msgid ""
"   @GET\n"
"   public Fruit getFruit(@RestQuery String name) {\n"
"       return Fruit.find(\"name\", name).firstResult();\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:209
#, fuzzy
msgid "You don't need to use `@Blocking` as the signature is synchronous. No more wall of text!"
msgstr "你不需要使用 `@Blocking` ，因为签名是同步的。不再有文字墙!"

#. type: Title ===
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:210
#, fuzzy, no-wrap
msgid "Integrating with Hibernate Reactive"
msgstr "与Hibernate Reactive的整合"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:213
#, fuzzy
msgid "If you use Hibernate _reactive_, you will use the Mutiny API, and so the resulting code will be:"
msgstr "如果你使用Hibernate _反应式_ ，你将使用Mutiny API，因此产生的代码将是。"

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:220
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import org.jboss.resteasy.reactive.RestQuery;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:232
#, no-wrap
msgid ""
"   @GET\n"
"   public Uni<Fruit> getFruit(@RestQuery String name) {\n"
"       return Fruit.find(\"name\", name).firstResult();\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:235
#, fuzzy
msgid "This method runs on the I/O thread, which is what Hibernate _reactive_ expects."
msgstr "这个方法在I/O线程上运行，这也是Hibernate _反应式_ 所期望的。"

#. type: Title ===
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:236
#, fuzzy, no-wrap
msgid "Integrating with Kafka"
msgstr "与Kafka集成"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:241
#, fuzzy
msgid "If you combine HTTP and Kafka (using reactive messaging), you will use an emitter.  Depending on the emitter type (`Emitter` or `MutinyEmitter`), the `send` method returns a `CompletionStage` or a `Uni`.  So, the following HTTP method runs on the I/O thread:"
msgstr "如果你把HTTP和Kafka结合起来（使用反应式消息传递），你将使用一个发射器。根据发射器的类型（ `Emitter` 或 `MutinyEmitter` ）， `send` 方法会返回一个 `CompletionStage` 或 `Uni` 。因此，下面的HTTP方法在I/O线程上运行。"

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:249
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:304
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.MutinyEmitter;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:252
#, no-wrap
msgid ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:258
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:284
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:314
#, no-wrap
msgid ""
"   @Channel(\"kafka\")\n"
"   MutinyEmitter<Fruit> emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:264
#, no-wrap
msgid ""
"   @POST\n"
"   public Uni<Void> writeToKafka(Fruit fruit) {\n"
"       return emitter.send(fruit);\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:267
#, fuzzy
msgid "If you change it to a synchronous signature, it runs on a worker thread:"
msgstr "如果你把它改为同步签名，它就会在一个工作线程上运行。"

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:274
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.MutinyEmitter;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:278
#, no-wrap
msgid ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import java.time.Duration;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:291
#, no-wrap
msgid ""
"   @POST\n"
"   public void writeToKafka(Fruit fruit) {\n"
"       System.out.println(Thread.currentThread().getName());\n"
"       emitter.send(fruit).await().atMost(Duration.ofSeconds(5));\n"
"   }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:293
#, fuzzy, no-wrap
msgid "Combining RESTEasy Reactive, Hibernate ORM and Kafka"
msgstr "结合RESTEasy Reactive、Hibernate ORM和Kafka"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:296
#, fuzzy
msgid "Let's now combine Resteasy _reactive_, Hibernate ORM _classic_ and Kafka to persist an entity and write it to a Kafka topic:"
msgstr "现在让我们结合Resteasy _reactive_ 、Hibernate ORM _classic_ 和Kafka来持久化一个实体并将其写入Kafka主题。"

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:308
#, no-wrap
msgid ""
"import javax.transaction.Transactional;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:323
#, no-wrap
msgid ""
"   @POST\n"
"   @Transactional\n"
"   public Uni<Void> persistAndWriteToKafka(Fruit fruit) {\n"
"       System.out.println(Thread.currentThread().getName());\n"
"       fruit.persist();\n"
"       return emitter.send(fruit);\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:327
#, fuzzy
msgid "This method runs on a worker thread despite the signature.  The `@Transactional` annotation configures the dispatching strategy to use a worker thread."
msgstr "尽管有签名，这个方法还是在一个工作线程上运行。 `@Transactional` 注解将调度策略配置为使用一个工作线程。"

#. type: Title ==
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:329
#, fuzzy, no-wrap
msgid "Summary"
msgstr "摘要"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:332
#, fuzzy
msgid "With Quarkus 2.2, the dispatching strategy of RESTEasy _reactive_ becomes smarter thus improving the developer experience."
msgstr "有了Quarkus 2.2，RESTEasy _反应式_ 的调度策略变得更加智能，从而改善了开发者的体验。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:334
#, fuzzy
msgid "You don't need to learn the reactive way; you can keep using imperative code."
msgstr "你不需要学习反应式方法；你可以继续使用命令式代码。"

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:335
msgid "You don't need to think about your threads; Quarkus does that for you."
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:336
msgid "You don't lose in flexibility; you can override the decision."
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-08-23-resteasy-reactive-smart-dispatch.adoc:339
msgid "Starting with Quarkus 2.3, the Quarkus team is thinking of making RESTEasy _reactive_ the default way to implement HTTP APIs.  It does not mean that the RESTEasy _classic_ extension will be retired, just that we reach the point where RESTEasy _reactive_ gives you more without burden."
msgstr ""
