msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "Agentic AI with Quarkus - part 3"
msgstr "使用 Quarkus 的代理人工智能--第 3 部分"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "The https://quarkus.io/blog/agentic-ai-with-quarkus/[first part] of this blog post series briefly introduced agentic AI and discussed workflow patterns. Subsequently, the https://quarkus.io/blog/agentic-ai-with-quarkus-p2/[second installment] explored the proper agentic patterns, showing how to implement them using Quarkus and its LangChain4j extension."
msgstr "本系列博文的 link:https://quarkus.io/blog/agentic-ai-with-quarkus/[第一部分] 简要介绍了代理人工智能，并讨论了工作流模式。随后， link:https://quarkus.io/blog/agentic-ai-with-quarkus-p2/[第二部分] 探讨了适当的代理模式，展示了如何使用 Quarkus 及其 LangChain4j 扩展实现这些模式。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "This third article aims to clarify the differences between these two approaches, discuss their pros and cons, and demonstrate with a practical example how to migrate an AI-infused service using a workflow pattern to a pure agentic implementation."
msgstr "第三篇文章旨在阐明这两种方法的区别，讨论它们的优缺点，并通过一个实际例子演示如何将使用工作流模式的人工智能注入服务迁移到纯代理实现。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "In essence, the most relevant difference between the two is that workflow patterns are programmatically orchestrated through handcrafted code paths, while agents autonomously decide their own processes and tool usage, maintaining control over how they execute tasks. This makes them more flexible and adaptable to various scenarios, but it also makes them less predictable and, in some cases, more prone to hallucinations."
msgstr "从本质上讲，两者之间最相关的区别在于，工作流模式是通过手工编制的代码路径进行编程协调的，而代理可以自主决定自己的流程和工具使用，保持对任务执行方式的控制。这使它们更灵活，更能适应各种情况，但也使它们的可预测性降低，在某些情况下，更容易产生幻觉。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "AI Workflow Vs. Pure Agentic AI"
msgstr "人工智能工作流与纯代理人工智能"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "From Workflow to Agents"
msgstr "从工作流程到代理"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "https://quarkus.io/blog/agentic-ai-with-quarkus/#routing[Routing] is one of the workflow patterns presented in the first article of this series. There, we used a first LLM service to categorize the user request and then used that category to programmatically reroute that request to one of three other LLMs acting as medical, legal, or technical experts."
msgstr "link:https://quarkus.io/blog/agentic-ai-with-quarkus/#routing[路由] 是本系列第一篇文章中介绍的工作流模式之一。在这篇文章中，我们使用第一个 LLM 服务对用户请求进行分类，然后使用该分类以编程方式将该请求重新路由到充当医疗、法律或技术专家的其他三个 LLM 中的一个。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "Routing pattern"
msgstr "路由模式"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "In that example, each expert was implemented as a separate and independent LLM service, and the routing to one of them was performed programmatically by the application code. Tracing the execution of a request like:"
msgstr "在该示例中，每个专家都是作为独立的 LLM 服务实现的，路由到其中一个专家的过程是由应用程序代码编程完成的。跟踪类似以下请求的执行情况"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "The resulting traces show the sequence of steps performed to fulfill the user request: first, the relatively fast, less than 2 seconds, classification phase conducted by the Router Agent, then the more expensive invocation of the selected expert service, which took almost 25 seconds to generate its answer."
msgstr "跟踪结果显示了为满足用户请求而执行的一系列步骤：首先是路由器代理相对较快的不到 2 秒钟的分类阶段，然后是耗时较长的对所选专家服务的调用，该服务需要将近 25 秒钟才能生成答案。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "Tracing routing workflow pattern execution"
msgstr "跟踪路由工作流程模式的执行情况"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid ""
"In this example, we use the same model to classify and generate the response. However, it is possible to use specialized models for the classification and each experts.\n"
"Now, let’s see how we can transform this workflow approach into a more agentic one."
msgstr "在本例中，我们使用同一个模型进行分类和生成响应。不过，我们也可以为分类和每位专家使用专门的模型。现在，让我们看看如何将这种工作流程方法转化为更具代理性的方法。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "Quarkus integration makes it straightforward to turn these AI “expert” services into _tools_ that another AI service can invoke. You only need to annotate the AI service methods with `@Tool` and configure the caller AI service with `@Toolbox`. This approach preserves the possibility of also invoking the single expert directly as an independent LLM service, and also using specialized models for each expert. Note that this `@Tool` annotation is not related with the presence of any MCP server and has the purpose of exposing the AI service also as a tool for other AI services. It is planned to discuss MCP in the next blog post of this series."
msgstr "通过 Quarkus 集成，可以直接将这些人工智能 \"专家 \"服务转化为另一个人工智能服务可以调用的 _工具_ 。您只需用 `@Tool` 来注释人工智能服务方法，并用 `@Toolbox` 来配置调用者人工智能服务。这种方法保留了作为独立 LLM 服务直接调用单个专家的可能性，也保留了为每个专家使用专门模型的可能性。请注意， `@Tool` 注释与任何 MCP 服务器的存在无关，其目的是将人工智能服务作为其他人工智能服务的工具。我们计划在本系列的下一篇博文中讨论 MCP。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "This way, it is possible to provide a second alternative implementation of the same expert interrogation service, this time using a pure agentic approach. The Router Agent is replaced by a single LLM, having the three experts as _tools_, that can autonomously decide to which expert the question must be delegated."
msgstr "这样，我们就有可能为相同的专家问询服务提供第二种替代实施方案，这一次使用的是纯代理方法。路由器代理被一个单一的 LLM 所取代，该 LLM 以三位专家为 _工具_ ，可以自主决定将问题委托给哪位专家。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "The `@ToolBox` annotation is used to specify the list of tools the agent can use, in this case, the three experts. Note that, similarly to what has been done for other agentic examples in the previous post of this series, this AI service has been configured to use a model capable of reasoning and requesting tool invocations. In our example, the model is configured in the `application.properties` file and is using  `qwen2.5` with 7 billion parameters. In addition, the `temperature` is set to 0 to make the classification more predictable and minimize the possibility of hallucinations."
msgstr "`@ToolBox` 注释用于指定代理可以使用的工具列表，在本例中就是三位专家。请注意，与本系列前一篇文章中的其他代理示例类似，该人工智能服务也被配置为使用一个能够推理和请求工具调用的模型。在我们的示例中，该模型配置在 `application.properties` 文件中，并使用带有 70 亿个参数的 `qwen2.5` 。此外， `temperature` 设置为 0，以提高分类的可预测性，并尽量减少出现幻觉的可能性。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "At this point, the agentic implementation of this expert interrogation service is also ready and can be exposed with a different REST endpoint, making it possible to use and compare these two alternative solutions."
msgstr "此时，该专家查询服务的代理实施也已准备就绪，可以通过不同的 REST 端点进行公开，从而可以使用和比较这两种备选解决方案。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "Comparing the workflow and agentic approaches"
msgstr "比较工作流程和代理方法"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "The two approaches are equivalent in terms of functionality, but they differ in how they are implemented and the levels of control and flexibility they offer. In particular, the pure agentic solution is much simpler and more elegant, as it does not require additional code to route the request to the right expert. The agent can do that by itself. It could also use more than one expert for a single query if needed, which would be impossible with the workflow approach, where the routing is hardcoded in the application code."
msgstr "就功能而言，这两种方法是等同的，但在实现方式以及提供的控制和灵活性方面却有所不同。特别是，纯代理解决方案要简单和优雅得多，因为它不需要额外的代码来将请求路由到正确的专家。代理可以自己完成这项工作。如果需要，它还可以针对单个查询使用多个专家，而工作流方法则不可能做到这一点，因为路由选择是应用程序代码中的硬编码。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "On the other hand, the workflow approach is more predictable and easier to debug, as the routing logic is explicit and can be easily traced. It can also be tested and controlled separately. For instance, the behavior of the Router Agent alone could be controlled and corrected with an output guardrail. Moreover, it also allows for more complex workflows, where the routing decision can depend on multiple factors and not just the user’s request."
msgstr "另一方面，工作流方法的可预测性更高，也更容易调试，因为路由逻辑是明确的，很容易跟踪。它还可以单独进行测试和控制。例如，仅路由器代理的行为就可以通过输出护栏来控制和纠正。此外，它还可以实现更复杂的工作流，路由决策可以取决于多种因素，而不仅仅是用户的请求。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "Finally, as evidenced by tracing of the agentic execution, its current implementation has a significant drawback: the overall time to fulfill the user request is significantly increased."
msgstr "最后，正如对代理执行情况的跟踪所证明的那样，其目前的执行方式有一个明显的缺点：满足用户请求的总体时间大大增加。"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "Tracing agentic routing execution"
msgstr "跟踪代理路由执行情况"

#: _posts/2025-05-08-agentic-ai-with-quarkus-p3.adoc
#, fuzzy
msgid "This depends on how the agent uses the LLM expert as a tool: even though it has been explicitly required to forward the expert’s response as it is and without any modification, it seems to ignore this instruction. It can't avoid wasting significant time reprocessing the expert's answer before returning it. In other words, this is a side-effect of the fact that the agent is in complete control of the execution, and there is no way to forward this control to a different LLM, as it would be convenient in this case."
msgstr "这取决于代理如何将 LLM 专家作为一种工具来使用：尽管代理被明确要求原封不动地转发专家的答复，但它似乎忽略了这一指示。它无法避免浪费大量时间来重新处理专家的答复，然后再将其返回。换句话说，这是代理完全控制执行的一个副作用，没有办法将控制权转交给另一个 LLM，而在这种情况下，转交给另一个 LLM 会很方便。"
