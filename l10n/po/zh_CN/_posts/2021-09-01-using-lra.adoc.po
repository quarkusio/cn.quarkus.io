# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2021-09-01-using-lra.adoc:1
#, fuzzy, no-wrap
msgid "mmusgrov"
msgstr "mmusgrov"

#. type: YAML Front Matter: date
#: upstream/_posts/2021-09-01-using-lra.adoc:1
#, fuzzy, no-wrap
msgid "2021-09-01"
msgstr "2021-09-01"

#. type: YAML Front Matter: layout
#: upstream/_posts/2021-09-01-using-lra.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "职位"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2021-09-01-using-lra.adoc:1
#, fuzzy, no-wrap
msgid "How to use the narayana LRA extension to create reliable long running activities."
msgstr "如何使用narayana LRA扩展来创建可靠的长期运行活动。"

#. type: YAML Front Matter: tags
#: upstream/_posts/2021-09-01-using-lra.adoc:1
#, fuzzy, no-wrap
msgid "extensions"
msgstr "扩展"

#. type: YAML Front Matter: title
#: upstream/_posts/2021-09-01-using-lra.adoc:1
#, fuzzy, no-wrap
msgid "An Extension for Long Running Activities"
msgstr "长跑活动的延伸"

#. type: Title ==
#: upstream/_posts/2021-09-01-using-lra.adoc:10
#, fuzzy, no-wrap
msgid "Introduction"
msgstr "简介"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:14
#, fuzzy
msgid "The Quarkus LRA extension is useful for building JAX-RS services that wish to definitively agree when an interaction has finished, with either a successful outcome or an unsuccessful one.  In the successful case, all participants can clean up in the knowledge that all other services will do so as well. Conversely, in the unsuccessful case, participants know that each other will compensate for any actions performed during the interaction. This feature means that participating services can reach a consensus and achieve an atomic outcome."
msgstr "Quarkus LRA扩展对于构建JAX-RS服务非常有用，这些服务希望在交互结束时达成明确的一致，要么是成功的结果，要么是不成功的结果。在成功的情况下，所有参与者都可以清理，因为他们知道所有其他服务也会这样做。相反，在不成功的情况下，参与者知道对方将对互动期间的任何行动进行补偿。这个特点意味着参与的服务可以达成共识，并取得一个原子性的结果。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:16
#, fuzzy
msgid "We call the service interaction an LRA, short for Long Running Action. An LRA has specific properties and guarantees that aid in the construction of reliable service interactions. Each action is assigned a unique identifier (referred to as the LRA context) so that it can be distinguished from other LRAs."
msgstr "我们把服务交互称为LRA，即Long Running Action的缩写。LRA具有特定的属性和保证，有助于构建可靠的服务交互。每个行动都被分配了一个独特的标识符（被称为LRA上下文），这样它就可以与其他LRA区分开来。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:18
#, fuzzy
msgid "Services start an LRA (or join an existing one) by marking a JAX-RS method with an https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html[@LRA annotation]. When such a method is invoked the system will start the action and make its identifier available as a JAX-RS header called \"Long-Running-Action\". If the body of the method performs any JAX-RS invocations the header is automatically added to outgoing requests. In this way the target services can join in with the interaction (if they are also annotated with the `@LRA` annotation)."
msgstr "服务通过用 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html[@LRA 注解] 标记 JAX-RS 方法来启动一个 LRA（或加入一个现有的 LRA）。当这样的方法被调用时，系统将启动该动作并将其标识符作为名为 \"Long-Running-Action \"的 JAX-RS 标头提供。如果该方法的主体执行了任何 JAX-RS 调用，该标头将被自动添加到发出的请求中。通过这种方式，目标服务可以加入到交互中（如果它们也被注解为 `@LRA` ）。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:20
#, fuzzy
msgid "Any work performed by a method annotated in this way should be \"compensatable\" in the sense that if some service \"cancels\" the LRA then the service will be reliably notified that it should compensate for any work that it did. Each service is responsible for interpreting the notion of what it means to compensate, the only requirement is that it responds https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ParticipantStatus.html[appropriately] when it is notified that it should compensate. The service indicates how it should be notified by annotating one of its method with an https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/Compensate.html[@Compensate] annotation. Refer to the javadoc for the `@LRA` annotation for the details of how to control the outcome of an LRA."
msgstr "以这种方式注释的方法所执行的任何工作都应该是 \"可补偿的\"，也就是说，如果某个服务 \"取消 \"LRA，那么该服务将被可靠地通知它应该对它所做的任何工作进行补偿。每个服务负责解释它意味着补偿的概念，唯一的要求是，当它被通知它应该补偿时，它要做出 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ParticipantStatus.html[适当的] 反应。服务通过用 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/Compensate.html[@Compensate] 注解注释它的一个方法来表明它应该如何被通知。关于如何控制LRA结果的细节，请参考 `@LRA` 注释的javadoc。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:23
#, fuzzy, no-wrap
msgid ""
"The extension provides an implementation of the https://download.eclipse.org/microprofile/microprofile-lra-1.0-M1/microprofile-lra-spec.html[MicroProfile LRA specification] and its associated\n"
" https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/index.html?org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html[annotations].\n"
msgstr "该扩展提供了 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0-M1/microprofile-lra-spec.html[MicroProfile LRA规范] 及其相关 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/index.html?org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html[注解的] 实现。"

#. type: Title ==
#: upstream/_posts/2021-09-01-using-lra.adoc:24
#, fuzzy, no-wrap
msgid "LRA coordinators"
msgstr "LRA协调员"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:29
#, fuzzy
msgid "The `narayana-lra` extension requires the presence of a running coordinator in the environment. Coordinators can be obtained from `https://hub.docker.com/r/jbosstm/lra-coordinator` or you can build your own coordinator using a maven pom that includes the appropriate dependencies. For the purpose of this blog we'll show how to create one from scratch using the `quarkus-maven-plugin`.  There is some extra information about configuring the coordinator in one of the https://jbossts.blogspot.com/2021/07/narayana-lra-update.html[narayana blogs]."
msgstr " `narayana-lra` 扩展需要环境中存在一个运行中的协调器。协调器可以从 `<a href=\"https://hub.docker.com/r/jbosstm/lra-coordinator\" class=\"bare\">https://hub.docker.com/r/jbosstm/lra-coordinator</a>` 或使用包含相应依赖项的maven pom构建自己的协调器。在本博客中，我们将展示如何使用 `quarkus-maven-plugin` ，从头开始创建一个。 在 link:https://jbossts.blogspot.com/2021/07/narayana-lra-update.html[narayana] 的一篇 link:https://jbossts.blogspot.com/2021/07/narayana-lra-update.html[博客] 中，有一些关于配置协调器的额外信息。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:31
#, fuzzy
msgid "Since the coordinator is just a JAX-RS resource we can build one using quarkus, adding the `resteasy-jackson` and `rest-client` extensions:"
msgstr "由于协调器只是一个JAX-RS资源，我们可以使用quarkus建立一个，添加 `resteasy-jackson` 和 `rest-client` 扩展。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:40
#, no-wrap
msgid ""
"$ mvn io.quarkus:quarkus-maven-plugin:2.2.1.Final:create \\\n"
"      -DprojectGroupId=org.acme \\\n"
"      -DprojectArtifactId=narayana-lra-coordinator \\\n"
"      -Dextensions=\"resteasy-jackson,rest-client\"\n"
"$ cd narayana-lra-coordinator/\n"
"$ rm -rf src\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:43
#, fuzzy
msgid "Note that we removed the generated src directory because we just need the quarkus framework for running the coordinator."
msgstr "注意，我们删除了生成的src目录，因为我们只需要quarkus框架来运行协调器。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:45
#, fuzzy
msgid "Update the pom.xml file to add a dependency on the narayana coordinator implementation:"
msgstr "更新pom.xml文件，增加对narayana协调器实现的依赖。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:53
#: upstream/_posts/2021-09-01-using-lra.adoc:457
#, no-wrap
msgid ""
"    <dependency>\n"
"      <groupId>org.jboss.narayana.rts</groupId>\n"
"      <artifactId>lra-coordinator-jar</artifactId>\n"
"      <version>5.12.0.Final</version>\n"
"    </dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:56
#, fuzzy
msgid "Now build it and run it in the background:"
msgstr "现在构建它并在后台运行。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:61
#, no-wrap
msgid ""
"$ ./mvnw clean package\n"
"$ java -Dquarkus.http.port=50000 -jar target/quarkus-app/quarkus-run.jar &\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:65
#, fuzzy
msgid "Here we are running the coordinator on the default port used by the `narayana-lra` quarkus extension, namely `50000`.  You can verify that the coordinator is running okay by listing the current LRAs:"
msgstr "这里我们在 `narayana-lra` quarkus扩展使用的默认端口上运行协调器，即 `50000` 。你可以通过列出当前的LRA来验证协调器是否运行正常。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:70
#, no-wrap
msgid ""
"$ curl http://localhost:50000/lra-coordinator\n"
"[]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:73
#, fuzzy
msgid "This snippet shows the request returning an empty json array."
msgstr "这个片段显示请求返回一个空的json数组。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:77
#, fuzzy
msgid "We shall leave the coordinator running (on the default port) while we develop and test services that use LRAs.  Towards the end of article we will show how to embed coordinators with services (NOTE: you cannot use this approach to run coordinators in native mode, a future extension will be provided to support this requirement)."
msgstr "当我们开发和测试使用LRA的服务时，我们将让协调器运行（在默认端口）。在文章的最后，我们将展示如何将协调器嵌入服务中（注意：你不能使用这种方法在本地模式下运行协调器，未来将提供一个扩展来支持这一要求）。"

#. type: Title ==
#: upstream/_posts/2021-09-01-using-lra.adoc:78
#, fuzzy, no-wrap
msgid "JVM mode"
msgstr "JVM模式"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:81
#, fuzzy
msgid "To build a JAX-RS application with LRA support add the dependency `io.quarkus:quarkus-narayana-lra` to your application's pom. This will add JAX-RS support and will also make the LRA annotations available when developing your services, it also registers a JAX-RS filter that automatically manages the participation of your services in LRAs."
msgstr "为了构建一个支持LRA的JAX-RS应用程序，请在你的应用程序的pom中添加依赖性 `io.quarkus:quarkus-narayana-lra` 。这将增加对JAX-RS的支持，并在开发服务时使LRA注释可用，它还注册了一个JAX-RS过滤器，自动管理你的服务对LRA的参与。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:83
#, fuzzy
msgid "As noted above, the guarantees (of eventual consistency) required by the https://download.eclipse.org/microprofile/microprofile-lra-1.0-M1/microprofile-lra-spec.html[LRA specification] rely on the presence of a JAX-RS application that coordinates the services participating in the LRA. This component must be present when starting the interaction, when joining the interaction and when ending the interaction. If the coordinator becomes unavailable it should be restarted. Similarly, services participating in the LRA must be available during the end phase; the system will continue retrying a service until it indicates that it is finished with the LRA, and once a service has indicated successful compensation (or completion) it no longer takes part in the interaction (although it can register for a reliable notification that all services have finished compensating or completing). Although there can be many coordinators, at the time of writing, only one can manage a particular LRA."
msgstr "如上所述， link:https://download.eclipse.org/microprofile/microprofile-lra-1.0-M1/microprofile-lra-spec.html[LRA 规范] 所要求的（最终一致性的）保证依赖于一个协调参与 LRA 的服务的 JAX-RS 应用程序的存在。在开始交互、加入交互和结束交互时，这个组件必须存在。如果协调者变得不可用，它应该被重新启动。同样，参与LRA的服务在结束阶段必须是可用的；系统将继续重试一个服务，直到它表示完成了LRA，一旦一个服务表示成功补偿（或完成），它就不再参与交互（尽管它可以注册一个可靠的通知，即所有服务都完成了补偿或完成）。尽管可以有许多协调人，但在撰写本文时，只有一个协调人可以管理一个特定的LRA。"

#. type: Title ===
#: upstream/_posts/2021-09-01-using-lra.adoc:84
#, fuzzy, no-wrap
msgid "Step 1: Create the application:"
msgstr "第1步：创建应用程序。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:93
#, no-wrap
msgid ""
"$ mvn io.quarkus:quarkus-maven-plugin:2.2.1.Final:create \\\n"
"      -DprojectGroupId=org.acme \\\n"
"      -DprojectArtifactId=narayana-lra-quickstart \\\n"
"      -Dextensions=\"narayana-lra\"\n"
"$ cd lra-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:96
#, fuzzy
msgid "Note that if the coordinator is running on a port different from the default, i.e. `50000`, then you will need to update the application config file (`src/main/resources/application.properties`) and specify the host and port:"
msgstr "请注意，如果协调器运行的端口与默认的不同，即 `50000` ，那么你将需要更新应用程序的配置文件( `src/main/resources/application.properties` )并指定主机和端口。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:100
#, no-wrap
msgid "quarkus.lra.coordinator-url=http://localhost:<port>/lra-coordinator\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:103
#, fuzzy
msgid "Verify that the generated application still works after these changes:"
msgstr "验证在这些改变之后，生成的应用程序仍然可以工作。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:107
#, no-wrap
msgid "$ ./mvnw clean package\n"
msgstr ""

#. type: Title ===
#: upstream/_posts/2021-09-01-using-lra.adoc:109
#, fuzzy, no-wrap
msgid "Step 2: Add LRA support"
msgstr "第2步：添加LRA支持"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:112
#, fuzzy
msgid "Now update the generated application so that the hello method will execute in the context of a Long Running Action:"
msgstr "现在更新生成的应用程序，以便hello方法将在Long Running Action的上下文中执行。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:114
#, fuzzy
msgid "Open the file `src/main/java/org/acme/GreetingResource.java` in an editor and annotate the `hello` method with an @LRA annotation (also inject the LRA context into the method using the JAX-RS `javax.ws.rs.HeaderParam` annotation). In addition, add two callback methods which will be called when the LRA is closed or cancelled."
msgstr "在编辑器中打开文件 `src/main/java/org/acme/GreetingResource.java` ，用@LRA注解来注解 `hello` 方法（同时使用JAX-RS `javax.ws.rs.HeaderParam` 注解将LRA上下文注入该方法中）。此外，添加两个回调方法，当LRA被关闭或取消时，这些方法将被调用。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:116
#, fuzzy
msgid "The end result, including the imports, should look like the following:"
msgstr "最终的结果，包括进口，应该是以下样子。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:120
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:125
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:135
#, no-wrap
msgid ""
"// Step 2a: Add imports for reading the LRA context and for using LRA annotations\n"
"import javax.ws.rs.HeaderParam;\n"
"import javax.ws.rs.PUT;\n"
"import javax.ws.rs.core.Response;\n"
"import java.net.URI;\n"
"import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n"
"import org.eclipse.microprofile.lra.annotation.Compensate;\n"
"import org.eclipse.microprofile.lra.annotation.Complete;\n"
"import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:138
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:146
#, no-wrap
msgid ""
"    @GET\n"
"    @LRA // Step 2b: The method should run within an LRA\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId /* Step 2c the context is useful for associating compensation logic */) {\n"
"        System.out.printf(\"hello with context %s%n\", lraId);\n"
"        return \"Hello RESTEasy\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:155
#, no-wrap
msgid ""
"    // Step 2d: There must be a method to compensate for the action if it's cancelled\n"
"    @PUT\n"
"    @Path(\"compensate\")\n"
"    @Compensate\n"
"    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n"
"        System.out.printf(\"compensating %s%n\", lraId);\n"
"        return Response.ok(lraId.toASCIIString()).build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:165
#, no-wrap
msgid ""
"    // Step 2e: An optional callback notifying that the LRA is closing\n"
"    @PUT\n"
"    @Path(\"complete\")\n"
"    @Complete\n"
"    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n"
"        System.out.printf(\"completing %s%n\", lraId);\n"
"        return Response.ok(lraId.toASCIIString()).build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:168
#, fuzzy
msgid "With these changes, if you build the application and then invoke the `hello` method then an LRA will be started before the method is entered and ended after it finishes:"
msgstr "有了这些变化，如果你构建应用程序，然后调用 `hello` 方法，那么LRA将在进入该方法之前启动，并在其结束后结束。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:178
#, no-wrap
msgid ""
"$ ./mvnw clean package\n"
"$ java -jar target/quarkus-app/quarkus-run.jar &\n"
"[1] 2389948\n"
"$ curl http://localhost:8080/hello\n"
"hello with context http://localhost:50000/lra-coordinator/0_ffffc0a8000e_8c1f_612a6e9b_a\n"
"completing http://localhost:50000/lra-coordinator/0_ffffc0a8000e_8c1f_612a6e9b_a\n"
"Hello RESTEasy\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:181
#, fuzzy
msgid "Make sure that the coordinator is still running otherwise you will see an error message similar to the following:"
msgstr "确保协调器仍在运行，否则你会看到类似以下的错误信息。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:185
#, no-wrap
msgid "2021-08-11 14:27:45,779 WARN  [io.nar.lra] (executor-thread-0) LRA025025: Unable to process LRA annotations: -3: StartFailed (start LRA client request timed out, try again later) ()'\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:189
#, fuzzy
msgid "Notice the `System.out` messages indicating that the `@Complete` callback was invoked.  Now kill the java process in preparation for the next step (the process id was printed on the console, in my example the pid is 2389948, so I typed `kill 2389948`)."
msgstr "注意到 `System.out` 信息表明 `@Complete` 回调被调用了。现在杀死java进程，为下一步做准备（进程ID被打印在控制台，在我的例子中，pid是2389948，所以我输入了 `kill 2389948` ）。"

#. type: Title ===
#: upstream/_posts/2021-09-01-using-lra.adoc:190
#, fuzzy, no-wrap
msgid "Step 3: Extending the LRA across two service methods"
msgstr "第3步：将LRA扩展到两种服务方法上"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:193
#, fuzzy
msgid "In this step we will start an LRA but not end it when the method finishes by using https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html#end--[the end element of the LRA annotation]."
msgstr "在这一步中，我们将启动一个LRA，但在方法结束时，通过使用 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html#end--[LRA注解的end元素] ，不结束它。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:195
#, fuzzy
msgid "Define a second business method to do this:"
msgstr "定义第二个业务方法来做这件事。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:206
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/start\")\n"
"    @LRA(end = false) // Step 3a: The method should run within an LRA\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String start(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n"
"        System.out.printf(\"hello with context %s%n\", lraId);\n"
"        return lraId.toASCIIString();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:211
#, fuzzy
msgid "The only difference from the hello method is the `@Path` and `@LRA` annotations and that it returns the LRA id back to the caller. We will need this to set the header when we send a request to the hello method to finish the LRA (note that this header is also available in one of the JAX-RS response headers)."
msgstr "与 hello 方法的唯一区别是 `@Path` 和 `@LRA` 注解，以及它将 LRA id 返回给调用者。当我们向hello方法发送请求以完成LRA时，我们将需要这个来设置头信息（注意这个头信息在JAX-RS响应头信息之一中也是可用的）。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:213
#, fuzzy
msgid "Kill the existing instance (`kill 2389948`) and rebuild the application (`./mvnw package -DskipTests`) and start it running in the background:"
msgstr "杀死现有的实例( `kill 2389948` )，重建应用程序( `./mvnw package -DskipTests` )，并开始在后台运行。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:218
#, no-wrap
msgid ""
"$ java -jar target/quarkus-app/quarkus-run.jar &\n"
"[1] 2495275\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:221
#, fuzzy
msgid "Start an LRA using `curl` to send a request the new method we have just added:"
msgstr "使用 `curl` 启动一个LRA，发送一个我们刚刚添加的新方法的请求。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:226
#, no-wrap
msgid ""
"$ LRA_URL=$(curl http://localhost:8080/hello/start)\n"
"hello with context http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a909_611a92ea_2\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:230
#, fuzzy
msgid "The start method was coded to return the LRA id and I have used `bash` to save it into an environment variable called `LRA_URL`.  The original hello method used the default value of the `end` element of the `@LRA` annotation so if we call that method with an LRA context then the LRA will automatically close when the method finishes:"
msgstr "start方法被编码为返回LRA id，我使用了 `bash` ，将其保存到一个名为 `LRA_URL` 的环境变量中。原来的hello方法使用了 `@LRA` 注释中的 `end` 元素的默认值，所以如果我们用LRA上下文调用该方法，那么当该方法完成时，LRA将自动关闭。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:237
#, no-wrap
msgid ""
"$ curl --header \"Long-Running-Action: $LRA_URL\" http://localhost:8080/hello\n"
"hello with context http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a909_611a92ea_2\n"
"completing http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a909_611a92ea_2\n"
"Hello RESTEasy\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:240
#, fuzzy
msgid "Notice that the `completeWork` method was invoked."
msgstr "请注意， `completeWork` 方法被调用。"

#. type: Title ===
#: upstream/_posts/2021-09-01-using-lra.adoc:241
#, fuzzy, no-wrap
msgid "Step 4: Start an LRA in one microservice and end it in a different microservice"
msgstr "第4步：在一个微服务中开始LRA，在另一个微服务中结束它"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:245
#, fuzzy
msgid "This step shows how two different microservices can coordinate their activities even though they have no coupling.  Start a second instance of the hello application on a different port:"
msgstr "这一步展示了两个不同的微服务如何协调它们的活动，尽管它们没有耦合。在不同的端口上启动Hello应用程序的第二个实例。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:250
#, no-wrap
msgid ""
"$ java -Dquarkus.http.port=8081 -jar target/quarkus-app/quarkus-run.jar &\n"
"[2] 2495369\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:253
#, fuzzy
msgid "Since we are still using the same application resource file and external coordinator there is no need to update the config."
msgstr "由于我们仍在使用相同的应用程序资源文件和外部协调器，因此没有必要更新配置。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:255
#, fuzzy
msgid "Again, start an LRA using `curl` to send a request to the start method of the first service:"
msgstr "再次，使用 `curl` ，启动一个LRA，向第一个服务的启动方法发送一个请求。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:260
#, no-wrap
msgid ""
"$ LRA_URL=$(curl http://localhost:8080/hello/start)\n"
"hello with context http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a355_6113dede_11\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:263
#, fuzzy
msgid "and now end it in the second service (the one running on port 8081):"
msgstr "现在在第二个服务（运行在8081端口的那个）中结束它。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:271
#, no-wrap
msgid ""
"$ curl --header \"Long-Running-Action: $LRA_URL\" http://localhost:8081/hello\n"
"hello with context http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a355_6113dede_11\n"
"completing http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a355_6113dede_11\n"
"completing http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a355_6113dede_11\n"
"Hello RESTEasy\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:274
#, fuzzy
msgid "Notice that both microservices indicated that they received the completion callback."
msgstr "请注意，两个微服务都表示他们收到了完成回调。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:276
#, fuzzy
msgid "Terminate both java processes (`kill 2495275 2495369`)."
msgstr "终止两个java进程( `kill 2495275 2495369` )。"

#. type: Title ====
#: upstream/_posts/2021-09-01-using-lra.adoc:277
#, fuzzy, no-wrap
msgid "Optional Step: using the MANDATORY element"
msgstr "可选步骤：使用MANDATORY元素"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:281
#, fuzzy
msgid "Instead of using an existing method to close the LRA you might prefer to write one which expects there to be a context.  In this case you would want to set the `LRA.Type` element:"
msgstr "与其使用一个现有的方法来关闭LRA，你可能更喜欢写一个期望有一个上下文的方法。在这种情况下，你会想设置 `LRA.Type` 元素。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:291
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/end\")\n"
"    @LRA(value = LRA.Type.MANDATORY) // Step 3a: The method MUST be invoked with an LRA\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String end(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n"
"        return lraId.toASCIIString();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:294
#, fuzzy
msgid "Because the end method is annotated with `@LRA(value = LRA.Type.MANDATORY)`, the context header must be present otherwise the method will return an error response code:"
msgstr "因为end方法被注释为 `@LRA(value = LRA.Type.MANDATORY)` ，所以context header必须存在，否则该方法将返回一个错误的响应代码。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:305
#, no-wrap
msgid ""
"$ ./mvnw clean package -DskipTests\n"
"$ java -Dquarkus.http.port=8081 -jar target/quarkus-app/quarkus-run.jar &\n"
"[1] 300189\n"
"$ LRA_URL=$(curl http://localhost:8081/hello/start)\n"
"$ curl -v http://localhost:8081/hello/end\n"
"...\n"
"HTTP/1.1 412 Precondition Failed\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:308
#, fuzzy
msgid "whereas providing the LRA context header will work:"
msgstr "而提供LRA上下文头就可以了。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:316
#, no-wrap
msgid ""
"$ curl --header \"Long-Running-Action: $LRA_URL\" -I http://localhost:8081/hello/end\n"
"HTTP/1.1 200 OK\n"
"Content-Type: application/octet-stream\n"
"connection: keep-alive\n"
"$ kill 300189\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:319
#, fuzzy
msgid "Other https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.Type.html[LRA.Type element values] may be useful, depending upon what your application is trying to achieve. For those readers familiar with JTA it is worth remarking that it was loosely modelled on the https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.TxType.html[Java Transactional TxType annotation]."
msgstr "其他的 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.Type.html[LRA.Type元素值] 可能是有用的，这取决于你的应用程序试图实现什么。对于那些熟悉JTA的读者来说，值得一提的是，它松散地仿照了 link:https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.TxType.html[Java交易型TxType注解] 。"

#. type: Title ==
#: upstream/_posts/2021-09-01-using-lra.adoc:320
#, fuzzy, no-wrap
msgid "Native mode"
msgstr "本地模式"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:323
#, fuzzy
msgid "in native mode only external coordinators (i.e. not embedded with the application) are supported (we will provide a coordinator extension in a later release to address this deficiency)."
msgstr "在本地模式下，只支持外部协调器（即不嵌入应用程序）（我们将在以后的版本中提供一个协调器扩展来解决这个缺陷）。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:325
#, fuzzy
msgid "First build a native executable:"
msgstr "首先建立一个本地可执行文件。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:329
#, no-wrap
msgid "$ ./mvnw package -DskipTests -Pnative\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:336
#, fuzzy
msgid "Check that the external coordinator started in <<_lra-coordinators,the section on coordinators>> is still running on port 50000 and then start the service as a native executable in the background. Note that if the coordinator is not running on the default port you would need to either pass in the location of a running coordinator as a Java system property (`-Dquarkus.lra.coordinator-url=http://localhost:50000/lra-coordinator`) or you can update the application config and rebuild the native executable."
msgstr "检查在 link:#_lra-coordinators[协调器一节] 中启动的外部协调器是否仍在50000端口运行，然后在后台以本地可执行文件的形式启动该服务。注意，如果协调器不在默认端口上运行，你需要把运行中的协调器的位置作为Java系统属性传入( `-Dquarkus.lra.coordinator-url=http://localhost:50000/lra-coordinator` )，或者你可以更新应用程序配置并重建本地可执行文件。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:338
#, fuzzy
msgid "Start an instance of the native service:"
msgstr "启动本地服务的一个实例。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:343
#, no-wrap
msgid ""
"$ ./target/narayana-lra-quickstart-1.0.0-SNAPSHOT-runner &\n"
"[1] 2434426\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:346
#, fuzzy
msgid "Take a note of the process id (i.e. 2434426) since we will need to kill the process later."
msgstr "记下进程的ID（即2434426），因为我们稍后将需要杀死这个进程。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:348
#, fuzzy
msgid "Start a new LRA:"
msgstr "启动一个新的LRA。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:352
#, no-wrap
msgid "$ LRA_URL=$(curl http://localhost:8080/hello/start)\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:355
#, fuzzy
msgid "and end it in a different method:"
msgstr "并以不同的方法结束它。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:362
#, no-wrap
msgid ""
"$ curl --header \"Long-Running-Action: $LRA_URL\" http://localhost:8080/hello\n"
"hello with context http://localhost:50000/lra-coordinator/0_ffffc0a8000e_8479_612e13fa_2\n"
"completing http://localhost:50000/lra-coordinator/0_ffffc0a8000e_8479_612e13fa_2\n"
"Hello RESTEasy\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:365
#, fuzzy
msgid "Kill the service in preparation for the next step (`kill 2434426`) or just leave it running."
msgstr "关闭服务，为下一步做准备( `kill 2434426` )，或者让它继续运行。"

#. type: Title ===
#: upstream/_posts/2021-09-01-using-lra.adoc:366
#, fuzzy, no-wrap
msgid "Failure handling"
msgstr "失败处理"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:373
#, fuzzy
msgid "In this step we will start an LRA running in one service and then kill the service before the LRA has finished.  Then we'll use a second service to end the LRA and note that second service completes but that the LRA will still be in the `Closing` state because the participant in the first, failed, service still needs to complete.  If the LRA is to reach the `Closed` state then the failed service must be restarted so that it can can respond to the `Complete` request."
msgstr "在这一步中，我们将在一个服务中启动一个运行中的LRA，然后在LRA完成之前杀死这个服务。然后我们将使用第二个服务来结束LRA，注意第二个服务完成了，但是LRA仍然处于 `Closing` 状态，因为第一个失败的服务中的参与者仍然需要完成。如果LRA要达到 `Closed` 状态，那么失败的服务必须被重新启动，这样它就可以对 `Complete` 请求做出响应。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:375
#, fuzzy
msgid "Restart the fist service on the default port 8080 (and note its process id):"
msgstr "在默认端口8080上重新启动拳头服务（并注意其进程ID）。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:380
#, no-wrap
msgid ""
"$ ./target/narayana-lra-quickstart-1.0.0-SNAPSHOT-runner &\n"
"[1] 2434936\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:383
#, fuzzy
msgid "and start a second service instance (on port 8082):"
msgstr "并启动第二个服务实例（端口为8082）。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:388
#, no-wrap
msgid ""
"$ ./target/narayana-lra-quickstart-1.0.0-SNAPSHOT-runner -Dquarkus.http.port=8082 &\n"
"[2] 2434984\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:391
#, fuzzy
msgid "Start an LRA at the first service:"
msgstr "在第一次礼拜时启动LRA。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:396
#, no-wrap
msgid ""
"$ LRA_URL=$(curl http://localhost:8080/hello/start)\n"
"hello with context http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a355_6113dede_34\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:399
#, fuzzy
msgid "Kill the first service"
msgstr "杀死第一个服务"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:404
#, no-wrap
msgid ""
"$ kill 2434936\n"
"2021-08-11 16:02:24,542 INFO  [io.quarkus] (Shutdown thread) narayana-lra-quickstart stopped in 0.003s\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:407
#, fuzzy
msgid "Now, with only the second service running, try ending the LRA:"
msgstr "现在，只有第二个服务在运行，试着结束LRA。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:414
#, no-wrap
msgid ""
"$ curl --header \"Long-Running-Action: $LRA_URL\" http://localhost:8082/hello\n"
"hello with context http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a355_6113dede_34\n"
"completing http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a355_6113dede_34\n"
"Hello RESTEasy\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:417
#, fuzzy
msgid "The LRA will still be running, as you may verify by querying the coordinator (`curl http://localhost:50000/lra-coordinator`)."
msgstr "LRA仍然在运行，你可以通过查询协调器( `curl <a href=\"http://localhost:50000/lra-coordinator\" class=\"bare\">http://localhost:50000/lra-coordinator</a>` )."

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:419
#, fuzzy
msgid "To finish the LRA restart the failed service (which was listening on port 8080):"
msgstr "为了完成LRA，重新启动失败的服务（该服务在8080端口监听）。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:424
#, no-wrap
msgid ""
"$ ./target/narayana-lra-quickstart-1.0.0-SNAPSHOT-runner &\n"
"[3] 2435130\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:429
#, fuzzy
msgid "Recovery processing is periodic (the default period between recovery passes is 2 minutes).  If you cannot wait 2 minutes then you may manually trigger a recovery cycle via the coordinators recovery endpoint as follows:"
msgstr "恢复处理是周期性的（恢复周期之间的默认周期为2分钟）。如果你不能等待2分钟，那么你可以通过协调人的恢复端点手动触发一个恢复周期，方法如下。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:435
#, no-wrap
msgid ""
"$ curl http://localhost:50000/lra-coordinator/recovery\n"
"completing http://localhost:50000/lra-coordinator/0_ffffc0a8000e_a355_6113dede_34\n"
"[]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:440
#, fuzzy
msgid "The item to note here is that the restarted service received the completion notification (`completing ...`).  The result of the request to run a recovery cycle is a json array of recovering LRAs (in this example the list is empty because the last LRA has now finished as indicated by the empty json array `[]`)."
msgstr "这里要注意的项目是，重启的服务收到了完成通知( `completing …​` )。运行恢复周期的请求的结果是一个恢复中的LRA的json数组（在这个例子中，这个列表是空的，因为最后一个LRA现在已经完成了，正如空的json数组 `[]` 所示）。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:442
#, fuzzy
msgid "Clean up by stopping the two services (`kill 2434984 2435130`)."
msgstr "通过停止这两个服务进行清理( `kill 2434984 2435130` )。"

#. type: Title ==
#: upstream/_posts/2021-09-01-using-lra.adoc:443
#, fuzzy, no-wrap
msgid "Appendix 1"
msgstr "附录1"

#. type: Title ===
#: upstream/_posts/2021-09-01-using-lra.adoc:445
#, fuzzy, no-wrap
msgid "Embedded Coordinators"
msgstr "嵌入式协调员"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:449
#, fuzzy
msgid "Since coordinators are just JAX-RS applications they can be embedded with JAX-RS services quite easily by adding the LRA coordinator dependency the applications pom.xml file:"
msgstr "由于协调器只是JAX-RS应用程序，它们可以通过在应用程序的pom.xml文件中添加LRA协调器的依赖关系来很容易地嵌入JAX-RS服务。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:461
#, fuzzy
msgid "and since, by default, quarkus only allows one application per deployment you will need to add the the following property to the application config file (`src/main/resources/application.properties`):"
msgstr "由于默认情况下，quarkus只允许每个部署一个应用程序，你将需要在应用程序配置文件中添加以下属性( `src/main/resources/application.properties` )。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:465
#, no-wrap
msgid "quarkus.resteasy.ignore-application-classes=true \n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:468
#, fuzzy
msgid "The same caveats as described in the <<_lra-coordinators,the section on coordinators>> still apply:"
msgstr "link:#_lra-coordinators[关于协调员一节] 中所描述的相同的注意事项仍然适用。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:470
#, fuzzy
msgid "no support for native executables."
msgstr "不支持本地可执行文件。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:471
#, fuzzy
msgid "each instance requires dedicated storage for the coordinators' transaction logs (since sharing transaction stores is not currently supported)."
msgstr "每个实例都需要为协调人的交易日志提供专门的存储（因为目前不支持共享交易存储）。"

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:475
#, fuzzy
msgid "The embedded coordinator will be available on the same port as the application (with path `lra-coordinator`), but note that the default coordinator port is `50000` so you will need to configure its location in the application config to tell the application to use it:"
msgstr "嵌入式协调器将在与应用程序相同的端口上可用（路径为 `lra-coordinator` ），但请注意，默认的协调器端口是 `50000` ，所以你需要在应用程序配置中配置其位置，以告诉应用程序使用它。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:480
#, no-wrap
msgid ""
"quarkus.http.port=8080\n"
"quarkus.lra.coordinator-url=http://localhost:8080/lra-coordinator\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:484
#, fuzzy
msgid "The location of the transaction logs cannot be configured in this way and must be configured via a system property (`ObjectStoreEnvironmentBean.objectStoreDir`):"
msgstr "交易日志的位置不能以这种方式配置，必须通过系统属性( `ObjectStoreEnvironmentBean.objectStoreDir` )进行配置。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:494
#, no-wrap
msgid ""
"$ java -DObjectStoreEnvironmentBean.objectStoreDir=target/lra-logs -jar target/quarkus-app/quarkus-run.jar &\n"
"[1] 2443349\n"
"$ LRA_URL=$(curl http://localhost:8080/hello/start)\n"
"02021-08-11 17:42:30,464 INFO  [com.arj.ats.arjuna] (executor-thread-1) ARJUNA012170: TransactionStatusManager started on port 35827 and host 127.0.0.1 with service com.arjuna.ats.arjuna.recovery.ActionStatusService\n"
"hello with context http://localhost:8080/lra-coordinator/0_ffffc0a8000e_a985_6113fdf6_2\n"
"$ curl http://localhost:8080/lra-coordinator\n"
"[{\"lraId\":\"http://localhost:8080/lra-coordinator/0_ffffc0a8000e_a985_6113fdf6_2\",\"clientId\":\"org.acme.GreetingResource#start\",\"status\":\"Active\",\"startTime\":1628700150466,\"finishTime\":0,\"httpStatus\":204,\"topLevel\":true,\"recovering\":false}]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:497
#, fuzzy
msgid "Now end the LRA in a different method:"
msgstr "现在以不同的方法结束上帝军。"

#. type: delimited block -
#: upstream/_posts/2021-09-01-using-lra.adoc:504
#, no-wrap
msgid ""
"$ curl --header \"Long-Running-Action: $LRA_URL\" http://localhost:8080/hello\n"
"hello with context http://localhost:8080/lra-coordinator/0_ffffc0a8000e_a985_6113fdf6_2\n"
"completing http://localhost:8080/lra-coordinator/0_ffffc0a8000e_a985_6113fdf6_2\n"
"Hello RESTEasy\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2021-09-01-using-lra.adoc:506
msgid "A later extension will provide better support for embedded coordinators (including configuring them using standard quarkus mechanisms)."
msgstr ""
