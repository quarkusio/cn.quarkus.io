# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-07-24 18:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: title
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "An Extension for Long Running Activities"
msgstr "长跑活动的延伸"

#. type: YAML Front Matter: synopsis
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "How to use the narayana LRA extension to create reliable long running activities."
msgstr "如何使用narayana LRA扩展来创建可靠的长期运行活动。"

#. type: Title ==
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Introduction"
msgstr "简介"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"The Quarkus LRA extension is useful for building JAX-RS services that wish to definitively agree when an interaction has finished, with either a successful outcome or an unsuccessful one.\n"
"In the successful case, all participants can clean up in the knowledge that all other services will do so as well. Conversely, in the unsuccessful case, participants know that each other will compensate for any actions performed during the interaction. This feature means that participating services can reach a consensus and achieve an atomic outcome."
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "We call the service interaction an LRA, short for Long Running Action. An LRA has specific properties and guarantees that aid in the construction of reliable service interactions. Each action is assigned a unique identifier (referred to as the LRA context) so that it can be distinguished from other LRAs."
msgstr "我们把服务交互称为LRA，即Long Running Action的缩写。LRA具有特定的属性和保证，有助于构建可靠的服务交互。每个行动都被分配了一个独特的标识符（被称为LRA上下文），这样它就可以与其他LRA区分开来。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Services start an LRA (or join an existing one) by marking a JAX-RS method with an https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html[@LRA annotation]. When such a method is invoked the system will start the action and make its identifier available as a JAX-RS header called \"Long-Running-Action\". If the body of the method performs any JAX-RS invocations the header is automatically added to outgoing requests. In this way the target services can join in with the interaction (if they are also annotated with the `@LRA` annotation)."
msgstr "服务通过用 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html[@LRA 注解] 标记 JAX-RS 方法来启动一个 LRA（或加入一个现有的 LRA）。当这样的方法被调用时，系统将启动该动作并将其标识符作为名为 \"Long-Running-Action \"的 JAX-RS 标头提供。如果该方法的主体执行了任何 JAX-RS 调用，该标头将被自动添加到发出的请求中。通过这种方式，目标服务可以加入到交互中（如果它们也被注解为 `@LRA` ）。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Any work performed by a method annotated in this way should be \"compensatable\" in the sense that if some service \"cancels\" the LRA then the service will be reliably notified that it should compensate for any work that it did. Each service is responsible for interpreting the notion of what it means to compensate, the only requirement is that it responds https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ParticipantStatus.html[appropriately] when it is notified that it should compensate. The service indicates how it should be notified by annotating one of its method with an https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/Compensate.html[@Compensate] annotation. Refer to the javadoc for the `@LRA` annotation for the details of how to control the outcome of an LRA."
msgstr "以这种方式注释的方法所执行的任何工作都应该是 \"可补偿的\"，也就是说，如果某个服务 \"取消 \"LRA，那么该服务将被可靠地通知它应该对它所做的任何工作进行补偿。每个服务负责解释它意味着补偿的概念，唯一的要求是，当它被通知它应该补偿时，它要做出 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ParticipantStatus.html[适当的] 反应。服务通过用 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/Compensate.html[@Compensate] 注解注释它的一个方法来表明它应该如何被通知。关于如何控制LRA结果的细节，请参考 `@LRA` 注释的javadoc。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"The extension provides an implementation of the https://download.eclipse.org/microprofile/microprofile-lra-1.0-M1/microprofile-lra-spec.html[MicroProfile LRA specification] and its associated\n"
" https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/index.html?org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html[annotations]."
msgstr ""

#. type: Title ==
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "LRA coordinators"
msgstr "LRA协调员"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"The `narayana-lra` extension requires the presence of a running coordinator in the environment. Coordinators can be obtained from `https://quay.io/repository/jbosstm/lra-coordinator`\n"
"or you can build your own coordinator using a maven pom that includes the appropriate dependencies. For the purpose of this blog we'll show how to create one from scratch using the `quarkus-maven-plugin`.\n"
"There is some extra information about configuring the coordinator in one of the https://jbossts.blogspot.com/2021/07/narayana-lra-update.html[narayana blogs]."
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Since the coordinator is just a JAX-RS resource we can build one using quarkus, adding the `resteasy-jackson` and `rest-client` extensions:"
msgstr "由于协调器只是一个JAX-RS资源，我们可以使用quarkus建立一个，添加 `resteasy-jackson` 和 `rest-client` 扩展。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Note that we removed the generated src directory because we just need the quarkus framework for running the coordinator."
msgstr "注意，我们删除了生成的src目录，因为我们只需要quarkus框架来运行协调器。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Update the pom.xml file to add a dependency on the narayana coordinator implementation:"
msgstr "更新pom.xml文件，增加对narayana协调器实现的依赖。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Now build it and run it in the background:"
msgstr "现在构建它并在后台运行。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"Here we are running the coordinator on the default port used by the `narayana-lra` quarkus extension, namely `50000`.\n"
"You can verify that the coordinator is running okay by listing the current LRAs:"
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "This snippet shows the request returning an empty json array."
msgstr "这个片段显示请求返回一个空的json数组。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"We shall leave the coordinator running (on the default port) while we develop and test services that use LRAs.\n"
"Towards the end of article we will show how to embed coordinators with services\n"
"(NOTE: you cannot use this approach to run coordinators in native mode, a future extension will be provided to support this requirement)."
msgstr ""

#. type: Title ==
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "JVM mode"
msgstr "JVM模式"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "To build a JAX-RS application with LRA support add the dependency `io.quarkus:quarkus-narayana-lra` to your application's pom. This will add JAX-RS support and will also make the LRA annotations available when developing your services, it also registers a JAX-RS filter that automatically manages the participation of your services in LRAs."
msgstr "为了构建一个支持LRA的JAX-RS应用程序，请在你的应用程序的pom中添加依赖性 `io.quarkus:quarkus-narayana-lra` 。这将增加对JAX-RS的支持，并在开发服务时使LRA注释可用，它还注册了一个JAX-RS过滤器，自动管理你的服务对LRA的参与。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "As noted above, the guarantees (of eventual consistency) required by the https://download.eclipse.org/microprofile/microprofile-lra-1.0-M1/microprofile-lra-spec.html[LRA specification] rely on the presence of a JAX-RS application that coordinates the services participating in the LRA. This component must be present when starting the interaction, when joining the interaction and when ending the interaction. If the coordinator becomes unavailable it should be restarted. Similarly, services participating in the LRA must be available during the end phase; the system will continue retrying a service until it indicates that it is finished with the LRA, and once a service has indicated successful compensation (or completion) it no longer takes part in the interaction (although it can register for a reliable notification that all services have finished compensating or completing). Although there can be many coordinators, at the time of writing, only one can manage a particular LRA."
msgstr "如上所述， link:https://download.eclipse.org/microprofile/microprofile-lra-1.0-M1/microprofile-lra-spec.html[LRA 规范] 所要求的（最终一致性的）保证依赖于一个协调参与 LRA 的服务的 JAX-RS 应用程序的存在。在开始交互、加入交互和结束交互时，这个组件必须存在。如果协调者变得不可用，它应该被重新启动。同样，参与LRA的服务在结束阶段必须是可用的；系统将继续重试一个服务，直到它表示完成了LRA，一旦一个服务表示成功补偿（或完成），它就不再参与交互（尽管它可以注册一个可靠的通知，即所有服务都完成了补偿或完成）。尽管可以有许多协调人，但在撰写本文时，只有一个协调人可以管理一个特定的LRA。"

#. type: Title ===
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Step 1: Create the application:"
msgstr "第1步：创建应用程序。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Note that if the coordinator is running on a port different from the default, i.e. `50000`, then you will need to update the application config file (`src/main/resources/application.properties`) and specify the host and port:"
msgstr "请注意，如果协调器运行的端口与默认的不同，即 `50000` ，那么你将需要更新应用程序的配置文件( `src/main/resources/application.properties` )并指定主机和端口。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Verify that the generated application still works after these changes:"
msgstr "验证在这些改变之后，生成的应用程序仍然可以工作。"

#. type: Title ===
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Step 2: Add LRA support"
msgstr "第2步：添加LRA支持"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Now update the generated application so that the hello method will execute in the context of a Long Running Action:"
msgstr "现在更新生成的应用程序，以便hello方法将在Long Running Action的上下文中执行。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Open the file `src/main/java/org/acme/GreetingResource.java` in an editor and annotate the `hello` method with an @LRA annotation (also inject the LRA context into the method using the JAX-RS `javax.ws.rs.HeaderParam` annotation). In addition, add two callback methods which will be called when the LRA is closed or cancelled."
msgstr "在编辑器中打开文件 `src/main/java/org/acme/GreetingResource.java` ，用@LRA注解来注解 `hello` 方法（同时使用JAX-RS `javax.ws.rs.HeaderParam` 注解将LRA上下文注入该方法中）。此外，添加两个回调方法，当LRA被关闭或取消时，这些方法将被调用。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "The end result, including the imports, should look like the following:"
msgstr "最终的结果，包括进口，应该是以下样子。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "With these changes, if you build the application and then invoke the `hello` method then an LRA will be started before the method is entered and ended after it finishes:"
msgstr "有了这些变化，如果你构建应用程序，然后调用 `hello` 方法，那么LRA将在进入该方法之前启动，并在其结束后结束。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Make sure that the coordinator is still running otherwise you will see an error message similar to the following:"
msgstr "确保协调器仍在运行，否则你会看到类似以下的错误信息。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"Notice the `System.out` messages indicating that the `@Complete` callback was invoked.\n"
"Now kill the java process in preparation for the next step (the process id was printed on the console, in my example the pid is 2389948, so I typed `kill 2389948`)."
msgstr ""

#. type: Title ===
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Step 3: Extending the LRA across two service methods"
msgstr "第3步：将LRA扩展到两种服务方法上"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "In this step we will start an LRA but not end it when the method finishes by using https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html#end--[the end element of the LRA annotation]."
msgstr "在这一步中，我们将启动一个LRA，但在方法结束时，通过使用 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.html#end--[LRA注解的end元素] ，不结束它。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Define a second business method to do this:"
msgstr "定义第二个业务方法来做这件事。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"The only difference from the hello method is the `@Path` and `@LRA` annotations and that it returns the LRA id\n"
"back to the caller. We will need this to set the header when we send a request to the hello method to finish\n"
"the LRA (note that this header is also available in one of the JAX-RS response headers)."
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Kill the existing instance (`kill 2389948`) and rebuild the application (`./mvnw package -DskipTests`) and start it running in the background:"
msgstr "杀死现有的实例( `kill 2389948` )，重建应用程序( `./mvnw package -DskipTests` )，并开始在后台运行。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Start an LRA using `curl` to send a request the new method we have just added:"
msgstr "使用 `curl` 启动一个LRA，发送一个我们刚刚添加的新方法的请求。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"The start method was coded to return the LRA id and I have used `bash` to save it into an environment variable called `LRA_URL`.\n"
"The original hello method used the default value of the `end` element of the `@LRA` annotation so if we call that method with an LRA context then the LRA will automatically close when the method finishes:"
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Notice that the `completeWork` method was invoked."
msgstr "请注意， `completeWork` 方法被调用。"

#. type: Title ===
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Step 4: Start an LRA in one microservice and end it in a different microservice"
msgstr "第4步：在一个微服务中开始LRA，在另一个微服务中结束它"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"This step shows how two different microservices can coordinate their activities even though they have no coupling.\n"
"Start a second instance of the hello application on a different port:"
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Since we are still using the same application resource file and external coordinator there is no need to update the config."
msgstr "由于我们仍在使用相同的应用程序资源文件和外部协调器，因此没有必要更新配置。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Again, start an LRA using `curl` to send a request to the start method of the first service:"
msgstr "再次，使用 `curl` ，启动一个LRA，向第一个服务的启动方法发送一个请求。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "and now end it in the second service (the one running on port 8081):"
msgstr "现在在第二个服务（运行在8081端口的那个）中结束它。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Notice that both microservices indicated that they received the completion callback."
msgstr "请注意，两个微服务都表示他们收到了完成回调。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Terminate both java processes (`kill 2495275 2495369`)."
msgstr "终止两个java进程( `kill 2495275 2495369` )。"

#. type: Title ====
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Optional Step: using the MANDATORY element"
msgstr "可选步骤：使用MANDATORY元素"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"Instead of using an existing method to close the LRA you might prefer to write one which expects there to be a context.\n"
"In this case you would want to set the `LRA.Type` element:"
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Because the end method is annotated with `@LRA(value = LRA.Type.MANDATORY)`, the context header must be present otherwise the method will return an error response code:"
msgstr "因为end方法被注释为 `@LRA(value = LRA.Type.MANDATORY)` ，所以context header必须存在，否则该方法将返回一个错误的响应代码。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "whereas providing the LRA context header will work:"
msgstr "而提供LRA上下文头就可以了。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Other https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.Type.html[LRA.Type element values] may be useful, depending upon what your application is trying to achieve. For those readers familiar with JTA it is worth remarking that it was loosely modelled on the https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.TxType.html[Java Transactional TxType annotation]."
msgstr "其他的 link:https://download.eclipse.org/microprofile/microprofile-lra-1.0/apidocs/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.Type.html[LRA.Type元素值] 可能是有用的，这取决于你的应用程序试图实现什么。对于那些熟悉JTA的读者来说，值得一提的是，它松散地仿照了 link:https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.TxType.html[Java交易型TxType注解] 。"

#. type: Title ==
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Native mode"
msgstr "本地模式"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "in native mode only external coordinators (i.e. not embedded with the application) are supported (we will provide a coordinator extension in a later release to address this deficiency)."
msgstr "在本地模式下，只支持外部协调器（即不嵌入应用程序）（我们将在以后的版本中提供一个协调器扩展来解决这个缺陷）。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "First build a native executable:"
msgstr "首先建立一个本地可执行文件。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"Check that the external coordinator started in <<_lra-coordinators,the section on coordinators>> is still running on\n"
"port 50000 and then start the service as a native executable in the background. Note that if the coordinator is not\n"
"running on the default port you would need to either pass in the location of a running coordinator as a Java system property\n"
"(`-Dquarkus.lra.coordinator-url=http://localhost:50000/lra-coordinator`) or you can update the application config and\n"
"rebuild the native executable."
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Start an instance of the native service:"
msgstr "启动本地服务的一个实例。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Take a note of the process id (i.e. 2434426) since we will need to kill the process later."
msgstr "记下进程的ID（即2434426），因为我们稍后将需要杀死这个进程。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Start a new LRA:"
msgstr "启动一个新的LRA。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "and end it in a different method:"
msgstr "并以不同的方法结束它。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Kill the service in preparation for the next step (`kill 2434426`) or just leave it running."
msgstr "关闭服务，为下一步做准备( `kill 2434426` )，或者让它继续运行。"

#. type: Title ===
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Failure handling"
msgstr "失败处理"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"In this step we will start an LRA running in one service and then kill the service before the LRA has finished.\n"
"Then we'll use a second service to end the LRA and note that second service completes but that the LRA will\n"
"still be in the `Closing` state because the participant in the first, failed, service still needs to complete.\n"
"If the LRA is to reach the `Closed` state then the failed service must be restarted so that it can can respond\n"
"to the `Complete` request."
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Restart the fist service on the default port 8080 (and note its process id):"
msgstr "在默认端口8080上重新启动拳头服务（并注意其进程ID）。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "and start a second service instance (on port 8082):"
msgstr "并启动第二个服务实例（端口为8082）。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Start an LRA at the first service:"
msgstr "在第一次礼拜时启动LRA。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Kill the first service"
msgstr "杀死第一个服务"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Now, with only the second service running, try ending the LRA:"
msgstr "现在，只有第二个服务在运行，试着结束LRA。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "The LRA will still be running, as you may verify by querying the coordinator (`curl http://localhost:50000/lra-coordinator`)."
msgstr "LRA仍然在运行，你可以通过查询协调器( `curl <a href=\"http://localhost:50000/lra-coordinator\" class=\"bare\">http://localhost:50000/lra-coordinator</a>` )."

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "To finish the LRA restart the failed service (which was listening on port 8080):"
msgstr "为了完成LRA，重新启动失败的服务（该服务在8080端口监听）。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"Recovery processing is periodic (the default period between recovery passes is 2 minutes).\n"
"If you cannot wait 2 minutes then you may manually trigger a recovery cycle via the coordinators\n"
"recovery endpoint as follows:"
msgstr ""

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"The item to note here is that the restarted service received the completion notification (`completing ...`).\n"
"The result of the request to run a recovery cycle is a json array of recovering LRAs (in this example the list is\n"
"empty because the last LRA has now finished as indicated by the empty json array `[]`)."
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Clean up by stopping the two services (`kill 2434984 2435130`)."
msgstr "通过停止这两个服务进行清理( `kill 2434984 2435130` )。"

#. type: Title ==
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Appendix 1"
msgstr "附录1"

#. type: Title ===
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy, no-wrap
msgid "Embedded Coordinators"
msgstr "嵌入式协调员"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"Since coordinators are just JAX-RS applications they can be embedded with JAX-RS services quite easily\n"
"by adding the LRA coordinator dependency the applications pom.xml file:"
msgstr ""

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"and since, by default, quarkus only allows one application per deployment you will need to add the the following\n"
"property to the application config file (`src/main/resources/application.properties`):"
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "The same caveats as described in the <<_lra-coordinators,the section on coordinators>> still apply:"
msgstr "link:#_lra-coordinators[关于协调员一节] 中所描述的相同的注意事项仍然适用。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "no support for native executables."
msgstr "不支持本地可执行文件。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "each instance requires dedicated storage for the coordinators' transaction logs (since sharing transaction stores is not currently supported)."
msgstr "每个实例都需要为协调人的交易日志提供专门的存储（因为目前不支持共享交易存储）。"

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"The embedded coordinator will be available on the same port as the application (with path `lra-coordinator`),\n"
"but note that the default coordinator port is `50000` so you will need to configure its location in the application\n"
"config to tell the application to use it:"
msgstr ""

#: _posts/2021-09-01-using-lra.adoc
msgid ""
"The location of the transaction logs cannot be configured in this way and must be configured via a system property\n"
"(`ObjectStoreEnvironmentBean.objectStoreDir`):"
msgstr ""

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
#, fuzzy
msgid "Now end the LRA in a different method:"
msgstr "现在以不同的方法结束上帝军。"

#. type: Plain text
#: _posts/2021-09-01-using-lra.adoc
msgid "A later extension will provide better support for embedded coordinators (including configuring them using standard quarkus mechanisms)."
msgstr ""
