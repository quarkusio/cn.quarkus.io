msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Use Quarkus MCP client to access secure MCP HTTP server from command line"
msgstr "使用 Quarkus MCP 客户端从命令行访问安全的 MCP HTTP 服务器"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Explain how Quarkus LangChain4j MCP client can access MCP HTTP servers with "
"access tokens from CLI"
msgstr "解释 Quarkus LangChain4j MCP 客户端如何通过 CLI 访问带有访问令牌的 MCP HTTP 服务器"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
msgid "Introduction"
msgstr "简介"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"In the https://quarkus.io/blog/secure-mcp-client/[Use Quarkus MCP client to "
"access secure MCP HTTP servers] blog post, we explained how a user can login "
"to Quarkus LangChain4j AI server application with GitHub OAuth2 and have "
"Google AI Gemini use https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp."
"html[Quarkus MCP Client] to access a secure https://github.com/quarkiverse/"
"quarkus-mcp-server[Quarkus MCP Server] user name provider tool with a GitHub "
"access token."
msgstr ""
"在《 link:https://quarkus.io/blog/secure-mcp-client/[使用 Quarkus MCP 客户端访问安全的 "
"MCP HTTP 服务器] 》博文中，我们介绍了用户如何使用 GitHub OAuth2 登录 Quarkus LangChain4j AI "
"服务器应用程序，并让 Google AI 双子座使用 link:https://github.com/quarkiverse/quarkus-mcp-"
"server[Quarkus MCP] link:https://docs.quarkiverse.io/quarkus-langchain4j/dev/"
"mcp.html[客户端] 访问带有 GitHub 访问令牌的安全 link:https://github.com/quarkiverse/"
"quarkus-mcp-server[Quarkus MCP 服务器] 用户名提供工具。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"However, not every AI service application is going to be designed to require "
"a user login: for example, it may run as a command line application or cron "
"scheduler. But also, not every AI service application that requires a user "
"login will be able to use a user login token to access a secure MCP server "
"because such a server may only support tokens of different type."
msgstr ""
"然而，并非每个人工智能服务应用程序都需要用户登录：例如，它可以作为命令行应用程序或 cron "
"调度程序运行。但也不是每个需要用户登录的人工智能服务应用程序都能使用用户登录令牌访问安全的 MCP 服务器，因为这类服务器可能只支持不同类型的令牌。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"In this blog post, we will explain how https://docs.quarkiverse.io/quarkus-"
"langchain4j/dev/mcp.html[Quarkus MCP Client] that runs in a command line "
"Quarkus LangChain4j AI application can itself acquire an access token using "
"an OAuth2 `client_credentials` grant and use it to access a secure https://"
"github.com/quarkiverse/quarkus-mcp-server[Quarkus MCP Server] service "
"account name provider tool."
msgstr ""
"在这篇博文中，我们将解释在命令行 Quarkus LangChain4j AI 应用程序中运行的 Quarkus link:https://docs."
"quarkiverse.io/quarkus-langchain4j/dev/mcp.html[MCP Client] 本身如何使用 OAuth2 "
"`client_credentials` grant 获取访问令牌，并使用它访问安全的 link:https://github.com/"
"quarkiverse/quarkus-mcp-server[Quarkus MCP Server] 服务帐户名提供工具。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"We will work with https://www.keycloak.org/[Keycloak] and rely on it to "
"demonstrate how to approach securing complex, distributed AI applications "
"that may span multiple security boundaries, by requiring that access tokens "
"are restricted to specific audiences, and exchanging them to acquire new, "
"correct audiences."
msgstr ""
"我们将与 link:https://www.keycloak.org/[Keycloak] "
"合作，并依靠它来演示如何确保可能跨越多个安全边界的复杂分布式人工智能应用的安全，方法是要求访问令牌仅限于特定受众，并通过交换令牌来获取新的正确受众。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Demo architecture"
msgstr "演示架构"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"As you can see in the diagram above, a command line agent uses a `Poem "
"Service` AI service to create a poem. The `Poem Service` uses `AI Gemini` "
"and requests `MCP Client` to complete a tool call to help `AI Gemini` to "
"find out the service account name."
msgstr ""
"如上图所示，命令行代理使用 `Poem Service` AI 服务来创建一首诗。 `Poem Service` 使用 `AI Gemini` 并请求 "
"`MCP Client` 完成工具调用，以帮助 `AI Gemini` 查找服务账户名。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The MCP client must use an access token. It uses an OAuth2 "
"`client_credential` grant to acquire a service account token and propagate "
"it to the secure MCP server. This service account token's audience restricts "
"it to accessing the MCP server only."
msgstr ""
"MCP 客户端必须使用访问令牌。它使用 OAuth2 `client_credential` 授予获取服务账户令牌，并将其传播到安全的 MCP "
"服务器。该服务账户令牌的受众限制它只能访问 MCP 服务器。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The MCP server tool implementation must access a REST server to complete the "
"tool action. However, it can not use the current access token that is "
"restricted to accessing this MCP server because the REST server accepts "
"tokens that are meant to access this REST server only."
msgstr ""
"MCP 服务器工具实施必须访问 REST 服务器才能完成工具操作。但是，它不能使用仅限于访问该 MCP 服务器的当前访问令牌，因为 REST "
"服务器只接受用于访问该 REST 服务器的令牌。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Therefore, the MCP server exchanges the current token to set the REST server "
"audience before propagating it, with the REST server successfully completing "
"the secure tool call, with the response returned to the MCP Client."
msgstr ""
"因此，MCP 服务器会交换当前令牌，以便在传播之前设置 REST 服务器受众，REST 服务器会成功完成安全工具调用，并将响应返回给 MCP 客户端。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "We are now ready to start working on the demo."
msgstr "现在我们可以开始制作演示了。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"You can find the complete project source in the https://github.com/"
"quarkiverse/quarkus-langchain4j/tree/main/samples/secure-mcp-cmd-client-"
"server[Quarkus LangChain4j Command Line Secure MCP Client Server sample]."
msgstr ""
"您可以在 link:https://github.com/quarkiverse/quarkus-langchain4j/tree/main/"
"samples/secure-mcp-cmd-client-server[Quarkus LangChain4j 命令行安全 MCP 客户端服务器示例] "
"中找到完整的项目源代码。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Step 1 - Create and start MCP server"
msgstr "步骤 1 - 创建并启动 MCP 服务器"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"First, let's create a secure Quarkus MCP SSE server that can enforce an "
"authenticated access to its tool, verify that the access token has a correct "
"audience, and complete a tool action by exchanging the current access token "
"for a new access token with the REST server audience and propagating this "
"token to the REST server to get the required service account name."
msgstr ""
"首先，让我们创建一个安全的 Quarkus MCP SSE "
"服务器，它可以强制执行对其工具的验证访问，验证访问令牌是否有正确的受众，并通过将当前访问令牌与 REST "
"服务器受众交换为新的访问令牌来完成工具操作，并将此令牌传播到 REST 服务器以获取所需的服务账户名。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "MCP server maven dependencies"
msgstr "MCP 服务器 maven 依赖项"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Add the following dependencies:"
msgstr "添加以下依赖项"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"`quarkus-mcp-server-sse` is required to support MCP Streamable HTTP and SSE "
"transports."
msgstr "`quarkus-mcp-server-sse` 是支持 MCP Streamable HTTP 和 SSE 传输所必需的。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"`quarkus-oidc` is required to secure access to MCP SSE endpoints. Its "
"version is defined in the Quarkus BOM."
msgstr "`quarkus-oidc` 是确保 MCP SSE 端点访问安全所必需的。其版本已在 Quarkus BOM 中定义。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"`quarkus-rest` is required to support REST server that the MCP tool has to "
"call. Its version is defined in the Quarkus BOM."
msgstr "`quarkus-rest` 是支持 MCP 工具必须调用的 REST 服务器所必需的。其版本已在 Quarkus BOM 中定义。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"`quarkus-rest-client-oidc-token-propagation` also brings `quarkus-rest-"
"client` and is required to support a REST client call to REST server with "
"the token exchange and propagation. Its version is defined in the Quarkus "
"BOM."
msgstr ""
"`quarkus-rest-client-oidc-token-propagation` 还带来了 ，并且需要它来支持 REST 客户端调用 REST "
"服务器，以及令牌交换和传播。其版本已在 Quarkus BOM 中定义。 `quarkus-rest-client` "

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "MCP Service Account Name Tool"
msgstr "MCP 服务账户名称工具"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Let's create a tool that can return a name of the current service account."
msgstr "让我们创建一个可以返回当前服务账户名称的工具。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Provide a tool that can return a name of the current service account."
msgstr "提供一个可以返回当前服务账户名称的工具。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Use an injected `ServiceAccountNameRestClient` to access the REST server to "
"complete the service account name request. See the <<service-account-name-"
"rest-client>> section below for more details."
msgstr ""
"使用注入的 `ServiceAccountNameRestClient` 访问 REST 服务器，完成服务账户名称请求。更多详情，请参阅下面的 "
"<<service-account-name-rest-client>> 部分。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The MCP server tool can be invoked only if the current MCP request is "
"authenticated."
msgstr "只有当前的 MCP 请求经过验证，才能调用 MCP 服务器工具。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"In this blog post we do not enforce the secure tool access with annotations "
"such as https://quarkus.io/blog/secure-mcp-client/#mcp-server-"
"tool[@PermissionAllowed] or https://quarkus.io/blog/secure-mcp-sse-server/"
"#tool[@Authenticated] but only use the HTTP security policy configuration "
"instead."
msgstr ""
"在这篇博文中，我们不使用 link:https://quarkus.io/blog/secure-mcp-client/#mcp-server-"
"tool[@PermissionAllowed] 或 link:https://quarkus.io/blog/secure-mcp-sse-"
"server/#tool[@Authenticated] 等注解来强制执行安全工具访问，而只使用 HTTP 安全策略配置。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"See how both main MCP SSE and tool endpoints are secured in the <<mcp-server-"
"configuration>> section below."
msgstr "请参阅 <<mcp-server-configuration>> 部分，了解主要 MCP SSE 和工具端点的安全保障。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Service Account Name REST client"
msgstr "服务帐户名 REST 客户端"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The <<mcp-server-tool>> uses the Service Account Name REST client to call "
"the REST server to complete a service account name request."
msgstr "<<mcp-server-tool>> 使用服务帐户名 REST 客户端调用 REST 服务器完成服务帐户名请求。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "This REST client looks like this:"
msgstr "这个 REST 客户端看起来是这样的"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Get a service account name from the REST server. See the <<service-account-"
"name-rest-server>> section below for more details."
msgstr "从 REST 服务器获取服务账户名称。详情请参阅 <<service-account-name-rest-server>> 部分。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Use `@AccessToken` annotation to require the access token exchange and "
"propagation. This single `@AccessToken` annotation, supported by an "
"additional configuration in the <<mcp-server-configuration>> section below, "
"is all that is required to support this complex access token flow."
msgstr ""
"使用 `@AccessToken` 注释要求交换和传播访问令牌。只需使用 `@AccessToken` 注释，并在下面的 <<mcp-server-"
"configuration>> 部分进行附加配置，就能支持这种复杂的访问令牌流。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Service Account Name REST server"
msgstr "服务账户名称 REST 服务器"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The <<mcp-server-tool>> uses the <<service-account-name-rest-client>> to get "
"a service account name from the Service Account Name REST server."
msgstr ""
"<<mcp-server-tool>> 使用 <<service-account-name-rest-client>> 从服务账户名称 REST "
"服务器获取服务账户名称。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "This REST server looks like this:"
msgstr "这个 REST 服务器看起来像这样："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Provide a secure REST resource method that can return a service account name"
msgstr "提供可返回服务账户名称的安全 REST 资源方法"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Use an injected `SecurityIdentity` to complete the method's task, in this "
"case - return a service account identity name."
msgstr "使用注入的 `SecurityIdentity` 来完成方法的任务，在本例中就是返回服务账户的身份名称。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"In this demo, the REST server is collocated with the MCP server to simplify "
"the demo. Of course, in production, such REST servers will most likely be "
"remote."
msgstr "在本演示中，REST 服务器与 MCP 服务器放在一起，以简化演示。当然，在生产中，这种 REST 服务器很可能是远程的。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Next, let's have a look, in the <<mcp-server-configuration>> section, how "
"access to both the <<mcp-server-tool>> and this server is restricted to "
"tokens with specific audiences only."
msgstr ""
"接下来，让我们看看 <<mcp-server-configuration>> 部分是如何限制只有特定受众的令牌才能访问 <<mcp-server-"
"tool>> 和本服务器的。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "MCP Server Configuration"
msgstr "MCP 服务器配置"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Let's configure our secure MCP server:"
msgstr "让我们配置安全的 MCP 服务器："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Declare MCP server and enable traffic logging."
msgstr "声明 MCP 服务器并启用流量日志。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Enforce an authenticated access to the main MCP SSE and tool endpoints. The "
"configured pattern covers both the initial '/mcp/sse' handshake and '/mcp/"
"messages/' requests."
msgstr "强制对主 MCP SSE 和工具端点进行身份验证访问。配置的模式包括初始\"/mcp/sse \"握手和\"/mcp/messages/\"请求。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Default OIDC tenant that secures the MCP SSE endpoint and tool. It is "
"supported by Keycloak Dev Service in dev mode. In simple cases you do not "
"even have to configure the default OIDC tenant. But in this demo, the "
"default OIDC tenant is required to enforce that the tokens which reach the "
"MCP server contain a `quarkus-mcp-server` audience."
msgstr ""
"确保 MCP SSE 端点和工具安全的默认 OIDC 租户。Keycloak Dev Service "
"在开发模式下支持该租户。在简单情况下，你甚至不需要配置默认 OIDC 租户。但在本演示中，默认 OIDC 租户需要强制执行到达 MCP 服务器的令牌包含 "
"`quarkus-mcp-server` 受众。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Request an access token exchange before the <<service-account-name-rest-"
"client>> propagates it."
msgstr "在 <<service-account-name-rest-client>> 传播之前请求交换访问令牌。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Configure OIDC client to perform the token exchange"
msgstr "配置 OIDC 客户端以执行令牌交换"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Set the https://datatracker.ietf.org/doc/html/rfc8693#name-token-type-"
"identifiers[type] of a new token that the current token will be exchanged "
"for to `access_token`. Starting from Quarkus 3.25, an expected new  token "
"type will be set to `access_token` by default, and users will not have to "
"configure this property when the access token type is required when "
"exchanging tokens."
msgstr ""
"将当前令牌交换的新令牌 link:https://datatracker.ietf.org/doc/html/rfc8693#name-token-"
"type-identifiers[类型] 设置为 `access_token` 。从 Quarkus 3.25 开始，预期的新令牌类型将默认设置为 "
"`access_token` ，当交换令牌时需要访问令牌类型时，用户无需配置此属性。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Configure the <<service-account-name-rest-client>> with the REST server "
"address. The REST server is collocated with the MCP server only to simplify "
"the demo."
msgstr ""
"使用 REST 服务器地址配置 <<service-account-name-rest-client>> 。将 REST 服务器与 MCP "
"服务器放在一起只是为了简化演示。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "The OIDC tenant that protects the REST server only."
msgstr "仅保护 REST 服务器的 OIDC 租户。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The OIDC tenant that protects the REST server requires that the tokens that "
"are used to access it contain a REST server `quarkus-mcp-service` audience."
msgstr ""
"保护 REST 服务器的 OIDC 租户要求用于访问 REST 服务器的令牌包含 REST 服务器 `quarkus-mcp-service` 受众。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Configure Keycloak dev service to use one of the latest released Keycloak "
"images, and make it run on a fixed `8081` port to simplify the <<poem-"
"service-configuration>> where an access to Keycloak is also required."
msgstr ""
"配置 Keycloak 开发服务，使其使用最新发布的 Keycloak 镜像之一，并使其在固定的 `8081` 端口上运行，以简化 <<poem-"
"service-configuration>> ，在这种情况下也需要访问 Keycloak。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Start the MCP server in dev mode"
msgstr "以开发模式启动 MCP 服务器"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Now let's start the MCP server in dev mode:"
msgstr "现在，让我们以开发模式启动 MCP 服务器："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"and go to the <<keycloak-setup>> in the next section to complete the "
"Keycloak configuration that is required to support the secure MCP server "
"token audience and exchange requirements."
msgstr ""
"并转到下一节中的 <<keycloak-setup>> 完成 Keycloak 配置，这是支持安全 MCP 服务器令牌接收和交换要求所必需的。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Step 2 - Keycloak setup"
msgstr "步骤 2 - 设置 Keycloak"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"When we <<start-mcp-server,started the MCP server in dev mode>>, Keycloak "
"Dev Service launched a Keycloak container, made it available on port `8081`, "
"created a `quarkus` realm with the `quarkus-mcp-server` client - this client "
"name was configured with the `quarkus.oidc.client-id=quarkus-mcp-server` "
"property in the <<mcp-server-configuration>> section."
msgstr ""
"当我们 xref:start-mcp-server[以开发模式] 启动 xref:start-mcp-server[MCP 服务器时] "
"，Keycloak 开发服务会启动一个 Keycloak 容器，使其在 `8081` 端口可用，并用 `quarkus-mcp-server` "
"客户端创建一个 `quarkus` 领域--该客户端名称是通过 <<mcp-server-configuration>> 部分的 `quarkus."
"oidc.client-id=quarkus-mcp-server` 属性配置的。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The `quarkus-mcp-server` client represents a confidential OIDC client that "
"protects the MCP server."
msgstr "`quarkus-mcp-server` 客户端代表保密的 OIDC 客户端，可保护 MCP 服务器。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"But MCP server and REST server have additional token audience and exchange "
"requirements and we must complete the Keycloak setup to support those "
"requirements. Let's do it."
msgstr "但 MCP 服务器和 REST 服务器有额外的令牌接收和交换要求，我们必须完成 Keycloak 设置以支持这些要求。让我们开始吧"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Go to `http://localhost:8081` and login as a Keycloak admin, with the "
"`admin` name and `admin` password credentials."
msgstr ""
"访问 `http://localhost:8081` 并以 Keycloak 管理员身份登录，使用 `admin` 名称和 `admin` 密码凭据。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Select the `quarkus` realm:"
msgstr "选择 `quarkus` realm："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"First, create a `quarkus-mcp-client` OIDC client that the Quarkus MCP client "
"will use to acquire OAuth2 `client_credentials` tokens for accessing the MCP "
"server."
msgstr ""
"首先，创建 `quarkus-mcp-client` OIDC 客户端，Quarkus MCP 客户端将使用该客户端获取访问 MCP 服务器的 "
"OAuth2 `client_credentials` 令牌。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Start with the `General Settings`:"
msgstr "从 `General Settings` 开始："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"and enable `Client authentication` and `Service accounts roles` capabilities:"
""
msgstr "并启用 `Client authentication` 和 `Service accounts roles` 功能："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Save the `quarkus-mcp-client` OIDC client. Click on its `Credentials` tab "
"and copy the generated secret to export it later as the <<oidc-client-"
"secret>> in order to run the command line AI `Poem Service` application."
msgstr ""
"保存 `quarkus-mcp-client` OIDC 客户端。单击 `Credentials` 选项卡，复制生成的秘密，稍后将其导出为 <<oidc-"
"client-secret>> ，以便运行命令行 AI `Poem Service` 应用程序。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"For the Quarkus MCP client to be able to access MCP server with access "
"tokens that the `quarkus-mcp-client` OIDC client will acquire, these tokens "
"must contain an audience (`aud`) claim with a `quarkus-mcp-server` audience. "
"The MCP server is configured in the <<mcp-server-configuration>> section to "
"require this audience."
msgstr ""
"要使夸克 MCP 客户端能够使用 `quarkus-mcp-client` OIDC 客户端获取的访问令牌访问 MCP 服务器，这些令牌必须包含一个 "
"`quarkus-mcp-server` audience ( `aud` ) claim。MCP 服务器在 <<mcp-server-"
"configuration>> 部分被配置为需要该受众。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Keycloak supports several options for adding an audience (`aud`) claim to "
"issued tokens. We will use an option that involves creating a custom `Client "
"scope` with an `Audience` mapping."
msgstr ""
"Keycloak 支持多种为已发行令牌添加受众 ( `aud` ) 权利主张的选项。我们将使用一个选项，即创建一个带有 `Audience` "
"映射的自定义 `Client scope` 。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Go to the `Client scopes` and create an `Optional` `quarkus-mcp-server-"
"scope`:"
msgstr "访问 `Client scopes` 并创建 `Optional` `quarkus-mcp-server-scope` ："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Once the `quarkus-mcp-server-scope` scope is created, go to its `Mappings` "
"tab, and choose `Configure a new mapper` option and select `Audience`:"
msgstr ""
"创建 `quarkus-mcp-server-scope` 作用域后，转到 `Mappings` 选项卡，选择 `Configure a new "
"mapper` 选项并选择 `Audience` ："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Name this mapper as `quarkus-mcp-server-as-audience` and choose `quarkus-mcp-"
"server` as an `Included Client Audience`:"
msgstr ""
"将此映射器命名为 `quarkus-mcp-server-as-audience` ，并选择 `quarkus-mcp-server` 作为 "
"`Included Client Audience` ："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Once the `quarkus-mcp-server-scope` is created, add it as an `Optional` "
"scope to the `quarkus-mcp-client`:"
msgstr ""
"创建 `quarkus-mcp-server-scope` 后，将其作为 `Optional` 作用域添加到 `quarkus-mcp-client` "
"："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Now, when Quarkus MCP client will use the `quarkus-mcp-client` OIDC client "
"to acquire tokens, it will request a `quarkus-mcp-server-scope` token scope, "
"resulting in Keycloak issuing tokens with an audience that contains the "
"`quarkus-mcp-server` - exactly what the Quarkus MCP server requires."
msgstr ""
"现在，当 Quarkus MCP 客户端使用 `quarkus-mcp-client` OIDC 客户端获取令牌时，它将请求 `quarkus-mcp-"
"server-scope` 令牌范围，从而使 Keycloak 发行的令牌受众包含 `quarkus-mcp-server` - 这正是 Quarkus "
"MCP 服务器所需要的。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Next, we need to support Quarkus MCP server exchanging the incoming access "
"token with the `quarkus-mcp-server` audience for a new token that will "
"contain a REST server audience instead."
msgstr ""
"接下来，我们需要支持 Quarkus MCP 服务器将传入的访问令牌与 `quarkus-mcp-server` 受众交换为新令牌，新令牌将包含 "
"REST 服务器受众。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Create a `quarkus-mcp-service` OIDC client that represents the REST server, "
"similarly to how you created the `quarkus-mcp-client` OIDC client. Next, "
"create a `quarkus-mcp-service-scope` client scope, similarly to how you "
"created the `quarkus-mcp-server-scope` client scope, choosing the `quarkus-"
"mcp-service` as an `Included Client Audience` when creating an audience "
"mapping for this scope."
msgstr ""
"与创建 `quarkus-mcp-client` OIDC 客户端的方法类似，创建一个代表 REST 服务器的 `quarkus-mcp-"
"service` OIDC 客户端。然后，创建 `quarkus-mcp-service-scope` 客户端作用域，与创建 `quarkus-mcp-"
"server-scope` 客户端作用域的方法类似，在为该作用域创建受众映射时选择 `quarkus-mcp-service` 作为 `Included "
"Client Audience` 。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Once the `quarkus-mcp-service-scope` is created, add it as an `Optional`  "
"client scope to the `quarkus-mcp-server` MCP Server OIDC client, similarly "
"to how you added the `quarkus-mcp-server-scope` to the `quarkus-mcp-client` "
"above."
msgstr ""
"创建 `quarkus-mcp-service-scope` 后，将其作为 `Optional` 客户端作用域添加到 `quarkus-mcp-"
"server` MCP 服务器 OIDC 客户端，与上文将 `quarkus-mcp-server-scope` 添加到 `quarkus-mcp-"
"client` 的方法类似。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Finally, update the `quarkus-mcp-server` capability to support a `Standard "
"Token Exchange`, see the https://www.keycloak.org/securing-apps/token-"
"exchange#_standard-token-exchange-enable[How to enable token exchange] "
"example in the Keycloak documentation."
msgstr ""
"最后，更新 `quarkus-mcp-server` 功能以支持 `Standard Token Exchange` ，请参阅 Keycloak "
"文档中的 link:https://www.keycloak.org/securing-apps/token-exchange#_standard-"
"token-exchange-enable[如何启用令牌交换] 示例。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Now, the `quarkus-mcp-server` OIDC client that secures the MCP server can "
"also exchange the incoming token and request a new `quarkus-mcp-service` "
"audience by adding the `quarkus-mcp-service-scope` scope to the token "
"exchange grant request, exactly what the REST server requires."
msgstr ""
"现在，保护 MCP 服务器的 `quarkus-mcp-server` OIDC 客户端也可以交换传入的令牌，并通过在令牌交换授予请求中添加 "
"`quarkus-mcp-service-scope` 范围来请求新的 `quarkus-mcp-service` 受众，这正是 REST "
"服务器所要求的。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"If you actively work with another OAuth2 provider that can produce tokens "
"with required audiences and exchange them using a standard token exchange "
"grant, then you can also try to adapt this demo to work with that provider "
"instead."
msgstr ""
"如果您积极使用另一个 OAuth2 "
"提供商，该提供商可以生成具有所需受众的令牌，并使用标准令牌交换授权进行交换，那么您也可以尝试调整此演示，使其与该提供商配合使用。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Step 3 - Create and run Poem Service from command line"
msgstr "步骤 3 - 从命令行创建并运行诗歌服务"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The MCP server is now <<start-mcp-server,running>> and ready to accept tool "
"calls. Let's create a command line AI `Poem Service` that will work with AI "
"Gemini and use Quarkus MCP client to complete tool calls."
msgstr ""
"MCP 服务器现在已经 xref:start-mcp-server[运行] ，可以接受工具调用。让我们创建一个命令行 AI `Poem Service` "
"，它将与 AI 双子座一起工作，并使用 Quarkus MCP 客户端完成工具调用。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Poem Service Maven dependencies"
msgstr "诗歌服务 Maven 依赖项"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "`quarkus-langchain4j-ai-gemini` brings support for AI Gemini."
msgstr "`quarkus-langchain4j-ai-gemini` 带来了对人工智能双子座的支持。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "`quarkus-langchain4j-mcp` provides core MCP Client support."
msgstr "`quarkus-langchain4j-mcp` 提供核心 MCP 客户端支持。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"`quarkus-langchain4j-oidc-cient-mcp-auth-provider` provides an "
"implementation of https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp."
"html#_authorization[McpClientAuthProvider] that can supply access tokens "
"that it itself acquires with an OAuth2 `client_credentials` grant (or any "
"other supported grant that does not require a user input). Note, this "
"dependency is different from the `quarkus-langchain4j-oidc-mcp-auth-"
"provider` one that supplies tokens already available after an authorization "
"code flow completes, it was demoed in the https://quarkus.io/blog/secure-mcp-"
"client/#poem-service-maven-dependencies[Use Quarkus MCP client to access "
"secure MCP HTTP servers] blog post to propagate GitHub login access tokens."
msgstr ""
"`quarkus-langchain4j-oidc-cient-mcp-auth-provider` 提供了一个 link:https://docs."
"quarkiverse.io/quarkus-langchain4j/dev/mcp."
"html#_authorization[McpClientAuthProvider] 的实现，它可以提供自己通过 OAuth2 "
"授予（或任何其他不需要用户输入的受支持授予）获取的访问令牌。请注意，这种依赖关系与 不同，后者提供的令牌在授权代码流完成后就已可用。在 "
"`client_credentials` `quarkus-langchain4j-oidc-mcp-auth-provider` link:https:"
"//quarkus.io/blog/secure-mcp-client/#poem-service-maven-dependencies[使用 "
"Quarkus MCP 客户端访问安全的 MCP HTTP 服务器] 以传播 GitHub 登录访问令牌的博文中演示了这种依赖关系。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"`quarkus-picocli` supports building command-line Quarkus applications. Its "
"version is defined in the Quarkus BOM."
msgstr "`quarkus-picocli` 支持构建命令行 Quarkus 应用程序。其版本已在 Quarkus BOM 中定义。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "AI Gemini API key"
msgstr "AI 双子座应用程序接口密钥"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "`Poem Service` relies on AI Gemini to create a poem."
msgstr "`Poem Service` 依靠人工智能双子座来创作一首诗。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Get https://aistudio.google.com/app/apikey[AI Gemini API key] and export it "
"as an `AI_GEMINI_API_KEY` environment property."
msgstr ""
"获取 link:https://aistudio.google.com/app/apikey[AI 双子座 API 密钥] ，并将其导出为 "
"`AI_GEMINI_API_KEY` 环境属性。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "OIDC client secret"
msgstr "OIDC 客户秘密"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Quarkus MCP client will use an implementation of https://docs.quarkiverse.io/"
"quarkus-langchain4j/dev/mcp.html#_authorization[McpClientAuthProvider] "
"provided by the `quarkus-langchain4j-oidc-cient-mcp-auth-provider` "
"dependency."
msgstr ""
"Quarkus MCP 客户端将使用 `quarkus-langchain4j-oidc-cient-mcp-auth-provider` 依赖项提供的 "
"link:https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp."
"html#_authorization[McpClientAuthProvider] 实现。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"This `McpClientAuthProvider` uses the <<poem-service-"
"configuration,configured OIDC client>> to acquire access tokens using an "
"OAuth2 `client_credentials` grant, where an OIDC client secret must be "
"provided."
msgstr ""
"`McpClientAuthProvider` 使用 xref:poem-service-configuration[已配置的 OIDC 客户端] "
"，通过 OAuth2 `client_credentials` 授予获取访问令牌，其中必须提供 OIDC 客户端秘密。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Export the OIDC `quarkus-mcp-client` client secret that you copied when "
"working through the <<keycloak-setup>> section as an `OIDC_CLIENT_SECRET` "
"environment property."
msgstr ""
"导出在 <<keycloak-setup>> 部分工作时复制的 OIDC `quarkus-mcp-client` 客户秘密，作为 "
"`OIDC_CLIENT_SECRET` 环境属性。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Poem Service"
msgstr "诗歌服务"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "`Poem Service` is a simple Quarkus LangChain4j AI service:"
msgstr "`Poem Service` 是一个简单的 Quarkus LangChain4j AI 服务："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Request to write a poem about Java."
msgstr "请求写一首关于 Java 的诗。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Use Quarkus MCP `service-account-name` client configured in the <<poem-"
"service-configuration>> section to call a tool that can provide a service "
"account name."
msgstr ""
"使用 <<poem-service-configuration>> 部分配置的 Quarkus MCP `service-account-name` "
"客户端调用可提供服务帐户名的工具。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "This service is called from the `PoemCommand`:"
msgstr "这项服务由 `PoemCommand` 调用："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Call `PoemService`."
msgstr "请致电 `PoemService` 。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Poem Service Configuration"
msgstr "诗歌服务配置"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Let's see how the command line `Poem Service` configuration looks like:"
msgstr "让我们看看 `Poem Service` 命令行配置是怎样的："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Enable MCP client HTTP transport. In this demo we use SSE, but `Streamable "
"HTTP` is also supported."
msgstr "启用 MCP 客户端 HTTP 传输。在本演示中，我们使用 SSE，但也支持 `Streamable HTTP` 。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Point to the Quarkus MCP server endpoint that you started in the <<start-mcp-"
"server>> step."
msgstr "指向在 <<start-mcp-server>> 步骤中启动的 Quarkus MCP 服务器端点。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Configure https://quarkus.io/guides/security-openid-connect-client-"
"reference[OIDC client] to acquire access tokens using OAuth2 "
"`client_credentials` grant, a default grant type supported by the OIDC "
"client. OIDC client points to a Keycloak `quarkus` realm, note the fixed "
"`8081` port that you requested Keycloak Dev Service to use for Keycloak in "
"the <<keycloak-setup>> section."
msgstr ""
"配置 link:https://quarkus.io/guides/security-openid-connect-client-"
"reference[OIDC 客户端] ，使用 OAuth2 `client_credentials` grant（OIDC 客户端支持的默认 "
"grant 类型）获取访问令牌。OIDC 客户端指向 Keycloak `quarkus` realm，注意您在 <<keycloak-setup>> "
"部分要求 Keycloak Dev Service 用于 Keycloak 的固定 `8081` 端口。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"OIDC client id, you created the OIDC `quarkus-mcp-client` client in the "
"<<keycloak-setup>> section."
msgstr ""
"OIDC 客户端 ID，您在 <<keycloak-setup>> 部分创建了 OIDC `quarkus-mcp-client` 客户端。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"OIDC `quarkus-mcp-client` client secret that you exported during the <<oidc-"
"client-secret>> step."
msgstr "<<oidc-client-secret>> 步骤中导出的 OIDC `quarkus-mcp-client` 客户秘密。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Request that the tokens issued to `quarkus-mcp-client` must contain a "
"`quarkus-mcp-server` MCP server audience. You created a client `quarkus-mcp-"
"server-scope` scope with a `quarkus-mcp-server` client audience mapping in "
"the <<keycloak-setup>> section."
msgstr ""
"要求签发给 `quarkus-mcp-client` 的令牌必须包含 `quarkus-mcp-server` MCP 服务器受众。您在 "
"<<keycloak-setup>> 部分创建了具有 `quarkus-mcp-server` 客户端受众映射的 `quarkus-mcp-server-"
"scope` 客户端作用域。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"AI Gemini key that you acquired and exported during the <<ai-gemini-key>> "
"step."
msgstr "您在 <<ai-gemini-key>> 步骤中获取并导出的 AI 双子座密钥。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Enable AI Gemini request and response logging"
msgstr "启用 AI 双子座请求和响应日志功能"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Please pay attention to the fact that the MCP client configuration has a "
"`service-account-name` name. You referred to this configuration with the "
"`@McpToolBox(\"service-account-name\")` annotation in the <<poem-service>> "
"section."
msgstr ""
"请注意，MCP 客户端配置有一个 `service-account-name` 名称。您在 <<poem-service>> 部分使用 "
"`@McpToolBox(\"service-account-name\")` 注释引用了该配置。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Package Poem Service"
msgstr "套餐诗歌服务"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Package the command line `Poem Service`:"
msgstr "打包命令行 `Poem Service` ："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Run Poem Service"
msgstr "运行诗歌服务"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Run the command line `Poem Service` that you packaged in the <<package-poem-"
"service>> section:"
msgstr "运行在 <<package-poem-service>> 部分打包的命令行 `Poem Service` ："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "You should get a response such as:"
msgstr "您应该会收到这样的回复"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "How about trying another language ?"
msgstr "试试其他语言如何？"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Have token audiences made any difference ?"
msgstr "象征性的观众有什么不同吗？"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"For the command line `Poem Service` to <<run-poem-service, run "
"successfully>>, Quarkus MCP client had to acquire a token with a `quarkus-"
"mcp-server` audience to access the MCP server."
msgstr ""
"为使命令行 `Poem Service` xref:run-poem-service[成功运行] ，Quarkus MCP 客户端必须获得一个 "
"`quarkus-mcp-server` 受众的令牌，才能访问 MCP 服务器。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Here is how a token that Keycloak issues to the MCP client looks like:"
msgstr "下面是 Keycloak 向 MCP 客户端发出的令牌的样子："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The token `aud` claim contains two audience values, one of them is a "
"required `quarkus-mcp-server` audience."
msgstr "令牌 `aud` 索赔包含两个受众值，其中一个是必须的 `quarkus-mcp-server` 受众。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"For the MCP `quarkus-mcp-server` server to complete the Quarkus MCP client "
"request, it had to verify that the token had a correct `quarkus-mcp-server` "
"audience, and exchange it for a new token with a `quarkus-mcp-service` "
"audience to access the REST server."
msgstr ""
"为了让 MCP `quarkus-mcp-server` 服务器完成 Quarkus MCP 客户端请求，它必须验证令牌是否具有正确的 `quarkus-"
"mcp-server` 受众，并将其交换为具有 `quarkus-mcp-service` 受众的新令牌，以访问 REST 服务器。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Here is how an exchanged token that a Keycloak issues to the MCP server "
"looks like:"
msgstr "下面是 Keycloak 向 MCP 服务器发送的交换令牌的样子："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The token `aud` claim contains a required `quarkus-mcp-service` audience."
msgstr "令牌 `aud` 索赔包含所需的 `quarkus-mcp-service` 受众。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Note this token still retains a record of the original `quarkus-mcp-client` "
"client that acquired the previous token, but also lists `quarkus-mcp-server` "
"as the authorizing party (`azp`)."
msgstr ""
"请注意，该令牌仍保留了获取前一个令牌的 `quarkus-mcp-client` 客户端的原始记录，但也将 `quarkus-mcp-server` "
"列为授权方 ( `azp` )。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Let's try to access both MCP server and REST server without an audience "
"claim."
msgstr "让我们尝试在没有受众请求的情况下访问 MCP 服务器和 REST 服务器。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Ensure the MCP server is <<start-mcp-server,running>> and <<keycloak-"
"setup,Keycloak is configured>>."
msgstr ""
"确保 MCP 服务器正在 xref:start-mcp-server[运行] 并 xref:keycloak-setup[配置了 Keycloak] 。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"In the demo, the OIDC `quarkus-mcp-client` client acquires tokens that are "
"used to access the MCP server."
msgstr "在演示中，OIDC `quarkus-mcp-client` 客户端获取用于访问 MCP 服务器的令牌。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Use the following curl command to acquire a `client_credentials` token for "
"the `quarkus-mcp-client` client, omitting a `quarkus-mcp-server-scope` grant "
"property:"
msgstr ""
"使用以下 curl 命令为 `quarkus-mcp-client` 客户端获取 `client_credentials` 令牌，省略 `quarkus-"
"mcp-server-scope` 授予属性："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"and confirm at https://jwt.io/[jwt.io] that the returned JWT token has no "
"audience claim."
msgstr "并在 link:https://jwt.io/[jwt.io] 上确认返回的 JWT 令牌没有受众要求。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Try to access the MCP server with this token:"
msgstr "尝试使用此令牌访问 MCP 服务器："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "and you will get HTTP 401."
msgstr "就会得到 HTTP 401。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"What about the REST server ? In the demo, the OIDC `quarkus-mcp-server` "
"client acquires tokens that are used to access the REST server."
msgstr "REST 服务器怎么样？在演示中，OIDC `quarkus-mcp-server` 客户端获取用于访问 REST 服务器的令牌。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Use the following curl command to acquire a `client_credentials` token  for "
"the `quarkus-mcp-server` client, omitting a `quarkus-mcp-service-scope` "
"grant property:"
msgstr ""
"使用以下 curl 命令为 `quarkus-mcp-server` 客户端获取 `client_credentials` 令牌，省略 `quarkus-"
"mcp-service-scope` 授予属性："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Try to access the REST server with this token:"
msgstr "尝试使用此令牌访问 REST 服务器："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"You can also enforce a stricter verification by requiring that tokens "
"received by both MCP and REST servers were issued to the `quarkus-mcp-"
"client` and `quarkus-mcp-server` respectively by adding the following "
"configuration fragment to the <<mcp-server-configuration>>:"
msgstr ""
"您还可以强制执行更严格的验证，要求 MCP 和 REST 服务器收到的令牌分别签发给 `quarkus-mcp-client` 和 `quarkus-"
"mcp-server` ，方法是在 <<mcp-server-configuration>> 中添加以下配置片段："

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Note about Resource Indicators"
msgstr "关于资源指标的说明"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"The https://modelcontextprotocol.io/specification/2025-06-18/basic/"
"authorization[latest 2025-06-18 MCP authorization specification] https://"
"modelcontextprotocol.io/specification/2025-06-18/basic/authorization#token-"
"audience-binding-and-validation[requires] the use of https://www.rfc-editor."
"org/rfc/rfc8707.html[OAuth2 Resource Indicators]."
msgstr ""
"link:https://modelcontextprotocol.io/specification/2025-06-18/basic/"
"authorization[最新的 2025-06-18 MCP 授权规范] link:https://modelcontextprotocol.io/"
"specification/2025-06-18/basic/authorization#token-audience-binding-and-"
"validation[要求] 使用 link:https://www.rfc-editor.org/rfc/rfc8707.html[OAuth2 "
"资源指标] 。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"OAuth2 Resource Indicator allows for a fine grained token audience "
"restriction, in the presence of multiple, diverse resource servers that must "
"be accessed with tokens."
msgstr "OAuth2 资源指示器允许在必须使用令牌访问多个不同资源服务器的情况下，对令牌受众进行细粒度限制。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"For a simple demo that we created in this blog post, having a token to "
"contain an audience only is sufficient."
msgstr "对于我们在这篇博文中创建的一个简单演示，只需要一个包含受众的标记就足够了。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"If your provider already supports https://www.rfc-editor.org/rfc/rfc8707."
"html[OAuth2 Resource Indicators] and you need to have a token to also "
"include a resource indicator, configure OIDC client to request it."
msgstr ""
"如果您的提供商已支持 link:https://www.rfc-editor.org/rfc/rfc8707.html[OAuth2 资源指示器] "
"，而您需要一个也包含资源指示器的令牌，请配置 OIDC 客户端以请求该令牌。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"For example, you can add `quarkus.oidc-client.grant.client.extra-params."
"resource=http://localhost:8080/mcp` to the <<poem-service-configuration>>."
msgstr ""
"例如，您可以在 <<poem-service-configuration>> 中添加 `quarkus.oidc-client.grant.client."
"extra-params.resource=http://localhost:8080/mcp` 。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"In this case, to have the MCP server verify that an access token contains a "
"correct resource indicator, add `quarkus.oidc.token.required-claims.resource="
"http://localhost:8080/mcp` to the <<mcp-server-configuration>>."
msgstr ""
"在这种情况下，要让 MCP 服务器验证访问令牌是否包含正确的资源指示符，可在 <<mcp-server-configuration>> 中添加 "
"`quarkus.oidc.token.required-claims.resource=http://localhost:8080/mcp` 。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid "Security Considerations"
msgstr "安全考虑因素"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Ensuring that each participant in your distributed AI system is properly "
"secured and accepts tokens thar are meant to access this participant only is "
"crucial."
msgstr "确保分布式人工智能系统中的每个参与者都有适当的安全保护，并接受只能访问该参与者的令牌，这一点至关重要。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Token audience restriction is one of the key OAuth2 mechanisms that supports "
"this goal, with <<resource-indicator,resource indicators>> allowing to "
"achieve a finer-grained audience restriction."
msgstr ""
"令牌受众限制是支持这一目标的关键 OAuth2 机制之一， xref:resource-indicator[资源指标] 允许实现更精细的受众限制。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"https://datatracker.ietf.org/doc/html/rfc8693[Token exchange] can help to "
"correctly switch the OAuth2 security context when the tokens are flowing in "
"a multi-hop distributed AI application."
msgstr ""
"当 link:https://datatracker.ietf.org/doc/html/rfc8693[令牌] 在多跳分布式人工智能应用中流动时，令牌 "
"link:https://datatracker.ietf.org/doc/html/rfc8693[交换] 有助于正确切换 OAuth2 安全上下文。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"Read more about the https://modelcontextprotocol.io/specification/draft/"
"basic/authorization#access-token-privilege-restriction[Access Token "
"Privilege Restriction] in the https://modelcontextprotocol.io/specification/"
"2025-06-18/basic/authorization[latest 2025-06-18 MCP authorization "
"specification]."
msgstr ""
"阅读 link:https://modelcontextprotocol.io/specification/2025-06-18/basic/"
"authorization[最新 2025-06-18 MCP 授权规范] 中有关 link:https://modelcontextprotocol."
"io/specification/draft/basic/authorization#access-token-privilege-"
"restriction[访问令牌权限限制的] 更多信息。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
msgid "Conclusion"
msgstr "解决方案"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"In this blog post, we demonstrated how https://docs.quarkiverse.io/quarkus-"
"langchain4j/dev/mcp.html[Quarkus MCP Client] can access secure MCP servers "
"by acquiring access tokens using an OAuth2 `client_credentials` grant and "
"propagating them to the secure Quarkus MCP server."
msgstr ""
"在这篇博文中，我们演示了 link:https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp."
"html[Quarkus MCP 客户端] 如何通过使用 OAuth2 `client_credentials` 授权获取访问令牌并将其传播到安全的 "
"Quarkus MCP 服务器，从而访问安全的 MCP 服务器。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"We also looked into restricting tokens to specific audiences and started "
"learning about an important OAuth2 https://datatracker.ietf.org/doc/html/"
"rfc8693[token exchange] grant."
msgstr ""
"我们还研究了将令牌限制给特定受众的问题，并开始了解一项重要的 OAuth2 link:https://datatracker.ietf.org/doc/"
"html/rfc8693[令牌交换] 授权。"

#: _posts/2025-07-23-secure-mcp-oidc-client.adoc
#, fuzzy
msgid ""
"We have more content dedicated to AI and MCP security lined up for you, stay "
"tuned !"
msgstr "我们为您准备了更多有关人工智能和 MCP 安全的内容，敬请期待！"
