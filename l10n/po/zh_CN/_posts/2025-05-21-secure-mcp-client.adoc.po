msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Use Quarkus MCP client to access secure MCP HTTP servers"
msgstr "使用 Quarkus MCP 客户端访问安全的 MCP HTTP 服务器"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Explain how Quarkus LangChain4j MCP client can access MCP HTTP servers with access tokens"
msgstr "解释 Quarkus LangChain4j MCP 客户端如何使用访问令牌访问 MCP HTTP 服务器"

#: _posts/2025-05-21-secure-mcp-client.adoc
msgid "Introduction"
msgstr "简介"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "MCP servers that use the _Streamable HTTP_ or HTTP/SSE transports may require MCP client authentication."
msgstr "使用 _可流 HTTP_ 或 HTTP/SSE 传输的 MCP 服务器可能需要 MCP 客户端验证。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "In the https://quarkus.io/blog/secure-mcp-sse-server/[Getting ready for secure MCP with Quarkus MCP Server] blog post, we explained how to enforce MCP client authentication with the https://github.com/quarkiverse/quarkus-mcp-server[Quarkus MCP Server] and demonstrated how https://quarkus.io/blog/secure-mcp-sse-server/#mcp-server-devui[MCP Server DevUI] can use Keycloak access tokens to access the MCP server in dev mode and how https://quarkus.io/blog/secure-mcp-sse-server/#mcp-inspector[MCP Inspector] and https://quarkus.io/blog/secure-mcp-sse-server/#use-curl-to-access-the-mcp-server[curl] can use GitHub access tokens to access the MCP server in prod mode."
msgstr "在《 link:https://quarkus.io/blog/secure-mcp-sse-server/[使用 Quarkus MCP Server 为安全的 MCP 做好准备] 》博文中，我们介绍了如何使用 link:https://github.com/quarkiverse/quarkus-mcp-server[Quarkus MCP Server] 强化 MCP 客户端身份验证，并演示了 link:https://quarkus.io/blog/secure-mcp-sse-server/#mcp-server-devui[MCP Server DevUI] 如何使用 Keycloak 访问令牌在开发模式下访问 MCP 服务器，以及 link:https://quarkus.io/blog/secure-mcp-sse-server/#mcp-inspector[MCP Inspector] 和 link:https://quarkus.io/blog/secure-mcp-sse-server/#use-curl-to-access-the-mcp-server[curl] 如何使用 GitHub 访问令牌在产品模式下访问 MCP 服务器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "In this blog post, we will explain how https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp.html[Quarkus MCP Client] can use access tokens to access secure MCP servers."
msgstr "在本博文中，我们将介绍 link:https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp.html[Quarkus MCP 客户端] 如何使用访问令牌访问安全的 MCP 服务器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "We will show how to log in to Quarkus LangChain4j AI `Poem Service` application with GitHub OAuth2 and have Google AI Gemini use tools with the help from Quarkus MCP Client that can propagate the GitHub access token to the secure Quarkus MCP Server."
msgstr "我们将展示如何使用 GitHub OAuth2 登录 Quarkus LangChain4j AI `Poem Service` 应用程序，并在 Quarkus MCP 客户端的帮助下让 Google AI 双子座使用工具，将 GitHub 访问令牌传播到安全的 Quarkus MCP 服务器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Demo architecture"
msgstr "演示架构"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "As you can see in the diagram above, the user logs in into the Quarkus REST `Poem Service` application endpoint. To support the user request to create a poem, the `Poem Service` uses `AI Gemini` and requests `MCP Client` to complete a tool call to help `AI Gemini` to find out the name of the logged-in user."
msgstr "如上图所示，用户登录 Quarkus REST `Poem Service` 应用程序端点。为了支持用户创建一首诗的请求， `Poem Service` 使用 `AI Gemini` 并请求 `MCP Client` 完成工具调用，以帮助 `AI Gemini` 查找登录用户的姓名。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "An essential point is that both `Poem Service` and `MCP Client` are part of the same single Quarkus REST application that only users who logged in with GitHub can access. The users do not login to `MCP Client`, they login to the `Poem Service` application, using the `MCP client` is an implementation detail of how this application completes the user request."
msgstr "重要的一点是， `Poem Service` 和 `MCP Client` 都是同一个 Quarkus REST 应用程序的一部分，只有通过 GitHub 登录的用户才能访问。用户登录的不是 `MCP Client` ，而是 `Poem Service` 应用程序，使用 `MCP client` 只是该应用程序如何完成用户请求的一个实现细节。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Therefore, this demo does not demonstrate an implementation of the https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization[MCP Authorization] flow which is primarily of interest to public MCP clients implemented as Single-page applications (SPA), such as as Anthropic Claude, that will be able to initiate a user login into an imported MCP server."
msgstr "因此，本演示并没有展示 link:https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization[MCP 授权] 流程的实施，这主要是以单页应用程序 (SPA) 形式实施的公共 MCP 客户端（如 Anthropic Claude）所感兴趣的，它们将能够启动用户登录到导入的 MCP 服务器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "This demo shows a typical `OAuth2` authorization code flow where a user logs-in to a REST endpoint and authorizes it to access another service on the user's behalf. It also strengthens the message about the https://quarkus.io/blog/gemini-personal-assistant/#integrated-ai-security[AI security being an integral part of your application security]."
msgstr "该演示展示了一个典型的 `OAuth2` 授权代码流，其中用户登录到一个 REST 端点，并授权它代表用户访问另一个服务。这也加强了关于 link:https://quarkus.io/blog/gemini-personal-assistant/#integrated-ai-security[人工智能安全是应用程序安全不可分割的一部分的] 信息。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "For example, let's temporarily update the diagram by removing the `AI Gemini`, replacing `MCP Client` with `REST Client`, `MCP Server` with `Poem Creator service` and `GitHub` with `OAuth2`:"
msgstr "例如，让我们临时更新图表，删除 `AI Gemini` ，用 `REST Client` 替换 `MCP Client` ，用 `Poem Creator service` 替换 `MCP Server` ，用 `OAuth2` 替换 `GitHub` ："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "You will very likely find similarities between this diagram and what you do in your projects. It is the OAuth2 authorization code flow in action: the user logs in to the application and authorizes it to access another service offering a poem creation on the user's behalf."
msgstr "您很可能会发现此图与您在项目中的操作有相似之处。这就是 OAuth2 授权代码流的操作过程：用户登录应用程序并授权它访问另一个代表用户提供诗歌创作的服务。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "The demo shows that Quarkus MCP Client can work effectively in such architectures by being able to use access tokens acquired during the user login, without you having to write any custom code."
msgstr "该演示表明，Quarkus MCP Client 可以使用用户登录时获取的访问令牌，从而在此类架构中有效运行，而无需编写任何自定义代码。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "We are now ready to start working on the `Secure MCP Client Server` demo."
msgstr "我们现在可以开始制作 `Secure MCP Client Server` 演示。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "You can find the complete project source in the https://github.com/quarkiverse/quarkus-langchain4j/tree/main/samples/secure-mcp-sse-client-server[Quarkus LangChain4j Secure MCP Client Server sample]."
msgstr "您可以在 link:https://github.com/quarkiverse/quarkus-langchain4j/tree/main/samples/secure-mcp-sse-client-server[Quarkus LangChain4j 安全 MCP 客户端服务器示例] 中找到完整的项目源代码。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Step 1 - Create and start MCP server"
msgstr "步骤 1 - 创建并启动 MCP 服务器"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "First, let's create a secure Quarkus MCP SSE server."
msgstr "首先，让我们创建一个安全的 Quarkus MCP SSE 服务器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "If you already created the MCP server https://quarkus.io/blog/secure-mcp-sse-server/#initial-mcp-server[as described] in the the https://quarkus.io/blog/secure-mcp-sse-server/[Getting ready for secure MCP with Quarkus MCP Server] blog post, then you will find instructions below familiar and should be able to reuse the project you created earlier with minor updates."
msgstr "如果你已经 link:https://quarkus.io/blog/secure-mcp-sse-server/#initial-mcp-server[按照] link:https://quarkus.io/blog/secure-mcp-sse-server/[\"使用 Quarkus MCP 服务器为安全 MCP 做好准备] \"博文中 link:https://quarkus.io/blog/secure-mcp-sse-server/#initial-mcp-server[的描述] 创建了 link:https://quarkus.io/blog/secure-mcp-sse-server/[MCP] 服务器，那么你会发现下面的说明很熟悉，只需稍作更新就可以重复使用你之前创建的项目。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "MCP server requires authentication to establish Server-Sent Events (SSE) connection and also when invoking the tools. Additionally, the MCP server endpoint that provides access to tools requires that the security identity has a `read:name` permission."
msgstr "MCP 服务器在建立服务器发送事件 (SSE) 连接和调用工具时需要身份验证。此外，提供工具访问权限的 MCP 服务器端点要求安全身份具有 `read:name` 权限。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "MCP server maven dependencies"
msgstr "MCP 服务器 maven 依赖项"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Add the following dependencies:"
msgstr "添加以下依赖项"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`quarkus-mcp-server-sse` is required to support MCP SSE transport."
msgstr "`quarkus-mcp-server-sse` 支持 MCP SSE 传输。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`quarkus-oidc` is required to secure access to MCP SSE endpoints. Its version is defined in the Quarkus BOM."
msgstr "`quarkus-oidc` 是确保 MCP SSE 端点访问安全所必需的。其版本已在 Quarkus BOM 中定义。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`quarkus-hibernate-orm-panache` and `quarkus-jdbc-postgresql` are required to support the <<security-identity-augmentation>>. Their versions are defined in the Quarkus BOM."
msgstr "`quarkus-hibernate-orm-panache` 和 是支持 所必需的。它们的版本已在 Quarkus BOM 中定义。 `quarkus-jdbc-postgresql` <<security-identity-augmentation>>"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "MCP server tool"
msgstr "MCP 服务器工具"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Let's create a tool that can return the name of the currently logged-in user. It can be invoked only if the current MCP request is authenticated but also if the security identity has a `read:name` permission:"
msgstr "让我们创建一个可以返回当前登录用户名称的工具。只有当当前的 MCP 请求已通过身份验证，而且安全身份具有 `read:name` 权限时，才能调用该工具："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Provide a tool that can return the name of the current user."
msgstr "提供一个可以返回当前用户名的工具。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid ""
"Require authenticated tool access with an additional authorization `read:name` permission constraint - yes, the only difference with an unauthenticated MCP server tool is `@PermissionsAllowed(\"read:name\")`, that's it!\n"
"See also how the main MCP SSE endpoint is secured in the <<mcp-server-configuration>> section below."
msgstr "要求经过身份验证的工具访问，并附加授权 `read:name` 权限约束 - 是的，与未经身份验证的 MCP 服务器工具的唯一区别是 `@PermissionsAllowed(\"read:name\")` ，仅此而已！另请参阅下面的 <<mcp-server-configuration>> 部分，了解主要 MCP SSE 端点是如何确保安全的。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Use the injected `SecurityIdentity` to return the current user's name. Alternatively, it can be acquired from the injected `quarkus.oidc.UserInfo`."
msgstr "使用注入的 `SecurityIdentity` 返回当前用户的名称。或者，也可以从注入的 `quarkus.oidc.UserInfo` 获取。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Security Identity Augmentation"
msgstr "安全身份增强"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "To meet the `@PermissionsAllowed(\"read:name\")` authorization constraint, the security identity created after verifying the GitHub access token must be augmented to have a `read:name` permission."
msgstr "为满足 `@PermissionsAllowed(\"read:name\")` 授权约束，在验证 GitHub 访问令牌后创建的安全身份必须增加 `read:name` 权限。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "The demo expects that a database has a record with a GitHub account name and the assigned permission. The security identity augmentor uses the identity name to retrieve this record and enhance the identity with the discovered permission."
msgstr "该演示预计数据库中会有一条包含 GitHub 账户名和分配权限的记录。安全身份增强器使用身份名称检索该记录，并使用发现的权限增强身份。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Let's see how this rather complex task can be easily achieved in Quarkus."
msgstr "让我们看看如何在 Quarkus 中轻松完成这项相当复杂的任务。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "First, we create a Panache entity that keeps the account name and permission values:"
msgstr "首先，我们创建一个保存账户名称和权限值的 Panache 实体："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Utility method to find an identity record with a matching GitHub account name."
msgstr "实用程序方法，用于查找与 GitHub 账户名匹配的身份记录。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Second, we create an `import.sql` script to have a demo record added to the database:"
msgstr "其次，我们创建一个 `import.sql` 脚本，将演示记录添加到数据库中："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Insert a demo record. You will provide your GitHub account name when starting MCP server."
msgstr "插入演示记录。启动 MCP 服务器时，您将提供自己的 GitHub 账户名。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Finally, we create a security identity augmentor:"
msgstr "最后，我们创建一个安全身份增强器："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Custom `SecurityIdentityAugmentor` can augment the already verified security identity."
msgstr "自定义 `SecurityIdentityAugmentor` 可以增强已验证的安全身份。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Run the augmentation in a blocking mode because it requires access to the database."
msgstr "以阻塞模式运行增强程序，因为它需要访问数据库。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Find the recorded `Identity` matching the current user's name."
msgstr "查找与当前用户名匹配的录音 `Identity` 。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Initialize a security identity builder from the current identity."
msgstr "从当前身份初始化安全身份构建器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Add the permission allocated to this user and create an updated `SecurityIdentity`."
msgstr "添加分配给该用户的权限，并创建更新后的 `SecurityIdentity` 。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "This is all, the augmentation step is done with a few lines of code only."
msgstr "仅此而已，增强步骤只需几行代码即可完成。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "MCP Server Configuration"
msgstr "MCP 服务器配置"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Let's configure our secure MCP server:"
msgstr "让我们配置安全的 MCP 服务器："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Enable MCP server traffic logging"
msgstr "启用 MCP 服务器流量日志"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Enforce an authenticated access to the main MCP SSE endpoint during the initial handshake. See also how the tool is secured with an annotation in the <<mcp-server-tool>> section above, though you can also secure access to the tool by listing both main and tools endpoints in the configuration, for example: `quarkus.http.auth.permission.authenticated.paths=/mcp/sse,/mcp/messages/*`."
msgstr "在初始握手过程中，强制执行对主 MCP SSE 端点的验证访问。另请参阅上文 <<mcp-server-tool>> 部分的注释，了解如何确保工具的安全，当然也可以通过在配置中同时列出主端点和工具端点来确保工具的访问安全，例如： `quarkus.http.auth.permission.authenticated.paths=/mcp/sse,/mcp/messages/*` 。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Requires that only GitHub access tokens can be used to access MCP server."
msgstr "要求只能使用 GitHub 访问令牌访问 MCP 服务器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "By default, `quarkus.oidc.provider=github` supports an authorization code flow only. `quarkus.oidc.application-type=service` overrides it and requires the use of bearer tokens."
msgstr "默认情况下， `quarkus.oidc.provider=github` 只支持授权码流。 `quarkus.oidc.application-type=service` 会覆盖授权码流，并要求使用承载令牌。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Database that keeps the identity records is supported by the PostgreSQL DevService."
msgstr "PostgreSQL DevService 支持保存身份记录的数据库。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Start MCP server on port `8081` - this is done for the Quarkus LangChain4j `Poem Service` application that uses an MCP client to be able to start on the default `8080` port."
msgstr "在 `8081` 端口启动 MCP 服务器--这样做是为了让使用 MCP 客户端的 Quarkus LangChain4j `Poem Service` 应用程序能够在默认 `8080` 端口启动。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Start the MCP server in dev mode"
msgstr "以开发模式启动 MCP 服务器"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Use your GitHub account name, for example, `mvn quarkus:dev -Duser.name=\"John Doe\"`. It is required to correctly import the user name and permission data to the database."
msgstr "请使用您的 GitHub 账户名，例如 `mvn quarkus:dev -Duser.name=\"John Doe\"` 。这样才能将用户名和权限数据正确导入数据库。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "The MCP server's security-related configuration remains exactly the same in prod mode, therefore we are not going to talk about running the MCP server in prod to save some blog post space. Please check the https://github.com/quarkiverse/quarkus-langchain4j/tree/main/samples/secure-mcp-sse-client-server[Quarkus LangChain4j Secure MCP Client Server sample] if you would like to run MCP server in prod mode - you will only need to make sure PostresSQL is available in prod mode too."
msgstr "MCP 服务器的安全相关配置在 prod 模式下完全相同，因此为了节省博文篇幅，我们不打算讨论在 prod 模式下运行 MCP 服务器的问题。如果你想在prod模式下运行MCP服务器，请查看 link:https://github.com/quarkiverse/quarkus-langchain4j/tree/main/samples/secure-mcp-sse-client-server[Quarkus LangChain4j安全MCP客户端服务器示例] --你只需要确保PostresSQL在prod模式下也是可用的。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Step 2 - Create and start Poem Service that uses AI Gemini and MCP client"
msgstr "第 2 步 - 创建并启动使用 AI 双子座和 MCP 客户端的诗歌服务"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "The MCP server is now running and ready to accept tool calls. Let's create an AI `Poem Service` that will work with AI Gemini and use an MCP client to complete tool calls."
msgstr "MCP 服务器现在已经运行，可以接受工具调用。让我们创建一个 AI `Poem Service` ，它将与 AI 双子座一起工作，并使用 MCP 客户端完成工具调用。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Poem Service Maven dependencies"
msgstr "诗歌服务 Maven 依赖项"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`quarkus-langchain4j-ai-gemini` brings support for AI Gemini."
msgstr "`quarkus-langchain4j-ai-gemini` 带来了对人工智能双子座的支持。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`quarkus-langchain4j-mcp` provides core MCP Client support."
msgstr "`quarkus-langchain4j-mcp` 提供核心 MCP 客户端支持。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`quarkus-langchain4j-oidc-mcp-auth-provider` provides an implementation of https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp.html#_authorization[McpClientAuthProvider] that can supply access tokens acquired during the GitHub OAuth2 authorization code flow."
msgstr "`quarkus-langchain4j-oidc-mcp-auth-provider` 提供了一个 link:https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp.html#_authorization[McpClientAuthProvider] 的实现，它可以提供在 GitHub OAuth2 授权代码流中获取的访问令牌。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`quarkus-oidc` supports GitHub OAuth2 login to secure access to `Poem Service`. Its version is defined in the Quarkus BOM."
msgstr "`quarkus-oidc` 支持 GitHub OAuth2 登录，以确保对 的访问安全。其版本已在 Quarkus BOM 中定义。 `Poem Service`"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`quarkus-rest-qute` generates an HTML page to welcome the logged-in user. Its version is defined in the Quarkus BOM."
msgstr "`quarkus-rest-qute` 生成欢迎登录用户的 HTML 页面。其版本已在 Quarkus BOM 中定义。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Register GitHub OAuth2 application"
msgstr "注册 GitHub OAuth2 应用程序"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Register a GitHub OAuth2 application that you will authorize when logging in to the `Poem Service` application."
msgstr "注册一个 GitHub OAuth2 应用程序，在登录 `Poem Service` 应用程序时对其进行授权。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Follow the https://quarkus.io/guides/security-openid-connect-providers#github[GitHub OAuth2 registration] process, and make sure to register the `http://localhost:8080/login` callback URL."
msgstr "按照 link:https://quarkus.io/guides/security-openid-connect-providers#github[GitHub OAuth2 注册] 流程操作，确保注册了 `http://localhost:8080/login` 回调 URL。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Use the generated GitHub client id and secret to either set `GITHUB_CLIENT_ID` and `GITHUB_CLIENT_SECRET` environment properties or update the `quarkus.oidc.client-id=${github_client_id}` and `quarkus.oidc.credentials.secret=${github_client_secret}` properties in application.properties by replacing `${github_client_id}` with the generated client id and `${github_client_secret}` with the generated client secret."
msgstr "使用生成的 GitHub 客户端 id 和秘密设置 `GITHUB_CLIENT_ID` 和 `GITHUB_CLIENT_SECRET` 环境属性，或更新 application.properties 中的 `quarkus.oidc.client-id=${github_client_id}` 和 `quarkus.oidc.credentials.secret=${github_client_secret}` 属性，将 `${github_client_id}` 替换为生成的客户端 id，将 `${github_client_secret}` 替换为生成的客户端秘密。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "By default, Quarkus GitHub provider submits the client id and secret in the HTTP Authorization header. However, GitHub may require that both client id and secret are submitted as form parameters instead."
msgstr "默认情况下，Quarkus GitHub 提供商会在 HTTP 授权头中提交客户 ID 和秘密。不过，GitHub 可能会要求以表单参数的形式提交客户端 id 和秘密。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "If you get HTTP 401 error after logging in to GitHub and being redirected back to Quarkus MCP server, try to replace `quarkus.oidc.credentials.secret=${github.client.secret}` property with the following two properties instead:"
msgstr "如果登录 GitHub 后出现 HTTP 401 错误并被重定向回 Quarkus MCP 服务器，请尝试用以下两个属性替换 `quarkus.oidc.credentials.secret=${github.client.secret}` 属性："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "AI Gemini API key"
msgstr "AI 双子座应用程序接口密钥"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "`Poem Service` relies on AI Gemini to create a poem for the logged-in user."
msgstr "`Poem Service` 依靠 AI 双子座为登录用户创作一首诗。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Get https://aistudio.google.com/app/apikey[AI Gemini API key] and either set an `AI_GEMINI_API_KEY` environment property or update the `quarkus.langchain4j.ai.gemini.api-key=${ai_gemini_api_key}` property in `application.properties` by replacing `${ai_gemini_api_key}` with the API key value."
msgstr "获取 link:https://aistudio.google.com/app/apikey[AI 双子座 API 密钥] ，然后设置 `AI_GEMINI_API_KEY` 环境属性，或用 API 密钥值替换 `${ai_gemini_api_key}` 更新 `application.properties` 中的 `quarkus.langchain4j.ai.gemini.api-key=${ai_gemini_api_key}` 属性。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "GitHub Login Endpoint"
msgstr "GitHub 登录端点"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "The `Poem Service` needs to have an endpoint that manages a GitHub OAuth2 login. Typically, such an endpoint welcomes the logged-in user and offers links for the user to navigate to the rest of the secured application."
msgstr "`Poem Service` 需要有一个管理 GitHub OAuth2 登录的端点。通常情况下，这样的端点会欢迎登录的用户，并提供链接供用户浏览安全应用程序的其他部分。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Let's implement this login endpoint:"
msgstr "让我们来实现这个登录端点："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Require an authenticated access. It forces an authorization code flow for users who did not login with GitHub yet and a session verification for the already authenticated users."
msgstr "要求经过身份验证的访问。对于尚未登录 GitHub 的用户，它将强制执行授权代码流；对于已通过身份验证的用户，它将强制执行会话验证。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "GitHub access tokens are binary and Quarkus OIDC indirectly verifies them by using them to request GitHub specific `UserInfo` representation."
msgstr "GitHub 访问令牌是二进制的，Quarkus OIDC 通过使用这些令牌请求 GitHub 特定的 `UserInfo` 表示法来间接验证它们。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "After the user logs in to GitHub and is redirected to this endpoint, an HTML page with a user name and a link to the <<jaxrs-poem-resource,Poem Resource endpoint>> is generated with a simple https://github.com/quarkiverse/quarkus-langchain4j/blob/main/samples/secure-mcp-sse-client-server/secure-mcp-client/src/main/resources/templates/poem.html[Qute template] and returned to the user."
msgstr "用户登录 GitHub 并被重定向到该端点后，系统会使用简单的 link:https://github.com/quarkiverse/quarkus-langchain4j/blob/main/samples/secure-mcp-sse-client-server/secure-mcp-client/src/main/resources/templates/poem.html[Qute 模板] 生成一个带有用户名和 xref:jaxrs-poem-resource[诗歌资源端点] 链接的 HTML 页面，并返回给用户。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Create Poem Resource endpoint"
msgstr "创建诗歌资源端点"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "The `Poem Resource` endpoint accepts poem requests from authenticated users and delegates these requests to AI `Poem Service` that uses `AI Gemini`. `AI Gemini` relies on the MCP client to get the name of the logged-in user."
msgstr "`Poem Resource` 端点接受通过身份验证的用户的诗歌请求，并将这些请求委托给使用 `AI Gemini` 的 AI `Poem Service` 。 `AI Gemini` 依靠 MCP 客户端获取登录用户的名称。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Require authenticated poem requests."
msgstr "要求验证诗歌请求。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "AI Poem Service interface."
msgstr "人工智能诗歌服务界面。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Refer to the MCP client `user-name` configuration, see the <<poem-service-configuration>> section below."
msgstr "请参阅 MCP 客户端 `user-name` 配置，见下文 <<poem-service-configuration>> 部分。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Poem Service Configuration"
msgstr "诗歌服务配置"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Let's see how the `Poem Service` configuration looks like:"
msgstr "让我们来看看 `Poem Service` 配置是怎样的："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Enable MCP client HTTP transport. In this demo we use SSE, with `Streamable HTTP` to be supported in the future."
msgstr "启用 MCP 客户端 HTTP 传输。在本演示中，我们使用 SSE，今后将支持 `Streamable HTTP` 。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Point to the Quarkus MCP server endpoint that you started in the <<start-mcp-server>> step."
msgstr "指向在 <<start-mcp-server>> 步骤中启动的 Quarkus MCP 服务器端点。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Require GitHub OAuth2 login."
msgstr "需要 GitHub OAuth2 登录。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "GitHub client id and secret that were generated during the <<register-github-application>> step."
msgstr "在 <<register-github-application>> 步骤中生成的 GitHub 客户端 ID 和密码。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "AI Gemini key that you acquired during the <<ai-gemini-key>> step."
msgstr "在 <<ai-gemini-key>> 步骤中获得的 AI 双子座钥匙。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Enable AI Gemini request and response logging"
msgstr "启用 AI 双子座请求和响应日志功能"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Please pay attention to the fact that the MCP client configuration has a `user-name` name. You referred to this configuration with the `@McpToolBox(\"user-name\")` annotation in the <<jaxrs-poem-resource>> step."
msgstr "请注意，MCP 客户端配置有一个 `user-name` 名称。您在 <<jaxrs-poem-resource>> 步骤中使用 `@McpToolBox(\"user-name\")` 注释引用了该配置。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Start Poem Service in dev mode"
msgstr "以开发模式启动诗歌服务"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "All the Poem Service configuration remains exactly the same in prod mode, therefore we are not going to talk about running it in prod to save some blog post space. Please check the https://github.com/quarkiverse/quarkus-langchain4j/tree/main/samples/secure-mcp-sse-client-server[Quarkus LangChain4j Secure MCP Client Server sample] if you would like to run it in prod mode."
msgstr "在 prod 模式下，Poem 服务的所有配置都完全相同，因此，为了节省博文篇幅，我们将不再讨论在 prod 模式下运行 Poem 服务的问题。如果你想在 prod 模式下运行它，请查看 link:https://github.com/quarkiverse/quarkus-langchain4j/tree/main/samples/secure-mcp-sse-client-server[Quarkus LangChain4j 安全 MCP 客户端服务器示例] 。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "We are ready to test our AI `Poem Service` application."
msgstr "我们已经准备好测试我们的人工智能 `Poem Service` 应用程序。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Step 3 - Test Poem Service"
msgstr "步骤 3 - 测试诗歌服务"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Access http://localhost:8080 and login to `Poem Service`:"
msgstr "访问 http://localhost:8080 并登录 `Poem Service` ："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "You should get a response with your name and a link to the `Poem Service` endpoint:"
msgstr "您应该会收到一个包含您的姓名和 `Poem Service` 端点链接的回复："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "At this point, Quarkus MCP Client was not involved in getting your name produced, it was done by the <<github-login-endpoint>>."
msgstr "此时，Quarkus MCP 客户端并不参与制作您的姓名，而是由 <<github-login-endpoint>> 完成。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Click on the link to get a poem created and have AI Gemini producing a poem about Java for you:"
msgstr "点击链接获取诗歌创作，让 AI 双子座为您创作一首关于 Java 的诗歌："

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "This time, Quarkus MCP Client helped AI Gemini to get your name from the secure Quarkus MCP server."
msgstr "这一次，Quarkus MCP 客户端帮助 AI 双子座从安全的 Quarkus MCP 服务器上获取了您的姓名。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Access token delegation considerations"
msgstr "访问令牌授权注意事项"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "In general, access tokens issued by social providers such as GitHub are not designed to be used in your distributed application architecture, with a service such as `Poem Service` accessing GitHub API indirectly through another service such as `Quarkus MCP server`."
msgstr "一般来说，由 GitHub 等社交服务提供商发放的访问令牌并不适合在分布式应用程序架构中使用，因为 `Poem Service` 等服务会通过 `Quarkus MCP server` 等其他服务间接访问 GitHub API。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Quarkus REST service that has users logged in with GitHub can access GitHub API directly. For example, `Poem Service` can use a great Quarkus LangChain4j capability to mark REST Clients as tools to access GitHub API. See how https://quarkus.io/blog/gemini-personal-assistant/#implementation[it was done with the Google Calendar service]."
msgstr "用户登录 GitHub 的 Quarkus REST 服务可以直接访问 GitHub API。例如， `Poem Service` 可以使用 Quarkus LangChain4j 的强大功能，将 REST 客户端标记为访问 GitHub API 的工具。看看 link:https://quarkus.io/blog/gemini-personal-assistant/#implementation[Google Calendar 服务是] 如何 link:https://quarkus.io/blog/gemini-personal-assistant/#implementation[实现的] 。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "In this demo, we show the https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp.html[Quarkus MCP Client]'s capability to interoperate with MCP servers and use access tokens to access secure MCP servers. We use GitHub OAuth2 because it is easily accessible to most developers."
msgstr "在本演示中，我们将展示 link:https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp.html[Quarkus MCP 客户端] 与 MCP 服务器互操作的能力，以及使用访问令牌访问安全 MCP 服务器的能力。我们使用 GitHub OAuth2，因为大多数开发人员都能轻松访问。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Providers such as `Keycloak` and `Auth0` can create access tokens that are meant to be propagated from one service to another one. You will quite likely have your Quarkus MCP server implementations dealing with such tokens in the enterprise. Alternatively, when possible, the AI service application which accepts an authenticated user can request the token issuer to exchange its access token for another token that will be used to access the downstream MCP Server instead."
msgstr "`Keycloak` 和 `Auth0` 等提供商可以创建访问令牌，以便从一个服务传播到另一个服务。在企业中，您很可能会让您的 Quarkus MCP 服务器实施来处理此类令牌。或者，在可能的情况下，接受已验证用户的人工智能服务应用程序可以请求令牌发行者将其访问令牌换成另一个令牌，用于访问下游 MCP 服务器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Quarkus AI Service applications may have to and can support a delegation flow such as `GitHub access token -> Poem Service -> MCP Client -> MCP Server tool -> GitHub API` with additional security measures that the Quarkus team wil discuss in the future blog posts and the identity augmentation like the one shown in this demo."
msgstr "Quarkus AI 服务应用程序可能必须也可以支持 `GitHub access token → Poem Service → MCP Client → MCP Server tool → GitHub API` 这样的授权流，并采取额外的安全措施，Quarkus 团队将在未来的博客文章中讨论这些措施，并支持本演示中所示的身份增强功能。"

#: _posts/2025-05-21-secure-mcp-client.adoc
msgid "Conclusion"
msgstr "解决方案"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "In this blog post, we demonstrated how https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp.html[Quarkus MCP Client] can access secure MCP servers by propagating access tokens available to the Quarkus LangChain4j AI Service application after the OAuth2 authorization code flow is complete."
msgstr "在这篇博文中，我们演示了 link:https://docs.quarkiverse.io/quarkus-langchain4j/dev/mcp.html[Quarkus MCP Client] 如何在 OAuth2 授权代码流完成后，通过向 Quarkus LangChain4j AI 服务应用程序传播可用的访问令牌来访问安全的 MCP 服务器。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Stay tuned for more upcoming blog posts about using MCP securely with Quarkus MCP client and MCP Server."
msgstr "请继续关注我们即将发布的更多博文，了解如何通过 Quarkus MCP 客户端和 MCP 服务器安全地使用 MCP。"

#: _posts/2025-05-21-secure-mcp-client.adoc
#, fuzzy
msgid "Enjoy !"
msgstr "享受 ！"
