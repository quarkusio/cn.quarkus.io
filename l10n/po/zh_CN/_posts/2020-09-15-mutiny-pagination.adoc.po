# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, fuzzy, no-wrap
msgid "cescoffier"
msgstr "鹤壁市"

#. type: YAML Front Matter: date
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, fuzzy, no-wrap
msgid "2020-09-15"
msgstr "2020-09-15"

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "职位"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, fuzzy, no-wrap
msgid "How to use API using pagination with Mutiny"
msgstr "如何利用Mutiny的分页功能来使用API"

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, fuzzy, no-wrap
msgid "reactive rest mutiny http pagination"
msgstr "反应性休息叛变http分页"

#. type: YAML Front Matter: title
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, fuzzy, no-wrap
msgid "Handling paginated APIs with Mutiny"
msgstr "用Mutiny处理分页的API"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:17
#, fuzzy
msgid "At the beginning of the Mutiny adventure, my friend Alex came to me with an interesting problem.  Alex wanted to retrieve data from a REST service in a reactive manner.  So far, no problem, we have everything for this in our toolbox.  But, this service, as many services, is using pagination.  Ah! That makes things a bit more spicy.  Alex wanted to retrieve all the items and consume them as a stream, but you can't retrieve the items in one batch.  You need to invoke the service for every page, extract the items and feed the stream."
msgstr "在Mutiny冒险的开始，我的朋友Alex带着一个有趣的问题来找我。Alex想以一种反应式的方式从一个REST服务中获取数据。到目前为止，没有问题，我们的工具箱里已经有了这方面的一切。但是，这个服务，和许多服务一样，正在使用分页。啊！这让事情变得有点辣手了。Alex想检索所有的项目，并把它们作为一个流来消费，但你不能一次性检索这些项目。你需要为每一个页面调用服务，提取项目并提供流。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:20
#, fuzzy
msgid "So, how to achieve this in a reactive manner and build a proper stream of items without loosing your sanity? Let's have a look!"
msgstr "那么，如何以被动的方式实现这一目标，并在不丧失理智的情况下建立一个适当的项目流？让我们来看看!"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:22
#, fuzzy
msgid "## The Punk API"
msgstr "朋克API\n"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:27
#, fuzzy
msgid "First, we need an API.  Alex introduced me to the https://punkapi.com/documentation/v2[Punk API], a REST API to retrieve beers.  That's fun, and even better, it uses pagination.  We got our API!"
msgstr "首先，我们需要一个API。Alex向我介绍了 link:https://punkapi.com/documentation/v2[Punk API] ，一个检索啤酒的REST API。这很有趣，而且更好的是，它使用分页。我们得到了我们的API!"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:29
#, fuzzy
msgid "If you call `https://api.punkapi.com/v2/beers?page=1`, you get a JSON array like:"
msgstr "如果你调用 `<a href=\"https://api.punkapi.com/v2/beers?page=1\" class=\"bare\">https://api.punkapi.com/v2/beers?page=1</a>` ，你会得到一个JSON数组，比如。"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:41
#, no-wrap
msgid ""
"[\n"
"    {\n"
"        first beer\n"
"    },\n"
"    {\n"
"        second beer\n"
"    }, \n"
"    // ...\n"
"]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:48
#, fuzzy
msgid "I won't show discuss the content of each object, the documentation page does a great job about that.  Let's focus on the pagination aspect.  First, we passed the `page` query parameter, indicating which page we want.  Generally, when you retrieve a page, the API provides a way to know if there is a next page (a special field in the JSON document, or HTTP header), but the Punk API does not provide any hint.  So, to retrieve all the beers, we need to invoke the service for page 1, 2, 3... until the returned JSON array is empty."
msgstr "我不会展示讨论每个对象的内容，文档页在这方面做得很好。让我们专注于分页方面。首先，我们传递了 `page` 查询参数，表明我们想要哪一页。一般来说，当你检索一个页面时，API会提供一种方法来知道是否有下一页（JSON文档中的一个特殊字段，或HTTP头），但Punk API没有提供任何提示。所以，为了检索所有的啤酒，我们需要调用第1、2、3......页的服务，直到返回的JSON数组为空。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:50
#, fuzzy
msgid "In an imperative world, to retrieve all the beers, you would do something like this:"
msgstr "在一个命令式的世界里，为了检索所有的啤酒，你会做这样的事情。"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:61
#, no-wrap
msgid ""
"List<Beer> beers = ...;\n"
"int page = 1;\n"
"List<Beer> batch = ...\n"
"do {\n"
"  batch= getBeersFromPage(page);\n"
"  beers.addAll(batch);\n"
"  page = page + 1;\n"
"} while (! batch.isEmpty());\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:64
#, fuzzy
msgid "How can we achieve the same in a reactive manner and build a stream of beer?"
msgstr "我们如何以被动的方式实现同样的目标，并建立一个啤酒流？"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:66
#, fuzzy
msgid "image:/assets/images/posts/mutiny-pagination/mutiny-pagination.png[]"
msgstr "image:/assets/images/posts/mutiny-pagination/mutiny-pagination.png[alt=\"mutiny pagination\"]"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:68
#, fuzzy
msgid "Let's proceed step by step."
msgstr "让我们一步一步地进行。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:70
#, fuzzy
msgid "## Retrieving a single page"
msgstr "检索单页\n"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:73
#, fuzzy
msgid "First, we need to see how we can retrieve a single page.  I'm going to use the Vert.x Web Client, but you can use any reactive HTTP clients providing a Mutiny API."
msgstr "首先，我们需要看看如何检索一个单页。我将使用Vert.x Web客户端，但你可以使用任何提供Mutiny API的反应式HTTP客户端。"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:82
#, no-wrap
msgid ""
"// Create the client\n"
"WebClient client = WebClient.create(vertx, new WebClientOptions()\n"
"      .setDefaultHost(\"api.punkapi.com\")\n"
"      .setDefaultPort(443)\n"
"      .setSsl(true)\n"
");\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:87
#, no-wrap
msgid ""
"// Retrieve the first page\n"
"Uni<List<Beer>> uni = client.get(\"/v2/beers?page=1\")\n"
"      .send()\n"
"      .onItem().transform(Pagination::toListOfBeer);\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:91
#, fuzzy
msgid "This snippet creates the web client.  Then, we use that client and retrieve the first page."
msgstr "这个片段创建了网络客户端。然后，我们使用该客户端并检索第一个页面。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:93
#, fuzzy
msgid "When we receive the result (`onItem`), we transform the JSON array into a list of beers."
msgstr "当我们收到结果( `onItem` )时，我们将JSON数组转化为啤酒列表。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:95
#, fuzzy
msgid "Let's extract this code in a method and take the page number as parameter:"
msgstr "让我们在一个方法中提取这段代码，并把页码作为参数。"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:103
#, no-wrap
msgid ""
"private static Uni<List<Beer>> getPage(WebClient client, int page) {\n"
"    return client.get(\"/v2/beers?page=\" + page)\n"
"            .send()\n"
"            .onItem().transform(Pagination::toListOfBeer);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:106
#, fuzzy
msgid "So far, so good."
msgstr "到目前为止，一切都很好。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:108
#, fuzzy
msgid "## Retrieving multiple page"
msgstr "检索多个页面\n"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:111
#, fuzzy
msgid "So, now, we know how to retrieve a single page and extract the items from it.  We just need to repeat this operation for every page, and provide a stream."
msgstr "所以，现在，我们知道如何检索一个单一的页面，并从中提取项目。我们只需要对每个页面重复这个操作，并提供一个流。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:116
#, fuzzy
msgid "Mutiny provides a method to create a `Multi` by repeating multiple times a `Uni`.  Under the hood, it calls a method returning a `Uni` and subscribe on it.  But we need to make _progress_, and pass the current page.  Mutiny offers the possibility to store a state in order to let the method creating the `Uni` increments the page number:"
msgstr "Mutiny提供了一种方法，通过多次重复一个 `Uni` ，来创建一个 `Multi` 。在引擎盖下，它调用一个方法返回一个 `Uni` ，并对其进行订阅。但我们需要取得 _进展_ ，并传递当前页面。Mutiny提供了存储一个状态的可能性，以便让创建 `Uni` 的方法增加页码。"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:122
#, no-wrap
msgid ""
"Multi.createBy().repeating().uni(AtomicInteger::new, page ->\n"
"\t\tgetPage(client, page.incrementAndGet())\n"
")\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:127
#, fuzzy
msgid "This code above creates a stream with the item emitted by the `Unis` returned by the `getPage` method.  We increment the page number (stored in an `AtomicInteger`) every time.  So, it retrieves the page 1, 2, 3 ... and every time emits the received `List<Beer>` downstream."
msgstr "上面这段代码用 `getPage` 方法返回的 `Unis` 所发出的项目创建一个流。我们每次都会递增页码（存储在 `AtomicInteger` ）。所以，它检索第1、2、3页......，每次都向下游发射收到的 `List<Beer>` 。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:130
#, fuzzy
msgid "However, at some point, we must stop.  As we said earlier, we can stop when the returned list is empty:"
msgstr "然而，在某些时候，我们必须停止。正如我们前面所说，我们可以在返回的列表为空时停止。"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:137
#, no-wrap
msgid ""
"Multi<List<Beer>> multi = Multi.createBy().repeating().uni(AtomicInteger::new, page ->\n"
"     getPage(client, page.incrementAndGet())\n"
")\n"
".until(List::isEmpty);\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:142
#, fuzzy
msgid "The `until` clause indicates when the iteration must be stopped.  It receives the retrieved list (produced by `getPage`), and when this list is empty, stops the repetition.  If the list still contains beers, it retrieves the next page."
msgstr " `until` 子句指出何时必须停止迭代。它接收检索到的列表（由 `getPage` 产生），当这个列表为空时，停止重复。如果列表中仍然有豆子，它就检索下一页。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:144
#, fuzzy
msgid "## Unpacking the beers"
msgstr "拆开啤酒的包装\n"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:148
#, fuzzy
msgid "We now have a stream of list, and each list contain a set of beers.  We are almost there, but Alex wants a stream of beer.  So we need to unpack the beers."
msgstr "我们现在有一个列表流，每个列表包含一组啤酒。我们就快成功了，但是Alex想要一个啤酒流。所以我们需要解开啤酒的包装。"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:150
#, fuzzy
msgid "The first approach to achieve this uses `transformToMultiAndConcatenate`, i.e. for each list create a new `multi` with the contained beers and concatenate these `multis`:"
msgstr "实现这一目标的第一种方法是使用 `transformToMultiAndConcatenate` ，即为每个列表创建一个包含啤酒的新 `multi` ，并将这些 `multis` 。"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:158
#, no-wrap
msgid ""
"Multi<Beer> multi = Multi.createBy().repeating().uni(AtomicInteger::new, page ->\n"
"        getPage(client, page.incrementAndGet())\n"
"    )\n"
"    .until(List::isEmpty)\n"
"    .onItem().transformToMultiAndConcatenate(l -> Multi.createFrom().iterable(l));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:161
#, fuzzy
msgid "Wondering about `concatenate`? Check out this https://quarkus.io/blog/mutiny-redis/[other blog post]"
msgstr "想知道 `concatenate` ?请看 link:https://quarkus.io/blog/mutiny-redis/[另一篇博文]"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:163
#, fuzzy
msgid "image:/assets/images/posts/mutiny-pagination/disjoint.png[]"
msgstr "image:/assets/images/posts/mutiny-pagination/disjoint.png[alt=\"disjoint\"]"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:165
#, fuzzy
msgid "Because this is a common operation, Mutiny provides the `disjoint` method doing exactly the same:"
msgstr "因为这是一个常见的操作，Mutiny提供了 `disjoint` 方法，做得完全一样。"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:173
#, no-wrap
msgid ""
"Multi<Beer> multi = Multi.createBy().repeating().uni(AtomicInteger::new, page ->\n"
"    getPage(client, page.incrementAndGet())\n"
")\n"
"  .until(List::isEmpty)\n"
"  .onItem().disjoint();\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:176
#, fuzzy
msgid "And we are done!"
msgstr "我们已经完成了!"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:178
msgid "## The benefits of reactive"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:181
msgid "We have our stream, it's time to use it! Let's, for example, retrieve the first 10 beers with \"IPA\" (let's be trendy) in their description:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:187
#, no-wrap
msgid ""
"multi\n"
"    .transform().byFilteringItemsWith(beer -> beer.description.contains(\"IPA\"))\n"
"    .transform().byTakingFirstItems(10);\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:193
msgid "The advantage of our stream is that we won't retrieve every page.  As soon as we have enough beers, we stop the repetition.  How? Because it informs the upstream that it does not need more items (*cancellation*) and that stops the repetition.  So, retrieving items from paginated APIs this way can reduce the number of requests and, as a consequence the load on the remote service."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:195
msgid "## Feel thirsty?"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:198
msgid "Wanna try this code, checkout this https://gist.github.com/cescoffier/18a326a5c057392bec54d95ec5a06ca6[gist].  You can run it immediately with jbang:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:202
#, no-wrap
msgid "jbang https://gist.github.com/cescoffier/18a326a5c057392bec54d95ec5a06ca6\n"
msgstr ""
