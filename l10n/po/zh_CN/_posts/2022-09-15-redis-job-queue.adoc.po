# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-09-12 12:15+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: title
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "How to implement a job queue with Redis"
msgstr "如何用Redis实现一个作业队列"

#. type: YAML Front Matter: synopsis
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "Implementing a job queue using Redis list and the Quarkus Redis extension"
msgstr "使用Redis列表和Quarkus Redis扩展实现一个作业队列"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"In https://quarkus.io/blog/redis-api-intro/[how to cache with Redis], we implemented a simple cache backed by Redis. +\n"
"That's just one use case of Redis.\n"
"Redis is also used as a messaging server to implement the processing of background jobs or other kinds of messaging tasks.\n"
"This post explores implementing this pattern with Quarkus and the new Redis data source API."
msgstr ""

#. type: Title ==
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "Job Queues and Supes!"
msgstr "工作排队和超员!"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"A job queue is a data structure storing _execution_ requests.\n"
"Job dispatchers submit the tasks they want to execute in that data structure.\n"
"On the other side, job consumers poll the requests and execute them."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"There are plenty of variants of that pattern, so let's focus on the following application.\n"
"We have an application managing heroes and villains.\n"
"The application offers the possibility to simulate a fight between a random hero and a random villain.\n"
"The fight simulation is delegated to _fight simulators_, applications dedicated to that task."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"In this context, the main application submits the fight request to the job queue.\n"
"Then, the fight simulators poll the submitted fight request and execute them."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The fight outcomes are communicated using another Redis feature: pub/sub communication.\n"
"The simulators send the outcome to a _channel_ consumed by the application.\n"
"The application then broadcasts these outcomes to a web page."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"This post only discusses the interaction with Redis.\n"
"The rest of the application is straightforward and just uses RESTEasy Reactive and Hibernate ORM with Panache.\n"
"You can find the full code of the application on https://github.com/cescoffier/quarkus-redis-job-queue-demo."
msgstr ""

#. type: Title ==
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "Submitting jobs"
msgstr "提交工作"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The first task is to model the job queue.\n"
"We are using a https://redis.io/docs/data-types/#lists[Redis list] to store the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightRequest.java[FightRequest]."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"Redis lists distinguish the left side of the list from the right side of the list.\n"
"This distinction allows implementing a FIFO queue where we write on the left side and consume from the right side."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"To manipulate a Redis list, we need the _group of commands_ associated with this data structure.\n"
"In the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[SupesService class], we inject the `RedisDataSource` and retrieve the group of commands:"
msgstr ""

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "Let's now look at the `submitAFight` method:"
msgstr "现在让我们来看看 `submitAFight` 方法。"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The `submitAFight` method retrieves the random fighters, computes an id,  builds the `FightRequest` instance, and executes the `LPUSH` command.\n"
"The `LPUSH`  command writes the given item to the left side of the list stored at the given key (`fight-requests`)."
msgstr ""

#. type: Title ==
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "Receiving the job requests"
msgstr "接收工作请求"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"Let's now look at the other side: the fight simulators.\n"
"The simulators poll the `FightRequests` from the Redis list representing our job queue and simulate the fight."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The simulator is implemented in https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightSimulator.java[`me.escoffier.quarkus.redis.fight.FightSimulator`].\n"
"The constructor receives a configured name (to distinguish multiple simulators) and the Redis data source.\n"
"It creates the objects to emit the Redis commands to read from a Redis list:"
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The simulator polls the fight requests and for each of them simulate the fight.\n"
"The implementation is an _infinite_ loop (it only stops when the application is shut down).\n"
"In each iteration, it reads the pending `FightRequest` from the right side of the queue with the `BRPOP` command.\n"
"If there is no pending request, it restarts from the beginning of the loop.\n"
"If it has a request, it simulates the fight:"
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The `BRPOP` command retrieves and removes the last (right) element of the list.\n"
"Unlike the `RPOP`, it waits for a given amount of time (1 second in the code above) if there are no elements in the list.\n"
"So, if the list contains an element, it gets it.\n"
"Otherwise, it waits up to one second before giving up.\n"
"It returns `null` in this case.\n"
"The `BRPOP` command returns a `KeyValue` composed of the key of the list and the `FightRequest`.\n"
"It uses that structure because you can pass multiple keys, which is convenient when you have lists with priorities."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The `BRPOP` command also avoids spinning indefinitely if the list is empty, as it waits for 1 second during each iteration.\n"
"Finally, the `BRPOP` command is _atomic_.\n"
"It means that if you have multiple simulators, they cannot retrieve the same item.\n"
"It dispatches each item once."
msgstr ""

#. type: Title ==
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "Sending the fight outcome"
msgstr "发送战斗结果"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The pool loop retrieves the `FightRequests` from the queue and simulates the fights, but how to communicate the results?\n"
"For this, we use another Redis feature: pub/sub communication."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"In simple words, we are going to send the `FightResult` to a _channel_.\n"
"Applications subscribing to that channel will receive the emitted `FightResult`."
msgstr ""

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "A `FightResult` contains the request id, the two fighters, and the name of the winner:"
msgstr "一个 `FightResult` ，其中包含请求ID、两名拳手和赢家的名字。"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"To use Redis _pub/sub_ commands, we need the object associated with this group.\n"
"In the `FightSimulator`, we also uses the `pubsub` method to get that object:"
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"Now, we can use this `publisher` to send the `FightResults`.\n"
"After each fight, we call `publisher.publish` to send the `FightResult` instance to the `fight-results` channel:"
msgstr ""

#. type: Title ==
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "Receiving the fight outcome"
msgstr "接收战斗结果"

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "At that point:"
msgstr "在这一点上。"

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "we submit the fight request into the job queue,"
msgstr "我们将战斗请求提交到工作队列中。"

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "we consume that queue and simulate the fight,"
msgstr "我们消耗该队列并模拟战斗。"

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "we send the outcome to the `fight-results` channel."
msgstr "我们将结果发送到 `fight-results` 频道。"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"So, the only missing piece is the consumption of that channel.\n"
"Let's return to the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[`me.escoffier.quarkus.redis.supes.SupesService`] class.\n"
"In the constructor, we also inject the `ReactiveRedisDataSource`, the reactive variant of the Redis data source.\n"
"Then, in the constructor code, we subscribe to the `fight-results`."
msgstr ""

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "Because we use the reactive data source, this subscription returns a `Multi<FightResult>`, ready to be served by Quarkus and an SSE (see https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesResource.java[SupesResource.java]):"
msgstr "因为我们使用了反应式数据源，这个订阅返回一个 `Multi<FightResult>` ，准备由Quarkus和SSE提供服务（见 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesResource.java[SupesResource.java] ）。"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"`.broadcast().toAllSubscribers()` instructs Quarkus to broadcast all the received `FightResult` to all the connected SSE.\n"
"So, the browser filters out unrequested results."
msgstr ""

#. type: Title ==
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "Running the system"
msgstr "运行系统"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The circle is complete!\n"
"The full code source is available from https://github.com/cescoffier/quarkus-redis-job-queue-demo.\n"
"To run the system, open three terminals."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"First, we start the `supes-application`.\n"
"In the first terminal, navigate to the `supes-application` and run `mvn quarkus:dev`\n"
"Quarkus automatically starts the PostgreSQL and Redis instances (if your machine can run containers).\n"
"In the console, hit `h` and then `c`.\n"
"It displays the running dev services.\n"
"Look for the redis one, and copy the `quarkus.redis.hosts` injected configuration:"
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"In the previous snippet, copy: `quarkus.redis.hosts=redis://localhost:53853`.\n"
"This is the address of the redis server.\n"
"We need to configure to the simulators with that address."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"If you go to http://localhost:8080, the web page is served.\n"
"You can hit the `fights!` button a few times."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"The fight won't happen as we have no simulator.\n"
"However, the fight requests have been submitted and stored in the list.\n"
"So they are not lost."
msgstr ""

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "Now, in the second terminal, navigate to the `fight-simulator` directory, and run:"
msgstr "现在，在第二个终端，导航到 `fight-simulator` 目录，并运行。"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid "*IMPORTANT*: update the `quarkus.redis-hosts` with the one copied above."
msgstr ""

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "As soon as you start it, it processes the pending fight requests:"
msgstr "一旦你启动它，它就会处理待处理的战斗请求。"

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "If you go back to the web page, the winners get a _halo_:"
msgstr "如果你回到网页上，获胜者会得到一个 _光环_ 。"

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy
msgid "Now, in the third terminal, navigate to the `fight-simulator` directory, and run:"
msgstr "现在，在第三个终端，导航到 `fight-simulator` 目录，并运行。"

#: _posts/2022-09-15-redis-job-queue.adoc
msgid "*IMPORTANT*: as in the previous command, update the `quarkus.redis-hosts` with the one copied above."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"Go back to the web page and click on the `fight!` button a few times.\n"
"Check the logs of both simulators to see that the fight requests are now dispatched beween the two simulators."
msgstr ""

#. type: Title ==
#: _posts/2022-09-15-redis-job-queue.adoc
#, fuzzy, no-wrap
msgid "Summary"
msgstr "摘要"

#. type: Plain text
#: _posts/2022-09-15-redis-job-queue.adoc
msgid "This posts explains how you can implement a job queue with Redis and the Quarkus Redis datasource API."
msgstr ""

#: _posts/2022-09-15-redis-job-queue.adoc
msgid ""
"Learn more about the Redis data source API from the https://quarkus.io/guides/redis[Quarkus documentation].\n"
"We will publish more content about Redis patterns, so stay tuned!"
msgstr ""
