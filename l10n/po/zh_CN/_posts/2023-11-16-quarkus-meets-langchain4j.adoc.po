# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-16 16:23+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: title
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "When Quarkus meets LangChain4j"
msgstr "当夸克遇到朗查尼4j"

#. type: YAML Front Matter: synopsis
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid ""
"Learn about the new quarkus-langchain4j extension to integrate LLMs in "
"Quarkus applications."
msgstr "了解新的 quarkus-langchain4j 扩展，以便在 Quarkus 应用程序中集成 LLM。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Large language models (LLMs) are reshaping the world of software, altering "
"the way we interact with users and develop business logic."
msgstr "大型语言模型（LLM）正在重塑软件世界，改变我们与用户交互和开发业务逻辑的方式。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Popularized by https://openai.com/[OpenAI]'s https://chat.openai.com/"
"[ChatGPT], LLMs are now available in many flavors and sizes. The https://"
"huggingface.co/models[Hugging-Face] platform references hundreds of them, "
"and major tech companies like Facebook, Google, Microsoft, Amazon and IBM "
"are also providing their own models."
msgstr ""
"在 link:https://openai.com/[OpenAI] 的 link:https://chat.openai.com/[ChatGPT] "
"的推广下，LLM 现在已经有了很多种类和规模。 link:https://huggingface.co/models[Hugging-Face] "
"平台引用了数百种 LLM，Facebook、谷歌、微软、亚马逊和 IBM 等大型科技公司也在提供自己的模型。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"LLMs are not a new concept. They have been around for a while, but they were "
"not as powerful or as accessible they became when OpenAI made ChatGPT API's "
"publically available. Since then the Quarkus team have been thinking about "
"what it would mean to integrate LLMs in the Quarkus ecosystem. The talk "
"https://www.youtube.com/watch?app=desktop&v=BD1MSLbs9KE[Java Meets AI] from "
"Lize Raes at Devoxx 2023 has been a great source of inspiration."
msgstr ""
"LLM 并不是一个新概念。它们已经存在了一段时间，但在 OpenAI 公开提供 ChatGPT API "
"时，它们还没有变得如此强大或易于访问。从那时起，Quarkus 团队就一直在思考将 LLMs 集成到 Quarkus 生态系统中的意义。Lize "
"Raes 在 Devoxx 2023 上的演讲《 link:https://www.youtube.com/watch?app=desktop&v="
"BD1MSLbs9KE[Java Meets AI] 》给了我们很大的启发。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Since, the Quarkus team, in collaboration with Dmytro Liubarskyi and the "
"LangChain4j team, has been working on an extension to integrate LLMs in "
"Quarkus applications. This extension is based on the https://github.com/"
"langchain4j[LangChain4j library], which provides a common API to interact "
"with LLMs. The LangChain4j project is a Java re-implementation of the famous "
"https://www.langchain.com/[langchain] library."
msgstr ""
"此后，Quarkus 团队与 Dmytro Liubarskyi 和 LangChain4j 团队合作，一直致力于开发一个扩展，以便将 LLMs 集成到 "
"Quarkus 应用程序中。该扩展基于 link:https://github.com/langchain4j[LangChain4j 库] ， "
"link:https://github.com/langchain4j[该库] 提供了与 LLM 交互的通用 API。LangChain4j "
"项目是对著名的 link:https://www.langchain.com/[langchain] 库的 Java 重新实现。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"In this blog post, we will see how to use the just released https://docs."
"quarkiverse.io/quarkus-langchain4j/dev/index.html[quarkus-langchain4j] 0.1 "
"extension to integrate LLMs in Quarkus applications. This extension is an "
"exploration to understand how LLMs can be used in Quarkus applications."
msgstr ""
"在这篇博文中，我们将了解如何使用刚刚发布的 link:https://docs.quarkiverse.io/quarkus-langchain4j/"
"dev/index.html[quarkus-langchain4j] 0.1 扩展将 LLMs 集成到 Quarkus "
"应用程序中。该扩展旨在探索如何在 Quarkus 应用程序中使用 LLM。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"We recorded a live Fireside chat on this extension. You can watch it here, "
"the blog continues <<overview,below>>."
msgstr "我们就这一扩展录制了现场炉边谈话。您可以在这里观看，博客内容将在 xref:overview[下面] 继续。"

#. type: Title ==
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "Overview"
msgstr "概述"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"First, let's have a look at the big picture. When integrating an LLM into a "
"Quarkus application, you need to describe what you want the AI to do. Unlike "
"traditional code, you are going to explain the behavior of the AI using "
"natural language. Of course, there are a few techniques to tame the AI, but "
"we will explore that later."
msgstr ""
"首先，让我们来看看全局。将 LLM 集成到 Quarkus "
"应用程序中时，你需要描述你希望人工智能做什么。与传统的代码不同，你需要用自然语言来解释人工智能的行为。当然，也有一些驯服人工智能的技巧，但我们稍后会进行探讨。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Strictly relying on the LLM's knowledge might not be enough. Thus, the "
"Quarkus LangChain4j extension provides two mechanisms to extend AI knowledge:"
""
msgstr "严格依靠 LLM 的知识可能还不够。因此，Quarkus LangChain4j 扩展提供了两种扩展人工智能知识的机制："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"_Tools_ - a tool lets the LLM execute actions in your application. For "
"instance, you can use a tool to send an email, call a REST endpoint, or "
"execute a database query. The LLM decides when to use the tool, the method "
"parameters, and what to do with the result."
msgstr ""
"_工具_ --工具可让 LLM 在您的应用程序中执行操作。例如，您可以使用工具发送电子邮件、调用 REST 端点或执行数据库查询。LLM "
"决定何时使用工具、方法参数以及如何处理结果。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"_Document stores_ - LLMs are not good at remembering things. In addition, "
"their context has a size limit. Thus, the extension provides a way to store "
"and retrieve information from document stores. Before calling the LLM, the "
"extension can ask for relevant documents in a document store and attach them "
"to the context. The LLM can then use this data to make a decision. For "
"instance, you can load spreadsheet data, reports, or data from a database."
msgstr ""
"_文件存储_ - LLM 不善于记忆。此外，它们的上下文有大小限制。因此，扩展提供了一种从文档库中存储和检索信息的方法。在调用 LLM "
"之前，扩展可以在文档库中查找相关文档，并将其附加到上下文中。然后，LLM 可以使用这些数据做出决策。例如，您可以加载电子表格数据、报告或数据库中的数据。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"The following diagram illustrates the interactions between the LLM, the "
"tools, and the document stores:"
msgstr "下图说明了 LLM、工具和文档存储之间的交互："

#. type: Title ==
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "Show me some code!"
msgstr "给我看看代码"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Alright, enough \"bla bla\", let's see some code! We are going to use Open "
"AI GPT-3.5 (be careful that it's not the state-of-the-art model, but it's "
"good enough for this demo), give it some product reviews, and ask the LLM to "
"classify them between positive and negative reviews. The full code is "
"available in the https://github.com/quarkiverse/quarkus-langchain4j/tree/"
"main/samples/review-triage[quarkus-langchain4j repository]."
msgstr ""
"好了，\"废话 \"说完了，让我们来看看代码！我们将使用 Open AI GPT-3."
"5（请注意，这并不是最先进的模型，但对于本演示来说已经足够好了），给它一些产品评论，并要求 LLM 将它们分为正面评论和负面评论。完整代码可在 link:"
"https://github.com/quarkiverse/quarkus-langchain4j/tree/main/samples/review-"
"triage[quarkus-langchain4j] 代码 link:https://github.com/quarkiverse/quarkus-"
"langchain4j/tree/main/samples/review-triage[库中] 找到。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid "First, we need the `quarkus-langchain4j-openai` extension:"
msgstr "首先，我们需要 `quarkus-langchain4j-openai` 扩展名："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Once we have the extension, it's time to tell the LLM what we want to do. "
"The Quarkus LangChain4J extension provides a declarative way to describe LLM "
"interactions. The idea is the same as the Quarkus REST client. We model the "
"interaction using an interface annotated with `@RegisterAiService`:"
msgstr ""
"一旦我们有了扩展，就该告诉 LLM 我们想要做什么了。Quarkus LangChain4J 扩展提供了一种描述 LLM 交互的声明式方法。其理念与 "
"Quarkus REST 客户端相同。我们使用一个注有 `@RegisterAiService` 的接口来模拟交互："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"The rest of the application would be able to use the LLM by injecting the "
"`TriageService` interface and calling the methods."
msgstr "应用程序的其他部分可以通过注入 `TriageService` 接口和调用方法来使用 LLM。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Speaking about methods, that's where the magic happens. You will describe "
"what you want the LLM to do using natural language. First, you start with "
"`@SystemMessage` to define the role and scope. Then, you can use "
"`@UserMessage` to describe the task."
msgstr ""
"说到方法，这就是神奇之处。您将使用自然语言描述您希望 LLM 做什么。首先，您可以使用 `@SystemMessage` "
"来定义角色和范围。然后，您可以使用 `@UserMessage` 来描述任务。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Voilà! That's all you need to do to describe the interaction with the LLM. "
"The instructions follow a set of principles to shape the LLM response. Learn "
"more about these techniques in https://docs.quarkiverse.io/quarkus-"
"langchain4j/dev/prompt-engineering.html[the dedicated prompt engineering "
"page]."
msgstr ""
"瞧！这就是你与 LLM 交互的全部过程。这些指令遵循一系列原则来塑造 LLM 的响应。有关这些技术的更多信息，请参阅 link:https://docs."
"quarkiverse.io/quarkus-langchain4j/dev/prompt-engineering.html[专门的提示工程页面] 。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Now, to call the LLM from the application code, just inject the "
"`TriageService` and call the `triage` method:"
msgstr "现在，要从应用程序代码中调用 LLM，只需注入 `TriageService` 并调用 `triage` 方法即可："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"That's it! The LLM is now integrated into the application. The "
"`TriageService` interface is used as an ambassador to call the LLM. This "
"declarative approach has many advantages:"
msgstr "就是这样！现在，LLM 已集成到应用程序中。 `TriageService` 接口被用作调用 LLM 的大使。这种声明式方法有很多优点："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Testability - you can easily mock the LLM by providing a fake implementation "
"of the interface."
msgstr "可测试性--通过提供接口的虚假实现，您可以轻松地模拟 LLM。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Observability - you can use the Quarkus metrics annotation to monitor the "
"LLM methods."
msgstr "可观察性--你可以使用 Quarkus 指标注解来监控 LLM 方法。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Resilience - you can use the Quarkus fault-tolerance annotations to handle "
"failures, timeouts, and other transient issues."
msgstr "弹性--你可以使用 Quarkus 容错注解来处理故障、超时和其他瞬时问题。"

#. type: Title ==
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "Tools and Document loader"
msgstr "工具和文件加载器"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"The previous example is a bit simplistic. In the real world, you will need "
"to extend the LLM knowledge with tools and document stores. The "
"`@RegisterAiService` annotation lets you define the tools and document "
"stores to use."
msgstr ""
"前面的例子有点简单。在现实世界中，你需要用工具和文档存储来扩展 LLM 知识。通过 `@RegisterAiService` "
"注释，您可以定义要使用的工具和文档存储。"

#. type: Title ===
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "Tools"
msgstr "工具"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid "Tools are methods that the LLM can invoke."
msgstr "工具是 LLM 可以调用的方法。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid "To declare a tool, just use the `@Tool` annotation on a _bean_ method:"
msgstr "要声明工具，只需在 _bean_ 方法上使用 `@Tool` 注解即可："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"In this example, we are using the Panache repository pattern to access the "
"database. We have a specific method annotated with `@Tool` to retrieve the "
"customer name. When the LLM needs to get the customer name, it instructs "
"Quarkus to call this method and receives the result."
msgstr ""
"在本例中，我们使用 Panache 资源库模式访问数据库。我们有一个注释为 `@Tool` 的特定方法，用于检索客户名称。当 LLM "
"需要获取客户名称时，它会指示 Quarkus 调用该方法并接收结果。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Obviously, it's not a good idea to expose every operation to the LLM. So, in "
"addition to `@Tool`, you need to list the set of tools you allow the LLM to "
"invoke in the `@RegisterAiService` annotation:"
msgstr ""
"显然，向 LLM 公开所有操作并不是一个好主意。因此，除了 `@Tool` 之外，还需要在 `@RegisterAiService` 注释中列出允许 "
"LLM 调用的工具集："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"The `chatMemoryProviderSupplier` configuration may raise questions. When "
"using tools, a sequence of messages unfolds behind the scenes. It becomes "
"necessary to configure the AI service's memory to adeptly track these "
"interactions. The `chatMemoryProviderSupplier` allows configuring how the "
"memory is handled. The value `BeanChatMemoryProviderSupplier.class` "
"instructs Quarkus to look for a `ChatMemoryProvider` bean, like the "
"following:"
msgstr ""
"`chatMemoryProviderSupplier` "
"配置可能会引起疑问。使用工具时，一连串的信息会在幕后展开。因此，有必要配置人工智能服务的内存，以便有效跟踪这些交互。 "
"`chatMemoryProviderSupplier` 允许配置内存的处理方式。 `BeanChatMemoryProviderSupplier."
"class` 的值指示 Quarkus 查找 `ChatMemoryProvider` bean，如下所示："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid "At the moment, only the OpenAI models support tools."
msgstr "目前，只有 OpenAI 模型支持工具。"

#. type: Title ===
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "Document stores"
msgstr "文件存储"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Document stores are a way to extend the LLM knowledge with your own data. "
"This approach - called Retrieval Augmented Generation (_RAG_) - requires two "
"processes:"
msgstr "文档存储是用自己的数据扩展 LLM 知识的一种方法。这种方法被称为 \"检索增强生成 _（RAG_ ）\"，需要两个过程："

#. type: Labeled list
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "The ingestion process"
msgstr "摄取过程"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"you ingest documents into a document store. The documents are not stored as-"
"is, but an embedding is computed. This embedding is a vector representation "
"of the document."
msgstr "将文档输入文档存储库。文档不是按原样存储，而是计算嵌入。这种嵌入是文档的矢量表示。"

#. type: Labeled list
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "The RAG process"
msgstr "RAG 程序"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"in the Quarkus application, you need to declare the document store and the "
"embedding to use. Thus, before calling the LLM, it retrieves the relevant "
"documents from the store (that's where the vector representation is useful) "
"and attaches them to the LLM context (which essentially means adding the "
"retrieved information from the document to the user message)."
msgstr ""
"在 Quarkus 应用程序中，你需要声明要使用的文档存储和嵌入。因此，在调用 LLM "
"之前，它会从文档库中检索相关文档（这正是向量表示法的用武之地），并将它们附加到 LLM "
"上下文中（这基本上意味着将从文档中检索到的信息添加到用户信息中）。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"The Quarkus LangChain4j extension provides facilities for both processes."
msgstr "Quarkus LangChain4j 扩展为这两个过程提供了便利。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"The following code shows how to ingest a document into a Redis document "
"store:"
msgstr "下面的代码展示了如何将文档导入 Redis 文档存储："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Then, generally, in another application, you can use the populated document "
"store to extend the LLM knowledge. First, create a bean implementing the "
"`Retriever<TextSegment>` interface:"
msgstr ""
"然后，一般来说，在另一个应用程序中，您可以使用填充的文档存储来扩展 LLM 知识。首先，创建一个实现 `Retriever<TextSegment>` "
"接口的 Bean："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"Then, add the document store and the retriever to the `@RegisterAiService` "
"annotation:"
msgstr "然后，在 `@RegisterAiService` 注释中添加文档存储和检索器："

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"`RegisterAiService.BeanRetrieverSupplier.class` is a special value looking "
"for the `Retriever` bean in the Quarkus application."
msgstr ""
"`RegisterAiService.BeanRetrieverSupplier.class` 是一个特殊值，用于在 Quarkus 应用程序中查找 "
"bean。 `Retriever` "

#. type: Title ==
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, no-wrap, fuzzy
msgid "Final notes"
msgstr "最后说明"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"This post presented the Quarkus LangChain4j extension. This is the first "
"version of the extension, and we continue exploring and experimenting with "
"approaches to integrate LLMs into Quarkus applications. We are looking for "
"feedback and ideas to improve these integrations. We are working on removing "
"some rough angles, and exploring other ways to integrate LLMs and to bring "
"developer joy when integrating with LLMs."
msgstr ""
"这篇文章介绍了 Quarkus LangChain4j 扩展。这是扩展的第一个版本，我们将继续探索和尝试将 LLM 集成到 Quarkus "
"应用程序中的方法。我们正在寻求反馈和想法，以改进这些集成。我们正在努力去除一些粗糙的角度，并探索集成 LLMs 的其他方法，让开发人员在集成 LLMs "
"时感到愉悦。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"This extension would not have been possible without the fantastic work from "
"Dmytro Liubarskyi on the LangChain4j library. Our collaboration has allowed "
"us to provide a Quarkus-friendly approach to integrate the library "
"(including native compilation support) and shape a new way to integrate LLMs "
"in Quarkus applications. The current design was tailored to enable Quarkus "
"applications to use LLM easily. You can basically hook up any of your "
"_beans_ as tools or ingest data into a store. In addition, any of your bean "
"can now interact with an LLM."
msgstr ""
"如果没有 Dmytro Liubarskyi 在 LangChain4j 库方面所做的出色工作，这一扩展就不可能实现。我们的合作使我们能够提供一种对 "
"Quarkus 友好的方法来集成该库（包括本地编译支持），并为在 Quarkus 应用程序中集成 LLM 塑造了一种新方法。当前的设计是为使 "
"Quarkus 应用程序能够轻松使用 LLM 而量身定制的。基本上，你可以将你的任何 _bean_ "
"作为工具连接起来，或将数据摄取到存储中。此外，你的任何 bean 现在都可以与 LLM 交互。"

#. type: Plain text
#: _posts/2023-11-16-quarkus-meets-langchain4j.adoc
#, fuzzy
msgid ""
"We are looking forward to continuing this collaboration and to see what you "
"will build with this extension."
msgstr "我们期待着继续这一合作，并期待着看到你们利用这一扩展功能打造出怎样的产品。"
