# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:1
#, fuzzy, no-wrap
msgid "dplatz"
msgstr "邓小平"

#. type: YAML Front Matter: date
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:1
#, fuzzy, no-wrap
msgid "2020-05-12"
msgstr "2020-05-12"

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "职位"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:1
#, fuzzy, no-wrap
msgid "Ideas on how to use Quarkus command-mode to develop native applications with web frontends; built with GitHub Actions."
msgstr "关于如何使用Quarkus命令模式来开发具有Web前端的本地应用程序的想法；使用GitHub Actions构建。"

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:1
#, fuzzy, no-wrap
msgid "development-tips"
msgstr "发展-提示"

#. type: YAML Front Matter: title
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:1
#, fuzzy, no-wrap
msgid "Ideas on Quarkus command-mode, UI-based apps and releasing via GitHub Actions"
msgstr "关于Quarkus命令模式、基于UI的应用程序和通过GitHub行动发布的想法"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:12
#, fuzzy
msgid "Quarkus is advertised as a cloud-native runtime for Microservices but the link:https://quarkus.io/blog/quarkus-1-4-final-released/[introduction of command-mode] might have opened up new and interesting spaces where it could find adoption."
msgstr "Quarkus被宣传为微服务的云原生运行时，但 link:https://quarkus.io/blog/quarkus-1-4-final-released/[命令模式的引入] 可能开辟了新的、有趣的空间，在那里它可以找到应用。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:15
#, fuzzy
msgid "In this blog post I will present a few ideas about the possible usage of command-mode in Quarkus that you might find useful to consider when developing your next tool.  If you have not heard about command-mode, I suggest to start reading link:https://quarkus.io/blog/introducing-command-mode/[this introduction] first and then come back."
msgstr "在这篇博文中，我将介绍一些关于Quarkus中命令模式的可能用法的想法，你可能会发现在开发你的下一个工具时，这些想法很有用。如果你还没有听说过命令模式，我建议你先开始阅读 link:https://quarkus.io/blog/introducing-command-mode/[这个介绍] ，然后再回来。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:17
#, fuzzy
msgid "Ready? Ok, let's continue."
msgstr "准备好了吗？好的，让我们继续。"

#. type: Title ==
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:18
#, fuzzy, no-wrap
msgid "Cross-platform builds via GitHub Actions"
msgstr "通过GitHub Actions进行跨平台构建"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:22
#, fuzzy
msgid "Command-line tools like `kubectl` are often written in languages like C, Go or Rust and compiled to native executables for various target platforms.  This is great because you don't need to rely on Java installed; or being installed in a wrong version."
msgstr "像 `kubectl` 这样的命令行工具通常是用C、Go或Rust等语言编写的，并被编译为各种目标平台的本地可执行文件。这很好，因为你不需要依赖已安装的Java；或者被安装在一个错误的版本中。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:25
#, fuzzy
msgid "With GraalVM native-images, this argument against Java does not hold anymore. Quarkus supports the build of native executables via GraalVM; mainly for building natively for Linux containers but there is experimental support for OS X and Windows as well.  Using the native build in combination with command-mode sounds like a very interesting and productive choice to write command-line tools."
msgstr "有了GraalVM的本地图像，这种反对Java的论点就不再成立了。Quarkus支持通过GraalVM构建本地可执行文件；主要是针对Linux容器的本地构建，但对OS X和Windows也有实验性支持。将本地构建与命令模式相结合，听起来是一个非常有趣和富有成效的选择，可以编写命令行工具。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:28
#, fuzzy
msgid "But how do you build your native executables for Linux, Mac and Windows? If you are hosting your sources as a GitHub project, I can tell you that it is super-simple to get started. GitHub offers link:https://help.github.com/en/actions/building-and-testing-code-with-continuous-integration/setting-up-continuous-integration-using-github-actions[ Actions] which is a free service like link:https://travis-ci.org/[Travis CI] but fully integrated into the GitHub experience. Also, it offers runners (i.e. the build agents) for Linux, Mac and Windows."
msgstr "但你如何为Linux、Mac和Windows构建你的本地可执行文件？如果你把你的源代码托管在GitHub项目中，我可以告诉你，这是很简单的开始。GitHub提供了 link:https://help.github.com/en/actions/building-and-testing-code-with-continuous-integration/setting-up-continuous-integration-using-github-actions[Actions] ，这是一个类似 link:https://travis-ci.org/[Travis CI] 的免费服务，但完全集成到GitHub的体验中。此外，它还提供Linux、Mac和Windows的运行器（即构建代理）。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:30
#, fuzzy
msgid "To provide a native release-build for linux, place the following file under `.github/workflows` in your repo:"
msgstr "要为linux提供一个本地发布-build，请将以下文件放在你的 repo中的 `.github/workflows` 。"

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:34
#, no-wrap
msgid "name: release-build\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:38
#, no-wrap
msgid ""
"on:\n"
"  release:\n"
"    types: [created] <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:41
#, no-wrap
msgid ""
"jobs:\n"
"  build:\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:43
#, no-wrap
msgid "    runs-on: ubuntu-latest <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:66
#, no-wrap
msgid ""
"    steps:\n"
"    - uses: actions/checkout@v2\n"
"    - name: Install graalvm\n"
"      uses: DeLaGuardo/setup-graalvm@3\n"
"      with:\n"
"        graalvm-version: '20.0.0.java11'\n"
"    - name: Install native-image\n"
"      run: gu install native-image\n"
"    - name: Set version\n"
"      run: ./mvnw versions:set -DnewVersion=\"${{ github.event.release.tag_name }}\" <3>\n"
"    - name: Build native executable\n"
"      run: ./mvnw package -Dnative <4>\n"
"    - name: Upload native executable\n"
"      id: upload-native-executable\n"
"      uses: actions/upload-release-asset@v1\n"
"      env:\n"
"        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n"
"      with:\n"
"        upload_url: ${{ github.event.release.upload_url }}\n"
"        asset_path: ./target/quarkus-ls-${{ github.event.release.tag_name }}-runner <5>\n"
"        asset_name: quarkus-ls-${{ github.event.release.tag_name }}-linux\n"
"        asset_content_type: application/octet-stream\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:68
#, fuzzy
msgid "This build-job is triggered when a new release is triggered. If your are the owner, you will have the button \"Draft a new release\" under link:https://github.com/38leinaD/quarkus-native-app-starter/releases[releases]"
msgstr "当一个新的版本被触发时，这个build-job就被触发了。如果你是所有者，你会在 link:https://github.com/38leinaD/quarkus-native-app-starter/releases[发布版下] 有一个 \"起草新的发布版 \"的按钮。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:69
#, fuzzy
msgid "Uses a ubuntu runner. See link:https://github.com/actions/virtual-environments[GitHub Actions Virtual Environments] for a list of all supported environments/runners."
msgstr "使用一个ubuntu运行器。所有支持的环境/运行器的列表见 link:https://github.com/actions/virtual-environments[GitHub Actions Virtual Environments] 。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:70
#, fuzzy
msgid "Set version in `pom.xml` based on specified release version"
msgstr "根据指定的发布版本，在 `pom.xml` 中设置版本"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:71
#, fuzzy
msgid "Build the native executable"
msgstr "构建本地可执行文件"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:72
#, fuzzy
msgid "Upload/attach the artifact to the release"
msgstr "上传/附加工件到版本中"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:74
#, fuzzy
msgid "Building for Mac just means to provide another job with `runs-on: macos-latest`."
msgstr "为Mac构建只是意味着提供另一份工作， `runs-on: macos-latest` 。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:77
#, fuzzy
msgid "Windows is essentially the same but requires a little more attention and knowledge about the tooling. Getting it working required some investigation on how the native build depends on Visual Studio. Also,the Windows runners on GitHub Actions have a too small page-file by default. That needs increasing as the memory consumption is rather high when running the GraalVMs `native-image` command.  An full example of a working native-image build under windows can be found link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/.github/workflows/release-build-native-win64.yml[here]."
msgstr "Windows基本上是一样的，但需要更多的关注和关于工具的知识。要让它工作，需要对本地构建如何依赖Visual Studio进行一些调查。另外，GitHub Actions上的Windows运行程序默认的页面文件太小。这需要增加，因为在运行GraalVMs `native-image` 命令时，内存消耗相当高。 link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/.github/workflows/release-build-native-win64.yml[这里] 有一个在windows下工作的原生图像构建的完整例子，可以找到。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:79
#, fuzzy
msgid "After triggering a release from the GitHub UI, the jobs for all target environments are triggered. The artifacts for all platforms are will be available within minutes and can be consumed by your users. Building, hosting: 100% free and no external service or registration needed."
msgstr "从GitHub用户界面触发发布后，所有目标环境的工作都会被触发。所有平台的工件将在几分钟内可用，并可以被你的用户所使用。构建、托管。100%免费，不需要外部服务或注册。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:81
#, fuzzy
msgid "image:github-actions.jpg[]"
msgstr "image:github-actions.jpg[alt=\"github actions\"]"

#. type: Title ==
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:82
#, fuzzy, no-wrap
msgid "Command-mode for UI-based applications"
msgstr "基于用户界面的应用程序的命令模式"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:86
#, fuzzy
msgid "Another exciting thing about command-mode is that it not only allows to write nice command-line tools (using e.g. link:https://picocli.info/[Picocli], link:http://aeshell.github.io/[Aesh] or link:https://commons.apache.org/proper/commons-cli/[Apache Commons CLI]) but in general allows to have more control over the lifecycle of an application.  With the possibility to embed your HTML/Javascript frontend, we can even build link:https://www.electronjs.org/[Electron-style] desktop application with rich user interfaces for our tools. As even JSF most likely will be link:https://github.com/adminfaces/quarkus-admin-starter[coming to Quarkus], there is a great variety of choices on how to build a frontend."
msgstr "关于命令模式的另一个令人兴奋的事情是，它不仅允许编写漂亮的命令行工具（例如使用 link:https://picocli.info/[Picocli] 、 link:http://aeshell.github.io/[Aesh] 或 link:https://commons.apache.org/proper/commons-cli/[Apache Commons CLI] ），而且一般来说允许对一个应用程序的生命周期有更多的控制。由于可以嵌入你的HTML/Javascript前端，我们甚至可以为我们的工具建立具有丰富用户界面的 link:https://www.electronjs.org/[Electron风格的] 桌面应用程序。因为即使是JSF也很有可能 link:https://github.com/adminfaces/quarkus-admin-starter[进入Quarkus] ，所以在如何建立一个前端方面有很多选择。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:89
#, fuzzy
msgid "A very simple scaffold does not require much. If you have `quarkus-resteasy` as a dependency, the embedded server will be started on port `8080` just like in any regular Quarkus backend application.  As your tools might be running on a developer system alongside other app-servers or Quarkus instances, it is a good idea to choose a different port to not run into conflicts."
msgstr "一个非常简单的脚手架不需要太多。如果你把 `quarkus-resteasy` 作为一个依赖项，嵌入式服务器将在端口 `8080` ，就像在任何常规的Quarkus后端应用中一样。由于你的工具可能与其他应用服务器或Quarkus实例一起运行在开发者系统上，因此最好选择一个不同的端口，以免发生冲突。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:92
#, fuzzy
msgid "Configuring `quarkus.http.port=0` in your `application.properties` will make Quarkus choose a random but free port.  How to know from within your application which port it is? When injecting the config-property via `@ConfigProperty(name = \"quarkus.http.port\")`, you will get the assigned port."
msgstr "在你的 `application.properties` 中配置 `quarkus.http.port=0` ，会使Quarkus选择一个随机但自由的端口。如何从你的应用程序中知道它是哪个端口？当通过 `@ConfigProperty(name = \"quarkus.http.port\")` 注入config-property时，你会得到指定的端口。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:94
#, fuzzy
msgid "Assuming you have your front-end under `src/main/resources/META-INF/resources` (in my example it is plain HTML with Javascript) and using a very old Java API (`Desktop.getDesktop().browse(...)`), you can spin up the default browser to your app like this:"
msgstr "假设你的前端在 `src/main/resources/META-INF/resources` （在我的例子中，它是带有Javascript的纯HTML），并使用非常老的Java API（ `Desktop.getDesktop().browse(…​)` ），你可以像这样为你的应用程序启动默认浏览器。"

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:103
#, no-wrap
msgid ""
"import java.awt.Desktop;\n"
"import java.net.URI;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
"import io.quarkus.runtime.Quarkus;\n"
"import io.quarkus.runtime.QuarkusApplication;\n"
"import io.quarkus.runtime.annotations.QuarkusMain;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:106
#, no-wrap
msgid ""
"@QuarkusMain\n"
"public class HelloMain implements QuarkusApplication {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:109
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"quarkus.http.port\")\n"
"    Integer assignedPort; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:113
#, no-wrap
msgid ""
"    public static void main(String[] args) {\n"
"        Quarkus.run(HelloMain.class, args);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:117
#, no-wrap
msgid ""
"    @Override\n"
"    public int run(String... args) throws Exception {\n"
"        URI webappUri = new URI(\"http://localhost:\" + assignedPort + \"/index.html\"); <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:120
#, no-wrap
msgid ""
"        Desktop.getDesktop().browse(webappUri);\n"
"        Quarkus.waitForExit(); <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:124
#, no-wrap
msgid ""
"        return 0;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:126
#, fuzzy
msgid "Get the assigned port"
msgstr "获得分配的端口"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:127
#, fuzzy
msgid "Open the `index.html` of your webapp with the default browser."
msgstr "用默认浏览器打开你的网络应用程序的 `index.html` 。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:128
#, fuzzy
msgid "Do not exit immediately but wait until the browser/tab is closed. See below for options how to do this."
msgstr "不要立即退出，而是等到浏览器/标签关闭后再退出。如何做到这一点，请看下面的选项。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:130
#, fuzzy
msgid "There are some more considerations here to make it work reliably."
msgstr "这里还有一些考虑，以使其可靠地工作。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:133
#, fuzzy
msgid "Ending the application when the browser window closes requires some feedback. There are simple ways to achieve this in a semi-reliabe way (see the usage of link:https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event[unload] in link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/resources/META-INF/resources/index.html#L89[index.html] by calling link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/java/org/acme/LsResource.java#L38[a rest endpoint]).  For Desktop-class applications, one might have to control the browser process more closely; or, like Electron, even package an own version of Chrome."
msgstr "在浏览器窗口关闭时结束应用程序需要一些反馈。有一些简单的方法可以以半可靠的方式实现这一点（参见通过调用 link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/java/org/acme/LsResource.java#L38[一个休息端点] 在 link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/resources/META-INF/resources/index.html#L89[index.html] 中使用 link:https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event[unload] ）。对于桌面级应用，我们可能需要更紧密地控制浏览器的进程；或者像Electron一样，甚至可以打包一个自己的Chrome版本。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:135
#, fuzzy
msgid "A problem I was facing is that `Desktop.getDesktop().browse(...)` does not seem to work reliably when run in native mode with the GraalVM version I was using (link:https://github.com/oracle/graal/issues/2430[issue]). The alternative, like already stated before, is to control the browser more directly and for example open a Chrome window via link:https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#exec(java.lang.String)[Runtime.exec(...)]. See the link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/java/org/acme/LsMain.java[main method] of the starter project for some possibilities to experiment with."
msgstr "我面临的一个问题是， `Desktop.getDesktop().browse(…​)` ，在我使用的GraalVM版本 link:https://github.com/oracle/graal/issues/2430[（问题] ）中以本地模式运行时，似乎不能可靠地工作。如前所述，另一种方法是更直接地控制浏览器，例如通过 link:https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#exec(java.lang.String)[Runtime.exec(...)] 打开一个Chrome窗口。请看启动项目的 link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/java/org/acme/LsMain.java[主要方法] ，以了解一些实验的可能性。"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:137
#, fuzzy
msgid "image:quarkus-native-webui.gif[]"
msgstr "image:quarkus-native-webui.gif[alt=\"quarkus native webui\"]"

#. type: Title ==
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:138
#, fuzzy, no-wrap
msgid "Summary"
msgstr "摘要"

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:142
msgid "It will be interesting to see where people are taking command-mode. Maybe we will be seeing Electron-style Desktop applications being developed based on Quarkus? At least to me, this sounds promising and productive. No wasting of time to learn a completely different stack just to write a small tool. Instead, use the same stack and API I am familar with from backend development anyway."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:144
msgid "We have seen that making a tool available in a way that is easy to consume by people can be achived with GitHub and GitHub Actions alone."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:145
msgid "In case you are interested in a more complete tool where I have used the ideas presented here, check out my link:https://github.com/38leinaD/bpmn-diff[bpmn-diff] project which is a Git difftool for BPMN files. As an added benefit, it uses Gradle as opposed to Maven and thus provides additional examples on the use of GitHub Actions."
msgstr ""
