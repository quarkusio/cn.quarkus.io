msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden"
msgstr "莱顿项目"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden: exploring its potential for Quarkus users."
msgstr "莱登项目：探索 Quarkus 用户的潜力。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "You might have heard of https://openjdk.org/projects/leyden/[Project Leyden], an initiative within the OpenJDK project with ambitious goals."
msgstr "您可能听说过 link:https://openjdk.org/projects/leyden/[莱登项目] ，它是 OpenJDK 项目中的一项计划，目标远大。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As Quarkus users, you'll be wondering how this project will benefit you and how it's different from GraalVM native images. While we think it's fair to say that Leyden was inspired or at least motivated by some ideas first implemented in GraalVM's native images, Leyden is remarkably different. It's essential to understand how it works: as we will see, Leyden is not a replacement for GraalVM native images but rather a substantial evolution of the JVM, and we expect it to bring some benefits to native images as well."
msgstr "作为 Quarkus 的用户，你一定想知道这个项目会给你带来什么好处，以及它与 GraalVM 原生镜像有什么不同。我们认为，可以说 Leyden 是受到了 GraalVM 本机镜像的启发，或者至少是受到了 GraalVM 本机镜像中首次实现的一些想法的启发，但 Leyden 又有明显的不同。了解它是如何工作的至关重要：正如我们将会看到的，Leyden 并不是 GraalVM 原生镜像的替代品，而是 JVM 的实质性进化，我们期待它也能为原生镜像带来一些好处。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To try to clarify this, unfortunately, this post is unusually long: we wish it could have been a short guide, \"This is how you enable Leyden,\" but this isn't quite the time yet, as we need to understand the different models first. Sometimes, the terminology is also different; for example, \"Ahead of Time (AOT)\" has a very specific meaning in the context of GraalVM native images and has traditionally been associated with \"compilation\", but in the context of Leyden is used more broadly to indicate a variety of aspects of JVM operation; hopefully, after reading this, it will be less confusing."
msgstr "为了澄清这一点，很遗憾这篇文章异常冗长：我们希望它能成为一份简短的指南，\"这就是如何启用 Leyden\"，但现在还不是时候，因为我们需要先了解不同的模型。有时，术语也会有所不同；例如，\"Ahead of Time (AOT) \"在 GraalVM 本机镜像中有着非常特殊的含义，传统上与 \"编译 \"相关，但在 Leyden 中却被更广泛地用于表示 JVM 运行的各种方面；希望读完这篇文章后，大家能减少困惑。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Another significant misconception about Leyden is that it's a project to \"improve startup times\"; this statement is not wrong, as improving startup times is one of its goals. Yet the other stated goals of the project offer even more significant potential for our favourite platform, Quarkus, and its users."
msgstr "关于莱登的另一个重大误解是它是一个 \"改善启动时间 \"的项目；这种说法并没有错，因为改善启动时间是它的目标之一。然而，该项目的其他既定目标为我们最喜爱的 Quarkus 平台及其用户提供了更大的潜力。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "So, let's dive in."
msgstr "那么，让我们开始吧。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "What is Leyden?"
msgstr "莱顿是什么？"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden is an initiative from the OpenJDK team. It is an ongoing experiment that is currently being developed by the joint effort of teams from different companies contributing to the project."
msgstr "莱登项目是 OpenJDK 团队的一项倡议。它是一项正在进行的实验，目前由来自不同公司的团队共同努力开发。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The primary goal of this Project is to improve the startup time, time to peak performance, and footprint of Java programs."
msgstr "该项目的主要目标是改进 Java 程序的启动时间、达到峰值性能的时间和占用空间。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "-- Project Leyden, first thing on its project page"
msgstr "- 莱顿项目，项目页面上的第一件事"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Leyden is a general umbrella project to address slow startup and large footprint. It is useful to keep JDK bootstrap times and footprint low. This helps reduce energy consumption, hardware resource use, and, ultimately, monetary costs.\n"
"However, it's equally as essential to reduce the time to application peak performance, time usually spent loading application classes and executing application code, including JIT compiling methods on hot code paths. Reducing application footprint can have a tremendous impact and this can be achieved by trimming not just application data but also application classes and code. Leyden is addressing ways that the JVM can help developers achieve those goals; in many ways, this is complementary to the techniques offered by Quarkus at the framework level, so we expect some powerful results from them combined."
msgstr "Leyden 是一个解决启动慢和占用空间大问题的总体项目。它有助于减少 JDK 启动时间和占用空间。这有助于降低能耗和硬件资源使用，并最终降低货币成本。不过，同样重要的是缩短达到应用程序峰值性能的时间，即通常用于加载应用程序类和执行应用程序代码（包括热代码路径上的 JIT 编译方法）的时间。减少应用程序占用空间会产生巨大的影响，这不仅可以通过减少应用程序数据，还可以通过减少应用程序类和代码来实现。Leyden 正在研究 JVM 可以帮助开发人员实现这些目标的方法；在很多方面，这与 Quarkus 在框架层面提供的技术是相辅相成的，因此我们期待它们的结合可以产生强大的效果。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Note that the project is evolving rapidly: some of the things explained in this article are evolving while this is written. If you plan on getting involved at a more technical level, follow the development in Jira and the https://mail.openjdk.org/mailman/listinfo/leyden-dev[Leyden mailing list]."
msgstr "请注意，该项目正在快速发展：在撰写本文的同时，本文中解释的某些内容也在不断发展。如果您打算参与到更多技术层面的工作中，请关注 Jira 和 link:https://mail.openjdk.org/mailman/listinfo/leyden-dev[莱登邮件列表] 中的开发动态。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Why it’s interesting to Quarkus"
msgstr "夸克为什么对它感兴趣"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"From a Quarkus perspective, we've done a fair job on all such metrics but we're constantly on the lookout to improve.\n"
"That's why Project Leyden got our attention. We're already working with our colleagues from the OpenJDK team at Red Hat, who are directly involved in implementing Leyden with the wider OpenJDK group: this blog post today is a collaboration among engineers from different teams."
msgstr "从 Quarkus 的角度来看，我们在所有这些指标上都做得不错，但我们一直在寻求改进。这就是莱登项目引起我们关注的原因。我们已经在与红帽公司 OpenJDK 团队的同事们合作，他们直接参与了莱登项目在 OpenJDK 团队中的实施：今天的这篇博文就是不同团队的工程师们的合作成果。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Although Quarkus is already doing a lot of work during the Ahead of Time phase to speed up warmup and response time, the enhancements that Leyden brings to the table are more related to how the JVM behaves. Complementing both approaches, the advantages we can expect from the combination of Quarkus and Leyden are beyond anything you can find with either of them in isolation."
msgstr "尽管 Quarkus 已经在 \"超前 \"阶段做了大量工作来加快预热和响应时间，但 Leyden 带来的增强功能更多地与 JVM 的行为方式有关。Quarkus 和 Leyden 相辅相成，我们可以期待 Quarkus 和 Leyden 的结合所带来的优势将远远超出单独使用其中任何一种方法所能带来的优势。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since the potential for such technological collaboration is strong, the Quarkus and OpenJDK teams are working together on various prototypes and anyone in the community is welcome to join as well."
msgstr "由于这种技术合作潜力巨大，Quarkus 和 OpenJDK 团队正在合作开发各种原型，欢迎社区中的任何人加入。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Refresher on JVM's bootstrap process"
msgstr "复习 JVM 的引导过程"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"To better understand the scope of the potential improvements, we need to take a step back and discuss how the JVM works today, especially how our application is started and iteratively evolves from interpreting our bytecode to its highest performance mode: running native code which is highly optimized, adapted to the particular hardware, the configuration of the day, and the specific workloads it's been asked to perform.\n"
"No other runtime is able to match the JVM on this."
msgstr "为了更好地理解潜在改进的范围，我们需要退一步讨论 JVM 目前是如何工作的，尤其是我们的应用程序是如何启动并从解释字节码迭代演进到最高性能模式的：运行经过高度优化的本地代码，并适应特定的硬件、当天的配置以及要求其执行的特定工作负载。在这一点上，其他运行时都无法与 JVM 匹敌。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"As we all know, a Java runtime does not directly run Java source code. The content of our JAR file is not executable machine code, but Java bytecode generated from Java source code, typically using the javac compiler but in some cases Quarkus will emit directly generated bytecode.\n"
"A key feature of bytecode is portability, encoding the structure of Java classes and operation of their methods in a machine and operating-system independent format. A Java runtime obeys the type information in the bytecode when laying out Java objects. Execution of a method normally involves interpreting the operations in the method bytecode, although a runtime may also choose to compile method bytecode to equivalent, native machine code and execute the latter directly."
msgstr "众所周知，Java 运行时并不直接运行 Java 源代码。我们的 JAR 文件内容不是可执行的机器代码，而是由 Java 源代码生成的 Java 字节码，通常使用 javac 编译器，但在某些情况下，Quarkus 会直接生成字节码。字节码的一个主要特点是可移植性，它以一种与机器和操作系统无关的格式编码 Java 类的结构及其方法的操作。Java 运行时在布局 Java 对象时会遵从字节码中的类型信息。方法的执行通常涉及解释方法字节码中的操作，不过运行时也可以选择将方法字节码编译为等价的本地机器代码，并直接执行后者。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The unit of delivery for bytecode is a class file, which models a single class. The Java runtime itself provides a host of utility and runtime management classes, as class files embedded in either system jars or jmod files. Applications supplement this with their own class files, usually by appending jars to the classpath or module path."
msgstr "字节码的交付单位是类文件，它是单个类的模型。Java 运行时本身提供了大量实用程序和运行时管理类，这些类文件嵌入在系统 jars 或 jmod 文件中。应用程序通常通过在类路径或模块路径中添加 jars 来补充自己的类文件。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Bytecode is delivered class-at-a-time to allow the runtime to load classes _lazily_: i.e. the runtime will only lookup, verify and consume a class file when that class's definition is required to proceed with execution."
msgstr "字节码是以类为单位交付的，这样运行时就可以 _懒散地_ 加载类：也就是说，只有在需要继续执行类的定义时，运行时才会查找、验证和使用该类文件。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Lazy loading is what allows Java to be a dynamic language -- i.e. one where the code that is included in the program can be decided at runtime. That might include loading classes from jars identified at runtime, possibly loaded via the network. Alternatively, it might include generating class bytecode at runtime, as is done with proxy classes or service provider auxiliary classes."
msgstr "懒加载使 Java 成为一种动态语言，即程序中包含的代码可在运行时决定。这可能包括从运行时确定的 jars 中加载类，也可能是通过网络加载。另外，它还可能包括在运行时生成类字节码，如代理类或服务提供商辅助类。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Just in Time (JIT) and Ahead of Time (AOT)"
msgstr "准时制（JIT）和超前制（AOT）"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Another name to describe Java's lazy loading is 'Just in Time' (JIT). JIT is a well known term used to describe the operation of Java's runtime compilers. What is less well known is that it has a much wider use.\n"
"JIT is not limited to compilation: many other operations performed by the JVM are done lazily at runtime or 'Just In Time'."
msgstr "描述 Java 懒加载的另一个名称是 \"JIT（Just in Time）\"。JIT 是一个众所周知的术语，用于描述 Java 运行时编译器的操作。但鲜为人知的是，它还有更广泛的用途。JIT 并不局限于编译：JVM 执行的许多其他操作都是在运行时或 \"Just In Time\"（及时）进行的。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"An alternative to doing things 'Just in Time' (JIT) is to do them 'Ahead Of Time' (AOT).\n"
"For example, GraalVM's Native Image runtime loads and analyses the bytecode of every single class needed by an application, including JDK runtime classes, 'Ahead Of Time' i.e. at image build time. It uses the type and method information encoded in that bytecode to 'Ahead Of Time' compile a complete program that includes code for every method that might possibly be executed by the application."
msgstr "除了 \"及时\"（JIT）之外，还有一种方法就是 \"提前\"（AOT）。例如，GraalVM 的本地映像运行时会 \"提前\"（即在映像构建时）加载并分析应用程序所需的每个类的字节码，包括 JDK 运行时类。它使用字节码中编码的类型和方法信息来 \"提前 \"编译一个完整的程序，其中包括应用程序可能执行的每个方法的代码。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The approach of GraalVM's native images lies at one extreme: everything is done AOT, while the traditional Java runtime model lies at the other extreme, as much as possible is done JIT.\n"
"However, it is actually possible to mix and match AOT and JIT models of execution in one runtime: re-balancing that AOT vs JIT mix is the goal of the first EA release of project Leyden."
msgstr "GraalVM 的原生映像采用了一种极端的方法：一切都以 AOT 方式执行，而传统的 Java 运行时模型则采用了另一种极端的方法，即尽可能以 JIT 方式执行。然而，实际上可以在一个运行时中混合和匹配 AOT 和 JIT 执行模式：重新平衡 AOT 与 JIT 的混合就是莱登项目首个 EA 版本的目标。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Interestingly, this time-shifting concept is also applied by Quarkus; we called it \"augmentation\" and essentially consists in booting popular frameworks during the build time of the application, to not incur such performance penalties at runtime."
msgstr "有趣的是，Quarkus 也采用了这种时间转移概念；我们称之为 \"增强\"，主要是在构建应用程序时启动常用框架，以避免在运行时产生性能损失。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"A native image build might also take advantage of Profile Guided Optimisations (PGO), which allows it to leverage some data about what's presumably happening at runtime back into the compilation process, guiding its optimisations.\n"
"It's essentially peeking into the future - another form of time-shifting.\n"
"However, it's only peeking into a simulation of runtime metrics, and ultimately, the compiler still needs to make all optimisation tradeoffs Ahead Of Time; this has pros and cons. The primary disadvantage is that any suboptimal decision is cast in stone; luckily there is a fallback mechanism to recover from outright bad decisions, but this mechanism cannot produce new optimal code. The advantage is more decisive for short-lived applications as the tradeoff of carrying all support for JIT optimisations in the runtime is less justifiable when there is barely an opportunity to take advantage of it."
msgstr "原生镜像编译还可以利用 \"配置文件引导优化\"（PGO），将运行时可能发生的情况的一些数据反馈到编译过程中，从而引导优化。这本质上是对未来的窥视，是另一种形式的时间转移。不过，这只是对运行时指标的模拟窥探，编译器最终仍需提前做出所有优化权衡；这有利有弊。主要的缺点是，任何次优决策都是一成不变的；幸运的是，有一种后备机制可以从完全错误的决策中恢复过来，但这种机制无法生成新的最优代码。对于短期应用来说，这种优势更具决定性，因为如果几乎没有机会利用 JIT 优化，那么在运行时携带 JIT 优化的所有支持就不那么合理了。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "On a default Java compilation and run, we have two distinct phases: First we compile the source code into bytecode. And then we use that bytecode to run the application."
msgstr "在默认的 Java 编译和运行中，我们有两个不同的阶段：首先，我们将源代码编译成字节码。然后使用字节码运行应用程序。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Class Data Sharing (CDS) as a step to AOT Caching"
msgstr "类数据共享（CDS）作为 AOT 缓存的一个步骤"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Shifting work so it is done AOT is not a wholly new idea as far as the OpenJDK runtime is concerned. OpenJDK has supported a hybrid AOT/JIT class loading model for years with CDS. The observation that led to https://docs.oracle.com/en/java/javase/21/vm/class-data-sharing.html[Class Data Sharing (CDS)] being proposed was that most applications load the same classes every time they run, both JDK classes during JDK bootstrap and application classes during application startup and warmup."
msgstr "就 OpenJDK 运行时而言，将工作转移到 AOT 完成并不是一个全新的想法。多年来，OpenJDK 一直通过 CDS 支持 AOT/JIT 混合类加载模型。导致 link:https://docs.oracle.com/en/java/javase/21/vm/class-data-sharing.html[类数据共享 (CDS)] 提出的原因是，大多数应用程序在每次运行时都会加载相同的类，包括在 JDK 引导期间加载 JDK 类，以及在应用程序启动和预热期间加载应用程序类。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading requires locating a class bytecode file, possibly calling out to a Java ClassLoader, parsing the bytecode then building a JVM-internal model of the class. This internal model unpacks the information packed into the bytecode into a format that enables fast interpreted or compiled execution. If this loading and unpacking work could be done once and the resulting class model efficiently reused on subsequent runs, then that would save time during startup and warm up."
msgstr "加载需要找到类的字节码文件，可能需要调用 Java ClassLoader，解析字节码，然后建立类的 JVM 内部模型。这个内部模型会将字节码中的信息解包成一种格式，以便快速解释或编译执行。如果加载和解包工作可以一次性完成，并且生成的类模型可以在后续运行中有效重用，那么就可以节省启动和预热的时间。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Initially CDS optimized loading for a large set of core JDK classes. It worked by booting the JVM and dumping the class model for all classes loaded during startup into an archive file laid out in memory format. The resulting JDK module, class, field, and method graph can then be quickly remapped into memory next time the JVM runs. Loading a class that is present in the archive involves a simple lookup in the AOT class model. Loading a class not present in the archive requires the normal JIT steps of bytecode lookup, parsing and unpacking i.e. CDS implements a hybrid JIT/AOT execution model."
msgstr "CDS 最初优化了大量 JDK 核心类的加载。它的工作原理是启动 JVM，并将启动过程中加载的所有类的类模型转储到一个以内存格式布局的归档文件中。生成的 JDK 模块、类、字段和方法图可以在 JVM 下次运行时快速重新映射到内存中。加载归档文件中存在的类只需在 AOT 类模型中进行简单的查找。加载一个不存在于存档中的类则需要执行字节码查找、解析和解包等常规 JIT 步骤，即 CDS 实现了一种混合 JIT/AOT 执行模型。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Static CDS archives are built during the JVM installation and includes classes from the core libraries. This archive can be used to move part of the class loading to AOT when running the application."
msgstr "静态 CDS 存档是在安装 JVM 时创建的，其中包含核心库中的类。运行应用程序时，可使用该归档将部分类加载转移到 AOT。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A default CDS archive for JDK runtime classes has been shipped with every JVM release since JDK17, halving JDK startup time. Improvements were made to CDS to allow application classes to be included in a CDS archive after executing a short application training run. The resulting mixed AOT/JIT operation can provide significant improvements to application startup and warmup times, depending on how well the training run exercises application code. So, selective JIT/AOT operation is not some new thing."
msgstr "自 JDK17 以来，每个 JVM 版本都随附了 JDK 运行时类的默认 CDS 存档，从而将 JDK 启动时间缩短了一半。对 CDS 进行了改进，允许在执行简短的应用程序培训运行后将应用程序类包含在 CDS 存档中。由此产生的 AOT/JIT 混合运行可显著改善应用程序的启动和预热时间，这取决于训练运行对应用程序代码的锻炼程度。因此，选择性 JIT/AOT 操作并不是什么新鲜事物。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "When doing training runs, we create an archive that contains information on how the application runs. This archive includes not only classes from the core libraries, but also classes from our application."
msgstr "在进行训练运行时，我们会创建一个包含应用程序运行信息的归档。该归档不仅包括核心库中的类，还包括我们应用程序中的类。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Quarkus makes it really easy to generate CDS archives specific to your application code; this feature has been around since some years already: see the https://quarkus.io/guides/appcds[AppCDS guide in Quarkus].\n"
"As Leyden is coming, we aim to evolve this further and fully automate it for Leyden as well, so to get you even more benefits at no additional hassle."
msgstr "Quarkus 可以非常容易地为您的应用程序代码生成特定的 CDS 存档；这一功能已存在多年：请参阅 link:https://quarkus.io/guides/appcds[Quarkus 中的 AppCDS 指南] 。由于 Leyden 即将推出，我们的目标是进一步发展这一功能，并将其完全自动化，以便为您带来更多好处，而不会给您带来额外的麻烦。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The goal of Project Leyden is extending the AOT vs JIT trade-off from class loading (as done by CDS) to other JIT operations in the JVM; there's a number of operations which could be \"moved in time\" to AOT, such as creation of heap objects to represent constants, gathering execution profile information, and many more.\n"
"Most importantly, it's moving AOT the lazy linking that normally happens during interpreted execution and the lazy compilation and recompilation that happens when methods have been executed enough times to justify the cost of compilation."
msgstr "莱登项目的目标是将 AOT 与 JIT 之间的权衡从类加载（如 CDS 所做的）扩展到 JVM 中的其他 JIT 操作；有许多操作都可以 \"及时 \"转移到 AOT，例如创建堆对象来表示常量、收集执行配置文件信息等。最重要的是，它将通常在解释执行过程中进行的懒链接，以及在方法被执行足够多次数以证明编译成本合理时进行的懒编译和重新编译转移到了 AOT。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "AOT vs JIT Linkage"
msgstr "AOT 与 JIT 联动"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Linking of classes is another operation that the JVM does lazily. When class bytecode is processed the class is directly linked to its owning module and its owned methods and fields. JIT linkage connects elements of each independent, linked class sub-graph into a fully connected graph where elements from different (class or module) files cross-reference each other."
msgstr "类的链接是 JVM 的另一个懒惰操作。处理类字节码时，类会直接链接到其所属模块及其所属方法和字段。JIT 链接将每个独立的链接类子图的元素连接到一个完全连接的图中，在这个图中，来自不同（类或模块）文件的元素相互参照。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading and linking needs to proceed recursively. As one example, every class (except Object) needs to be linked to its super class. Super linkage cannot complete without ensuring the super class is loaded. Indeed, if the super's bytecode cannot be found or is not valid (say it identifies an interface not a class) then a linkage error may occur. Likewise, a new operation or a field get/put operation occurring in some method's bytecode can only be linked after loading the class (and field) named in the new bytecode."
msgstr "加载和链接需要递归进行。例如，每个类（对象类除外）都需要链接到其超类。如果不能确保超类已加载，超类链接就无法完成。事实上，如果找不到超类的字节码或字节码无效（例如它标识的是接口而不是类），就可能发生链接错误。同样，只有在加载了新字节码中命名的类（和字段）后，才能链接某些方法字节码中出现的新操作或字段获取/输入操作。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Linking is sometimes, but not always, done lazily. Indeed, it is necessary to do some linkage lazily in order to allow loading also to be lazy, otherwise the whole class graph would end up being linked and loaded as soon as the main routine was entered. Super linkage is always done eagerly at the point where the subclass has just been loaded. That is because it is not possible to use a subclass to create instances or execute methods without knowing how the superclass is defined. By contrast, field and method linkage is done lazily. In these cases linkage happens as a side-effect of execution. When a method executes a field get/put or method invoke bytecode for the first time the target field or method is looked up via its owner class, loading it if necessary. The field type or method signature is checked for consistency and details of where to find the field or how to call the method are cached, allowing the next execution of the bytecode to bypass the linkage step."
msgstr "链接有时会偷懒地进行，但并非总是如此。事实上，为了使加载也能懒散地进行，有必要懒散地进行一些链接，否则一旦进入主例程，整个类图就会被链接和加载。超链接总是在子类刚刚被加载时急切地进行。这是因为如果不知道超类是如何定义的，就无法使用子类创建实例或执行方法。相比之下，字段和方法的链接则是懒惰地进行的。在这些情况下，链接是作为执行的副作用发生的。当一个方法首次执行字段 get/put 或方法调用字节码时，目标字段或方法将通过其所有者类进行查找，必要时加载它。我们会检查字段类型或方法签名是否一致，并缓存查找字段或调用方法的详细信息，以便下次执行字节码时绕过链接步骤。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As with lazy loading, this lazy approach results in almost the exact same linkage being established on every run. The time spent stopping and restarting execution to lazily connect the class graph comprises a noticeable percentage of JDK startup, application startup and application warm up (time to peak running). We could speed up startup and, more crucially, warm up time if we could pre-compute this linkage and avoid the need to establish it at runtime."
msgstr "与 \"懒加载 \"一样，这种 \"懒 \"方法会导致每次运行都建立几乎完全相同的链接。为了懒散地连接类图而停止和重新启动执行所花费的时间，在 JDK 启动、应用程序启动和应用程序预热（达到运行峰值的时间）中占了相当大的比例。如果我们能预先计算这种连接，并避免在运行时建立这种连接，我们就能加快启动速度，更重要的是加快预热时间。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Synergy with Quarkus"
msgstr "与 Quarkus 的协同作用"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading and linking of classes is an important step in the warm up of the application because it involves searching through the whole classpath for all classes and objects referenced by the bytecode the JVM is going to run. By default, this is done as a lazy operation because loading and linking all existing classes in the classpath would not only require a bigger memory footprint, but also a bigger warm up time. This is why the JVM only compiles and links the bytecode that is going to be used."
msgstr "加载和链接类是预热应用程序的一个重要步骤，因为这涉及到在整个类路径中搜索 JVM 将要运行的字节码所引用的所有类和对象。默认情况下，这是作为一种懒惰操作进行的，因为加载和链接类路径中的所有现有类不仅需要占用更多内存，而且需要更长的预热时间。这就是为什么 JVM 只编译和链接将要使用的字节码。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This is a process that Quarkus already speeds up by, among other strategies, aggressively reducing the set of classes included in the classpath, so the search for matches is faster. The search for classes is also accelerated by indexes which Quarkus can generate when it fully analyzes the application at build time. But it is still a heavy operation that is difficult to execute ahead of time, before we know what is going to be run and how. Quarkus might be able to provide some additional hints to the linker in the future."
msgstr "除其他策略外，Quarkus 还通过积极减少类路径中包含的类集加快了这一过程，从而加快了搜索匹配类的速度。此外，Quarkus 还能在构建时全面分析应用程序，并生成索引，从而加快类的搜索速度。但这仍然是一项繁重的操作，在我们知道要运行什么以及如何运行之前，很难提前执行。Quarkus 也许能在未来为链接器提供一些额外的提示。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The first improvement Leyden is offering to improve startup time is to upgrade the AOT model originally developed as part of the CDS project to encompass not just pre-loading of classes but also pre-linking, as described in https://openjdk.org/jeps/8315737[JEP Ahead-of-Time Class Linking]."
msgstr "莱登为缩短启动时间而提出的第一项改进措施是升级最初作为 CDS 项目一部分而开发的 AOT 模型，使其不仅包括类的预加载，还包括预链接，如 link:https://openjdk.org/jeps/8315737[JEP Ahead-of-Time Class Linking] 中所述。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"An AOT Cache can be generated during a training run that bootstraps the JVM and, optionally, executes application-specific code.\n"
"As with a CDS archive, the AOT Cache stores a class graph for all classes loaded during the training run in a format that allows it to be quickly remapped on a subsequent run. The stored graph also includes any linkage information established by code executed during the training run. Pre-cached links avoid the need to stop and start execution to perform linkage on subsequent runs."
msgstr "AOT 缓存可在启动 JVM 的训练运行中生成，也可选择执行特定于应用程序的代码。与 CDS 存档一样，AOT 缓存为训练运行期间加载的所有类存储了一个类图，其格式允许在后续运行中快速重新映射。存储的图形还包括训练运行期间执行的代码所建立的任何链接信息。预缓存链接可避免在后续运行中停止和启动执行以执行链接。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Leyden's AOT Cache contains a lot more pre-generated content that allows us to move part of the load, link, and compiling to AOT, allowing for faster startup and warm up of the application."
msgstr "莱登的 AOT 缓存包含更多预先生成的内容，使我们可以将部分加载、链接和编译工作转移到 AOT，从而加快应用程序的启动和预热。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Remember that the training run enables some of the loading and linking to be done AOT but that anything not trained for will still be performed via the regular JIT process: the AOT approach is not required to be applied comprehensively, so that the JVM can fallback to the regular loading system for the use cases which can not benefit from AOT processing.\n"
"This ability to fallback to \"regular JIT processing\" is a luxury that GraalVM native images can't use."
msgstr "请记住，训练运行可使部分加载和链接以 AOT 方式完成，但未经过训练的任何内容仍将通过常规 JIT 流程执行：AOT 方法并不需要全面应用，这样 JVM 就可以在无法受益于 AOT 处理的用例中退回到常规加载系统。这种回退到 \"常规 JIT 处理 \"的能力是 GraalVM 本地镜像无法使用的奢侈品。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "JIT vs AOT Compilation"
msgstr "JIT 与 AOT 编译"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Another well-known lazy operation the JVM performs is JIT (runtime) compilation. Method bytecode is normally interpreted, but the JVM will lazily translate bytecode to equivalent machine code.\n"
"Since generating optimal machine code is an expensive operation, it performs this compilation task selectively, only bothering to compile methods that have been invoked quite a few times."
msgstr "JVM 执行的另一个众所周知的懒惰操作是 JIT（运行时）编译。方法字节码通常是解释的，但 JVM 会懒散地将字节码翻译成等效的机器码。由于生成最佳机器代码是一项昂贵的操作，因此 JVM 会有选择性地执行编译任务，只对调用次数较多的方法进行编译。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "JIT compilation is also 'adaptive' i.e. the JVM will lazily recompile some methods, using different 'tiers' or levels of compilation."
msgstr "JIT 编译也是 \"自适应 \"的，即 JVM 会使用不同的编译 \"层 \"或编译级别，懒散地重新编译某些方法。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 1 compile generates code that is only lightly optimised, based on very limited execution profile data."
msgstr "第 1 级编译根据非常有限的执行配置文件数据，生成的代码仅经过轻度优化。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 2 compile also generates lightly optimized code but instruments it to profile control flow."
msgstr "第 2 层编译也会生成轻度优化的代码，但会将其用于控制流剖析。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Tier 3 compilation adds further instrumentation that records many more details about what gets executed, including with what type of values."
msgstr "第 3 层编译增加了进一步的工具，可记录执行内容的更多细节，包括值的类型。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 4 compile uses all gathered profile information and performs a great deal of optimization."
msgstr "第 4 级编译会使用所有收集到的配置文件信息，并进行大量优化。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Tier 1 - 3 compilations omit many possible optimizations in order to deliver compiled code quickly. A tier 4 compilation can take much longer to complete so it is only attempted for a small subset of very frequently executed methods."
msgstr "第 1 - 3 级编译省略了许多可能的优化，以便快速交付编译后的代码。第 4 层编译可能需要更长的时间才能完成，因此只对一小部分执行频率很高的方法进行编译。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Sometimes, the code is compiled with substantial optimisations based on 'speculative' assumptions extrapolated from the profiling data.\n"
"In such cases, the compiler will make an optimistic assumption about a condition to be consistently true in the future yet include an efficient check to verify the assumption during execution so that the semantics of the program are not affected in case this educated guess eventually turns out to be false; when this is detected, the code is de-optimised, returning at a previous tier of compilation and the profiling data is adjusted, so that it will eventually be recompiled with better information.\n"
"Essentially, some parts of code might get recompiled multiple times and occasionally revert to a lower tier: it's an highly dynamic process."
msgstr "有时，根据剖析数据推断出的 \"推测性 \"假设对代码进行了大量优化编译。在这种情况下，编译器会乐观地假设某个条件在未来将持续为真，但也会在执行过程中进行有效的检查以验证该假设，从而在该推测最终被证明是错误的情况下，程序的语义不会受到影响；当检测到这种情况时，代码会被取消优化，返回到上一级编译，并对剖析数据进行调整，以便最终以更好的信息重新编译。从本质上讲，代码的某些部分可能会被重新编译多次，偶尔也会返回到较低的层级：这是一个高度动态的过程。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Peak optimization is reached when most of the running code is compiled at the highest tier, and background compilation activities become very rare or, ideally, none at all."
msgstr "当大部分运行代码都在最高层编译时，就达到了优化的顶峰，后台编译活动变得非常少，或者在理想情况下，根本没有后台编译活动。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Compiling code for peak performance also requires quite some resources, so performing this work ahead of time can also save precious CPU cycles during the application bootstrap, and can manifest in substantial memory savings as well: Java developers aren't used to measure the memory costs of the JIT compiler, but the fact that it's hidden doesn't imply it's non-existent; and while this might be a detail for large enterprise servers, it's quite important to be aware of such resource costs when developing microservices or simply aiming for smaller, more power efficient targets."
msgstr "编译代码以获得最佳性能也需要相当多的资源，因此提前执行这项工作还可以在应用程序启动期间节省宝贵的 CPU 周期，同时还可以节省大量内存：Java 开发人员并不习惯衡量 JIT 编译器的内存成本，但这一隐藏的事实并不意味着它不存在；虽然这对大型企业服务器来说可能只是一个细节，但在开发微服务或只是为了实现更小、更节能的目标时，意识到这些资源成本是非常重要的。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "But there are some limitations on what we can optimise before runtime just by examining the bytecode. For example, extensive use of reflection prevents the compiler from predicting which symbols will be loaded, linked, and most used at runtime."
msgstr "但是，我们仅通过检查字节码就能在运行前对哪些内容进行优化，这存在一定的局限性。例如，反射的广泛使用使编译器无法预测哪些符号将在运行时被加载、链接和使用。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The Leyden project has already sucessfully prototyped shifting the work of method compilation from JIT to AOT. Execution and compilation of methods is tracked during the training run. At the end of the run any associated profiling information and compiled code for the method are saved to the AOT Cache, allowing them to be quickly mapped back into memory and reused when the application is next run."
msgstr "莱顿项目已经成功地将方法编译工作从 JIT 转移到了 AOT。在培训运行期间，方法的执行和编译会被跟踪。在运行结束时，任何相关的剖析信息和方法的编译代码都会保存到 AOT 缓存中，以便在下一次运行应用程序时快速映射回内存并重新使用。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As with AOT loading and linking, the training run enables some of the work of profiling and compiling to be done AOT but allows anything not trained still to be compiled via the regular JIT compilation process. Note that method code does not need to have been compiled at the highest tier in order to be saved. Also, when code compiled at a lower tier is restored it can still be recompiled at a higher level."
msgstr "与 AOT 加载和链接一样，训练运行可使部分剖析和编译工作在 AOT 中完成，但未训练的内容仍可通过常规 JIT 编译流程进行编译。请注意，方法代码不一定要在最高层编译后才能保存。此外，在较低层次编译的代码被恢复后，仍可在较高层次重新编译。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Compiled code can also be deoptimized and re-optimized to adapt to different runtime conditions, just as with code compiled in the current runtime. So, the use of AOT compilation is fully integrated into OpenJDK's adaptive, dynamic compilation and recompilation model: even if some assumptions made during AOT compilation turn out to be suboptimal, the just-in-time compiler can intervene at runtime and improve the code with the new information."
msgstr "编译后的代码也可以去优化和重新优化，以适应不同的运行时条件，就像在当前运行时编译的代码一样。因此，AOT 编译的使用完全融入了 OpenJDK 的自适应动态编译和重新编译模型：即使在 AOT 编译过程中做出的某些假设被证明是次优的，即时编译器也能在运行时进行干预，并利用新信息改进代码。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "How to play with it"
msgstr "如何玩转它"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The first step would be to install one of the early Leyden builds that you can find at https://jdk.java.net/leyden/[jdk.java.net/leyden/]."
msgstr "第一步是安装早期的 Leyden 版本，您可以在 link:https://jdk.java.net/leyden/[jdk.java.net/leyden/] 上找到。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Make sure that you have installed it correctly by running the following command:"
msgstr "运行以下命令，确保已正确安装："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Go to the application you want to test Leyden with and start a first training run:"
msgstr "转到要测试 Leyden 的应用程序，开始第一次训练运行："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This will generate the archive files with all the profiling information needed to speed up the production run."
msgstr "这将生成包含所有剖析信息的归档文件，以加快生产运行。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Now that we have them, we can run our application using the Leyden enhancements:"
msgstr "有了它们，我们就可以使用莱登增强程序运行我们的应用程序了："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Potentially needed workarounds"
msgstr "可能需要的变通办法"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since it’s early days for the Leyden project, there are some known issues. The following instructions shouldn’t be necessary for the final versions but you might need them today."
msgstr "由于 Leyden 项目还处于早期阶段，因此存在一些已知问题。最终版本应该不需要以下说明，但现在可能需要。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force the use of G1GC"
msgstr "强制使用 G1GC"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To benefit from the natively compiled code in AOT archives, the garbage collector used at runtime needs to match the same garbage collector used when you recorded the AOT archives."
msgstr "要利用 AOT 存档中的本地编译代码，运行时使用的垃圾回收器必须与记录 AOT 存档时使用的垃圾回收器一致。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Remember that the JVM’s default choice of garbage collector is based on ergonomics; normally this is nice but it can cause some confusion in this case; for example if you build on a large server it will pick G1GC by default, but then when you run the application on a server with constrained memory it would, by default, pick SerialGC."
msgstr "请记住，JVM 默认选择的垃圾回收器是基于人体工程学原理的；这通常是件好事，但在这种情况下可能会造成一些混乱；例如，如果您在大型服务器上构建应用程序，它默认会选择 G1GC，但当您在内存有限的服务器上运行应用程序时，它默认会选择 SerialGC。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To avoid this mismatch it’s best to pick a garbage collector explicitly; and since several AOT related optimisations today only apply to G1, let’s enforce the use of G1GC."
msgstr "为了避免这种不匹配，最好明确选择一个垃圾回收器；由于目前与 AOT 相关的一些优化只适用于 G1，因此我们强制使用 G1GC。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force using G1GC:"
msgstr "使用 G1GC 施力："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "N.B. you need to use this consistently on both the process generating the AOT archives and the runtime."
msgstr "注意：您需要在生成 AOT 存档的进程和运行时间中始终使用此功能。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force the G1 Region sizes"
msgstr "强制 G1 区域大小"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"As identified and reported by the Quarkus team to our colleagues working on Project Leyden, beyond enforcing a specific garbage collector, one should also ensure that the code stored in AOT archives is being generated with the same G1 region sizes as what’s going to be used at runtime, or one risks segmentation faults caused by it wrongly identifying regions.\n"
"See https://bugs.openjdk.org/browse/JDK-8335440 for details, or simply set:"
msgstr "正如 Quarkus 团队向莱登项目的同事们指出并报告的那样，除了强制使用特定的垃圾回收器外，还应确保 AOT 存档中存储的代码在生成时使用的 G1 区域大小与运行时使用的相同，否则就有可能因错误识别区域而导致分段故障。 link:https://bugs.openjdk.org/browse/JDK-8335440[详情请参见 https://bugs.openjdk.org/browse/JDK-8335440] ，或直接设置："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Configure G1HeapRegionSize explicitly:"
msgstr "显式配置 G1HeapRegionSize："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Failure to terminate in containers"
msgstr "未在集装箱内终止"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This issue has already been resolved, but in case you’re using an older version of project Leyden and it fails to exit on regular container termination, you might be affected by https://bugs.openjdk.org/browse/JDK-8333794[JDK-8333794]."
msgstr "此问题已得到解决，但如果您使用的是旧版本的 Leyden 项目，并且在常规容器终止时无法退出，则可能会受到 link:https://bugs.openjdk.org/browse/JDK-8333794[JDK-8333794 的] 影响。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Workaround for JDK-8333794:"
msgstr "JDK-8333794 的解决方法："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Current status of Project Leyden"
msgstr "莱登项目现状"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There are already experimental https://jdk.java.net/leyden/[early-access builds of Leyden] that can be tested based on https://openjdk.org/jeps/8315737[this draft JEP about Ahead-of-Time Class Linking]."
msgstr "link:https://jdk.java.net/leyden/[莱登] 已经有了实验性 link:https://jdk.java.net/leyden/[的早期访问版本] ，可以根据 link:https://openjdk.org/jeps/8315737[这份关于超前类链接的 JEP 草案] 进行测试。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "With the Leyden Project, the idea of leveraging a \"training run\" has been extended to a wider range of data structures embedded in the new AOT cache. Now the cache produced by the AOT process contains the following data:"
msgstr "随着莱顿项目的实施，利用 \"训练运行 \"的想法已经扩展到嵌入新的 AOT 缓存中的更广泛的数据结构。现在，AOT 流程产生的缓存包含以下数据："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Class file events with historical data (Classes loaded and linked, Compilations)"
msgstr "带有历史数据的类文件事件（类的加载和链接、编译）"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Resolution of API points and indy (stored in constant pool images in the AOT archive). If you have lambdas in your code, they are captured here."
msgstr "API 点和 indy 的解析（存储在 AOT 存档中的常量池映像中）。如果您的代码中有 lambdas，也会在此捕获。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Pre-created constant objects in the Java heap (String and Class<?> constants)"
msgstr "Java 堆中预先创建的常量对象（字符串和类<?）"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Execution profiles and some compiled native code (all tiers)"
msgstr "执行配置文件和部分编译后的本地代码（所有层级）"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Leyden is also a hot topic at the https://openjdk.org/projects/mlvm/jvmlangsummit/agenda.html[JVM Language Summit] this year; as soon as the recordings of the talks about Leyden are publicly available we'll add the links here."
msgstr "Leyden 也是今年 link:https://openjdk.org/projects/mlvm/jvmlangsummit/agenda.html[JVM 语言峰会] 的热门话题；一旦有关 Leyden link:https://openjdk.org/projects/mlvm/jvmlangsummit/agenda.html[的] 会谈录音公开，我们将在此添加链接。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Some known limitations"
msgstr "一些已知的局限性"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This is an experimental project being developed by multiple teams having different approaches and focuses. Limitations explained here are being worked on at the time of writing this blog post."
msgstr "这是一个实验性项目，由多个团队开发，他们采用不同的方法，侧重点也各不相同。在撰写本博文时，我们正在研究这里解释的局限性。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "One of the main issues is that functionality is currently only available for x86_64 and AArch64 architectures at the moment."
msgstr "其中一个主要问题是，该功能目前只适用于 x86_64 和 AArch64 架构。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Also, current developments rely on a flat classpath. If the application is using custom classloaders, then it may not benefit as much as it could as it may miss caching many classes."
msgstr "此外，当前的开发依赖于扁平的类路径。如果应用程序使用自定义类加载器，那么它可能无法从中获益，因为它可能会错过许多类的缓存。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The same happens if the application is intensively using reflection. Quarkus avoids reflection whenever possible, preferring to resolve reflective calls at build time as well - so there’s a nice synergy at play."
msgstr "如果应用程序大量使用反射，也会出现同样的情况。Quarkus 尽可能避免使用反射，并倾向于在构建时解决反射调用--因此这将产生很好的协同效应。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"However Quarkus in “fast-jar” mode, which is the default packaging mode, will use a custom classloader which currently would get in the way of some Leyden optimisations. One could use a different packaging mode in Quarkus to get more prominent benefits from Leyden, but doing so would disable other Quarkus optimisations, so the comparison wouldn’t be entirely fair today.\n"
"We hope to work on improvements in this area to have all possible benefits, combined."
msgstr "然而，Quarkus 在 \"fast-jar \"模式下（这是默认的打包模式）将使用一个自定义的类加载器，而这个类加载器目前会妨碍某些 Leyden 优化功能。我们可以在 Quarkus 中使用不同的打包模式，以便从 Leyden 中获得更显著的优势，但这样做会禁用 Quarkus 的其他优化功能，因此现在的比较并不完全公平。我们希望能在这一领域进行改进，将所有可能的优势结合起来。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The focus on these first early releases has been on bootstrap times. There are measurable, significant startup time improvements, due to AOT loading and linking. In some cases, these improvements on startup time have worsened the memory footprint of some applications. That’s an already known issue that is being worked on, and the expected outcome is to improve memory footprint as well, so we would suggest not worrying too much about total memory consumption at this stage."
msgstr "第一批早期版本的重点是启动时间。由于采用了 AOT 加载和链接技术，启动时间有了明显的改善。在某些情况下，这些启动时间的改善会使某些应用程序的内存占用情况恶化。这是一个已知的问题，我们正在努力解决，预计结果也会改善内存占用，因此我们建议在现阶段不要过于担心总的内存消耗。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since the AOT archives include machine specific optimisations such as the native code generated by the C2 compiler, the training run and the production run must be done on the same type of hardware and JDK versions; it also requires using the same JAR-based classpaths and the same command line options."
msgstr "由于 AOT 存档包括机器特定的优化，如 C2 编译器生成的本地代码，因此培训运行和生产运行必须在相同类型的硬件和 JDK 版本上进行；还需要使用相同的基于 JAR 的类路径和相同的命令行选项。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Although the training run can use a different Main class to the one used for running the application, for example a test class that simulates usage."
msgstr "尽管训练运行可以使用与运行应用程序不同的 Main 类，例如模拟使用情况的测试类。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "What is on the roadmap for Leyden?"
msgstr "莱登的路线图是什么？"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There’s still work to be done regarding classes that can’t be loaded and linked in AOT with the current implementation. For example, classes loaded using a user-defined class loader. There’s also room to improve the way the training runs are made, maybe allowing the user to tweak the results to influence decisions."
msgstr "对于目前的实现方式无法在 AOT 中加载和链接的类，还有很多工作要做。例如，使用用户自定义类加载器加载的类。此外，训练运行的方式也有待改进，或许可以允许用户调整结果以影响决策。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Currently, the https://bugs.openjdk.org/browse/JDK-8326035[Z Garbage Collector] does not support AOT object archiving. There is an active effort to make sure all Garbage Collectors are compatible with these enhancements."
msgstr "目前， link:https://bugs.openjdk.org/browse/JDK-8326035[Z 垃圾收集器] 不支持 AOT 对象归档。我们正在积极努力，确保所有垃圾收集器都能与这些增强功能兼容。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There are also other things planned in the roadmap for Leyden, like adding condensers. https://openjdk.org/projects/leyden/notes/03-toward-condensers[Condensers] will be composable transformers of the source code in AOT that modify the source code optimising it. Each developer will be able to define a pipeline of condensers that improves their source code before compiling it into bytecode; this is very interesting to the Quarkus team but condensers aren’t available yet."
msgstr "莱登的路线图中还计划了其他一些内容，例如添加冷凝器。 link:https://openjdk.org/projects/leyden/notes/03-toward-condensers[冷凝器] 将是 AOT 中源代码的可组合转换器，用于修改优化源代码。每个开发人员都可以定义一个冷凝器管道，在将源代码编译成字节码之前对其进行改进；Quarkus 团队对此非常感兴趣，但目前还没有冷凝器。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The OpenJDK team is actively extending the range of compiled code that can be saved to and restored from the AOT cache. Our colleagues from Red Hat’s OpenJDK team are directly involved in this effort, looking into save and restore of auxiliary code that is normally generated at runtime and used to provide optimized code for 'intrinsic' methods or to link compiled Java method code to the compiled C code that implements the JVM, the interpreter and other compiled C libraries."
msgstr "OpenJDK 团队正在积极扩展可保存到 AOT 缓存并从 AOT 缓存中恢复的编译代码的范围。我们来自红帽 OpenJDK 团队的同事直接参与了这项工作，他们正在研究辅助代码的保存和恢复，这些代码通常在运行时生成，用于为 \"内在 \"方法提供优化代码，或将编译后的 Java 方法代码链接到实现 JVM、解释器和其他编译 C 库的编译 C 代码。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Will Leyden replace GraalVM's native-image capabilities?"
msgstr "Leyden 是否会取代 GraalVM 的原生映像功能？"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The short answer is no."
msgstr "简短的回答是否定的。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"If you want the absolute smallest footprint and ensure that absolutely no \"dynamic\" adaptations happen at runtime, GraalVM native images are the way to go. Just think about it: to support the dynamic aspects that the JVM normally provides,\n"
"even in very minimal form, you would need some code which is able to perform this work, and some memory and some computational resources to run such code and adapt your runtime safely; this is a complex feature and will never be completely free, even in the case Leyden evolved significantly beyond the current plans."
msgstr "如果您希望获得绝对最小的占用空间，并确保在运行时绝对不会发生 \"动态 \"调整，那么 GraalVM 本地镜像是您的不二之选。试想一下：要支持 JVM 通常提供的动态方面，即使是以非常小的形式，您也需要一些能够执行此工作的代码、一些内存和一些计算资源来运行这些代码并安全地调整您的运行时；这是一个复杂的功能，而且永远不会完全免费，即使 Leyden 的发展大大超出了当前的计划。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The architecture of Quarkus enables developers to define an application in strict \"closed world\" style, and this approach works extremely well in combination with GraalVM native images, but the Quarkus design works indeed very well on the bigger, dynamic JVMs as well."
msgstr "Quarkus 的架构使开发人员能够以严格的 \"封闭世界 \"风格定义应用程序，这种方法与 GraalVM 本地镜像结合使用效果极佳，但 Quarkus 的设计在更大的动态 JVM 上也确实非常有效。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The ability that Quarkus offers to create a closed world application doesn't imply that you should necessarily be doing so; in fact there are many applications which could benefit from a bit more dynamism, some more runtime configurability or auto-adaptability, and Quarkus also allows to create such applications while still benefiting from very substantial efficiency improvements over competing architectures, and even over competing runtimes and languages."
msgstr "Quarkus 提供了创建封闭世界应用程序的能力，但这并不意味着你一定要这样做；事实上，有许多应用程序可以从更多的动态性、更多的运行时可配置性或自动适应性中获益，Quarkus 也允许创建这样的应用程序，同时还能从与竞争架构相比、甚至与竞争运行时和语言相比的非常可观的效率改进中获益。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "We're very excited by Project Leyden as it allows to substantially improve bootstrap times, warmup times, and overall costs even for the \"regular\" JVM, so retaining all the benefits of a dynamic runtime and an adaptative JIT compiler, and this will be a fantastic option for all those applications for which a fully AOT native image might not be suitable: you'll get some of the benefits from native-image (not all of them) but essentially for free, at no drawbacks."
msgstr "我们对 Project Leyden 感到非常兴奋，因为它可以大幅缩短启动时间、预热时间，甚至可以降低 \"常规 \"JVM 的总体成本，从而保留动态运行时和适应性 JIT 编译器的所有优点，对于那些不适合使用完全 AOT 本地映像的应用程序来说，这将是一个绝佳的选择：您将获得本地映像的部分优点（不是全部），但基本上是免费的，没有任何缺点。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "We also hope it will bring better defined semantics in regards to running certain phases “ahead of time” (or later); there is a very interesting read on this topic by Mark Reinhold: https://openjdk.org/projects/leyden/notes/02-shift-and-constrain[Selectively Shifting and Constraining Computation] ; from a perspective of Quarkus developers, we can confirm that improvements in the language specification in this area would be very welcome, and also improve the quality and maintainability of applications compiled with GraalVM native-image(s)."
msgstr "我们还希望它能为 \"提前\"（或稍后）运行某些阶段带来更好的语义定义；马克-莱因霍尔德（Mark Reinhold）就这一主题撰写了一篇非常有趣的文章：从 Quarkus 开发人员的角度来看，我们可以肯定，语言规范在这方面的改进将是非常受欢迎的，而且还能提高使用 GraalVM 原生镜像编译的应用程序的质量和 link:https://openjdk.org/projects/leyden/notes/02-shift-and-constrain[可维护性] 。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "For these reasons, Quarkus will definitely not deprecate support for native images; it's more plausible that, eventually, the \"full JVM\" will always be benefiting from Leyden powered improvements, and as usual we'll work to make these benefits work in synergy with our architecture, and at minimal effort for you all."
msgstr "出于这些原因，Quarkus 绝对不会放弃对本地镜像的支持；更有可能的是，最终 \"完整 JVM \"将始终受益于由 Leyden 驱动的改进。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Essentially both the JVM and the native-image options are bound to benefit from this initiative. It's a great time to be a Java developer!"
msgstr "从本质上讲，JVM 和本地映像选项都将从这一举措中受益。现在是 Java 开发人员的大好时机！"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "How can I make sure this will work for me?"
msgstr "如何确保这对我有用？"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The best way to make sure your application benefits from Leyden is to start experimenting early and participate in the development. It would be great to add real-world feedback from a perspective of Quarkus users."
msgstr "确保您的应用程序从 Leyden 中受益的最佳方式是尽早开始尝试并参与开发。如果能从 Quarkus 用户的角度提供真实的反馈意见，那将是再好不过了。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "If you spend some time testing your application with the https://jdk.java.net/leyden/[early-access builds of Leyden], and https://bugs.openjdk.org/browse/JDK-8332177?jql=issuetype%20%3D%20Bug%20AND%20status%20%3D%20Open%20AND%20labels%20%3D%20leyden[reporting any bugs] or weird behaviour the developers will take your specificities into account."
msgstr "如果您花一些时间使用 link:https://jdk.java.net/leyden/[Leyden 的早期版本] 测试您的应用程序，并 link:https://bugs.openjdk.org/browse/JDK-8332177?jql=issuetype%20%3D%20Bug%20AND%20status%20%3D%20Open%20AND%20labels%20%3D%20leyden[报告任何错误] 或奇怪的行为，开发人员就会考虑到您的特殊性。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The OpenJDK issue tracker isn’t open to everyone, but you’re also very welcome to provide feedback on our https://quarkus.io/discussion/[Quarkus channels]; we can then relay any suggestions to our colleagues who are directly working on project Leyden.\n"
"You can also use the https://mail.openjdk.org/mailman/listinfo/leyden-dev[Leyden mailing list]."
msgstr "OpenJDK 问题跟踪器并不对所有人开放，但我们也非常欢迎您在我们的 link:https://quarkus.io/discussion/[Quarkus 频道] 上提供反馈意见；我们可以将任何建议转达给直接负责 Leyden 项目的同事。您也可以使用 link:https://mail.openjdk.org/mailman/listinfo/leyden-dev[莱登邮件列表] 。"
