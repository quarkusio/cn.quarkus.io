# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:1
#, fuzzy, no-wrap
msgid "cescoffier"
msgstr "鹤壁市"

#. type: YAML Front Matter: date
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:1
#, fuzzy, no-wrap
msgid "2020-12-01"
msgstr "2020-12-01"

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "职位"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:1
#, fuzzy, no-wrap
msgid "How to send and receive Cloud Events with Quarkus, Kafka and Reactive Messaging"
msgstr "如何用Quarkus、Kafka和Reactive Messaging发送和接收云事件"

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:1
#, fuzzy, no-wrap
msgid "reactive kafka"
msgstr "反应式卡夫卡"

#. type: YAML Front Matter: title
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:1
#, fuzzy, no-wrap
msgid "Sending and Receiving Cloud Events with Kafka"
msgstr "用Kafka发送和接收云事件"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:13
#, fuzzy
msgid "https://cloudevents.io/[Cloud Events] is a specification for describing events.  It aims to ease interoperability.  With the rise of event-driven architecture, it's not surprising to see Cloud Events gaining popularity."
msgstr "link:https://cloudevents.io/[云事件] 是一个描述事件的规范。它的目的是缓解互操作性。随着事件驱动架构的兴起，看到云事件的流行也就不足为奇了。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:15
#, fuzzy
msgid "This post explains how you can generate and consume Cloud Events using Quarkus, Kafka, and Reactive Messaging."
msgstr "这篇文章解释了如何使用Quarkus、Kafka和Reactive Messaging来生成和消费云事件。"

#. type: Title ==
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:16
#, fuzzy, no-wrap
msgid "What is Cloud Event?"
msgstr "什么是云事件？"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:23
#, fuzzy
msgid "First, let's look at the why.  Events are everywhere.  Many modern systems are using events one way or another.  Events can be used to implement event sourcing, communicate facts, trigger out-of-band processing, or send notifications.  Events become an essential piece of any system."
msgstr "首先，让我们看一下原因。事件无处不在。许多现代系统都以这样或那样的方式使用事件。事件可以被用来实现事件源，沟通事实，触发带外处理，或发送通知。事件成为任何系统的一个重要部分。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:29
#, fuzzy
msgid "Yet event publishers tend to describe events differently.  I don't mean the content is different, but the envelope and the event's format are heterogeneous, even if these events transit on the same event mesh.  Some applications choose JSON and encode everything in the event's payload; some other systems prefer binary formats, such as Avro or Protobuf, and use the protocol capability, such as headers or properties, to transport metadata about the wrapped payload.  While event-driven architecture claims to ease the integration with external systems, this disparity is doing the opposite.  It's not rare to need a specific event translator with the only purpose to adapt events from one format to another."
msgstr "然而，事件发布者往往以不同的方式描述事件。我的意思不是内容不同，而是信封和事件的格式是异质的，即使这些事件在同一个事件网中转。一些应用程序选择JSON，并在事件的有效载荷中编码所有内容；其他一些系统更喜欢二进制格式，如Avro或Protobuf，并使用协议能力，如头文件或属性，来传输关于包装的有效载荷的元数据。虽然事件驱动架构宣称可以缓解与外部系统的整合，但这种差异却在做相反的事情。需要一个特定的事件翻译器的情况并不罕见，其唯一目的是将事件从一种格式转换为另一种。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:36
#, fuzzy
msgid "So, what's Cloud Event? Cloud Event proposes a common way to describe events.  The goal is, obviously, interoperability and easing the integration burden.  Cloud Event 1.0 was released almost a year ago.  Over the past year, many Cloud Providers adopted this format, such as Azure and Oracle.  Several middlewares have also added support for Cloud Events, such as Knative, Kogito, Debezium, and Quarkus."
msgstr "那么，什么是云事件？云事件提出了一种描述事件的通用方法。其目标显然是互操作性和减轻集成负担。云事件1.0版几乎是在一年前发布的。在过去的一年中，许多云供应商采用了这种格式，如Azure和Oracle。一些中间件也增加了对云事件的支持，如Knative、Kogito、Debezium和Quarkus。"

#. type: Title ==
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:37
#, fuzzy, no-wrap
msgid "Show me some examples!"
msgstr "给我看一些例子!"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:40
#, fuzzy
msgid "Ok, so, how does it look? The easiest way to understand Cloud Event is to look at one of them:"
msgstr "好吧，那么，它是怎么看的？了解云事件的最简单方法是看其中一个。"

#. type: delimited block -
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:54
#, no-wrap
msgid ""
"{\n"
"    \"specversion\" : \"1.0\",\n"
"    \"id\" : \"O234-345-890\",\n"
"    \"source\" : \"https://reactive-coffee-shop.io/1234/order\",\n"
"    \"type\" : \"me.escoffier.coffee.Order\",\n"
"    \"subject\" : \"order\",\n"
"    \"time\" : \"2020-11-25T09:05:00Z\",\n"
"    \"datacontenttype\" : \"application/json\",\n"
"    \"data\" : \"{\\\"name\\\": \\\"clement\\\", \\\"order\\\":\\\"espresso\\\"}\",\n"
"    \"custom-attribute\" : \"some custom value\"\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:58
#, fuzzy
msgid "This event is described in JSON, but that's just one of the possibilities.  Let's look at the fields."
msgstr "这个事件是用JSON描述的，但这只是其中一种可能性。我们来看看这些字段。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:68
#, fuzzy
msgid "First, the `specversion` indicates which version of Cloud Event it is using (1.0).  The `id` field provides an id for that specific event.  The `source` attribute is a URI identifying the event source, i.e., the context in which an event happened or the application that emitted that specific event.  Combining the `id` and the `source` provides a unique identifier.  Such uniqueness is essential to implement idempotence and handle potential duplicates.  The `type` is the last mandatory attribute.  It indicates the _type_ of the event.  Here, I use the fully qualified class name, but you can imagine anything.  It should refer to the kind of event you have defined in your system."
msgstr "首先， `specversion` 表示它使用的是哪个版本的云事件（1.0）。 `id` 字段为该特定事件提供了一个ID。 `source` 属性是一个识别事件源的 URI，即事件发生的环境或发出该特定事件的应用程序。结合 `id` 和 `source` 提供一个唯一的标识符。这种唯一性对于实现同位素和处理潜在的重复是至关重要的。 `type` 是最后一个强制属性。它表示事件的 _类型_ 。在这里，我使用完全合格的类名，但你可以想象任何东西。它应该指的是你在你的系统中定义的事件的类型。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:75
#, fuzzy
msgid "The other attributes are optional.  `datacontenttype` defines the content-type of the `data` attribute.  `subject` allows passing extra details about the event, such as an additional hint about the context or the type of event.  `time` is a timestamp, generally indicating the creation time.  There is another optional attribute not used in my example.  The `dataschema` attribute lets you pass the schema of the event data."
msgstr "其他属性是可选的。 `datacontenttype` 定义了 `data` 属性的内容类型。 `subject` 允许传递关于事件的额外细节，例如关于上下文或事件类型的额外提示。 `time` 是一个时间戳，通常表示创建时间。还有一个可选的属性，在我的例子中没有使用。 `dataschema` 属性让你传递事件数据的模式。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:78
#, fuzzy
msgid "The `data` attribute contains the wrapped business event.  It is an essential part, and the other attributes are just providing details about that specific business event."
msgstr " `data` 属性包含被包装的业务事件。它是一个重要的部分，其他属性只是提供关于该具体业务事件的细节。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:81
#, fuzzy
msgid "You can also define _extensions_.  These extensions would be a set of custom attributes used when the proposed set of attributes is not enough for your use case."
msgstr "你也可以定义 _扩展_ 。这些扩展将是一组自定义的属性，当建议的属性集不足以满足你的使用情况时使用。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:84
#, fuzzy
msgid "That's it! So, we can summarize Cloud Events as _just enough metadata to understand an event_ - its source, an id, a type, and the business data."
msgstr "就这样吧!因此，我们可以把云事件总结为 _只需要足够的元数据来理解一个事件_ --它的来源，一个ID，一个类型，以及业务数据。"

#. type: Title ==
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:85
#, fuzzy, no-wrap
msgid "Cloud Events on the wire - the bindings"
msgstr "线上的云活动--绑定"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:89
#, fuzzy
msgid "But, how would these events be encoded? The previous example using JSON is nice, but some protocols may want to leverage their own capabilities to transmit these metadata."
msgstr "但是，如何对这些事件进行编码？之前使用JSON的例子很好，但有些协议可能想利用自己的能力来传输这些元数据。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:94
#, fuzzy
msgid "That's why Cloud Events also proposes bindings.  A binding is a set of recommendations specific to one protocol.  It explains how each protocol should encode Cloud Events.  For example, there is a binding for HTTP, one for Kafka, and another for AMQP."
msgstr "这就是为什么云事件也提出了绑定。绑定是一组针对某一协议的建议。它解释了每个协议应该如何对云事件进行编码。例如，HTTP有一个绑定，Kafka有一个，AMQP也有一个。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:96
#, fuzzy
msgid "Most of these bindings propose two approaches:"
msgstr "这些捆绑方式大多提出了两种方法。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:98
#, fuzzy
msgid "structured"
msgstr "结构化"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:99
#, fuzzy
msgid "binary"
msgstr "二进制"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:104
#, fuzzy
msgid "The structured approach keeps event metadata and data together in the payload of the message or request.  It generally uses JSON to encode that data.  If you pass the Cloud Event example (from above), in an HTTP request, it will use the structured mode.  It will also use the structured mode when you write that JSON snippet in a Kafka record's value."
msgstr "结构化方法将事件元数据和数据放在消息或请求的有效载荷中。它通常使用JSON来编码这些数据。如果你在HTTP请求中传递云事件的例子（上文），它将使用结构化模式。当你在Kafka记录的值中写入该JSON片段时，它也将使用结构化模式。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:107
#, fuzzy
msgid "The structured approach allows simple forwarding across multiple protocols.  However, it may not be efficient and may constraint the type of business data."
msgstr "结构化的方法允许在多个协议间进行简单的转发。然而，它可能并不高效，并可能限制业务数据的类型。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:111
#, fuzzy
msgid "The other approach relies on protocol capabilities and enables efficient transfer and encoding.  If we use the binary mode with Kafka, we will store the `data` attribute value in the Kafka record's value and pass the other attributes using the record's headers.  Consequently, business data can be encoded using binary protocols such as Avro, leading to higher efficiency."
msgstr "另一种方法是依靠协议能力，实现高效传输和编码。如果我们使用Kafka的二进制模式，我们将在Kafka记录的值中存储 `data` 属性值，并使用记录的头文件传递其他属性。因此，业务数据可以使用二进制协议（如Avro）进行编码，从而获得更高的效率。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:113
#, fuzzy
msgid "The rest of the post explains how you can send and receive Cloud Events using Quarkus, Kafka, and Reactive Messaging."
msgstr "帖子的其余部分解释了如何使用Quarkus、Kafka和Reactive Messaging发送和接收云事件。"

#. type: Title ==
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:114
#, fuzzy, no-wrap
msgid "Sending Cloud Events on Kafka"
msgstr "在Kafka上发送云事件"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:118
#, fuzzy
msgid "The Kafka connector used by Quarkus has built-in support for Cloud Events.  It can send and consume Cloud Events using the structured mode (encoding everything in a JSON payload) or the binary mode (using Kafka headers)."
msgstr "Quarkus使用的Kafka连接器内置了对云事件的支持。它可以使用结构化模式（将所有内容编码为JSON有效载荷）或二进制模式（使用Kafka头文件）发送和消费云事件。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:120
#, fuzzy
msgid "To write your outgoing messages as Cloud Event, you only need to specify the `cloud-events-type` and `cloud-events-source` attributes on your channel:"
msgstr "要把你发出的信息写成云事件，你只需要在你的通道上指定 `cloud-events-type` 和 `cloud-events-source` 属性。"

#. type: delimited block -
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:129
#, no-wrap
msgid ""
"mp.messaging.outgoing.generated-price.connector=smallrye-kafka\n"
"mp.messaging.outgoing.generated-price.topic=prices\n"
"mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"
"mp.messaging.outgoing.generated-price.cloud-events-source=price-generators\n"
"mp.messaging.outgoing.generated-price.cloud-events-type=price\n"
"mp.messaging.outgoing.generated-price.cloud-events-subject=generated-prices\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:134
#, fuzzy
msgid "By default, the connector writes Cloud Events using the binary mode.  The connector generates a random `id` for each message.  You can also customize the other Cloud Event attributes using `cloud-events-$attribute`, such as `cloud-events-subject`."
msgstr "默认情况下，连接器使用二进制模式写入云事件。连接器为每个消息生成一个随机的 `id` 。你也可以使用 `cloud-events-$attribute` ，定制其他的云事件属性，如 `cloud-events-subject` 。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:138
#, fuzzy
msgid "The configuration shown above is applied to all the outgoing messages.  Sometimes, you want to customize the value for each message individually.  To achieve this, you can also attach `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` to your message to customize the id, source, type and subject for each message:"
msgstr "上面显示的配置适用于所有发出的邮件。有时，你想为每封邮件单独定制值。为了实现这一点，你也可以在信息中附加 `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` ，以定制每条信息的ID、来源、类型和主题。"

#. type: delimited block -
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:149
#, no-wrap
msgid ""
"@Outgoing(\"cloud-events\")\n"
"public Message<String> toCloudEvents(Message<String> in) {\n"
"    return in.addMetadata(OutgoingCloudEventMetadata.builder()\n"
"      .withId(\"id-\" + in.getPayload())\n"
"      .withType(\"greetings\")\n"
"      .withSource(URI.create(\"http://example.com\"))\n"
"      .withSubject(\"greeting-message\") .build());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:155
#, fuzzy
msgid "The connector also supports the _structured_ mode.  You can write structured Cloud Events by setting the `cloud-events-mode` attribute to `structured`.  It only supports JSON at the moment.  The written record gets its `content-type` header set to `application/cloudevents+json; charset=UTF-8`, which allows the receiver to understand that it's a structured Cloud Event."
msgstr "该连接器还支持 _结构化_ 模式。您可以通过将 `cloud-events-mode` 属性设置为 `structured` 来编写结构化的云事件。目前，它只支持 JSON。写入的记录将其 `content-type` 头部设置为 `application/cloudevents+json; charset=UTF-8` ，这使得接收方能够理解它是一个结构化的云事件。"

#. type: Title ==
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:156
#, fuzzy, no-wrap
msgid "Consuming Cloud Event from Kafka"
msgstr "从Kafka消耗云事件"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:161
#, fuzzy
msgid "Naturally, the connector can also consume Cloud Events.  The connector detects Cloud Events automatically by checking the record's headers.  It also determines the mode."
msgstr "当然，该连接器也可以消费云事件。连接器通过检查记录的标题自动检测云事件。它还可以确定模式。"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:164
#, fuzzy
msgid "When the connector receives a Cloud Event, it attaches an `IncomingKafkaCloudEventMetadata` to the message metadata.  So, you can retrieve the various attributes as well as the extensions:"
msgstr "当连接器接收到云事件时，它会在消息元数据上附加一个 `IncomingKafkaCloudEventMetadata` 。因此，你可以检索到各种属性以及扩展。"

#. type: delimited block -
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:170
#, no-wrap
msgid ""
"public Message<Double> process(Message<Integer> priceInUsd) {\n"
"  IncomingCloudEventMetadata<Integer> cloudEventMetadata = priceInUsd.getMetadata(IncomingCloudEventMetadata.class)\n"
"    .orElseThrow(() -> new IllegalArgumentException(\"Expected a Cloud Event\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:176
#, no-wrap
msgid ""
"  LOGGER.infof(\"Received Cloud Events (spec-version: %s): source:  '%s', type: '%s', subject: '%s' \",\n"
"    cloudEventMetadata.getSpecVersion(),\n"
"    cloudEventMetadata.getSource(),\n"
"    cloudEventMetadata.getType(),\n"
"    cloudEventMetadata.getSubject().orElse(\"no subject\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:179
#, no-wrap
msgid ""
"  return priceInUsd.withPayload(Integer.valueOf(priceInUsd.getPayload()) * CONVERSION_RATE);\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:181
#, fuzzy, no-wrap
msgid "Summary"
msgstr "摘要"

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:186
msgid "With the rise of event-driven architecture, Cloud Events are becoming highly popular.  Since Quarkus 1.9, the Kafka Connector used in Quarkus has built-in support for Cloud Events.  This post introduced Cloud Events and showed how you could write and read Cloud Events easily."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-12-01-kafka-cloud-events.adoc:188
msgid "Many more options are http://smallrye.io/smallrye-reactive-messaging/3.14.1/kafka/kafka/[available], and Kafka is not the only part of Quarkus with Cloud Events support.  For example, Funqy[https://quarkus.io/guides/funqy#context-injection] also supports Cloud Event out of the box."
msgstr ""
