# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/micrometer.adoc:6
#, fuzzy, no-wrap
msgid "Micrometer Metrics"
msgstr "测微计指标"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:12
#, fuzzy
msgid "This guide demonstrates how your Quarkus application can utilize the Micrometer metrics library for runtime and application metrics."
msgstr "本指南展示了你的Quarkus应用程序如何利用Micrometer度量库进行运行时和应用程序度量。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:16
#, fuzzy
msgid "Apart from application-specific metrics, which are described in this guide, you may also utilize built-in metrics exposed by various Quarkus extensions. These are described in the guide for each particular extension that supports built-in metrics."
msgstr "除了在本指南中描述的特定应用的度量之外，你也可以利用各种Quarkus扩展所暴露的内置度量。这些将在支持内置指标的每个特定扩展的指南中描述。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:18
#, fuzzy
msgid "Micrometer is the recommended approach to metrics for Quarkus."
msgstr "Micrometer是Quarkus推荐的度量方法。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:19
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:23
#, fuzzy, no-wrap
msgid "Architecture"
msgstr "建筑学"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:31
#, fuzzy
msgid "Micrometer defines a core library providing a registration mechanism for Metrics, and core metric types (Counters, Gauges, Timers, Distribution Summaries, etc.). These core types provide an abstraction layer that can be adapted to different backend monitoring systems. In essence, your application (or a library) can `register` a `Counter`, `Gauge`, `Timer`, or `DistributionSummary` with a `MeterRegistry`. Micrometer will then delegate that registration to one or more implementations, where each implementation handles the unique considerations for the associated monitoring stack."
msgstr "Micrometer定义了一个核心库，为度量衡提供注册机制，以及核心度量衡类型（计数器、仪表、计时器、分布汇总等）。这些核心类型提供了一个抽象层，可以适应不同的后端监控系统。 `Counter` 从本质上讲，你的应用程序（或一个库）可以 `register` ， `Gauge` ， `Timer` ，或 `DistributionSummary` 与 `MeterRegistry` 。然后Micrometer会将该注册委托给一个或多个实现，每个实现都会处理相关监控栈的独特考虑。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:37
#, fuzzy
msgid "Micrometer uses naming conventions to translate between registered Meters and the conventions used by various backend registries. Meter names, for example, should be created and named using dots to separate segments, `a.name.like.this`.  Micrometer then translates that name into the format that the selected registry prefers. Prometheus uses underscores, which means the previous name will appear as `a_name_like_this` in Prometheus-formatted metrics output."
msgstr "Micrometer使用命名惯例来翻译已注册的仪表和各种后端注册机构使用的惯例。例如，仪表名称的创建和命名应使用点来分隔段， `a.name.like.this` 。然后，Micrometer将该名称翻译成所选注册机构喜欢的格式。普罗米修斯使用下划线，这意味着之前的名字在普罗米修斯格式的度量衡输出中会显示为 `a_name_like_this` 。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:38
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:42
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  You can skip right to the solution if you prefer. Either:"
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。如果你愿意，你可以直接跳到解决方案。要么。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:44
#, fuzzy
msgid "Clone the git repository: `git clone {quickstarts-clone-url}`, or"
msgstr "克隆git存储库。 `git clone {quickstarts-clone-url}` ，或"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:45
#, fuzzy
msgid "Download an {quickstarts-archive-url}[archive]."
msgstr "下载一个{quickstarts-archive-url}[档案]。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:47
#, fuzzy
msgid "The solution is located in the `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[directory]."
msgstr "该解决方案位于 `micrometer-quickstart` {quickstarts-treeurl}/micrometer-quickstart[目录]中。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:48
#, fuzzy, no-wrap
msgid "Creating the Maven Project"
msgstr "创建Maven项目"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:53
#, fuzzy
msgid "Quarkus Micrometer extensions are structured similarly to Micrometer itself: `quarkus-micrometer` provides core micrometer support and runtime integration and other Quarkus and Quarkiverse extensions bring in additional dependencies and requirements to support specific monitoring systems."
msgstr "Quarkus Micrometer扩展的结构与Micrometer本身类似： `quarkus-micrometer` ，提供核心Micrometer支持和运行时集成，其他Quarkus和Quarkiverse扩展带来额外的依赖和要求，以支持特定的监测系统。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:55
#, fuzzy
msgid "For this example, we'll use the Prometheus registry."
msgstr "在这个例子中，我们将使用普罗米修斯注册表。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:57
#, fuzzy
msgid "First, we need a new project. Create a new project with the following command:"
msgstr "首先，我们需要一个新的项目。用以下命令创建一个新项目。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:65
#, fuzzy
msgid "This command generates a Maven project, that imports the `micrometer-registry-prometheus` extension as a dependency.  This extension will load the core `micrometer` extension as well as additional library dependencies required to support prometheus."
msgstr "该命令生成一个Maven项目，将 `micrometer-registry-prometheus` 扩展作为一个依赖项导入。该扩展将加载核心的 `micrometer` 扩展，以及支持Prometheus所需的其他库依赖项。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:68
#, fuzzy
msgid "If you already have your Quarkus project configured, you can add the `micrometer-registry-prometheus` extension to your project by running the following command in your project base directory:"
msgstr "如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `micrometer-registry-prometheus` 扩展到你的项目。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:73
#, fuzzy
msgid "This will add the following to your build file:"
msgstr "这将在你的构建文件中添加以下内容。"

#. type: Block title
#: upstream/_guides/micrometer.adoc:75 upstream/_guides/micrometer.adoc:476
#: upstream/_guides/micrometer.adoc:494 upstream/_guides/micrometer.adoc:579
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:81
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/micrometer.adoc:84 upstream/_guides/micrometer.adoc:485
#: upstream/_guides/micrometer.adoc:507 upstream/_guides/micrometer.adoc:588
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:87
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-micrometer-registry-prometheus\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/micrometer.adoc:89
#, fuzzy, no-wrap
msgid "Writing the application"
msgstr "编写应用程序"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:94
#, fuzzy
msgid "Micrometer provides an API that allows you to construct your own custom metrics. The most common types of meters supported by monitoring systems are gauges, counters, and summaries. The following sections build an example endpoint, and observes endpoint behavior using these basic meter types."
msgstr "Micrometer提供了一个API，允许你构建自己的自定义度量。监测系统支持的最常见的仪表类型是仪表、计数器和总结。下面的章节构建了一个实例端点，并使用这些基本的仪表类型观察端点行为。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:97
#, fuzzy
msgid "To register meters, you need a reference to a `MeterRegistry`, which is configured and maintained by the Micrometer extension. The `MeterRegistry` can be injected into your application as follows:"
msgstr "要注册仪表，你需要一个对 `MeterRegistry` 的引用，该引用由Micrometer扩展配置和维护。 `MeterRegistry` 可以按以下方式注入到你的应用程序中。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:101
#, no-wrap
msgid "package org.acme.micrometer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:103
#, no-wrap
msgid "import io.micrometer.core.instrument.MeterRegistry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:107
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:111
#, no-wrap
msgid ""
"@Path(\"/example\")\n"
"@Produces(\"text/plain\")\n"
"public class ExampleResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:113
#, no-wrap
msgid "    private final MeterRegistry registry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:118
#, no-wrap
msgid ""
"    ExampleResource(MeterRegistry registry) {\n"
"        this.registry = registry;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:123
#, fuzzy
msgid "Micrometer maintains an internal mapping between unique metric identifier and tag combinations and specific meter instances. Using `register`, `counter`, or other methods to increment counters or record values does not create a new instance of a meter unless that combination of identifier and tag/label values hasn't been seen before."
msgstr "Micrometer在独特的公制标识符和标签组合与特定的仪表实例之间保持着一种内部映射关系。使用 `register` , `counter` , 或其他方法来增加计数器或记录数值，并不会创建一个新的仪表实例，除非该标识符和标记/标签值的组合以前未曾出现过。"

#. type: Title ===
#: upstream/_guides/micrometer.adoc:124
#, fuzzy, no-wrap
msgid "Gauges"
msgstr "计量器"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:129
#, fuzzy
msgid "Gauges measure a value that can increase or decrease over time, like the speedometer on a car. Gauges can be useful when monitoring the statistics for a cache or collection. Consider the following simple example that observes the size of a list:"
msgstr "仪表测量的是一个可以随时间增加或减少的数值，就像汽车上的速度表。仪表盘在监控一个缓存或集合的统计数据时很有用。考虑一下下面这个观察列表大小的简单例子。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:133
#, no-wrap
msgid "    LinkedList<Long> list = new LinkedList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:139
#, no-wrap
msgid ""
"    // Update the constructor to create the gauge\n"
"    ExampleResource(MeterRegistry registry) {\n"
"        this.registry = registry;\n"
"        registry.gaugeCollectionSize(\"example.list.size\", Tags.empty(), list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:156
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"gauge/{number}\")\n"
"    public Long checkListSize(long number) {\n"
"        if (number == 2 || number % 2 == 0) {\n"
"            // add even numbers to the list\n"
"            list.add(number);\n"
"        } else {\n"
"            // remove items from the list for odd numbers\n"
"            try {\n"
"                number = list.removeFirst();\n"
"            } catch (NoSuchElementException nse) {\n"
"                number = 0;\n"
"            }\n"
"        }\n"
"        return number;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:159
#, fuzzy
msgid "Note that even numbers are added to the list, and odd numbers remove an element from the list."
msgstr "请注意，偶数被添加到列表中，而奇数从列表中删除一个元素。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:161
#, fuzzy
msgid "Start your application in dev mode:"
msgstr "在开发模式下启动你的应用程序。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:165
#, fuzzy
msgid "Then try the following sequence and look for `example_list_size` in the plain text output:"
msgstr "然后尝试以下序列，在纯文本输出中寻找 `example_list_size` 。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:176
#, no-wrap
msgid ""
"curl http://localhost:8080/example/gauge/1\n"
"curl http://localhost:8080/example/gauge/2\n"
"curl http://localhost:8080/example/gauge/4\n"
"curl http://localhost:8080/q/metrics\n"
"curl http://localhost:8080/example/gauge/6\n"
"curl http://localhost:8080/example/gauge/5\n"
"curl http://localhost:8080/example/gauge/7\n"
"curl http://localhost:8080/q/metrics\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:181
#, fuzzy
msgid "It is important to note that gauges are sampled rather than set; there is no record of how the value associated with a gauge might have changed between measurements. In this example, the size of the list is observed when the Prometheus endpoint is visited."
msgstr "需要注意的是，仪表是采样的，而不是设置的；没有记录与仪表相关的值在测量之间可能发生的变化。在这个例子中，列表的大小是在访问Prometheus端点时观察到的。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:185
#, fuzzy
msgid "Micrometer provides a few additional mechanisms for creating gauges. Note that Micrometer does not create strong references to the objects it observes by default. Depending on the registry, Micrometer either omits gauges that observe objects that have been garbage-collected entirely or uses `NaN` (not a number) as the observed value."
msgstr "Micrometer提供了一些额外的机制来创建测量仪。请注意，Micrometer在默认情况下不会对它所观察的对象创建强引用。根据注册表，Micrometer或者完全省略观察已经被垃圾收集的对象的仪表，或者使用 `NaN` （不是数字）作为观察值。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:189
#, fuzzy
msgid "When should you use a Gauge? Only if you can't use something else. Never gauge something you can count. Gauges can be less straight-forward to use than counters. If what you are measuring can be counted (because the value always increments), use a counter instead."
msgstr "什么时候应该使用量具？只有在你无法使用其他东西的时候。不要用你可以计算的东西来衡量。量具的使用可能没有计数器那么直接。如果你要测量的东西可以计算（因为数值总是递增的），就用计数器代替。"

#. type: Title ===
#: upstream/_guides/micrometer.adoc:190
#, fuzzy, no-wrap
msgid "Counters"
msgstr "计数器"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:194
#, fuzzy
msgid "Counters are used to measure values that only increase. In the example below, you will count the number of times you test a number to see if it is prime:"
msgstr "计数器是用来测量只增加的数值的。在下面的例子中，你将计算你测试一个数字的次数，看它是否是质数。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:206
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"prime/{number}\")\n"
"    public String checkIfPrime(long number) {\n"
"        if (number < 1) {\n"
"            return \"Only natural numbers can be prime numbers.\";\n"
"        }\n"
"        if (number == 1 || number == 2 || number % 2 == 0) {\n"
"            return number + \" is not prime.\";\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:213
#, no-wrap
msgid ""
"        if ( testPrimeNumber(number) ) {\n"
"            return number + \" is prime.\";\n"
"        } else {\n"
"            return number + \" is not prime.\";\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:224
#, no-wrap
msgid ""
"    protected boolean testPrimeNumber(long number) {\n"
"        // Count the number of times we test for a prime number\n"
"        registry.counter(\"example.prime.number\").increment();\n"
"        for (int i = 3; i < Math.floor(Math.sqrt(number)) + 1; i = i + 2) {\n"
"            if (number % i == 0) {\n"
"                return false;\n"
"            }\n"
"        }\n"
"        return true;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:230
#, fuzzy
msgid "It might be tempting to add a label or tag to the counter indicating what value was checked, but remember that each unique combination of metric name (`example.prime.number`) and label value produces a unique time series. Using an unbounded set of data as label values can lead to a \"cardinality explosion\", an exponential increase in the creation of new time series."
msgstr "可能很想给计数器添加一个标签或标记，表明什么值被检查了，但是请记住，公制名称( `example.prime.number` )和标签值的每个独特组合都会产生一个独特的时间序列。使用无限制的数据集作为标签值会导致 \"cardinality爆炸\"，即新的时间序列的创建呈指数级增长。"

#. type: delimited block =
#: upstream/_guides/micrometer.adoc:237
#, fuzzy
msgid "Label and tag can be used interchangably. You may also see \"attribute\" used in this context in some documentation.  The gist is each that each label or tag or attribute defines an additional bit of information associated with the single numerical measurement that helps you classify, group, or aggregate the measured value later. The Micrometer API uses `Tag` as the mechanism for specifying this additional data."
msgstr "Label和tag可以互换使用。你也可能在一些文档中看到 \"属性 \"在此背景下使用。要点是每个标签或标记或属性都定义了与单一数字测量相关的额外信息，帮助你以后对测量值进行分类、分组或汇总。千分尺API使用 `Tag` 作为指定这种额外数据的机制。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:241
#, fuzzy
msgid "It is possible to add a tag that would convey a little more information, however. Let's adjust our code, and move the counter to add some tags to convey additional information."
msgstr "不过，有可能添加一个标签，传达更多的信息。让我们调整我们的代码，移动计数器，添加一些标签来传达更多信息。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:259
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"prime/{number}\")\n"
"    public String checkIfPrime(long number) {\n"
"        if (number < 1) {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"not-natural\").increment();\n"
"            return \"Only natural numbers can be prime numbers.\";\n"
"        }\n"
"        if (number == 1 ) {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"one\").increment();\n"
"            return number + \" is not prime.\";\n"
"        }\n"
"        if (number == 2 || number % 2 == 0) {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"even\").increment();\n"
"            return number + \" is not prime.\";\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:268
#, no-wrap
msgid ""
"        if ( testPrimeNumber(number) ) {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"prime\").increment();\n"
"            return number + \" is prime.\";\n"
"        } else {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"not-prime\").increment();\n"
"            return number + \" is not prime.\";\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:277
#, no-wrap
msgid ""
"    protected boolean testPrimeNumber(long number) {\n"
"        for (int i = 3; i < Math.floor(Math.sqrt(number)) + 1; i = i + 2) {\n"
"            if (number % i == 0) {\n"
"                return false;\n"
"            }\n"
"        }\n"
"        return true;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:283
#, fuzzy
msgid "Looking at the data produced by this counter, you can tell how often a negative number was checked, or the number one, or an even number, and so on. Try the following sequence and look for `example_prime_number_total` in the plain text output. Note that the `_total` suffix is added when Micrometer applies Prometheus naming conventions to `example.prime.number`, the originally specified counter name."
msgstr "看一下这个计数器产生的数据，你可以知道负数被检查的频率，或者数字1，或者偶数，等等。试试下面的序列，在纯文本输出中寻找 `example_prime_number_total` 。请注意，当Micrometer将Prometheus命名规则应用于 `example.prime.number` ，即最初指定的计数器名称时，会添加后缀 `_total` 。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:285 upstream/_guides/micrometer.adoc:339
#, fuzzy
msgid "If you did not leave Quarkus running in dev mode, start it again:"
msgstr "如果你没有让Quarkus在开发模式下运行，请再次启动它。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:289 upstream/_guides/micrometer.adoc:343
#, fuzzy
msgid "Then execute the following sequence:"
msgstr "然后执行以下顺序。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:299
#, no-wrap
msgid ""
"curl http://localhost:8080/example/prime/-1\n"
"curl http://localhost:8080/example/prime/0\n"
"curl http://localhost:8080/example/prime/1\n"
"curl http://localhost:8080/example/prime/2\n"
"curl http://localhost:8080/example/prime/3\n"
"curl http://localhost:8080/example/prime/15\n"
"curl http://localhost:8080/q/metrics\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:305
#, fuzzy
msgid "When should you use a counter? Only if you are doing something that can not be either timed (or summarized).  Counters only record a count, which may be all that is needed. However, if you want to understand more about how a value is changing, a timer (when the base unit of measurement is time) or a distribution summary might be more appropriate."
msgstr "什么时候应该使用计数器？只有当你正在做的事情不能被计时（或总结）的时候。计数器只记录一个计数，这可能就是所需的全部。但是，如果你想更多地了解一个值是如何变化的，那么计时器（当基本的测量单位是时间时）或分布汇总可能更合适。"

#. type: Title ===
#: upstream/_guides/micrometer.adoc:306
#, fuzzy, no-wrap
msgid "Summaries and Timers"
msgstr "总结和定时器"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:311
#, fuzzy
msgid "Timers and distribution summaries in Micrometer are very similar. Both allow you to record an observed value, which will be aggregated with other recorded values and stored as a sum. Micrometer also increments a counter to indicate the number of measurements that have been recorded and tracks the maximum observed value (within a decaying interval)."
msgstr "Micrometer中的定时器和分布总结非常相似。两者都允许你记录一个观察值，这个观察值将与其他记录值汇总，并作为一个总和存储。Micrometer也会递增一个计数器来表示已经记录的测量值的数量，并跟踪最大的观察值（在一个衰减的区间内）。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:316
#, fuzzy
msgid "Distribution summaries are populated by calling the `record` method to record observed values, while timers provide additional capabilities specific to working with time and measuring durations. For example, we can use a timer to measure how long it takes to calculate prime numbers using one of the `record` methods that wraps the invocation of a Supplier function:"
msgstr "分布汇总表是通过调用 `record` 方法来记录观察到的数值，而计时器则提供了专门用于处理时间和测量持续时间的额外功能。例如，我们可以使用一个计时器来测量计算素数所需的时间，使用包裹调用Supplier函数的 `record` 方法之一。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:330
#, no-wrap
msgid ""
"    protected boolean testPrimeNumber(long number) {\n"
"        Timer timer = registry.timer(\"example.prime.number.test\");\n"
"        return timer.record(() -> {\n"
"            for (int i = 3; i < Math.floor(Math.sqrt(number)) + 1; i = i + 2) {\n"
"                if (number % i == 0) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            return true;\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:337
#, fuzzy
msgid "Micrometer will apply Prometheus conventions when emitting metrics for this timer. Prometheus measures time in seconds.  Micrometer converts measured durations into seconds and includes the unit in the metric name, per convention. After visiting the prime endpoint a few more times, look in the plain text output for the following three entries: `example_prime_number_test_seconds_count`, `example_prime_number_test_seconds_sum`, and `example_prime_number_test_seconds_max`."
msgstr "Micrometer在为这个定时器发射指标时将应用Prometheus惯例。普罗米修斯测量时间的单位是秒。Micrometer将测量的持续时间转换为秒，并按照惯例在度量衡名称中包含单位。再访问几次prime端点后，在纯文本输出中寻找以下三个条目。 `example_prime_number_test_seconds_count` , `example_prime_number_test_seconds_sum` , 和 `example_prime_number_test_seconds_max` 。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:350
#, no-wrap
msgid ""
"curl http://localhost:8080/example/prime/256\n"
"curl http://localhost:8080/q/metrics\n"
"curl http://localhost:8080/example/prime/7919\n"
"curl http://localhost:8080/q/metrics\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:355
#, fuzzy
msgid "Both timers and distribution summaries can be configured to emit additional statistics, like histogram data, precomputed percentiles, or service level objective (SLO) boundaries. Note that the count, sum, and histogram data can be re-aggregated across dimensions (or across a series of instances), while precomputed percentile values cannot."
msgstr "计时器和分布摘要都可以被配置为发出额外的统计数据，如直方图数据、预先计算的百分位数或服务水平目标（SLO）的界限。请注意，计数、总和和直方图数据可以跨维度（或跨一系列实例）重新汇总，而预计算的百分位值不能。"

#. type: Title ===
#: upstream/_guides/micrometer.adoc:356
#, fuzzy, no-wrap
msgid "Review automatically generated metrics"
msgstr "审查自动生成的指标"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:359
#, fuzzy
msgid "To view metrics, execute `curl localhost:8080/q/metrics/`"
msgstr "要查看指标，请执行 `curl localhost:8080/q/metrics/` "

#. type: Plain text
#: upstream/_guides/micrometer.adoc:364
#, fuzzy
msgid "The Micrometer extension automatically times HTTP server requests. Following Prometheus naming conventions for timers, look for `http_server_requests_seconds_count`, `http_server_requests_seconds_sum`, and `http_server_requests_seconds_max`. Dimensional labels have been added for the requested uri, the HTTP method (GET, POST, etc.), the status code (200, 302, 404, etc.), and a more general outcome field."
msgstr "Micrometer扩展会自动为HTTP服务器请求计时。按照Prometheus对定时器的命名惯例，查找 `http_server_requests_seconds_count` , `http_server_requests_seconds_sum` , 和 `http_server_requests_seconds_max` 。维度标签已经被添加到请求的URI、HTTP方法（GET、POST等）、状态代码（200、302、404等）和一个更通用的结果字段。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:375
#, no-wrap
msgid ""
"# HELP http_server_requests_seconds\n"
"# TYPE http_server_requests_seconds summary\n"
"http_server_requests_seconds_count{method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/example/prime/{number}\",} 1.0\n"
"http_server_requests_seconds_sum{method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/example/prime/{number}\",} 0.017385896\n"
"# HELP http_server_requests_seconds_max\n"
"# TYPE http_server_requests_seconds_max gauge\n"
"http_server_requests_seconds_max{method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/example/prime/{number}\",} 0.017385896\n"
"#\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:379
#, fuzzy
msgid "Note that metrics appear lazily, you often won't see any data for your endpoint until something tries to access it, etc."
msgstr "请注意，指标的出现是懒散的，你通常不会看到你的端点的任何数据，直到有东西试图访问它，等等。"

#. type: Block title
#: upstream/_guides/micrometer.adoc:380
#, fuzzy, no-wrap
msgid "Ignoring endpoints"
msgstr "忽略端点"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:387
#, fuzzy
msgid "You can disable measurement of HTTP endpoints using the `quarkus.micrometer.binder.http-server.ignore-patterns` property. This property accepts a comma-separated list of simple regex match patterns identifying URI paths that should be ignored. For example, setting `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` will ignore a request to `http://localhost:8080/example/prime/7919`. A request to `http://localhost:8080/example/gauge/7919` would still be measured."
msgstr "你可以使用 `quarkus.micrometer.binder.http-server.ignore-patterns` 属性禁用对HTTP端点的测量。这个属性接受一个用逗号分隔的简单重码匹配模式的列表，识别应该被忽略的URI路径。例如，设置 `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` 将忽略对 `<a href=\"http://localhost:8080/example/prime/7919\" class=\"bare\">http://localhost:8080/example/prime/7919</a>` .一个到 `<a href=\"http://localhost:8080/example/gauge/7919\" class=\"bare\">http://localhost:8080/example/gauge/7919</a>` 的请求仍会被测量。"

#. type: Block title
#: upstream/_guides/micrometer.adoc:388
#, fuzzy, no-wrap
msgid "URI templates"
msgstr "URI模板"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:393
#, fuzzy
msgid "The micrometer extension will make a best effort at representing URIs containing path parameters in templated form.  Using examples from above, a request to `http://localhost:8080/example/prime/7919` should appear as an attribute of `http_server_requests_seconds_*` metrics with a value of `uri=/example/prime/{number}`."
msgstr "micrometer扩展将尽最大努力以模板的形式表示包含路径参数的URI。使用上面的例子，一个对 `<a href=\"http://localhost:8080/example/prime/7919\" class=\"bare\">http://localhost:8080/example/prime/7919</a>` 应该作为 `http_server_requests_seconds_*` 度量的一个属性出现，其值为 `uri=/example/prime/{number}` 。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:399
#, fuzzy
msgid "Use the `quarkus.micrometer.binder.http-server.match-patterns` property if the correct URL can not be determined. This property accepts a comma-separated list defining an association between a simple regex match pattern and a replacement string. For example, setting `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` would use the value `/example/{jellybeans}` for the uri attribute any time the requested uri matches `/example/prime/[0-9]+`."
msgstr "如果不能确定正确的URL，请使用 `quarkus.micrometer.binder.http-server.match-patterns` 属性。这个属性接受一个逗号分隔的列表，定义了一个简单的重码匹配模式和一个替换字符串之间的关联。例如，设置 `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` ，在任何时候请求的URI与 `/example/prime/[0-9]+` 匹配时，都会为URI属性使用值 `/example/{jellybeans}` 。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:400
#, fuzzy, no-wrap
msgid "Using MeterFilter to configure metrics"
msgstr "使用MeterFilter来配置指标"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:405
#, fuzzy
msgid "Micrometer uses `MeterFilter` instances to customize the metrics emitted by `MeterRegistry` instances.  The Micrometer extension will detect `MeterFilter` CDI beans and use them when initializing `MeterRegistry` instances."
msgstr "Micrometer使用 `MeterFilter` 实例来定制 `MeterRegistry` 实例发出的度量。Micrometer扩展将检测 `MeterFilter` CDI beans，并在初始化 `MeterRegistry` 实例时使用它们。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:410
#, no-wrap
msgid ""
"@Singleton\n"
"public class CustomConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:413
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"deployment.env\")\n"
"    String deploymentEnv;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:422
#, no-wrap
msgid ""
"    /** Define common tags that apply only to a Prometheus Registry */\n"
"    @Produces\n"
"    @Singleton\n"
"    @MeterFilterConstraint(applyTo = PrometheusMeterRegistry.class)\n"
"    public MeterFilter configurePrometheusRegistries() {\n"
"        return MeterFilter.commonTags(Arrays.asList(\n"
"                Tag.of(\"registry\", \"prometheus\")));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:430
#, no-wrap
msgid ""
"    /** Define common tags that apply globally */\n"
"    @Produces\n"
"    @Singleton\n"
"    public MeterFilter configureAllRegistries() {\n"
"        return MeterFilter.commonTags(Arrays.asList(\n"
"                Tag.of(\"env\", deploymentEnv)));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:450
#, no-wrap
msgid ""
"    /** Enable histogram buckets for a specific timer */\n"
"    @Produces\n"
"    @Singleton\n"
"    public MeterFilter enableHistogram() {\n"
"        return new MeterFilter() {\n"
"            @Override\n"
"            public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) {\n"
"                if(id.getName().startsWith(\"myservice\")) {\n"
"                    return DistributionStatisticConfig.builder()\n"
"                        .percentiles(0.5, 0.95)     // median and 95th percentile, not aggregable\n"
"                        .percentilesHistogram(true) // histogram buckets (e.g. prometheus histogram_quantile)\n"
"                        .build()\n"
"                        .merge(config);\n"
"                }\n"
"                return config;\n"
"            }\n"
"        };\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:457
#, fuzzy
msgid "In this example, a singleton CDI bean will produce two different `MeterFilter` beans. One will be applied only to Prometheus `MeterRegistry` instances (using the `@MeterFilterConstraint` qualifier), and another will be applied to all `MeterRegistry` instances. An application configuration property is also injected and used as a tag value.  Additional examples of MeterFilters can be found in the link:https://micrometer.io/docs/concepts[official documentation]."
msgstr "在这个例子中，一个单子CDI bean将产生两个不同的 `MeterFilter` bean。一个将只应用于Prometheus `MeterRegistry` 实例（使用 `@MeterFilterConstraint` 修饰语），另一个将应用于所有 `MeterRegistry` 实例。一个应用配置属性也被注入并作为标签值使用。MeterFilters的其他例子可以在 link:https://micrometer.io/docs/concepts[官方文档] 中找到。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:458
#, fuzzy, no-wrap
msgid "Does Micrometer support annotations?"
msgstr "Micrometer支持注释吗？"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:463
#, fuzzy
msgid "Micrometer does define two annotations, `@Counted` and `@Timed`, that can be added to methods. The `@Timed` annotation will wrap the execution of a method and will emit the following tags in addition to any tags defined on the annotation itself: class, method, and exception (either \"none\" or the simple class name of a detected exception)."
msgstr "Micrometer确实定义了两个注解， `@Counted` 和 `@Timed` ，它们可以被添加到方法中。 `@Timed` 注解将包裹一个方法的执行，除了注解本身定义的任何标签外，还将发出以下标签：类、方法和异常（\"无 \"或检测到的异常的简单类名）。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:466
#, fuzzy
msgid "Using annotations is limited, as you can't dynamically assign meaningful tag values. Also note that many methods, e.g.  REST endpoint methods or Vert.x Routes, are counted and timed by the micrometer extension out of the box."
msgstr "使用注释是有限的，因为你不能动态地分配有意义的标签值。还要注意的是，许多方法，例如REST端点方法或Vert.x Routes，都是由Micrometer扩展开箱计算和计时的。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:467
#, fuzzy, no-wrap
msgid "Using other Registry implementations"
msgstr "使用其他注册表的实现"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:474
#, fuzzy
msgid "If you aren't using Prometheus, you have a few options. Some Micrometer registry implementations have been wrapped in https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse extensions].  To use the Micrometer StackDriver MeterRegistry, for example, you would use the `quarkus-micrometer-registry-stackdriver` extension:"
msgstr "如果你不使用Prometheus，你有几个选择。一些Micrometer注册表的实现已经被包裹在 link:https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse扩展] 中了。例如，要使用Micrometer StackDriver MeterRegistry，你可以使用 `quarkus-micrometer-registry-stackdriver` 扩展。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:482
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-micrometer-registry-stackdriver</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:488
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-micrometer-registry-stackdriver\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:492
#, fuzzy
msgid "If the Micrometer registry you would like to use does not yet have an associated extension, use the `quarkus-micrometer` extension and bring in the packaged MeterRegistry dependency directly:"
msgstr "如果你想使用的Micrometer注册表还没有相关的扩展，请使用 `quarkus-micrometer` ，并直接带入打包的MeterRegistry依赖。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:504
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>com.acme</groupId>\n"
"    <artifactId>custom-micrometer-registry</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:511
#, no-wrap
msgid ""
"implementation(\"io.quarkus:quarkus-micrometer\")\n"
"implementation(\"com.acme:custom-micrometer-registry\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:515
#, fuzzy
msgid "You will then need to specify your own provider to configure and initialize the MeterRegistry, as discussed in the next section."
msgstr "然后，你将需要指定你自己的提供者来配置和初始化MeterRegistry，这将在下一节讨论。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:516
#, fuzzy, no-wrap
msgid "Creating a customized MeterRegistry"
msgstr "创建一个自定义的MeterRegistry"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:519
#, fuzzy
msgid "Use a custom `@Produces` method to create and configure a customized `MeterRegistry` if you need to."
msgstr "如果需要的话，使用自定义的 `@Produces` 方法来创建和配置一个自定义的 `MeterRegistry` 。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:521
#, fuzzy
msgid "The following example customizes the line format used for StatsD:"
msgstr "下面的例子自定义了用于StatsD的行格式。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:529
#, no-wrap
msgid ""
"@Produces\n"
"@Singleton\n"
"public StatsdMeterRegistry createStatsdMeterRegistry(StatsdConfig statsdConfig, Clock clock) {\n"
"    // define what to do with lines\n"
"    Consumer<String> lineLogger = line -> logger.info(line);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:536
#, no-wrap
msgid ""
"    // inject a configuration object, and then customize the line builder\n"
"    return StatsdMeterRegistry.builder(statsdConfig)\n"
"          .clock(clock)\n"
"          .lineSink(lineLogger)\n"
"          .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:540
#, fuzzy
msgid "This example corresponds to the following instructions in the Micrometer documentation: https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink"
msgstr "这个例子对应于Micrometer文件中的以下说明 https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink "

#. type: Plain text
#: upstream/_guides/micrometer.adoc:545
#, fuzzy
msgid "Note that the method returns the specific type of `MeterRegistry` as a `@Singleton`. Use MicroProfile Config to inject any configuration attributes you need to configure the registry. Most Micrometer registry extensions, like `quarkus-micrometer-registry-statsd`, define a producer for registry-specific configuration objects that are integrated with the Quarkus configuration model."
msgstr "请注意，该方法返回特定类型的 `MeterRegistry` ，作为一个 `@Singleton` 。使用MicroProfile Config来注入任何你需要配置注册表的配置属性。大多数Micrometer注册表扩展，如 `quarkus-micrometer-registry-statsd` ，为注册表特定的配置对象定义了一个生产者，与Quarkus配置模型集成。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:546
#, fuzzy, no-wrap
msgid "Support for the MicroProfile Metrics API"
msgstr "支持MicroProfile Metrics API"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:552
#, fuzzy
msgid "If you use the MicroProfile Metrics API in your application, the Micrometer extension will create an adaptive layer to map those metrics into the Micrometer registry. Note that naming conventions between the two systems is different, so the metrics that are emitted when using MP Metrics with Micrometer will change.  You can use a `MeterFilter` to remap names or tags according to your conventions."
msgstr "如果你在你的应用程序中使用MicroProfile Metrics API，Micrometer扩展将创建一个自适应层，把这些指标映射到Micrometer注册表中。注意，两个系统之间的命名规则是不同的，所以在Micrometer中使用MP Metrics时发出的度量将发生变化。你可以使用 `MeterFilter` ，根据你的惯例重新映射名称或标签。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:559
#, no-wrap
msgid ""
"@Produces\n"
"@Singleton\n"
"public MeterFilter renameApplicationMeters() {\n"
"    final String targetMetric = MPResourceClass.class.getName() + \".mpAnnotatedMethodName\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:574
#, no-wrap
msgid ""
"    return MeterFilter() {\n"
"        @Override\n"
"        public Meter.Id map(Meter.Id id) {\n"
"            if (id.getName().equals(targetMetric)) {\n"
"                // Drop the scope tag (MP Registry type: application, vendor, base)\n"
"                List<Tag> tags = id.getTags().stream().filter(x -> !\"scope\".equals(x.getKey()))\n"
"                        .collect(Collectors.toList());\n"
"                // rename the metric\n"
"                return id.withName(\"my.metric.name\").replaceTags(tags);\n"
"            }\n"
"            return id;\n"
"        }\n"
"    };\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:577
#, fuzzy
msgid "Ensure the following dependency is present in your build file if you require the MicroProfile Metrics API:"
msgstr "如果你需要MicroProfile Metrics API，请确保你的构建文件中存在以下依赖关系。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:585
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>org.eclipse.microprofile.metrics</groupId>\n"
"    <artifactId>microprofile-metrics-api</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:591
#, no-wrap
msgid "implementation(\"org.eclipse.microprofile.metrics:microprofile-metrics-api\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:594
msgid "The MP Metrics API compatibility layer will be moved to a different extension in the future."
msgstr ""

#. type: Title ==
#: upstream/_guides/micrometer.adoc:595
#, no-wrap
msgid "Configuration Reference"
msgstr "配置参考"
