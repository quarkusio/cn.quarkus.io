# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-29 11:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Virtual Thread support reference"
msgstr "虚拟线程支持参考"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "This guide explains how to benefit from Java 21+ virtual threads in Quarkus application."
msgstr "本指南解释了在Quarkus中编写REST服务时如何从Java 19虚拟线程中获益。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "What are virtual threads?"
msgstr "什么是虚拟线程？"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Terminology"
msgstr "术语"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "OS thread"
msgstr "操作系统线程"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "A \"thread-like\" data structure managed by the Operating System."
msgstr "一个由操作系统管理的 \"类线程 \"数据结构。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Platform thread"
msgstr "平台螺纹"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, a wrapper around an OS thread.\n"
"Creating a platform thread creates an OS thread, and blocking a platform thread blocks an OS thread."
msgstr "在 Java 19 之前， link:{thread}[Thread] 类的每个实例都是一个平台线程，是操作系统线程的包装器。创建一个平台线程会创建一个操作系统线程，阻塞一个平台线程会阻塞一个操作系统线程。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Virtual thread"
msgstr "虚拟线程"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.\n"
"Thus, scheduling virtual threads is the responsibility of the JVM."
msgstr "由 JVM 管理的轻量级线程。它们扩展了 link:{thread}[线程] 类，但不与特定的操作系统线程绑定。因此，调度虚拟线程是 JVM 的职责。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Carrier thread"
msgstr "承载线"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"A platform thread used to execute a virtual thread is called a **carrier** thread.\n"
"It isn't a class distinct from link:{Thread}[Thread] or `VirtualThread` but rather a functional denomination."
msgstr "用于执行虚拟线程的平台线程称为 *载体* 线程。它不是一个有别于 link:{Thread}[Thread] 或 `VirtualThread` 的类，而是一个功能名称。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Differences between virtual threads and platform threads"
msgstr "虚拟线程和平台线程之间的区别"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "We will give a brief overview of the topic here; please refer to the link:{vthreadjep}[JEP 425] for more information."
msgstr "我们将在此对该主题进行简要概述，更多信息请参考 link:{vthreadjep}[JEP425号] 文件。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Virtual threads are a feature available since Java 19 (Java 21 is the first LTS version including virtual threads),\n"
"aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
msgstr "虚拟线程是从 Java 19 开始提供的一项功能（Java 21 是第一个包含虚拟线程的 LTS 版本），旨在为 I/O 绑定工作负载提供平台线程的廉价替代品。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Until now, platform threads were the concurrency unit of the JVM.\n"
"They are a wrapper over OS structures.\n"
"Creating a Java platform thread creates a \"thread-like\" structure in your operating system."
msgstr "迄今为止，平台线程一直是 JVM 的并发单元。它们是操作系统结构的封装。创建 Java 平台线程可在操作系统中创建一个 \"类线程 \"结构。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Virtual threads, on the other hand, are managed by the JVM. To be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).\n"
"As such, they have been designed to offer the following characteristics:"
msgstr "虚拟线程则由 JVM 管理。要执行虚拟线程，需要将其安装在平台线程上（平台线程是虚拟线程的载体）。因此，虚拟线程在设计上具有以下特点："

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Lightweight "
msgstr "轻量级"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Virtual threads occupy less space than platform threads in memory.\n"
"Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the memory.\n"
"By default, platform threads are created with a stack of about 1 MB, whereas virtual threads stack is \"pay-as-you-go.\"\n"
"You can find these numbers and other motivations for virtual threads in this https://youtu.be/lIq-x_iI-kc?t=543[presentation] given by the lead developer of project Loom (the project that added the virtual thread support to the JVM)."
msgstr "虚拟线程占用的内存空间比平台线程小。因此，在不占用内存的情况下，可以同时使用比平台线程更多的虚拟线程。默认情况下，平台线程创建时的堆栈约为 1 MB，而虚拟线程的堆栈是 \"即用即付 \"的。您可以在 Loom 项目（为 JVM 添加虚拟线程支持的项目）首席开发人员的 link:https://youtu.be/lIq-x_iI-kc?t=543[演讲] 中找到这些数字以及虚拟线程的其他动机。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Cheap to create"
msgstr "创建成本低"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Creating a platform thread in Java takes time.\n"
"Currently, techniques such as pooling, where threads are created once and then reused, are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).\n"
"Virtual threads are supposed to be disposable entities that we create when we need them,\n"
"it is discouraged to pool them or reuse them for different tasks."
msgstr "在 Java 中创建平台线程需要时间。目前，为了尽量减少启动线程所耗费的时间（同时限制线程的最大数量，以保持较低的内存消耗），我们大力提倡池化等技术，即只创建一次线程，然后重复使用。虚拟线程应该是我们在需要时创建的一次性实体，我们不鼓励在不同任务中池化或重复使用虚拟线程。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Cheap to block"
msgstr "便于封锁"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue, and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.\n"
"Since the JVM manages virtual threads, no underlying OS thread is blocked when they perform a blocking operation.\n"
"Their state is stored in the heap, and another virtual thread is executed on the same Java platform (carrier) thread."
msgstr "在执行阻塞 I/O 时，Java 平台线程封装的底层操作系统线程会被放入等待队列，并进行上下文切换，将新的线程上下文加载到 CPU 内核上。这一操作需要时间。由于 JVM 管理的是虚拟线程，因此底层操作系统线程在执行阻塞操作时不会被阻塞。它们的状态存储在堆中，另一个虚拟线程在同一个 Java 平台（载体）线程上执行。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "The Continuation Dance"
msgstr "续舞"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "As mentioned above, the JVM schedules the virtual threads. These virtual threads are mounted on carrier threads. The scheduling comes with a pinch of magic. When the virtual thread attempts to use blocking I/O, the JVM _transforms_ this call into a non-blocking one, unmounts the virtual thread, and mounts another virtual thread on the carrier thread. When the I/O completes, the _waiting_ virtual thread becomes eligible again and will be re-mounted on a carrier thread to continue its execution. For the user, all this dance is invisible. Your synchronous code is executed asynchronously."
msgstr "如上所述，JVM 会调度虚拟线程。这些虚拟线程安装在载体线程上。这种调度有一定的魔力。当虚拟线程试图使用阻塞 I/O 时，JVM 会 _将_ 此调用 _转换_ 为非阻塞调用，卸载虚拟线程，并在载体线程上挂载另一个虚拟线程。当 I/O 完成后， _等待的_ 虚拟线程再次成为合格线程，并重新挂载到载体线程上继续执行。对于用户来说，所有这些操作都是不可见的。你的同步代码是异步执行的。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Note that the virtual thread may not be re-mounted on the same carrier thread."
msgstr "请注意，虚拟线程不得重新挂载到同一载体线程上。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Virtual threads are useful for I/O-bound workloads only"
msgstr "虚拟线程只对I/O绑定的工作负载有用"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"We now know we can create more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).\n"
"It is useless and counterproductive.\n"
"CPU-bound doesn't consist of quickly swapping threads while they need to wait for the completion of an I/O, but in leaving\n"
"them attached to a CPU core to compute something.\n"
"In this scenario, it is worse than useless to have thousands of threads if we have tens of CPU cores, virtual threads won't enhance the performance of CPU-bound workloads.\n"
"Even worse, when running a CPU-bound workload on a virtual thread, the virtual thread monopolizes the carrier thread on which it is mounted.\n"
"It will either reduce the chance for the other virtual thread to run or will start creating new carrier threads, leading to high memory usage."
msgstr "我们现在知道，我们可以创建比平台线程更多的虚拟线程。我们可能会倾向于使用虚拟线程来执行长时间计算（CPU 绑定工作负载）。但这是无用的，而且会适得其反。CPU 绑定并不包括在线程需要等待 I/O 完成时快速交换线程，而是让线程连接到 CPU 内核进行计算。在这种情况下，如果我们只有几十个 CPU 内核，那么拥有数千个线程就会变得毫无用处，虚拟线程不会提高 CPU 绑定工作负载的性能。更糟糕的是，当在虚拟线程上运行 CPU 绑定的工作负载时，虚拟线程会垄断挂载它的载体线程。它要么会减少其他虚拟线程运行的机会，要么会开始创建新的载体线程，从而导致内存使用率居高不下。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Run code on virtual threads using @RunOnVirtualThread"
msgstr "使用 @RunOnVirtualThread 在虚拟线程上运行代码"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"In Quarkus, the support of virtual thread is implemented using the link:{runonvthread}[@RunOnVirtualThread] annotation.\n"
"This section briefly overviews the rationale and how to use it.\n"
"There are dedicated guides for extensions supporting that annotation, such as:"
msgstr "在 Quarkus 中，对虚拟线程的支持是通过 link:{runonvthread}[@RunOnVirtualThread] 注解实现的。本节将简要介绍其原理和使用方法。支持该注解的扩展有专门的指南，例如"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid "xref:./rest-virtual-threads.adoc[Virtual threads in REST applications]"
msgstr "xref:./rest-virtual-threads.adoc[REST 应用程序中的虚拟线程]"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "xref:./messaging-virtual-threads.adoc[Virtual threads in reactive messaging applications]"
msgstr "xref:./messaging-virtual-threads.adoc[反应式消息传递应用程序中的虚拟线程]"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "xref:./grpc-virtual-threads.adoc[Virtual threads in gRPC services]"
msgstr "xref:./grpc-virtual-threads.adoc[gRPC 服务中的虚拟线程]"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "xref:./scheduler-reference.adoc#virtual_threads[Execute periodic tasks on virtual threads]"
msgstr "xref:./scheduler-reference.adoc#virtual_threads[在虚拟线程上执行定期任务]"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Why not run everything on virtual threads?"
msgstr "什么是虚拟线程？"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"As mentioned above, not everything can run safely on virtual threads.\n"
"The risk of **monopolization** can lead to high-memory usage.\n"
"Also, there are situations where the virtual thread cannot be unmounted from the carrier thread.\n"
"This is called **pinning**.\n"
"Finally, some libraries use `ThreadLocal` to store and reuse objects.\n"
"Using virtual threads with these libraries will lead to massive allocation, as the intentionally pooled objects will be instantiated for every (disposable and generally short-lived) virtual thread."
msgstr "如上所述，并非所有程序都能在虚拟线程上安全运行。 *垄断* 的风险会导致高内存使用率。此外，在某些情况下，虚拟线程无法从载体线程上卸载。这就是所谓的 \" *钉住\"（pinning* ）。最后，有些库使用 `ThreadLocal` 来存储和重用对象。在这些库中使用虚拟线程将导致大量分配，因为有意池化的对象将被实例化为每个虚拟线程（一次性且通常寿命较短）。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"As of today, it is not possible to use virtual threads in a carefree manner.\n"
"Following such a laissez-faire approach could quickly lead to memory and resource starvation issues.\n"
"Thus, Quarkus uses an explicit model until the aforementioned issues disappear (as the Java ecosystem matures).\n"
"It is also the reason why _reactive_ extensions have the virtual thread support, and rarely the _classic_ ones.\n"
"We need to know when to dispatch on a virtual thread."
msgstr "就目前而言，还无法无忧无虑地使用虚拟线程。采用这种自由放任的方式可能会很快导致内存和资源匮乏问题。因此，Quarkus 使用显式模型，直到上述问题消失（随着 Java 生态系统的成熟）。这也是为什么 _反应式_ 扩展支持虚拟线程，而很少支持 _经典_ 线程的原因。我们需要知道何时在虚拟线程上进行调度。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "It is essential to understand that these issues are not Quarkus limitations or bugs but are due to the current state of the Java ecosystem which needs to evolve to become virtual thread friendly."
msgstr "我们必须明白，这些问题并不是 Quarkus 的限制或错误，而是由于 Java 生态系统的现状造成的，该系统需要不断发展才能变得对虚拟线程友好。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "To learn more about the internal design and choices, check the https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment] paper."
msgstr "要了解有关内部设计和选择的更多信息，请查阅《在 link:https://dl.acm.org/doi/10.1145/3583678.3596895[Java 框架中集成虚拟线程的考虑因素：资源受限环境中的 Quarkus 示例》一文] 。"

#. type: Title ====
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Monopolization cases"
msgstr "垄断案件"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"The monopolization has been explained in the xref:cpu-bound[Virtual threads are useful for I/O-bound workloads only] section.\n"
"When running long computations, we do not allow the JVM to unmount and switch to another virtual thread until the virtual thread terminates.\n"
"Indeed, the current scheduler does not support preempting tasks."
msgstr "xref:cpu-bound[虚拟线程仅适用于 I/O 绑定的工作负载] 。在运行长时间计算时，我们不允许 JVM 卸载并切换到另一个虚拟线程，直到该虚拟线程终止。事实上，当前的调度程序并不支持抢占式任务。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"This monopolization can lead to the creation of new carrier threads to execute other virtual threads.\n"
"Creating carrier threads results in creating platform threads.\n"
"So, there is a memory cost associated with this creation."
msgstr "这种垄断会导致创建新的载体线程来执行其他虚拟线程。创建载体线程会导致创建平台线程。因此，这种创建会产生内存成本。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Suppose you run in a constrained environment, such as containers. In that case, monopolization can quickly become a concern, as the high memory usage can lead to out-of-memory issues and container termination.\n"
"The memory usage may be higher than with regular worker threads because of the inherent cost of the scheduling and virtual threads."
msgstr "假设您在容器等受限环境中运行。在这种情况下，垄断很快就会成为一个问题，因为高内存使用率会导致内存不足问题和容器终止。由于调度和虚拟线程的固有成本，内存使用量可能会高于普通工作线程。"

#. type: Title ====
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Pinning cases"
msgstr "钉子案"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"The promise of \"cheap blocking\" might not always hold: a virtual thread might _pin_ its carrier on certain occasions.\n"
"The platform thread is blocked in this situation, precisely as it would have been in a typical blocking scenario."
msgstr "廉价阻塞 \"的承诺可能并不总是有效：虚拟线程可能会在某些情况下 _锁定_ 其载体。在这种情况下，平台线程会被阻塞，就像在典型的阻塞情况下一样。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "According to link:{vthreadjep}[JEP 425] this can happen in two situations:"
msgstr "根据 link:{vthreadjep}[JEP425] ，这可能发生在两种情况下。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "when a virtual thread performs a blocking operation inside a `synchronized` block or method"
msgstr "当一个虚拟线程在一个 `synchronized` 块或方法内执行一个阻塞操作时"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "when it executes a blocking operation inside a native method or a foreign function"
msgstr "当它在一个本地方法或外国函数中执行一个阻塞操作时"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"It can be reasonably easy to avoid these situations in your code, but verifying every dependency you use is hard.\n"
"Typically, while experimenting with virtual threads, we realized that versions older than 42.6.0 of the link:{pgsql-driver}[postgresql-JDBC driver] result in frequent pinning.\n"
"Most JDBC drivers still pin the carrier thread.\n"
"Even worse, many libraries require code changes."
msgstr "要在代码中避免这些情况并不难，但要验证使用的每个依赖关系却很难。通常情况下，我们在试验虚拟线程时发现， link:{pgsql-driver}[postgresql-JDBC 驱动程序] 的版本比 42.6.0 更早，会导致频繁钉住线程。大多数 JDBC 驱动程序仍然会钉住载体线程。更糟糕的是，许多库都需要修改代码。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "For more information, see link:https://quarkus.io/blog/virtual-thread-1/[When Quarkus meets Virtual Threads]"
msgstr "更多信息，请参阅《 link:https://quarkus.io/blog/virtual-thread-1/[当 Quarkus 遇到虚拟线程] 》。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"This information about pinning cases applies to PostgreSQL JDBC driver 42.5.4 and earlier.\n"
"For PostgreSQL JDBC driver 42.6.0 and later, virtually all synchronized methods have been replaced by reentrant locks.\n"
"For more information, see the link:https://jdbc.postgresql.org/changelogs/2023-03-17-42.6.0-release/[Notable Changes] for PostgreSQL JDBC driver 42.6.0."
msgstr "这些有关钉住情况的信息适用于 PostgreSQL JDBC 驱动程序 42.5.4 及更早版本。对于PostgreSQL JDBC驱动程序42.6.0及更高版本，几乎所有同步方法都已被重入锁取代。有关详细信息，请参阅 PostgreSQL JDBC 驱动程序 42.6.0 的 link:https://jdbc.postgresql.org/changelogs/2023-03-17-42.6.0-release/[显著变更] 。"

#. type: Title ====
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "The pooling case"
msgstr "集合情况"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Some libraries are using `ThreadLocal` as an object pooling mechanism.\n"
"Extremely popular libraries like https://github.com/FasterXML/jackson-core/issues/919[Jackson] and Netty assume that the application uses a limited number of threads, which are recycled (using a thread pool) to run multiple (unrelated but sequential) tasks."
msgstr "一些库使用 `ThreadLocal` 作为对象池机制。 link:https://github.com/FasterXML/jackson-core/issues/919[Jackson] 和Netty等极为流行的库假定应用程序使用数量有限的线程，这些线程被回收（使用线程池）以运行多个（不相关但有顺序的）任务。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "This pattern has multiple advantages, such as:"
msgstr "这种模式具有多种优势，例如"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Allocation benefit: heavy objects are only allocated once per thread, but because the number of these threads was intended to be limited, it would not use too much memory."
msgstr "分配优势：每个线程只分配一次重对象，但由于这些线程的数量有限，因此不会占用太多内存。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Thread safety: only one thread can access the object stored in the thread local - preventing concurrent accesses."
msgstr "线程安全：只有一个线程可以访问存储在线程本地的对象--防止并发访问。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"However, this pattern is counter-productive when using virtual threads.\n"
"Virtual threads are not pooled and generally short-lived.\n"
"So, instead of a few of them, we now have many of them.\n"
"For each of them, the object stored in the `ThreadLocal` is created (often large and expensive) and won't be reused, as the virtual thread is not pooled (and won't be used to run another task once the execution completes).\n"
"This problem leads to high memory usage.\n"
"Unfortunately, it requires sophisticated code changes in the libraries themselves."
msgstr "不过，在使用虚拟线程时，这种模式会适得其反。虚拟线程不是池化的，通常寿命很短。因此，我们现在拥有的不是几个虚拟线程，而是许多虚拟线程。对于每一个虚拟线程，都要创建存储在 `ThreadLocal` 中的对象（通常较大且昂贵），并且不会重复使用，因为虚拟线程不是池化的（一旦执行完成，就不会用于运行另一个任务）。这个问题会导致内存使用率很高。遗憾的是，这需要对库本身进行复杂的代码修改。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Use @RunOnVirtualThread with Quarkus REST (formerly RESTEasy Reactive)"
msgstr "将 @RunOnVirtualThread 与 Quarkus REST（前身为 RESTEasy Reactive）一起使用"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"This section shows a brief example of using the link:{runonvthread}[@RunOnVirtualThread] annotation.\n"
"It also explains the various development and execution models offered by Quarkus."
msgstr "本节简要介绍了使用 link:{runonvthread}[@RunOnVirtualThread] 注解的示例。它还解释了 Quarkus 提供的各种开发和执行模式。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"The `@RunOnVirtualThread` annotation instructs Quarkus to invoke the annotated method on a **new** virtual thread instead of the current one.\n"
"Quarkus handles the creation of the virtual thread and the offloading."
msgstr "`@RunOnVirtualThread` 注解指示 Quarkus 在一个 *新的* 虚拟线程（而不是当前线程）上调用被注解的方法。Quarkus 处理虚拟线程的创建和卸载。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Since virtual threads are disposable entities, the fundamental idea of `@RunOnVirtualThread` is to offload the execution of an endpoint handler on a new virtual thread instead of running it on an event-loop or worker thread (in the case of Quarkus REST)."
msgstr "由于虚拟线程是一次性实体， `@RunOnVirtualThread` 的基本思想是在新的虚拟线程上卸载端点处理程序的执行，而不是在事件循环或工作线程上运行（在 Quarkus REST 中）。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.\n"
"If the Java Virtual Machine used to **run** the application provides virtual thread support (so Java 21 or later versions), then the endpoint execution is offloaded to a virtual thread.\n"
"It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
msgstr "为此，只需在端点中添加 link:{runonvthread}[@RunOnVirtualThread] 注解即可。如果用于 *运行* 应用程序的 Java 虚拟机提供虚拟线程支持（因此 Java 21 或更高版本），那么端点的执行将被卸载到虚拟线程。这样就可以执行阻塞操作，而不会阻塞虚拟线程所在的平台线程。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"In the case of Quarkus REST, this annotation can only be used on endpoints annotated with link:{blockingannotation}[@Blocking] or\n"
"considered blocking because of their signature.\n"
"You can visit xref:rest.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking]\n"
"for more information."
msgstr "就 Quarkus REST 而言，该注解只能用于注解为 link:{blockingannotation}[@Blocking] 或因其签名而被视为阻塞的端点。更多信息，请访问 xref:rest.adoc#execution-model-blocking-non-blocking[执行模型、阻塞、非阻塞] 。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Get started with virtual threads with Quarkus REST"
msgstr "使用 Quarkus REST 开始使用虚拟线程"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Add the following dependency to your build file:"
msgstr "在你的构建文件中添加以下导入。"

#. type: Block title
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Block title
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Then, you also need to make sure that you are using Java 21+, this can be enforced in your pom.xml file with the following:"
msgstr "你还需要确保你使用的是19版的Java，这可以在你的pom.xml文件中用下面的方法强制执行。"

#. type: Title ====
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Three development and execution models"
msgstr "三种开发和执行模式"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"The example below shows the differences between three endpoints, all of them querying a _fortune_ in the database then\n"
"returning it to the client."
msgstr "下面的示例显示了三个端点之间的差异，它们都是查询数据库中的一笔 _财富_ ，然后返回给客户端。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "the first one uses the traditional blocking style, it is considered blocking due to its signature."
msgstr "第一个是使用传统的阻断方式，由于其特征，它被认为是阻断。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "the second one uses Mutiny, it is considered non-blocking due to its signature."
msgstr "第二个是以声明的方式使用Mutiny的反应式流，由于它的签名，它被认为是非阻塞的。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"the third one uses Mutiny but in a synchronous way, since it doesn't return a \"reactive type\" it is\n"
"considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
msgstr "第三种方法使用 Mutiny，但采用同步方式，因为它不返回 \"反应式类型\"，所以被认为是阻塞的，可以使用 link:{runonvthread}[@RunOnVirtualThread] 注解。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "The following table summarizes the options:"
msgstr "下表概述了这些选项："

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Model"
msgstr "模型"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Example of signature"
msgstr "签名示例"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Pros"
msgstr "优点"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Cons"
msgstr "缺点"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Synchronous code on worker thread"
msgstr "工作线程上的同步代码"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "`Fortune blocking()`"
msgstr "`Fortune blocking()`"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Simple code"
msgstr "简单代码"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Use worker thread (limit concurrency)"
msgstr "使用工作线程（限制并发）"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Reactive code on event loop"
msgstr "事件循环上的反应代码"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "`Uni<Fortune> reactive()`"
msgstr "`Uni<Fortune> reactive()`"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "High concurrency and low resource usage"
msgstr "高并发性和低资源使用率"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "More complex code"
msgstr "更复杂的代码"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Synchronous code on virtual thread"
msgstr "什么是虚拟线程？"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "`@RunOnVirtualThread Fortune vt()`"
msgstr "`@RunOnVirtualThread Fortune vt()`"

#. type: Table
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Risk of pinning, monopolization and under-efficient object pooling"
msgstr "钉牢、垄断和效率低下的对象池风险"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Note that all three models can be used in a single application."
msgstr "请注意，所有这三种型号都可以在一个应用中使用。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Use virtual thread friendly clients"
msgstr "使用虚拟线程友好客户端"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"As mentioned in the xref:why-not[Why not run everything on virtual threads?] section, the Java ecosystem is not entirely ready for virtual threads.\n"
"So, you need to be careful, especially when using a libraries doing I/O."
msgstr "正如在 \" xref:why-not[为什么不在虚拟线程上运行一切？] \"一节中提到的，Java 生态系统尚未完全准备好使用虚拟线程。因此，您需要小心谨慎，尤其是在使用执行 I/O 的库时。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Fortunately, Quarkus provides a massive ecosystem that is ready to be used in virtual threads.\n"
"Mutiny, the reactive programming library used in Quarkus, and the Vert.x Mutiny bindings provides the ability to write blocking code (so, no fear, no learning curve) which do not pin the carrier thread."
msgstr "幸运的是，Quarkus 提供了一个可用于虚拟线程的庞大生态系统。Quarkus中使用的反应式编程库Mutiny和Vert.x Mutiny绑定提供了编写阻塞代码的能力（因此，不用担心，没有学习曲线），而这些代码不会固定在载体线程上。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "As a result:"
msgstr "因此"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Quarkus extensions providing blocking APIs on top of reactive APIs can be used in virtual threads.\n"
"This includes the REST Client, the Redis client, the mailer..."
msgstr "在反应式 API 的基础上提供阻塞式 API 的 Quarkus 扩展可以在虚拟线程中使用。这包括 REST 客户端、Redis 客户端、邮件发送器..."

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "API returning `Uni` can be used directly using `uni.await().atMost(...)`. It blocks the virtual thread, without blocking the carrier thread, and also improves the resilience of your application with an easy (non-blocking) timeout support."
msgstr "返回 `Uni` 的应用程序接口可直接使用 `uni.await().atMost(…​)` 。它可以阻塞虚拟线程，而不会阻塞载体线程，还能通过简单的（非阻塞）超时支持提高应用程序的弹性。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "If you use a https://smallrye.io/smallrye-mutiny-vertx-bindings/latest/[Vert.x client using the Mutiny bindings], use the `andAwait()` methods which block until you get the result without pinning the carrier thread. It includes all the reactive SQL drivers."
msgstr "如果您使用的是 link:https://smallrye.io/smallrye-mutiny-vertx-bindings/latest/[使用 Mutiny 绑定的 Vert.x 客户端] ，请使用 `andAwait()` 方法，该方法会阻塞直到得到结果，而不会锁定载体线程。它包括所有反应式 SQL 驱动程序。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Detect pinned thread in tests"
msgstr "在测试中检测钉住的线程"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"We recommend to use the following configuration when running tests in application using virtual threads.\n"
"If would not fail the tests, but at least dump start traces if the code pins the carrier thread:"
msgstr "在使用虚拟线程的应用程序中运行测试时，我们建议使用以下配置。这样做不会导致测试失败，但至少会在代码引脚指向载体线程时转储启动跟踪："

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Run application using virtual threads"
msgstr "什么是虚拟线程？"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Prior to Java 21, virtual threads were still an experimental feature, you need to start your application with the `--enable-preview` flag."
msgstr "虚拟线程仍然是一个实验性的功能，你需要用 `--enable-preview` 标志启动你的应用程序。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Build containers for application using virtual threads"
msgstr "使用虚拟线程为应用程序构建容器"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "When running your application in JVM mode (so not compiled into native, for native check xref:native[the dedicated section]), you can follow the xref:./container-image.adoc[containerization guide] to build a container."
msgstr "在 JVM 模式下运行应用程序时（因此未编译为本地模式，有关本地模式，请查看 xref:native[专门章节] ），可以按照 xref:./container-image.adoc[容器化指南] 来构建容器。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"In this section, we use JIB to build the container.\n"
"Refer to the xref:./container-image.adoc[containerization guide] to learn more about the alternatives."
msgstr "在本节中，我们使用 JIB 构建容器。请参阅 xref:./container-image.adoc[容器化指南] ，了解更多替代方法。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "To containerize your Quarkus application that use `@RunOnVirtualThread`, add the following properties in your `application.properties`:"
msgstr "要对使用 `@RunOnVirtualThread` 的 Quarkus 应用程序进行容器化，请在 `application.properties` 中添加以下属性："

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Make sure you use a base image supporting virtual threads. Here we use an image providing Java 21. Quarkus picks an image providing Java 21+ automatically if you do not set one."
msgstr "确保使用支持虚拟线程的基础镜像。这里我们使用的是提供 Java 21 的映像。如果没有设置，Quarkus 会自动选择提供 Java 21+ 的映像。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Select the target architecture. You can select more than one to build multi-archs images."
msgstr "选择目标架构。您可以选择多个架构来构建多架构镜像。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Then, build your container as you would do usually.\n"
"For example, if you are using Maven, run:"
msgstr "然后，像往常一样构建你的容器。例如，如果使用 Maven，请运行"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Compiling Quarkus application using virtual threads into native executable"
msgstr "使用虚拟线程将 Quarkus 应用程序编译成本地可执行文件"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Using a local GraalVM installation"
msgstr "使用本地 GraalVM 安装"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "To compile a Quarkus applications leveraging `@RunOnVirtualThread` into a native executable, you must be sure to use a GraalVM / Mandrel `native-image` supporting virtual threads, so providing at least Java 21."
msgstr "要将利用 `@RunOnVirtualThread` 的 Quarkus 应用程序编译成本地可执行文件，必须确保使用支持虚拟线程的 GraalVM / Mandrel `native-image` ，因此至少要提供 Java 21。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Build the native executable as indicated on xref:./building-native-image.adoc[the native compilation guide].\n"
"For example, with Maven, run:"
msgstr "按照 xref:./building-native-image.adoc[本地编译指南] 的指示，编译 xref:./building-native-image.adoc[本地] 可执行文件。例如，使用 Maven，运行"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Using an in-container build"
msgstr "使用容器内构建"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"In-container build allows building Linux 64 executables by using a `native-image` compiler running in a container.\n"
"It avoids having to install `native-image` on your machine, and also allows configuring the GraalVM version you need.\n"
"Note that, to use in-container build, you must have Docker or Podman installed on your machine."
msgstr "容器内构建允许使用运行在容器中的 `native-image` 编译器构建 Linux 64 可执行文件。它可以避免在机器上安装 `native-image` ，还可以配置所需的 GraalVM 版本。请注意，要使用容器内编译，必须在机器上安装 Docker 或 Podman。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Then, add to your `application.properties` file:"
msgstr "然后，添加到 `application.properties` 文件中："

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Enables the in-container build"
msgstr "启用容器内构建"

#. type: Block title
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "From ARM/64 to AMD/64"
msgstr "从 ARM/64 到 AMD/64"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"If you are using a Mac M1 or M2 (using an ARM64 CPU), you need to be aware that the native executable you will get using an in-container build will be a Linux executable, but using your host (ARM 64) architecture.\n"
"You can use emulation to force the architecture when using Docker with the following property:"
msgstr "如果你使用的是 Mac M1 或 M2（使用 ARM64 CPU），你需要注意，使用容器内构建获得的本地可执行文件将是 Linux 可执行文件，但使用的是你的主机（ARM 64）架构。在使用 Docker 时，你可以使用仿真来强制使用架构，属性如下："

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Be aware that it increases the compilation time... a lot (>10 minutes)."
msgstr "请注意，这会增加编译时间......非常长（>10 分钟）。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Containerize native applications using virtual threads"
msgstr "使用虚拟线程容器化本地应用程序"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"To build a container running a Quarkus application using virtual threads compiled into a native executable, you must\n"
"make sure you have a Linux/AMD64 executable (or ARM64 if you are targeting ARM machines)."
msgstr "要使用编译成本地可执行文件的虚拟线程构建一个运行 Quarkus 应用程序的容器，必须确保有一个 Linux/AMD64 可执行文件（如果使用的是 ARM 机器，则为 ARM64）。"

#. type: delimited block =
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Make sure your `application.properties` contains the configuration explained in xref:native[the native compilation section]."
msgstr "确保 `application.properties` 包含 xref:native[本地编译部分] 所解释的配置。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "If you ever want to build a native container image and already have an existing native image you can set `-Dquarkus.native.reuse-existing=true` and the native image build will not be re-run."
msgstr "如果你想构建原生容器镜像，而现有的原生镜像已经存在，你可以设置 `-Dquarkus.native.reuse-existing=true` ，这样原生镜像的构建就不会重新运行了。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Use the duplicated context in virtual threads"
msgstr "在虚拟线程中使用复制的上下文"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Methods annotated with `@RunOnVirtualThread` inherit from the original duplicated context (See the xref:duplicated-context.adoc[duplicated context reference guide] for details).\n"
"So, the data written in the duplicated context (and the request scope, as the request scoped is stored in the duplicated context) by filters and interceptors are available during the method execution (even if the filters and interceptors are not run on the virtual thread)."
msgstr "注释为 `@RunOnVirtualThread` 的方法继承自原始复制上下文（详情请参见 xref:duplicated-context.adoc[复制上下文参考指南] ）。因此，过滤器和拦截器写入复制上下文（以及请求作用域，因为请求作用域存储在复制上下文中）的数据在方法执行期间可用（即使过滤器和拦截器不在虚拟线程上运行）。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "However, thread locals are not propagated."
msgstr "但是，线程本地不会传播。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Virtual thread names"
msgstr "虚拟线程"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Virtual threads are created without a thread name by default, which is not practical to identify the execution for debugging and logging purposes.\n"
"Quarkus managed virtual threads are named and prefixed with `quarkus-virtual-thread-`.\n"
"You can customize this prefix, or disable the naming altogether configuring an empty value:"
msgstr "虚拟线程创建时默认没有线程名称，这不利于调试和日志记录时识别线程的执行。Quarkus 管理的虚拟线程会以 `quarkus-virtual-thread-` 命名和前缀。你可以自定义这个前缀，也可以配置一个空值来禁用命名："

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Inject the virtual thread executor"
msgstr "什么是虚拟线程？"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"In order to run tasks on virtual threads Quarkus manages an internal `ThreadPerTaskExecutor`.\n"
"In rare instances where you'd need to access this executor directly you can inject it using the `@VirtualThreads` CDI qualifier:"
msgstr "为了在虚拟线程上运行任务，Quarkus 管理着一个内部 `ThreadPerTaskExecutor` 。在极少数情况下，如果需要直接访问该执行器，可以使用 `@VirtualThreads` CDI 限定符注入该执行器："

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "Injecting the Virtual Thread ExecutorService is experimental and may change in future versions."
msgstr "注入虚拟线程 ExecutorService 是试验性的，在未来版本中可能会更改。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Testing virtual thread applications"
msgstr "测试虚拟线程应用程序"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"As mentioned above, virtual threads have a few limitations that can drastically affect your application performance and memory usage.\n"
"The _junit5-virtual-threads_ extension provides a way to detect pinned carrier threads while running your tests.\n"
"Thus, you can eliminate one of the most prominent limitations or be aware of the problem."
msgstr "如上所述，虚拟线程有一些限制，会严重影响应用程序的性能和内存使用。 _junit5-virtual-threads_ 扩展提供了一种在运行测试时检测被钉住的载波线程的方法。这样，你就可以消除最突出的限制之一或意识到问题所在。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "To enable this detection:"
msgstr "要启用此检测功能："

#: _guides/virtual-threads.adoc
#, fuzzy
msgid "1) Add the `junit5-virtual-threads` dependency to your project:"
msgstr "1) 在项目中添加 `junit5-virtual-threads` 依赖项："

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus.junit5</groupId>\n"
"    <artifactId>junit5-virtual-threads</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>"
msgstr "<dependency> <groupId>io.quarkus.junit5</groupId> <artifactId>junit5-virtual-threads</artifactId> <scope>test</scope> </dependency>"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid "2) In your test case, add the `io.quarkus.test.junit5.virtual.VirtualThreadUnit`  and `io.quarkus.test.junit.virtual.ShouldNotPin` annotations:"
msgstr "2) 在测试用例中，添加 `io.quarkus.test.junit5.virtual.VirtualThreadUnit` 和 `io.quarkus.test.junit.virtual.ShouldNotPin` 注释："

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"@QuarkusTest\n"
"@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n"
"@VirtualThreadUnit // Use the extension\n"
"@ShouldNotPin // Detect pinned carrier thread\n"
"class TodoResourceTest {\n"
"    // ...\n"
"}"
msgstr "@QuarkusTest @TestMethodOrder(MethodOrderer.OrderAnnotation.class) @VirtualThreadUnit // 使用扩展 @ShouldNotPin // 检测被钉住的载体线程 class TodoResourceTest { // ... }"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"When you run your test (remember to use Java 21+), Quarkus detects pinned carrier threads.\n"
"When it happens, the test fails."
msgstr "当你运行测试时（记住使用 Java 21+），Quarkus 会检测到被钉住的载波线程。一旦出现这种情况，测试就会失败。"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "The `@ShouldNotPin` can also be used on methods directly."
msgstr "`@ShouldNotPin` 也可以直接用于方法。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"The _junit5-virtual-threads_ also provides a `@ShouldPin` annotation for cases where pinning is unavoidable.\n"
"The following snippet demonstrates the `@ShouldPin` annotation usage."
msgstr "_junit5-virtual-threads_ 还提供了一个 `@ShouldPin` 注释，用于处理不可避免的钉扎情况。以下代码段演示了 `@ShouldPin` 注释的用法。"

#: _guides/virtual-threads.adoc
msgid "Virtual thread metrics"
msgstr ""

#: _guides/virtual-threads.adoc
msgid "You can enable the Micrometer Virtual Thread _binder_ by adding the following artifact to your application:"
msgstr ""

#: _guides/virtual-threads.adoc
msgid ""
"This binder keeps track of the number of pinning events and the number of virtual threads failed to be started or un-parked.\n"
"See the https://docs.micrometer.io/micrometer/reference/reference/jvm.html#_java_21_metrics[MicroMeter documentation] for more information."
msgstr ""

#: _guides/virtual-threads.adoc
msgid "You can explicitly disable the binder by setting the following property in your `application.properties`:"
msgstr ""

#: _guides/virtual-threads.adoc
msgid "In addition, if the application is running on a JVM that does not support virtual threads (prior to Java 21), the binder is automatically disabled."
msgstr ""

#: _guides/virtual-threads.adoc
msgid "You can associate tags to the collected metrics by setting the following properties in your `application.properties`:"
msgstr ""

#. type: Title ==
#: _guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Additional references"
msgstr "其他参考资料"

#. type: Plain text
#: _guides/virtual-threads.adoc
#, fuzzy
msgid "https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment]"
msgstr "link:https://dl.acm.org/doi/10.1145/3583678.3596895[在 Java 框架中集成虚拟线程的考虑因素：资源受限环境中的 Quarkus 示例]"
