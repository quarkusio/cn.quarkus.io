# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-11-16 17:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/virtual-threads.adoc:6
#, fuzzy, no-wrap
msgid "Writing simpler reactive REST services with Quarkus Virtual Thread support"
msgstr "用Quarkus虚拟线程支持编写更简单的反应式REST服务"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:19
#, fuzzy
msgid "This guide explains how to benefit from Java 19 virtual threads when writing REST services in Quarkus."
msgstr "本指南解释了在Quarkus中编写REST服务时如何从Java 19虚拟线程中获益。"

#. type: delimited block =
#: upstream/_guides/virtual-threads.adoc:25
#, fuzzy
msgid "This is the reference guide for using virtual threads to write reactive REST services.  Please refer to the xref:rest-json.adoc[Writing JSON REST services guides] for a lightweight introduction to reactive REST services and to the xref:resteasy-reactive.adoc[Writing REST Services with RESTEasy Reactive] guide for a detailed presentation."
msgstr "这是使用虚拟线程来编写反应式REST服务的参考指南。有关反应式REST服务的轻量级介绍，请参考 link:rest-json.html[编写JSON REST服务指南] ；有关详细介绍，请参考 link:resteasy-reactive.html[用RESTEasy Reactive编写REST服务指南] 。"

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:27
#, fuzzy, no-wrap
msgid "What are virtual threads ?"
msgstr "什么是虚拟线程？"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:29
#, fuzzy, no-wrap
msgid "Terminology"
msgstr "术语"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:30
#, fuzzy, no-wrap
msgid "OS thread"
msgstr "操作系统线程"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:32
#, fuzzy
msgid "A \"thread-like\" data-structure managed by the Operating System."
msgstr "一个由操作系统管理的 \"类线程 \"数据结构。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:33
#, fuzzy, no-wrap
msgid "Platform thread"
msgstr "平台螺纹"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:36
#, fuzzy
msgid "Up until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, that is, a wrapper around an OS thread.  Creating a platform threads creates an OS thread, blocking a platform thread blocks an OS thread."
msgstr "直到Java 19， link:{thread}[Thread] 类的每一个实例都是一个平台线程，也就是说，是对一个操作系统线程的包装。创建一个平台线程会创建一个操作系统线程，阻塞一个平台线程会阻塞一个操作系统线程。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:37
#, fuzzy, no-wrap
msgid "Virtual thread"
msgstr "虚拟线程"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:40
#, fuzzy
msgid "Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.  Thus, scheduling virtual threads is the responsibility of the JVM."
msgstr "轻量级的、由JVM管理的线程。它们扩展了 link:{thread}[Thread] 类，但不与一个特定的操作系统线程相联系。因此，调度虚拟线程是JVM的责任。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:41
#, fuzzy, no-wrap
msgid "Carrier thread"
msgstr "承载线"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:44
#, fuzzy
msgid "A platform thread used to execute a virtual thread is called a carrier.  This isn't a class distinct from link:{Thread}[Thread] or VirtualThread but rather a functional denomination."
msgstr "一个用于执行虚拟线程的平台线程被称为载体。这并不是一个有别于 link:{Thread}[Thread] 或VirtualThread的类，而是一种功能上的称谓。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:45
#, fuzzy, no-wrap
msgid "Differences between virtual threads and platform threads"
msgstr "虚拟线程和平台线程之间的区别"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:47
#, fuzzy
msgid "We will give a brief overview of the topic here, please refer to the link:{vthreadjep}[JEP 425] for more information."
msgstr "我们将在此对该主题进行简要概述，更多信息请参考 link:{vthreadjep}[JEP425号] 文件。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:49
#, fuzzy
msgid "Virtual threads are a feature available since Java 19 aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
msgstr "虚拟线程是自Java 19以来的一项功能，旨在为I/O绑定的工作负载提供平台线程的廉价替代品。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:53
#, fuzzy
msgid "Until now, platform threads were the concurrency unit of the JVM.  They are a wrapper over OS structures.  This means that creating a Java platform thread actually results in creating a \"thread-like\" structure in your operating system."
msgstr "到目前为止，平台线程是JVM的并发单元。它们是对操作系统结构的一种包装。这意味着，创建一个Java平台线程实际上是在你的操作系统中创建一个 \"类似线程 \"的结构。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:57
#, fuzzy
msgid "Virtual threads on the other hand are managed by the JVM. In order to be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).  As such, they have been designed to offer the following characteristics:"
msgstr "另一方面，虚拟线程是由JVM管理的。为了执行，它们需要被安装在一个平台线程上（它作为该虚拟线程的载体）。因此，它们被设计成具有以下特点。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:58
#, fuzzy, no-wrap
msgid "Lightweight "
msgstr "轻量级"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:62
#, fuzzy
msgid "Virtual threads occupy less space than platform threads in memory.  Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the heap.  By default, platform threads are created with a stack of about 1 MB where virtual threads stack is \"pay-as-you-go\".  You can find these numbers along with other motivations for virtual threads in this presentation given by the lead developer of project Loom: https://youtu.be/lIq-x_iI-kc?t=543."
msgstr "虚拟线程在内存中占用的空间比平台线程少。因此，有可能同时使用比平台线程更多的虚拟线程，而不会炸毁堆。默认情况下，平台线程创建时的堆栈约为1MB，而虚拟线程的堆栈是 \"随用随取 \"的。你可以在Loom项目的主要开发者的演讲中找到这些数字以及虚拟线程的其他动机 https://youtu.be/lIq-x_iI-kc?t=543 "

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:63
#, fuzzy, no-wrap
msgid "Cheap to create"
msgstr "创建成本低"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:68
#, fuzzy
msgid "Creating a platform thread in Java takes time.  Currently, techniques such as pooling where threads are created once then reused are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).  Virtual threads are supposed to be disposable entities that we create when we need them, it is discouraged to pool them or to reuse them for different tasks."
msgstr "在Java中创建一个平台线程需要时间。目前，我们强烈鼓励采用池化技术，即线程只创建一次，然后重复使用，以尽量减少启动线程的时间损失（同时限制线程的最大数量以保持低内存消耗）。虚拟线程应该是我们在需要时创建的一次性实体，我们不鼓励将它们集中起来或在不同的任务中重复使用它们。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:69
#, fuzzy, no-wrap
msgid "Cheap to block"
msgstr "便于封锁"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:73
#, fuzzy
msgid "When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.  Since virtual threads are managed by the JVM, no underlying OS thread is blocked when they perform a blocking operation.  Their state is simply stored in the heap and another Virtual thread is executed on the same Java platform thread."
msgstr "在执行阻塞式I/O时，由Java平台线程包裹的底层操作系统线程被放在一个等待队列中，并发生上下文切换，将一个新的线程上下文加载到CPU核上。这个操作需要时间。由于虚拟线程是由JVM管理的，所以当它们执行阻塞性操作时，没有底层操作系统线程被阻塞。它们的状态被简单地存储在堆中，另一个虚拟线程则在同一个Java平台线程上执行。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:74
#, fuzzy, no-wrap
msgid "Virtual threads are useful for I/O-bound workloads only"
msgstr "虚拟线程只对I/O绑定的工作负载有用"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:82
#, fuzzy
msgid "We now know that we can create way more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).  This is useless if not counterproductive.  CPU-bound doesn't consist in quickly swapping threads while they need to wait for the completion of an I/O but in leaving them attached to a CPU-core to actually compute something.  In this scenario, it is useless to have thousands of threads if we have tens of CPU-cores, virtual threads won't enhance the performance of CPU-bound workloads."
msgstr "我们现在知道，我们可以创建比平台线程多得多的虚拟线程。人们可能会被诱惑使用虚拟线程来进行长时间的计算（CPU绑定的工作负载）。这即使不是适得其反，也是无用的。绑定CPU并不意味着在需要等待I/O完成时快速交换线程，而是让它们附着在CPU核上实际计算什么。在这种情况下，如果我们有几十个CPU核，那么拥有成千上万的线程是没有用的，虚拟线程不会提高CPU绑定的工作负载的性能。"

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:84
#, fuzzy, no-wrap
msgid "Bringing virtual threads to reactive REST services"
msgstr "为反应式REST服务带来虚拟线程"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:88
#, fuzzy
msgid "Since virtual threads are disposable entities, the fundamental idea of quarkus-loom is to offload the execution of an endpoint handler on a new virtual thread instead of running it on an event-loop (in the case of RESTeasy-reactive) or a platform worker thread."
msgstr "由于虚拟线程是一次性的实体，quarkus-loom的基本思想是在一个新的虚拟线程上卸载端点处理程序的执行，而不是在事件循环（在RESTeasy-reactive的情况下）或平台工作线程上运行它。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:93
#, fuzzy
msgid "To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.  If the JDK is compatible (Java 19 or later versions) then the endpoint will be offloaded to a virtual thread.  It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
msgstr "要做到这一点，只需向端点添加 link:{runonvthread}[@RunOnVirtualThread] 注解。如果JDK是兼容的（Java 19或更高版本），那么端点将被卸载到一个虚拟线程。这样就有可能执行阻塞操作，而不会阻塞虚拟线程所在的平台线程。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:98
#, fuzzy
msgid "This annotation can only be used in conjunction with endpoints annotated with link:{blockingannotation}[@Blocking] or considered blocking because of their signature.  You can visit xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking] for more information."
msgstr "这个注解只能与用 link:{blockingannotation}[@Blocking] 注解的端点一起使用，或者因为其签名而被认为是阻塞的。你可以访问 link:resteasy-reactive.html#execution-model-blocking-non-blocking[执行模型、阻塞、非阻塞] ，了解更多信息。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:99
#, fuzzy, no-wrap
msgid "Getting started"
msgstr "开始工作"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:102
#, fuzzy
msgid "Add the following import to your build file:"
msgstr "在你的构建文件中添加以下导入。"

#. type: Block title
#: upstream/_guides/virtual-threads.adoc:104
#: upstream/_guides/virtual-threads.adoc:121
#: upstream/_guides/virtual-threads.adoc:449
#: upstream/_guides/virtual-threads.adoc:469
#: upstream/_guides/virtual-threads.adoc:502
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:110
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/virtual-threads.adoc:113
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:116
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-resteasy-reactive\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:119
#, fuzzy
msgid "You also need to make sure that you are using the version 19 of Java, this can be enforced in your pom.xml file with the following:"
msgstr "你还需要确保你使用的是19版的Java，这可以在你的pom.xml文件中用下面的方法强制执行。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:127
#, no-wrap
msgid ""
"<properties>\n"
"    <maven.compiler.source>19</maven.compiler.source>\n"
"    <maven.compiler.target>19</maven.compiler.target>\n"
"</properties>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:130
#, fuzzy
msgid "Virtual threads are still an experimental feature, you need to start your application with the `--enable-preview` flag:"
msgstr "虚拟线程仍然是一个实验性的功能，你需要用 `--enable-preview` 标志启动你的应用程序。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:134
#, no-wrap
msgid "java --enable-preview -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:138
#, fuzzy
msgid "The example below shows the differences between three endpoints, all of them querying a fortune in the database then returning it to the client."
msgstr "下面的例子显示了三个端点之间的差异，它们都是在数据库中查询财富，然后将其返回给客户。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:140
#, fuzzy
msgid "the first one uses the traditional blocking style, it is considered blocking due to its signature."
msgstr "第一个是使用传统的阻断方式，由于其特征，它被认为是阻断。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:141
#, fuzzy
msgid "the second one uses Mutiny reactive streams in a declarative style, it is considered non-blocking due to its signature."
msgstr "第二个是以声明的方式使用Mutiny的反应式流，由于它的签名，它被认为是非阻塞的。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:143
#, fuzzy
msgid "the third one uses Mutiny reactive streams in a synchronous way, since it doesn't return a \"reactive type\" it is considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
msgstr "第三种是以同步的方式使用Mutiny的反应式流，因为它没有返回 \"反应式类型\"，所以被认为是阻塞的，可以使用 link:{runonvthread}[@RunOnVirtualThread] 注解。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:147
#, fuzzy
msgid "When using Mutiny, alternative \"xAndAwait\" methods are provided to be used with virtual threads.  They ensure that waiting for the completion of the I/O will not \"pin\" the carrier thread and deteriorate performance.  Pinning is a phenomenon that we describe in xref:Pinning cases[this section]."
msgstr "当使用Mutiny时，提供了替代的 \"xAndAwait \"方法，以便与虚拟线程一起使用。它们确保等待I/O的完成不会 \"钉住 \"载波线程并使性能恶化。钉住是一种现象，我们将在 link:#Pinning cases[本节] 中描述。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:151
#, fuzzy
msgid "In other words, the mutiny environment is a safe environment for virtual threads.  The guarantees offered by Mutiny are detailed later."
msgstr "换句话说，Mutiny环境是一个虚拟线程的安全环境。Mutiny所提供的保证将在后面详述。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:155
#: upstream/_guides/virtual-threads.adoc:206
#, no-wrap
msgid "package org.acme.rest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:160
#: upstream/_guides/virtual-threads.adoc:211
#, no-wrap
msgid ""
"import org.acme.fortune.model.Fortune;\n"
"import org.acme.fortune.repository.FortuneRepository;\n"
"import io.smallrye.common.annotation.RunOnVirtualThread;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:165
#: upstream/_guides/virtual-threads.adoc:216
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import java.util.List;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:169
#: upstream/_guides/virtual-threads.adoc:220
#, no-wrap
msgid ""
"@Path(\"\")\n"
"public class FortuneResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:176
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/blocking\")\n"
"    public Fortune blocking() {\n"
"        var list = repository.findAllBlocking();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:183
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/reactive\")\n"
"    public Uni<Fortune> reactive() {\n"
"        return repository.findAllAsync()\n"
"                .map(this::pickOne);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:191
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/virtual\")\n"
"    @RunOnVirtualThread\n"
"    public Fortune virtualThread() {\n"
"        var list = repository.findAllAsyncAndAwait();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:193
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:195
#, fuzzy, no-wrap
msgid "Simplifying complex logic"
msgstr "简化复杂的逻辑"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:200
#, fuzzy
msgid "The previous example is trivial and doesn't capture how imperative style can simplify complex reactive operations.  Below is a more complex example.  The endpoints must now fetch all the fortunes in the database, then append a quote to each fortune before finally returning the result to the client."
msgstr "前面的例子是微不足道的，并没有体现出命令式风格如何简化复杂的反应式操作。下面是一个更复杂的例子。端点现在必须在数据库中获取所有的财富，然后在每个财富上附加一句话，最后将结果返回给客户端。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:222
#, no-wrap
msgid "    private final FortuneRepository repository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:227
#, no-wrap
msgid ""
"    public Uni<List<String>> getQuotesAsync(int size){\n"
"        //...\n"
"        //asynchronously returns a list of quotes from an arbitrary source\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:233
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/quoted-blocking\")\n"
"    public List<Fortune> getAllQuotedBlocking() {\n"
"        // we get the list of fortunes\n"
"        var fortunes = repository.findAllBlocking();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:236
#, no-wrap
msgid ""
"        // we get the list of quotes\n"
"        var quotes = getQuotesAsync(fortunes.size()).await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:243
#, no-wrap
msgid ""
"        // we append each quote to each fortune\n"
"        for(int i=0; i  < fortunes.size(); i ++){\n"
"            fortunes.get(i).title += \"   -  \" + quotes.get(i);\n"
"        }\n"
"        return fortunes;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:250
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/quoted-reactive\")\n"
"    public Uni<List<Fortune>> getAllQuoted() {\n"
"        // we first fetch the list of resource and we memoize it\n"
"        // to avoid fetching it again everytime need it\n"
"        var fortunes = repository.findAllAsync().memoize().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:254
#, no-wrap
msgid ""
"        // once we get a result for fortunes,\n"
"        // we know its size and can thus query the right number of quotes\n"
"        var quotes = fortunes.onItem().transformToUni(list -> getQuotesAsync(list.size()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:267
#, no-wrap
msgid ""
"        // we now need to combine the two reactive streams\n"
"        // before returning the result to the user\n"
"        return Uni.combine().all().unis(fortunes, quotes).asTuple().onItem().transform(tuple -> {\n"
"            var todoList = tuple.getItem1();\n"
"            //can await it since it is already resolved\n"
"            var quotesList = tuple.getItem2();\n"
"            for(int i=0; i  < todoList.size(); i ++){\n"
"                todoList.get(i).title += \"   -  \" + quotesList.get(i);\n"
"            }\n"
"            return todoList;\n"
"        });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:274
#, no-wrap
msgid ""
"    @GET\n"
"    @RunOnVirtualThread\n"
"    @Path(\"/quoted-virtual-thread\")\n"
"    public List<Fortune> getAllQuotedBlocking() {\n"
"        //we get the list of fortunes\n"
"        var fortunes = repository.findAllAsyncAndAwait();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:277
#, no-wrap
msgid ""
"        //we get the list of quotes\n"
"        var quotes = getQuotesAsync(fortunes.size()).await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:285
#, no-wrap
msgid ""
"        //we append each quote to each fortune\n"
"        for(int i=0; i  < fortunes.size(); i ++){\n"
"            fortunes.get(i).title += \"   -  \" + quotes.get(i);\n"
"        }\n"
"        return fortunes;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:287
#, fuzzy, no-wrap
msgid "Pinning cases"
msgstr "钉子案"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:291
#, fuzzy
msgid "The notion of \"cheap blocking\" might not always be true: in certain occasions a virtual thread might \"pin\" its carrier (the platform thread it is mounted upon).  In this situation, the platform thread is blocked exactly as it would have been in a typical blocking scenario."
msgstr "\"廉价阻塞 \"的概念可能并不总是真实的：在某些情况下，一个虚拟线程可能会 \"钉住 \"它的载体（它所挂载的平台线程）。在这种情况下，平台线程被阻塞，就像它在一个典型的阻塞情况下被阻塞一样。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:293
#, fuzzy
msgid "According to link:{vthreadjep}[JEP 425] this can happen in two situations:"
msgstr "根据 link:{vthreadjep}[JEP425] ，这可能发生在两种情况下。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:295
#, fuzzy
msgid "when a virtual thread performs a blocking operation inside a `synchronized` block or method"
msgstr "当一个虚拟线程在一个 `synchronized` 块或方法内执行一个阻塞操作时"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:296
#, fuzzy
msgid "when it executes a blocking operation inside a native method or a foreign function"
msgstr "当它在一个本地方法或外国函数中执行一个阻塞操作时"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:300
#, fuzzy
msgid "It can be fairly easy to avoid these situations in our own code, but it is hard to verify every dependency we use.  Typically, while experimenting with virtual-threads, we realized that using the link:{pgsql-driver}[postgresql-JDBC driver] results in frequent pinning."
msgstr "在我们自己的代码中避免这些情况是相当容易的，但要验证我们使用的每一个依赖关系是很难的。典型的情况是，在试验虚拟线程的时候，我们意识到使用 link:{pgsql-driver}[postgresql-JDBC驱动] 会导致频繁的钉住。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:301
#, fuzzy, no-wrap
msgid "The JDBC problem"
msgstr "JDBC问题"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:304
#, fuzzy
msgid "Our experiments so far show that when a virtual thread queries a database using the JDBC driver, it will pin its carrier thread during the entire operation."
msgstr "到目前为止，我们的实验表明，当一个虚拟线程使用JDBC驱动查询数据库时，它将在整个操作过程中钉住其载体线程。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:306
#, fuzzy
msgid "Let's show the code of the `findAllBlocking()` method we used in the first example"
msgstr "让我们展示一下我们在第一个例子中使用的 `findAllBlocking()` 方法的代码"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:310
#: upstream/_guides/virtual-threads.adoc:383
#, no-wrap
msgid "//import ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:314
#: upstream/_guides/virtual-threads.adoc:387
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FortuneRepository {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:334
#, no-wrap
msgid ""
"    public List<Fortune> findAllBlocking() {\n"
"        List<Fortune> fortunes = new ArrayList<>();\n"
"        Connection conn = null;\n"
"        try {\n"
"            conn = db.getJdbcConnection();\n"
"            var preparedStatement = conn.prepareStatement(SELECT_ALL);\n"
"            ResultSet rs = preparedStatement.executeQuery();\n"
"            while (rs.next()) {\n"
"                fortunes.add(create(rs));\n"
"            }\n"
"            rs.close();\n"
"            preparedStatement.close();\n"
"        } catch (SQLException e) {\n"
"            logger.warn(\"Unable to retrieve fortunes from the database\", e);\n"
"        } finally {\n"
"           close(conn);\n"
"        }\n"
"        return fortunes;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:337
#: upstream/_guides/virtual-threads.adoc:403
#, no-wrap
msgid ""
"    //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:341
#, fuzzy
msgid "The actual query happens at `ResultSet rs = preparedStatement.executeQuery();`, here is how it is implemented in the postgresql-jdbc driver 42.5.0:"
msgstr "实际的查询发生在 `ResultSet rs = preparedStatement.executeQuery();` ，下面是它在postgresql-jdbc驱动42.5.0中的实现方式。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:346
#, no-wrap
msgid ""
"class PgPreparedStatement extends PgStatement implements PreparedStatement {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:363
#, no-wrap
msgid ""
"    /*\n"
"    * A Prepared SQL query is executed and its ResultSet is returned\n"
"    *\n"
"    * @return a ResultSet that contains the data produced by the * query - never null\n"
"    *\n"
"    * @exception SQLException if a database access error occurs\n"
"    */\n"
"    @Override\n"
"    public ResultSet executeQuery() throws SQLException {\n"
"        synchronized (this) {\n"
"            if (!executeWithFlags(0)) {\n"
"                throw new PSQLException(GT.tr(\"No results were returned by the query.\"), PSQLState.NO_DATA);\n"
"            }\n"
"            return getSingleResultSet();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:366
#, no-wrap
msgid ""
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:371
#, fuzzy
msgid "This `synchronized` block is the culprit.  Replacing it with a lock is a good solution, but it won't be enough: `synchronized` blocks are also used in `executeWithFlags(int flag)`.  A systematic review of the postgresql-jdbc driver is necessary to make sure that it is compliant with virtual threads."
msgstr "这个 `synchronized` 块是罪魁祸首。用锁代替它是一个很好的解决方案，但这还不够： `synchronized` 块也被用在 `executeWithFlags(int flag)` 。有必要对postgresql-jdbc驱动进行系统的审查，以确保它符合虚拟线程的要求。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:372
#, fuzzy, no-wrap
msgid "Reactive drivers at the rescue"
msgstr "反应灵敏的司机在救援"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:377
#, fuzzy
msgid "The vertx-sql-client is a reactive client, hence it is not supposed to block while waiting for the completion of a transaction with the database.  However, when using the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] it is possible to use a variant method that will await for the completion of the transaction, mimicking a blocking behaviour."
msgstr "vertx-sql-client是一个反应式客户端，因此它不应该在等待数据库的事务完成时阻塞。然而，当使用 link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] 时，可以使用一个变体方法来等待事务的完成，模仿一个阻塞行为。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:379
#, fuzzy
msgid "Below is the `FortuneRepository` except the blocking we've seen earlier has been replaced by reactive methods."
msgstr "下面是 `FortuneRepository` ，只是我们之前看到的阻塞被反应式方法所取代。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:392
#, no-wrap
msgid ""
"    public Uni<List<Fortune>> findAllAsync() {\n"
"        return db.getPool()\n"
"                .preparedQuery(SELECT_ALL).execute()\n"
"                .map(this::createListOfFortunes);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:394
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:400
#, no-wrap
msgid ""
"    public List<Fortune> findAllAsyncAndAwait() {\n"
"        var rows = db.getPool().preparedQuery(SELECT_ALL)\n"
"                .executeAndAwait();\n"
"        return createListOfFortunes(rows);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:407
#, fuzzy
msgid "Contrary to the link:{pgsql-driver}[postgresql-jdbc driver], no `synchronized` block is used where it shouldn't be, and the `await` behaviour is implemented using locks and latches that won't cause pinning."
msgstr "与 link:{pgsql-driver}[postgresql-jdbc驱动] 相反，在不应该使用的地方没有使用 `synchronized` 块，而且 `await` 行为是用锁和锁存器实现的，不会导致钉死。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:411
#, fuzzy
msgid "Using the synchronous methods of the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] along with virtual threads will allow you to use the synchronous blocking style, avoid pinning the carrier thread, and get performance close to a pure reactive implementation."
msgstr "使用 link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] 的同步方法和虚拟线程将允许你使用同步阻塞风格，避免钉住载体线程，并获得接近于纯反应式实现的性能。"

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:412
#, fuzzy, no-wrap
msgid "A point about performance"
msgstr "关于性能的一点"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:418
#, fuzzy
msgid "Our experiments seem to indicate that Quarkus with virtual threads will scale better than Quarkus blocking (offloading the computation on a pool of platform worker threads) but not as well as Quarkus reactive.  The memory consumption especially might be an issue: if your system needs to keep its memory footprint low we would advise you stick to using reactive constructs."
msgstr "我们的实验似乎表明，带有虚拟线程的Quarkus将比Quarkus blocking（在平台工作线程池上卸载计算）的扩展性更好，但不如Quarkus reactive。特别是内存消耗可能是一个问题：如果你的系统需要保持低内存占用，我们会建议你坚持使用反应式结构。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:422
#, fuzzy
msgid "This degradation of performance doesn't seem to come from virtual threads themselves but from the interactions between Vert.x/Netty (Quarkus underlying reactive engine) and the virtual threads.  This was illustrated in the issue that we will now describe."
msgstr "这种性能下降似乎不是来自于虚拟线程本身，而是来自于Vert.x/Netty（Quarkus底层反应式引擎）和虚拟线程之间的相互作用。这在我们现在要描述的问题中得到了说明。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:423
#, fuzzy, no-wrap
msgid "The Netty problem"
msgstr "Netty问题"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:428
#, fuzzy
msgid "For JSON serialization, Netty uses their custom implementation of thread locals, `FastThreadLocal` to store buffers.  When using virtual threads in quarkus, the number of virtual threads simultaneously living in the service is directly related to the incoming traffic.  It is possible to get hundreds of thousands, if not millions, of them."
msgstr "对于JSON序列化，Netty使用他们自定义的线程定位实现， `FastThreadLocal` 来存储缓冲区。在quarkus中使用虚拟线程时，那么同时存在于服务中的虚拟线程的数量与传入的流量直接相关。有可能会有几十万，甚至上百万个。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:432
#, fuzzy
msgid "If they need to serialize some data to JSON they will end up creating as many instances of `FastThreadLocal`, resulting on a massive memory consumption as well as exacerbated pressure on the garbage collector.  This will eventually affect the performance of the application and inhibit its scalability."
msgstr "如果他们需要将一些数据序列化为JSON，他们最终会创建尽可能多的 `FastThreadLocal` ，从而导致大量的内存消耗，并加剧了垃圾收集器的压力。这最终会影响应用程序的性能，并抑制其可扩展性。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:439
#, fuzzy
msgid "This is a perfect example of the mismatch between the reactive stack and the virtual threads.  The fundamental hypothesis are completely different and result in different optimizations.  Netty expects a system using few event-loops (as many event-loops as CPU cores by default in Quarkus), but it gets hundreds of thousands of threads.  You can refer to link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[this mail] to get more information on how we envision our future with virtual threads."
msgstr "这是反应堆和虚拟线程之间不匹配的一个完美例子。基本假设完全不同，导致了不同的优化。Netty期望一个使用少量事件循环的系统（在Quarkus中默认情况下，事件循环的数量与CPU内核一样多），但它得到的却是成百上千的线程。你可以参考 link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[这封邮件] ，以获得更多关于我们对虚拟线程的未来设想的信息。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:440
#, fuzzy, no-wrap
msgid "Our solution to the Netty problem"
msgstr "我们对Netty问题的解决方案"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:445
#, fuzzy
msgid "In order to avoid this wasting of resource without modifying Netty upstream, we wrote an extension that modifies the bytecode of the class responsible for creating the thread locals at build time.  Using this extension, performance of virtual threads in Quarkus for the Json Serialization test of the Techempower suite increased by nearly 80%, making it almost as good as reactive endpoints."
msgstr "为了避免这种资源的浪费而不需要修改Netty的上游，我们写了一个扩展，在构建时修改了负责创建线程局部的类的字节码。使用这个扩展，Quarkus中的虚拟线程在Techempower套件的Json序列化测试中的性能提高了近80%，使其几乎与反应式端点一样好。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:447
#, fuzzy
msgid "To use it, it needs to be added as a dependency:"
msgstr "要使用它，需要将它作为一个依赖项添加。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:455
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-netty-loom-adaptor</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:458
msgid "Furthermore, some operations undertaken by this extension need special access, it is necessary to"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:460
msgid "compile the application with the flag `-Dnet.bytebuddy.experimental`"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:461
msgid "open the `java.base.lang` module at runtime with the flag `--add-opens java.base/java.lang=ALL-UNNAMED`"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:463
msgid "This extension is only intended to improve performance, it is perfectly fine not to use it."
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:464
#, no-wrap
msgid "Concerning dev mode"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:467
msgid "If you want to use quarkus with the dev mode, it won't be possible to manually specify the flags we mentioned along this guide.  Instead, you want to specify them all in the configuration of the `quarkus-maven-plugin` as presented below."
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:482
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-maven-plugin</artifactId>\n"
"    <version>${quarkus.version}</version>\n"
"    <executions>\n"
"        <execution>\n"
"            <goals>\n"
"                <goal>build</goal>\n"
"            </goals>\n"
"        </execution>\n"
"    </executions>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:492
#, no-wrap
msgid ""
"    <configuration>\n"
"      <source>19</source>\n"
"      <target>19</target>\n"
"      <compilerArgs>\n"
"        <arg>--enable-preview</arg>\n"
"        <arg>-Dnet.bytebuddy.experimental</arg>\n"
"      </compilerArgs>\n"
"      <jvmArgs>--enable-preview --add-opens java.base/java.lang=ALL-UNNAMED</jvmArgs>\n"
"    </configuration>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:494
#, no-wrap
msgid "</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:498
msgid "If you don't want to specify the opening of the `java.lang` module in your pom.xml file, you can also specify it as an argument when you start the dev mode."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:500
msgid "The configuration of the quarkus-maven-plugin will be simpler:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:513
#, no-wrap
msgid ""
"    <configuration>\n"
"      <source>19</source>\n"
"      <target>19</target>\n"
"      <compilerArgs>\n"
"        <arg>--enable-preview</arg>\n"
"        <arg>-Dnet.bytebuddy.experimental</arg>\n"
"      </compilerArgs>\n"
"      <jvmArgs>--enable-preview</jvmArgs>\n"
"    </configuration>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:516
msgid "And the command will become:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:520
#, no-wrap
msgid "mvn quarkus:dev -Dopen-lang-package\n"
msgstr ""
