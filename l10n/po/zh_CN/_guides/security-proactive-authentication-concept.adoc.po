# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-04-26 15:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/security-proactive-authentication-concept.adoc:7
#, no-wrap
msgid "Proactive authentication"
msgstr "主动认证"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:12
#, fuzzy
msgid "Proactive authentication is enabled in Quarkus by default. This means that if an incoming request has a credential then that request will always be authenticated, even if the target page does not require authentication."
msgstr "Quarkus默认启用了主动认证。这意味着，如果一个传入的请求有一个证书，那么这个请求将总是被认证，即使目标页面不需要认证。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:16
#, fuzzy
msgid "Requests with an invalid credential will always be rejected, even when the page is public."
msgstr "无效凭证的请求将总是被拒绝，即使页面是公开的。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:18
#, fuzzy
msgid "You can change the default behavior if you only want to authenticate when the target page requires authentication."
msgstr "如果你只想在目标页面需要认证时进行认证，你可以改变默认行为。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:20
#, fuzzy
msgid "To disable proactive authentication in Quarkus, set the following attribute in the `application.properties` configuration file:"
msgstr "要在Quarkus中禁用主动认证，请在 `application.properties` 配置文件中设置以下属性："

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:24
#, no-wrap
msgid "`quarkus.http.auth.proactive=false` \n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:27
#, fuzzy
msgid "If you disable proactive authentication, the authentication process runs only when an identity is requested. An identity can be requested because of security rules that require the user to authenticate or because programmatic access to the current identity is required."
msgstr "如果你禁用主动认证，认证过程只在身份被请求时运行。请求一个身份可能是因为安全规则要求用户进行身份验证，或者是因为需要对当前身份进行程序化访问。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:33
#, fuzzy
msgid "If proactive authentication is in use, accessing the `SecurityIdentity` is a blocking operation.  This is because authentication may have yet to happen, and accessing it may require calls to external systems, such as databases that may block.  For blocking applications, this is no problem. However, if you have disabled authentication in a reactive application, this will fail (as you cannot do blocking operations on the IO thread).  To work around this, you need to `@Inject` an instance of `io.quarkus.security.identity.CurrentIdentityAssociation` and call the `Uni<SecurityIdentity> getDeferredIdentity();` method.  You can then subscribe to the resulting `Uni` and will be notified when authentication is complete and the identity is available."
msgstr "如果正在使用主动认证，访问 `SecurityIdentity` 是一个阻塞操作。这是因为认证可能还没有发生，访问它可能需要调用外部系统，如数据库，可能会阻塞。对于阻塞的应用程序，这没有问题。然而，如果你在一个反应式应用程序中禁用了认证，这将失败（因为你不能在IO线程上做阻塞操作）。为了解决这个问题，你需要 `@Inject` 一个 `io.quarkus.security.identity.CurrentIdentityAssociation` 的实例并调用 `Uni<SecurityIdentity> getDeferredIdentity();` 方法。然后，你可以订阅产生的 `Uni` ，当认证完成和身份可用时，你将得到通知。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:36
#, fuzzy
msgid "It's still possible to access the `SecurityIdentity` synchronously with `public SecurityIdentity getIdentity()` in the xref:resteasy-reactive.adoc[RESTEasy Reactive] from endpoints annotated with `@RolesAllowed`, `@Authenticated`, or with respective configuration authorization checks as authentication has already happened.  The same is also valid for the xref:reactive-routes.adoc[Reactive routes] if a route response is synchronous."
msgstr "在 link:resteasy-reactive.html[RESTEasy Reactive] 中，仍然可以通过 `public SecurityIdentity getIdentity()` ，从注有 `@RolesAllowed` 、 `@Authenticated` 、或各自配置授权检查的端点同步访问 `SecurityIdentity` ，因为认证已经发生。如果路由响应是同步的，这对 link:reactive-routes.html[Reactive路由] 也同样有效。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:39
#, fuzzy
msgid "xref:security-authorization.adoc#standard-security-annotations[Standard security annotations] on CDI beans are not supported on IO thread if a non-void secured method returns a value synchronously and proactive authentication is disabled, as they need to access the `SecurityIdentity`.  In the example below, we have defined `HelloResource` and `HelloService`. It's easy to see that any GET request to `/hello` will run on IO thread and throw `BlockingOperationNotAllowedException` exception."
msgstr "如果一个非void的安全方法同步返回一个值，并且主动认证被禁用，那么CDI Bean上的 link:security-authorization.html#standard-security-annotations[标准安全注释] 在IO线程上是不被支持的，因为他们需要访问 `SecurityIdentity` 。在下面的例子中，我们定义了 `HelloResource` 和 `HelloService` 。很容易看出，任何对 `/hello` 的GET请求都会在IO线程上运行，并抛出 `BlockingOperationNotAllowedException` 异常。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:41
#, fuzzy
msgid "There is more than one way to fix the example:"
msgstr "修复这个例子的方法不止一种："

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:43
#, fuzzy
msgid "switch to a worker thread (annotate `hello` endpoint with `@Blocking`)"
msgstr "切换到一个工作线程（用 `@Blocking` 注释 `hello` 端点）。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:44
#, fuzzy
msgid "change `sayHello` method return type (use reactive or asynchronous data type)"
msgstr "改变 `sayHello` 方法的返回类型（使用反应式或异步数据类型）。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:45
#, fuzzy
msgid "arguably the safest way is to move `@RolesAllowed` annotation to the endpoint, as accessing `SecurityIdentity` from endpoint methods is never the blocking operation"
msgstr "可以说，最安全的方法是将 `@RolesAllowed` 注释移至端点，因为从端点方法中访问 `SecurityIdentity` ，永远不会是阻塞操作。"

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:52
#, no-wrap
msgid ""
"import jakarta.annotation.security.PermitAll;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:54
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:58
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"@PermitAll\n"
"public class HelloResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:61
#, no-wrap
msgid ""
"    @Inject\n"
"    HelloService helloService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:66
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<String> hello() {\n"
"        return Uni.createFrom().item(helloService.sayHello());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:68
#: upstream/_guides/security-proactive-authentication-concept.adoc:84
#, no-wrap
msgid "}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:74
#, no-wrap
msgid ""
"import jakarta.annotation.security.RolesAllowed;\n"
"import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:77
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class HelloService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:82
#, no-wrap
msgid ""
"    @RolesAllowed(\"admin\")\n"
"    public String sayHello() {\n"
"        return \"Hello\";\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-proactive-authentication-concept.adoc:86
#, fuzzy, no-wrap
msgid "How to customize authentication exception responses"
msgstr "如何定制认证异常响应"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:89
#, fuzzy
msgid "You can use Jakarta REST `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException`, for example:"
msgstr "你可以使用Jakarta REST `ExceptionMapper` 来捕获Quarkus Security认证异常，例如： `io.quarkus.security.AuthenticationFailedException` ："

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:93
#: upstream/_guides/security-proactive-authentication-concept.adoc:125
#, no-wrap
msgid "package io.quarkus.it.keycloak;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:99
#, no-wrap
msgid ""
"import jakarta.annotation.Priority;\n"
"import jakarta.ws.rs.Priorities;\n"
"import jakarta.ws.rs.core.Response;\n"
"import jakarta.ws.rs.ext.ExceptionMapper;\n"
"import jakarta.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:101
#, no-wrap
msgid "import io.quarkus.security.AuthenticationFailedException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:105
#, no-wrap
msgid ""
"@Provider\n"
"@Priority(Priorities.AUTHENTICATION)\n"
"public class AuthenticationFailedExceptionMapper implements ExceptionMapper<AuthenticationFailedException> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:108
#, no-wrap
msgid ""
"    @Context\n"
"    UriInfo uriInfo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:114
#, no-wrap
msgid ""
"    @Override\n"
"    public Response toResponse(AuthenticationFailedException exception) {\n"
"        return Response.status(401).header(\"WWW-Authenticate\", \"Basic realm=\\\"Quarkus\\\"\").build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:121
#, fuzzy
msgid "Some HTTP authentication mechanisms need to handle authentication exceptions themselves to create a correct authentication challenge.  For example, `io.quarkus.oidc.runtime.CodeAuthenticationMechanism` which manages OpenId Connect authorization code flow authentication, needs to build a correct redirect URL, cookies, etc.  For that reason, using custom exception mappers to customize authentication exceptions thrown by such mechanisms is not recommended.  Instead, a safer approach would be to ensure that proactive authentication is enabled and to use Vert.x HTTP route failure handlers. This is because events come to the handler with the correct response status and headers.  You will then only need to customize the response, as outlined in the following example:"
msgstr "一些HTTP认证机制需要自己处理认证异常，以创建一个正确的认证挑战。例如，管理OpenId Connect授权代码流认证的 `io.quarkus.oidc.runtime.CodeAuthenticationMechanism` ，需要建立一个正确的重定向URL、cookies等。由于这个原因，不建议使用自定义异常映射器来定制此类机制抛出的认证异常。相反，更安全的方法是确保启用主动认证，并使用Vert.x HTTP路由失败处理程序。这是因为事件会带着正确的响应状态和头文件来到处理程序。然后你只需要定制响应，就像下面的例子中所概述的那样："

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:128
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:133
#, no-wrap
msgid ""
"import io.quarkus.security.AuthenticationFailedException;\n"
"import io.vertx.core.Handler;\n"
"import io.vertx.ext.web.Router;\n"
"import io.vertx.ext.web.RoutingContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:136
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class AuthenticationFailedExceptionHandler {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:150
#, no-wrap
msgid ""
"    public void init(@Observes Router router) {\n"
"        router.route().failureHandler(new Handler<RoutingContext>() {\n"
"            @Override\n"
"            public void handle(RoutingContext event) {\n"
"                if (event.failure() instanceof AuthenticationFailedException) {\n"
"                    event.response().end(\"CUSTOMIZED_RESPONSE\");\n"
"                } else {\n"
"                    event.next();\n"
"                }\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-proactive-authentication-concept.adoc:152
#, no-wrap
msgid "References"
msgstr "参考文献"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:155
#, fuzzy
msgid "xref:security-overview-concept.adoc[Quarkus Security overview]"
msgstr "link:security-overview-concept.html[Quarkus安全概述]"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:156
#, fuzzy
msgid "xref:security-architecture-concept.adoc[Quarkus Security architecture]"
msgstr "link:security-architecture-concept.html[Quarkus安全架构]"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:157
msgid "xref:security-authentication-mechanisms-concept.adoc#other-supported-authentication-mechanisms[Authentication mechanisms in Quarkus]"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:157
msgid "xref:security-identity-providers-concept.adoc[Identity providers]"
msgstr ""
