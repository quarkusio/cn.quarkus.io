# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/topic/architecture.adoc:2
#, fuzzy, no-wrap
msgid "{project-name} - Architecture"
msgstr "{项目名称} - 建筑"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:5
#, fuzzy
msgid "image::images/architecture-phases.png"
msgstr "image::images/architecture-phases.png"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:9
#, fuzzy
msgid "{project-name} has an architecture that does as much processing as possible at build time. Annotations and other descriptors are processed as early as possible, and then {project-name} will generate bytecode based on this information. This results in lower memory usage and faster startup speeds at runtime."
msgstr "{项目名称}有一个架构，在构建时尽可能多地进行处理。注释和其他描述符尽可能早地被处理，然后{项目名称}将根据这些信息生成字节码。这使得运行时的内存使用率更低，启动速度更快。"

#. type: Title ==
#: upstream/_guides/topic/architecture.adoc:10
#, fuzzy, no-wrap
msgid "Application Architecture"
msgstr "应用架构"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:14
#, fuzzy
msgid "This means that a {project-name} based application will go through a few different distinct phases, each of which can potentially be executed in a different JVM. These phases are:"
msgstr "这意味着一个基于{项目名称}的应用程序将经历几个不同的阶段，每个阶段都有可能在不同的JVM中执行。这些阶段是。"

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:15
#, fuzzy, no-wrap
msgid "Augmentation"
msgstr "扩容"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:22
#, fuzzy
msgid "This involves processing all the metadata that is present in the application and its libraries, such as annotations, descriptors etc, and processing this information to create bytecode that is executable at runtime. This generated bytecode will directly start the runtime services that were represented by the metadata. For example if your application contains a `@WebServlet` annotation this phase will output the bytecode required to start Undertow and register this Servlet.  The end result of this phase is a runnable application that should be equivalent to manually wiring up the runtime services you require, without any of the deployment time code present."
msgstr "这涉及到处理所有存在于应用程序及其库中的元数据，如注释、描述符等，并处理这些信息以创建可在运行时执行的字节码。这个生成的字节码将直接启动元数据所代表的运行时服务。例如，如果你的应用程序包含一个 `@WebServlet` 注释，这个阶段将输出启动Undertow和注册这个Servlet所需的字节码。这个阶段的最终结果是一个可运行的应用程序，它应该等同于手动连接你所需要的运行时服务，而没有任何部署时间的代码存在。"

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:23
#, fuzzy, no-wrap
msgid "JVM Startup"
msgstr "JVM启动"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:29
#, fuzzy
msgid "When running as a normal JVM application the bytecode generated in the augmentation phase will be executed to start the runtime services needed by the application. In production mode this will generally be in a different JVM instance, which means that none of the classes needed by the augmentation phase will be loaded at runtime, resulting in a smaller memory footprint and faster startup time. In development mode this will be the same JVM, allowing for the application to be quickly restarted when changes are made."
msgstr "当作为一个正常的JVM应用程序运行时，在增强阶段生成的字节码将被执行以启动应用程序所需的运行时服务。在生产模式下，这通常是在一个不同的JVM实例中，这意味着增强阶段所需的类将不会在运行时加载，从而导致更小的内存占用和更快的启动时间。在开发模式下，这将是同一个JVM，允许应用程序在发生变化时快速重新启动。"

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:30
#, fuzzy, no-wrap
msgid "Native Image Build"
msgstr "本地图像构建"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:38
#, fuzzy
msgid "When building a native image with SubstrateVM any code that is part of a static initializer is run as part of the native image build process, and the results are directly stored in memory. {project-name} takes advantage of this by generating some of the startup code in static initializer blocks, so they are run as part of the image build process rather than on image startup. This has multiple advantages, as the image build is a standard JVM it is still possible to use JVM features such as reflection and dynamic proxy generation that do not work out of the box on Substrate. As most of the startup is done in this phase the native image will start even faster, as it effectively contains a serialized image of an already started application."
msgstr "当用SubstrateVM构建本地镜像时，任何属于静态初始化器的代码都会作为本地镜像构建过程的一部分来运行，其结果会直接存储在内存中。{project-name}通过在静态初始化器块中生成一些启动代码来利用这一点，因此它们是作为图像构建过程的一部分来运行的，而不是在图像启动时。这有多个优点，因为图像构建是一个标准的JVM，所以仍然可以使用JVM的功能，如反射和动态代理的生成，而这些功能在Substrate上是不工作的。由于大部分的启动都是在这个阶段完成的，因此本地镜像的启动速度会更快，因为它实际上包含了一个已经启动的应用程序的序列化镜像。"

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:39
#, fuzzy, no-wrap
msgid "Native Image Start"
msgstr "本机图像启动"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:42
#, fuzzy
msgid "As most of the work has been done in the image build the actual native image startup will generally only contain tasks that can't be done in advance, such as opening sockets and connecting to databases."
msgstr "由于大部分工作已经在图像构建中完成，实际的本地图像启动通常只包含不能提前完成的任务，如打开套接字和连接到数据库。"

#. type: Title ==
#: upstream/_guides/topic/architecture.adoc:43
#, fuzzy, no-wrap
msgid "Extension Architecture"
msgstr "扩展架构"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:50
#, fuzzy
msgid "As a result of this architecture every extension will provide two artifacts, one that handles build time processing (the `-deployment` artifacts), and another `-runtime` artifact that contains the classes needed at runtime. Only the runtime artifact will end up in the final application. The end result of the deployment process is some generated bytecode that can directly start any runtime services required by the application (but don't worry, you don't have to know anything about bytecode to write a {project-name} extension)."
msgstr "由于这种架构，每个扩展将提供两个工件，一个处理构建时的处理（ `-deployment` 工件），另一个 `-runtime` 工件，包含运行时需要的类。只有运行时的工件会最终出现在最终的应用程序中。部署过程的最终结果是一些生成的字节码，它可以直接启动应用程序所需的任何运行时服务（但不要担心，你不必知道任何关于字节码的知识来编写{项目名称}扩展）。"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:56
#, fuzzy
msgid "{project-name} uses a novel technique for writing bytecode that we are calling _Bytecode Recording_. Basically at augment time extensions can inject instances of classes that contain the runtime logic to start services, and invoke these instances as if they were directly starting the service. These injected instances are actually proxies, that override all the public methods and record exactly which invocations have been made, what the parameters are, and the order they were made in. They then generate bytecode to perform this exact same sequence of invocations when the application starts up."
msgstr "{项目名称}使用一种新颖的技术来编写字节码，我们称之为 _字节码记录_ 。基本上，在扩展时，可以注入包含运行时逻辑的类的实例来启动服务，并调用这些实例，就像他们直接启动服务一样。这些注入的实例实际上是代理，它覆盖了所有的公共方法，并准确地记录了哪些调用，参数是什么，以及它们的顺序。然后，当应用程序启动时，它们会生成字节码来执行这个完全相同的调用序列。"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:60
#, fuzzy
msgid "This means that from the point of view of an extension developer it looks like they are making invocations that directly start the application, when in fact they are recording bytecode that will be used to start the application later."
msgstr "这意味着从扩展开发者的角度来看，他们看起来是在进行直接启动应用程序的调用，而实际上他们是在记录字节码，以后会用来启动应用程序。"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:62
msgid "The `-deployment` artifacts work by defining `@BuildStep` methods, that produce and consume `BuildItem` instances, and can also record bytecode if required."
msgstr ""
