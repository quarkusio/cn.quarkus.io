# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/topic/architecture.adoc:2
#, no-wrap
msgid "{project-name} - Architecture"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:5
msgid "image::images/architecture-phases.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:9
msgid "{project-name} has an architecture that does as much processing as possible at build time. Annotations and other descriptors are processed as early as possible, and then {project-name} will generate bytecode based on this information. This results in lower memory usage and faster startup speeds at runtime."
msgstr ""

#. type: Title ==
#: upstream/_guides/topic/architecture.adoc:10
#, no-wrap
msgid "Application Architecture"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:14
msgid "This means that a {project-name} based application will go through a few different distinct phases, each of which can potentially be executed in a different JVM. These phases are:"
msgstr ""

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:15
#, no-wrap
msgid "Augmentation"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:22
msgid "This involves processing all the metadata that is present in the application and its libraries, such as annotations, descriptors etc, and processing this information to create bytecode that is executable at runtime. This generated bytecode will directly start the runtime services that were represented by the metadata. For example if your application contains a `@WebServlet` annotation this phase will output the bytecode required to start Undertow and register this Servlet.  The end result of this phase is a runnable application that should be equivalent to manually wiring up the runtime services you require, without any of the deployment time code present."
msgstr ""

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:23
#, no-wrap
msgid "JVM Startup"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:29
msgid "When running as a normal JVM application the bytecode generated in the augmentation phase will be executed to start the runtime services needed by the application. In production mode this will generally be in a different JVM instance, which means that none of the classes needed by the augmentation phase will be loaded at runtime, resulting in a smaller memory footprint and faster startup time. In development mode this will be the same JVM, allowing for the application to be quickly restarted when changes are made."
msgstr ""

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:30
#, no-wrap
msgid "Native Image Build"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:38
msgid "When building a native image with SubstrateVM any code that is part of a static initializer is run as part of the native image build process, and the results are directly stored in memory. {project-name} takes advantage of this by generating some of the startup code in static initializer blocks, so they are run as part of the image build process rather than on image startup. This has multiple advantages, as the image build is a standard JVM it is still possible to use JVM features such as reflection and dynamic proxy generation that do not work out of the box on Substrate. As most of the startup is done in this phase the native image will start even faster, as it effectively contains a serialized image of an already started application."
msgstr ""

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:39
#, no-wrap
msgid "Native Image Start"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:42
msgid "As most of the work has been done in the image build the actual native image startup will generally only contain tasks that can't be done in advance, such as opening sockets and connecting to databases."
msgstr ""

#. type: Title ==
#: upstream/_guides/topic/architecture.adoc:43
#, no-wrap
msgid "Extension Architecture"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:50
msgid "As a result of this architecture every extension will provide two artifacts, one that handles build time processing (the `-deployment` artifacts), and another `-runtime` artifact that contains the classes needed at runtime. Only the runtime artifact will end up in the final application. The end result of the deployment process is some generated bytecode that can directly start any runtime services required by the application (but don't worry, you don't have to know anything about bytecode to write a {project-name} extension)."
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:56
msgid "{project-name} uses a novel technique for writing bytecode that we are calling _Bytecode Recording_. Basically at augment time extensions can inject instances of classes that contain the runtime logic to start services, and invoke these instances as if they were directly starting the service. These injected instances are actually proxies, that override all the public methods and record exactly which invocations have been made, what the parameters are, and the order they were made in. They then generate bytecode to perform this exact same sequence of invocations when the application starts up."
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:60
msgid "This means that from the point of view of an extension developer it looks like they are making invocations that directly start the application, when in fact they are recording bytecode that will be used to start the application later."
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:62
msgid "The `-deployment` artifacts work by defining `@BuildStep` methods, that produce and consume `BuildItem` instances, and can also record bytecode if required."
msgstr ""
