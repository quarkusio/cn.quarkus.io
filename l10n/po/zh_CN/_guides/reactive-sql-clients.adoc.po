# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-16 16:23+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/reactive-sql-clients.adoc:6
#, fuzzy, no-wrap
msgid "Reactive SQL Clients"
msgstr "反应式SQL客户端"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:16
#, fuzzy
msgid "The Reactive SQL Clients have a straightforward API focusing on scalability and low-overhead.  Currently, the following database servers are supported:"
msgstr "Reactive SQL客户端有一个直接的API，专注于可扩展性和低开销。目前，支持以下数据库服务器。"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:18
#: upstream/_guides/reactive-sql-clients.adoc:478
#: upstream/_guides/reactive-sql-clients.adoc:756
#: upstream/_guides/reactive-sql-clients.adoc:857
#, fuzzy, no-wrap
msgid "IBM Db2"
msgstr "IBM Db2"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:19
#: upstream/_guides/reactive-sql-clients.adoc:498
#: upstream/_guides/reactive-sql-clients.adoc:662
#: upstream/_guides/reactive-sql-clients.adoc:768
#: upstream/_guides/reactive-sql-clients.adoc:873
#, fuzzy, no-wrap
msgid "PostgreSQL"
msgstr "PostgreSQL"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:20
#: upstream/_guides/reactive-sql-clients.adoc:483
#: upstream/_guides/reactive-sql-clients.adoc:680
#: upstream/_guides/reactive-sql-clients.adoc:759
#: upstream/_guides/reactive-sql-clients.adoc:861
#, fuzzy, no-wrap
msgid "MariaDB/MySQL"
msgstr "玛丽亚数据库/MySQL"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:21
#: upstream/_guides/reactive-sql-clients.adoc:488
#: upstream/_guides/reactive-sql-clients.adoc:762
#: upstream/_guides/reactive-sql-clients.adoc:865
#, fuzzy, no-wrap
msgid "Microsoft SQL Server"
msgstr "微软SQL服务器"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:22
#: upstream/_guides/reactive-sql-clients.adoc:493
#: upstream/_guides/reactive-sql-clients.adoc:765
#: upstream/_guides/reactive-sql-clients.adoc:869
#, fuzzy, no-wrap
msgid "Oracle"
msgstr "甲骨文"

#. type: delimited block =
#: upstream/_guides/reactive-sql-clients.adoc:26
#, fuzzy
msgid "The Reactive SQL Client for Oracle is considered _tech preview_."
msgstr "用于Oracle的Reactive SQL客户端被认为是 _技术预览_ 。"

#. type: delimited block =
#: upstream/_guides/reactive-sql-clients.adoc:30
#, fuzzy
msgid "In _tech preview_ mode, early feedback is requested to mature the idea.  There is no guarantee of stability in the platform until the solution matures.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker]."
msgstr "在 _技术预览_ 模式下，要求早期反馈以使想法成熟。在解决方案成熟之前，不保证平台的稳定性。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题跟踪器] 中作为问题提供反馈。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:33
#, fuzzy
msgid "In this guide, you will learn how to implement a simple CRUD application exposing data stored in *PostgreSQL* over a RESTful API."
msgstr "在本指南中，你将学习如何实现一个简单的CRUD应用程序，通过RESTful API暴露存储在 *PostgreSQL* 中的数据。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:35
#, fuzzy
msgid "Extension and connection pool class names for each client can be found at the bottom of this document."
msgstr "每个客户端的扩展和连接池类的名称可以在本文件的底部找到。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:37
#, fuzzy
msgid "If you are not familiar with the Quarkus Vert.x extension, consider reading the xref:vertx.adoc[Using Eclipse Vert.x] guide first."
msgstr "如果你对Quarkus Vert.x扩展不熟悉，可以考虑先阅读 link:vertx.html[Using Eclipse Vert.x] 指南。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:39
#, fuzzy
msgid "The application shall manage fruit entities:"
msgstr "该应用程序应管理水果实体。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:43
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:45
#, no-wrap
msgid "    public Long id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:47
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:50
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:54
#, no-wrap
msgid ""
"    public Fruit(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:60
#, no-wrap
msgid ""
"    public Fruit(Long id, String name) {\n"
"        this.id = id;\n"
"        this.name = name;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/reactive-sql-clients.adoc:65
#, fuzzy
msgid "Do you need a ready-to-use PostgreSQL server to try out the examples?"
msgstr "你是否需要一个现成的PostgreSQL服务器来试用这些例子？"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:69
#, no-wrap
msgid "docker run -it --rm=true --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:14.1\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:72
#, fuzzy, no-wrap
msgid "Installing"
msgstr "安装"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:74
#, fuzzy, no-wrap
msgid "Reactive PostgreSQL Client extension"
msgstr "反应式PostgreSQL客户端扩展"

#. type: delimited block =
#: upstream/_guides/reactive-sql-clients.adoc:78
#, fuzzy
msgid "First, make sure your project has the `quarkus-reactive-pg-client` extension enabled.  If you are creating a new project, use the following command:"
msgstr "首先，确保你的项目启用了 `quarkus-reactive-pg-client` 扩展。如果你正在创建一个新项目，使用以下命令。"

#. type: delimited block =
#: upstream/_guides/reactive-sql-clients.adoc:84
#, fuzzy
msgid "If you have an already created project, the `reactive-pg-client` extension can be added to an existing Quarkus project with the `add-extension` command:"
msgstr "如果你有一个已经创建的项目， `reactive-pg-client` 扩展可以通过 `add-extension` 命令添加到现有的Quarkus项目中。"

#. type: delimited block =
#: upstream/_guides/reactive-sql-clients.adoc:89
#, fuzzy
msgid "Otherwise, you can manually add the dependency to your build file:"
msgstr "否则，你可以手动将该依赖关系添加到你的构建文件中。"

#. type: Block title
#: upstream/_guides/reactive-sql-clients.adoc:91
#: upstream/_guides/reactive-sql-clients.adoc:126
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:97
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-reactive-pg-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/reactive-sql-clients.adoc:100
#: upstream/_guides/reactive-sql-clients.adoc:135
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:103
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-reactive-pg-client\")\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:105
#, fuzzy, no-wrap
msgid "Mutiny"
msgstr "叛变"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:108
#, fuzzy
msgid "RESTEasy Reactive includes supports for Mutiny types (e.g. `Uni` and `Multi`) out of the box."
msgstr "RESTEasy Reactive包括对Mutiny类型的支持（例如 `Uni` 和 `Multi` ），开箱即用。"

#. type: delimited block =
#: upstream/_guides/reactive-sql-clients.adoc:113
#, fuzzy
msgid "In this guide, we will use the Mutiny API of the Reactive PostgreSQL Client.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "在本指南中，我们将使用Mutiny API的Reactive PostgreSQL客户端。如果你对Mutiny不熟悉，请查看 link:mutiny-primer.html[Mutiny - 一个直观的反应式编程库] 。"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:115
#, fuzzy, no-wrap
msgid "JSON Binding"
msgstr "JSON绑定"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:119
#, fuzzy
msgid "We will expose `Fruit` instances over HTTP in the JSON format.  Consequently, you also need to add the `quarkus-resteasy-reactive-jackson` extension:"
msgstr "我们将通过HTTP以JSON格式公开 `Fruit` 实例。因此，你也需要添加 `quarkus-resteasy-reactive-jackson` 扩展。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:124
#, fuzzy
msgid "If you prefer not to use the command line, manually add the dependency to your build file:"
msgstr "如果你不喜欢使用命令行，可以手动添加依赖关系到你的构建文件。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:132
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-reactive-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:138
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-resteasy-reactive-jackson\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:141
#, fuzzy
msgid "Of course, this is only a requirement for this guide, not any application using the Reactive PostgreSQL Client."
msgstr "当然，这只是本指南的要求，而不是任何使用Reactive PostgreSQL客户端的应用。"

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:142
#, fuzzy, no-wrap
msgid "Configuring"
msgstr "配置"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:145
#, fuzzy
msgid "The Reactive PostgreSQL Client can be configured with standard Quarkus datasource properties and a reactive URL:"
msgstr "反应式PostgreSQL客户端可以用标准的Quarkus数据源属性和反应式URL进行配置。"

#. type: Block title
#: upstream/_guides/reactive-sql-clients.adoc:147
#, fuzzy, no-wrap
msgid "src/main/resources/application.properties"
msgstr "src/main/resources/application.properties"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:153
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus_test\n"
"quarkus.datasource.password=quarkus_test\n"
"quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:156
#, fuzzy
msgid "With that you may create your `FruitResource` skeleton and `@Inject` a `io.vertx.mutiny.pgclient.PgPool` instance:"
msgstr "有了这个，你可以创建你的 `FruitResource` 骨架和 `@Inject` 一个 `io.vertx.mutiny.pgclient.PgPool` 实例。"

#. type: Block title
#: upstream/_guides/reactive-sql-clients.adoc:158
#: upstream/_guides/reactive-sql-clients.adoc:177
#: upstream/_guides/reactive-sql-clients.adoc:266
#: upstream/_guides/reactive-sql-clients.adoc:316
#: upstream/_guides/reactive-sql-clients.adoc:343
#: upstream/_guides/reactive-sql-clients.adoc:375
#, fuzzy, no-wrap
msgid "src/main/java/org/acme/vertx/FruitResource.java"
msgstr "src/main/java/org/acme/vertx/FruitResource.java"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:162
#, no-wrap
msgid ""
"@Path(\"fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:166
#, no-wrap
msgid ""
"    @Inject\n"
"    io.vertx.mutiny.pgclient.PgPool client;\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:168
#, fuzzy, no-wrap
msgid "Database schema and seed data"
msgstr "数据库模式和种子数据"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:172
#, fuzzy
msgid "Before we implement the REST endpoint and data management code, we need to set up the database schema.  It would also be convenient to have some data inserted up-front."
msgstr "在我们实现REST端点和数据管理代码之前，我们需要设置数据库模式。如果能在前期插入一些数据，也是很方便的。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:175
#, fuzzy
msgid "For production, we would recommend to use something like the xref:flyway.adoc[Flyway database migration tool].  But for development we can simply drop and create the tables on startup, and then insert a few fruits."
msgstr "对于生产，我们建议使用类似 link:flyway.html[Flyway数据库迁移工具] 的东西。但对于开发来说，我们可以简单地在启动时丢弃和创建表，然后插入一些水果。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:182
#, no-wrap
msgid ""
"@Inject\n"
"@ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\") // <1>\n"
"boolean schemaCreate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:188
#, no-wrap
msgid ""
"void config(@Observes StartupEvent ev) {\n"
"    if (schemaCreate) {\n"
"        initdb();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:192
#, no-wrap
msgid ""
"private void initdb() {\n"
"    // TODO\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:195
#, fuzzy
msgid "You may override the default value of the `myapp.schema.create` property in the `application.properties` file."
msgstr "你可以在 `application.properties` 文件中覆盖 `myapp.schema.create` 属性的默认值。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:199
#, fuzzy
msgid "Almost ready! To initialize the DB in development mode, we will use the client simple `query` method.  It returns a `Uni` and thus can be composed to execute queries sequentially:"
msgstr "几乎准备好了!为了在开发模式下初始化DB，我们将使用客户端的简单 `query` 方法。它返回一个 `Uni` ，因此可以组成顺序执行查询。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:208
#, no-wrap
msgid ""
"client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"    .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"    .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Orange')\").execute())\n"
"    .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pear')\").execute())\n"
"    .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Apple')\").execute())\n"
"    .await().indefinitely();\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:213
#, fuzzy
msgid "Wondering why we need to block until the latest query is completed? This code is part of a `@PostConstruct` method and Quarkus invokes it synchronously.  As a consequence, returning prematurely could lead to serving requests while the database is not ready yet."
msgstr "想知道为什么我们需要阻塞，直到最新的查询完成？这段代码是 `@PostConstruct` 方法的一部分，Quarkus同步地调用了它。因此，过早地返回可能会导致在数据库尚未准备好的情况下提供请求。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:217
#, fuzzy
msgid "That's it! So far we have seen how to configure a pooled client and execute simple queries.  We are now ready to develop the data management code and implement our RESTful endpoint."
msgstr "这就是了!到目前为止，我们已经看到了如何配置一个池化客户端和执行简单的查询。现在我们已经准备好开发数据管理代码并实现我们的RESTful端点。"

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:218
#, fuzzy, no-wrap
msgid "Using"
msgstr "使用"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:220
#, fuzzy, no-wrap
msgid "Query results traversal"
msgstr "查询结果遍历"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:224
#, fuzzy
msgid "In development mode, the database is set up with a few rows in the `fruits` table.  To retrieve all the data, we will use the `query` method again:"
msgstr "在开发模式下，数据库的设置是在 `fruits` 表中有几行。为了检索所有的数据，我们将再次使用 `query` 方法。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:228
#, no-wrap
msgid "Uni<RowSet<Row>> rowSet = client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\").execute();\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:232
#, fuzzy
msgid "When the operation completes, we will get a `RowSet` that has all the rows buffered in memory.  A `RowSet` is an `java.lang.Iterable<Row>` and thus can be converted to a `Multi`:"
msgstr "当操作完成后，我们将得到一个 `RowSet` ，它在内存中缓冲了所有的行。一个 `RowSet` 是一个 `java.lang.Iterable<Row>` ，因此可以转换为一个 `Multi` 。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:238
#, no-wrap
msgid ""
"Multi<Fruit> fruits = rowSet\n"
"  .onItem().transformToMulti(set -> Multi.createFrom().iterable(set))\n"
"  .onItem().transform(Fruit::from);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:242
#, fuzzy
msgid "The `Fruit#from` method converts a `Row` instance to a `Fruit` instance.  It is extracted as a convenience for the implementation of the other data management methods:"
msgstr " `Fruit#from` 方法将一个 `Row` 实例转换为一个 `Fruit` 实例。它的提取是为了方便其他数据管理方法的实现。"

#. type: Block title
#: upstream/_guides/reactive-sql-clients.adoc:244
#: upstream/_guides/reactive-sql-clients.adoc:254
#: upstream/_guides/reactive-sql-clients.adoc:301
#: upstream/_guides/reactive-sql-clients.adoc:332
#: upstream/_guides/reactive-sql-clients.adoc:363
#, fuzzy, no-wrap
msgid "src/main/java/org/acme/vertx/Fruit.java"
msgstr "src/main/java/org/acme/vertx/Fruit.java"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:249
#, no-wrap
msgid ""
"private static Fruit from(Row row) {\n"
"    return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:252
#, fuzzy
msgid "Putting it all together, the `Fruit.findAll` method looks like:"
msgstr "把这一切放在一起， `Fruit.findAll` 方法看起来像。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:261
#, no-wrap
msgid ""
"public static Multi<Fruit> findAll(PgPool client) {\n"
"    return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\").execute()\n"
"            .onItem().transformToMulti(set -> Multi.createFrom().iterable(set))\n"
"            .onItem().transform(Fruit::from);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:264
#, fuzzy
msgid "And the endpoint to get all fruits from the backend:"
msgstr "以及从后端获取所有水果的端点。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:272
#, no-wrap
msgid ""
"@GET\n"
"public Multi<Fruit> get() {\n"
"    return Fruit.findAll(client);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:275
#, fuzzy
msgid "Now start Quarkus in dev mode with:"
msgstr "现在以开发模式启动Quarkus。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:279
#, fuzzy
msgid "Lastly, open your browser and navigate to http://localhost:8080/fruits, you should see:"
msgstr "最后，打开你的浏览器，导航到 http://localhost:8080/fruits 你应该看到。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:283
#, no-wrap
msgid "[{\"id\":3,\"name\":\"Apple\"},{\"id\":1,\"name\":\"Orange\"},{\"id\":2,\"name\":\"Pear\"}]\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:285
#, fuzzy, no-wrap
msgid "Prepared queries"
msgstr "准备好的查询"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:288
#, fuzzy
msgid "The Reactive PostgreSQL Client can also prepare queries and take parameters that are replaced in the SQL statement at execution time:"
msgstr "反应式PostgreSQL客户端也可以准备查询，并采取在执行时在SQL语句中替换的参数。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:292
#, no-wrap
msgid "client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:296
#, fuzzy
msgid "For PostgreSQL, the SQL string can refer to parameters by position, using `$1`, `$2`, ...etc.  Please refer to the xref:reactive-sql-clients-details[Database Clients details] section for other databases."
msgstr "对于PostgreSQL，SQL字符串可以通过位置来引用参数，使用 `$1` , `$2` , ...等等。对于其他数据库，请参考 link:#Database Clients details[[数据库客户详情]] 部分。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:299
#, fuzzy
msgid "Similar to the simple `query` method, `preparedQuery` returns an instance of `PreparedQuery<RowSet<Row>>`.  Equipped with this tooling, we are able to safely use an `id` provided by the user to get the details of a particular fruit:"
msgstr "与简单的 `query` 方法类似， `preparedQuery` 返回一个 `PreparedQuery<RowSet<Row>>` 的实例。有了这个工具，我们就能够安全地使用用户提供的 `id` 来获得某个水果的细节。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:308
#, no-wrap
msgid ""
"public static Uni<Fruit> findById(PgPool client, Long id) {\n"
"    return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\").execute(Tuple.of(id)) // <1>\n"
"            .onItem().transform(RowSet::iterator) // <2>\n"
"            .onItem().transform(iterator -> iterator.hasNext() ? from(iterator.next()) : null); // <3>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:310
#, fuzzy
msgid "Create a `Tuple` to hold the prepared query parameters."
msgstr "创建一个 `Tuple` ，以保存准备好的查询参数。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:311
#, fuzzy
msgid "Get an `Iterator` for the `RowSet` result."
msgstr "为 `RowSet` 结果获取一个 `Iterator` 。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:312
#, fuzzy
msgid "Create a `Fruit` instance from the `Row` if an entity was found."
msgstr "如果找到一个实体，从 `Row` ，创建一个 `Fruit` 实例。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:314
#, fuzzy
msgid "And in the Jakarta REST resource:"
msgstr "而在JAX-RS资源中。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:325
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"{id}\")\n"
"public Uni<Response> getSingle(Long id) {\n"
"    return Fruit.findById(client, id)\n"
"            .onItem().transform(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND)) // <1>\n"
"            .onItem().transform(ResponseBuilder::build); // <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:327
#, fuzzy
msgid "Prepare a Jakarta REST response with either the `Fruit` instance if found or the `404` status code."
msgstr "准备一个JAX-RS响应，如果找到了 `Fruit` 实例或 `404` 状态代码。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:328
#, fuzzy
msgid "Build and send the response."
msgstr "建立并发送响应。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:330
#, fuzzy
msgid "The same logic applies when saving a `Fruit`:"
msgstr "同样的逻辑也适用于保存一个 `Fruit` 。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:338
#, no-wrap
msgid ""
"public Uni<Long> save(PgPool client) {\n"
"    return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING id\").execute(Tuple.of(name))\n"
"            .onItem().transform(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:341
#, fuzzy
msgid "And in the web resource we handle the `POST` request:"
msgstr "而在网络资源中，我们处理 `POST` 的请求。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:351
#, no-wrap
msgid ""
"@POST\n"
"public Uni<Response> create(Fruit fruit) {\n"
"    return fruit.save(client)\n"
"            .onItem().transform(id -> URI.create(\"/fruits/\" + id))\n"
"            .onItem().transform(uri -> Response.created(uri).build());\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:353
#, fuzzy, no-wrap
msgid "Result metadata"
msgstr "结果元数据"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:356
#, fuzzy
msgid "A `RowSet` does not only hold your data in memory, it also gives you some information about the data itself, such as:"
msgstr "一个 `RowSet` ，不仅在内存中保存你的数据，它还为你提供关于数据本身的一些信息，例如。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:358
#, fuzzy
msgid "the number of rows affected by the query (inserted/deleted/updated/retrieved depending on the query type),"
msgstr "受查询影响的行数（根据查询类型，插入/删除/更新/检索）。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:359
#, fuzzy
msgid "the column names."
msgstr "的列名。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:361
#, fuzzy
msgid "Let's use this to support removal of fruits in the database:"
msgstr "让我们用它来支持数据库中水果的移除。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:369
#, no-wrap
msgid ""
"public static Uni<Boolean> delete(PgPool client, Long id) {\n"
"    return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"            .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1); // <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:371
#, fuzzy
msgid "Inspect metadata to determine if a fruit has been actually deleted."
msgstr "检查元数据以确定一个水果是否真的被删除。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:373
#, fuzzy
msgid "And to handle the HTTP `DELETE` method in the web resource:"
msgstr "并处理网络资源中的HTTP `DELETE` 方法。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:384
#, no-wrap
msgid ""
"@DELETE\n"
"@Path(\"{id}\")\n"
"public Uni<Response> delete(Long id) {\n"
"    return Fruit.delete(client, id)\n"
"            .onItem().transform(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n"
"            .onItem().transform(status -> Response.status(status).build());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:388
#, fuzzy
msgid "With `GET`, `POST` and `DELETE` methods implemented, we may now create a minimal web page to try the RESTful application out.  We will use https://jquery.com/[jQuery] to simplify interactions with the backend:"
msgstr "有了 `GET` , `POST` 和 `DELETE` 方法的实现，我们现在可以创建一个最小的网页来尝试RESTful应用程序了。我们将使用 link:https://jquery.com/[jQuery] 来简化与后台的交互。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:401
#, no-wrap
msgid ""
"<!doctype html>\n"
"<html>\n"
"<head>\n"
"    <meta charset=\"utf-8\"/>\n"
"    <title>Reactive PostgreSQL Client - Quarkus</title>\n"
"    <script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"\n"
"            integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"></script>\n"
"    <script type=\"application/javascript\" src=\"fruits.js\"></script>\n"
"</head>\n"
"<body>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:403
#, no-wrap
msgid "<h1>Fruits API Testing</h1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:406
#, no-wrap
msgid ""
"<h2>All fruits</h2>\n"
"<div id=\"all-fruits\"></div>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:411
#, no-wrap
msgid ""
"<h2>Create Fruit</h2>\n"
"<input id=\"fruit-name\" type=\"text\">\n"
"<button id=\"create-fruit-button\" type=\"button\">Create</button>\n"
"<div id=\"create-fruit\"></div>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:414
#, no-wrap
msgid ""
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:417
#, fuzzy
msgid "In the JavaScript code, we need a function to refresh the list of fruits when:"
msgstr "在Javascript代码中，我们需要一个函数来刷新水果的列表，当。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:419
#, fuzzy
msgid "the page is loaded, or"
msgstr "的页面被加载，或"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:420
#, fuzzy
msgid "a fruit is added, or"
msgstr "加入一个水果，或"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:421
#, fuzzy
msgid "a fruit is deleted."
msgstr "删掉一个水果。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:446
#, no-wrap
msgid ""
"function refresh() {\n"
"    $.get('/fruits', function (fruits) {\n"
"        var list = '';\n"
"        (fruits || []).forEach(function (fruit) { // <1>\n"
"            list = list\n"
"                + '<tr>'\n"
"                + '<td>' + fruit.id + '</td>'\n"
"                + '<td>' + fruit.name + '</td>'\n"
"                + '<td><a href=\"#\" onclick=\"deleteFruit(' + fruit.id + ')\">Delete</a></td>'\n"
"                + '</tr>'\n"
"        });\n"
"        if (list.length > 0) {\n"
"            list = ''\n"
"                + '<table><thead><th>Id</th><th>Name</th><th></th></thead>'\n"
"                + list\n"
"                + '</table>';\n"
"        } else {\n"
"            list = \"No fruits in database\"\n"
"        }\n"
"        $('#all-fruits').html(list);\n"
"    });\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:450
#, no-wrap
msgid ""
"function deleteFruit(id) {\n"
"    $.ajax('/fruits/' + id, {method: 'DELETE'}).then(refresh);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:452
#, no-wrap
msgid "$(document).ready(function () {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:461
#, no-wrap
msgid ""
"    $('#create-fruit-button').click(function () {\n"
"        var fruitName = $('#fruit-name').val();\n"
"        $.post({\n"
"            url: '/fruits',\n"
"            contentType: 'application/json',\n"
"            data: JSON.stringify({name: fruitName})\n"
"        }).then(refresh);\n"
"    });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:464
#, no-wrap
msgid ""
"    refresh();\n"
"});\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:466
#, fuzzy
msgid "The `fruits` parameter is not defined when the database is empty."
msgstr "当数据库为空时， `fruits` 参数未被定义。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:469
#, fuzzy
msgid "All done! Navigate to http://localhost:8080/fruits.html and read/create/delete some fruits."
msgstr "全部完成!导航到 http://localhost:8080/fruits.html ，阅读/创建/删除一些水果。"

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:471
#, fuzzy, no-wrap
msgid "Database Clients details"
msgstr "数据库客户的详细信息"

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:475
#: upstream/_guides/reactive-sql-clients.adoc:753
#, fuzzy, no-wrap
msgid "Database"
msgstr "数据库"

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:475
#, fuzzy, no-wrap
msgid "Extension name"
msgstr "扩展名"

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:475
#, fuzzy, no-wrap
msgid "Pool class name"
msgstr "池类名称"

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:477
#, fuzzy, no-wrap
msgid "Placeholders"
msgstr "占位符"

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:479
#, fuzzy, no-wrap
msgid "`quarkus-reactive-db2-client`"
msgstr " `quarkus-reactive-db2-client` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:480
#, fuzzy, no-wrap
msgid "`io.vertx.mutiny.db2client.DB2Pool`"
msgstr " `io.vertx.mutiny.db2client.DB2Pool` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:482
#: upstream/_guides/reactive-sql-clients.adoc:487
#: upstream/_guides/reactive-sql-clients.adoc:497
#, fuzzy, no-wrap
msgid "`?`"
msgstr " `?` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:484
#, fuzzy, no-wrap
msgid "`quarkus-reactive-mysql-client`"
msgstr " `quarkus-reactive-mysql-client` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:485
#, fuzzy, no-wrap
msgid "`io.vertx.mutiny.mysqlclient.MySQLPool`"
msgstr " `io.vertx.mutiny.mysqlclient.MySQLPool` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:489
#, fuzzy, no-wrap
msgid "`quarkus-reactive-mssql-client`"
msgstr " `quarkus-reactive-mssql-client` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:490
#, fuzzy, no-wrap
msgid "`io.vertx.mutiny.mssqlclient.MSSQLPool`"
msgstr " `io.vertx.mutiny.mssqlclient.MSSQLPool` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:492
#, fuzzy, no-wrap
msgid "`@p1`, `@p2`, etc."
msgstr " `@p1` , `@p2` , 等。"

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:494
#, fuzzy, no-wrap
msgid "`quarkus-reactive-oracle-client`"
msgstr " `quarkus-reactive-oracle-client` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:495
#, fuzzy, no-wrap
msgid "`io.vertx.mutiny.oracleclient.OraclePool`"
msgstr " `io.vertx.mutiny.oracleclient.OraclePool` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:499
#, fuzzy, no-wrap
msgid "`quarkus-reactive-pg-client`"
msgstr " `quarkus-reactive-pg-client` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:500
#, fuzzy, no-wrap
msgid "`io.vertx.mutiny.pgclient.PgPool`"
msgstr " `io.vertx.mutiny.pgclient.PgPool` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:501
#, fuzzy, no-wrap
msgid "`$1`, `$2`, etc."
msgstr " `$1` , `$2` , 等。"

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:503
#, fuzzy, no-wrap
msgid "Transactions"
msgstr "交易"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:508
#, fuzzy
msgid "The reactive SQL clients support transactions.  A transaction is started with `io.vertx.mutiny.sqlclient.SqlConnection#begin` and terminated with either `io.vertx.mutiny.sqlclient.Transaction#commit` or `io.vertx.mutiny.sqlclient.Transaction#rollback`.  All these operations are asynchronous:"
msgstr "反应式SQL客户端支持事务。一个事务以 `io.vertx.mutiny.sqlclient.SqlConnection#begin` 开始，以 `io.vertx.mutiny.sqlclient.Transaction#commit` 或 `io.vertx.mutiny.sqlclient.Transaction#rollback` 终止。所有这些操作都是异步的。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:510
#, fuzzy
msgid "`connection.begin()` returns a `Uni<Transaction>`"
msgstr " `connection.begin()` 返回一个 `Uni<Transaction>` "

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:511
#, fuzzy
msgid "`transaction.commit()` and `transaction.rollback()` return `Uni<Void>`"
msgstr " `transaction.commit()` 和 返回 `transaction.rollback()` `Uni<Void>` "

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:514
#, fuzzy
msgid "Managing transactions in the reactive programming world can be cumbersome.  Instead of writing repetitive and complex (thus error-prone!) code, you can use the `io.vertx.mutiny.sqlclient.Pool#withTransaction` helper method."
msgstr "在反应式编程的世界里管理事务可能是很麻烦的。你可以使用 `io.vertx.mutiny.sqlclient.Pool#withTransaction` 帮助方法，而不是编写重复的、复杂的（因此容易出错！）代码。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:516
#, fuzzy
msgid "The following snippet shows how to run 2 insertions in the same transaction:"
msgstr "下面的片段显示了如何在同一个事务中运行2个插入。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:525
#, no-wrap
msgid ""
"public static Uni<Void> insertTwoFruits(PgPool client, Fruit fruit1, Fruit fruit2) {\n"
"    return client.withTransaction(conn -> {\n"
"        Uni<RowSet<Row>> insertOne = conn.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING id\")\n"
"                .execute(Tuple.of(fruit1.name));\n"
"        Uni<RowSet<Row>> insertTwo = conn.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING id\")\n"
"                .execute(Tuple.of(fruit2.name));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:531
#, no-wrap
msgid ""
"        return Uni.combine().all().unis(insertOne, insertTwo)\n"
"                // Ignore the results (the two ids)\n"
"                .discardItems();\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:534
#, fuzzy
msgid "In this example, the transaction is automatically committed on success or rolled back on failure."
msgstr "在这个例子中，交易在成功时自动提交，失败时自动回滚。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:536
#, fuzzy
msgid "You can also create dependent actions as follows:"
msgstr "你也可以按以下方式创建从属行动。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:540
#, no-wrap
msgid "return client.withTransaction(conn -> conn\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:543
#, no-wrap
msgid ""
"        .preparedQuery(\"INSERT INTO person (firstname,lastname) VALUES ($1,$2) RETURNING id\")\n"
"        .execute(Tuple.of(person.getFirstName(), person.getLastName()))\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:546
#, no-wrap
msgid ""
"        .onItem().transformToUni(id -> conn.preparedQuery(\"INSERT INTO addr (person_id,addrline1) VALUES ($1,$2)\")\n"
"                .execute(Tuple.of(id.iterator().next().getLong(\"id\"), person.getLastName())))\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:548
#, no-wrap
msgid "        .onItem().ignore().andContinueWithNull());\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:550
#, fuzzy, no-wrap
msgid "Working with batch query results"
msgstr "处理批量查询结果"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:554
#, fuzzy
msgid "When executing batch queries, reactive SQL clients return a `RowSet` that corresponds to the results of the first element in the batch.  To get the results of the following batch elements, you must invoke the `RowSet#next` method until it returns `null`."
msgstr "当执行批处理查询时，反应式SQL客户端会返回一个 `RowSet` ，与批处理中第一个元素的结果相对应。要获得下面的批处理元素的结果，必须调用 `RowSet#next` 方法，直到它返回 `null` 。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:557
#, fuzzy
msgid "Let's say you want to update some rows and compute the total number of affected rows.  You must inspect each `RowSet`:"
msgstr "假设你想更新一些行，并计算出受影响的行的总数。你必须检查每个 `RowSet` 。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:561
#, no-wrap
msgid "PreparedQuery<RowSet<Row>> preparedQuery = client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:566
#, no-wrap
msgid ""
"Uni<RowSet<Row>> rowSet = preparedQuery.executeBatch(Arrays.asList(\n"
"        Tuple.of(\"Orange\", 1),\n"
"        Tuple.of(\"Pear\", 2),\n"
"        Tuple.of(\"Apple\", 3)));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:574
#, no-wrap
msgid ""
"Uni<Integer> totalAffected = rowSet.onItem().transform(res -> {\n"
"    int total = 0;\n"
"    do {\n"
"        total += res.rowCount(); // <1>\n"
"    } while ((res = res.next()) != null); // <2>\n"
"    return total;\n"
"});\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:576
#, fuzzy
msgid "Compute the sum of `RowSet#rowCount`."
msgstr "计算 `RowSet#rowCount` 的总和。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:577
#, fuzzy
msgid "Invoke `RowSet#next` until it returns `null`."
msgstr "调用 `RowSet#next` ，直到它返回 `null` 。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:579
#, fuzzy
msgid "As another example, if you want to load all the rows you just inserted, you must concatenate the contents of each `RowSet`:"
msgstr "再举个例子，如果你想加载你刚刚插入的所有行，你必须把每个 `RowSet` 的内容连接起来。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:583
#, no-wrap
msgid "PreparedQuery<RowSet<Row>> preparedQuery = client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING *\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:588
#, no-wrap
msgid ""
"Uni<RowSet<Row>> rowSet = preparedQuery.executeBatch(Arrays.asList(\n"
"        Tuple.of(\"Orange\"),\n"
"        Tuple.of(\"Pear\"),\n"
"        Tuple.of(\"Apple\")));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:603
#, no-wrap
msgid ""
"// Generate a Multi of RowSet items\n"
"Multi<RowSet<Row>> rowSets = rowSet.onItem().transformToMulti(res -> {\n"
"    return Multi.createFrom().generator(() -> res, (rs, emitter) -> {\n"
"        RowSet<Row> next = null;\n"
"        if (rs != null) {\n"
"            emitter.emit(rs);\n"
"            next = rs.next();\n"
"        }\n"
"        if (next == null) {\n"
"            emitter.complete();\n"
"        }\n"
"        return next;\n"
"    });\n"
"});\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:606
#, no-wrap
msgid ""
"// Transform each RowSet into Multi of Row items and Concatenate\n"
"Multi<Row> rows = rowSets.onItem().transformToMultiAndConcatenate(Multi.createFrom()::iterable);\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:608
#, fuzzy, no-wrap
msgid "Multiple Datasources"
msgstr "多个数据源"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:611
#, fuzzy
msgid "The reactive SQL clients support defining several datasources."
msgstr "反应式SQL客户端支持定义几个数据源。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:613
#, fuzzy
msgid "A typical configuration with several datasources would look like:"
msgstr "一个有几个数据源的典型配置是这样的。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:620
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql <1>\n"
"quarkus.datasource.username=user-default\n"
"quarkus.datasource.password=password-default\n"
"quarkus.datasource.reactive.url=postgresql://localhost:5432/default\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:625
#, no-wrap
msgid ""
"quarkus.datasource.\"additional1\".db-kind=postgresql <2>\n"
"quarkus.datasource.\"additional1\".username=user-additional1\n"
"quarkus.datasource.\"additional1\".password=password-additional1\n"
"quarkus.datasource.\"additional1\".reactive.url=postgresql://localhost:5432/additional1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:630
#, no-wrap
msgid ""
"quarkus.datasource.\"additional2\".db-kind=mysql <3>\n"
"quarkus.datasource.\"additional2\".username=user-additional2\n"
"quarkus.datasource.\"additional2\".password=password-additional2\n"
"quarkus.datasource.\"additional2\".reactive.url=mysql://localhost:3306/additional2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:632
#, fuzzy
msgid "The default datasource - using PostgreSQL."
msgstr "默认的数据源--使用PostgreSQL。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:633
#, fuzzy
msgid "A named datasource called `additional1` - using PostgreSQL."
msgstr "一个名为 `additional1` 的数据源 - 使用PostgreSQL。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:634
#, fuzzy
msgid "A named datasource called `additional2` - using MySQL."
msgstr "一个名为 `additional2` 的数据源 - 使用MySQL。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:636
#, fuzzy
msgid "You can then inject the clients as follows:"
msgstr "然后你可以按以下方式注入客户端。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:641
#, no-wrap
msgid ""
"@Inject <1>\n"
"PgPool defaultClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:645
#, no-wrap
msgid ""
"@Inject\n"
"@ReactiveDataSource(\"additional1\") <2>\n"
"PgPool additional1Client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:649
#, no-wrap
msgid ""
"@Inject\n"
"@ReactiveDataSource(\"additional2\")\n"
"MySQLPool additional2Client;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:651
#, fuzzy
msgid "Injecting the client for the default datasource does not require anything special."
msgstr "注入默认数据源的客户端不需要任何特殊的东西。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:652
#, fuzzy
msgid "For a named datasource, you use the `@ReactiveDataSource` CDI qualifier with the datasource name as its value."
msgstr "对于一个命名的数据源，你使用 `@ReactiveDataSource` CDI限定符，以数据源名称作为其值。"

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:653
#, fuzzy, no-wrap
msgid "UNIX Domain Socket connections"
msgstr "UNIX域套接字连接"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:656
#, fuzzy
msgid "The PostgreSQL and MariaDB/MySQL clients can be configured to connect to the server through a UNIX domain socket."
msgstr "PostgreSQL和MariaDB/MySQL客户端可以被配置为通过UNIX域套接字连接到服务器。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:658
#, fuzzy
msgid "First make sure that xref:vertx-reference.adoc#native-transport[native transport support] is enabled."
msgstr "首先要确保启用 link:vertx-reference.html#native-transport[本地传输支持] 。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:661
#, fuzzy
msgid "Then configure the database connection url.  This step depends on the database type."
msgstr "然后配置数据库连接网址。这一步取决于数据库的类型。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:665
#, fuzzy
msgid "PostgreSQL domain socket paths have the following form: `<directory>/.s.PGSQL.<port>`"
msgstr "PostgresSQL域套接字路径有以下形式。 `<directory>/.s.PGSQL.<port>` "

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:667
#, fuzzy
msgid "The database connection url must be configured so that:"
msgstr "必须对数据库连接网址进行配置，以使其能够。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:669
#, fuzzy
msgid "the `host` is the `directory` in the socket path"
msgstr " `host` 是插座路径中的 `directory` 。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:670
#, fuzzy
msgid "the `port` is the `port` in the socket path"
msgstr " `port` 是插座路径中的 `port` 。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:672
#, fuzzy
msgid "Consider the following socket path: `/var/run/postgresql/.s.PGSQL.5432`."
msgstr "考虑以下套接字路径： `/var/run/postgresql/.s.PGSQL.5432` 。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:674
#: upstream/_guides/reactive-sql-clients.adoc:687
#, fuzzy
msgid "In `application.properties` add:"
msgstr "在 `application.properties` 添加。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:678
#, no-wrap
msgid "quarkus.datasource.reactive.url=postgresql://:5432/quarkus_test?host=/var/run/postgresql\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:683
#, fuzzy
msgid "The database connection url must be configured so that the `host` is the socket path."
msgstr "数据库连接的网址必须被配置为： `host` ，以使其成为套接字路径。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:685
#, fuzzy
msgid "Consider the following socket path: `/var/run/mysqld/mysqld.sock`."
msgstr "考虑以下套接字路径： `/var/run/mysqld/mysqld.sock` 。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:691
#, no-wrap
msgid "quarkus.datasource.reactive.url=mysql:///quarkus_test?host=/var/run/mysqld/mysqld.sock\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:693
#, fuzzy, no-wrap
msgid "Load-balancing connections"
msgstr "负载平衡连接"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:696
#, fuzzy
msgid "The reactive PostgreSQL and MariaDB/MySQL clients support defining several connections."
msgstr "反应式SQL客户端支持定义几个数据源。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:698
#, fuzzy
msgid "A typical configuration with several connections would look like:"
msgstr "一个有几个数据源的典型配置是这样的。"

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:702
#, no-wrap
msgid "quarkus.datasource.reactive.url=postgresql://host1:5432/default,postgresql://host2:5432/default,postgresql://host3:5432/default\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:705
#, fuzzy
msgid "This can also be written with indexed property syntax:"
msgstr "这也可以用索引属性的语法来写："

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:711
#, no-wrap
msgid ""
"quarkus.datasource.reactive.url[0]=postgresql://host1:5432/default\n"
"quarkus.datasource.reactive.url[1]=postgresql://host2:5432/default\n"
"quarkus.datasource.reactive.url[2]=postgresql://host3:5432/default\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:713
#, fuzzy, no-wrap
msgid "Pooled connection `idle-timeout`"
msgstr "集合式连接 `idle-timeout` "

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:717
#, fuzzy
msgid "Reactive datasources can be configured with an `idle-timeout`.  It is the maximum time a connection remains unused in the pool before it is closed."
msgstr "反应式数据源可以配置一个 `idle-timeout` （单位：毫秒）。这是一个连接在池子里保持未使用的最大时间，然后才会被关闭。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:719
#, fuzzy
msgid "The `idle-timeout` is disabled by default."
msgstr " `idle-timeout` ，默认情况下是禁用的。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:721
#, fuzzy
msgid "For example, you could expire idle connections after 60 minutes:"
msgstr "例如，你可以在60分钟后使空闲的连接过期："

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:725
#, no-wrap
msgid "quarkus.datasource.reactive.idle-timeout=PT60M\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:727
#, fuzzy, no-wrap
msgid "Pooled Connection `max-lifetime`"
msgstr "集合式连接 `idle-timeout` "

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:732
msgid "In addition to `idle-timeout`, reactive datasources can also be configured with a `max-lifetime`.  It is the maximum time a connection remains in the pool before it is closed and replaced as needed.  The `max-lifetime` allows ensuring the pool has fresh connections with up-to-date configuration."
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:735
msgid "The `max-lifetime` is disabled by default but is an important configuration when using a credentials provider that provides time limited credentials, like the xref:credentials-provider.adoc[Vault credentials provider]."
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:737
#, fuzzy
msgid "For example, you could ensure connections are recycled after 60 minutes:"
msgstr "例如，你可以在60分钟后使空闲的连接过期："

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:741
#, no-wrap
msgid "quarkus.datasource.reactive.max-lifetime=PT60M\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:743
#, fuzzy, no-wrap
msgid "Customizing pool creation"
msgstr "定制水池的创建"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:746
#, fuzzy
msgid "Sometimes, the database connection pool cannot be configured only by declaration."
msgstr "必须对数据库连接网址进行配置，以使其能够。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:748
#, fuzzy
msgid "You may need to read a specific file only present in production, or retrieve configuration data from a proprietary configuration server."
msgstr "你可能需要读取一个只存在于生产中的特定文件，或者从一个专有的配置服务器中检索配置数据。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:750
#, fuzzy
msgid "In this case, you can customize pool creation by creating a class implementing an interface which depends on the target database:"
msgstr "在这种情况下，你可以通过创建一个实现取决于目标数据库的接口的类来定制池的创建："

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:755
#, fuzzy, no-wrap
msgid "Pool creator class name"
msgstr "池类名称"

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:758
#, fuzzy, no-wrap
msgid "`io.quarkus.reactive.db2.client.DB2PoolCreator`"
msgstr " `quarkus-reactive-db2-client` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:761
#, fuzzy, no-wrap
msgid "`io.quarkus.reactive.mysql.client.MySQLPoolCreator`"
msgstr " `io.vertx.mutiny.mysqlclient.MySQLPool` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:764
#, fuzzy, no-wrap
msgid "`io.quarkus.reactive.mssql.client.MSSQLPoolCreator`"
msgstr " `io.vertx.mutiny.mssqlclient.MSSQLPool` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:767
#, fuzzy, no-wrap
msgid "`io.quarkus.reactive.oracle.client.OraclePoolCreator`"
msgstr " `io.vertx.mutiny.oracleclient.OraclePool` "

#. type: Table
#: upstream/_guides/reactive-sql-clients.adoc:769
#, fuzzy, no-wrap
msgid "`io.quarkus.reactive.pg.client.PgPoolCreator`"
msgstr " `quarkus-reactive-pg-client` "

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:772
#: upstream/_guides/reactive-sql-clients.adoc:803
#, fuzzy
msgid "Here's an example for PostgreSQL:"
msgstr "这里有一个PostgreSQL的例子："

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:776
#, no-wrap
msgid "import jakarta.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:781
#, no-wrap
msgid ""
"import io.quarkus.reactive.pg.client.PgPoolCreator;\n"
"import io.vertx.pgclient.PgConnectOptions;\n"
"import io.vertx.pgclient.PgPool;\n"
"import io.vertx.sqlclient.PoolOptions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:784
#, no-wrap
msgid ""
"@Singleton\n"
"public class CustomPgPoolCreator implements PgPoolCreator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:793
#, no-wrap
msgid ""
"    @Override\n"
"    public PgPool create(Input input) {\n"
"        PgConnectOptions connectOptions = input.pgConnectOptions();\n"
"        PoolOptions poolOptions = input.poolOptions();\n"
"        // Customize connectOptions, poolOptions or both, as required\n"
"        return PgPool.pool(input.vertx(), connectOptions, poolOptions);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:795
#, fuzzy, no-wrap
msgid "Pipelining"
msgstr "Pipelining"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:799
#, fuzzy
msgid "The PostgreSQL and MariaDB/MySQL clients support pipelining of queries at the connection level.  The feature consists in sending multiple queries on the same database connection without waiting for the corresponding responses."
msgstr "PostgreSQL和MariaDB/MySQL客户端支持连接层面的查询管道。该功能包括在同一数据库连接上发送多个查询，而无需等待相应的响应。"

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:801
msgid "In some use cases, query pipelining can improve database access performance."
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:807
#, no-wrap
msgid "import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:810
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:812
#, no-wrap
msgid "public class PipeliningExample {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:815
#, no-wrap
msgid ""
"    @Inject\n"
"    PgPool client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:828
#, no-wrap
msgid ""
"    public Uni<String> favoriteFruitAndVegetable() {\n"
"        // Explicitly acquire a connection\n"
"        return client.withConnection(conn -> {\n"
"            Uni<String> favoriteFruit = conn.query(\"SELECT name FROM fruits WHERE preferred IS TRUE\").execute()\n"
"                    .onItem().transform(rows -> rows.iterator().next().getString(\"name\"));\n"
"            Uni<String> favoriteVegetable = conn.query(\"SELECT name FROM vegetables WHERE preferred IS TRUE\").execute()\n"
"                    .onItem().transform(rows -> rows.iterator().next().getString(\"name\"));\n"
"            // favoriteFruit and favoriteVegetable unis will be subscribed at the same time\n"
"            return Uni.combine().all().unis(favoriteFruit, favoriteVegetable)\n"
"                    .combinedWith(PipeliningExample::formatMessage);\n"
"        });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:833
#, no-wrap
msgid ""
"    private static String formatMessage(String fruit, String vegetable) {\n"
"        return String.format(\"The favorite fruit is %s and the favorite vegetable is %s\", fruit, vegetable);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:836
msgid "The maximum number of pipelined queries is configured with the `pipelining-limit` property:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-sql-clients.adoc:843
#, no-wrap
msgid ""
"# For PostgreSQL\n"
"quarkus.datasource.reactive.postgresql.pipelining-limit=256\n"
"# For MariaDB/MySQL\n"
"quarkus.datasource.reactive.mysql.pipelining-limit=256\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-sql-clients.adoc:846
msgid "By default, `pipelining-limit` is set to 256."
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-sql-clients.adoc:847
#, no-wrap
msgid "Configuration Reference"
msgstr "配置参考"

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:849
#, no-wrap
msgid "Common Datasource"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-sql-clients.adoc:853
#, no-wrap
msgid "Reactive Datasource"
msgstr ""
