# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/reactive-routes.adoc:6
#, fuzzy, no-wrap
msgid "Using Reactive Routes"
msgstr "使用反应式路由"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:14
#, fuzzy
msgid "Reactive routes propose an alternative approach to implement HTTP endpoints where you declare and chain _routes_.  This approach became very popular in the JavaScript world, with frameworks like Express.Js or Hapi.  Quarkus also offers the possibility to use reactive routes.  You can implement REST API with routes only or combine them with JAX-RS resources and servlets."
msgstr "反应式路由提出了另一种实现HTTP端点的方法，即声明和链式 _路由_ 。这种方法在JavaScript领域非常流行，比如Express.Js或Hapi等框架。Quarkus也提供了使用反应式路由的可能性。你可以只用路由来实现REST API，或者将它们与JAX-RS资源和servlets结合起来。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:16
#, fuzzy
msgid "The code presented in this guide is available in this {quickstarts-base-url}[GitHub repository] under the {quickstarts-tree-url}/reactive-routes-quickstart[`reactive-routes-quickstart` directory]"
msgstr "本指南中介绍的代码可在此{quickstarts-base-url}[GitHub仓库]下的{quickstarts-tree-url}/reactive-routes-quickstart[ `reactive-routes-quickstart` 目录] 中找到。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:20
#, fuzzy
msgid "Reactive Routes were initially introduced to provide a reactive execution model for HTTP APIs on top of the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture].  With the introduction of xref:resteasy-reactive.adoc[RESTEasy Reactive], you can now implement reactive HTTP APIs and still use JAX-RS annotations.  Reactive Routes are still supported, especially if you want a more _route-based_ approach, and something closer to the underlying reactive engine."
msgstr "反应式路由最初是为了在 link:quarkus-reactive-architecture.html[Quarkus反应式架构] 之上为HTTP API提供一个反应式执行模型而引入的。随着 link:resteasy-reactive.html[RESTEasy Reactive] 的引入，你现在可以实现反应式HTTP APIs，并且仍然使用JAX-RS注释。反应式路由仍然被支持，特别是如果你想要一个更 _基于路由的_ 方法，以及更接近底层反应式引擎的东西。"

#. type: Title ==
#: upstream/_guides/reactive-routes.adoc:21
#, fuzzy, no-wrap
msgid "Quarkus HTTP"
msgstr "Quarkus HTTP"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:28
#, fuzzy
msgid "Before going further, let's have a look at the HTTP layer of Quarkus.  Quarkus HTTP support is based on a non-blocking and reactive engine (Eclipse Vert.x and Netty).  All the HTTP requests your application receive are handled by _event loops_ (I/O Thread) and then are routed towards the code that manages the request.  Depending on the destination, it can invoke the code managing the request on a worker thread (Servlet, Jax-RS) or use the IO Thread (reactive route).  Note that because of this, a reactive route must be non-blocking or explicitly declare its blocking nature (which would result by being called on a worker thread)."
msgstr "在进一步讨论之前，让我们先看看Quarkus的HTTP层。Quarkus的HTTP支持是基于一个非阻塞和反应式引擎（Eclipse Vert.x和Netty）。你的应用程序收到的所有HTTP请求都由 _事件循环_ （I/O Thread）处理，然后被路由到管理该请求的代码。根据目的地的不同，它可以在工作线程（Servlet、Jax-RS）上调用管理请求的代码，或者使用IO Thread（反应式路由）。请注意，正因为如此，一个反应式路由必须是非阻塞的，或者明确声明其阻塞的性质（这将导致在一个工作线程上被调用）。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:30
#, fuzzy
msgid "image:http-architecture.png[alt=Quarkus HTTP Architecture]"
msgstr "image:http-architecture.png[alt=\"Quarkus HTTP Architecture\"]"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:32
#, fuzzy
msgid "See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic."
msgstr "关于这个话题的更多细节，请看 link:quarkus-reactive-architecture.html[Quarkus Reactive Architecture文档] 。"

#. type: Title ==
#: upstream/_guides/reactive-routes.adoc:34
#, fuzzy, no-wrap
msgid "Declaring reactive routes"
msgstr "声明反应式路由"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:38
#, fuzzy
msgid "The first way to use reactive routes is to use the `@Route` annotation.  To have access to this annotation, you need to add the `quarkus-reactive-routes` extension:"
msgstr "使用反应式路由的第一个方法是使用 `@Route` 注解。要访问这个注解，你需要添加 `quarkus-reactive-routes` 扩展。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:40
#, fuzzy
msgid "In your build file, add:"
msgstr "在你的构建文件中，添加。"

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:42
#: upstream/_guides/reactive-routes.adoc:717
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:48
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-reactive-routes</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:51
#: upstream/_guides/reactive-routes.adoc:726
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:54
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-reactive-routes\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:57
#, fuzzy
msgid "Then in a _bean_, you can use the `@Route` annotation as follows:"
msgstr "然后在一个 _Bean_ 中，你可以使用 `@Route` 注解，如下所示。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:61
#: upstream/_guides/reactive-routes.adoc:669
#, no-wrap
msgid "package org.acme.reactive.routes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:66
#, no-wrap
msgid ""
"import io.quarkus.vertx.web.Route;\n"
"import io.quarkus.vertx.web.Route.HttpMethod;\n"
"import io.quarkus.vertx.web.RoutingExchange;\n"
"import io.vertx.ext.web.RoutingContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:68
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:71
#, no-wrap
msgid ""
"@ApplicationScoped // <1>\n"
"public class MyDeclarativeRoutes {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:77
#, no-wrap
msgid ""
"    // neither path nor regex is set - match a path derived from the method name\n"
"    @Route(methods = Route.HttpMethod.GET) // <2>\n"
"    void hello(RoutingContext rc) { // <3>\n"
"        rc.response().end(\"hello\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:82
#, no-wrap
msgid ""
"    @Route(path = \"/world\") \n"
"    String helloWorld() { // <4>\n"
"        return \"Hello world!\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:88
#, no-wrap
msgid ""
"    @Route(path = \"/greetings\", methods = Route.HttpMethod.GET)\n"
"    void greetings(RoutingExchange ex) { // <5>\n"
"        ex.ok(\"hello \" + ex.getParam(\"name\").orElse(\"world\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:90
#, fuzzy
msgid "If there is a reactive route found on a class with no scope annotation then `@javax.inject.Singleton` is added automatically."
msgstr "如果在一个没有范围注解的类上发现了一个反应式路由，那么 `@javax.inject.Singleton` ，就会自动添加。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:91
#, fuzzy
msgid "The `@Route` annotation indicates that the method is a reactive route. Again, by default, the code contained in the method must not block."
msgstr " `@Route` 注解表明该方法是一个反应式途径。同样，在默认情况下，该方法中包含的代码必须不阻塞。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:92
#, fuzzy
msgid "The method gets a https://vertx.io/docs/apidocs/io/vertx/ext/web/RoutingContext.html[`RoutingContext`] as a parameter. From the `RoutingContext` you can retrieve the HTTP request (using `request()`) and write the response using `response().end(...)`."
msgstr "该方法得到一个 link:https://vertx.io/docs/apidocs/io/vertx/ext/web/RoutingContext.html[`RoutingContext`] 作为参数。从 `RoutingContext` ，你可以检索到HTTP请求（使用 `request()` ），并使用 `response().end(…​)` 写出响应。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:93
#, fuzzy
msgid "If the annotated method does not return `void` the arguments are optional."
msgstr "如果被注释的方法不返回 `void` ，则参数是可选的。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:94
#, fuzzy
msgid "`RoutingExchange` is a convenient wrapper of `RoutingContext` which provides some useful methods."
msgstr " `RoutingExchange` 是一个方便的 的包装器，提供了一些有用的方法。 `RoutingContext` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:96
#, fuzzy
msgid "More details about using the `RoutingContext` is available in the https://vertx.io/docs/vertx-web/java/[Vert.x Web documentation]."
msgstr "关于使用 `RoutingContext` 的更多细节，可以在 link:https://vertx.io/docs/vertx-web/java/[Vert.x Web文档] 中找到。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:98
#, fuzzy
msgid "The `@Route` annotation allows you to configure:"
msgstr " `@Route` 注释允许你进行配置。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:100
#, fuzzy
msgid "The `path` - for routing by path, using the https://vertx.io/docs/vertx-web/java/#_capturing_path_parameters[Vert.x Web format]"
msgstr " `path` - 用于按路径路由，使用 link:https://vertx.io/docs/vertx-web/java/#_capturing_path_parameters[Vert.x Web格式] 。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:101
#, fuzzy
msgid "The `regex` - for routing with regular expressions, see https://vertx.io/docs/vertx-web/java/#_routing_with_regular_expressions[for more details]"
msgstr " `regex` - 使用正则表达式进行路由， link:https://vertx.io/docs/vertx-web/java/#_routing_with_regular_expressions[更多细节] 见"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:102
#, fuzzy
msgid "The `methods` - the HTTP verb triggering the route such as `GET`, `POST`..."
msgstr " `methods` - 触发路由的HTTP动词，如 `GET` , `POST` ..."

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:103
#, fuzzy
msgid "The `type` - it can be _normal_ (non-blocking), _blocking_ (method dispatched on a worker thread), or _failure_ to indicate that this route is called on failures"
msgstr " `type` - 它可以是 _正常的_ （非阻塞的）， _阻塞的_ （在工作线程上派发的方法），或者是 _失败的_ ，以表明此路由在失败时被调用。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:105
#, fuzzy
msgid "The `order` - the order of the route when several routes are involved in handling the incoming request.  Must be positive for regular user routes."
msgstr " `order` - 当几个路由参与处理传入的请求时，路由的顺序。对于普通用户路由必须是正数。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:106
#, fuzzy
msgid "The produced and consumed mime types using `produces`, and `consumes`"
msgstr "使用 `produces` ，生产和消费的mime类型，以及 `consumes` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:108
#, fuzzy
msgid "For instance, you can declare a blocking route as follows:"
msgstr "例如，你可以这样声明一个阻塞性路由。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:115
#, no-wrap
msgid ""
"@Route(methods = HttpMethod.POST, path = \"/post\", type = Route.HandlerType.BLOCKING)\n"
"public void blocking(RoutingContext rc) {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/reactive-routes.adoc:120
#, fuzzy
msgid "Alternatively, you can use `@io.smallrye.common.annotation.Blocking` and omit the `type = Route.HandlerType.BLOCKING`:"
msgstr "或者，你可以使用 `@io.smallrye.common.annotation.Blocking` ，省略 `type = Route.HandlerType.BLOCKING` 。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:127
#, no-wrap
msgid ""
"@Route(methods = HttpMethod.POST, path = \"/post\")\n"
"@Blocking\n"
"public void blocking(RoutingContext rc) {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:129
#, fuzzy
msgid "When `@Blocking` is used, it ignores the `type` attribute of `@Route`."
msgstr "当使用 `@Blocking` ，它忽略了 `@Route` 的属性 `type` 。"

#. type: delimited block =
#: upstream/_guides/reactive-routes.adoc:132
#, fuzzy
msgid "The `@Route` annotation is repeatable and so you can declare several routes for a single method:"
msgstr " `@Route` 注解是可重复的，因此你可以为一个方法声明多个路由。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:140
#, no-wrap
msgid ""
"@Route(path = \"/first\") <1>\n"
"@Route(path = \"/second\")\n"
"public void route(RoutingContext rc) {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:142
#, fuzzy
msgid "Each route can use different paths, methods..."
msgstr "每条路线可以使用不同的路径、方法..."

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:144
#, fuzzy
msgid "If no content-type header is set then we will try to use the most acceptable content type as defined by `io.vertx.ext.web.RoutingContext.getAcceptableContentType()`."
msgstr "如果没有设置内容类型头，那么我们将尝试使用由 `io.vertx.ext.web.RoutingContext.getAcceptableContentType()` 定义的最可接受的内容类型。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:151
#, no-wrap
msgid ""
"@Route(path = \"/person\", produces = \"text/html\") <1>\n"
"String person() {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:153
#, fuzzy
msgid "If the `accept` header matches `text/html` we set the content type automatically."
msgstr "如果 `accept` header与 `text/html` ，我们就会自动设置内容类型。"

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:154
#, fuzzy, no-wrap
msgid "Handling conflicting routes"
msgstr "处理冲突的路线"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:158
#, fuzzy
msgid "You may end up with multiple routes matching a given path.  In the following example, both route matches `/accounts/me`:"
msgstr "你最终可能会有多个路由匹配一个给定的路径。在下面的例子中，两个路由都匹配 `/accounts/me` 。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:165
#, no-wrap
msgid ""
"@Route(path = \"/accounts/:id\", methods = HttpMethod.GET)\n"
"void getAccount(RoutingContext ctx) {\n"
"  ...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:170
#, no-wrap
msgid ""
"@Route(path = \"/accounts/me\", methods = HttpMethod.GET)\n"
"void getCurrentUserAccount(RoutingContext ctx) {\n"
"  ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:174
#, fuzzy
msgid "As a consequence, the result is not the expected one as the first route is called with the path parameter `id` set to `me`.  To avoid the conflict, use the `order` attribute:"
msgstr "因此，结果不是预期的，因为第一个路由被调用时，路径参数 `id` 设置为 `me` 。为了避免冲突，使用 `order` 属性。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:181
#, no-wrap
msgid ""
"@Route(path = \"/accounts/:id\", methods = HttpMethod.GET, order = 2)\n"
"void getAccount(RoutingContext ctx) {\n"
"  ...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:186
#, no-wrap
msgid ""
"@Route(path = \"/accounts/me\", methods = HttpMethod.GET, order = 1)\n"
"void getCurrentUserAccount(RoutingContext ctx) {\n"
"  ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:190
#, fuzzy
msgid "By giving a lower order to the second route, it gets evaluated first.  If the request path matches, it is invoked, otherwise the other routes are evaluated."
msgstr "通过给第二个路由一个较低的顺序，它首先被评估。如果请求路径匹配，它就被调用，否则就评估其他路由。"

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:191
#, fuzzy, no-wrap
msgid "`@RouteBase`"
msgstr " `@RouteBase` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:194
#, fuzzy
msgid "This annotation can be used to configure some defaults for reactive routes declared on a class."
msgstr "这个注解可以用来为在类上声明的反应式路由配置一些默认值。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:199
#, no-wrap
msgid ""
"@RouteBase(path = \"simple\", produces = \"text/plain\") <1> <2>\n"
"public class SimpleRoutes {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:205
#, no-wrap
msgid ""
"    @Route(path = \"ping\") // the final path is /simple/ping\n"
"    void ping(RoutingContext rc) {\n"
"        rc.response().end(\"pong\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:207
#, fuzzy
msgid "The `path` value is used as a prefix for any route method declared on the class where `Route#path()` is used."
msgstr " `path` 的值被用作在使用 `Route#path()` 的类上声明的任何路由方法的前缀。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:208
#, fuzzy
msgid "The value of `produces()` is used for content-based routing for all routes where `Route#produces()` is empty."
msgstr " `produces()` 的值用于基于内容的路由，用于所有 `Route#produces()` 为空的路由。"

#. type: Title ==
#: upstream/_guides/reactive-routes.adoc:210
#, fuzzy, no-wrap
msgid "Reactive Route Methods"
msgstr "反应性路线方法"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:215
#, fuzzy
msgid "A route method must be a non-private non-static method of a CDI bean.  If the annotated method returns `void` then it has to accept at least one argument - see the supported types below.  If the annotated method does not return `void` then the arguments are optional."
msgstr "一个路由方法必须是CDI Bean的非私有非静态方法。如果注解的方法返回 `void` ，那么它必须接受至少一个参数--见下面的支持类型。如果被注释的方法不返回 `void` ，那么参数是可选的。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:218
#, fuzzy
msgid "Methods that return `void` must __end__ the response or the HTTP request to this route will never end.  Some methods of `RoutingExchange` do it for you, others not and you must call the `end()` method of the response by yourself, please refer to its JavaDoc for more information."
msgstr "返回 `void` 的方法必须 _结束_ 响应，否则这个路由的HTTP请求将永远不会结束。 `RoutingExchange` 的一些方法为你做，另一些则不做，你必须自己调用响应的 `end()` 方法，更多信息请参考其 JavaDoc。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:220
#, fuzzy
msgid "A route method can accept arguments of the following types:"
msgstr "一个路由方法可以接受以下类型的参数。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:222
#, fuzzy
msgid "`io.vertx.ext.web.RoutingContext`"
msgstr " `io.vertx.ext.web.RoutingContext` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:223
#, fuzzy
msgid "`io.quarkus.vertx.web.RoutingExchange`"
msgstr " `io.quarkus.vertx.web.RoutingExchange` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:224
#, fuzzy
msgid "`io.vertx.core.http.HttpServerRequest`"
msgstr " `io.vertx.core.http.HttpServerRequest` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:225
#, fuzzy
msgid "`io.vertx.core.http.HttpServerResponse`"
msgstr " `io.vertx.core.http.HttpServerResponse` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:226
#, fuzzy
msgid "`io.vertx.mutiny.core.http.HttpServerRequest`"
msgstr " `io.vertx.mutiny.core.http.HttpServerRequest` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:227
#, fuzzy
msgid "`io.vertx.mutiny.core.http.HttpServerResponse`"
msgstr " `io.vertx.mutiny.core.http.HttpServerResponse` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:229
#, fuzzy
msgid "Furthermore, it is possible to inject the `HttpServerRequest` parameters into a method parameter annotated with `@io.quarkus.vertx.web.Param`:"
msgstr "此外，还可以将 `HttpServerRequest` 参数注入到用 `@io.quarkus.vertx.web.Param` 注解的方法参数中。"

#. type: Table
#: upstream/_guides/reactive-routes.adoc:232
#: upstream/_guides/reactive-routes.adoc:252
#: upstream/_guides/reactive-routes.adoc:272
#, fuzzy, no-wrap
msgid "Parameter Type"
msgstr "参数类型"

#. type: Table
#: upstream/_guides/reactive-routes.adoc:234
#: upstream/_guides/reactive-routes.adoc:254
#: upstream/_guides/reactive-routes.adoc:274
#, fuzzy, no-wrap
msgid ""
"Obtained via  \n"
"//-------------"
msgstr "通过以下方式获得"

#. type: Table
#: upstream/_guides/reactive-routes.adoc:234
#: upstream/_guides/reactive-routes.adoc:254
#: upstream/_guides/reactive-routes.adoc:274
#, fuzzy, no-wrap
msgid "`java.lang.String`"
msgstr " `java.lang.String` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:235
#: upstream/_guides/reactive-routes.adoc:236
#, fuzzy, no-wrap
msgid "`routingContext.request().getParam()`"
msgstr " `routingContext.request().getParam()` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:235
#: upstream/_guides/reactive-routes.adoc:255
#, fuzzy, no-wrap
msgid "`java.util.Optional<String>`"
msgstr " `java.util.Optional<String>` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:236
#: upstream/_guides/reactive-routes.adoc:256
#, fuzzy, no-wrap
msgid "`java.util.List<String>`"
msgstr " `java.util.List<String>` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:237
#, fuzzy, no-wrap
msgid "`routingContext.request().params().getAll()`"
msgstr " `routingContext.request().params().getAll()` "

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:239
#, fuzzy, no-wrap
msgid "Request Parameter Example"
msgstr "请求参数示例"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:246
#, no-wrap
msgid ""
"@Route\n"
"String hello(@Param Optional<String> name) {\n"
"   return \"Hello \" + name.orElse(\"world\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:249
#, fuzzy
msgid "The `HttpServerRequest` headers can be injected into a method parameter annotated with `@io.quarkus.vertx.web.Header`:"
msgstr " `HttpServerRequest` headers可以被注入到一个用 `@io.quarkus.vertx.web.Header` 注释的方法参数中。"

#. type: Table
#: upstream/_guides/reactive-routes.adoc:255
#: upstream/_guides/reactive-routes.adoc:256
#, fuzzy, no-wrap
msgid "`routingContext.request().getHeader()`"
msgstr " `routingContext.request().getHeader()` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:257
#, fuzzy, no-wrap
msgid "`routingContext.request().headers().getAll()`"
msgstr " `routingContext.request().headers().getAll()` "

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:259
#, fuzzy, no-wrap
msgid "Request Header Example"
msgstr "请求标头示例"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:266
#, no-wrap
msgid ""
"@Route\n"
"String helloFromHeader(@Header(\"My-Header\") String header) {\n"
"   return header;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:269
#, fuzzy
msgid "The request body can be injected into a method parameter annotated with `@io.quarkus.vertx.web.Body`."
msgstr "请求主体可以被注入一个用 `@io.quarkus.vertx.web.Body` 注释的方法参数中。"

#. type: Table
#: upstream/_guides/reactive-routes.adoc:275
#, fuzzy, no-wrap
msgid "`routingContext.getBodyAsString()`"
msgstr " `routingContext.getBodyAsString()` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:275
#, fuzzy, no-wrap
msgid "`io.vertx.core.buffer.Buffer`"
msgstr " `io.vertx.core.buffer.Buffer` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:276
#, fuzzy, no-wrap
msgid "`routingContext.getBody()`"
msgstr " `routingContext.getBody()` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:276
#, fuzzy, no-wrap
msgid "`io.vertx.core.json.JsonObject`"
msgstr " `io.vertx.core.json.JsonObject` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:277
#, fuzzy, no-wrap
msgid "`routingContext.getBodyAsJson()`"
msgstr " `routingContext.getBodyAsJson()` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:277
#, fuzzy, no-wrap
msgid "`io.vertx.core.json.JsonArray`"
msgstr " `io.vertx.core.json.JsonArray` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:278
#, fuzzy, no-wrap
msgid "`routingContext.getBodyAsJsonArray()`"
msgstr " `routingContext.getBodyAsJsonArray()` "

#. type: Table
#: upstream/_guides/reactive-routes.adoc:278
#, fuzzy, no-wrap
msgid "any other type"
msgstr "任何其他类型"

#. type: Table
#: upstream/_guides/reactive-routes.adoc:279
#, fuzzy, no-wrap
msgid "`routingContext.getBodyAsJson().mapTo(MyPojo.class)`"
msgstr " `routingContext.getBodyAsJson().mapTo(MyPojo.class)` "

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:281
#, fuzzy, no-wrap
msgid "Request Body Example"
msgstr "请求正文示例"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:289
#, no-wrap
msgid ""
"@Route(produces = \"application/json\")\n"
"Person createPerson(@Body Person person, @Param(\"id\") Optional<String> primaryKey) {\n"
"  person.setId(primaryKey.map(Integer::valueOf).orElse(42));\n"
"  return person;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:293
#, fuzzy
msgid "A failure handler can declare a single method parameter whose type extends `Throwable`.  The type of the parameter is used to match the result of `RoutingContext#failure()`."
msgstr "失败处理程序可以声明一个单一的方法参数，其类型扩展为 `Throwable` 。该参数的类型用于匹配 `RoutingContext#failure()` 的结果。"

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:294
#, fuzzy, no-wrap
msgid "Failure Handler Example"
msgstr "失败处理程序实例"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:301
#, no-wrap
msgid ""
"@Route(type = HandlerType.FAILURE)\n"
"void unsupported(UnsupportedOperationException e, HttpServerResponse response) {\n"
"  response.setStatusCode(501).end(e.getMessage());\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:303
#, fuzzy, no-wrap
msgid "Returning Unis"
msgstr "返回的大学"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:306
#, fuzzy
msgid "In a reactive route, you can return a `Uni` directly:"
msgstr "在一个反应式路由中，你可以直接返回一个 `Uni` 。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:313
#, no-wrap
msgid ""
"@Route(path = \"/hello\")\n"
"Uni<String> hello(RoutingContext context) {\n"
"    return Uni.createFrom().item(\"Hello world!\");\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:318
#, no-wrap
msgid ""
"@Route(path = \"/person\")\n"
"Uni<Person> getPerson(RoutingContext context) {\n"
"    return Uni.createFrom().item(() -> new Person(\"neo\", 12345));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:321
#, fuzzy
msgid "Returning `Unis` is convenient when using a reactive client:"
msgstr "在使用反应式客户端时，返回 `Unis` ，很方便。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:328
#, no-wrap
msgid ""
"@Route(path = \"/mail\")\n"
"Uni<Void> sendEmail(RoutingContext context) {\n"
"    return mailer.send(...);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:331
#, fuzzy
msgid "The item produced by the returned `Uni` can be:"
msgstr "由返回的 `Uni` 产生的项目可以是。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:333
#: upstream/_guides/reactive-routes.adoc:359
#, fuzzy
msgid "a string - written into the HTTP response directly"
msgstr "一个字符串 - 直接写入HTTP响应中"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:334
#: upstream/_guides/reactive-routes.adoc:360
#, fuzzy
msgid "a buffer - written into the HTTP response directly"
msgstr "一个缓冲区--直接写入HTTP响应中"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:336
#: upstream/_guides/reactive-routes.adoc:362
#, fuzzy
msgid "an object - written into the HTTP response after having been encoded into JSON.  The `content-type` header is set to `application/json` if not already set."
msgstr "一个对象--在被编码为JSON后写入HTTP响应中。 `content-type` 标头如果尚未设置，则设置为 `application/json` 。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:338
#, fuzzy
msgid "If the returned `Uni` produces a failure (or is `null`), an HTTP 500 response is written."
msgstr "如果返回的 `Uni` 产生失败（或者是 `null` ），就会写一个HTTP 500响应。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:340
#, fuzzy
msgid "Returning a `Uni<Void>` produces a 204 response (no content)."
msgstr "返回 `Uni<Void>` ，产生204响应（无内容）。"

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:341
#, fuzzy, no-wrap
msgid "Returning results"
msgstr "返回结果"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:344
#, fuzzy
msgid "You can also return a result directly:"
msgstr "你也可以直接返回一个结果。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:351
#, no-wrap
msgid ""
"@Route(path = \"/hello\")\n"
"String helloSync(RoutingContext context) {\n"
"    return \"Hello world\";\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:355
#, fuzzy
msgid "Be aware, the processing must be **non-blocking** as reactive routes are invoked on the IO Thread.  Otherwise, set the `type` attribute of the `@Route` annotation to `Route.HandlerType.BLOCKING`, or use the `@io.smallrye.common.annotation.Blocking` annotation."
msgstr "请注意，处理必须是 *无阻塞* 的，因为反应式路由是在IO线程上调用的。否则，将 `@Route` 注解的 `type` 属性设置为 `Route.HandlerType.BLOCKING` ，或者使用 `@io.smallrye.common.annotation.Blocking` 注解。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:357
#: upstream/_guides/reactive-routes.adoc:379
#, fuzzy
msgid "The method can return:"
msgstr "该方法可以返回。"

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:363
#, fuzzy, no-wrap
msgid "Returning Multis"
msgstr "归来的多胞胎"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:368
#, fuzzy
msgid "A reactive route can return a `Multi`.  The items are written one by one, in the response.  The response `Transfer-Encoding` header is set to `chunked`."
msgstr "一个反应式路由可以返回一个 `Multi` 。这些项目被逐一写入响应中。响应 `Transfer-Encoding` 头被设置为 `chunked` 。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:375
#, no-wrap
msgid ""
"@Route(path = \"/hello\")\n"
"Multi<String> hellos(RoutingContext context) {\n"
"    return Multi.createFrom().items(\"hello\", \"world\", \"!\");  // <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:377
#, fuzzy
msgid "Produces `helloworld!`"
msgstr "生产 `helloworld!` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:381
#, fuzzy
msgid "a `Multi<String>` - the items are written one by one (one per _chunk_) in the response."
msgstr "a `Multi<String>` - 响应中的项目是一个接一个地写的（ _每块_ 一个）。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:382
#, fuzzy
msgid "a `Multi<Buffer>` - the buffers are written one by one (one per _chunk_) without any processing."
msgstr "a `Multi<Buffer>` - 缓冲区被一个一个地写入（ _每块_ 一个），不做任何处理。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:383
#, fuzzy
msgid "a `Multi<Object>` - the items are encoded to JSON written one by one in the response."
msgstr "a `Multi<Object>` - 项目被编码为JSON，逐一写入响应中。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:394
#, no-wrap
msgid ""
"@Route(path = \"/people\")\n"
"Multi<Person> people(RoutingContext context) {\n"
"    return Multi.createFrom().items(\n"
"            new Person(\"superman\", 1),\n"
"            new Person(\"batman\", 2),\n"
"            new Person(\"spiderman\", 3));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:397
#: upstream/_guides/reactive-routes.adoc:423
#, fuzzy
msgid "The previous snippet produces:"
msgstr "前面的片段产生了。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:403
#, no-wrap
msgid ""
"{\"name\":\"superman\", \"id\": 1} // chunk 1\n"
"{\"name\":\"batman\", \"id\": 2} // chunk 2\n"
"{\"name\":\"spiderman\", \"id\": 3} // chunk 3\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:405
#, fuzzy, no-wrap
msgid "Streaming JSON Array items"
msgstr "流式JSON数组项目"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:410
#, fuzzy
msgid "You can return a `Multi` to produce a JSON Array, where every item is an item from this array.  The response is written item by item to the client.  To do that set the `produces` attribute to `\"application/json\"` (or `ReactiveRoutes.APPLICATION_JSON`)."
msgstr "你可以返回一个 `Multi` ，产生一个JSON数组，其中每个项目都是这个数组的一个项目。响应被逐项写给客户端。要做到这一点，将 `produces` 属性设置为 `\"application/json\"` （或 `ReactiveRoutes.APPLICATION_JSON` ）。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:420
#, no-wrap
msgid ""
"@Route(path = \"/people\", produces = ReactiveRoutes.APPLICATION_JSON)\n"
"Multi<Person> people(RoutingContext context) {\n"
"    return Multi.createFrom().items(\n"
"            new Person(\"superman\", 1),\n"
"            new Person(\"batman\", 2),\n"
"            new Person(\"spiderman\", 3));\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:431
#, no-wrap
msgid ""
"[\n"
"  {\"name\":\"superman\", \"id\": 1} // chunk 1\n"
"  ,{\"name\":\"batman\", \"id\": 2} // chunk 2\n"
"  ,{\"name\":\"spiderman\", \"id\": 3} // chunk 3\n"
"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:436
#, fuzzy
msgid "The `produces` attribute is an array.  When you pass a single value you can omit the \"{\" and \"}\".  Note that `\"application/json\"` must be the first value in the array."
msgstr " `produces` 属性是一个数组。当你传递一个单值时，你可以省略\"{\"和\"}\"。注意， `\"application/json\"` 必须是数组中的第一个值。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:441
#, fuzzy
msgid "Only `Multi<String>`, `Multi<Object>` and `Multi<Void>` can be written into the JSON Array.  Using a `Multi<Void>` produces an empty array.  You cannot use `Multi<Buffer>`.  If you need to use `Buffer`, transform the content into a JSON or String representation first."
msgstr "只有 `Multi<String>` , `Multi<Object>` 和 `Multi<Void>` 可以被写入JSON数组中。使用 `Multi<Void>` 会产生一个空数组。你不能使用 `Multi<Buffer>` 。如果你需要使用 `Buffer` ，先将内容转化为JSON或String表示。"

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:443
#, fuzzy, no-wrap
msgid "Deprecation of `asJsonArray`"
msgstr "废弃的 `asJsonArray` "

#. type: delimited block =
#: upstream/_guides/reactive-routes.adoc:446
#, fuzzy
msgid "The `ReactiveRoutes.asJsonArray` has been deprecated as it is not compatible with the security layer of Quarkus."
msgstr " `ReactiveRoutes.asJsonArray` 已经被废弃，因为它与Quarkus的安全层不兼容。"

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:448
#, fuzzy, no-wrap
msgid "Event Stream and Server-Sent Event support"
msgstr "支持事件流和服务器发送的事件"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:452
#, fuzzy
msgid "You can return a `Multi` to produce an event source (stream of server sent events).  To enable this feature, set the `produces` attribute to `\"text/event-stream\"` (or `ReactiveRoutes.EVENT_STREAM`), such as in:"
msgstr "你可以返回一个 `Multi` ，产生一个事件源（服务器发送的事件流）。要启用这个功能，请将 `produces` 属性设置为 `\"text/event-stream\"` （或 `ReactiveRoutes.EVENT_STREAM` ），如在。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:462
#, no-wrap
msgid ""
"@Route(path = \"/people\", produces = ReactiveRoutes.EVENT_STREAM)\n"
"Multi<Person> people(RoutingContext context) {\n"
"    return Multi.createFrom().items(\n"
"            new Person(\"superman\", 1),\n"
"            new Person(\"batman\", 2),\n"
"            new Person(\"spiderman\", 3));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:465
#: upstream/_guides/reactive-routes.adoc:555
#, fuzzy
msgid "This method would produce:"
msgstr "这种方法会产生。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:470
#, no-wrap
msgid ""
"data: {\"name\":\"superman\", \"id\": 1}\n"
"id: 0\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:473
#, no-wrap
msgid ""
"data: {\"name\":\"batman\", \"id\": 2}\n"
"id: 1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:476
#, no-wrap
msgid ""
"data: {\"name\":\"spiderman\", \"id\": 3}\n"
"id: 2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:482
#, fuzzy
msgid "The `produces` attribute is an array.  When you pass a single value you can omit the \"{\" and \"}\".  Note that `\"text/event-stream\"` must be the first value in the array."
msgstr " `produces` 属性是一个数组。当你传递一个单值时，你可以省略\"{\"和\"}\"。注意， `\"text/event-stream\"` 必须是数组中的第一个值。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:484
#, fuzzy
msgid "You can also implement the `io.quarkus.vertx.web.ReactiveRoutes.ServerSentEvent` interface to customize the `event` and `id` section of the server sent event:"
msgstr "你也可以实现 `io.quarkus.vertx.web.ReactiveRoutes.ServerSentEvent` 接口来定制服务器发送事件的 `event` 和 `id` 部分。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:490
#, no-wrap
msgid ""
"class PersonEvent implements ReactiveRoutes.ServerSentEvent<Person> {\n"
"    public String name;\n"
"    public int id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:495
#, no-wrap
msgid ""
"    public PersonEvent(String name, int id) {\n"
"        this.name = name;\n"
"        this.id = id;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:500
#, no-wrap
msgid ""
"    @Override\n"
"    public Person data() {\n"
"        return new Person(name, id); // Will be JSON encoded\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:505
#, no-wrap
msgid ""
"    @Override\n"
"    public long id() {\n"
"        return id;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:511
#, no-wrap
msgid ""
"    @Override\n"
"    public String event() {\n"
"        return \"person\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:514
#, fuzzy
msgid "Using a `Multi<PersonEvent>` would produce:"
msgstr "使用 `Multi<PersonEvent>` ，会产生。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:520
#, no-wrap
msgid ""
"event: person\n"
"data: {\"name\":\"superman\", \"id\": 1}\n"
"id: 1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:524
#, no-wrap
msgid ""
"event: person\n"
"data: {\"name\":\"batman\", \"id\": 2}\n"
"id: 2\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:528
#, no-wrap
msgid ""
"event: person\n"
"data: {\"name\":\"spiderman\", \"id\": 3}\n"
"id: 3\n"
msgstr ""

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:532
#, fuzzy, no-wrap
msgid "Deprecation of `asEventStream`"
msgstr "废弃的 `asEventStream` "

#. type: delimited block =
#: upstream/_guides/reactive-routes.adoc:535
#, fuzzy
msgid "The `ReactiveRoutes.asEventStream` has been deprecated as it is not compatible with the security layer of Quarkus."
msgstr " `ReactiveRoutes.asEventStream` 已经被废弃，因为它与Quarkus的安全层不兼容。"

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:537
#, fuzzy, no-wrap
msgid "Json Stream in NDJSON format"
msgstr "NDJSON格式的Json流"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:541
#, fuzzy
msgid "You can return a `Multi` to produce a newline delimited stream of JSON values.  To enable this feature, set the `produces` attribute of the `@Route` annotation to `\"application/x-ndjson\"` (or `ReactiveRoutes.ND_JSON`):"
msgstr "你可以返回一个 `Multi` ，产生一个以换行符为界的JSON值流。要启用这个功能，将 `@Route` 注释的 `produces` 属性设置为 `\"application/x-ndjson\"` （或 `ReactiveRoutes.ND_JSON` ）。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:552
#, no-wrap
msgid ""
"@Route(path = \"/people\", produces = ReactiveRoutes.ND_JSON)\n"
"Multi<Person> people(RoutingContext context) {\n"
"    return ReactiveRoutes.asJsonStream(Multi.createFrom().items(\n"
"            new Person(\"superman\", 1),\n"
"            new Person(\"batman\", 2),\n"
"            new Person(\"spiderman\", 3)\n"
"            ));\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:561
#, no-wrap
msgid ""
"{\"name\":\"superman\", \"id\": 1}\n"
"{\"name\":\"batman\", \"id\": 2}\n"
"{\"name\":\"spiderman\", \"id\": 3}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:566
#, fuzzy
msgid "The `produces` attribute is an array. When you pass a single value you can omit the \"{\" and \"}\".  Note that `\"application/x-ndjson\"` must be the first value in the array."
msgstr " `produces` 属性是一个数组。当你传递一个单值时，你可以省略\"{\"和\"}\"。注意， `\"application/x-ndjson\"` 必须是数组中的第一个值。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:568
#, fuzzy
msgid "You can also provide strings instead of Objects, in that case the strings will be wrapped in quotes to become valid JSON values:"
msgstr "你也可以提供字符串而不是Objects，在这种情况下，字符串将被包裹在引号中，成为有效的JSON值。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:579
#, no-wrap
msgid ""
"@Route(path = \"/people\", produces = ReactiveRoutes.ND_JSON)\n"
"Multi<Person> people(RoutingContext context) {\n"
"    return ReactiveRoutes.asJsonStream(Multi.createFrom().items(\n"
"            \"superman\",\n"
"            \"batman\",\n"
"            \"spiderman\"\n"
"            ));\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:586
#, no-wrap
msgid ""
"\"superman\"\n"
"\"batman\"\n"
"\"spiderman\"\n"
msgstr ""

#. type: Block title
#: upstream/_guides/reactive-routes.adoc:590
#, fuzzy, no-wrap
msgid "Deprecation of `asJsonStream`"
msgstr "废弃的 `asJsonStream` "

#. type: delimited block =
#: upstream/_guides/reactive-routes.adoc:593
#, fuzzy
msgid "The `ReactiveRoutes.asJsonStream` has been deprecated as it is not compatible with the security layer of Quarkus."
msgstr " `ReactiveRoutes.asJsonStream` 已经被废弃，因为它与Quarkus的安全层不兼容。"

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:595
#, fuzzy, no-wrap
msgid "Using Bean Validation"
msgstr "使用Bean Validation"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:600
#, fuzzy
msgid "You can combine reactive routes and Bean Validation.  First, don't forget to add the `quarkus-hibernate-validator` extension to your project.  Then, you can add constraints to your route parameter (annotated with `@Param` or `@Body`):"
msgstr "你可以结合反应式路由和Bean Validation。首先，别忘了在你的项目中添加 `quarkus-hibernate-validator` 扩展。然后，你可以给你的路由参数添加约束条件（用 `@Param` 或 `@Body` 注解）。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:607
#, no-wrap
msgid ""
"@Route(produces = \"application/json\")\n"
"Person createPerson(@Body @Valid Person person, @NonNull @Param(\"id\") String primaryKey) {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:611
#, fuzzy
msgid "If the parameters do not pass the tests, it returns an HTTP 400 response.  If the request accepts JSON payload, the response follows the https://opensource.zalando.com/problem/constraint-violation/[Problem] format."
msgstr "如果参数没有通过测试，它会返回一个HTTP 400响应。如果请求接受JSON有效载荷，响应遵循 link:https://opensource.zalando.com/problem/constraint-violation/[问题] 格式。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:613
#, fuzzy
msgid "When returning an object or a `Uni`, you can also use the `@Valid` annotation:"
msgstr "当返回一个对象或一个 `Uni` ，你也可以使用 `@Valid` 注解。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:620
#, no-wrap
msgid ""
"@Route(...)\n"
"@Valid Uni<Person> createPerson(@Body @Valid Person person, @NonNull @Param(\"id\") String primaryKey) {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:624
#, fuzzy
msgid "If the item produced by the route does not pass the validation, it returns a HTTP 500 response.  If the request accepts JSON payload, the response follows the https://opensource.zalando.com/problem/constraint-violation/[Problem] format."
msgstr "如果路由产生的项目没有通过验证，它会返回一个HTTP 500响应。如果请求接受JSON有效载荷，响应遵循 link:https://opensource.zalando.com/problem/constraint-violation/[问题] 格式。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:628
#, fuzzy
msgid "Note that only `@Valid` is supported on the return type.  The returned class can use any constraint.  In the case of `Uni`, it checks the item produced asynchronously."
msgstr "注意，在返回类型上只支持 `@Valid` 。返回的类可以使用任何约束条件。在 `Uni` 的情况下，它以异步方式检查产生的项目。"

#. type: Title ==
#: upstream/_guides/reactive-routes.adoc:629
#, fuzzy, no-wrap
msgid "Using the Vert.x Web Router"
msgstr "使用Vert.x网络路由器"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:633
#, fuzzy
msgid "You can also register your route directly on the _HTTP routing layer_ by registering routes directly on the `Router` object.  To retrieve the `Router` instance at startup:"
msgstr "你也可以直接在 _HTTP路由层上_ 注册你的路由，直接在 `Router` 对象上注册路由。要在启动时检索 `Router` 实例。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:639
#, no-wrap
msgid ""
"public void init(@Observes Router router) {\n"
"    router.get(\"/my-route\").handler(rc -> rc.response().end(\"Hello from my route\"));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:642
#, fuzzy
msgid "Check the https://vertx.io/docs/vertx-web/java/#_basic_vert_x_web_concepts[Vert.x Web documentation] to know more about the route registration, options, and available handlers."
msgstr "查看 link:https://vertx.io/docs/vertx-web/java/#_basic_vert_x_web_concepts[Vert.x Web文档] ，了解更多关于路由注册、选项和可用处理程序的信息。"

#. type: delimited block =
#: upstream/_guides/reactive-routes.adoc:648
#, fuzzy
msgid "`Router` access is provided by the `quarkus-vertx-http` extension.  If you use `quarkus-resteasy-reactive` or `quarkus-reactive-routes`, the extension will be added automatically."
msgstr " `Router` 访问是由 扩展提供的。如果你使用 或 ，该扩展将被自动添加。 `quarkus-vertx-http` `quarkus-resteasy-reactive` `quarkus-reactive-routes` "

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:651
#, fuzzy
msgid "You can also receive the Mutiny variant of the Router (`io.vertx.mutiny.ext.web.Router`):"
msgstr "你也可以收到路由器的突变体( `io.vertx.mutiny.ext.web.Router` )。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:657
#, no-wrap
msgid ""
"public void init(@Observes io.vertx.mutiny.ext.web.Router router) {\n"
"    router.get(\"/my-route\").handler(rc -> rc.response().endAndForget(\"Hello from my route\"));\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-routes.adoc:659
#, fuzzy, no-wrap
msgid "Intercepting HTTP requests"
msgstr "拦截HTTP请求"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:663
#, fuzzy
msgid "You can also register filters that would intercept incoming HTTP requests.  Note that these filters are also applied for servlets, JAX-RS resources, and reactive routes."
msgstr "你也可以注册过滤器，以拦截传入的 HTTP 请求。注意，这些过滤器也适用于servlets、JAX-RS资源和反应式路由。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:665
#, fuzzy
msgid "For example, the following code snippet registers a filter adding an HTTP header:"
msgstr "例如，下面的代码片段注册了一个添加HTTP头的过滤器。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:671
#, no-wrap
msgid "import io.vertx.ext.web.RoutingContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:673
#, no-wrap
msgid "public class MyFilters {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:680
#, no-wrap
msgid ""
"    @RouteFilter(100) <1>\n"
"    void myFilter(RoutingContext rc) {\n"
"       rc.response().putHeader(\"X-Header\", \"intercepting the request\");\n"
"       rc.next(); <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:683
#, fuzzy
msgid "The `RouteFilter#value()` defines the priority used to sort the filters - filters with higher priority are called first."
msgstr " `RouteFilter#value()` 定义了用于对过滤器进行排序的优先级--优先级较高的过滤器被首先调用。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:684
#, fuzzy
msgid "The filter is likely required to call the `next()` method to continue the chain."
msgstr "过滤器很可能需要调用 `next()` 方法来继续链。"

#. type: Title ==
#: upstream/_guides/reactive-routes.adoc:685
#, fuzzy, no-wrap
msgid "HTTP Compression"
msgstr "HTTP压缩"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:689
#, fuzzy
msgid "The body of an HTTP response is not compressed by default.  You can enable the HTTP compression support by means of `quarkus.http.enable-compression=true`."
msgstr "默认情况下，HTTP响应的主体是不压缩的。你可以通过 `quarkus.http.enable-compression=true` .NET来启用HTTP压缩支持。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:691
#, fuzzy
msgid "If compression support is enabled then the response body is compressed if:"
msgstr "如果启用了压缩支持，那么响应体将被压缩，如果。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:693
#, fuzzy
msgid "the route method is annotated with `@io.quarkus.vertx.http.Compressed`, or"
msgstr "途径方法被注释为 `@io.quarkus.vertx.http.Compressed` ，或者"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:694
#, fuzzy
msgid "the `Content-Type` header is set and the value is a compressed media type as configured via `quarkus.http.compress-media-types`."
msgstr " `Content-Type` 头被设置，其值是通过 `quarkus.http.compress-media-types` 配置的压缩媒体类型。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:696
#, fuzzy
msgid "The response body is never compressed if:"
msgstr "响应主体永远不会被压缩，如果。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:698
#, fuzzy
msgid "the route method is annotated with `@io.quarkus.vertx.http.Uncompressed`, or"
msgstr "途径方法被注释为 `@io.quarkus.vertx.http.Uncompressed` ，或者"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:699
#, fuzzy
msgid "the `Content-Type` header is not set."
msgstr " `Content-Type` header未被设置。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:701
#, fuzzy
msgid "By default, the following list of media types is compressed: `text/html`, `text/plain`, `text/xml`, `text/css`, `text/javascript` and `application/javascript`."
msgstr "默认情况下，以下媒体类型的列表被压缩。 `text/html` , `text/plain` , `text/xml` , `text/css` , `text/javascript` 和 `application/javascript` 。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:703
#, fuzzy
msgid "If the client does not support HTTP compression then the response body is not compressed."
msgstr "如果客户端不支持HTTP压缩，那么响应体就不会被压缩。"

#. type: Title ==
#: upstream/_guides/reactive-routes.adoc:705
#, fuzzy, no-wrap
msgid "Adding OpenAPI and Swagger UI"
msgstr "添加OpenAPI和Swagger用户界面"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:708
#, fuzzy
msgid "You can add support for link:https://www.openapis.org/[OpenAPI] and link:https://swagger.io/tools/swagger-ui/[Swagger UI] by using the `quarkus-smallrye-openapi` extension."
msgstr "你可以通过使用 `quarkus-smallrye-openapi` 扩展添加对 link:https://www.openapis.org/[OpenAPI] 和 link:https://swagger.io/tools/swagger-ui/[Swagger UI] 的支持。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:710
#, fuzzy
msgid "Add the extension by running this command:"
msgstr "通过运行此命令添加扩展程序。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:715
#, fuzzy
msgid "This will add the following to your build file:"
msgstr "这将在你的构建文件中添加以下内容。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:723
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-openapi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:729
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-smallrye-openapi\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:732
#, fuzzy
msgid "This is enough to generate a basic OpenAPI schema document from your Vert.x Routes:"
msgstr "这足以从你的Vert.x Routes生成一个基本的OpenAPI模式文档。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:736
#, no-wrap
msgid "curl http://localhost:8080/q/openapi\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:739
#, fuzzy
msgid "You will see the generated OpenAPI schema document:"
msgstr "你会看到生成的OpenAPI模式文档。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:742
#: upstream/_guides/reactive-routes.adoc:823
#, no-wrap
msgid "---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:767
#, no-wrap
msgid ""
"openapi: 3.0.3\n"
"info:\n"
"  title: Generated API\n"
"  version: \"1.0\"\n"
"paths:\n"
"  /greetings:\n"
"    get:\n"
"      responses:\n"
"        \"204\":\n"
"          description: No Content\n"
"  /hello:\n"
"    get:\n"
"      responses:\n"
"        \"204\":\n"
"          description: No Content\n"
"  /world:\n"
"    get:\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                type: string\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:770
#, fuzzy
msgid "Also see xref:openapi-swaggerui.adoc[the OpenAPI Guide]."
msgstr "也请参见 link:openapi-swaggerui.html[《OpenAPI指南》] 。"

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:771
#, fuzzy, no-wrap
msgid "Adding MicroProfile OpenAPI Annotations"
msgstr "添加MicroProfile的OpenAPI注释"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:775
#, fuzzy
msgid "You can use link:https://github.com/eclipse/microprofile-open-api[MicroProfile OpenAPI] to better document your schema, example, adding header info, or specifying the return type on `void` methods might be usefull :"
msgstr "你可以使用 link:https://github.com/eclipse/microprofile-open-api[MicroProfile OpenAPI] 来更好地记录你的模式，例如，添加头信息，或指定 `void` 方法的返回类型可能是有用的。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:792
#, no-wrap
msgid ""
"@OpenAPIDefinition( // <1>\n"
"    info = @Info(\n"
"        title=\"Greeting API\",\n"
"        version = \"1.0.1\",\n"
"        contact = @Contact(\n"
"            name = \"Greeting API Support\",\n"
"            url = \"http://exampleurl.com/contact\",\n"
"            email = \"techsupport@example.com\"),\n"
"        license = @License(\n"
"            name = \"Apache 2.0\",\n"
"            url = \"https://www.apache.org/licenses/LICENSE-2.0.html\"))\n"
")\n"
"@ApplicationScoped\n"
"public class MyDeclarativeRoutes {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:801
#, no-wrap
msgid ""
"    // neither path nor regex is set - match a path derived from the method name\n"
"    @Route(methods = Route.HttpMethod.GET)\n"
"    @APIResponse(responseCode=\"200\", \n"
"            description=\"Say hello\", \n"
"            content=@Content(mediaType=\"application/json\", schema=@Schema(type=SchemaType.STRING))) // <2>\n"
"    void hello(RoutingContext rc) {\n"
"        rc.response().end(\"hello\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:806
#, no-wrap
msgid ""
"    @Route(path = \"/world\") \n"
"    String helloWorld() {\n"
"        return \"Hello world!\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:815
#, no-wrap
msgid ""
"    @Route(path = \"/greetings\", methods = HttpMethod.GET)\n"
"    @APIResponse(responseCode=\"200\", \n"
"            description=\"Greeting\", \n"
"            content=@Content(mediaType=\"application/json\", schema=@Schema(type=SchemaType.STRING)))\n"
"    void greetings(RoutingExchange ex) {\n"
"        ex.ok(\"hello \" + ex.getParam(\"name\").orElse(\"world\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:817
#, fuzzy
msgid "Header information about your API."
msgstr "关于你的API的标题信息。"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:818
#, fuzzy
msgid "Defining the response"
msgstr "界定应对措施"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:820
#, fuzzy
msgid "This will generate this OpenAPI schema:"
msgstr "这将生成这个OpenAPI模式。"

#. type: delimited block -
#: upstream/_guides/reactive-routes.adoc:863
#, no-wrap
msgid ""
"openapi: 3.0.3\n"
"info:\n"
"  title: Greeting API\n"
"  contact:\n"
"    name: Greeting API Support\n"
"    url: http://exampleurl.com/contact\n"
"    email: techsupport@example.com\n"
"  license:\n"
"    name: Apache 2.0\n"
"    url: https://www.apache.org/licenses/LICENSE-2.0.html\n"
"  version: 1.0.1\n"
"paths:\n"
"  /greetings:\n"
"    get:\n"
"      responses:\n"
"        \"200\":\n"
"          description: Greeting\n"
"          content:\n"
"            application/json:\n"
"              schema:\n"
"                type: string\n"
"  /hello:\n"
"    get:\n"
"      responses:\n"
"        \"200\":\n"
"          description: Say hello\n"
"          content:\n"
"            application/json:\n"
"              schema:\n"
"                type: string\n"
"  /world:\n"
"    get:\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                type: string\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-routes.adoc:865
#, fuzzy, no-wrap
msgid "Using Swagger UI"
msgstr "使用Swagger UI"

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:869
msgid "Swagger UI is included by default when running in `dev` or `test` mode, and can optionally added to `prod` mode.  See <<openapi-swaggerui.adoc#dev-mode,the Swagger UI>> Guide for more details."
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:871
msgid "Navigate to link:http://localhost:8080/q/swagger-ui/[localhost:8080/q/swagger-ui/] and you will see the Swagger UI screen:"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:873
msgid "image:reactive-routes-guide-screenshot01.png[alt=Swagger UI]"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-routes.adoc:874
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-routes.adoc:877
msgid "This guide has introduced how you can use reactive routes to define an HTTP endpoint.  It also describes the structure of the Quarkus HTTP layer and how to write filters."
msgstr ""
