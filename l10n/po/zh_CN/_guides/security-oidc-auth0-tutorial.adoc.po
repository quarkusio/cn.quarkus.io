# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-09 10:15+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Protect Quarkus web application by using an Auth0 OpenID Connect provider"
msgstr "通过使用OpenID Connect（OIDC）授权代码流来保护一个网络应用程序"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "xref:security-architecture.adoc[Quarkus Security] provides comprehensive OpenId Connect (OIDC) and OAuth2 support with its `quarkus-oidc` extension, supporting both xref:security-oidc-code-flow-authentication.adoc[Authorization code flow] and xref:security-oidc-bearer-token-authentication.adoc[Bearer token] authentication mechanisms."
msgstr "xref:security-architecture.adoc[Quarkus Security] 通过其 `quarkus-oidc` 扩展提供全面的 OpenId Connect (OIDC) 和 OAuth2 支持，同时支持 xref:security-oidc-code-flow-authentication.adoc[授权代码流] 和 xref:security-oidc-bearer-token-authentication.adoc[承载令牌] 认证机制。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "With Quarkus, you can easily configure OIDC providers such as link:https://www.keycloak.org/documentation[Keycloak], link:https://developer.okta.com/[Okta], link:https://auth0.com/docs/[Auth0], and other xref:security-openid-connect-providers.adoc[well-known social OIDC and OAuth2 providers]."
msgstr "使用 Quarkus，你可以轻松配置 OIDC 提供商，如 link:https://www.keycloak.org/documentation[Keycloak] 、 link:https://developer.okta.com/[Okta] 、 link:https://auth0.com/docs/[Auth0] 和其他 xref:security-openid-connect-providers.adoc[知名的社交 OIDC 和 OAuth2 提供商] 。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Learn how to use the Quarkus OpenID Connect extension (`quarkus-oidc`) together with the https://auth0.com/docs/[Auth0] OIDC provider to protect your API endpoints."
msgstr "了解如何将 Quarkus OpenID Connect 扩展 ( `quarkus-oidc` ) 与 link:https://auth0.com/docs/[Auth0] OIDC 提供商结合使用，以保护您的 API 端点。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Review the following documentation before you begin:"
msgstr "在开始之前，请查看以下文件："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "link:https://auth0.com/docs/[Auth0 docs site]"
msgstr "link:https://auth0.com/docs/[Auth0 文档网站]"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "xref:security-oidc-code-flow-authentication.adoc[Quarkus OpenID Connect Authorization code flow mechanism for protecting web applications]"
msgstr "xref:security-oidc-code-flow-authentication.adoc[用于保护网络应用程序的 Quarkus OpenID Connect 授权代码流机制]"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "xref:security-oidc-bearer-token-authentication.adoc[Quarkus OpenID Connect (OIDC) Bearer token authentication]"
msgstr "xref:security-oidc-bearer-token-authentication.adoc[Quarkus OpenID Connect（OIDC）承载令牌验证]"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Create an Auth0 application"
msgstr "创建 Auth0 应用程序"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Go to the Auth0 dashboard and create a regular web application.\n"
"For example, create an Auth0 application called `QuarkusAuth0`."
msgstr "转到 Auth0 面板，创建一个常规网络应用。例如，创建一个名为 `QuarkusAuth0` 的 Auth0 应用程序。"

#. type: Block title
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Result"
msgstr "结果"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Your Auth0 application gets created with a client ID, secret, and HTTPS-based domain.\n"
"Make a note of these properties because you will need them to complete the Quarkus configuration in the next step."
msgstr "你的 Auth0 应用程序创建时会带有客户端 ID、密文和基于 HTTPS 的域。请记下这些属性，因为在下一步完成 Quarkus 配置时会用到它们。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Next, while still in the Auth0 dashboard, add some users to your application."
msgstr "接下来，在 Auth0 控制面板中为应用程序添加一些用户。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Now that you have successfully created and configured your Auth0 application, you are ready to start creating and configuring a Quarkus endpoint.\n"
"In the steps that follow, you will continue to configure and update the Auth0 application as well."
msgstr "现在，你已经成功创建并配置了 Auth0 应用程序，可以开始创建并配置 Quarkus 端点了。在接下来的步骤中，你还将继续配置和更新 Auth0 应用程序。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Create a Quarkus application"
msgstr "创建 Quarkus 应用程序"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Use the following Maven command to create a Quarkus REST (formerly RESTEasy Reactive) application that can be secured with the Quarkus OIDC extension."
msgstr "使用以下 Maven 命令创建可使用 Quarkus OIDC 扩展确保安全的 Quarkus REST（前身为 RESTEasy Reactive）应用程序。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Create the application workspace and import it into your favorite IDE.\n"
"Let's add a Jakarta REST endpoint that can only be accessed by authenticated users:"
msgstr "创建应用程序工作区，并将其导入您最喜欢的集成开发环境。让我们添加一个只能由通过身份验证的用户访问的 Jakarta REST 端点："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"The injected `JsonWebToken` (JWT) bean has an `@IdToken` qualifier, which means it represents not an access token but OIDC `ID token`.\n"
"`IdToken` provides information in the form of claims about the current user authenticated during the OIDC authorization code flow and you can use `JsonWebToken` API to access these claims."
msgstr "注入的 `JsonWebToken` (JWT) Bean 有一个 `@IdToken` 限定符，这意味着它代表的不是访问令牌，而是 OIDC `ID token` 。 `IdToken` ，它以 OIDC 授权代码流中已验证的当前用户的权利要求的形式提供信息，您可以使用 `JsonWebToken` API 访问这些权利要求。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The `io.quarkus.security.Authenticated` annotation is added to the `hello()` method, which means that only authenticated users can access it."
msgstr "`io.quarkus.security.Authenticated` 注解被添加到 `hello()` 方法中，这意味着只有通过身份验证的用户才能访问该方法。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"The access token acquired during the authorization code flow, alongside the ID token, is not used directly by the endpoint but is used only to access downstream services on behalf of the currently authenticated user.\n"
"More to come on the topic of \"access tokens\", later in this tutorial."
msgstr "在授权代码流程中获得的访问令牌与 ID 令牌一样，不会被终端直接使用，而是仅用于代表当前已通过身份验证的用户访问下游服务。有关 \"访问令牌 \"的更多内容，请参见本教程的后续章节。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Configure OIDC in the Quarkus `application.properties` file  by using the properties from the Auth0 application that you created earlier."
msgstr "使用之前创建的 Auth0 应用程序中的属性，在 Quarkus `application.properties` 文件中配置 OIDC。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"In completing this step, you have just configured Quarkus to use the domain, client ID, and secret of your Auth0 application.\n"
"Setting the property `quarkus.oidc.application-type=web-app` instructs Quarkus to use the OIDC authorization code flow, but there are also other methods, which are discussed later on in the tutorial."
msgstr "完成这一步后，你就完成了对 Quarkus 的配置，使其使用 Auth0 应用程序的域、客户端 ID 和密文。设置 `quarkus.oidc.application-type=web-app` 属性可指示 Quarkus 使用 OIDC 授权代码流，但还有其他方法，本教程稍后将讨论。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The endpoint address will be  \\http://localhost:8080/hello, which must also be registered as an allowed callback URL in your Auth0 application."
msgstr "端点地址将是 http://localhost:8080/hello，它还必须在 Auth0 应用程序中注册为允许的回调 URL。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "After completing this step, when you access the Quarkus \\http://localhost:8080/hello endpoint from a browser, Auth0 redirects you back to the same address after the authentication is completed."
msgstr "完成这一步后，当你从浏览器访问 Quarkus http://localhost:8080/hello 端点时，Auth0 会在验证完成后将你重定向回相同的地址。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"By default, Quarkus automatically uses the current request path as the callback path.\n"
"But you can override the default behavior and configure a specific callback path by setting the Quarkus `quarkus.oidc.authentication.redirect-path` property."
msgstr "默认情况下，Quarkus 会自动使用当前请求路径作为回调路径。但你可以通过设置 Quarkus `quarkus.oidc.authentication.redirect-path` 属性，覆盖默认行为并配置特定的回调路径。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"In production, your application will most likely have a larger URL space, with multiple endpoint addresses available.\n"
"In such cases, you can set a dedicated callback (redirect) path and register this URL in the provider's dashboard, as outlined in the following configuration example:"
msgstr "在生产过程中，您的应用程序很可能有更大的 URL 空间，并有多个端点地址可用。在这种情况下，您可以设置一个专用的回调（重定向）路径，并在提供商的仪表板中注册此 URL，如下配置示例所示："

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "`quarkus.oidc.authentication.redirect-path=/authenticated-welcome`"
msgstr "`quarkus.oidc.authentication.redirect-path=/authenticated-welcome`"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"In the example scenario, Quarkus calls `/authenticated-welcome` after accepting a redirect from Auth0, completing the authorization code flow,  and creating the session cookie.\n"
"Successfully authenticated users are also allowed to access other parts of the secured application space, without needing to authenticate again. For example, the endpoint callback method can use a JAX-RS API to redirect users to other parts of the secured application where a session cookie will be verified."
msgstr "在示例场景中，Quarkus 在接受来自 Auth0 的重定向、完成授权代码流程并创建会话 cookie 之后，会调用 `/authenticated-welcome` 。成功通过身份验证的用户还可以访问安全应用空间的其他部分，而无需再次进行身份验证。例如，端点回调方法可以使用 JAX-RS API 将用户重定向到安全应用程序的其他部分，并在那里验证会话 Cookie。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now you are ready to start testing the endpoint."
msgstr "现在，您可以开始测试端点了。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Test the Quarkus endpoint"
msgstr "测试 Quarkus 端点"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Start Quarkus in dev mode:"
msgstr "以开发模式启动 Quarkus："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"This is the only time during this tutorial when you are expected to manually start Quarkus in dev mode.\n"
"The configuration and code update steps in the remaining sections of this tutorial are automatically observed and processed by Quarkus without you needing to restart the application manually."
msgstr "这是本教程中唯一需要你在开发模式下手动启动 Quarkus 的时候。本教程其余章节中的配置和代码更新步骤将由 Quarkus 自动观察和处理，无需手动重启应用程序。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Open the browser and access http://localhost:8080/hello."
msgstr "打开浏览器，访问 http://localhost:8080/hello 。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "You will be redirected to Auth0 and prompted to log in:"
msgstr "您将被重定向到 Auth0 并被提示登录："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "and authorize the `QuarkusAuth0` application to access your account:"
msgstr "并授权 `QuarkusAuth0` 应用程序访问您的账户："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Finally, you will be redirected back to the Quarkus endpoint which will return the following response:\n"
"`Hello, auth0|60e5a305e8da5a006aef5471`"
msgstr "最后，你将被重定向到 Quarkus 端点，它将返回以下响应： `Hello, auth0|60e5a305e8da5a006aef5471`"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Notice that the current username does not get returned.\n"
"To learn more about why this behavior occurs, you can use OIDC Dev UI as explained in the xref:security-openid-connect-dev-services.adoc#dev-ui-all-oidc-providers[Dev UI for all OpenID Connect Providers] section of the \"Dev Services and UI for OpenID Connect (OIDC)\" guide and the following section."
msgstr "请注意，当前用户名不会返回。要进一步了解出现这种行为的原因，可以使用 OIDC Dev UI，详见 \"Dev Services and UI for OpenID Connect (OIDC) \"指南中的 \"Dev xref:security-openid-connect-dev-services.adoc#dev-ui-all-oidc-providers[UI] for xref:security-openid-connect-dev-services.adoc#dev-ui-all-oidc-providers[all] OpenID Connect xref:security-openid-connect-dev-services.adoc#dev-ui-all-oidc-providers[Providers] \"部分和以下部分。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Looking at Auth0 tokens in the OIDC Dev UI"
msgstr "在 OIDC Dev UI 中查看 Auth0 令牌"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Quarkus provides a great xref:dev-ui.adoc[Dev UI] experience.\n"
"Specifically, Quarkus offers built-in support for developing and testing OIDC endpoints with a Keycloak container.\n"
"xref:security-openid-connect-dev-services.adoc#dev-services-for-keycloak[DevService for Keycloak] is automatically started and used if the address of the OIDC provider is not specified for the Quarkus `quarkus.oidc.auth-server-url` configuration property."
msgstr "Quarkus 提供了出色的 xref:dev-ui.adoc[开发人员用户界面] 体验。具体来说，Quarkus 内置支持使用 Keycloak 容器开发和测试 OIDC 端点。如果没有为 Quarkus `quarkus.oidc.auth-server-url` 配置属性指定 OIDC 提供商的地址，则会自动启动和使用 xref:security-openid-connect-dev-services.adoc#dev-services-for-keycloak[Keycloak 的 DevService] 。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"You can continue using the Quarkus OIDC Dev UI when the provider is already configured.\n"
"Use the following instructions to update your configuration:"
msgstr "如果已经配置了提供程序，您可以继续使用 Quarkus OIDC Dev UI。使用以下说明更新配置："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "First, change your Quarkus application type from `web-app` to `hybrid`, as follows:"
msgstr "首先，将 Quarkus 应用程序类型从 `web-app` 更改为 `hybrid` ，如下所示："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Application type is changed to `hybrid` because OIDC Dev UI currently supports `SPA` (single-page application) mode only.\n"
"OIDC Dev UI single-page application, using its own Java Script, authenticates users to the OIDC provider and uses the access token as a Bearer token to access the Quarkus endpoint as a service."
msgstr "应用程序类型更改为 `hybrid` ，因为 OIDC Dev UI 目前仅支持 `SPA` （单页面应用程序）模式。OIDC Dev UI 单页面应用程序使用自己的 Java 脚本向 OIDC 提供商验证用户身份，并使用访问令牌作为承载令牌访问作为服务的 Quarkus 端点。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Typically, Quarkus must be configured with `quarkus.oidc.application-type=service` to support `Bearer` token authentication, but it also supports a `hybrid` application type, which means it can support both the authorization code and bearer token flows at the same time."
msgstr "通常，Quarkus 必须配置 `quarkus.oidc.application-type=service` 才能支持 `Bearer` 令牌验证，但它也支持 `hybrid` 应用类型，这意味着它可以同时支持授权码和承载令牌流。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"You also need to configure the Auth0 application to allow the callbacks to the OIDC Dev UI.\n"
"Use the following URL format:"
msgstr "您还需要配置 Auth0 应用程序，以允许回调到 OIDC Dev UI。使用以下 URL 格式："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "`http://localhost:8080/q/dev-ui/io.quarkus.quarkus-oidc/${provider-name}-provider`"
msgstr "`http://localhost:8080/q/dev-ui/io.quarkus.quarkus-oidc/${provider-name}-provider`"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Where in this example, the `${provider-name}` is `auth0`"
msgstr "在这个例子中， `${provider-name}` `auth0`"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now you are ready to use OIDC Dev UI with Auth0."
msgstr "现在，您可以使用 Auth0 使用 OIDC Dev UI 了。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Open http://localhost:8080/q/dev/ in a browser session. An OpenId Connect card that links to an Auth0 provider SPA displays, as follows:"
msgstr "在浏览器会话中打开 http://localhost:8080/q/dev/ 。会显示一个链接到 Auth0 提供商 SPA 的 OpenId Connect 卡，如下所示："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Click *Auth0 provider* followed by *Login into Single Page Application*:"
msgstr "*单击* *Auth0 提供商* ，然后 *单击登录到单页应用程序* ："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"You will be redirected to Auth0 to log in.\n"
"You will then be redirected to the OIDC Dev UI dashboard, as follows:"
msgstr "您将被重定向到 Auth0 进行登录。然后，您将被重定向到 OIDC Dev UI 面板，如下所示："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Here, you can look at both ID and access tokens in the encoded and decoded formats, copy them to the clipboard or use them to test the service endpoint. We will test the endpoint later but for now let's check the ID token:"
msgstr "在这里，您可以查看编码和解码格式的 ID 和访问令牌，将其复制到剪贴板或用于测试服务端点。我们稍后将测试端点，但现在先检查 ID 令牌："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "As you can see it does not have any claim representing a user name but if you check its `sub` (subject) claim you will see its value matches what you got in the response when you accessed the Quarkus endpoint directly from the browser, `auth0|60e5a305e8da5a006aef5471`."
msgstr "正如你所看到的，它没有任何代表用户名的声明，但如果你检查它的 `sub` （主题）声明，就会发现它的值与你从浏览器直接访问 Quarkus 端点时在响应中得到的值相符， `auth0|60e5a305e8da5a006aef5471` 。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Fix it by configuring Quarkus to request a standard OIDC `profile` scope during the authentication process which should result in the ID token including more information:"
msgstr "通过配置 Quarkus，使其在身份验证过程中请求标准 OIDC `profile` 范围来解决这个问题，这样 ID 标记就会包含更多信息："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Request `profile` scope in addition to the default `openid` scope."
msgstr "除了默认的 `openid` 作用域外，还请求 `profile` 作用域。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Go back to http://localhost:8080/q/dev/, repeat the process of logging in to `Auth0` and check the ID token again, now you should see the ID token containing the `name` claim:"
msgstr "返回 link:http://localhost:8080/q/dev/[http://localhost:8080/q/dev/，] 重复登录 `Auth0` 的过程，再次检查 ID 令牌，现在应该可以看到包含 `name` 申请的 ID 令牌了："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "You should get the name when you access the Quarkus endpoint directly from the browser. Clear the browser cookie cache, access http://localhost:8080/hello and yet again, you get `Hello, auth0|60e5a305e8da5a006aef5471` returned. Hmm, what is wrong ?"
msgstr "从浏览器直接访问 Quarkus 端点时，应该会得到该名称。清除浏览器 cookie 缓存，访问 http://localhost:8080/hello ，结果还是 `Hello, auth0|60e5a305e8da5a006aef5471` 。嗯，出什么问题了？"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The answer lies with the specifics of the `org.eclipse.microprofile.jwt.JsonWebToken#getName()` implementation, which, according to the https://github.com/eclipse/microprofile-jwt-auth[MicroProfile MP JWT RBAC  specification], checks an MP JWT specific `upn` claim, trying `preferred_username` next and finally `sub` which explains why you get the `Hello, auth0|60e5a305e8da5a006aef5471` answer even with the ID token containing the `name` claim. We can fix it easily by changing the endpoint `hello()` method's implementation to return a specific claim value:"
msgstr "答案就在 `org.eclipse.microprofile.jwt.JsonWebToken#getName()` 实现的具体细节上，根据 link:https://github.com/eclipse/microprofile-jwt-auth[MicroProfile MP JWT RBAC 规范] ，它会检查特定于 MP JWT 的 `upn` 索赔，然后尝试 `preferred_username` ，最后是 `sub` ，这就解释了为什么即使包含 `name` 索赔的 ID 标记也会得到 `Hello, auth0|60e5a305e8da5a006aef5471` 的答案。我们可以通过更改端点 `hello()` 方法的实现来返回特定的权利要求值，从而轻松解决这个问题："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now clear the browser cache, access http://localhost:8080/hello and finally the user name is returned."
msgstr "现在清除浏览器缓存，访问 http://localhost:8080/hello ，最后返回用户名。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Logout support"
msgstr "注销支持"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now that you have the users signing in to Quarkus with the help of Auth0, you probably want to support a user-initiated logout. Quarkus supports https://quarkus.io/guides/security-oidc-code-flow-authentication#logout-and-expiration[RP-initiated and other standard OIDC logout mechanisms, as well as the local session logout]."
msgstr "既然用户已经在 Auth0 的帮助下登录了 Quarkus，那么你可能希望支持由用户发起的注销。Quarkus 支持 link:https://quarkus.io/guides/security-oidc-code-flow-authentication#logout-and-expiration[RP 启动和其他标准 OIDC 注销机制，以及本地会话] 注销。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Currently, Auth0 does not support the standard OIDC RP-initiated logout and does not provide an end session endpoint URL in its discoverable metadata, but it provides its own logout mechanism which works nearly exactly the same as the standard one."
msgstr "目前，Auth0 不支持标准的 OIDC RP 启动注销，也不在其可发现元数据中提供结束会话端点 URL，但它提供了自己的注销机制，其工作原理与标准机制几乎完全相同。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "It is easy to support it with Quarkus OIDC. You must configure an Auth0 end session endpoint URL and have Quarkus include both the `client-id` query parameter and the post logout URL as the `returnTo` query parameter in the RP-initated logout redirect request to Auth0:"
msgstr "使用 Quarkus OIDC 很容易实现。您必须配置 Auth0 结束会话端点 URL，并让 Quarkus 在 RP-initated 注销重定向请求中将 `client-id` 查询参数和注销后 URL 作为 `returnTo` 查询参数包含到 Auth0 中："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Auth0 does not include the end session URL in its metadata, so complement it with manually configuring the Auth0 end session endpoint URL."
msgstr "Auth0 的元数据中不包含结束会话 URL，因此需要手动配置 Auth0 结束会话端点 URL 作为补充。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Auth0 will not recognize a standard `post_logout_redirect_uri` query parameter and expects a parameter `returnTo` instead."
msgstr "Auth0 无法识别标准 `post_logout_redirect_uri` 查询参数，而是希望使用 `returnTo` 参数。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Auth0 expects `client-id` in the logout request."
msgstr "Auth0 希望在注销请求中使用 `client-id` 。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Authenticated requests to `/logout` path will be treated as RP-inititated logout requests."
msgstr "`/logout` 路径的验证请求将被视为 RP 触发的注销请求。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "This is a public resource to where the logged out user should be returned to."
msgstr "这是已注销用户应返回的公共资源。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Make sure the `/logout` path is protected."
msgstr "确保 `/logout` 路径受到保护。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Here we have customized the Auth0 end session endpoint URL and indicated to Quarkus that an `http://localhost:8080/logout` request must trigger a logout of the currently authenticated user. An interesting thing about the `/logout` path is that it is `virtual`, it is not supported by any method in the JAX-RS endpoint, so for Quarkus OIDC to be able to react to `/logout` requests we attach an `authenticated` https://quarkus.io/guides/security-authorize-web-endpoints-reference#authorization-using-configuration[HTTP security policy] to this path directly in the configuration."
msgstr "在这里，我们定制了 Auth0 结束会话端点 URL，并向 Quarkus 指出，一个 `http://localhost:8080/logout` 请求必须触发当前已验证用户的注销。 `/logout` 路径的一个有趣之处在于它是 `virtual` ，JAX-RS 端点中的任何方法都不支持它，因此为了让 Quarkus OIDC 能够对 `/logout` 请求做出反应，我们在配置中直接为该路径附加了 `authenticated` link:https://quarkus.io/guides/security-authorize-web-endpoints-reference#authorization-using-configuration[HTTP 安全策略] 。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "We also have configured Quarkus to return the logged out user to the public `/hello/post-logout` resource, and this path is included in the logout request as the Auth0 specific `returnTo` query parameter. Finally, the Quarkus application's `client-id` is included in the logout URL as well."
msgstr "我们还将 Quarkus 配置为将注销用户返回到公共 `/hello/post-logout` 资源，并将此路径作为 Auth0 特定的 `returnTo` 查询参数包含在注销请求中。最后，Quarkus 应用程序的 `client-id` 也包含在注销 URL 中。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Update the endpoint to accept the post logout redirects:"
msgstr "更新端点以接受注销后重定向："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Note the addition of the public `/hello/post-logout` resource method."
msgstr "注意添加了公共 `/hello/post-logout` 资源方法。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Before we test the logout, make sure the `Auth0` application is configured to allow this post logout redirect back to Quarkus after the user has been logged out:"
msgstr "在测试注销之前，请确保 `Auth0` 应用程序已配置为允许注销后重定向到 Quarkus："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now, clear the browser cookie cache, access http://localhost:8080/hello, login to Quarkus with Auth0, get the user name returned, and go to `http://localhost:8080/logout`. You'll see the `You were logged out` message displayed in the browser."
msgstr "现在，清除浏览器 cookie 缓存，访问 link:http://localhost:8080/hello[http://localhost:8080/hello，] 使用 Auth0 登录 Quarkus，获取返回的用户名，然后转到 `http://localhost:8080/logout` .您将看到浏览器中显示的 `You were logged out` 消息。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Next, go to the http://localhost:8080/q/dev/, login to Auth0 from the Dev UI SPA and notice you can now logout from the OIDC Dev UI too, see the symbol representing the logout next to the `Logged in as Sergey Beryozkin` text:"
msgstr "接下来，访问 link:http://localhost:8080/q/dev/[http://localhost:8080/q/dev/，] 从 Dev UI SPA 登录 Auth0，注意现在也可以从 OIDC Dev UI 注销了，请看 `Logged in as Sergey Beryozkin` 文本旁边代表注销的符号："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "For the logout to work from OIDC DevUI, the Auth0 application's list of allowed logout callbacks has to be updated to include the OIDC DevUI endpoint:"
msgstr "若要从 OIDC DevUI 注销，必须更新 Auth0 应用程序的允许注销回调列表，以包含 OIDC DevUI 端点："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now logout directly from OIDC Dev UI and login as a new user - add more users to the registered Auth0 application if required."
msgstr "现在直接从 OIDC Dev UI 注销，然后以新用户身份登录--如有需要，可在已注册的 Auth0 应用程序中添加更多用户。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Role-based access control"
msgstr "基于角色的访问控制"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "We have confirmed that the Quarkus endpoint can be accessed by users who have authenticated with the help of `Auth0`."
msgstr "我们已经确认，通过 `Auth0` 验证的用户可以访问 Quarkus 端点。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The next step is to introduce role-based access control (RBAC) to have users in a specific role only, such as `admin`, be able to access the endpoint."
msgstr "下一步是引入基于角色的访问控制（RBAC），让只有特定角色（如 `admin` ）的用户才能访问端点。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "See also the <<permission-based-access-control>> section below."
msgstr "另请参阅下文 <<permission-based-access-control>> 部分。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Auth0 tokens do not include any claims containing roles by default, so, first, you must customize the `Login` flow of the `Auth0` application with a custom action which will add the roles to tokens. Select `Actions/Flows/Login` in the `Auth0` dashboard, choose `Add Action/Build Custom`, name it as `AddRoleClaim`:"
msgstr "Auth0 令牌默认情况下不包含任何包含角色的声明，因此，首先必须自定义 `Auth0` 应用程序的 `Login` 流程，使用自定义操作将角色添加到令牌中。在 `Auth0` 面板中选择 `Actions/Flows/Login` ，选择 `Add Action/Build Custom` ，将其命名为 `AddRoleClaim` ："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Add the following action script to it:"
msgstr "添加以下操作脚本："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Note a custom Auth0 claim has to be namespace qualified, so the claim which will contain roles will be named as \"https://quarkus-security.com/roles\". Have a look at the ID token content we analyzed in the previous sections and you will see how this claim is represented, for example:"
msgstr "请注意，自定义 Auth0 声明必须使用名称空间限定，因此包含角色的声明将命名为 \"https://quarkus-security.com/roles\"。例如，请看一下我们在前面章节中分析的 ID 标记内容，你就会知道这种权利要求是如何表示的："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The `Auth0` Login Flow diagram should look like this now:"
msgstr "`Auth0` 登录流程图现在应该是这样的："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "You must add a role such as `admin` to the users registered in the `Auth0` application."
msgstr "您必须为 `Auth0` 应用程序中注册的用户添加 `admin` 等角色。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Create an `admin` role:"
msgstr "创建 `admin` 角色："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "and add it to the registered user:"
msgstr "并将其添加到注册用户中："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Next, update the Quarkus endpoint to require that only users with the `admin` role can access the endpoint:"
msgstr "接下来，更新 Quarkus 端点，要求只有 `admin` 角色的用户才能访问该端点："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Open http://localhost:8080/hello, authenticate to Auth0 and get `403`. The reason you get `403` is because Quarkus OIDC does not know which claim in the `Auth0` tokens represents the roles information, by default a `groups` claim is checked, while Auth0 tokens are now expected to have an \"https://quarkus-security.com/roles\" claim."
msgstr "打开 link:http://localhost:8080/hello[http://localhost:8080/hello，] 对 Auth0 link:http://localhost:8080/hello[进行] 身份验证，然后得到 `403` 。之所以会得到 `403` ，是因为 Quarkus OIDC 不知道 `Auth0` 标记中的哪个声称代表角色信息，默认情况下会检查 `groups` 声称，而 Auth0 标记现在预计会有 \"https://quarkus-security.com/roles \"声称。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Fix it by telling Quarkus OIDC which claim must be checked to enforce RBAC:"
msgstr "通过告诉 Quarkus OIDC 必须检查哪些声明才能执行 RBAC 来解决这个问题："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Point to the custom roles claim. The path to the roles claim is in double quotes because the claim is namespace qualified."
msgstr "指向自定义角色声明。角色要求的路径使用双引号，因为该要求是名称空间限定的。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now, clear the browser cookie cache, access http://localhost:8080/hello again, authenticate to Auth0 and get an expected user name."
msgstr "现在，清除浏览器 cookie 缓存，再次访问 http://localhost:8080/hello ，验证 Auth0 并获取预期用户名。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Access Quarkus with opaque Auth0 access tokens"
msgstr "使用不透明 Auth0 访问令牌访问 Quarkus"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The main goal of this section is to explain how Quarkus can be tuned to accept `opaque` bearer Auth0 access tokens as opposed to Auth0 JWT access tokens because Auth0 access tokens issued during the authorization code flow are opaque by default and they can only be used to request `UserInfo` in addition to the information about the current user which is already available in ID token. Learning how to verify opaque tokens can be useful because many OIDC and OAuth2 providers will issue opaque access tokens only."
msgstr "本节的主要目的是解释如何调整 Quarkus，使其接受 `opaque` bearer Auth0 访问令牌，而不是 Auth0 JWT 访问令牌，因为在授权代码流程中签发的 Auth0 访问令牌默认情况下是不透明的，而且除了 ID 令牌中已有的当前用户信息外，它们只能用于请求 `UserInfo` 。学习如何验证不透明令牌非常有用，因为许多 OIDC 和 OAuth2 提供商只会签发不透明访问令牌。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "For more information on how to configure Auth0 and Quarkus to have authorization code access tokens issued in the JWT format and propagated to service endpoints, see the following <<token-propagation>> and <<jwt-access-tokens>> sections."
msgstr "有关如何配置 Auth0 和 Quarkus 以获得以 JWT 格式发布并传播到服务端点的授权码访问令牌的更多信息，请参阅以下 <<token-propagation>> 和 <<jwt-access-tokens>> 部分。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "So far we have only tested the Quarkus endpoint using OIDC authorization code flow. In this flow you use the browser to access the Quarkus endpoint, Quarkus itself manages the authorization code flow, a user is redirected to Auth0, logs in, is redirected back to Quarkus, Quarkus completes the flow by exchanging the code for the ID, access, and refresh tokens, and works with the ID token representing the successful user authentication. The access token is not relevant at the moment. As mentioned earlier, in the authorization code flow, Quarkus will only use the access token to access downstream services on behalf of the currently authenticated user."
msgstr "到目前为止，我们只使用 OIDC 授权代码流测试了 Quarkus 端点。在这个流程中，你使用浏览器访问 Quarkus 端点，Quarkus 本身管理授权代码流，用户被重定向到 Auth0，登录，重定向回 Quarkus，Quarkus 通过交换 ID、访问和刷新令牌代码完成流程，并使用代表成功用户验证的 ID 令牌工作。访问令牌目前与此无关。如前所述，在授权代码流程中，Quarkus 将仅使用访问令牌来代表当前通过身份验证的用户访问下游服务。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Let's imagine though that the Quarkus endpoint we have developed has to accept `Bearer` access tokens too: it may be that the other Quarkus endpoint which is propagating it to this endpoint or it can be SPA which uses the access token to access the Quarkus endpoint. And Quarkus OIDC DevUI SPA which we already used to analyze the ID token fits perfectly for using the access token available to SPA to test the Quarkus endpoint."
msgstr "让我们设想一下，我们开发的 Quarkus 端点也必须接受 `Bearer` 访问令牌：可能是其他 Quarkus 端点将访问令牌传播到这个端点，也可能是 SPA 使用访问令牌访问 Quarkus 端点。而我们已经用来分析 ID 令牌的 Quarkus OIDC DevUI SPA 完全适合使用 SPA 可用的访问令牌来测试 Quarkus 端点。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Let's go again to http://localhost:8080/q/dev-ui, select the `OpenId Connect` card, login to Auth0, and check the Access token content:"
msgstr "让我们再次访问 link:http://localhost:8080/q/dev-ui[http://localhost:8080/q/dev-ui，] 选择 `OpenId Connect` 卡，登录 Auth0，检查访问令牌内容："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "This access token, as opposed to the ID token we looked at earlier, cannot be verified by Quarkus directly. This is because the access token is in `JWE` (encrypted) as opposed to `JWS` (signed) format. You can see from the decoded token headers that it has been encrypted directly with a secret key known to Auth0 only, and therefore its content cannot be decrypted by Quarkus. From the Quarkus's perspective this access token is an `opaque` one, Quarkus cannot use public Auth0 asymmetric verification keys to verify it."
msgstr "该访问令牌与我们前面提到的 ID 令牌不同，不能直接由 Quarkus 验证。这是因为访问令牌是 `JWE` （加密）格式，而不是 `JWS` （签名）格式。从解码后的令牌标头可以看出，它是直接用只有 Auth0 知道的秘钥加密的，因此 Quarkus 无法解密其内容。从 Quarkus 的角度来看，这个访问令牌是 `opaque` ，Quarkus 无法使用 Auth0 的公开非对称验证密钥来验证它。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "To confirm it, enter `/hello` as the `Service Address` in the `Test Service` area and press `With Access Token` and you will get the HTTP `401` status:"
msgstr "要确认它，请在 `Test Service` 区域输入 `/hello` 作为 `Service Address` ，然后按 `With Access Token` ，就会得到 HTTP `401` 状态："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"For Quarkus be able to accept such access tokens, one of the two options should be available.\n"
"The first option is to introspect the opaque token remotely using a provider's introspection endpoint. Token introspection is typically supported at the `OAuth2` level, and since `OIDC` is built on top of `OAuth2`, some OIDC providers such as Keycloak support the token introspection as well. However, Auth0 does not support the token introspection, you can check it by looking at the publicly available Auth0 metadata, add `/.well-known/openid-configuration` to the address of your configured Auth0 provider, and open the resulting URL, `https://dev-3ve0cgn7.us.auth0.com/.well-known/openid-configuration`. You will see that Auth0 does not have an introspection endpoint:"
msgstr "要让 Quarkus 能够接受这种访问令牌，应该有两种选择。第一个选项是使用提供者的反省端点远程反省不透明令牌。 `OAuth2` 通常支持令牌自省，由于 `OIDC` 是在 `OAuth2` 的基础上构建的，因此一些 OIDC 提供商（如 Keycloak）也支持令牌自省。不过，Auth0 不支持令牌内省，你可以查看公开的 Auth0 元数据，在配置的 Auth0 提供商地址中添加 `/.well-known/openid-configuration` ，然后打开生成的 URL、 `https://dev-3ve0cgn7.us.auth0.com/.well-known/openid-configuration` .你会发现 Auth0 没有反省端点："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Therefore the other option, indirect access token verification, where the access token is used to acquire `UserInfo` from Auth0 can be used to accept and verify opaque Auth0 tokens. This option works because OIDC providers have to verify access tokens before they can issue `UserInfo` and Auth0 has a `UserInfo` endpoint."
msgstr "因此，另一种方案--间接访问令牌验证，即使用访问令牌从 Auth0 获取 `UserInfo` ，可用于接受和验证不透明 Auth0 令牌。该方案之所以可行，是因为 OIDC 提供商必须先验证访问令牌，然后才能发布 `UserInfo` ，而 Auth0 有一个 `UserInfo` 端点。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "So lets configure Quarkus to request that the access tokens must be verified by using them to acquire `UserInfo`:"
msgstr "因此，让我们配置 Quarkus，要求必须通过使用访问令牌获取 `UserInfo` 来验证访问令牌："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Verify access tokens indirectly by using them to request `UserInfo`."
msgstr "通过使用访问令牌请求 `UserInfo` ，间接验证访问令牌。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Update the endpoint code to expect `UserInfo` as opposed to `ID token`:"
msgstr "更新端点代码，将 `UserInfo` 改为 `ID token` ："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "This code will now work both for the authorization code and bearer access token flows."
msgstr "现在，该代码可同时用于授权码和承载访问令牌流。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Let's go to the OIDC Dev UI where we looked at the access token, enter `/hello` as the `Service Address` in the `Test Service` area and press `With Access Token` and you will get `200`:"
msgstr "让我们进入 OIDC Dev UI，在这里我们查看了访问令牌，在 `Test Service` 区域输入 `/hello` 作为 `Service Address` ，然后按 `With Access Token` ，就会得到 `200` ："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "To confirm that it really does work, update the test endpoint to allow a `user` role only with `@RolesAllowed(\"user\")`. Try to access the endpoint from OIDC Dev UI again, and you will get the HTTP `403` error. Revert the code back to `@RolesAllowed(\"admin\")` to get the reassuring HTTP `200` status again."
msgstr "要确认它确实有效，请更新测试端点，使其只允许 `user` 角色访问 `@RolesAllowed(\"user\")` 。再次尝试从 OIDC Dev UI 访问端点，您将收到 HTTP `403` 错误。将代码还原为 `@RolesAllowed(\"admin\")` ，即可再次获得令人放心的 HTTP `200` 状态。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "When verifying the opaque access token indirectly, by using it to request `UserInfo`, Quarkus will use `UserInfo` as the source of the roles information, if any. As it happens, Auth0 includes the custom role claim which was created earlier in the `UserInfo` response as well."
msgstr "通过使用不透明访问令牌请求 `UserInfo` 来间接验证不透明访问令牌时，Quarkus 将使用 `UserInfo` 作为角色信息（如果有的话）的来源。因此，Auth0 也会在 `UserInfo` 响应中包含之前创建的自定义角色声明。"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "As has already been mentioned in the introduction to this section, the main goal of this section is to explain how Quarkus can verify opaque access tokens. In general, propagating access tokens whose only purpose is to allow retrieving `UserInfo` to services should be avoided unless the front-end JAX-RS endpoint or SPA prefers to delegate UserInfo retrieval to the trusted service."
msgstr "正如本节导言中提到的，本节的主要目的是解释 Quarkus 如何验证不透明的访问令牌。一般来说，除非前端 JAX-RS 端点或 SPA 希望将用户信息检索委托给受信任的服务，否则应避免向服务传播访问令牌（其唯一目的是允许检索 `UserInfo` ）。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "For a recommended approach of working with Auth0 access tokens, see the following <<token-propagation>> and <<jwt-access-tokens>> sections."
msgstr "有关使用 Auth0 访问令牌的推荐方法，请参阅以下 <<token-propagation>> 和 <<jwt-access-tokens>> 部分。"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Typically one uses access tokens to access remote services but OIDC DevUI SPA dashboard also offers an option to test with the ID token. This option is only available to emulate the cases where SPA delegates to the endpoint to verify and retrieve some information from the ID token for SPA to use - but ID token will still be sent to the endpoint as Bearer token by OIDC DevUI. Prefer testing with the access token in most cases."
msgstr "通常，人们使用访问令牌访问远程服务，但 OIDC DevUI SPA 面板也提供了使用 ID 令牌进行测试的选项。该选项仅适用于模拟 SPA 委托端点验证并从 ID 令牌中检索某些信息供 SPA 使用的情况，但 OIDC DevUI 仍会将 ID 令牌作为承载令牌发送到端点。在大多数情况下，最好使用访问令牌进行测试。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"You can use SwaggerUI or GraphQL from OIDC DevUI for testing the service, instead of manually entering the service path to test.\n"
"For example, if you add"
msgstr "您可以使用 SwaggerUI 或 OIDC DevUI 中的 GraphQL 测试服务，而不必手动输入服务路径进行测试。例如，如果添加"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "to your application's pom then you will see a Swagger link in OIDC Dev UI:"
msgstr "到应用程序的 pom 中，然后您就可以在 OIDC Dev UI 中看到 Swagger 链接："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Click the Swagger link and start testing the service."
msgstr "点击 Swagger 链接，开始测试服务。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Propagate access tokens to microservices"
msgstr "向微服务传播访问令牌"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now that we have managed to use OIDC authorization code flow and used both ID token and UserInfo to access the user information, the next typical task is to propagate the current Auth0 access token to access the downstream service on behalf of the currently authenticated user."
msgstr "既然我们已经成功使用了 OIDC 授权代码流，并使用 ID 令牌和 UserInfo 来访问用户信息，下一个典型任务就是传播当前的 Auth0 访问令牌，以代表当前已通过身份验证的用户访问下游服务。"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "In fact, the last code example, showing the injected `UserInfo`, is a concrete example of the access token propagation, in this case, Quarkus propagates the Auth0 access token to the Auth0 `UserInfo` endpoint to acquire `UserInfo`. Quarkus does it without users having to do anything themselves."
msgstr "事实上，最后一个代码示例显示了注入的 `UserInfo` ，是访问令牌传播的一个具体例子，在这种情况下，Quarkus 将 Auth0 访问令牌传播到 Auth0 `UserInfo` 端点，以获取 `UserInfo` 。Quarkus 不需要用户自己做任何事情。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "But what about propagating access tokens to some custom services ? It is very easy to achieve in Quarkus, both for the authorization code and bearer token flows. All you need to do is to create a REST Client interface for calling the service requiring a Bearer token access and annotate it with `@AccessToken` and the access token arriving to the front-end endpoint as the Auth0 Bearer access token or acquired by Quarkus after completing the Auth0 authorization code flow, will be propagated to the target microservice. This is as easy as it can get."
msgstr "但如何将访问令牌传播到一些自定义服务呢？这在 Quarkus 中很容易实现，包括授权代码和承载令牌流。您只需创建一个 REST 客户端接口，用于调用需要无记名访问令牌的服务，并用 `@AccessToken` 进行注释，然后访问令牌就会作为 Auth0 无记名访问令牌到达前端端点，或在完成 Auth0 授权代码流程后由 Quarkus 获取，并传播到目标微服务。这是最简单不过的了。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"For examples of propagating access tokens, see the following sections in this tutorial.\n"
"For more information about token propagation, see xref:security-openid-connect-client-reference.adoc#reactive-token-propagation[OIDC token propagation]."
msgstr "有关传播访问令牌的示例，请参阅本教程的以下章节。有关令牌传播的更多信息，请参阅 xref:security-openid-connect-client-reference.adoc#reactive-token-propagation[OIDC 令牌传播] 。"

#. type: Title ===
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Access tokens in JWT format"
msgstr "JWT 格式的访问令牌"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "We have already looked in detail at how Quarkus OIDC can handle <<opaque-access-tokens>>, but we don't want to propagate Auth0 opaque tokens to micro services which do something useful on behalf on the currently authenticated user, beyond checking its UserInfo."
msgstr "我们已经详细了解了 Quarkus OIDC 如何处理 <<opaque-access-tokens>> ，但我们不希望将 Auth0 不透明令牌传播给微服务，因为微服务除了检查用户信息（UserInfo）外，还要代表当前已通过身份验证的用户做一些有用的事情。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "A microservice which the front-end Quarkus application will access by propagating authorization code flow access tokens to it is represented in the Auth0 dashboard as an `API`. Let's add it in the `Applications/APIs`:"
msgstr "前端 Quarkus 应用程序将通过传播授权代码流访问令牌来访问的微服务在 Auth0 面板中表示为 `API` 。让我们在 `Applications/APIs` 中添加它："

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The `https://quarkus-auth0` identifier of the created `QuarkusAuth0API` will serve as this API's `audience`. Providing this audience as a query parameter in the authorization code flow redirect to Auth0 will ensure that Auth0 issues access tokens in the JWT format."
msgstr "创建的 `https://quarkus-auth0` 创建的 `QuarkusAuth0API` 的标识符将作为此 API 的 `audience` 。在重定向到 Auth0 的授权代码流中，将此受众作为查询参数提供，可确保 Auth0 以 JWT 格式签发访问令牌。"

#. type: Title ===
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "API microservice"
msgstr "应用程序接口微服务"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Add the following dependencies to the project to support OIDC token propagation and REST clients:"
msgstr "在项目中添加以下依赖项，以支持 OIDC 令牌传播和 REST 客户端："

#. type: Block title
#: _guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Create `ApiEchoService` service class:"
msgstr "创建 `ApiEchoService` 服务类："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"And configure it as an OIDC `service` application which will only fetch public verification keys from Auth0.\n"
"The configuration for this microservice should only have a single line:"
msgstr "并将其配置为 OIDC `service` 应用程序，该应用程序将只从 Auth0 获取公共验证密钥。该微服务的配置应该只有一行："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "which is all what is needed for the OIDC `service` application to fetch Auth0 public verification keys and use them to verify Auth0 access tokens in JWT format."
msgstr "这就是 OIDC `service` 应用程序获取 Auth0 公共验证密钥并用其验证 JWT 格式 Auth0 访问令牌所需的全部内容。"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "In this tutorial you have already configured the OIDC `hybrid` application which can handle both authorization code and bearer token authentication flows. In production you will run microservices as separate servers but for the sake of simplicity `ApiEchoService` will not have to be started as a second server with its own configuration containing `quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com` only, and therefore the current configuration which already has the Auth0 dev tenant address configured will be reused."
msgstr "在本教程中，您已经配置了 OIDC `hybrid` 应用程序，它可以同时处理授权代码和承载令牌身份验证流。在生产中，您将把微服务作为单独的服务器运行，但为了简单起见， `ApiEchoService` 不必作为第二个服务器启动，其自身的配置仅包含 `quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com` ，因此当前配置（已配置 Auth0 开发租户地址）将被重复使用。"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The `hybrid` OIDC application type will ensure that `http://localhost:8080/hello` requests to `GreetingResource` initiate an Authorization code flow while `http://localhost:8080/echo` requests to `ApiEchoService`, initiated by `GreetingResource`, will lead to the authorization code flow tokens being propagated and accepted by `ApiEchoService` as bearer JWT access tokens."
msgstr "`hybrid` OIDC 应用程序类型将确保 `http://localhost:8080/hello` `GreetingResource` 的请求启动授权代码流，而 `http://localhost:8080/echo` `ApiEchoService` 的请求（由 `GreetingResource` 发起）将导致授权代码流令牌被 `ApiEchoService` 作为承载 JWT 访问令牌传播和接受。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Next, add a REST client interface representing `ApiEchoService`:"
msgstr "接下来，添加代表 `ApiEchoService` 的 REST 客户端接口："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Propagate access token as an HTTP `Authorization: Bearer accesstoken` header"
msgstr "将访问令牌作为 HTTP `Authorization: Bearer accesstoken` 标头传播"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "And update the configuration for the Quarkus front-end application, `GreetingResource`, which has been created earlier, to request that an authorization code flow access token (as opposed to ID token) includes an `aud` (audience) claim targeting `ApiEchoService`, as well as configure the base URL for the `ApiEchoService` REST client:"
msgstr "更新早先创建的 Quarkus 前端应用程序 `GreetingResource` 的配置，要求授权代码流访问令牌（而不是 ID 令牌）包含针对 `ApiEchoService` 的 `aud` （受众）主张，并为 `ApiEchoService` REST 客户端配置基本 URL："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"Pass an extra `audience` query parameter to the Auth0 authorization endpoint during the authorization code flow redirect from Quarkus to Auth0.\n"
"It will ensure that the access token is issued in the JWT format and includes an `aud` (audience) claim which will contain `https://quarkus-auth0`."
msgstr "在授权代码流从 Quarkus 重定向到 Auth0 的过程中，向 Auth0 授权端点传递一个额外的 `audience` 查询参数。这将确保访问令牌以 JWT 格式发布，并包含 `aud` （受众）声明，其中将包含 `https://quarkus-auth0` ."

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Point `ApiEchoServiceClient` to the `ApiEchoService` endpoint. HTTP port in the `org.acme.ApiEchoServiceClient/mp-rest/url=http://localhost:${port}` property is parameterized to ensure the correct URL is built while using the dev, test and prod modes."
msgstr "将 `ApiEchoServiceClient` 指向 `ApiEchoService` 端点。 `org.acme.ApiEchoServiceClient/mp-rest/url=http://localhost:${port}` 属性中的 HTTP 端口被参数化，以确保在使用开发、测试和 prod 模式时建立正确的 URL。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Finally update `GreetingResource` to request that `ApiEchoService` echoes a user name:"
msgstr "最后更新 `GreetingResource` ，要求 `ApiEchoService` 回传用户名："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Inject `ApiEchoServiceClient` REST client"
msgstr "注入 `ApiEchoServiceClient` REST 客户端"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Use `ApiEchoServiceClient` to echo the user name."
msgstr "使用 `ApiEchoServiceClient` 来回声用户名。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Open a browser, access http://localhost:8080/hello and get your name displayed in the browser."
msgstr "打开浏览器，访问 http://localhost:8080/hello 并在浏览器中显示您的姓名。"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Let's go to http://localhost:8080/q/dev-ui, select the `OpenId Connect` card, login to Auth0, and check the Access token content:"
msgstr "让我们访问 link:http://localhost:8080/q/dev-ui[http://localhost:8080/q/dev-ui，] 选择 `OpenId Connect` 卡，登录 Auth0 并检查访问令牌内容："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "As you can see, the access token is no longer encrypted as shown in the <<opaque-access-tokens>> section and indeed it is in the JWT format now."
msgstr "如您所见，访问令牌不再像 <<opaque-access-tokens>> 部分所示的那样经过加密，实际上它现在是 JWT 格式。"

#. type: Title ===
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Permission Based Access Control"
msgstr "基于权限的访问控制"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "We have discussed in the <<role-based-access-control>> section how to get Quarkus to check a namespace qualified claim containing user roles and use this information to enforce role-based access control. You have configured Auth0 to add the custom roles claim to both ID and access tokens."
msgstr "我们在 <<role-based-access-control>> 部分讨论了如何让 Quarkus 检查包含用户角色的命名空间限定声明，并使用这些信息来执行基于角色的访问控制。你已经对 Auth0 进行了配置，以便将自定义角色声明添加到 ID 和访问令牌中。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "However, Permission Based Access Control is better suited to the case where an access token is propagated by the front-end endpoint to a microservice which will check if a given access token has been authorized for this service to perform a concrete action, as opposed to this token vouching for a user be in a specific role. For example, being in the admin role does not necessarily mean the user is allowed to have a read and write access to some of this microservice's content."
msgstr "不过，基于权限的访问控制更适合前端端点将访问令牌传播到微服务的情况，微服务会检查给定的访问令牌是否已获得授权，以便该服务执行具体操作，而不是由访问令牌来证明用户处于特定角色。例如，用户扮演管理员角色并不一定意味着他可以读写该微服务的某些内容。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Let's see how Permission Based Access Control constraints can be applied to `ApiEchoService`."
msgstr "让我们看看如何将基于权限的访问控制约束应用于 `ApiEchoService` 。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Go to the Auth0 dashboard, add an `echo:name` permission to the `QuarkusAuth0API` API:"
msgstr "进入 Auth0 面板，为 `QuarkusAuth0API` API 添加 `echo:name` 权限："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The `echo:name` permission will be included in the access token as a standard OAuth2 `scope` claim value if this scope will also be requested during the authorization code flow. Update the configuration as follows:"
msgstr "`echo:name` 权限将作为标准 OAuth2 `scope` 索赔值包含在访问令牌中，如果在授权代码流程中也会请求此范围的话。更新配置如下："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "An extra `echo:name` scope will be requested during the authorization code flow."
msgstr "在授权代码流程中，将请求额外的 `echo:name` 范围。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now update `ApiEchoService` to enforce Permission Based Access Control:"
msgstr "现在更新 `ApiEchoService` 以执行基于权限的访问控制："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "This is all what is needed as Quarkus OIDC automatically associates `scope` claim values as permissions with the current security identity."
msgstr "Quarkus OIDC 会自动将 `scope` 索赔值作为权限与当前安全身份关联起来，这就是所需要的一切。"

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "You can enforce both Role Based and Permission Based Access Controls in Quarkus by combining `@RolesAllowed` and `@PermissionsAllowed` annotations."
msgstr "通过结合 `@RolesAllowed` 和 `@PermissionsAllowed` 注释，您可以在 Quarkus 中同时执行基于角色和基于权限的访问控制。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Open a browser, access http://localhost:8080/hello and get the name displayed in the browser."
msgstr "打开浏览器，访问 http://localhost:8080/hello 并在浏览器中显示名称。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "To confirm the permission is correctly enforced, change it to `echo.name`: `@PermissionsAllowed(\"echo.name\")`. Clear the browser cache, access http://localhost:8080/hello again and you will get `403` reported by `ApiEchoService`. Now revert it back to `@PermissionsAllowed(\"echo:name\")`."
msgstr "要确认权限是否正确执行，请将其更改为 `echo.name` : `@PermissionsAllowed(\"echo.name\")` 。清除浏览器缓存，再次访问 http://localhost:8080/hello ，您将看到 `403` 被 `ApiEchoService` 报告。现在将其还原为 `@PermissionsAllowed(\"echo:name\")` 。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Integration testing"
msgstr "集成测试"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "You have already used OIDC DevUI SPA to login to Auth0 and test the Quarkus endpoint with the access token, updating the endpoint code along the way."
msgstr "您已经使用 OIDC DevUI SPA 登录 Auth0，并使用访问令牌测试了 Quarkus 端点，同时更新了端点代码。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "However, running tests is also essential, lets see how we can test the endpoint and configuration which you have developed during the course of this tutorial, using xref:continuous-testing.adoc[Quarkus Continuous Testing] feature."
msgstr "不过，运行测试也是必不可少的，让我们看看如何使用 xref:continuous-testing.adoc[Quarkus 的持续测试] 功能测试本教程中开发的端点和配置。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Start with the following test code :"
msgstr "从以下测试代码开始："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "If you recall, when the application was started in dev mode, the following could be seen in the CLI window:"
msgstr "如果你还记得，在开发模式下启动应用程序时，在 CLI 窗口中可以看到以下内容："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Press `r` and notice this test failing with `403` which is expected because the test does not send a token to the endpoint:"
msgstr "按 `r` 并注意到该测试以 `403` 失败，这在意料之中，因为测试没有向端点发送令牌："

#: _guides/security-oidc-auth0-tutorial.adoc
msgid "Before fixing the test, let's review the options available for testing Quarkus endpoints secured by OIDC. These options might vary, depending on which flow your application supports and how you prefer to test. Endpoints which use OIDC authorization code flow can be tested using xref:security-oidc-code-flow-authentication#code-flow-integration-testing[one of these options] and endpoints which use Bearer token authentication can be tested using xref:security-oidc-bearer-token-authentication#bearer-token-integration-testing[one of these options]."
msgstr ""

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "As you can see, testing of the endpoints secured with Auth0 can be done with the help of `Wiremock`, or `@TestSecurity` annotation. Experiment with writing such tests on your own and reach out if you encounter any problems."
msgstr "正如你所看到的，可以借助 `Wiremock` 或 `@TestSecurity` 注释对使用 Auth0 加密的端点进行测试。请尝试自己编写此类测试，如果遇到任何问题，请联系我们。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "In this tutorial though, we will use a recently added `OidcTestClient` to support testing endpoints which use live Auth0 development tenants."
msgstr "不过，在本教程中，我们将使用最近添加的 `OidcTestClient` 来支持使用实时 Auth0 开发租户的测试端点。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Here is a related fragment of the configuration:"
msgstr "下面是配置的相关片段："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "In production, you will distinguish between prod and test level configuration with `%prod.` and `%test.` qualifiers. Let's assume that the above configuration will indeed be prefixed with `%test.` in your real application, with this configuration also including the `%prod.` qualified Auth0 production tenant configuration."
msgstr "在生产中，您将使用 `%prod.` 和 `%test.` 限定符来区分 prod 和测试级配置。假设上述配置在实际应用中确实以 `%test.` 为前缀，该配置还包括 `%prod.` 限定 Auth0 生产租户配置。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Using `OidcTestClient` to test such configuration requires acquiring a token from the Auth0 dev tenant, using either OAuth2 `password` or `client_credentials` grant, we will try a `password` grant. Make sure the application registered in the Auth0 dashboard allows the `password` grant:"
msgstr "使用 `OidcTestClient` 测试此类配置需要从 Auth0 开发租户获取一个令牌，使用 OAuth2 `password` 或 `client_credentials` 授予，我们将尝试 `password` 授予。确保 Auth0 面板中注册的应用程序允许 `password` 授权："

#. type: delimited block =
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "It is important to clarify that we do not recommend using the deprecated OAuth2 `password` token grant in production. However using it can help testing the endpoint with tokens acquired from the live dev Auth0 tenant."
msgstr "需要说明的是，我们不建议在生产中使用过时的 OAuth2 `password` 令牌授权。不过，使用它有助于使用从实时开发 Auth0 租户获取的令牌测试端点。"

#: _guides/security-oidc-auth0-tutorial.adoc
msgid "`OidcTestClient` should be used to test applications accepting bearer tokens which will work for the endpoint developed in this tutorial as it supports both authorization code flow and bearer token authentication. You would need to use OIDC WireMock or `HtmlUnit` directly against the Auth0 dev tenant if only the authorization code flow was supported - in the latter case `HtmlUnit` test code would have to be aligned with how Auth0 challenges users to enter their credentials. If you like, you can copy the xref:security-oidc-code-flow-authentication#code-flow-integration-testing-wiremock[HtmlUnit test fragment] from the documentation and experiment with it."
msgstr ""

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "In meantime we will now proceed with fixing the currently failing test using `OidcTestClient`."
msgstr "同时，我们将使用 `OidcTestClient` 修复当前失败的测试。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "First you must add the following dependency:"
msgstr "首先，您必须添加以下依赖项："

#. type: Block title
#: _guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "which provides a utility class `io.quarkus.test.oidc.client.OidcTestClient` which can be used in tests for acquiring access tokens (This dependency also offers an OIDC WireMock support - review the documentation how to use it for testing if you want)."
msgstr "提供了一个实用程序类 `io.quarkus.test.oidc.client.OidcTestClient` ，可在测试中用于获取访问令牌（该依赖项还提供了 OIDC WireMock 支持--如果需要，请查看文档了解如何将其用于测试）。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Now update the test code like this:"
msgstr "现在像这样更新测试代码："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "`OidcTestClient` is used to acquire an access token, using one of the registered user's name and password, as well as the `audience` and `scope` parameters."
msgstr "`OidcTestClient` 用于获取访问令牌，使用的是注册用户的姓名和密码之一，以及 和 参数。 `audience` `scope` "

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "`OidcTestClient` will itself find out the `Auth0` token endpoint address, client id and secret."
msgstr "`OidcTestClient` 本身会找出 令牌端点地址、客户端 ID 和密文。 `Auth0` "

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Press `r` again and have the test passing:"
msgstr "再次按 `r` ，测试通过："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "By the way, if you like, you can run the tests in Continuous mode directly from DevUI:"
msgstr "顺便说一下，如果您愿意，可以直接从 DevUI 以持续模式运行测试："

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Production mode"
msgstr "生产模式"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"You have developed and tested the Quarkus endpoint secured with Auth0 in the development mode.\n"
"The next step is to run your application in the production mode.\n"
"Choose between JVM and native modes."
msgstr "您已经在开发模式下开发并测试了使用 Auth0 加密的 Quarkus 端点。下一步是在生产模式下运行应用程序。在 JVM 和本地模式之间进行选择。"

#. type: Title ===
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Run the Application in JVM mode"
msgstr "以 JVM 模式运行应用程序"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Compile the application:"
msgstr "编译应用程序："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Run the application:"
msgstr "要在开发模式下运行应用程序，请使用："

#. type: Title ===
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Run the application in native mode"
msgstr "要在开发模式下运行应用程序，请使用："

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"You can compile this same demo into native mode without needing any modifications.\n"
"This implies that you no longer need to install a JVM on your production environment.\n"
"The runtime technology is included in the produced binary and optimized to run with minimal resources required."
msgstr "您可以将同样的演示编译为本地模式，而无需做任何修改。这意味着您不再需要在生产环境中安装 JVM。运行时技术已包含在生成的二进制文件中，并经过优化，只需最少的资源即可运行。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Compilation takes a bit longer, so this step is disabled by default."
msgstr "编译会花一点时间，所以这一步默认是禁用的；让我们通过启用 `native` profile来再次构建："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Build your application again by enabling the `native` profile:"
msgstr "启用 `native` 配置文件，重新构建应用程序："

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Next run the following binary directly:"
msgstr "接下来直接运行以下二进制文件："

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Troubleshooting"
msgstr "故障排除"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "The steps described in this tutorial should work exactly as the tutorial describes. You might have to clear the browser cookies when accessing the updated Quarkus endpoint if you have already completed the authentication. You might need to restart the Quarkus application manually in dev mode but it is not expected. If you need help completing this tutorial, you can get in touch with the Quarkus team."
msgstr "本教程中描述的步骤应与教程中描述的完全一致。如果已完成身份验证，在访问更新的 Quarkus 端点时可能需要清除浏览器 cookie。你可能需要在开发模式下手动重启 Quarkus 应用程序，但这不是预期的。如果您在完成本教程时需要帮助，可以联系 Quarkus 团队。"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy, no-wrap
msgid "Summary"
msgstr "摘要"

#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid ""
"This tutorial demonstrated how Quarkus endpoints can be secured with the `quarkus-oidc` extension and Auth0 using Authorization code and Bearer token authentication flows, with both flows being supported by the same endpoint code.\n"
"Without writing a single line of code, you have added support for the custom Auth0 logout flow and enabled role-based access control with a custom Auth0 namespace qualified claim.\n"
"Token propagation from the front-end endpoint to the microservice endpoint has been achieved by adding the `@AccessToken` annotation to the microservice REST client.\n"
"Microservice endpoint activated the permission-based access control with the `@PermissionsAllowed` annotation.\n"
"You used Quarkus dev mode to update the code and configuration without restarting the endpoint, and you also used the OIDC Dev UI to visualize and test Auth0 tokens.\n"
"You used the continuous testing feature of Quarkus to complement OIDC Dev UI tests with integration tests against the live Auth0 development tenant.\n"
"Finally, you have run the application in JVM and native modes."
msgstr "本教程演示了 Quarkus 端点如何通过 `quarkus-oidc` 扩展和 Auth0 使用授权代码和承载令牌身份验证流来确保安全，并通过相同的端点代码来支持这两种流。不需要编写一行代码，你就能添加对自定义 Auth0 注销流程的支持，并通过自定义 Auth0 命名空间限定声明启用基于角色的访问控制。通过在微服务 REST 客户端添加 `@AccessToken` 注解，令牌从前端端点传播到了微服务端点。微服务端点通过 `@PermissionsAllowed` 注解激活了基于权限的访问控制。你使用了 Quarkus 开发模式来更新代码和配置，而无需重启端点，还使用了 OIDC Dev UI 来可视化和测试 Auth0 令牌。你还使用了 Quarkus 的持续测试功能，通过针对实时 Auth0 开发租户的集成测试来补充 OIDC Dev UI 测试。最后，您在 JVM 和本地模式下运行了应用程序。"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "Enjoy!"
msgstr "请慢用"

#. type: Title ==
#: _guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "References"
msgstr "参考文献"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "xref:security-overview.adoc[Quarkus Security overview]"
msgstr "xref:security-overview.adoc[Quarkus 安全概述]"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "xref:security-oidc-code-flow-authentication.adoc[OIDC code flow mechanism for protecting web applications]"
msgstr "xref:security-oidc-code-flow-authentication.adoc[保护网络应用程序的 OIDC 代码流机制]"

#. type: Plain text
#: _guides/security-oidc-auth0-tutorial.adoc
#, fuzzy
msgid "xref:security-openid-connect-providers.adoc[Configuring well-known OpenID Connect providers]"
msgstr "link:security-openid-connect-providers.html[配置知名的OpenID连接提供者]"
