# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-keycloak-authorization.adoc:6
#, fuzzy, no-wrap
msgid "Using OpenID Connect (OIDC) and Keycloak to Centralize Authorization"
msgstr "使用OpenID连接（OIDC）和Keycloak来集中授权"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:11
#, fuzzy
msgid "This guide demonstrates how your Quarkus application can authorize a bearer token access to protected resources using https://www.keycloak.org/docs/latest/authorization_services/index.html[Keycloak Authorization Services]."
msgstr "本指南演示了你的Quarkus应用程序如何使用 link:https://www.keycloak.org/docs/latest/authorization_services/index.html[Keycloak授权服务] 来授权不记名令牌访问受保护的资源。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:15
#, fuzzy
msgid "The `quarkus-keycloak-authorization` extension is based on `quarkus-oidc` and provides a policy enforcer that enforces access to protected resources based on permissions managed by Keycloak and currently can only be used with the Quarkus xref:security-openid-connect.adoc[OIDC service applications].  It provides a flexible and dynamic authorization capability based on Resource-Based Access Control.  In other words, instead of explicitly enforcing access based on some specific access control mechanism (e.g.: RBAC), you just check whether or not a request is allowed to access a resource based on its name, identifier or URI."
msgstr " `quarkus-keycloak-authorization` 扩展是基于 `quarkus-oidc` ，并提供一个策略执行者，根据Keycloak管理的权限执行对受保护资源的访问，目前只能与Quarkus link:security-openid-connect.html[OIDC服务应用] 一起使用。它提供了一个基于资源访问控制的灵活和动态的授权能力。换句话说，你不需要明确地根据一些特定的访问控制机制（例如：RBAC）来执行访问，而只是根据资源的名称、标识符或URI来检查一个请求是否被允许访问。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:17
#, fuzzy
msgid "By externalizing authorization from your application, you are allowed to protect your applications using different access control mechanisms as well as avoid re-deploying your application every time your security requirements change, where Keycloak will be acting as a centralized authorization service from where your protected resources and their associated permissions are managed."
msgstr "通过将授权从你的应用程序中外部化，你可以使用不同的访问控制机制来保护你的应用程序，也可以避免在你的安全需求发生变化时重新部署你的应用程序，Keycloak将作为一个集中的授权服务，你的受保护资源和它们的相关权限都在这里得到管理。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:19
#, fuzzy
msgid "See the xref:security-openid-connect.adoc[Using OpenID Connect to Protect Service Applications] guide for more information about `Bearer Token` authentication mechanism. It is important to realize that it is the `Bearer Token` authentication mechanism which does the authentication and creates a security identity - while the `quarkus-keycloak-authorization` extension is responsible for applying a Keycloak Authorization Policy to this identity based on the current request path and other policy settings."
msgstr "关于 `Bearer Token` 认证机制的更多信息，请参见 link:security-openid-connect.html[使用OpenID Connect保护服务应用] 指南。重要的是要认识到，是 `Bearer Token` 认证机制进行认证并创建一个安全身份 - 而 `quarkus-keycloak-authorization` 扩展负责根据当前的请求路径和其他策略设置对该身份应用Keycloak授权策略。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:22
#, fuzzy
msgid "If you are already familiar with Keycloak, you’ll notice that the extension is basically another adapter implementation but specific for Quarkus applications.  Otherwise, you can find more information in the Keycloak https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview[documentation]."
msgstr "如果你已经熟悉Keycloak，你会注意到这个扩展基本上是另一个适配器的实现，但专门针对Quarkus应用程序。否则，你可以在Keycloak link:https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview[文档] 中找到更多信息。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:23
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:28
#, fuzzy
msgid "https://stedolan.github.io/jq/[jq tool]"
msgstr "link:https://stedolan.github.io/jq/[jq工具]"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:29
#, fuzzy
msgid "https://www.keycloak.org/docs/latest/server_installation/index.html[Keycloak]"
msgstr "link:https://www.keycloak.org/docs/latest/server_installation/index.html[钥匙环]"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:30
#, fuzzy, no-wrap
msgid "Architecture"
msgstr "建筑学"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:33
#, fuzzy
msgid "In this example, we build a very simple microservice which offers two endpoints:"
msgstr "在这个例子中，我们建立了一个非常简单的微服务，提供两个端点。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:35
#, fuzzy
msgid "`/api/users/me`"
msgstr " `/api/users/me` "

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:36
#, fuzzy
msgid "`/api/admin`"
msgstr " `/api/admin` "

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:38
#, fuzzy
msgid "These endpoints are protected and can only be accessed if a client is sending a bearer token along with the request, which must be valid (e.g.: signature, expiration and audience) and trusted by the microservice."
msgstr "这些端点是受保护的，只有当客户端与请求一起发送一个不记名令牌时才能被访问，该令牌必须是有效的（例如：签名、过期和受众），并得到微服务的信任。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:41
#, fuzzy
msgid "The bearer token is issued by a Keycloak Server and represents the subject to which the token was issued for.  For being an OAuth 2.0 Authorization Server, the token also references the client acting on behalf of the user."
msgstr "不记名令牌是由Keycloak服务器发出的，并代表令牌的发放对象。对于作为OAuth 2.0授权服务器，该令牌还引用了代表用户的客户端。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:45
#, fuzzy
msgid "The `/api/users/me` endpoint can be accessed by any user with a valid token.  As a response, it returns a JSON document with details about the user where these details are obtained from the information carried on the token.  This endpoint is protected with RBAC (Role-Based Access Control) and only users granted with the `user` role can access this endpoint."
msgstr " `/api/users/me` 端点可由任何拥有有效令牌的用户访问。作为响应，它返回一个JSON文档，其中包含关于用户的详细信息，这些详细信息是从令牌上的信息中获得的。这个端点受到RBAC（基于角色的访问控制）的保护，只有被授予 `user` 角色的用户才能访问这个端点。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:47
#, fuzzy
msgid "The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) and only users granted with the `admin` role can access it."
msgstr " `/api/admin` 端点受到RBAC（基于角色的访问控制）的保护，只有被授予 `admin` 角色的用户才能访问它。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:51
#, fuzzy
msgid "This is a very simple example using RBAC policies to govern access to your resources.  However, Keycloak supports other types of policies that you can use to perform even more fine-grained access control.  By using this example, you'll see that your application is completely decoupled from your authorization policies with enforcement being purely based on the accessed resource."
msgstr "这是一个非常简单的例子，使用RBAC策略来管理对你的资源的访问。然而，Keycloak支持其他类型的策略，你可以用它来执行更细粒度的访问控制。通过使用这个例子，你会看到你的应用程序与你的授权策略完全脱钩，执行完全基于访问的资源。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:52
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:56
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。然而，你可以直接进入已完成的例子。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:58
#, fuzzy
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库。 `git clone {quickstarts-clone-url}` ，或者下载一个{quickstarts-archive-url}[存档]。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:60
#, fuzzy
msgid "The solution is located in the `security-keycloak-authorization-quickstart` {quickstarts-tree-url}/security-keycloak-authorization-quickstart[directory]."
msgstr "该解决方案位于 `security-keycloak-authorization-quickstart` {quickstarts-tree-url}/security-keycloak-authorization-quickstart[目录]中。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:61
#, fuzzy, no-wrap
msgid "Creating the Project"
msgstr "创建项目"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:65
#, fuzzy
msgid "First, we need a new project.  Create a new project with the following command:"
msgstr "首先，我们需要一个新的项目。用以下命令创建一个新项目。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:71
#, fuzzy
msgid "This command generates a project, importing the `keycloak-authorization` extension which is an implementation of a Keycloak Adapter for Quarkus applications and provides all the necessary capabilities to integrate with a Keycloak Server and perform bearer token authorization."
msgstr "该命令生成一个项目，导入 `keycloak-authorization` 扩展，这是一个用于Quarkus应用程序的Keycloak适配器的实现，并提供所有必要的功能来与Keycloak服务器集成并执行不记名令牌授权。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:74
#, fuzzy
msgid "If you already have your Quarkus project configured, you can add the `oidc` and `keycloak-authorization` extensions to your project by running the following command in your project base directory:"
msgstr "如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `oidc` 和 `keycloak-authorization` 扩展到你的项目中。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:79
#, fuzzy
msgid "This will add the following to your build file:"
msgstr "这将在你的构建文件中添加以下内容。"

#. type: Block title
#: upstream/_guides/security-keycloak-authorization.adoc:81
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:91
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-oidc</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-keycloak-authorization</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/security-keycloak-authorization.adoc:94
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:98
#, no-wrap
msgid ""
"implementation(\"io.quarkus:quarkus-oidc\")\n"
"implementation(\"io.quarkus:quarkus-keycloak-authorization\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:102
#, fuzzy
msgid "Let's start by implementing the `/api/users/me` endpoint.  As you can see from the source code below it is just a regular JAX-RS resource:"
msgstr "让我们从实现 `/api/users/me` 端点开始。从下面的源代码可以看出，它只是一个普通的JAX-RS资源。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:106
#: upstream/_guides/security-keycloak-authorization.adoc:148
#, no-wrap
msgid "package org.acme.security.keycloak.authorization;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:110
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:112
#, no-wrap
msgid "import org.jboss.resteasy.annotations.cache.NoCache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:114
#, no-wrap
msgid "import io.quarkus.security.identity.SecurityIdentity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:117
#, no-wrap
msgid ""
"@Path(\"/api/users\")\n"
"public class UsersResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:120
#: upstream/_guides/security-keycloak-authorization.adoc:342
#, no-wrap
msgid ""
"    @Inject\n"
"    SecurityIdentity identity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:127
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/me\")\n"
"    @NoCache\n"
"    public User me() {\n"
"        return new User(identity);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:129
#, no-wrap
msgid "    public static class User {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:131
#, no-wrap
msgid "        private final String userName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:135
#, no-wrap
msgid ""
"        User(SecurityIdentity identity) {\n"
"            this.userName = identity.getPrincipal().getName();\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:141
#, no-wrap
msgid ""
"        public String getUserName() {\n"
"            return userName;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:144
#, fuzzy
msgid "The source code for the `/api/admin` endpoint is also very simple:"
msgstr " `/api/admin` 端点的源代码也非常简单。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:153
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:155
#, no-wrap
msgid "import io.quarkus.security.Authenticated;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:159
#, no-wrap
msgid ""
"@Path(\"/api/admin\")\n"
"@Authenticated\n"
"public class AdminResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:166
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String admin() {\n"
"        return \"granted\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:170
#, fuzzy
msgid "Note that we did not define any annotation such as `@RolesAllowed` to explicitly enforce access to a resource.  The extension will be responsible to map the URIs of the protected resources you have in Keycloak and evaluate the permissions accordingly, granting or denying access depending on the permissions that will be granted by Keycloak."
msgstr "请注意，我们没有定义任何注释，如 `@RolesAllowed` ，以明确地执行对资源的访问。扩展将负责映射你在Keycloak中的受保护资源的URI，并相应地评估权限，根据将由Keycloak授予的权限，授予或拒绝访问。"

#. type: Title ===
#: upstream/_guides/security-keycloak-authorization.adoc:171
#, fuzzy, no-wrap
msgid "Configuring the application"
msgstr "配置应用程序"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:174
#, fuzzy
msgid "The OpenID Connect extension allows you to define the adapter configuration using the `application.properties` file which should be located at the `src/main/resources` directory."
msgstr "OpenID Connect扩展允许你使用 `application.properties` 文件来定义适配器配置，该文件应位于 `src/main/resources` 目录下。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:182
#, no-wrap
msgid ""
"# OIDC Configuration\n"
"%prod.quarkus.oidc.auth-server-url=https://localhost:8543/realms/quarkus\n"
"quarkus.oidc.client-id=backend-service\n"
"quarkus.oidc.credentials.secret=secret\n"
"quarkus.oidc.tls.verification=none\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:185
#, no-wrap
msgid ""
"# Enable Policy Enforcement\n"
"quarkus.keycloak.policy-enforcer.enable=true\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:189
#, no-wrap
msgid ""
"# Tell Dev Services for Keycloak to import the realm file\n"
"# This property is not effective when running the application in JVM or Native modes\n"
"quarkus.keycloak.devservices.realm-path=quarkus-realm.json\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:192
#, fuzzy
msgid "Adding a `%prod.` profile prefix to `quarkus.oidc.auth-server-url` ensures that `Dev Services for Keycloak` will launch a container for you when the application is run in a dev mode. See <<keycloak-dev-mode, Running the Application in Dev mode>> section below for more information."
msgstr "在 `quarkus.oidc.auth-server-url` 上添加一个 `%prod.` profile 前缀，可以确保在应用程序以开发模式运行时， `Dev Services for Keycloak` 会为你启动一个容器。更多信息请参见下面的 \" link:#keycloak-dev-mode[在开发模式下运行应用程序] \"部分。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:194
#, fuzzy
msgid "By default, applications using the `quarkus-oidc` extension are marked as a `service` type application (see `quarkus.oidc.application-type`). This extension also supports only `web-app` type applications but only if the access token returned as part of the authorization code grant response is marked as a source of roles: `quarkus.oidc.roles.source=accesstoken` (`web-app` type applications check ID token roles by default)."
msgstr "默认情况下，使用 `quarkus-oidc` 扩展的应用程序被标记为 `service` 类型的应用程序（见 `quarkus.oidc.application-type` ）。这个扩展也只支持 `web-app` 类型的应用程序，但只有当作为授权码授予响应的一部分返回的访问令牌被标记为角色的来源： `quarkus.oidc.roles.source=accesstoken` （ `web-app` 类型的应用程序默认检查ID令牌角色）。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:195
#, fuzzy, no-wrap
msgid "Starting and Configuring the Keycloak Server"
msgstr "启动和配置Keycloak服务器"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:198
#, fuzzy
msgid "Do not start the Keycloak server when you run the application in a dev mode - `Dev Services for Keycloak` will launch a container. See <<keycloak-dev-mode, Running the Application in Dev mode>> section below for more information."
msgstr "当你以开发模式运行应用程序时，不要启动Keycloak服务器 - `Dev Services for Keycloak` 将启动一个容器。更多信息请参见下面在 link:#keycloak-dev-mode[开发模式下运行应用程序] 的部分。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:200
#, fuzzy
msgid "To start a Keycloak Server you can use Docker and just run the following command:"
msgstr "要启动Keycloak服务器，你可以使用Docker，只需运行以下命令。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:204
#, no-wrap
msgid "docker run --name keycloak -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin -p 8543:8443 -v \"$(pwd)\"/config/keycloak-keystore.jks:/etc/keycloak-keystore.jks quay.io/keycloak/keycloak:{keycloak.version} start  --hostname-strict=false --https-key-store-file=/etc/keycloak-keystore.jks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:207
#, fuzzy
msgid "where `keycloak.version` should be set to `17.0.0` or higher."
msgstr "其中 `keycloak.version` 应该设置为 `17.0.0` 或更高。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:209
#, fuzzy
msgid "You should be able to access your Keycloak Server at https://localhost:8543[localhost:8543]."
msgstr "你应该能够在 link:https://localhost:8543[localhost:8543] 访问你的Keycloak服务器。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:212
#, fuzzy
msgid "Log in as the `admin` user to access the Keycloak Administration Console.  Username should be `admin` and password `admin`."
msgstr "以 `admin` 用户身份登录，访问Keycloak管理控制台。用户名应该是 `admin` ，密码是 `admin` 。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:215
#, fuzzy
msgid "Import the {quickstarts-tree-url}/security-keycloak-authorization-quickstart/config/quarkus-realm.json[realm configuration file] to create a new realm.  For more details, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm]."
msgstr "导入{quickstarts-tree-url}/security-keycloak-authorization-quickstart/config/quarkus-realm.json[境界配置文件]来创建一个新境界。更多细节，请参阅Keycloak文档中关于如何 link:https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[创建一个新的境] 界。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:217
#, fuzzy
msgid "After importing the realm you can see the resource permissions:"
msgstr "导入境界后，你可以看到资源的权限。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/security-keycloak-authorization.adoc:218
#, fuzzy, no-wrap
msgid "Keycloak"
msgstr "钥匙环"

#. type: Target for macro image
#: upstream/_guides/security-keycloak-authorization.adoc:218
#, no-wrap
msgid "keycloak-authorization-permissions.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:221
#, fuzzy
msgid "It explains why the endpoint has no `@RolesAllowed` annotations - the resource access permissions are set directly in Keycloak."
msgstr "这解释了为什么端点没有 `@RolesAllowed` 注释--资源访问权限是直接在Keycloak中设置的。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:223
#, fuzzy, no-wrap
msgid "Running the Application in Dev mode"
msgstr "在开发模式下运行应用程序"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:226
#, fuzzy
msgid "To run the application in dev mode, use:"
msgstr "要在开发模式下运行应用程序，请使用。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:230
#, fuzzy
msgid "xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] will launch a Keycloak container and import a `quarkus-realm.json`."
msgstr "link:security-openid-connect-dev-services.html[Keycloak的开发服务] 将启动一个Keycloak容器并导入一个 `quarkus-realm.json` 。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:232
#, fuzzy
msgid "Open a xref:dev-ui.adoc[Dev UI] available at http://localhost:8080/q/dev[/q/dev] and click on a `Provider: Keycloak` link in an `OpenID Connect` `Dev UI` card."
msgstr "打开 link:http://localhost:8080/q/dev[/q/dev] 提供的 link:dev-ui.html[开发用户界面] ，点击 `OpenID Connect` `Dev UI` 卡中的一个 `Provider: Keycloak` 链接。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:234
#, fuzzy
msgid "You will be asked to login into a `Single Page Application` provided by `OpenID Connect Dev UI`:"
msgstr "你将被要求登录到由 `OpenID Connect Dev UI` 提供的 `Single Page Application` 。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:236
#, fuzzy
msgid "Login as `alice` (password: `alice`) who only has a `User Permission` to access the `/api/users/me` resource"
msgstr "以 `alice` （密码： `alice` ）登录，他只有一个 `User Permission` ，可以访问 `/api/users/me` 资源。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:237
#, fuzzy
msgid "accessing `/api/admin` will return `403`"
msgstr "访问 `/api/admin` ，将返回 `403` "

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:238
#: upstream/_guides/security-keycloak-authorization.adoc:241
#, fuzzy
msgid "accessing `/api/users/me` will return `200`"
msgstr "访问 `/api/users/me` ，将返回 `200` "

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:239
#, fuzzy
msgid "Logout and login as `admin` (password: `admin`) who has both `Admin Permission` to access the `/api/admin` resource and `User Permission` to access the `/api/users/me` resource"
msgstr "退出并以 `admin` （密码： `admin` ）的身份登录，他同时拥有 `Admin Permission` 访问 `/api/admin` 资源和 `User Permission` 访问 `/api/users/me` 资源。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:240
#, fuzzy
msgid "accessing `/api/admin` will return `200`"
msgstr "访问 `/api/admin` ，将返回 `200` "

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:242
#, fuzzy, no-wrap
msgid "Running the Application in JVM mode"
msgstr "在JVM模式下运行应用程序"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:245
#, fuzzy
msgid "When you're done playing with the `dev` mode\" you can run it as a standard Java application."
msgstr "当你玩完了 `dev` 模式\"，你可以把它作为一个标准的Java应用程序运行。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:247
#, fuzzy
msgid "First compile it:"
msgstr "首先编译它。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:251
#, fuzzy
msgid "Then run it:"
msgstr "然后运行它。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:255
#, no-wrap
msgid "java -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:257
#, fuzzy, no-wrap
msgid "Running the Application in Native Mode"
msgstr "在本地模式下运行应用程序"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:260
#, fuzzy
msgid "This same demo can be compiled into native code: no modifications required."
msgstr "这个同样的演示可以被编译成本地代码：不需要修改。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:262
#, fuzzy
msgid "This implies that you no longer need to install a JVM on your production environment, as the runtime technology is included in the produced binary, and optimized to run with minimal resource overhead."
msgstr "这意味着你不再需要在你的生产环境中安装JVM，因为运行时技术包含在生产的二进制文件中，并以最小的资源开销优化运行。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:264
#, fuzzy
msgid "Compilation will take a bit longer, so this step is disabled by default; let's build again by enabling the `native` profile:"
msgstr "编译会花一点时间，所以这一步默认是禁用的；让我们通过启用 `native` profile来再次构建。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:268
#, fuzzy
msgid "After getting a cup of coffee, you'll be able to run this binary directly:"
msgstr "喝完一杯咖啡后，你就可以直接运行这个二进制文件。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:272
#, no-wrap
msgid "./target/security-keycloak-authorization-quickstart-runner\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:274
#, fuzzy, no-wrap
msgid "Testing the Application"
msgstr "测试应用程序"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:277
#, fuzzy
msgid "See <<keycloak-dev-mode, Running the Application in Dev mode>> section above about testing your application in a dev mode."
msgstr "关于在开发模式下测试你的应用程序，请参见上面在开发模式下 link:#keycloak-dev-mode[运行] 应用程序一节。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:279
#, fuzzy
msgid "You can test the application launched in JVM or Native modes with `curl`."
msgstr "你可以用 `curl` ，测试在JVM或Native模式下启动的应用程序。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:281
#, fuzzy
msgid "The application is using bearer token authorization and the first thing to do is obtain an access token from the Keycloak Server in order to access the application resources:"
msgstr "该应用程序使用不记名令牌授权，首先要做的是从Keycloak服务器获得一个访问令牌，以便访问应用程序资源。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:290
#, no-wrap
msgid ""
"export access_token=$(\\\n"
"    curl --insecure -X POST https://localhost:8543/realms/quarkus/protocol/openid-connect/token \\\n"
"    --user backend-service:secret \\\n"
"    -H 'content-type: application/x-www-form-urlencoded' \\\n"
"    -d 'username=alice&password=alice&grant_type=password' | jq --raw-output '.access_token' \\\n"
" )\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:293
#, fuzzy
msgid "The example above obtains an access token for user `alice`."
msgstr "上面的例子为用户 `alice` ，获得了一个访问令牌。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:297
#, fuzzy
msgid "Any user is allowed to access the `http://localhost:8080/api/users/me` endpoint which basically returns a JSON payload with details about the user."
msgstr "任何用户都被允许访问这个 `<a href=\"http://localhost:8080/api/users/me\" class=\"bare\">http://localhost:8080/api/users/me</a>` 端点，该端点基本上返回一个包含用户详细信息的JSON有效载荷。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:303
#, no-wrap
msgid ""
"curl -v -X GET \\\n"
"  http://localhost:8080/api/users/me \\\n"
"  -H \"Authorization: Bearer \"$access_token\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:307
#, fuzzy
msgid "The `http://localhost:8080/api/admin` endpoint can only be accessed by users with the `admin` role.  If you try to access this endpoint with the previously issued access token, you should get a `403` response from the server."
msgstr "该 `<a href=\"http://localhost:8080/api/admin\" class=\"bare\">http://localhost:8080/api/admin</a>` 端点只能由具有 `admin` 角色的用户访问。如果你试图用先前发布的访问令牌访问这个端点，你应该从服务器上得到一个 `403` 的响应。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:313
#, no-wrap
msgid ""
" curl -v -X GET \\\n"
"   http://localhost:8080/api/admin \\\n"
"   -H \"Authorization: Bearer \"$access_token\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:316
#, fuzzy
msgid "In order to access the admin endpoint you should obtain a token for the `admin` user:"
msgstr "为了访问管理端点，你应该获得一个 `admin` 用户的令牌。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:325
#, no-wrap
msgid ""
"export access_token=$(\\\n"
"    curl --insecure -X POST https://localhost:8543/realms/quarkus/protocol/openid-connect/token \\\n"
"    --user backend-service:secret \\\n"
"    -H 'content-type: application/x-www-form-urlencoded' \\\n"
"    -d 'username=admin&password=admin&grant_type=password' | jq --raw-output '.access_token' \\\n"
" )\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:327
#, fuzzy, no-wrap
msgid "Checking Permissions Programmatically"
msgstr "以程序方式检查权限"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:331
#, fuzzy
msgid "In some cases, you may want to programmatically check whether or not a request is granted to access a protected resource. By injecting a `SecurityIdentity` instance in your beans, you are allowed to check permissions as follows:"
msgstr "在某些情况下，你可能想以编程方式检查一个请求是否被允许访问受保护的资源。通过在你的Bean中注入一个 `SecurityIdentity` 实例，你可以按以下方式检查权限。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:336
#, no-wrap
msgid ""
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:339
#, no-wrap
msgid ""
"@Path(\"/api/protected\")\n"
"public class ProtectedResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:355
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<List<Permission>> get() {\n"
"        return identity.checkPermission(new AuthPermission(\"{resource_name}\")).onItem()\n"
"                .transform(granted -> {\n"
"                    if (granted) {\n"
"                        return identity.getAttribute(\"permissions\");\n"
"                    }\n"
"                    throw new ForbiddenException();\n"
"                });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:357
#, fuzzy, no-wrap
msgid "Injecting the Authorization Client"
msgstr "注入授权客户端"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:362
#, fuzzy
msgid "In some cases, you may want to use the https://www.keycloak.org/docs/latest/authorization_services/#_service_client_api[Keycloak Authorization Client Java API] to perform specific operations like managing resources and obtaining permissions directly from Keycloak. For that, you can inject a `AuthzClient` instance into your beans as follows:"
msgstr "在某些情况下，你可能想使用 link:https://www.keycloak.org/docs/latest/authorization_services/#_service_client_api[Keycloak授权客户端Java API] 来执行特定的操作，如管理资源和直接从Keycloak获得权限。为此，你可以按以下方式将一个 `AuthzClient` 实例注入到你的bean中。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:369
#, no-wrap
msgid ""
"public class ProtectedResource {\n"
"    @Inject\n"
"    AuthzClient authzClient;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:372
#, fuzzy
msgid "Note: If you want to use the `AuthzClient` directly make sure to to set `quarkus.keycloak.policy-enforcer.enable=true` otherwise there is no Bean available for injection."
msgstr "注意：如果你想直接使用 `AuthzClient` ，请确保设置 `quarkus.keycloak.policy-enforcer.enable=true` ，否则就没有Bean可供注入。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:373
#, fuzzy, no-wrap
msgid "Mapping Protected Resources"
msgstr "绘制受保护资源地图"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:376
#, fuzzy
msgid "By default, the extension is going to fetch resources on-demand from Keycloak where their `URI` are used to map the resources in your application that should be protected."
msgstr "默认情况下，扩展将从Keycloak按需获取资源，其中他们的 `URI` ，用于映射你的应用程序中应该被保护的资源。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:378
#, fuzzy
msgid "If you want to disable this behavior and fetch resources during startup, you can use the following configuration:"
msgstr "如果你想禁用这种行为，并在启动期间获取资源，你可以使用以下配置。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:382
#, no-wrap
msgid "quarkus.keycloak.policy-enforcer.lazy-load-paths=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:385
#, fuzzy
msgid "Note that, depending on how many resources you have in Keycloak the time taken to fetch them may impact your application startup time."
msgstr "请注意，根据你在Keycloak中有多少资源，获取这些资源的时间可能会影响你的应用程序的启动时间。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:386
#, fuzzy, no-wrap
msgid "More About Configuring Protected Resources"
msgstr "关于配置受保护资源的更多信息"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:389
#, fuzzy
msgid "In the default configuration, Keycloak is responsible for managing the roles and deciding who can access which routes."
msgstr "在默认配置中，Keycloak负责管理角色并决定谁可以访问哪些路由。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:391
#, fuzzy
msgid "To configure the protected routes using the `@RolesAllowed` annotation or the `application.properties` file, check the xref:security-openid-connect.adoc[Using OpenID Connect Adapter to Protect JAX-RS Applications] and xref:security-authorization.adoc[Security Authorization] guides. For more details, check the xref:security.adoc[Security guide]."
msgstr "要使用 `@RolesAllowed` 注解或 `application.properties` 文件配置受保护的路由，请查看《 link:security-openid-connect.html[使用 OpenID 连接适配器保护 JAX-RS 应用程序] 》和《 link:security-authorization.html[安全授权] 》指南。更多细节，请查看 link:security.html[安全指南] 。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:392
#, fuzzy, no-wrap
msgid "Access to Public Resources"
msgstr "获取公共资源"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:395
#, fuzzy
msgid "If you'd like to access a public resource without `quarkus-keycloak-authorization` trying to apply its policies to it then you need to create a `permit` HTTP Policy configuration in `application.properties` as documented in the xref:security-authorization.adoc[Security Authorization] guide."
msgstr "如果你想访问一个公共资源，而不试图将其政策应用于 `quarkus-keycloak-authorization` ，那么你需要在 `application.properties` 中创建一个 `permit` HTTP政策配置，正如 link:security-authorization.html[安全授权] 指南中所记载的那样。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:397
#, fuzzy
msgid "Disabling a policy check using a Keycloak Authorization Policy such as:"
msgstr "使用Keycloak授权策略禁用一个策略检查，如：。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:402
#, no-wrap
msgid ""
"quarkus.keycloak.policy-enforcer.paths.1.path=/api/public\n"
"quarkus.keycloak.policy-enforcer.paths.1.enforcement-mode=DISABLED\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:405
#, fuzzy
msgid "is no longer required."
msgstr "不再需要了。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:407
#, fuzzy
msgid "If you'd like to block an access to the public resource to anonymous users then you can create an enforcing Keycloak Authorization Policy:"
msgstr "如果你想阻止匿名用户访问公共资源，那么你可以创建一个强制的Keycloak授权策略。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:412
#, no-wrap
msgid ""
"quarkus.keycloak.policy-enforcer.paths.1.path=/api/public-enforcing\n"
"quarkus.keycloak.policy-enforcer.paths.1.enforcement-mode=ENFORCING\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:415
#, fuzzy
msgid "Note only the default tenant configuration applies when controlling an anonymous access to the public resource is required."
msgstr "注意只有在需要控制公共资源的匿名访问时才适用默认租户配置。"

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:416
#, fuzzy, no-wrap
msgid "Multi-Tenancy"
msgstr "多租户"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:419
#, fuzzy
msgid "It is possible to configure multiple policy enforcer configurations, one per each tenant, similarly to how it can be done for xref:security-openid-connect-multitenancy.adoc[Multi-Tenant OpenID Connect Service Applications]."
msgstr "可以配置多个策略执行者的配置，每个租户一个，类似于 link:security-openid-connect-multitenancy.html[多租户OpenID连接服务应用程序] 的配置方式。"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:421
#, fuzzy
msgid "For example:"
msgstr "比如说。"

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:425
#, no-wrap
msgid "quarkus.keycloak.policy-enforcer.enable=true\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:430
#, no-wrap
msgid ""
"# Default Tenant\n"
"quarkus.oidc.auth-server-url=${keycloak.url}/realms/quarkus\n"
"quarkus.oidc.client-id=quarkus-app\n"
"quarkus.oidc.credentials.secret=secret\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:435
#, no-wrap
msgid ""
"quarkus.keycloak.policy-enforcer.enforcement-mode=PERMISSIVE\n"
"quarkus.keycloak.policy-enforcer.paths.1.name=Permission Resource\n"
"quarkus.keycloak.policy-enforcer.paths.1.path=/api/permission\n"
"quarkus.keycloak.policy-enforcer.paths.1.claim-information-point.claims.static-claim=static-claim\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:437
#, no-wrap
msgid "# Service Tenant\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:441
#, no-wrap
msgid ""
"quarkus.oidc.service-tenant.auth-server-url=${keycloak.url}/realms/quarkus\n"
"quarkus.oidc.service-tenant.client-id=quarkus-app\n"
"quarkus.oidc.service-tenant.credentials.secret=secret\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:446
#, no-wrap
msgid ""
"quarkus.keycloak.service-tenant.policy-enforcer.enforcement-mode=PERMISSIVE\n"
"quarkus.keycloak.service-tenant.policy-enforcer.paths.1.name=Permission Resource Service\n"
"quarkus.keycloak.service-tenant.policy-enforcer.paths.1.path=/api/permission\n"
"quarkus.keycloak.service-tenant.policy-enforcer.paths.1.claim-information-point.claims.static-claim=static-claim\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:449
#, no-wrap
msgid "# WebApp Tenant\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:455
#, no-wrap
msgid ""
"quarkus.oidc.webapp-tenant.auth-server-url=${keycloak.url}/realms/quarkus\n"
"quarkus.oidc.webapp-tenant.client-id=quarkus-app\n"
"quarkus.oidc.webapp-tenant.credentials.secret=secret\n"
"quarkus.oidc.webapp-tenant.application-type=web-app\n"
"quarkus.oidc.webapp-tenant.roles.source=accesstoken\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-keycloak-authorization.adoc:460
#, no-wrap
msgid ""
"quarkus.keycloak.webapp-tenant.policy-enforcer.enforcement-mode=PERMISSIVE\n"
"quarkus.keycloak.webapp-tenant.policy-enforcer.paths.1.name=Permission Resource WebApp\n"
"quarkus.keycloak.webapp-tenant.policy-enforcer.paths.1.path=/api/permission\n"
"quarkus.keycloak.webapp-tenant.policy-enforcer.paths.1.claim-information-point.claims.static-claim=static-claim\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:462
#, fuzzy, no-wrap
msgid "Configuration Reference"
msgstr "配置参考"

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:465
msgid "The configuration is based on the official https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_filter[Keycloak Policy Enforcer Configuration]. If you are looking for more details about the different configuration options, please take a look at this documentation,"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-keycloak-authorization.adoc:468
#, no-wrap
msgid "References"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:471
msgid "https://www.keycloak.org/documentation.html[Keycloak Documentation]"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:472
msgid "https://www.keycloak.org/docs/latest/authorization_services/index.html[Keycloak Authorization Services Documentation]"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:473
msgid "https://openid.net/connect/[OpenID Connect]"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:474
msgid "https://tools.ietf.org/html/rfc7519[JSON Web Token]"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-keycloak-authorization.adoc:474
msgid "xref:security.adoc[Quarkus Security]"
msgstr ""
