# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-12-06 10:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/reactive-event-bus.adoc:6
#, fuzzy, no-wrap
msgid "Using the event bus"
msgstr "使用事件总线"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:17
#, fuzzy
msgid "Quarkus allows different beans to interact using asynchronous events, thus promoting loose-coupling.  The messages are sent to _virtual addresses_.  It offers 3 types of delivery mechanism:"
msgstr "Quarkus允许不同的Bean使用异步事件进行交互，从而促进松散耦合。消息被发送至 _虚拟地址_ 。它提供了3种类型的传递机制。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:19
#, fuzzy
msgid "point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round-robin is applied;"
msgstr "点对点 - 发送消息，一个消费者接收。如果有几个消费者监听该地址，则采用轮回的方式。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:20
#, fuzzy
msgid "publish/subscribe - publish a message, all the consumers listening to the address are receiving the message;"
msgstr "发布/订阅 - 发布一个消息，所有监听该地址的消费者都会收到该消息。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:21
#, fuzzy
msgid "request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous-fashion"
msgstr "request/reply - 发送消息并期望得到回应。接收者可以以异步方式对消息作出回应"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:23
#, fuzzy
msgid "All these delivery mechanisms are non-blocking, and are providing one of the fundamental brick to build reactive applications."
msgstr "所有这些交付机制都是无阻塞的，并且为构建反应式应用提供了基本的砖块之一。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:26
#, fuzzy
msgid "The asynchronous message passing feature allows replying to messages which is not supported by Reactive Messaging.  However, it is limited to single-event behavior (no stream) and to local messages."
msgstr "异步消息传递功能允许对消息进行回复，这是反应式消息传递不支持的。然而，它只限于单事件行为（没有流）和本地消息。"

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:27
#, fuzzy, no-wrap
msgid "Installing"
msgstr "安装"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:31
#, fuzzy
msgid "This mechanism uses the Vert.x EventBus, so you need to enable the `vertx` extension to use this feature.  If you are creating a new project, set the `extensions` parameter as follows:"
msgstr "这个机制使用Vert.x EventBus，所以你需要启用 `vertx` 扩展来使用这个功能。如果你正在创建一个新的项目，设置 `extensions` 参数如下。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:38
#, fuzzy
msgid "If you have an already created project, the `vertx` extension can be added to an existing Quarkus project with the `add-extension` command:"
msgstr "如果你有一个已经创建的项目， `vertx` 扩展可以通过 `add-extension` 命令添加到现有的Quarkus项目中。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:43
#, fuzzy
msgid "Otherwise, you can manually add this to the dependencies section of your build file:"
msgstr "否则，你可以手动将其添加到你的构建文件的依赖项中。"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:45
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:51
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:54
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:57
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-vertx\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:59
#, fuzzy, no-wrap
msgid "Consuming events"
msgstr "消耗性事件"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:62
#, fuzzy
msgid "To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:"
msgstr "要消耗事件，请使用 `io.quarkus.vertx.ConsumeEvent` 注解。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:66
#: upstream/_guides/reactive-event-bus.adoc:115
#: upstream/_guides/reactive-event-bus.adoc:241
#: upstream/_guides/reactive-event-bus.adoc:313
#: upstream/_guides/reactive-event-bus.adoc:349
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:68
#: upstream/_guides/reactive-event-bus.adoc:117
#: upstream/_guides/reactive-event-bus.adoc:351
#, no-wrap
msgid "import io.quarkus.vertx.ConsumeEvent;\n"
msgstr "import io.quarkus.vertx.ConsumeEvent;\n"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:70
#: upstream/_guides/reactive-event-bus.adoc:353
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:73
#: upstream/_guides/reactive-event-bus.adoc:125
#: upstream/_guides/reactive-event-bus.adoc:356
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class GreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:79
#, no-wrap
msgid ""
"    @ConsumeEvent                           // <1>\n"
"    public String consume(String name) {    // <2>\n"
"        return name.toUpperCase();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:81
#, fuzzy
msgid "If not set, the address is the fully qualified name of the bean, for instance, in this snippet it's `org.acme.vertx.GreetingService`."
msgstr "如果没有设置，地址就是Bean的完全合格名称，例如，在这个片段中是 `org.acme.vertx.GreetingService` 。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:82
#, fuzzy
msgid "The method parameter is the message body. If the method returns _something_ it's the message response."
msgstr "方法参数是消息主体。如果该方法返回 _一些东西_ ，那就是消息响应。"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:87
#, fuzzy
msgid "By default, the code consuming the event must be _non-blocking_, as it's called on the Vert.x event loop.  If your processing is blocking, use the `blocking` attribute:"
msgstr "默认情况下，消耗事件的代码必须 _是非阻塞_ 的，因为它是在Vert.x事件循环中调用的。如果你的处理是阻塞的，请使用 `blocking` 属性。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:94
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\", blocking = true)\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:97
#, fuzzy
msgid "Alternatively, you can annotate your method with `@io.smallrye.common.annotation.Blocking`:"
msgstr "另外，你可以用 `@io.smallrye.common.annotation.Blocking` 来注释你的方法。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:104
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\")\n"
"@Blocking\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:108
#, fuzzy
msgid "When using `@Blocking`, it ignores the value of the `blocking` attribute of `@ConsumeEvent`.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic."
msgstr "当使用 `@Blocking` ，它忽略了 `@ConsumeEvent` 的 `blocking` 属性的值。关于这个主题的进一步细节，请参见 link:quarkus-reactive-architecture.html[Quarkus Reactive Architecture 文档] 。"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:111
#, fuzzy
msgid "Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:"
msgstr "异步处理也可以通过返回一个 `io.smallrye.mutiny.Uni` 或一个 `java.util.concurrent.CompletionStage` 。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:122
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:131
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public CompletionStage<String> consume(String name) {\n"
"        // return a CompletionStage completed when the processing is finished.\n"
"        // You can also fail the CompletionStage explicitly\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:138
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public Uni<String> process(String name) {\n"
"        // return an Uni completed when the processing is finished.\n"
"        // You can also fail the Uni explicitly\n"
"    }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:141
#, fuzzy, no-wrap
msgid "Mutiny"
msgstr "叛变"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:145
#, fuzzy
msgid "The previous example uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "前面的例子使用了Mutiny反应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的反应式编程库] 。"

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:147
#, fuzzy, no-wrap
msgid "Configuring the address"
msgstr "配置地址"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:150
#, fuzzy
msgid "The `@ConsumeEvent` annotation can be configured to set the address:"
msgstr " `@ConsumeEvent` 注释可以被配置为设置地址。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:157
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")               // <1>\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:159
#, fuzzy
msgid "Receive the messages sent to the `greeting` address"
msgstr "接收发送到 `greeting` 地址的信息"

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:160
#, fuzzy, no-wrap
msgid "Replying"
msgstr "回复"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:164
#, fuzzy
msgid "The _return_ value of a method annotated with `@ConsumeEvent` is used as response to the incoming message.  For instance, in the following snippet, the returned `String` is the response."
msgstr "用 `@ConsumeEvent` 注释的方法的 _返回值_ 被用来作为对传入消息的响应。例如，在下面的片段中，返回的 `String` 是响应。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:171
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:174
#, fuzzy
msgid "You can also return a `Uni<T>` or a `CompletionStage<T>` to handle asynchronous reply:"
msgstr "你也可以返回一个 `Uni<T>` 或一个 `CompletionStage<T>` 来处理异步回复。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:181
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public Uni<String> consume2(String name) {\n"
"    return Uni.createFrom().item(() -> name.toUpperCase()).emitOn(executor);\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:186
#, fuzzy
msgid "You can inject an `executor` if you use the Context Propagation extension:"
msgstr "如果你使用Context Propagation扩展，你可以注入一个 `executor` 。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:189
#, no-wrap
msgid "@Inject ManagedExecutor executor;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:192
#, fuzzy
msgid "Alternatively, you can use the default Quarkus worker pool using:"
msgstr "或者，你可以使用默认的Quarkus工作池，使用。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:196
#, no-wrap
msgid "Executor executor = Infrastructure.getDefaultWorkerPool();\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:199
#, fuzzy, no-wrap
msgid "Implementing fire and forget interactions"
msgstr "实施火与忘的互动"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:204
#, fuzzy
msgid "You don't have to reply to received messages.  Typically, for a _fire and forget_ interaction, the messages are consumed and the sender does not need to know about it.  To implement this, your consumer method just returns `void`"
msgstr "你不需要回复收到的消息。通常情况下，对于 _fire and forget_ 的交互，消息被消耗掉了，发送者不需要知道这件事。为了实现这一点，你的消费者方法只是返回 `void` "

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:211
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(String event) {\n"
"    // Do something with the event\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:213
#, fuzzy, no-wrap
msgid "Dealing with messages"
msgstr "处理信息"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:216
#, fuzzy
msgid "As said above, this mechanism is based on the Vert.x event bus. So, you can also use `Message` directly:"
msgstr "如上所述，这种机制是基于Vert.x事件总线的。所以，你也可以直接使用 `Message` 。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:224
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(Message<String> msg) {\n"
"    System.out.println(msg.address());\n"
"    System.out.println(msg.body());\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:226
#, fuzzy, no-wrap
msgid "Handling Failures"
msgstr "处理故障"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:229
#, fuzzy
msgid "If a method annotated with `@ConsumeEvent` throws an exception then:"
msgstr "如果一个用 `@ConsumeEvent` 注解的方法抛出了一个异常，那么。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:231
#, fuzzy
msgid "if a reply handler is set then the failure is propagated back to the sender via an `io.vertx.core.eventbus.ReplyException` with code `ConsumeEvent#FAILURE_CODE` and the exception message,"
msgstr "如果设置了一个回复处理程序，那么失败就会通过一个带有代码 `ConsumeEvent#FAILURE_CODE` 和异常消息的 `io.vertx.core.eventbus.ReplyException` 传播回发送者。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:232
#, fuzzy
msgid "if no reply handler is set then the exception is rethrown (and wrapped in a `RuntimeException` if necessary) and can be handled by the default exception handler, i.e. `io.vertx.core.Vertx#exceptionHandler()`."
msgstr "如果没有设置回复处理程序，那么异常会被重新抛出（如果需要的话，会被包裹在一个 `RuntimeException` ），并且可以由默认的异常处理程序来处理，即 `io.vertx.core.Vertx#exceptionHandler()` 。"

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:233
#, fuzzy, no-wrap
msgid "Sending messages"
msgstr "发出信息"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:237
#, fuzzy
msgid "Ok, we have seen how to receive messages, let's now switch to the _other side_: the sender.  Sending and publishing messages use the Vert.x event bus:"
msgstr "好了，我们已经看到了如何接收消息，现在让我们切换到 _另一边_ ：发送者。发送和发布消息使用Vert.x的事件总线。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:245
#: upstream/_guides/reactive-event-bus.adoc:317
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.core.eventbus.EventBus;\n"
"import io.vertx.mutiny.core.eventbus.Message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:251
#: upstream/_guides/reactive-event-bus.adoc:323
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:254
#: upstream/_guides/reactive-event-bus.adoc:326
#, no-wrap
msgid ""
"@Path(\"/async\")\n"
"public class EventResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:257
#, no-wrap
msgid ""
"    @Inject\n"
"    EventBus bus;                                       // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:266
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(String name) {\n"
"        return bus.<String>request(\"greeting\", name)        // <2>\n"
"                .onItem().transform(Message::body);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:268
#, fuzzy
msgid "Inject the Event bus"
msgstr "注入事件总线"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:269
#, fuzzy
msgid "Send a message to the address `greeting`. Message payload is `name`"
msgstr "发送消息到地址 `greeting` 。消息的有效载荷是 `name` "

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:271
#, fuzzy
msgid "The `EventBus` object provides methods to:"
msgstr " `EventBus` 对象提供了以下方法。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:273
#, fuzzy
msgid "`send` a message to a specific address - one single consumer receives the message."
msgstr " `send` 一个消息到一个特定的地址 - 一个单一的消费者收到该消息。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:274
#, fuzzy
msgid "`publish` a message to a specific address - all consumers receive the messages."
msgstr " `publish` 向一个特定的地址发送消息--所有的消费者都会收到这些消息。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:275
#, fuzzy
msgid "`send` a message and expect reply asynchronously"
msgstr " `send` 留言并期待回复"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:276
#, fuzzy
msgid "`send` a message and expect reply in a blocking manner"
msgstr " `send` 留言并期待回复"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:288
#, no-wrap
msgid ""
"// Case 1\n"
"bus.<String>requestAndForget(\"greeting\", name);\n"
"// Case 2\n"
"bus.publish(\"greeting\", name);\n"
"// Case 3\n"
"Uni<String> response = bus.<String>request(\"address\", \"hello, how are you?\")\n"
"        .onItem().transform(Message::body);\n"
"// Case 4\n"
"String response = bus.<String>requestAndAwait(\"greeting\", name).body();\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:290
#, fuzzy, no-wrap
msgid "Putting things together - bridging HTTP and messages"
msgstr "把东西放在一起--桥接HTTP和消息"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:296
#, fuzzy
msgid "Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.  It uses the request/reply dispatching mechanism.  Instead of implementing the business logic inside the Jakarta REST endpoint, we are sending a message.  This message is consumed by another bean and the response is sent using the _reply_ mechanism."
msgstr "让我们重新审视一个问候的HTTP端点，并使用异步消息传递将调用委托给一个分离的bean。它使用了请求/回复的调度机制。我们不是在JAX-RS端点内实现业务逻辑，而是发送一个消息。这个消息被另一个Bean消费，响应则使用 _回复_ 机制发送。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:298
#, fuzzy
msgid "First create a new project using:"
msgstr "首先创建一个新的项目，使用。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:304
#, fuzzy
msgid "You can already start the application in _dev mode_ using:"
msgstr "你已经可以在 _开发模式_ 下使用启动应用程序。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:308
#, fuzzy
msgid "Then, creates a new Jakarta REST resource with the following content:"
msgstr "然后，创建一个新的JAX-RS资源，内容如下。"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:310
#, fuzzy, no-wrap
msgid "src/main/java/org/acme/vertx/EventResource.java"
msgstr "src/main/java/org/acme/vertx/EventResource.java"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:329
#, no-wrap
msgid ""
"    @Inject\n"
"    EventBus bus;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:338
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(String name) {\n"
"        return bus.<String>request(\"greeting\", name)            // <1>\n"
"                .onItem().transform(Message::body);            // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:340
#, fuzzy
msgid "send the `name` to the `greeting` address and request a response"
msgstr "将 `name` 发送到 `greeting` 地址，并要求作出回应。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:341
#, fuzzy
msgid "when we get the response, extract the body and send it to the user"
msgstr "当我们得到响应时，提取正文并将其发送给用户"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:344
#, fuzzy
msgid "If you call this endpoint, you will wait and get a timeout. Indeed, no one is listening.  So, we need a consumer listening on the `greeting` address. Create a `GreetingService` bean with the following content:"
msgstr "如果你调用这个端点，你会等待并得到一个超时。的确，没有人在听。所以，我们需要一个消费者来监听 `greeting` 地址。创建一个 `GreetingService` bean，内容如下。"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:346
#, fuzzy, no-wrap
msgid "src/main/java/org/acme/vertx/GreetingService.java"
msgstr "src/main/java/org/acme/vertx/GreetingService.java"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:361
#, no-wrap
msgid ""
"    @ConsumeEvent(\"greeting\")\n"
"    public String greeting(String name) {\n"
"        return \"Hello \" + name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:363
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:366
#, fuzzy
msgid "This bean receives the name, and returns the greeting message."
msgstr "这个Bean接收名字，并返回问候信息。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:368
#, fuzzy
msgid "Now, open your browser to http://localhost:8080/async/Quarkus, and you should see:"
msgstr "现在，打开你的浏览器到 http://localhost:8080/async/Quarkus 你应该看到。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:372
#, no-wrap
msgid "Hello Quarkus\n"
msgstr "Hello Quarkus\n"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:375
#, fuzzy
msgid "To better understand, let's detail how the HTTP request/response has been handled:"
msgstr "为了更好地理解，让我们详细介绍一下HTTP请求/响应是如何被处理的。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:377
#, fuzzy
msgid "The request is received by the `hello` method"
msgstr "该请求由 `hello` 方法接收"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:378
#, fuzzy
msgid "a message containing the _name_ is sent to the event bus"
msgstr "含有该 _名称_ 的消息被发送到事件总线。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:379
#, fuzzy
msgid "Another bean receives this message and computes the response"
msgstr "另一个Bean收到这个消息，并计算出响应。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:380
#, fuzzy
msgid "This response is sent back using the reply mechanism"
msgstr "该响应使用回复机制发回"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:381
#, fuzzy
msgid "Once the reply is received by the sender, the content is written to the HTTP response"
msgstr "一旦发送方收到回复，内容就会被写入HTTP回复中"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:383
#, fuzzy
msgid "This application can be packaged using:"
msgstr "这个应用程序可以用以下方式打包。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:387
#, fuzzy
msgid "You can also compile it as a native executable with:"
msgstr "你也可以把它编译成一个本地可执行文件。"

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:390
#, fuzzy, no-wrap
msgid "Using codecs"
msgstr "使用编解码器"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:395
msgid "The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default codec for local delivery.  So you can exchange objects as follows:"
msgstr "link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x事件总线] 使用编解码器来 _序列化_ 和 _反序列化_ 对象。Quarkus为本地交付提供了一个默认的编解码器。所以你可以按以下方式交换对象："

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:405
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(String name) {\n"
"    return bus.<String>request(\"greeting\", new MyName(name))\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:410
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\")\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \" + name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:413
msgid "If you want to use a specific codec, you need to explicitly set it on both ends:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:424
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(String name) {\n"
"    return bus.<String>request(\"greeting\", name,\n"
"        new DeliveryOptions().setCodecName(MyNameCodec.class.getName())) // <1>\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:429
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\", codec = MyNameCodec.class)            // <2>\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \"+name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:431
msgid "Set the name of the codec to use to send the message"
msgstr "设置用于发送消息的编解码器的名称"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:431
msgid "Set the codec to use to receive the message"
msgstr "设置用于接收信息的编解码器"
