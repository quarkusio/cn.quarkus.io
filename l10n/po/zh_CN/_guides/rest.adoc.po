msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _guides/rest.adoc
#, fuzzy
msgid "Writing REST Services with Quarkus REST (formerly RESTEasy Reactive)"
msgstr "使用 Quarkus REST（前身为 RESTEasy Reactive）编写 REST 服务"

#: _guides/rest.adoc
#, fuzzy
msgid "This guide explains how to write REST Services with Quarkus REST in Quarkus."
msgstr "本指南介绍如何在 Quarkus 中使用 Quarkus REST 编写 REST 服务。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"This is the reference guide for Quarkus REST.\n"
"For a more lightweight introduction, please refer to the xref:rest-json.adoc[Writing JSON REST services guides]."
msgstr "这是 Quarkus REST 的参考指南。如需更轻量级的介绍，请参阅《 xref:rest-json.adoc[编写 JSON REST 服务指南] 》。"

#: _guides/rest.adoc
#, fuzzy
msgid "What is Quarkus REST?"
msgstr "什么是 Quarkus REST？"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Quarkus REST is a new link:{jaxrsspec}[Jakarta REST (formerly known as JAX-RS)]\n"
"implementation written from the ground up to work on our\n"
"common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n"
"Quarkus and consequently moving a lot of work to build time."
msgstr "Quarkus REST 是一种全新的 link:{jaxrsspec}[Jakarta REST（以前称为 JAX-RS）] 实现，它从头开始编写，可在我们通用的 link:https://vertx.io/[Vert.x] 层上运行，因此是完全反应式的，同时还与 Quarkus 紧密集成，从而将大量工作转移到构建时间。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You should be able to use it in place of any Jakarta REST implementation, but on top of that it has\n"
"great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n"
"of what Jakarta REST provides."
msgstr "您可以用它来替代任何 Jakarta REST 实现，而且它还能为阻塞和非阻塞端点提供出色的性能，并在 Jakarta REST 的基础上提供大量新功能。"

#: _guides/rest.adoc
#, fuzzy
msgid "Writing endpoints"
msgstr "编写端点"

#: _guides/rest.adoc
#, fuzzy
msgid "Getting started"
msgstr "开始"

#: _guides/rest.adoc
#, fuzzy
msgid "Add the following import to your build file:"
msgstr "在构建文件中添加以下导入"

#: _guides/rest.adoc
msgid "pom.xml"
msgstr "pom.xml"

#: _guides/rest.adoc
msgid "build.gradle"
msgstr "build.gradle"

#: _guides/rest.adoc
#, fuzzy
msgid "You can now write your first endpoint in the `org.acme.rest.Endpoint` class:"
msgstr "现在，您可以在 `org.acme.rest.Endpoint` 类中编写第一个端点："

#: _guides/rest.adoc
#, fuzzy
msgid "Terminology"
msgstr "术语"

#: _guides/rest.adoc
#, fuzzy
msgid "REST"
msgstr "REST"

#: _guides/rest.adoc
#, fuzzy
msgid "https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]"
msgstr "link:https://en.wikipedia.org/wiki/Representational_state_transfer[呈现状态转移]"

#: _guides/rest.adoc
#, fuzzy
msgid "Endpoint"
msgstr "终点"

#: _guides/rest.adoc
#, fuzzy
msgid "Java method which is called to serve a REST call"
msgstr "为 REST 调用提供服务的 Java 方法"

#: _guides/rest.adoc
#, fuzzy
msgid "URL / URI (Uniform Resource Locator / Identifier)"
msgstr "URL / URI（统一资源定位器/标识符）"

#: _guides/rest.adoc
#, fuzzy
msgid "Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])"
msgstr "用于标识 REST 资源的位置（ link:https://tools.ietf.org/html/rfc7230#section-2.7[规范）]"

#: _guides/rest.adoc
msgid "Resource"
msgstr "资源"

#: _guides/rest.adoc
#, fuzzy
msgid "Represents your domain object. This is what your API serves and modifies. Also called an `entity` in Jakarta REST."
msgstr "代表您的域对象。这是您的 API 服务和修改的对象。在 Jakarta REST 中也称为 `entity` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "Representation"
msgstr "代表性"

#: _guides/rest.adoc
#, fuzzy
msgid "How your resource is represented on the wire, can vary depending on content types"
msgstr "内容类型不同，资源在网络上的表现形式也会不同"

#: _guides/rest.adoc
#, fuzzy
msgid "Content type"
msgstr "内容类型"

#: _guides/rest.adoc
#, fuzzy
msgid "Designates a particular representation (also called a media type), for example `text/plain` or `application/json`"
msgstr "指定一种特定的表示形式（也称为媒体类型），例如 `text/plain` 或 `application/json`"

#: _guides/rest.adoc
#, fuzzy
msgid "HTTP"
msgstr "超文本传输协定"

#: _guides/rest.adoc
#, fuzzy
msgid "Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])"
msgstr "路由 REST 调用的基础线路协议（参见 link:https://tools.ietf.org/html/rfc7230[HTTP 规范）]"

#: _guides/rest.adoc
#, fuzzy
msgid "HTTP request"
msgstr "HTTP 请求"

#: _guides/rest.adoc
#, fuzzy
msgid "The request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body"
msgstr "HTTP 调用的请求部分，由 HTTP 方法、目标 URI、标题和可选的信息体组成"

#: _guides/rest.adoc
#, fuzzy
msgid "HTTP response"
msgstr "HTTP 响应"

#: _guides/rest.adoc
#, fuzzy
msgid "The response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body"
msgstr "HTTP 调用的响应部分，由 HTTP 响应状态、标题和可选的信息体组成"

#: _guides/rest.adoc
#, fuzzy
msgid "Declaring endpoints: URI mapping"
msgstr "声明端点URI 映射"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Any class annotated with a link:{jaxrsapi}/jakarta/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n"
"provided they have an HTTP method annotation (see below)."
msgstr "注解的任何类都可以将其方法作为 REST 端点公开。 link:{jaxrsapi}/jakarta/ws/rs/Path.html[@Path] 注解的任何类，只要具有 HTTP 方法注解（见下文），都可以将其方法作为 REST 端点公开。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"That link:{jaxrsapi}/jakarta/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n"
"be empty, or contain a prefix such as `rest` or `rest/V1`."
msgstr "该 link:{jaxrsapi}/jakarta/ws/rs/Path.html[@Path] 注释定义了这些方法的 URI 前缀。它可以是空的，也可以包含一个前缀，如 `rest` 或 `rest/V1` 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Each exposed endpoint method can in turn have another link:{jaxrsapi}/jakarta/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n"
"class annotation. For example, this defines a `rest/hello` endpoint:"
msgstr "每个暴露的端点方法又可以有另一个 link:{jaxrsapi}/jakarta/ws/rs/Path.html[@Path] 注解，并将其添加到包含类的注解中。例如，这定义了一个 `rest/hello` 端点："

#: _guides/rest.adoc
#, fuzzy
msgid "See <<uri-parameters,URI parameters>> for more information about URI mapping."
msgstr "有关 URI 映射的更多信息，请参阅 URI xref:uri-parameters[参数] 。"

#: _guides/rest.adoc
#, fuzzy
msgid "You can set the root path for all rest endpoints using the `@ApplicationPath` annotation, as shown below."
msgstr "您可以使用 `@ApplicationPath` 注解为所有休息端点设置根路径，如下所示。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"This will cause all rest endpoints to be resolve relative to `/api`, so the endpoint above with `@Path(\"rest\")` would\n"
"be accessible at `/api/rest/`. You can also set the `quarkus.rest.path` build time property to set the root path if you\n"
"don't want to use an annotation."
msgstr "这将导致所有其余端点都相对于 `/api` 进行解析，因此上面的 `@Path(\"rest\")` 端点可以在 `/api/rest/` 访问。如果不想使用注解，也可以设置 `quarkus.rest.path` 的构建时间属性来设置根路径。"

#: _guides/rest.adoc
#, fuzzy
msgid "Declaring endpoints: HTTP methods"
msgstr "声明端点HTTP 方法"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n"
"method will be mapped to the method:"
msgstr "每个端点方法都必须使用以下注解之一进行注解，该注解定义了将映射到该方法的 HTTP 方法："

#: _guides/rest.adoc
#, fuzzy
msgid "HTTP method annotations"
msgstr "HTTP 方法注解"

#: _guides/rest.adoc
#, fuzzy
msgid "Annotation"
msgstr "注释"

#: _guides/rest.adoc
#, fuzzy
msgid "Usage"
msgstr "使用方法"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/GET.html[`@GET`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/GET.html[@GET]"

#: _guides/rest.adoc
#, fuzzy
msgid "Obtain a resource representation, should not modify state, link:{httpspec}#section-4.2.2[idempotent] (link:{httpspec}#section-4.3.1[HTTP docs])"
msgstr "获取资源表示，不应修改状态， link:{httpspec}#section-4.2.2[idempotent] （ link:{httpspec}#section-4.3.1[HTTP 文档）]"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/HEAD.html[`@HEAD`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/HEAD.html[@HEAD]"

#: _guides/rest.adoc
#, fuzzy
msgid "Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])"
msgstr "获取资源的元数据，类似于无正文的 `GET` （ link:{httpspec}#section-4.3.2[HTTP 文档）]"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/POST.html[`@POST`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/POST.html[@POST]"

#: _guides/rest.adoc
#, fuzzy
msgid "Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])"
msgstr "创建资源并获取其链接（ link:{httpspec}#section-4.3.3[HTTP 文档）]"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/PUT.html[`@PUT`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/PUT.html[@PUT]"

#: _guides/rest.adoc
#, fuzzy
msgid "Replace a resource or create one, should be link:{httpspec}#section-4.2.2[idempotent] (link:{httpspec}#section-4.3.4[HTTP docs])"
msgstr "替换资源或创建资源，应为 link:{httpspec}#section-4.2.2[empotent] （ link:{httpspec}#section-4.3.4[HTTP 文档）]"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/DELETE.html[`@DELETE`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/DELETE.html[@DELETE]"

#: _guides/rest.adoc
#, fuzzy
msgid "Delete an existing resource, link:{httpspec}#section-4.2.2[idempotent]  (link:{httpspec}#section-4.3.5[HTTP docs])"
msgstr "删除现有资源， link:{httpspec}#section-4.2.2[idempotent] （ link:{httpspec}#section-4.3.5[HTTP 文档）]"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/OPTIONS.html[`@OPTIONS`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/OPTIONS.html[@OPTIONS]"

#: _guides/rest.adoc
#, fuzzy
msgid "Obtain information about a resource, link:{httpspec}#section-4.2.2[idempotent] (link:{httpspec}#section-4.3.7[HTTP docs])"
msgstr "获取资源信息， link:{httpspec}#section-4.2.2[idempotent] （ link:{httpspec}#section-4.3.7[HTTP 文档）]"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/PATCH.html[`@PATCH`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/PATCH.html[@PATCH]"

#: _guides/rest.adoc
#, fuzzy
msgid "Update a resource, or create one, not link:{httpspec}#section-4.2.2[idempotent] (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])"
msgstr "更新资源或创建资源，非 link:{httpspec}#section-4.2.2[empotent] （ link:https://tools.ietf.org/html/rfc5789#section-2[HTTP 文档）]"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can also declare other HTTP methods by declaring them as an annotation with the\n"
"link:{jaxrsapi}/jakarta/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:"
msgstr "您还可以通过使用 link:{jaxrsapi}/jakarta/ws/rs/HttpMethod.html[@HttpMethod] 注解来声明其他 HTTP 方法："

#: _guides/rest.adoc
#, fuzzy
msgid "Declaring endpoints: representation / content types"
msgstr "声明端点：表示法/内容类型"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Each endpoint method may consume or produce specific resource representations, which are indicated by\n"
"the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains\n"
"link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:"
msgstr "每种端点方法都可以消费或生成特定的资源表示，这些表示由 HTTP link:{httpspec}#section-3.1.1.5[Content-Type] 标头表示，而 HTTP 标头又包含 link:{httpspec}#section-3.1.1.1[MIME（媒体类型）] 值，如以下所示："

#: _guides/rest.adoc
#, fuzzy
msgid "`text/plain` which is the default for any endpoint returning a `String`."
msgstr "`text/plain` 这是任何返回 的端点的默认值。 `String`"

#: _guides/rest.adoc
#, fuzzy
msgid "`text/html` for HTML (such as with xref:qute.adoc[Qute templating])"
msgstr "`text/html` 用于 HTML（如使用 xref:qute.adoc[Qute 模板）]"

#: _guides/rest.adoc
#, fuzzy
msgid "`application/json` for a <<json,JSON REST endpoint>>"
msgstr "`application/json` 的 xref:json[JSON REST 端点]"

#: _guides/rest.adoc
#, fuzzy
msgid "`text/*` which is a sub-type wildcard for any text media type"
msgstr "`text/*` 它是任何文本媒体类型的子类型通配符"

#: _guides/rest.adoc
#, fuzzy
msgid "`\\*/*` which is a wildcard for any media type"
msgstr "`*/*` 是任何媒体类型的通配符"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You may annotate your endpoint class with the link:{jaxrsapi}/jakarta/ws/rs/Produces.html[`@Produces`]\n"
"or link:{jaxrsapi}/jakarta/ws/rs/Consumes.html[`@Consumes`] annotations, which\n"
"allow you to specify one or more media types that your endpoint may accept as HTTP request body\n"
"or produce as HTTP response body. Those class annotations apply to each method."
msgstr "您可以使用 link:{jaxrsapi}/jakarta/ws/rs/Produces.html[@Produces] 或 link:{jaxrsapi}/jakarta/ws/rs/Consumes.html[@Consumes] 注解来注解端点类，通过这些注解，您可以指定一种或多种媒体类型，端点可将其作为 HTTP 请求体接受或作为 HTTP 响应体生成。这些类注解适用于每个方法。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Any method may also be annotated with the link:{jaxrsapi}/jakarta/ws/rs/Produces.html[`@Produces`]\n"
"or link:{jaxrsapi}/jakarta/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n"
"case they override any eventual class annotation."
msgstr "也可以用 link:{jaxrsapi}/jakarta/ws/rs/Produces.html[@Produces] 或 link:{jaxrsapi}/jakarta/ws/rs/Consumes.html[@Consumes] 注解，在这种情况下，它们会覆盖任何最终的类注解。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The link:{jaxrsapi}/jakarta/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n"
"can use to point to specific pre-defined media types."
msgstr "该 link:{jaxrsapi}/jakarta/ws/rs/core/MediaType.html[MediaType] 类中有许多常量，可以用来指向特定的预定义媒体类型。"

#: _guides/rest.adoc
#, fuzzy
msgid "See the <<negotiation>> section for more information."
msgstr "更多信息，请参阅 <<negotiation>> 部分。"

#: _guides/rest.adoc
#, fuzzy
msgid "Accessing request parameters"
msgstr "访问请求参数"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n"
"or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven])."
msgstr "不要忘记使用 `-parameters` (javac) 或 `<parameters>` 或 `<maven.compiler.parameters>` ( link:https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven] ) 配置编译器以生成参数名信息。"

#: _guides/rest.adoc
#, fuzzy
msgid "The following HTTP request elements may be obtained by your endpoint method:"
msgstr "以下 HTTP 请求元素可通过端点方法获取："

#: _guides/rest.adoc
#, fuzzy
msgid "HTTP request parameter annotations"
msgstr "HTTP 请求参数注释"

#: _guides/rest.adoc
#, fuzzy
msgid "HTTP element"
msgstr "HTTP 元素"

#: _guides/rest.adoc
#, fuzzy
msgid "[[path-parameter]]Path parameter"
msgstr " 路径参数"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestPath.html[`@RestPath`] (or nothing)"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestPath.html[@RestPath] (或什么都没有）"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]),\n"
"see <<uri-parameters,URI parameters>> for more information."
msgstr "URI 模板参数（ link:https://tools.ietf.org/html/rfc6570[URI 模板规范] 的简化版本），更多信息请参阅 URI xref:uri-parameters[参数] 。"

#: _guides/rest.adoc
#, fuzzy
msgid "Query parameter"
msgstr "查询参数"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestQuery.html[`@RestQuery`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestQuery.html[@RestQuery]"

#: _guides/rest.adoc
#, fuzzy
msgid "The value of a https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]"
msgstr "link:https://tools.ietf.org/html/rfc3986#section-3.4[URI 查询参数] 的值"

#: _guides/rest.adoc
#, fuzzy
msgid "Header"
msgstr "页眉"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestHeader.html[`@RestHeader`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestHeader.html[@RestHeader]"

#: _guides/rest.adoc
#, fuzzy
msgid "The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]"
msgstr "link:https://tools.ietf.org/html/rfc7230#section-3.2[HTTP 标头] 的值"

#: _guides/rest.adoc
#, fuzzy
msgid "Cookie"
msgstr "饼干"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestCookie.html[`@RestCookie`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestCookie.html[@RestCookie]"

#: _guides/rest.adoc
#, fuzzy
msgid "The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]"
msgstr "link:https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie] 的值"

#: _guides/rest.adoc
#, fuzzy
msgid "Form parameter"
msgstr "表格参数"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestForm.html[`@RestForm`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestForm.html[@RestForm]"

#: _guides/rest.adoc
#, fuzzy
msgid "The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]"
msgstr "link:https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL 编码 FORM] 的值"

#: _guides/rest.adoc
#, fuzzy
msgid "Matrix parameter"
msgstr "矩阵参数"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestMatrix.html[`@RestMatrix`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestMatrix.html[@RestMatrix]"

#: _guides/rest.adoc
#, fuzzy
msgid "The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]"
msgstr "link:https://tools.ietf.org/html/rfc3986#section-3.3[URI 路径段参数] 的值"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"For each of those annotations, you may specify the name of the element they refer to,\n"
"otherwise, they will use the name of the annotated method parameter."
msgstr "对于每个注解，您都可以指定它们所引用的元素名称，否则，它们将使用注解方法参数的名称。"

#: _guides/rest.adoc
#, fuzzy
msgid "If a client made the following HTTP call:"
msgstr "如果客户端进行了以下 HTTP 调用："

#: _guides/rest.adoc
#, fuzzy
msgid "Then you could obtain all the various parameters with this endpoint method:"
msgstr "然后，您就可以通过这种端点方法获取所有各种参数："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestPath.html[`@RestPath`]\n"
"annotation is optional: any parameter whose name matches an existing URI\n"
"template variable will be automatically assumed to have link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestPath.html[`@RestPath`]."
msgstr "注释是可选的。 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestPath.html[@RestPath] 注释是可选的：任何名称与现有 URI 模板变量相匹配的参数都会被自动假定为具有 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestPath.html[@RestPath] ."

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can also use any of the Jakarta REST annotations link:{jaxrsapi}/jakarta/ws/rs/PathParam.html[`@PathParam`],\n"
"link:{jaxrsapi}/jakarta/ws/rs/QueryParam.html[`@QueryParam`],\n"
"link:{jaxrsapi}/jakarta/ws/rs/HeaderParam.html[`@HeaderParam`],\n"
"link:{jaxrsapi}/jakarta/ws/rs/CookieParam.html[`@CookieParam`],\n"
"link:{jaxrsapi}/jakarta/ws/rs/FormParam.html[`@FormParam`] or\n"
"link:{jaxrsapi}/jakarta/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n"
"but they require you to specify the parameter name."
msgstr "您也可以使用任何 Jakarta REST 注释 link:{jaxrsapi}/jakarta/ws/rs/PathParam.html[@PathParam] , link:{jaxrsapi}/jakarta/ws/rs/QueryParam.html[@QueryParam] , link:{jaxrsapi}/jakarta/ws/rs/HeaderParam.html[@HeaderParam] , link:{jaxrsapi}/jakarta/ws/rs/CookieParam.html[@CookieParam] , link:{jaxrsapi}/jakarta/ws/rs/FormParam.html[@FormParam] 或 link:{jaxrsapi}/jakarta/ws/rs/MatrixParam.html[@MatrixParam] 但它们要求您指定参数名称。"

#: _guides/rest.adoc
#, fuzzy
msgid "See <<parameter-mapping>> for more advanced use-cases."
msgstr "更多高级用例请参见 <<parameter-mapping>> 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"When an exception occurs in Quarkus REST request parameter handling code, the exception is not printed by default to the log (for security reasons).\n"
"This can sometimes make it hard to understand why certain HTTP status codes are returned (as the Jakarta REST mandates the use of non-intuitive error codes in various cases).\n"
"In such cases, users are encouraged to set the logging level for the `org.jboss.resteasy.reactive.server.handlers.ParameterHandler` category to `DEBUG` like so:"
msgstr "当 Quarkus REST 请求参数处理代码出现异常时，默认情况下不会将异常打印到日志中（出于安全原因）。这有时会让人难以理解为什么会返回某些 HTTP 状态代码（因为 Jakarta REST 规定在各种情况下使用非直观的错误代码）。在这种情况下，建议用户将 `org.jboss.resteasy.reactive.server.handlers.ParameterHandler` 类别的日志级别设置为 `DEBUG` ，如图所示："

#: _guides/rest.adoc
#, fuzzy
msgid "Grouping parameters in a custom class"
msgstr "在自定义类中分组参数"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can group your request parameters in a container class instead of declaring them as method parameters to you endpoint,\n"
"so we can rewrite the previous example like this:"
msgstr "你可以在容器类中对请求参数进行分组，而不是将它们作为方法参数声明给端点，因此我们可以这样重写前面的示例："

#: _guides/rest.adoc
#, fuzzy
msgid "`BeanParam` is required to comply with the Jakarta REST specification so that libraries like OpenAPI can introspect the parameters."
msgstr "`BeanParam` 需要符合 Jakarta REST 规范，以便 OpenAPI 等库可以自省参数。"

#: _guides/rest.adoc
#, fuzzy
msgid "[[declaring-uri-parameters]] Declaring URI parameters"
msgstr " 声明 URI 参数"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can declare URI parameters and use regular expressions in your path, so for instance\n"
"the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n"
"`/hello/stef/0x23`:"
msgstr "您可以在路径中声明 URI 参数并使用正则表达式，例如，以下端点将为 `/hello/stef/23` 和 `/hello` 的请求提供服务，但不会为 `/hello/stef/0x23` 的请求提供服务："

#: _guides/rest.adoc
#, fuzzy
msgid "Accessing the request body"
msgstr "访问请求正文"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n"
"<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n"
"its HTTP representation to the Java type of the parameter."
msgstr "任何没有注释的方法参数在从 HTTP 表示映射到参数的 Java 类型后，都会收到方法正文[ link:[1, id=\"_footnoteref_1\", class=\"footnote\", href=\"#_footnotedef_1\", title=\"View footnote.\"] ]。"

#: _guides/rest.adoc
#, fuzzy
msgid "The following parameter types will be supported out of the box:"
msgstr "开箱即支持以下参数类型："

#: _guides/rest.adoc
#, fuzzy
msgid "Request body parameter types"
msgstr "请求正文参数类型"

#: _guides/rest.adoc
msgid "Type"
msgstr "类型"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jdkapi}/java/io/File.html[`File`]"
msgstr "link:{jdkapi}/java/io/File.html[File]"

#: _guides/rest.adoc
#, fuzzy
msgid "The entire request body in a temporary file"
msgstr "临时文件中的整个请求正文"

#: _guides/rest.adoc
msgid "`byte[]`"
msgstr "`byte[]`"

#: _guides/rest.adoc
#, fuzzy
msgid "The entire request body, not decoded"
msgstr "整个请求正文，未解码"

#: _guides/rest.adoc
#, fuzzy
msgid "`char[]`"
msgstr "`char[]`"

#: _guides/rest.adoc
#, fuzzy
msgid "The entire request body, decoded"
msgstr "解码后的整个请求正文"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jdkapi}/java/lang/String.html[`String`]"
msgstr "link:{jdkapi}/java/lang/String.html[String]"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jdkapi}/java/io/InputStream.html[`InputStream`]"
msgstr "link:{jdkapi}/java/io/InputStream.html[InputStream]"

#: _guides/rest.adoc
#, fuzzy
msgid "The request body in a blocking stream"
msgstr "阻塞流中的请求正文"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jdkapi}/java/io/Reader.html[`Reader`]"
msgstr "link:{jdkapi}/java/io/Reader.html[Reader]"

#: _guides/rest.adoc
#, fuzzy
msgid "All Java primitives and their wrapper classes"
msgstr "所有 Java 基元及其封装类"

#: _guides/rest.adoc
#, fuzzy
msgid "Java primitive types"
msgstr "Java 原始类型"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]"
msgstr "link:{jdkapi}/java/math/BigDecimal.html[BigDecimal] , link:{jdkapi}/java/math/BigInteger.html[BigInteger]"

#: _guides/rest.adoc
#, fuzzy
msgid "Large integers and decimals."
msgstr "大整数和小数"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"link:{jsonpapi}/jakarta/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/jakarta/json/JsonObject.html[`JsonObject`],\n"
"link:{jsonpapi}/jakarta/json/JsonStructure.html[`JsonStructure`], link:{jsonpapi}/jakarta/json/JsonValue.html[`JsonValue`]"
msgstr "link:{jsonpapi}/jakarta/json/JsonArray.html[JsonArray] , link:{jsonpapi}/jakarta/json/JsonObject.html[JsonObject] , link:{jsonpapi}/jakarta/json/JsonStructure.html[JsonStructure] , link:{jsonpapi}/jakarta/json/JsonValue.html[JsonValue]"

#: _guides/rest.adoc
#, fuzzy
msgid "JSON value types"
msgstr "JSON 值类型"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{vertxapi}/io/vertx/core/buffer/Buffer.html[`Buffer`]"
msgstr "link:{vertxapi}/io/vertx/core/buffer/Buffer.html[Buffer]"

#: _guides/rest.adoc
#, fuzzy
msgid "Vert.x Buffer"
msgstr "Vert.x 缓冲区"

#: _guides/rest.adoc
#, fuzzy
msgid "any other type"
msgstr "其他类型"

#: _guides/rest.adoc
#, fuzzy
msgid "Will be <<json,mapped from JSON to that type>>"
msgstr "将 xref:json[从 JSON 映射到该类型]"

#: _guides/rest.adoc
#, fuzzy
msgid "You can add support for more <<readers-writers,body parameter types>>."
msgstr "您可以添加对更多 xref:readers-writers[正文参数类型的] 支持。"

#: _guides/rest.adoc
#, fuzzy
msgid "Handling Multipart Form data"
msgstr "处理多部分表单数据"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"To handle HTTP requests that have `multipart/form-data` as their content type, you can use the regular\n"
"link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestForm.html[`@RestForm`] annotation, but we have special types\n"
"that allow you to access the parts as files or as entities.\n"
"Let us look at an example of its use."
msgstr "要处理内容类型为 `multipart/form-data` 的 HTTP 请求，您可以使用常规的 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestForm.html[@RestForm] 注解，但我们有特殊的类型，允许您以文件或实体的形式访问这些部分。让我们来看一个使用示例。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Assuming an HTTP request containing a file upload, a JSON entity and a form value containing a string description, we could write\n"
"the following endpoint:"
msgstr "假设 HTTP 请求包含文件上传、JSON 实体和包含字符串描述的表单值，我们可以编写以下端点："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The `description` parameter will contain the data contained in the part of HTTP request called `description` (because\n"
"link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestForm.html[`@RestForm`] does not define a value, the field name is used),\n"
"while the `file` parameter will contain data about the uploaded file in the `image` part of HTTP request, and\n"
"the `person` parameter will read the `Person` entity using the `JSON` <<json,body reader>>."
msgstr "`description` 参数将包含 HTTP 请求中名为 `description` 的部分所包含的数据（因为 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestForm.html[@RestForm] 没有定义值，所以使用了字段名），而 `file` 参数将包含 HTTP 请求 `image` 部分中上传文件的数据， `person` 参数将使用 `JSON` xref:json[body] 阅读器读取 `Person` 实体。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The size of every part in a multipart request must conform to the value of `quarkus.http.limits.max-form-attribute-size`, for which the default is 2048 bytes.\n"
"Any request with a part of a size exceeding this configuration will result in HTTP status code 413."
msgstr "多部分请求中每个部分的大小必须符合 `quarkus.http.limits.max-form-attribute-size` 的值，默认值为 2048 字节。任何部分大小超过此配置值的请求都将导致 HTTP 状态代码 413。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/multipart/FileUpload.html[`FileUpload`]\n"
"provides access to various metadata of the uploaded file. If however all you need is a handle to the uploaded file, `java.nio.file.Path` or `java.io.File` could be used."
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/multipart/FileUpload.html[FileUpload] 可以访问上传文件的各种元数据。如果只需要上传文件的句柄，可以使用 `java.nio.file.Path` 或 `java.io.File` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "If you need access to all uploaded files for all parts regardless of their names, you can do it with `@RestForm(FileUpload.ALL) List<FileUpload>`."
msgstr "如果您需要访问所有部件的所有上传文件（无论文件名如何），可以使用 `@RestForm(FileUpload.ALL) List<FileUpload>` 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/PartType.html[`@PartType`] is used to aid\n"
"in deserialization of the corresponding part of the request into the desired Java type. It is only required if\n"
"you need to use a <<readers-writers,special body parameter type>> for that particular parameter."
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/PartType.html[@PartType] 用于帮助将请求的相应部分反序列化为所需的 Java 类型。只有在需要为特定参数使用 xref:readers-writers[特殊的主体参数类型] 时才需要使用它。"

#: _guides/rest.adoc
#, fuzzy
msgid "Just like for any other request parameter type, you can also group them into a <<parameter-grouping,container class>>."
msgstr "与其他请求参数类型一样，您也可以将它们归入一个 xref:parameter-grouping[容器类] 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"When handling file uploads, it is very important to move the file to permanent storage (like a database, a dedicated file system or a cloud storage) in your code that handles the POJO.\n"
"Otherwise, the file will no longer be accessible when the request terminates.\n"
"Moreover, if `quarkus.http.body.delete-uploaded-files-on-end` is set to true, Quarkus will delete the uploaded file when the HTTP response is sent. If the setting is disabled,\n"
"the file will reside on the file system of the server (in the directory defined by the `quarkus.http.body.uploads-directory` configuration option), but as the uploaded files are saved\n"
"with a UUID file name and no additional metadata is saved, these files are essentially a random dump of files."
msgstr "处理文件上传时，在处理 POJO 的代码中将文件移至永久存储（如数据库、专用文件系统或云存储）非常重要。否则，当请求终止时，将无法再访问该文件。此外，如果 `quarkus.http.body.delete-uploaded-files-on-end` 设置为 true，Quarkus 将在发送 HTTP 响应时删除上传的文件。如果禁用该设置，文件将驻留在服务器的文件系统中（在 `quarkus.http.body.uploads-directory` 配置选项所定义的目录中），但由于上传的文件是以 UUID 文件名保存的，而且没有保存额外的元数据，因此这些文件基本上是随机转储的文件。"

#: _guides/rest.adoc
#, fuzzy
msgid "When a Resource method needs to handle various types of multipart requests, then the `org.jboss.resteasy.reactive.server.multipart.MultipartFormDataInput` method type can be used as provides access to all the parts of the request."
msgstr "当资源方法需要处理各种类型的多部分请求时，可以使用 `org.jboss.resteasy.reactive.server.multipart.MultipartFormDataInput` 方法类型来访问请求的所有部分。"

#: _guides/rest.adoc
#, fuzzy
msgid "The following code shows a simple example where we iterate over the parts and return a list of aggregated data:"
msgstr "下面的代码展示了一个简单的示例，我们遍历各个部分并返回一个汇总数据列表："

#: _guides/rest.adoc
#, fuzzy
msgid "Handling malformed input"
msgstr "处理畸形输入"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"As part of reading the multipart body, Quarkus REST invokes the proper MessageBodyReaderlink:{jaxrsapi}/jakarta/ws/rs/ext/MessageBodyReader.html[`MessageBodyReader`] for each part of the request.\n"
"If an `IOException` occurs for one of these parts (for example if Jackson was unable to deserialize a JSON part), then a `org.jboss.resteasy.reactive.server.multipart.MultipartPartReadingException` is thrown.\n"
"If this exception is not handled by the application as mentioned in <<exception-mapping>>, an HTTP 400 response is returned by default."
msgstr "作为读取多部分正文的一部分，Quarkus REST 会针对请求的每一部分调用适当的 MessageBodyReader link:{jaxrsapi}/jakarta/ws/rs/ext/MessageBodyReader.html[MessageBodyReader] 来读取请求的每一部分。如果其中一部分出现 `IOException` （例如，Jackson 无法反序列化 JSON 部分），则会抛出 `org.jboss.resteasy.reactive.server.multipart.MultipartPartReadingException` 。如果应用程序未按 <<exception-mapping>> 中所述处理该异常，则默认返回 HTTP 400 响应。"

#: _guides/rest.adoc
#, fuzzy
msgid "Multipart output"
msgstr "多部分输出"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Similarly, Quarkus REST can produce Multipart Form data to allow users download files from the server. For example, we could write a POJO\n"
"that will hold the information we want to expose as:"
msgstr "同样，Quarkus REST 可以生成多部分表单数据，让用户从服务器下载文件。例如，我们可以编写一个 POJO，用来保存我们想以以下方式公开的信息："

#: _guides/rest.adoc
#, fuzzy
msgid "And then expose this POJO via a Resource like so:"
msgstr "然后像这样通过一个资源公开这个 POJO："

#: _guides/rest.adoc
#, fuzzy
msgid "Additionally, you can also manually append the parts of the form using the class `MultipartFormDataOutput` as:"
msgstr "此外，您还可以使用 `MultipartFormDataOutput` as 类手动添加表单的各个部分："

#: _guides/rest.adoc
#, fuzzy
msgid "This last approach allows you adding extra headers to the output part."
msgstr "最后一种方法允许你在输出部分添加额外的标题。"

#: _guides/rest.adoc
#, fuzzy
msgid "For the time being, returning Multipart data is limited to be blocking endpoints."
msgstr "目前，返回 Multipart 数据仅限于阻塞端点。"

#: _guides/rest.adoc
#, fuzzy
msgid "Returning a response body"
msgstr "返回响应体"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"In order to return an HTTP response, simply return the resource you want from your method. The method\n"
"return type and its optional content type will be used to decide how to serialise it to the HTTP\n"
"response (see the <<negotiation>> section for more advanced information)."
msgstr "要返回 HTTP 响应，只需从方法中返回所需的资源即可。方法的返回类型及其可选的内容类型将用于决定如何将其序列化到 HTTP 响应（更多高级信息请参阅 <<negotiation>> 部分）。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n"
"and any other type will be mapped <<json,from that type to JSON>>."
msgstr "您可以返回从 xref:resource-types[HTTP 响应] 中读取的任何预定义类型，任何其他类型都将 xref:json[从该类型] 映射 xref:json[到 JSON] 。"

#: _guides/rest.adoc
#, fuzzy
msgid "In addition, the following return types are also supported:"
msgstr "此外，还支持以下返回类型："

#: _guides/rest.adoc
#, fuzzy
msgid "Additional response body parameter types"
msgstr "附加响应体参数类型"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jdkapi}/java/nio/file/Path.html[`Path`]"
msgstr "link:{jdkapi}/java/nio/file/Path.html[Path]"

#: _guides/rest.adoc
#, fuzzy
msgid "The contents of the file specified by the given path"
msgstr "由给定路径指定的文件内容"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/PathPart.html[`PathPart`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/PathPart.html[PathPart]"

#: _guides/rest.adoc
#, fuzzy
msgid "The partial contents of the file specified by the given path"
msgstr "由给定路径指定的文件的部分内容"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/FilePart.html[`FilePart`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/FilePart.html[FilePart]"

#: _guides/rest.adoc
#, fuzzy
msgid "The partial contents of a file"
msgstr "文件的部分内容"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{vertxapi}/io/vertx/core/file/AsyncFile.html[`AsyncFile`]"
msgstr "link:{vertxapi}/io/vertx/core/file/AsyncFile.html[AsyncFile]"

#: _guides/rest.adoc
#, fuzzy
msgid "Vert.x AsyncFile, which can be in full, or partial"
msgstr "Vert.x AsyncFile，可以是全部文件，也可以是部分文件"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`],\n"
"link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or\n"
"link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n"
"that resolve to one of the mentioned return types."
msgstr "或者，您也可以返回一种 xref:reactive[反应式类型] ，例如 link:{mutinyapi}/io/smallrye/mutiny/Uni.html[Uni] , link:{mutinyapi}/io/smallrye/mutiny/Multi.html[Multi] 或 link:{jdkapi}/java/util/concurrent/CompletionStage.html[CompletionStage] 解析为上述返回类型之一。"

#: _guides/rest.adoc
#, fuzzy
msgid "Setting other response properties"
msgstr "设置其他响应属性"

#: _guides/rest.adoc
#, fuzzy
msgid "Manually setting the response"
msgstr "手动设置响应"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If you need to set more properties on the HTTP response than just the body, such as the status code\n"
"or headers, you can make your method return `org.jboss.resteasy.reactive.RestResponse` from a resource method.\n"
"An example of this could look like:"
msgstr "如果需要在 HTTP 响应上设置更多属性，而不仅仅是正文，例如状态代码或标头，可以让方法从资源方法返回 `org.jboss.resteasy.reactive.RestResponse` 。示例如下"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can also use the Jakarta REST type link:{jaxrsapi}/jakarta/ws/rs/core/Response.html[`Response`] but it is\n"
"not strongly typed to your entity."
msgstr "您也可以使用 Jakarta REST 类型 link:{jaxrsapi}/jakarta/ws/rs/core/Response.html[Response] 但它与您的实体不是强类型的。"

#: _guides/rest.adoc
#, fuzzy
msgid "Using annotations"
msgstr "使用注释"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Alternatively, if you only need to set the status code and / or HTTP headers with static values, you can use `@org.jboss.resteasy.reactive.ResponseStatus` and /or `ResponseHeader` respectively.\n"
"An example of this could look like:"
msgstr "另外，如果只需要设置状态代码和/或 HTTP 头信息的静态值，可以分别使用 `@org.jboss.resteasy.reactive.ResponseStatus` 和/或 `ResponseHeader` 。示例如下"

#: _guides/rest.adoc
#, fuzzy
msgid "Redirect support"
msgstr "重定向支持"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"When handling a `@POST`, `@PUT` or `@DELETE` endpoint, it is common practice to redirect to a `@GET` endpoint after the action has been performed to allow the user to reload the page without triggering the action a second time.\n"
"There are multiple ways to achieve this."
msgstr "在处理 `@POST` 、 `@PUT` 或 `@DELETE` 端点时，通常的做法是在执行操作后重定向到 `@GET` 端点，以便用户重新加载页面，而无需再次触发操作。实现这一目的有多种方法。"

#: _guides/rest.adoc
#, fuzzy
msgid "Using RestResponse"
msgstr "使用 RestResponse"

#: _guides/rest.adoc
#, fuzzy
msgid "Using `RestResponse` as the return type while making sure the proper redirection URI is created can be done as in the following example:"
msgstr "使用 `RestResponse` 作为返回类型，同时确保创建了正确的重定向 URI，可参考下面的示例："

#: _guides/rest.adoc
#, fuzzy
msgid "Using RedirectException"
msgstr "使用 RedirectException"

#: _guides/rest.adoc
#, fuzzy
msgid "Users can also throw `jakarta.ws.rs.RedirectionException` from a method body to get Quarkus REST to perform the desired redirect."
msgstr "用户还可以从方法主体中抛出 `jakarta.ws.rs.RedirectionException` ，让 Quarkus REST 执行所需的重定向。"

#: _guides/rest.adoc
#, fuzzy
msgid "Async/reactive support"
msgstr "异步/反应式支持"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If your endpoint method needs to accomplish an asynchronous or reactive task before\n"
"being able to answer, you can declare your method to return the\n"
"link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n"
"case the current HTTP request will be automatically suspended after your method, until\n"
"the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n"
"which will be mapped to a response exactly according to the previously described rules:"
msgstr "如果你的端点方法需要先完成异步或反应任务，然后才能回答问题，你可以声明你的方法返回 link:{mutinyapi}/io/smallrye/mutiny/Uni.html[Uni] 类型（来自 link:https://smallrye.io/smallrye-mutiny/[Mutiny] ），在这种情况下，当前 HTTP 请求将在你的方法之后自动暂停，直到返回的 link:{mutinyapi}/io/smallrye/mutiny/Uni.html[Uni] 实例解析为一个值，该值将完全按照之前描述的规则映射到响应中："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"This allows you to not block the event-loop thread while the book is being fetched from the\n"
"database, and allows Quarkus to serve more requests until your book is ready to\n"
"be sent to the client and terminate this request.\n"
"See <<execution-model,Execution Model documentation>> for more information."
msgstr "这样，在从数据库获取图书时，就不会阻塞事件循环线程，并允许 Quarkus 提供更多请求，直到图书准备好发送到客户端并终止此请求。更多信息，请参阅 xref:execution-model[执行模型文档] 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n"
"type is also supported."
msgstr "也支持 link:{jdkapi}/java/util/concurrent/CompletionStage.html[CompletionStage] 也支持返回类型。"

#: _guides/rest.adoc
#, fuzzy
msgid "Streaming support"
msgstr "流媒体支持"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If you want to stream your response element by element, you can make your endpoint method return a\n"
"link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n"
"This is especially useful for streaming text or binary data."
msgstr "如果要逐个元素流式传输响应，可以让端点方法返回一个 link:{mutinyapi}/io/smallrye/mutiny/Multi.html[Multi] 类型（来自 link:https://smallrye.io/smallrye-mutiny/[Mutiny] ）。这对于流式传输文本或二进制数据尤其有用。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"This example, using https://github.com/quarkiverse/quarkus-reactive-messaging-http[Reactive Messaging HTTP] shows how to stream\n"
"text data:"
msgstr "本例使用 link:https://github.com/quarkiverse/quarkus-reactive-messaging-http[反应式消息 HTTP] 展示了如何流式传输文本数据："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Response filters are **not** invoked on streamed responses, because they would give a false\n"
"impression that you can set headers or HTTP status codes, which is not true after the initial\n"
"response.\n"
"Exception mappers are also not invoked because part of the response may already have been written."
msgstr "响应过滤器 *不会* 在流式响应中调用，因为它们会给人一种错觉，以为你可以设置头或 HTTP 状态代码，而在初始响应之后就不是这样了。异常映射器也不会被调用，因为部分响应可能已经被写入。"

#: _guides/rest.adoc
#, fuzzy
msgid "Customizing headers and status"
msgstr "自定义标题和状态"

#: _guides/rest.adoc
#, fuzzy
msgid "If you need to set custom HTTP headers and / or the HTTP response, then you can return `org.jboss.resteasy.reactive.RestMulti` instead, like this:"
msgstr "如果需要设置自定义 HTTP 头信息和/或 HTTP 响应，则可以像这样返回 `org.jboss.resteasy.reactive.RestMulti` ："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"In more advanced cases where the headers and / or status can only be obtained from the results of an async call, the `RestMulti.fromUniResponse` needs to be used.\n"
"Here is an example of such a use case:"
msgstr "在更高级的情况下，如果只能从异步调用的结果中获取报头和/或状态，则需要使用 `RestMulti.fromUniResponse` 。下面就是这样一个用例："

#: _guides/rest.adoc
#, fuzzy
msgid "Concurrent stream element processing"
msgstr "并行流元素处理"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"By default, `RestMulti` ensures serial/sequential order of the items/elements produced by the wrapped\n"
"`Multi` by using a value of 1 for the demand signaled to the publishers. To enable concurrent\n"
"processing/generation of multiple items, use `withDemand(long demand)`."
msgstr "默认情况下， `RestMulti` 通过使用向发布者发出的需求信号值 1 来确保由封装的 `Multi` 生成的项目/元素的序列/顺序。要同时处理/生成多个项目，请使用 `withDemand(long demand)` 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Using a demand higher than 1 is useful when multiple items shall be returned and the production of each\n"
"item takes some time, i.e. when parallel/concurrent production improves the service response time. Be\n"
"aware the concurrent processing also requires more resources and puts a higher load on services or\n"
"resources that are needed to produce the items. Also consider using `Multi.capDemandsTo(long)` and\n"
"`Multi.capDemandsUsing(LongFunction)`."
msgstr "当需要返回多个项目且每个项目的生产都需要一些时间时，即并行/并发生产可改善服务响应时间时，使用大于 1 的需求量是有用的。需要注意的是，并发处理也需要更多的资源，并且会给生产项目所需的服务或资源带来更高的负载。还可以考虑使用 `Multi.capDemandsTo(long)` 和 `Multi.capDemandsUsing(LongFunction)` 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The example below produces 5 (JSON) strings, but the _order_ of the strings in the returned JSON array\n"
"is not guaranteed. The below example also works for JSON objects and not just simple types."
msgstr "下面的示例产生 5 个（JSON）字符串，但不保证返回的 JSON 数组中字符串的 _顺序_ 。下面的示例也适用于 JSON 对象，而不仅仅是简单类型。"

#: _guides/rest.adoc
#, fuzzy
msgid "Example response, the order is non-deterministic."
msgstr "回应示例，顺序是不确定的。"

#: _guides/rest.adoc
#, fuzzy
msgid "Returning multiple JSON objects"
msgstr "返回多个 JSON 对象"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"By default, `RestMulti` returns items/elements produced by the wrapped `Multi` as a JSON array, if the\n"
"media-type is `application/json`. To return separate JSON objects that are not wrapped in a JSON array,\n"
"use `encodeAsArray(false)` (`encodeAsArray(true)` is the default). Note that streaming multiple\n"
"objects this way requires a slightly different parsing on the client side, but objects can be parsed and\n"
"consumed as they appear without having to deserialize a possibly huge result at once."
msgstr "默认情况下，如果媒体类型为 `application/json` ， `RestMulti` 将以 JSON 数组的形式返回由封装的 `Multi` 生成的项/元素。要返回未封装在 JSON 数组中的单独 JSON 对象，请使用 `encodeAsArray(false)` （默认为 `encodeAsArray(true)` ）。需要注意的是，以这种方式流式传输多个对象需要在客户端进行略微不同的解析，但对象可以在出现时被解析和消费，而不必一次性反序列化可能很大的结果。"

#: _guides/rest.adoc
#, fuzzy
msgid "The example below produces 5 (JSON) strings, that are not wrapped in an array, like this:"
msgstr "下面的示例生成了 5 个（JSON）字符串，这些字符串没有封装在数组中，就像这样："

#: _guides/rest.adoc
#, fuzzy
msgid "Server-Sent Event (SSE) support"
msgstr "支持服务器发送事件（SSE）"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If you want to stream JSON objects in your response, you can use\n"
"https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n"
"by just annotating your endpoint method with\n"
"link:{jaxrsapi}/jakarta/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n"
"and specifying that each element should be <<json,serialised to JSON>> with\n"
"`@RestStreamElementType(MediaType.APPLICATION_JSON)`."
msgstr "如果您想在响应中流式传输 link:https://html.spec.whatwg.org/multipage/server-sent-events.html[JSON] 对象，只需在端点方法中注释 link:{jaxrsapi}/jakarta/ws/rs/Produces.html[@Produces(MediaType.SERVER_SENT_EVENTS)] 注释您的端点方法，并指定每个元素都应 xref:json[序列化为 JSON] ， `@RestStreamElementType(MediaType.APPLICATION_JSON)` 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Sometimes it's useful to create a customized SSE message, for example if you need to specify the `event` field of a SSE message to distinguish various event types.\n"
"A resource method may return `Multi<jakarta.ws.rs.sse.OutboundSseEvent>` and an injected `jakarta.ws.rs.sse.Sse` can be used to create `OutboundSseEvent` instances."
msgstr "有时，创建定制的 SSE 消息很有用，例如，如果需要指定 SSE 消息的 `event` 字段以区分各种事件类型，就可以创建定制的 SSE 消息。资源方法可能会返回 `Multi<jakarta.ws.rs.sse.OutboundSseEvent>` ，注入的 `jakarta.ws.rs.sse.Sse` 可用于创建 `OutboundSseEvent` 实例。"

#: _guides/rest.adoc
#, fuzzy
msgid "Inject the server-side entry point for creating ``OutboundSseEvent``s."
msgstr "注入用于创建 `OutboundSseEvent` s 的服务器端入口点。"

#: _guides/rest.adoc
#, fuzzy
msgid "Create a new outbound event builder."
msgstr "创建一个新的外发事件生成器。"

#: _guides/rest.adoc
#, fuzzy
msgid "Set the event name, i.e. the value of the `event` field of a SSE message."
msgstr "设置事件名称，即 SSE 报文 `event` 字段的值。"

#: _guides/rest.adoc
#, fuzzy
msgid "Set the data, i.e. the value of the `data` field of a SSE message."
msgstr "设置数据，即 SSE 报文 `data` 字段的值。"

#: _guides/rest.adoc
#, fuzzy
msgid "Manipulation of the returned HTTP headers and status code is not possible via `RestMulti.fromUniResponse` because when returning SSE responses the headers and status code cannot be delayed until the response becomes available."
msgstr "无法通过 `RestMulti.fromUniResponse` 对返回的 HTTP 头信息和状态代码进行操作，因为在返回 SSE 响应时，头信息和状态代码不能延迟到响应可用时才返回。"

#: _guides/rest.adoc
#, fuzzy
msgid "Controlling HTTP Caching features"
msgstr "控制 HTTP 缓存功能"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Quarkus REST provides the link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/Cache.html[`@Cache`]\n"
"and link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/NoCache.html[`@NoCache`] annotations to facilitate\n"
"handling HTTP caching semantics, i.e. setting the 'Cache-Control' HTTP header."
msgstr "Quarkus REST 提供了 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/Cache.html[@Cache] 和 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/NoCache.html[@NoCache] 注解，以方便处理 HTTP 缓存语义，即设置 \"Cache-Control \"HTTP 头信息。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"These annotations can be placed either on a Resource Method or a Resource Class (in which case it applies to all Resource Methods of the class that do *not* contain the same annotation) and allow users\n"
"to return domain objects and not have to deal with building up the `Cache-Control` HTTP header explicitly."
msgstr "这些注解可以放在资源方法或资源类上（在这种情况下，它适用于该类中 *不* 包含相同注解的所有资源方法），允许用户返回域对象，而不必明确建立 `Cache-Control` HTTP 标头。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"While link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/Cache.html[`@Cache`]\n"
"builds a complex `Cache-Control` header, link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/NoCache.html[`@NoCache`]\n"
"is a simplified notation to say that you don't want anything cached; i.e. `Cache-Control: nocache`."
msgstr "而 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/Cache.html[@Cache] 则会生成一个复杂的 `Cache-Control` 标头、 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/NoCache.html[@NoCache] 是一种简化符号，表示不希望缓存任何内容，即 `Cache-Control: nocache` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "More information on the `Cache-Control` header and be found in link:https://datatracker.ietf.org/doc/html/rfc7234[RFC 7234]"
msgstr "有关 `Cache-Control` 标头的更多信息，请参阅 link:https://datatracker.ietf.org/doc/html/rfc7234[RFC 7234] 。"

#: _guides/rest.adoc
#, fuzzy
msgid "Accessing context objects"
msgstr "访问上下文对象"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"There are a number of contextual objects that the framework will give you, if your endpoint\n"
"method takes parameters of the following type:"
msgstr "如果您的端点方法需要以下类型的参数，框架会提供一些上下文对象："

#: _guides/rest.adoc
#, fuzzy
msgid "Contextual objects"
msgstr "上下文对象"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/core/HttpHeaders.html[`HttpHeaders`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/core/HttpHeaders.html[HttpHeaders]"

#: _guides/rest.adoc
#, fuzzy
msgid "All the request headers"
msgstr "所有请求标头"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/container/ResourceInfo.html[`ResourceInfo`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/container/ResourceInfo.html[ResourceInfo]"

#: _guides/rest.adoc
#, fuzzy
msgid "Information about the current endpoint method and class (requires reflection)"
msgstr "有关当前端点方法和类的信息（需要反射）"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/core/SecurityContext.html[`SecurityContext`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/core/SecurityContext.html[SecurityContext]"

#: _guides/rest.adoc
#, fuzzy
msgid "Access to the current user and roles"
msgstr "访问当前用户和角色"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/SimpleResourceInfo.html[`SimpleResourceInfo`]"
msgstr "link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/SimpleResourceInfo.html[SimpleResourceInfo]"

#: _guides/rest.adoc
#, fuzzy
msgid "Information about the current endpoint method and class (no reflection required)"
msgstr "有关当前端点方法和类的信息（无需反射）"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/core/UriInfo.html[`UriInfo`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/core/UriInfo.html[UriInfo]"

#: _guides/rest.adoc
#, fuzzy
msgid "Provides information about the current endpoint and application URI"
msgstr "提供有关当前端点和应用程序 URI 的信息"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/core/Application.html[`Application`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/core/Application.html[Application]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: Current Jakarta REST application class"
msgstr "高级：当前的 Jakarta REST 应用程序类"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/core/Configuration.html[`Configuration`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/core/Configuration.html[Configuration]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: Configuration about the deployed Jakarta REST application"
msgstr "高级：配置已部署的 Jakarta REST 应用程序"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/ext/Providers.html[`Providers`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/ext/Providers.html[Providers]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: Runtime access to Jakarta REST providers"
msgstr "高级：运行时访问 Jakarta REST 提供程序"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/core/Request.html[`Request`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/core/Request.html[Request]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: Access to the current HTTP method and <<preconditions>>"
msgstr "高级：访问当前 HTTP 方法和 <<preconditions>>"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/core/ResourceContext.html[`ResourceContext`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/core/ResourceContext.html[ResourceContext]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: access to instances of endpoints"
msgstr "高级：访问端点实例"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/spi/ServerRequestContext.html[`ServerRequestContext`]"
msgstr "link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/spi/ServerRequestContext.html[ServerRequestContext]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: Quarkus REST access to the current request/response"
msgstr "高级：Quarkus REST 访问当前请求/响应"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/sse/Sse.html[`Sse`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/sse/Sse.html[Sse]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: Complex SSE use-cases"
msgstr "先进：复杂的 SSE 用例"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{vertxapi}/io/vertx/core/http/HttpServerRequest.html[`HttpServerRequest`]"
msgstr "link:{vertxapi}/io/vertx/core/http/HttpServerRequest.html[HttpServerRequest]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: Vert.x HTTP Request"
msgstr "高级：Vert.x HTTP 请求"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{vertxapi}/io/vertx/core/http/HttpServerResponse.html[`HttpServerResponse`]"
msgstr "link:{vertxapi}/io/vertx/core/http/HttpServerResponse.html[HttpServerResponse]"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced: Vert.x HTTP Response"
msgstr "高级：Vert.x HTTP 响应"

#: _guides/rest.adoc
#, fuzzy
msgid "For example, here is how you can return the name of the currently logged-in user:"
msgstr "例如，以下是返回当前登录用户名称的方法："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can also inject those context objects using\n"
"{injectapi}/jakarta/inject/Inject.html[`@Inject`] on fields of the same\n"
"type:"
msgstr "您还可以使用 {injectapi}/jakarta/inject/Inject.html[ `@Inject` ] 在相同类型的字段上注入这些上下文对象："

#: _guides/rest.adoc
#, fuzzy
msgid "Or even on your endpoint constructor:"
msgstr "甚至在端点构造函数上："

#: _guides/rest.adoc
#, fuzzy
msgid "JSON serialisation"
msgstr "JSON 序列化"

#: _guides/rest.adoc
#, fuzzy
msgid "Instead of importing `io.quarkus:quarkus-rest`, you can import either of the following modules to get support for JSON:"
msgstr "无需导入 `io.quarkus:quarkus-rest` ，您可以导入以下任一模块来获得 JSON 支持："

#: _guides/rest.adoc
#, fuzzy
msgid "GAV"
msgstr "GAV"

#: _guides/rest.adoc
#, fuzzy
msgid "`io.quarkus:quarkus-rest-jackson`"
msgstr "`io.quarkus:quarkus-rest-jackson`"

#: _guides/rest.adoc
#, fuzzy
msgid "https://github.com/FasterXML/jackson[Jackson support]"
msgstr "link:https://github.com/FasterXML/jackson[杰克逊支持]"

#: _guides/rest.adoc
#, fuzzy
msgid "`io.quarkus:quarkus-rest-jsonb`"
msgstr "`io.quarkus:quarkus-rest-jsonb`"

#: _guides/rest.adoc
#, fuzzy
msgid "https://eclipse-ee4j.github.io/jsonb-api/[JSON-B support]"
msgstr "link:https://eclipse-ee4j.github.io/jsonb-api/[支持 JSON-B]"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"In both cases, importing those modules will allow HTTP message bodies to be read from JSON\n"
"and serialised to JSON, for <<resource-types,all the types not already registered with a more specific\n"
"serialisation>>."
msgstr "在这两种情况下，导入这些模块将允许从 JSON 读取 HTTP 消息体并将其序列化为 JSON，适用于 xref:resource-types[所有尚未注册更特定序列化的类型] 。"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced Jackson-specific features"
msgstr "针对杰克逊的高级功能"

#: _guides/rest.adoc
#, fuzzy
msgid "When using the `quarkus-rest-jackson` extension there are some advanced features that Quarkus REST supports."
msgstr "使用 `quarkus-rest-jackson` 扩展时，Quarkus REST 支持一些高级功能。"

#: _guides/rest.adoc
msgid "Secure serialization"
msgstr "安全序列化"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"When used with Jackson to perform JSON serialization, Quarkus REST provides the ability to limit the set of fields that are serialized based on the roles of the current user.\n"
"This is achieved by simply annotating the fields (or getters) of the POJO being returned with `@io.quarkus.resteasy.reactive.jackson.SecureField`."
msgstr "当与 Jackson 一起使用来执行 JSON 序列化时，Quarkus REST 能够根据当前用户的角色来限制序列化的字段集。只需在返回的 POJO 的字段（或获取器）中注释 `@io.quarkus.resteasy.reactive.jackson.SecureField` ，即可实现这一功能。"

#: _guides/rest.adoc
#, fuzzy
msgid "A simple example could be the following:"
msgstr "下面是一个简单的例子："

#: _guides/rest.adoc
#, fuzzy
msgid "Assume we have a POJO named `Person` which looks like so:"
msgstr "假设我们有一个名为 `Person` 的 POJO，它看起来像这样："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The `io.quarkus.resteasy.reactive.jackson.SecureField.rolesAllowed` property supports xref:config-reference.adoc#property-expressions[property expressions]\n"
"exactly in the same fashion the `jakarta.annotation.security.RolesAllowed` annotation does. For more information, please\n"
"refer to the xref:security-authorize-web-endpoints-reference.adoc#standard-security-annotations[Standard security annotations]\n"
"section of the Authorization of web endpoints guide."
msgstr "`io.quarkus.resteasy.reactive.jackson.SecureField.rolesAllowed` 属性支持与 `jakarta.annotation.security.RolesAllowed` 注释完全相同的属性 xref:config-reference.adoc#property-expressions[表达式] 。如需了解更多信息，请参阅网络端点授权指南中的 xref:security-authorize-web-endpoints-reference.adoc#standard-security-annotations[标准安全注解] 部分。"

#: _guides/rest.adoc
#, fuzzy
msgid "A very simple Jakarta REST Resource that uses `Person` could be:"
msgstr "一个使用 `Person` 的非常简单的 Jakarta REST 资源可以是"

#: _guides/rest.adoc
msgid "The `@SecureField` annotation is only effective when Quarkus recognizes that produced content type is the 'application/json' type."
msgstr ""

#: _guides/rest.adoc
msgid "Currently you cannot use the `@SecureField` annotation to secure your data returned from resource methods returning the `io.smallrye.mutiny.Multi` reactive type."
msgstr ""

#: _guides/rest.adoc
msgid ""
"All resource methods returning data secured with the `@SecureField` annotation should be tested.\n"
"Please make sure data are secured as you intended."
msgstr ""

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Assuming security has been set up for the application (see our xref:security-overview.adoc[guide] for more details), when a user with the `admin` role\n"
"performs an HTTP GET on `/person/1` they will receive:"
msgstr "假设已为应用程序设置了安全机制（更多详情，请参阅我们的 xref:security-overview.adoc[指南] ），当 `admin` 角色的用户在 `/person/1` 上执行 HTTP GET 时，他们将收到以下信息："

#: _guides/rest.adoc
#, fuzzy
msgid "as the response."
msgstr "作为回应。"

#: _guides/rest.adoc
#, fuzzy
msgid "Any user however that does not have the `admin` role will receive:"
msgstr "但是，任何没有 `admin` 角色的用户都会收到："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"No additional configuration needs to be applied for this secure serialization to take place. However, users can use the `@io.quarkus.resteasy.reactive.jackson.EnableSecureSerialization` and `@io.quarkus.resteasy.reactive.jackson.DisableSecureSerialization`\n"
"annotation to opt in or out for specific Jakarta REST Resource classes or methods."
msgstr "这种安全序列化无需额外配置。不过，用户可以使用 `@io.quarkus.resteasy.reactive.jackson.EnableSecureSerialization` 和 `@io.quarkus.resteasy.reactive.jackson.DisableSecureSerialization` 注释来选择加入或退出特定的 Jakarta REST 资源类或方法。"

#: _guides/rest.adoc
#, fuzzy
msgid "Configuration expressions set with the `SecureField.rolesAllowed` property are validated during application startup even when the `@io.quarkus.resteasy.reactive.jackson.DisableSecureSerialization` annotation is used."
msgstr "即使使用 `@io.quarkus.resteasy.reactive.jackson.DisableSecureSerialization` 注解，使用 `SecureField.rolesAllowed` 属性设置的配置表达式也会在应用程序启动期间得到验证。"

#: _guides/rest.adoc
#, fuzzy
msgid "@JsonView support"
msgstr "@JsonView 支持"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Jakarta REST methods can be annotated with https://fasterxml.github.io/jackson-annotations/javadoc/2.10/com/fasterxml/jackson/annotation/JsonView.html[@JsonView]\n"
"in order to customize the serialization of the returned POJO, on a per method-basis. This is best explained with an example."
msgstr "Jakarta REST 方法可以使用 link:https://fasterxml.github.io/jackson-annotations/javadoc/2.10/com/fasterxml/jackson/annotation/JsonView.html[@JsonView] 进行注解，以便根据每个方法定制返回 POJO 的序列化。最好用一个例子来解释这一点。"

#: _guides/rest.adoc
#, fuzzy
msgid "A typical use of `@JsonView` is to hide certain fields on certain methods. In that vein, let's define two views:"
msgstr "`@JsonView` 的典型用途是隐藏某些方法的某些字段。因此，让我们定义两个视图："

#: _guides/rest.adoc
#, fuzzy
msgid "Let's assume we have the `User` POJO on which we want to hide some field during serialization. A simple example of this is:"
msgstr "假设我们有一个 `User` POJO，我们想在序列化过程中隐藏它的某些字段。一个简单的例子是"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Depending on the Jakarta REST method that returns this user, we might want to exclude the `id` field from serialization.\n"
"For example, you might want an insecure method to not expose this field.\n"
"The way we can achieve that in Quarkus REST is shown in the following example:"
msgstr "根据返回该用户的 Jakarta REST 方法，我们可能希望将 `id` 字段排除在序列化之外。例如，您可能希望不安全的方法不暴露这个字段。在 Quarkus REST 中实现这一点的方法如下例所示："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"When the result the `userPublic` method is serialized, the `id` field will not be contained in the response as the `Public` view does not include it.\n"
"The result of `userPrivate` however will include the `id` as expected when serialized."
msgstr "在对 `userPublic` 方法的结果进行序列化时，由于 `Public` 视图不包含 `id` 字段，因此响应中将不包含该字段。但 `userPrivate` 的结果在序列化时将包含预期的 `id` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "Completely customized per method serialization/deserialization"
msgstr "完全按方法定制的序列化/反序列化"

#: _guides/rest.adoc
#, fuzzy
msgid "There are times when you need to completely customize the serialization/deserialization of a POJO on a per Jakarta REST method basis or on a per Jakarta REST resource basis. For such use cases, you can use the `@io.quarkus.resteasy.reactive.jackson.CustomSerialization` and `@io.quarkus.resteasy.reactive.jackson.CustomDeserialization` annotations in the REST method or in the REST resource at class level. These annotations allow you to fully configure the `com.fasterxml.jackson.databind.ObjectWriter`/`com.fasterxml.jackson.databind.ObjectReader`."
msgstr "有时，您需要根据每个 Jakarta REST 方法或每个 Jakarta REST 资源完全自定义 POJO 的序列化/解序列化。对于此类用例，您可以在 REST 方法或 REST 资源的类级中使用 `@io.quarkus.resteasy.reactive.jackson.CustomSerialization` 和 `@io.quarkus.resteasy.reactive.jackson.CustomDeserialization` 注释。通过这些注解，您可以完全配置 `com.fasterxml.jackson.databind.ObjectWriter` / `com.fasterxml.jackson.databind.ObjectReader` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "Here is an example use case to customize the `com.fasterxml.jackson.databind.ObjectWriter`:"
msgstr "下面是一个自定义 `com.fasterxml.jackson.databind.ObjectWriter` 的用例："

#: _guides/rest.adoc
#, fuzzy
msgid "where `UnquotedFields` is a `BiFunction` defined as so:"
msgstr "其中 `UnquotedFields` 是一个 `BiFunction` ，定义如下："

#: _guides/rest.adoc
#, fuzzy
msgid "Essentially what this class does is force Jackson to not include quotes in the field names."
msgstr "该类的主要功能是强制 Jackson 在字段名中不包含引号。"

#: _guides/rest.adoc
#, fuzzy
msgid "It is important to note that this customization is only performed for the serialization of the Jakarta REST methods that use `@CustomSerialization(UnquotedFields.class)`."
msgstr "需要注意的是，这种定制只针对使用 `@CustomSerialization(UnquotedFields.class)` 的 Jakarta REST 方法的序列化。"

#: _guides/rest.adoc
#, fuzzy
msgid "Following the previous example, let's now customize the `com.fasterxml.jackson.databind.ObjectReader` to read JSON requests with unquoted field names:"
msgstr "按照前面的示例，现在让我们自定义 `com.fasterxml.jackson.databind.ObjectReader` ，以读取字段名未加引号的 JSON 请求："

#: _guides/rest.adoc
#, fuzzy
msgid "where `SupportUnquotedFields` is a `BiFunction` defined as so:"
msgstr "其中 `SupportUnquotedFields` 是一个 `BiFunction` ，定义如下："

#: _guides/rest.adoc
#, fuzzy
msgid "XML serialisation"
msgstr "XML 序列化"

#: _guides/rest.adoc
#, fuzzy
msgid "To enable XML support, add the `quarkus-rest-jaxb` extension to your project."
msgstr "要启用 XML 支持，请在项目中添加 `quarkus-rest-jaxb` 扩展。"

#: _guides/rest.adoc
#, fuzzy
msgid "`io.quarkus:quarkus-rest-jaxb`"
msgstr "`io.quarkus:quarkus-rest-jaxb`"

#: _guides/rest.adoc
#, fuzzy
msgid "https://javaee.github.io/jaxb-v2/[XML support]"
msgstr "link:https://javaee.github.io/jaxb-v2/[支持 XML]"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Importing this module will allow HTTP message bodies to be read from XML\n"
"and serialised to XML, for <<resource-types,all the types not already registered with a more specific\n"
"serialisation>>."
msgstr "导入该模块后，HTTP 消息体可从 XML 读取并序列化为 XML，适用于 xref:resource-types[所有尚未注册更具体序列化的类型] 。"

#: _guides/rest.adoc
#, fuzzy
msgid "The JAXB Quarkus REST extension will automatically detect the classes that are used in the resources and require JAXB serialization. Then, it will register these classes into the default `JAXBContext` which is internally used by the JAXB message reader and writer."
msgstr "JAXB Quarkus REST 扩展会自动检测资源中使用的、需要 JAXB 序列化的类。然后，它会把这些类注册到 JAXB 消息读写器内部使用的默认 `JAXBContext` 中。"

#: _guides/rest.adoc
#, fuzzy
msgid "However, in some situations, these classes cause the `JAXBContext` to fail: for example, when you're using the same class name in different java packages. In these cases, the application will fail at build time and print the JAXB exception that caused the issue, so you can properly fix it. Alternatively, you can also exclude the classes that cause the issue by using the property `quarkus.jaxb.exclude-classes`. When excluding classes that are required by any resource, the JAXB Quarkus REST extension will create and cache a custom `JAXBContext` that will include the excluded class, causing a minimal performance degradance."
msgstr "但是，在某些情况下，这些类会导致 `JAXBContext` 失败：例如，在不同的 java 包中使用相同的类名。在这种情况下，应用程序将在构建时失败，并打印导致问题的 JAXB 异常，以便您能正确修复。另外，您也可以使用属性 `quarkus.jaxb.exclude-classes` 来排除导致问题的类。当排除任何资源所需的类时，JAXB Quarkus REST 扩展将创建并缓存一个自定义的 `JAXBContext` ，其中将包括排除的类，从而将性能降低到最低程度。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The property `quarkus.jaxb.exclude-classes` accepts a comma separated list of either fully qualified class names\n"
"or package names. Package names must be suffixed by `.*` and all classes in the specified package and its subpackages will be excluded."
msgstr "`quarkus.jaxb.exclude-classes` 属性接受以逗号分隔的全限定类名或包名列表。软件包名称必须以 `.*` 作为后缀，指定软件包及其子软件包中的所有类都将被排除在外。"

#: _guides/rest.adoc
#, fuzzy
msgid "For instance, when setting `quarkus.jaxb.exclude-classes=org.acme.one.Model,org.acme.two.Model,org.acme.somemodel.*`, the following elements are excluded:"
msgstr "例如，在设置 `quarkus.jaxb.exclude-classes=org.acme.one.Model,org.acme.two.Model,org.acme.somemodel.*` 时，下列元素将被排除在外："

#: _guides/rest.adoc
#, fuzzy
msgid "The class `org.acme.one.Model`"
msgstr "班级 `org.acme.one.Model`"

#: _guides/rest.adoc
#, fuzzy
msgid "The class `org.acme.two.Model`"
msgstr "班级 `org.acme.two.Model`"

#: _guides/rest.adoc
#, fuzzy
msgid "All the classes in the `org.acme.somemodel` package and its subpackages"
msgstr "`org.acme.somemodel` 软件包及其子软件包中的所有类"

#: _guides/rest.adoc
#, fuzzy
msgid "Advanced JAXB-specific features"
msgstr "针对 JAXB 的高级功能"

#: _guides/rest.adoc
#, fuzzy
msgid "When using the `quarkus-resteasy-reactive-jaxb` extension there are some advanced features that Quarkus REST supports."
msgstr "使用 `quarkus-resteasy-reactive-jaxb` 扩展时，Quarkus REST 支持一些高级功能。"

#: _guides/rest.adoc
#, fuzzy
msgid "Inject JAXB components"
msgstr "注入 JAXB 组件"

#: _guides/rest.adoc
#, fuzzy
msgid "The JAXB Quarkus REST extension will serialize and unserialize requests and responses transparently for users. However, if you need finer grain control over JAXB components, you can inject either the JAXBContext, Marshaller, or Unmarshaller components into your beans:"
msgstr "JAXB Quarkus REST 扩展会为用户透明地序列化和取消序列化请求和响应。不过，如果你需要对 JAXB 组件进行更精细的控制，你可以将 JAXBContext、Marshaller 或 Unmarshaller 组件注入到你的 Bean 中："

#: _guides/rest.adoc
#, fuzzy
msgid "Quarkus will automatically find all the classes annotated with `@XmlRootElement` and then bound them to the JAXB context."
msgstr "Quarkus 会自动查找所有注释为 `@XmlRootElement` 的类，然后将它们绑定到 JAXB 上下文。"

#: _guides/rest.adoc
#, fuzzy
msgid "Customize the JAXB configuration"
msgstr "自定义 JAXB 配置"

#: _guides/rest.adoc
#, fuzzy
msgid "To customize the JAXB configuration for either the JAXB context, and/or the Marshaller/Unmarshaller components, the suggested approach is to define a CDI bean of type `io.quarkus.jaxb.runtime.JaxbContextCustomizer`."
msgstr "要为 JAXB 上下文和/或 Marshaller/Unmarshaller 组件定制 JAXB 配置，建议的方法是定义一个 `io.quarkus.jaxb.runtime.JaxbContextCustomizer` 类型的 CDI Bean。"

#: _guides/rest.adoc
msgid "An example where a custom module needs to be registered would look like so:"
msgstr "需要注册自定义模块的示例如下所示："

#: _guides/rest.adoc
#, fuzzy
msgid "It's not necessary to implement all three methods, but only the want you need."
msgstr "不一定要实现所有三种方法，只需实现你需要的方法即可。"

#: _guides/rest.adoc
#, fuzzy
msgid "Alternatively, you can provide your own `JAXBContext` bean by doing:"
msgstr "或者，您也可以通过以下方式提供自己的 `JAXBContext` bean："

#: _guides/rest.adoc
#, fuzzy
msgid "Note that if you provide your custom JAXB context instance, you will need to register the classes you want to use for the XML serialization. This means that Quarkus will not update your custom JAXB context instance with the auto-discovered classes."
msgstr "请注意，如果您提供了自定义 JAXB 上下文实例，则需要注册您想用于 XML 序列化的类。这意味着 Quarkus 不会用自动发现的类更新你的自定义 JAXB 上下文实例。"

#: _guides/rest.adoc
#, fuzzy
msgid "Web Links support"
msgstr "网络链接支持"

#: _guides/rest.adoc
#, fuzzy
msgid "To enable Web Links support, add the `quarkus-rest-links` extension to your project."
msgstr "要启用网络链接支持，请在项目中添加 `quarkus-rest-links` 扩展。"

#: _guides/rest.adoc
#, fuzzy
msgid "`io.quarkus:quarkus-rest-links`"
msgstr "`io.quarkus:quarkus-rest-links`"

#: _guides/rest.adoc
#, fuzzy
msgid "https://www.w3.org/wiki/LinkHeader[Web Links support]"
msgstr "link:https://www.w3.org/wiki/LinkHeader[网络链接支持]"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Importing this module will allow injecting web links into the response HTTP headers by just annotating your endpoint resources with the `@InjectRestLinks` annotation. To declare the web links that will be returned, you must use the `@RestLink` annotation in the linked methods.\n"
"Assuming a `Record` looks like:"
msgstr "导入该模块后，只需在端点资源中注释 `@InjectRestLinks` 注释，就能在响应的 HTTP 标头中注入网络链接。要声明将返回的网络链接，必须在链接方法中使用 `@RestLink` 注解。假设 `Record` 是这样的"

#: _guides/rest.adoc
#, fuzzy
msgid "An example of enabling Web Links support would look like:"
msgstr "启用网络链接支持的示例如下："

#: _guides/rest.adoc
#, fuzzy
msgid "When calling the endpoint `/records` which is defined by the method `getAll` within the above resource using curl, you would get the web links header:"
msgstr "当使用 curl 调用上述资源中由 `getAll` 方法定义的端点 `/records` 时，你会得到网络链接头："

#: _guides/rest.adoc
#, fuzzy
msgid "As this resource does not return a single instance of type `Record`, the links for the methods `get`, `update`, and `delete` are not injected. Now, when calling the endpoint `/records/1`, you would get the following web links:"
msgstr "由于该资源不会返回 `Record` 类型的单个实例，因此不会注入 `get` 、 `update` 和 `delete` 方法的链接。现在，当调用端点 `/records/1` 时，会得到以下网络链接："

#: _guides/rest.adoc
#, fuzzy
msgid "The `get`, `update`, and `delete` methods use the path param \"id\" and as the field \"id\" exists in the entity type \"Record\", the web link properly populates the value \"1\" in the returned links. In addition to this, we can also generate web links with path params that do not match with any field of the entity type. For example, the following method is using a path param \"text\" and the entity Record does not have any field named \"text\":"
msgstr "`get` 、 `update` 和 `delete` 方法使用路径参数 \"id\"，由于 \"id \"字段存在于实体类型 \"记录 \"中，因此网络链接会在返回的链接中正确填充值 \"1\"。除此之外，我们还可以使用与实体类型中任何字段都不匹配的路径参数生成网络链接。例如，下面的方法使用的路径参数是 \"text\"，而实体 \"Record \"没有任何名为 \"text \"的字段："

#: _guides/rest.adoc
#, fuzzy
msgid "The generated web link for this resource is `Link: <http://localhost:8080/search/{text}>; rel=\"search records by free text\"`."
msgstr "该资源的生成网络链接为 `Link: < http://localhost:8080/search/{text}> ; rel=\"search records by free text\"` ."

#: _guides/rest.adoc
#, fuzzy
msgid "Finally, when calling the `delete` resource, you should not see any web links as the method `delete` is not annotated with the `@InjectRestLinks` annotation."
msgstr "最后，在调用 `delete` 资源时，由于 `delete` 方法没有注释 `@InjectRestLinks` 注释，因此应该看不到任何网络链接。"

#: _guides/rest.adoc
#, fuzzy
msgid "Programmatically access to the web links registry"
msgstr "以编程方式访问网络链接注册表"

#: _guides/rest.adoc
#, fuzzy
msgid "You can programmatically have access to the web links registry just by injecting the `RestLinksProvider` bean:"
msgstr "只需注入 `RestLinksProvider` Bean，就能以编程方式访问网络链接注册表："

#: _guides/rest.adoc
#, fuzzy
msgid "Using this injected bean of type `RestLinksProvider`, you can get the links by type using the method `RestLinksProvider.getTypeLinks` or get the links by a concrete instance using the method `RestLinksProvider.getInstanceLinks`."
msgstr "使用这个类型为 `RestLinksProvider` 的注入式 Bean，可以使用方法 `RestLinksProvider.getTypeLinks` 按类型获取链接，或使用方法 `RestLinksProvider.getInstanceLinks` 按具体实例获取链接。"

#: _guides/rest.adoc
#, fuzzy
msgid "JSON Hypertext Application Language (HAL) support"
msgstr "支持 JSON 超文本应用语言 (HAL)"

#: _guides/rest.adoc
#, fuzzy
msgid "The https://tools.ietf.org/id/draft-kelly-json-hal-01.html[HAL] standard is a simple format to represent web links."
msgstr "link:https://tools.ietf.org/id/draft-kelly-json-hal-01.html[HAL] 标准是一种表示网络链接的简单格式。"

#: _guides/rest.adoc
#, fuzzy
msgid "To enable the HAL support, add the `quarkus-hal` extension to your project. Also, as HAL needs JSON support, you need to add either the `quarkus-rest-jsonb` or the `quarkus-rest-jackson` extension."
msgstr "要启用 HAL 支持，请在项目中添加 `quarkus-hal` 扩展。此外，由于 HAL 需要 JSON 支持，因此需要添加 `quarkus-rest-jsonb` 或 `quarkus-rest-jackson` 扩展。"

#: _guides/rest.adoc
#, fuzzy
msgid "`io.quarkus:quarkus-hal`"
msgstr "`io.quarkus:quarkus-hal`"

#: _guides/rest.adoc
#, fuzzy
msgid "https://tools.ietf.org/id/draft-kelly-json-hal-01.html[HAL]"
msgstr "link:https://tools.ietf.org/id/draft-kelly-json-hal-01.html[哈拉尔]"

#: _guides/rest.adoc
#, fuzzy
msgid "After adding the extensions, we can now annotate the REST resources to produce the media type `application/hal+json` (or use RestMediaType.APPLICATION_HAL_JSON). For example:"
msgstr "添加扩展后，我们就可以对 REST 资源进行注释，以生成媒体类型 `application/hal+json` （或使用 RestMediaType.APPLICATION_HAL_JSON）。例如"

#: _guides/rest.adoc
#, fuzzy
msgid "Now, the endpoints `/records` and `/records/{id}` will accept the media type both `json` and `hal+json` to print the records in Hal format."
msgstr "现在，端点 `/records` 和 `/records/{id}` 将接受媒体类型 `json` 和 `hal+json` ，以 Hal 格式打印记录。"

#: _guides/rest.adoc
#, fuzzy
msgid "For example, if we invoke the `/records` endpoint using curl to return a list of records, the HAL format will look like as follows:"
msgstr "例如，如果我们使用 curl 调用 `/records` 端点来返回记录列表，HAL 格式将如下所示："

#: _guides/rest.adoc
#, fuzzy
msgid "When we call a resource `/records/1` that returns only one instance, then the output is:"
msgstr "当我们调用只返回一个实例的资源 `/records/1` 时，输出结果为"

#: _guides/rest.adoc
#, fuzzy
msgid "Finally, you can also provide additional HAL links programmatically in your resource just by returning either `HalCollectionWrapper<T>` (to return a list of entities) or `HalEntityWrapper<T>` (to return a single object) as described in the following example:"
msgstr "最后，您还可以通过返回 `HalCollectionWrapper<T>` （返回实体列表）或 `HalEntityWrapper<T>` （返回单个对象），在资源中以编程方式提供额外的 HAL 链接，如下例所示："

#: _guides/rest.adoc
#, fuzzy
msgid "CORS filter"
msgstr "CORS 过滤器"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin resource sharing] (CORS) is a mechanism that\n"
"allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource\n"
"was served."
msgstr "link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[跨源资源共享] （CORS）是一种机制，允许从提供第一个资源的域之外的另一个域请求网页上的受限资源。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Quarkus includes a CORS filter at the HTTP layer level.\n"
"For more information about the CORS filters and their usage, see the xref:security-cors.adoc#cors-filter[CORS filter] section of the Quarkus \"Cross-origin resource sharing\" guide."
msgstr "Quarkus 在 HTTP 层包含 CORS 过滤器。有关 CORS 过滤器及其用法的更多信息，请参阅 Quarkus \"跨源资源共享 \"指南中的 xref:security-cors.adoc#cors-filter[CORS 过滤器] 部分。"

#: _guides/rest.adoc
#, fuzzy
msgid "More advanced usage"
msgstr "更高级的用法"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Here are some more advanced topics that you may not need to know about initially, but\n"
"could prove useful for more complex use cases."
msgstr "以下是一些更高级的主题，您最初可能不需要了解，但可能对更复杂的使用案例有用。"

#: _guides/rest.adoc
#, fuzzy
msgid "Execution model, blocking, non-blocking"
msgstr "执行模式、阻塞、非阻塞"

#: _guides/rest.adoc
#, fuzzy
msgid "Quarkus REST is implemented using two main thread types:"
msgstr "Quarkus REST 采用两种主要线程类型："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Event-loop threads: which are responsible, among other things, for reading bytes from the HTTP request and\n"
"writing bytes back to the HTTP response"
msgstr "事件循环线程：主要负责从 HTTP 请求中读取字节，并将字节写回 HTTP 响应"

#: _guides/rest.adoc
#, fuzzy
msgid "Worker threads: they are pooled and can be used to offload long-running operations"
msgstr "工作线程：它们是池化的，可用于卸载长时间运行的操作"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The event-loop threads (also called IO threads) are responsible for actually performing all the IO\n"
"operations in an asynchronous way, and to trigger any listener interested in the completion of those\n"
"IO operations."
msgstr "事件循环线程（也称为 IO 线程）负责以异步方式实际执行所有 IO 操作，并触发任何对这些 IO 操作完成情况感兴趣的监听器。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"By default, the thread Quarkus REST will run endpoint methods on depends on the signature of the method.\n"
"If a method returns one of the following types then it is considered non-blocking, and will be run on the IO thread\n"
"by default:"
msgstr "默认情况下，Quarkus REST 运行端点方法的线程取决于方法的签名。如果方法返回以下类型之一，则该方法被认为是非阻塞的，默认情况下将在 IO 线程上运行："

#: _guides/rest.adoc
#, fuzzy
msgid "`io.smallrye.mutiny.Uni`"
msgstr "`io.smallrye.mutiny.Uni`"

#: _guides/rest.adoc
#, fuzzy
msgid "`io.smallrye.mutiny.Multi`"
msgstr "`io.smallrye.mutiny.Multi`"

#: _guides/rest.adoc
#, fuzzy
msgid "`java.util.concurrent.CompletionStage`"
msgstr "`java.util.concurrent.CompletionStage`"

#: _guides/rest.adoc
#, fuzzy
msgid "`org.reactivestreams.Publisher`"
msgstr "`org.reactivestreams.Publisher`"

#: _guides/rest.adoc
#, fuzzy
msgid "Kotlin `suspended` methods"
msgstr "Kotlin `suspended` 方法"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"This 'best guess' approach means most operations will run on the correct thread by default.\n"
"If you are writing reactive code, your method will generally return one of these types and will be executed on the IO thread.\n"
"If you are writing blocking code, your methods will usually return the result directly, and these will be run on a worker thread."
msgstr "这种 \"最佳猜测 \"方法意味着大多数操作都会默认在正确的线程上运行。如果您编写的是反应式代码，您的方法通常会返回这些类型之一，并在 IO 线程上执行。如果您编写的是阻塞代码，您的方法通常会直接返回结果，这些方法将在工作线程上运行。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can override this behaviour using the\n"
"https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[`@Blocking`]\n"
"and\n"
"https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/NonBlocking.html[`@NonBlocking`]\n"
"annotations. This can be applied at the method, class or `jakarta.ws.rs.core.Application` level."
msgstr "您可以使用 link:https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[@Blocking] 和 link:https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/NonBlocking.html[@NonBlocking] 注释来覆盖这一行为。这可以应用于方法、类或 `jakarta.ws.rs.core.Application` 级别。"

#: _guides/rest.adoc
#, fuzzy
msgid "The example below will override the default behaviour and always run on a worker thread, even though it returns a `Uni`."
msgstr "下面的示例将覆盖默认行为，并始终在工作线程上运行，即使它返回的是 `Uni` 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive\n"
"way, using https://smallrye.io/smallrye-mutiny/[Mutiny], https://hibernate.org/reactive/[Hibernate Reactive]\n"
"or any of the xref:quarkus-reactive-architecture.adoc#quarkus-extensions-enabling-reactive[Quarkus Reactive extensions] for example:"
msgstr "大多数情况下，可以使用 link:https://smallrye.io/smallrye-mutiny/[Mutiny] 、 link:https://hibernate.org/reactive/[Hibernate Reactive] 或 xref:quarkus-reactive-architecture.adoc#quarkus-extensions-enabling-reactive[Quarkus Reactive 扩展] 等异步/交互方式实现相同的阻塞操作："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If a method or class is annotated with `jakarta.transaction.Transactional` then it will also be treated as a blocking\n"
"method. This is because JTA is a blocking technology, and is generally used with other blocking technology such as\n"
"Hibernate and JDBC. An explicit `@Blocking` or `@NonBlocking` on the class will override this behaviour."
msgstr "如果一个方法或类被注释为 `jakarta.transaction.Transactional` ，那么它也将被视为阻塞方法。这是因为 JTA 是一种阻塞技术，通常与 Hibernate 和 JDBC 等其他阻塞技术一起使用。类上显式的 `@Blocking` 或 `@NonBlocking` 将覆盖这种行为。"

#: _guides/rest.adoc
#, fuzzy
msgid "Overriding the default behaviour"
msgstr "覆盖默认行为"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If you want to override the default behavior, you can annotate a `jakarta.ws.rs.core.Application` subclass in your application with `@Blocking` or `@NonBlocking`,\n"
"and this will set the default for every method that does not have an explicit annotation."
msgstr "如果想覆盖默认行为，可以在应用程序中使用 `@Blocking` 或 `@NonBlocking` 对 `jakarta.ws.rs.core.Application` 子类进行注解，这样就能为每一个没有明确注解的方法设置默认行为。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Behavior can still be overridden on a class or method level by annotating them directly, however,\n"
"all endpoints without an annotation will now follow the default, no matter their method signature."
msgstr "然而，所有没有注解的端点，无论其方法签名如何，现在都将遵循默认值。"

#: _guides/rest.adoc
#, fuzzy
msgid "Exception mapping"
msgstr "异常映射"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If your application needs to return non-nominal HTTP codes in error cases, the best is\n"
"to throw exceptions that will result in the proper HTTP response being sent by the\n"
"framework using link:{jaxrsapi}/jakarta/ws/rs/WebApplicationException.html[`WebApplicationException`] or any of its subtypes:"
msgstr "如果您的应用程序需要在错误情况下返回非名义 HTTP 代码，最好的办法是抛出异常，这样框架就会使用 link:{jaxrsapi}/jakarta/ws/rs/WebApplicationException.html[WebApplicationException] 或其任何子类型发送正确的 HTTP 响应："

#: _guides/rest.adoc
#, fuzzy
msgid "You can change the log level of the thrown `WebApplicationException` exceptions by configuring the following property `quarkus.log.category.\"WebApplicationException\".level` like so:"
msgstr "通过配置以下属性 `quarkus.log.category.\"WebApplicationException\".level` ，可以更改 `WebApplicationException` 异常抛出的日志级别："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If your endpoint method is delegating calls to another service layer which\n"
"does not know of Jakarta REST, you need a way to turn service exceptions to an\n"
"HTTP response, and you can do that using the\n"
"link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/ServerExceptionMapper.html[`@ServerExceptionMapper`]\n"
"annotation on a method, with one parameter of the exception type you want to handle, and turning\n"
"that exception into a link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestResponse.html[`RestResponse`] (or a\n"
"link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<RestResponse<?>>`]):"
msgstr "如果您的端点方法将调用委托给另一个不知道 Jakarta REST 的服务层，那么您需要一种方法将服务异常转化为 HTTP 响应。 link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/ServerExceptionMapper.html[@ServerExceptionMapper] 注解，在方法中加入一个要处理的异常类型参数，并将该异常转化为一个 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestResponse.html[RestResponse] 或 link:{mutinyapi}/io/smallrye/mutiny/Uni.html[Uni<RestResponse<?>>] ):"

#: _guides/rest.adoc
#, fuzzy
msgid "By default, methods annotated with `@ServerExceptionMapper` do **not** run CDI interceptors that apply to the other methods of the class (like ones needed for implementing security method level security)."
msgstr "默认情况下，注释为 `@ServerExceptionMapper` 的方法 *不会* 运行适用于该类其他方法的 CDI 拦截器（如实现安全方法级安全所需的拦截器）。"

#: _guides/rest.adoc
#, fuzzy
msgid "Users however can opt into interceptors by adding the corresponding annotations to the method."
msgstr "不过，用户可以通过在方法中添加相应的注解来选择使用拦截器。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Εxception mappers defined in REST endpoint classes will only be called if the  exception is thrown in the same class. If you want to define global exception mappers,\n"
"simply define them outside a REST endpoint class:"
msgstr "在 REST 端点类中定义的异常映射器只有在异常在同一类中抛出时才会被调用。如果要定义全局异常映射器，只需在 REST 端点类之外定义即可："

#: _guides/rest.adoc
#, fuzzy
msgid "You can also declare link:{jaxrsspec}#exceptionmapper[exception mappers in the Jakarta REST way]."
msgstr "您也可以 link:{jaxrsspec}#exceptionmapper[用 Jakarta REST 的方式] 声明 link:{jaxrsspec}#exceptionmapper[异常映射器] 。"

#: _guides/rest.adoc
#, fuzzy
msgid "Your exception mapper may declare any of the following parameter types:"
msgstr "异常映射器可声明以下任何一种参数类型："

#: _guides/rest.adoc
#, fuzzy
msgid "Exception mapper parameters"
msgstr "异常映射器参数"

#: _guides/rest.adoc
#, fuzzy
msgid "An exception type"
msgstr "异常类型"

#: _guides/rest.adoc
#, fuzzy
msgid "Defines the exception type you want to handle"
msgstr "定义要处理的异常类型"

#: _guides/rest.adoc
#, fuzzy
msgid "Any of the <<context-objects,Context objects>>"
msgstr "任何 xref:context-objects[上下文对象]"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/container/ContainerRequestContext.html[`ContainerRequestContext`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/container/ContainerRequestContext.html[ContainerRequestContext]"

#: _guides/rest.adoc
#, fuzzy
msgid "A context object to access the current request"
msgstr "用于访问当前请求的上下文对象"

#: _guides/rest.adoc
#, fuzzy
msgid "It may declare any of the following return types:"
msgstr "它可以声明以下任何一种返回类型："

#: _guides/rest.adoc
#, fuzzy
msgid "Exception mapper return types"
msgstr "异常映射器返回类型"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestResponse.html[`RestResponse`] or link:{jaxrsapi}/jakarta/ws/rs/core/Response.html[`Response`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestResponse.html[RestResponse] 或 link:{jaxrsapi}/jakarta/ws/rs/core/Response.html[Response]"

#: _guides/rest.adoc
#, fuzzy
msgid "The response to send to the client when the exception occurs"
msgstr "出现异常时发送给客户端的响应"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<RestResponse>`] or link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]"
msgstr "link:{mutinyapi}/io/smallrye/mutiny/Uni.html[Uni<RestResponse>] 或 link:{mutinyapi}/io/smallrye/mutiny/Uni.html[Uni<Response>]"

#: _guides/rest.adoc
#, fuzzy
msgid "An asynchronous response to send to the client when the exception occurs"
msgstr "异常发生时发送给客户端的异步响应"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"When an exception occurs, Quarkus REST does not log it by default (for security reasons).\n"
"This can sometimes make it hard to understand why certain exception handling code was invoked (or not invoked).\n"
"To make Quarkus REST log the actual exception before an exception mapping code is run the `org.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext` log category can be set to `DEBUG` like so:"
msgstr "发生异常时，Quarkus REST 默认不记录日志（出于安全原因）。这有时会让人难以理解为什么会调用（或不调用）某些异常处理代码。要使 Quarkus REST 在运行异常映射代码之前记录实际异常，可以将 `org.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext` 日志类别设置为 `DEBUG` ，如下所示："

#: _guides/rest.adoc
#, fuzzy
msgid "Request or response filters"
msgstr "请求或响应过滤器"

#: _guides/rest.adoc
#, fuzzy
msgid "Via annotations"
msgstr "通过注释"

#: _guides/rest.adoc
#, fuzzy
msgid "You can declare functions that are invoked in the following phases of the request processing:"
msgstr "您可以声明在请求处理的以下阶段调用的函数："

#: _guides/rest.adoc
#, fuzzy
msgid "Before the endpoint method is identified: pre-matching request filter"
msgstr "在识别终端方法之前：预匹配请求过滤器"

#: _guides/rest.adoc
#, fuzzy
msgid "After routing, but before the endpoint method is called: normal request filter"
msgstr "路由之后，终端方法调用之前：正常请求过滤器"

#: _guides/rest.adoc
#, fuzzy
msgid "After the endpoint method is called: response filter"
msgstr "调用端点方法后：响应过滤器"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"These filters allow you to do various things such as examine the request URI,\n"
"HTTP method, influence routing, look or change request headers, abort the request,\n"
"or modify the response."
msgstr "这些过滤器允许你做各种事情，如检查请求 URI、HTTP 方法、影响路由、查看或更改请求头、中止请求或修改响应。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Request filters can be declared with the\n"
"link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/ServerRequestFilter.html[`@ServerRequestFilter`]\n"
"annotation:"
msgstr "可以使用 link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/ServerRequestFilter.html[@ServerRequestFilter] 注解声明请求过滤器："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Request filters are usually executed on the same thread that the method that handles the request will be executed.\n"
"That means that if the method servicing the request is annotated with `@Blocking`, then the filters will also be run\n"
"on the worker thread.\n"
"If the method is annotated with `@NonBlocking` (or is not annotated at all), then the filters will also be run\n"
"on the same event-loop thread."
msgstr "请求过滤器通常在与处理请求的方法相同的线程上执行。也就是说，如果处理请求的方法被注释为 `@Blocking` ，那么过滤器也将在工作线程上运行。如果方法注释为 `@NonBlocking` （或根本没有注释），那么过滤器也将在同一事件循环线程上运行。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If however a filter needs to be run on the event-loop despite the fact that the method servicing the request will be\n"
"run on a worker thread, then `@ServerRequestFilter(nonBlocking=true)` can be used.\n"
"Note however, that these filters need to be run before **any** filter that does not use that setting and would run on a worker thread."
msgstr "但是，如果需要在事件循环中运行过滤器，尽管为请求提供服务的方法将在工作线程上运行，那么可以使用 `@ServerRequestFilter(nonBlocking=true)` 。但需要注意的是，这些过滤器需要在不使用该设置且在工作线程上运行 *的* 过滤器之前运行。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Keep in mind however that the information above does **not** apply to pre-matching filters (`@ServerRequestFilter(preMatching = true)`).\n"
"These filters are *always* run on an event-loop thread."
msgstr "但请注意，上述信息 *不适* 用于预匹配过滤器 ( `@ServerRequestFilter(preMatching = true)` )。这些过滤器 *总是* 在事件循环线程上运行。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Similarly, response filters can be declared with the\n"
"link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/ServerResponseFilter.html[`@ServerResponseFilter`]\n"
"annotation:"
msgstr "同样，响应滤波器也可以用 link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/ServerResponseFilter.html[@ServerResponseFilter] 注释来声明响应滤波器："

#: _guides/rest.adoc
#, fuzzy
msgid "Such a response filter will also be called for <<exception-mapping, handled>> exceptions."
msgstr "对于 xref:exception-mapping[已处理的] 异常，也会调用这样的响应过滤器。"

#: _guides/rest.adoc
#, fuzzy
msgid "Your filters may declare any of the following parameter types:"
msgstr "您的过滤器可以声明以下任何一种参数类型："

#: _guides/rest.adoc
#, fuzzy
msgid "Filter parameters"
msgstr "过滤器参数"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jaxrsapi}/jakarta/ws/rs/container/ContainerResponseContext.html[`ContainerResponseContext`]"
msgstr "link:{jaxrsapi}/jakarta/ws/rs/container/ContainerResponseContext.html[ContainerResponseContext]"

#: _guides/rest.adoc
#, fuzzy
msgid "A context object to access the current response"
msgstr "用于访问当前响应的上下文对象"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jdkapi}/java/lang/Throwable.html[`Throwable`]"
msgstr "link:{jdkapi}/java/lang/Throwable.html[Throwable]"

#: _guides/rest.adoc
#, fuzzy
msgid "Any thrown and <<exception-mapping, handled>> exception, or `null` (only for response filters)."
msgstr "任何已抛出和 xref:exception-mapping[处理的] 异常，或 `null` （仅适用于响应过滤器）。"

#: _guides/rest.adoc
#, fuzzy
msgid "Filter return types"
msgstr "过滤器返回类型"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestResponse.html[`RestResponse<?>`] or link:{jaxrsapi}/jakarta/ws/rs/core/Response.html[`Response`]"
msgstr "link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestResponse.html[RestResponse<?>] 或 link:{jaxrsapi}/jakarta/ws/rs/core/Response.html[Response]"

#: _guides/rest.adoc
#, fuzzy
msgid "The response to send to the client instead of continuing the filter chain, or `null` if the filter chain should proceed"
msgstr "将发送给客户端而不是继续过滤链的响应，或者 `null` （如果继续过滤链）。"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{jdkapi}/java/util/Optional.html[`Optional<RestResponse<?>>`] or link:{jdkapi}/java/util/Optional.html[`Optional<Response>`]"
msgstr "link:{jdkapi}/java/util/Optional.html[Optional<RestResponse<?>>] 或 link:{jdkapi}/java/util/Optional.html[Optional<Response>]"

#: _guides/rest.adoc
#, fuzzy
msgid "An optional response to send to the client instead of continuing the filter chain, or an empty value if the filter chain should proceed"
msgstr "发送给客户端而不是继续过滤链的可选响应，如果过滤链应该继续，则为空值"

#: _guides/rest.adoc
#, fuzzy
msgid "link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<RestResponse<?>>`] or link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]"
msgstr "link:{mutinyapi}/io/smallrye/mutiny/Uni.html[Uni<RestResponse<?>>] 或 link:{mutinyapi}/io/smallrye/mutiny/Uni.html[Uni<Response>]"

#: _guides/rest.adoc
#, fuzzy
msgid "An asynchronous response to send to the client instead of continuing the filter chain, or `null` if the filter chain should proceed"
msgstr "发送给客户端的异步响应，而不是继续过滤链，或者 `null` （如果继续过滤链）。"

#: _guides/rest.adoc
#, fuzzy
msgid "You can restrict the Resource methods for which a filter runs, by using link:{jaxrsapi}/jakarta/ws/rs/NameBinding.html[`@NameBinding`] meta-annotations."
msgstr "您可以通过使用 link:{jaxrsapi}/jakarta/ws/rs/NameBinding.html[@NameBinding] 元注释。"

#: _guides/rest.adoc
#, fuzzy
msgid "The Jakarta REST way"
msgstr "雅加达 REST 方式"

#: _guides/rest.adoc
#, fuzzy
msgid "You can also link:{jaxrsspec}#filters[declare request and response filters in the Jakarta REST way]."
msgstr "您还可以 link:{jaxrsspec}#filters[用 Jakarta REST 方式声明请求和响应过滤器] 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Both HTTP request and response can be intercepted by providing `ContainerRequestFilter` or `ContainerResponseFilter`\n"
"implementations respectively. These filters are suitable for processing the metadata associated with a message: HTTP\n"
"headers, query parameters, media type, and other metadata. They also have the capability to abort the request\n"
"processing, for instance when the user does not have the permissions to access the endpoint."
msgstr "通过分别提供 `ContainerRequestFilter` 或 `ContainerResponseFilter` 实现，可以拦截 HTTP 请求和响应。这些过滤器适用于处理与信息相关的元数据：HTTP 头信息、查询参数、媒体类型和其他元数据。它们还具有中止请求处理的功能，例如当用户没有访问端点的权限时。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Let's use `ContainerRequestFilter` to add logging capability to our service. We can do that by implementing\n"
"`ContainerRequestFilter` and annotating it with the `@Provider` annotation:"
msgstr "让我们使用 `ContainerRequestFilter` 为我们的服务添加日志功能。我们可以通过实现 `ContainerRequestFilter` 并使用 `@Provider` 注释来实现这一功能："

#: _guides/rest.adoc
#, fuzzy
msgid "Now, whenever a REST method is invoked, the request will be logged into the console:"
msgstr "现在，只要调用 REST 方法，请求就会被记录到控制台中："

#: _guides/rest.adoc
#, fuzzy
msgid "A `ContainerResponseFilter` will also be called for <<exception-mapping, handled>> exceptions."
msgstr "对于 xref:exception-mapping[已处理的] 异常，也会调用 `ContainerResponseFilter` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "Readers and Writers: mapping entities and HTTP bodies"
msgstr "读者和作者：映射实体和 HTTP 主体"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Whenever your endpoint methods return an object (or when they return a\n"
"link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestResponse.html[`RestResponse<?>`]\n"
"or link:{jaxrsapi}/jakarta/ws/rs/core/Response.html[`Response`] with\n"
"an entity), Quarkus REST will look for a way to map that into an HTTP response body."
msgstr "每当你的端点方法返回一个对象时（或者当它们返回一个 link:{resteasy-reactive-common-api}/org/jboss/resteasy/reactive/RestResponse.html[RestResponse<?>] 或 link:{jaxrsapi}/jakarta/ws/rs/core/Response.html[Response] 实体）时，Quarkus REST 都会想办法将其映射到 HTTP 响应体中。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Similarly, whenever your endpoint method takes an object as parameter, we will look for\n"
"a way to map the HTTP request body into that object."
msgstr "同样，只要你的端点方法将一个对象作为参数，我们就会寻找一种方法将 HTTP 请求正文映射到该对象中。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"This is done via a pluggable system of link:{jaxrsapi}/jakarta/ws/rs/ext/MessageBodyReader.html[`MessageBodyReader`]\n"
"and link:{jaxrsapi}/jakarta/ws/rs/ext/MessageBodyWriter.html[`MessageBodyWriter`] interfaces,\n"
"which are responsible for defining which Java type they map from/to, for which media types,\n"
"and how they turn HTTP bodies to/from Java instances of that type."
msgstr "这是通过一个由 link:{jaxrsapi}/jakarta/ws/rs/ext/MessageBodyReader.html[MessageBodyReader] 和 link:{jaxrsapi}/jakarta/ws/rs/ext/MessageBodyWriter.html[MessageBodyWriter] 接口，这些接口负责定义它们映射自/映射到哪些 Java 类型、哪些媒体类型，以及如何将 HTTP 主体转换为/转换为该类型的 Java 实例。"

#: _guides/rest.adoc
#, fuzzy
msgid "For example, if we have our own `Cheese` type on our endpoint:"
msgstr "例如，如果我们在端点上有自己的 `Cheese` 类型："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Then we can define how to read and write it with our body reader/writers, annotated\n"
"with link:{jaxrsapi}/jakarta/ws/rs/ext/Provider.html[`@Provider`]:"
msgstr "然后，我们就可以用我们的正文读写器定义如何读取和写入，注释如下 link:{jaxrsapi}/jakarta/ws/rs/ext/Provider.html[@Provider] :"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"If you want to get the most performance out of your writer, you can extend the\n"
"link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/spi/ServerMessageBodyWriter.html[`ServerMessageBodyWriter`]\n"
"instead of link:{jaxrsapi}/jakarta/ws/rs/ext/MessageBodyWriter.html[`MessageBodyWriter`]\n"
"where you will be able to use less reflection and bypass the blocking IO layer:"
msgstr "如果想让写入器发挥最大性能，可以扩展 link:{resteasy-reactive-api}/org/jboss/resteasy/reactive/server/spi/ServerMessageBodyWriter.html[ServerMessageBodyWriter] 而不是 link:{jaxrsapi}/jakarta/ws/rs/ext/MessageBodyWriter.html[MessageBodyWriter] 扩展，这样可以减少反射的使用，并绕过阻塞 IO 层："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"You can restrict which content-types your reader/writer apply to by adding\n"
"link:{jaxrsapi}/jakarta/ws/rs/Consumes.html[`Consumes`]/link:{jaxrsapi}/jakarta/ws/rs/Produces.html[`Produces`] annotations\n"
"on your provider class."
msgstr "您可以通过添加 link:{jaxrsapi}/jakarta/ws/rs/Consumes.html[Consumes] / link:{jaxrsapi}/jakarta/ws/rs/Produces.html[Produces] 注释来限制阅读器/写入器适用的内容类型。"

#: _guides/rest.adoc
#, fuzzy
msgid "Reader and Writer interceptors"
msgstr "读取器和写入器拦截器"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Just as you can intercept requests and responses, you can also intercept readers and writers, by\n"
"extending the link:{jaxrsapi}/jakarta/ws/rs/ext/ReaderInterceptor.html[`ReaderInterceptor`] or\n"
"link:{jaxrsapi}/jakarta/ws/rs/ext/WriterInterceptor.html[`WriterInterceptor`] on a class annotated with\n"
"link:{jaxrsapi}/jakarta/ws/rs/ext/Provider.html[`@Provider`]."
msgstr "正如可以拦截请求和响应一样，通过扩展 link:{jaxrsapi}/jakarta/ws/rs/ext/ReaderInterceptor.html[ReaderInterceptor] 或 link:{jaxrsapi}/jakarta/ws/rs/ext/WriterInterceptor.html[WriterInterceptor] 注释的类上扩展 link:{jaxrsapi}/jakarta/ws/rs/ext/Provider.html[@Provider] ."

#: _guides/rest.adoc
#, fuzzy
msgid "If we look at this endpoint:"
msgstr "如果我们看一下这个端点："

#: _guides/rest.adoc
#, fuzzy
msgid "We can add reader and writer interceptors like this:"
msgstr "我们可以这样添加阅读器和写入器拦截器："

#: _guides/rest.adoc
#, fuzzy
msgid "Quarkus REST and REST Client interactions"
msgstr "Quarkus REST 和 REST 客户端交互"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"In Quarkus, the Quarkus REST extension and xref:rest-client.adoc[the REST Client extension] share the same infrastructure.\n"
"One important consequence of this consideration is that they share the same list of providers (in the Jakarta REST meaning of the word)."
msgstr "在 Quarkus 中，Quarkus REST 扩展和 xref:rest-client.adoc[REST 客户端扩展] 共享相同的基础设施。这种考虑的一个重要结果是，它们共享相同的提供者列表（按照 Jakarta REST 的含义）。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"For instance, if you declare a `WriterInterceptor`, it will by default intercept both the servers calls and the client calls,\n"
"which might not be the desired behavior."
msgstr "例如，如果您声明一个 `WriterInterceptor` ，它将默认拦截服务器调用和客户端调用，这可能不是您想要的行为。"

#: _guides/rest.adoc
#, fuzzy
msgid "However, you can change this default behavior and constrain a provider to:"
msgstr "不过，您可以更改这一默认行为，并将提供程序限制为\"......\"："

#: _guides/rest.adoc
#, fuzzy
msgid "only consider *server* calls by adding the `@ConstrainedTo(RuntimeType.SERVER)` annotation to your provider;"
msgstr "通过在提供程序中添加 `@ConstrainedTo(RuntimeType.SERVER)` 注解，只考虑 *服务器* 调用；"

#: _guides/rest.adoc
#, fuzzy
msgid "only consider *client* calls by adding the `@ConstrainedTo(RuntimeType.CLIENT)` annotation to your provider."
msgstr "通过在提供程序中添加 `@ConstrainedTo(RuntimeType.CLIENT)` 注解，只考虑 *客户端* 调用。"

#: _guides/rest.adoc
#, fuzzy
msgid "Parameter mapping"
msgstr "参数映射"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"All <<request-parameters,Request Parameters>> can be declared as link:{jdkapi}/java/lang/String.html[`String`],\n"
"but also any of the following types:"
msgstr "所有 xref:request-parameters[请求参数] 都可以声明为 link:{jdkapi}/java/lang/String.html[String] 类型，也可声明为以下任何类型："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Types for which a link:{jaxrsapi}/jakarta/ws/rs/ext/ParamConverter.html[`ParamConverter`] is available via a registered\n"
"link:{jaxrsapi}/jakarta/ws/rs/ext/ParamConverterProvider.html[`ParamConverterProvider`]."
msgstr "的类型 link:{jaxrsapi}/jakarta/ws/rs/ext/ParamConverter.html[ParamConverter] 可通过注册的 link:{jaxrsapi}/jakarta/ws/rs/ext/ParamConverterProvider.html[ParamConverterProvider] ."

#: _guides/rest.adoc
#, fuzzy
msgid "Primitive types."
msgstr "原始类型。"

#: _guides/rest.adoc
#, fuzzy
msgid "Types that have a constructor that accepts a single link:{jdkapi}/java/lang/String.html[`String`] argument."
msgstr "类型的构造函数只接受一个 link:{jdkapi}/java/lang/String.html[String] 参数的构造函数的类型。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Types that have a static method named `valueOf` or `fromString` with a single link:{jdkapi}/java/lang/String.html[`String`] argument\n"
"that return an instance of the type. If both methods are present then `valueOf` will be used unless\n"
"the type is an `enum` in which case `fromString` will be used."
msgstr "具有名为 `valueOf` 或 `fromString` 的静态方法的类型。 link:{jdkapi}/java/lang/String.html[String] 参数的静态方法，并返回该类型的一个实例。如果这两个方法都存在，那么将使用 `valueOf` ，除非该类型是 `enum` ，在这种情况下将使用 `fromString` 。"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"link:{jdkapi}/java/util/List.html[`List<T>`], link:{jdkapi}/java/util/Set.html[`Set<T>`], or\n"
"link:{jdkapi}/java/util/SortedSet.html[`SortedSet<T>`], where `T` satisfies any above criterion."
msgstr "link:{jdkapi}/java/util/List.html[List<T>] , link:{jdkapi}/java/util/Set.html[Set<T>] 或 link:{jdkapi}/java/util/SortedSet.html[SortedSet<T>] , 其中 `T` 满足上述任一标准。"

#: _guides/rest.adoc
#, fuzzy
msgid "The following example illustrates all those possibilities:"
msgstr "下面的示例说明了所有这些可能性："

#: _guides/rest.adoc
#, fuzzy
msgid "Handling dates"
msgstr "处理日期"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Quarkus REST supports the use of the implementations of `java.time.Temporal` (like `java.time.LocalDateTime`) as query, path, or form params.\n"
"Furthermore, it provides the `@org.jboss.resteasy.reactive.DateFormat` annotation, which can be used to set a custom expected pattern.\n"
"Otherwise, the JDK's default format for each type is used implicitly."
msgstr "Quarkus REST 支持使用 `java.time.Temporal` 的实现（如 `java.time.LocalDateTime` ）作为查询、路径或表单参数。此外，它还提供了 `@org.jboss.resteasy.reactive.DateFormat` 注解，可用于设置自定义的预期模式。否则，每种类型都会隐式使用 JDK 的默认格式。"

#: _guides/rest.adoc
#, fuzzy
msgid "Preconditions"
msgstr "先决条件"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"https://tools.ietf.org/html/rfc7232[HTTP allows requests to be conditional], based on a number of\n"
"conditions, such as:"
msgstr "link:https://tools.ietf.org/html/rfc7232[HTTP 允许] 根据一些条件（如"

#: _guides/rest.adoc
#, fuzzy
msgid "Date of last resource modification"
msgstr "上次修改资源的日期"

#: _guides/rest.adoc
#, fuzzy
msgid "A resource tag, similar to a hash code of the resource to designate its state or version"
msgstr "资源标签，类似于资源的哈希代码，用于指定其状态或版本"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Let's see how you can do conditional request validation using the\n"
"link:{jaxrsapi}/jakarta/ws/rs/core/Request.html[`Request`] context object:"
msgstr "让我们看看如何使用 link:{jaxrsapi}/jakarta/ws/rs/core/Request.html[Request] 上下文对象进行条件请求验证："

#: _guides/rest.adoc
#, fuzzy
msgid "When we call `GET /conditional` the first time, we will get this response:"
msgstr "当我们第一次拨打 `GET /conditional` 时，会得到这样的回复："

#: _guides/rest.adoc
#, fuzzy
msgid "So now if we want to check if we need to fetch a new version, we can make the following request:"
msgstr "因此，如果我们要检查是否需要获取新版本，可以提出以下请求："

#: _guides/rest.adoc
#, fuzzy
msgid "And we would get the following response:"
msgstr "我们会得到如下答复："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Because the resource has not been modified since that date, this saves on sending the resource but can also help your users detect the concurrent modification.\n"
"For example, one client wants to update the resource, but another user has modified it since.\n"
"You can follow the previous `GET` request with this update:"
msgstr "由于资源在该日期后没有被修改过，这样不仅可以节省发送资源的时间，还能帮助用户检测到并发修改。例如，一个客户端想更新资源，但另一个用户在此之后又修改了资源。您可以通过此更新跟踪之前的 `GET` 请求："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"And if some other user has modified the resource between your `GET` and your `PUT` you would\n"
"get this answer back:"
msgstr "如果其他用户修改了您的 `GET` 和 `PUT` 之间的资源，您会得到这样的回复："

#: _guides/rest.adoc
#, fuzzy
msgid "Negotiation"
msgstr "谈判"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"One of the main ideas of REST (https://tools.ietf.org/html/rfc7231#section-3.4[and HTTP]) is that\n"
"your resource is independent of its representation, and\n"
"that both the client and server are free to represent their resources in as many media types as\n"
"they want. This allows the server to declare support for multiple representations and let the\n"
"client declare which ones it supports and get served something appropriate."
msgstr "REST （ link:https://tools.ietf.org/html/rfc7231#section-3.4[和 HTTP] ）的主要理念之一是，资源独立于其表示形式，客户端和服务器都可以自由地使用多种媒体类型来表示其资源。这就允许服务器声明支持多种表示法，让客户端声明它支持哪些表示法，并获得相应的服务。"

#: _guides/rest.adoc
#, fuzzy
msgid "The following endpoint supports serving cheese in plain text or JSON:"
msgstr "以下端点支持以纯文本或 JSON 格式提供奶酪："

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The user will be able to select which representation it gets with the\n"
"link:{httpspec}#section-5.3.2[`Accept`] header, in the case of JSON:"
msgstr "用户可以通过 link:{httpspec}#section-5.3.2[Accept] 标头获得的表示形式："

#: _guides/rest.adoc
#, fuzzy
msgid "And for text:"
msgstr "文字方面"

#: _guides/rest.adoc
#, fuzzy
msgid "Similarly, you can `PUT` two different representations. JSON:"
msgstr "同样，您可以 `PUT` 两种不同的表示法。JSON："

#: _guides/rest.adoc
#, fuzzy
msgid "Or plain text:"
msgstr "或纯文本："

#: _guides/rest.adoc
#, fuzzy
msgid "HTTP Compression"
msgstr "HTTP 压缩"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"The body of an HTTP response is not compressed by default.\n"
"You can enable the HTTP compression support by means of `quarkus.http.enable-compression=true`."
msgstr "HTTP 响应的正文默认不压缩。您可以通过 `quarkus.http.enable-compression=true` 启用 HTTP 压缩支持。"

#: _guides/rest.adoc
#, fuzzy
msgid "If compression support is enabled then the response body is compressed if:"
msgstr "如果启用了压缩支持，则在下列情况下对响应正文进行压缩："

#: _guides/rest.adoc
#, fuzzy
msgid "the resource method is annotated with `@io.quarkus.vertx.http.Compressed`, or"
msgstr "资源方法注释为 `@io.quarkus.vertx.http.Compressed` ，或"

#: _guides/rest.adoc
#, fuzzy
msgid "the `Content-Type` header is set and the value is a compressed media type as configured via `quarkus.http.compress-media-types`."
msgstr "`Content-Type` 标头，其值为通过 `quarkus.http.compress-media-types` 配置的压缩媒体类型。"

#: _guides/rest.adoc
#, fuzzy
msgid "The response body is never compressed if:"
msgstr "如果出现以下情况，响应正文将不会被压缩"

#: _guides/rest.adoc
#, fuzzy
msgid "the resource method is annotated with `@io.quarkus.vertx.http.Uncompressed`, or"
msgstr "资源方法注释为 `@io.quarkus.vertx.http.Uncompressed` ，或"

#: _guides/rest.adoc
#, fuzzy
msgid "the `Content-Type` header is not set."
msgstr "`Content-Type` 标头未设置。"

#: _guides/rest.adoc
#, fuzzy
msgid "By default, the following list of media types is compressed: `text/html`, `text/plain`, `text/xml`, `text/css`, `text/javascript` and `application/javascript`."
msgstr "默认情况下，以下媒体类型列表会被压缩： `text/html` , `text/plain` , `text/xml` , `text/css` , `text/javascript` 和 `application/javascript` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "If the client does not support HTTP compression then the response body is not compressed."
msgstr "如果客户端不支持 HTTP 压缩，则不会对响应体进行压缩。"

#: _guides/rest.adoc
#, fuzzy
msgid "Include/Exclude Jakarta REST classes"
msgstr "包含/排除 Jakarta REST 类"

#: _guides/rest.adoc
#, fuzzy
msgid "Using Build time conditions"
msgstr "使用构建时间条件"

#: _guides/rest.adoc
#, fuzzy
msgid ""
"Quarkus enables the inclusion or exclusion of Jakarta REST Resources, Providers and Features directly thanks to build time conditions in the same that it does for CDI beans.\n"
"Thus, the various Jakarta REST classes can be annotated with profile conditions (`@io.quarkus.arc.profile.IfBuildProfile` or `@io.quarkus.arc.profile.UnlessBuildProfile`) and/or with property conditions (`io.quarkus.arc.properties.IfBuildProperty` or `io.quarkus.arc.properties.UnlessBuildProperty`) to indicate to Quarkus at build time under which conditions these Jakarta REST classes should be included."
msgstr "Quarkus 与 CDI Bean 一样，通过构建时的条件，可以直接包含或排除 Jakarta REST 资源、提供者和功能。因此，各种 Jakarta REST 类都可以用配置文件条件（ `@io.quarkus.arc.profile.IfBuildProfile` 或 `@io.quarkus.arc.profile.UnlessBuildProfile` ）和/或属性条件（ `io.quarkus.arc.properties.IfBuildProperty` 或 `io.quarkus.arc.properties.UnlessBuildProperty` ）进行注释，以便在构建时向 Quarkus 表明在哪些条件下应包含这些 Jakarta REST 类。"

#: _guides/rest.adoc
#, fuzzy
msgid "In the following example, Quarkus includes the `ResourceForApp1Only` Resource class if and only if the build profile `app1` has been enabled."
msgstr "在下面的示例中，如果且仅当构建配置文件 `app1` 已启用，Quarkus 才会包含 `ResourceForApp1Only` 资源类。"

#: _guides/rest.adoc
#, fuzzy
msgid "Please note that if a Jakarta REST Application has been detected and the method `getClasses()` and/or `getSingletons()` has/have been overridden, Quarkus will ignore the build time conditions and consider only what has been defined in the Jakarta REST Application."
msgstr "请注意，如果检测到一个 Jakarta REST 应用程序，而方法 `getClasses()` 和/或 `getSingletons()` 已被重写，Quarkus 将忽略构建时间条件，只考虑 Jakarta REST 应用程序中定义的内容。"

#: _guides/rest.adoc
#, fuzzy
msgid "Using a runtime property"
msgstr "使用运行时属性"

#: _guides/rest.adoc
#, fuzzy
msgid "Quarkus can also conditionally disable Jakarta REST Resources based on the value of runtime properties using the `@io.quarkus.resteasy.reactive.server.EndpointDisabled` annotation."
msgstr "Quarkus 还可以使用 `@io.quarkus.resteasy.reactive.server.EndpointDisabled` 注解，根据运行时属性的值有条件地禁用 Jakarta REST 资源。"

#: _guides/rest.adoc
#, fuzzy
msgid "In the following example, Quarkus will exclude `RuntimeResource` at runtime if the application has `some.property` configured to `\"disable\"`."
msgstr "在下面的示例中，如果应用程序将 `some.property` 配置为 `\"disable\"` ，Quarkus 将在运行时排除 `RuntimeResource` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "This feature does not work when using native build."
msgstr "使用本机构建时，此功能不起作用。"

#: _guides/rest.adoc
#, fuzzy
msgid "REST Client"
msgstr "REST 客户端"

#: _guides/rest.adoc
#, fuzzy
msgid "In addition to the Server side, Quarkus REST comes with a new MicroProfile REST Client implementation that is non-blocking at its core."
msgstr "除服务器端外，Quarkus REST 还配备了全新的 MicroProfile REST 客户端实现，其核心是无阻塞。"

#: _guides/rest.adoc
#, fuzzy
msgid "Please note that the `quarkus-resteasy-client` extension may not be used with Quarkus REST, use `quarkus-rest-client` instead."
msgstr "请注意， `quarkus-resteasy-client` 扩展不可与 Quarkus REST 一起使用，请使用 `quarkus-rest-client` 。"

#: _guides/rest.adoc
#, fuzzy
msgid "See the xref:rest-client.adoc[REST Client Guide] for more information about the REST client."
msgstr "有关 REST 客户端的更多信息，请参阅《REST 客户端 xref:rest-client.adoc[指南》] 。"
