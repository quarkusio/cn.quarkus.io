# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-08-02 18:23+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/command-mode-reference.adoc:6
#, fuzzy, no-wrap
msgid "Command Mode Applications"
msgstr "命令模式的应用"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:12
#, fuzzy
msgid "This reference covers how to write applications that run and then exit."
msgstr "本参考书涵盖了如何编写运行后退出的应用程序。"

#. type: Title ==
#: upstream/_guides/command-mode-reference.adoc:13
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:17
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。然而，你可以直接进入已完成的例子。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:19
#, fuzzy
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库。 `git clone {quickstarts-clone-url}` ，或者下载一个 {quickstarts-archive-url}[存档] 。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:21
#, fuzzy
msgid "The solution is located in the `getting-started-command-mode` link:{quickstarts-tree-url}/getting-started-command-mode[directory]."
msgstr "该解决方案位于 `getting-started-command-mode` {quickstarts-tree-url}/getting-started-command-mode[目录]中。"

#. type: Title ==
#: upstream/_guides/command-mode-reference.adoc:22
#, no-wrap
msgid "Creating the Maven project"
msgstr "创建Maven项目"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:25
#, fuzzy
msgid "First, we need to create a new Quarkus project with the following command:"
msgstr "首先，我们需要用以下命令创建一个新的Quarkus项目。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:31
#, fuzzy
msgid "The suggested project creation command lines disable the codestarts to avoid including a REST server. Similarly, if you use code.quarkus.io to generate a project, you need to go to *MORE OPTIONS -> Starter Code* and select *No* to avoid adding the RESTEasy Reactive extension."
msgstr "建议项目创建命令行禁用codestarts以避免包括REST服务器。同样，如果你使用code.quarkus.io生成项目，你需要进入 *MORE OPTIONS → Starter Code* 并选择 *No* 以避免添加RESTEasy Reactive扩展。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:33
#, fuzzy
msgid "The RESTEasy Reactive extension is added automatically only if you ask for codestarts and you didn't specify any extensions."
msgstr "只有当你要求提供codestarts并且没有指定任何扩展时，才会自动添加RESTEasy Reactive扩展。"

#. type: Title ==
#: upstream/_guides/command-mode-reference.adoc:35
#, fuzzy, no-wrap
msgid "Writing Command Mode Applications"
msgstr "编写命令模式的应用程序"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:39
#, fuzzy
msgid "There are two different approaches that can be used to implement applications that exit."
msgstr "有两种不同的方法可以用来实现退出的应用程序。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:41
#, fuzzy
msgid "Implement `QuarkusApplication` and have Quarkus run this method automatically"
msgstr "实施 `QuarkusApplication` ，让Quarkus自动运行这个方法"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:42
#, fuzzy
msgid "Implement `QuarkusApplication` and a Java main method, and use the Java main method to launch Quarkus"
msgstr "实现 `QuarkusApplication` 和一个Java主方法，并使用Java主方法来启动Quarkus"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:45
#, fuzzy
msgid "In this document the `QuarkusApplication` instance is referred to as the application main, and a class with a Java main method is the Java main."
msgstr "在本文中， `QuarkusApplication` 实例被称为应用程序main，而具有Java main方法的类就是Java main。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:47
#, fuzzy
msgid "The simplest possible command mode application with access to Quarkus APIs might appear as follows:"
msgstr "访问Quarkus API的最简单的命令模式应用可能如下。"

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:52
#, no-wrap
msgid ""
"import io.quarkus.runtime.QuarkusApplication;\n"
"import io.quarkus.runtime.annotations.QuarkusMain;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:61
#, no-wrap
msgid ""
"@QuarkusMain    // <.>\n"
"public class HelloWorldMain implements QuarkusApplication {\n"
"  @Override\n"
"  public int run(String... args) throws Exception {   // <.>\n"
"    System.out.println(\"Hello \" + args[0]);\n"
"    return 0;\n"
" }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:64
#, fuzzy
msgid "<.> The `@QuarkusMain` annotation tells Quarkus that this is the main entry point.  <.> The `run` method is invoked once Quarkus starts, and the application stops when it finishes."
msgstr "  `@QuarkusMain` 注解告诉Quarkus这是主入口点。<.>一旦Quarkus启动， `run` 方法就会被调用，应用程序结束后就会停止。 "

#. type: Title ===
#: upstream/_guides/command-mode-reference.adoc:65
#, fuzzy, no-wrap
msgid "Contexts"
msgstr "背景"

#. type: Block title
#: upstream/_guides/command-mode-reference.adoc:68
#, fuzzy, no-wrap
msgid "Got a `ContextNotActiveException`?"
msgstr "有一个 `ContextNotActiveException` ？"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:73
#, fuzzy
msgid "A command mode application (like a CLI) is a bit different from say an HTTP service, there is a single call from the command line.  So the notion of _request_ let alone multiple requests does not exist per se.  Therefore, request scope is not the default."
msgstr "一个命令模式的应用程序（如CLI）与HTTP服务有点不同，它只有一个来自命令行的调用。所以 _请求_ 的概念本身并不存在，更不用说多个请求了。因此，请求范围不是默认的。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:76
#, fuzzy
msgid "To get access to your application beans and services, be aware that a `@QuarkusMain` instance is an application scoped bean by default.  It has access to singletons, application and dependent scoped beans."
msgstr "为了获得对应用程序Bean和服务的访问，请注意， `@QuarkusMain` 实例默认是一个应用程序范围的Bean。它可以访问单子、应用和依赖范围的Bean。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:80
#, fuzzy
msgid "If you want to interact with beans that requires a request scope, simply add the `@ActivateRequestContext` annotation on your `run()` method.  This let `run()` have access to methods like `listAll()` and `query*` methods on a Panache Entity.  Without it, you will eventually get a `ContextNotActiveException` when accessing such classes/beans."
msgstr "如果你想与需要请求范围的bean交互，只需在你的 `run()` 方法上添加 `@ActivateRequestContext` 注解。这让 `run()` 可以访问像Panache实体上的 `listAll()` 和 `query*` 方法。如果没有它，你在访问这些类/豆时最终会得到一个 `ContextNotActiveException` 。"

#. type: Title ===
#: upstream/_guides/command-mode-reference.adoc:82
#, fuzzy, no-wrap
msgid "Main method"
msgstr "主要方法"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:84
#, fuzzy
msgid "If we want to use a Java main to run the application main it would look like:"
msgstr "如果我们想用一个Java main来运行应用程序的main，它看起来就像。"

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:89
#, no-wrap
msgid ""
"import io.quarkus.runtime.Quarkus;\n"
"import io.quarkus.runtime.annotations.QuarkusMain;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:92
#, no-wrap
msgid ""
"@QuarkusMain\n"
"public class JavaMain {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:97
#, no-wrap
msgid ""
"    public static void main(String... args) {\n"
"        Quarkus.run(HelloWorldMain.class, args);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:101
#, fuzzy
msgid "This is effectively the same as running the `HelloWorldMain` application main directly, but has the advantage it can be run from the IDE."
msgstr "这实际上与直接运行 `HelloWorldMain` 应用程序主程序相同，但它的优点是可以从IDE中运行。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:103
#, fuzzy
msgid "If a class that implements `QuarkusApplication` and has a Java main then the Java main will be run."
msgstr "如果一个实现了 `QuarkusApplication` ，并且有一个Java main的类，那么Java main将被运行。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:108
#, fuzzy
msgid "It is recommended that a Java main perform very little logic, and just launch the application main. In development mode the Java main will run in a different ClassLoader to the main application, so may not behave as you would expect."
msgstr "我们建议Java主程序只执行很少的逻辑，而只是启动应用程序主程序。在开发模式下，Java主程序将在与主程序不同的ClassLoader中运行，所以可能不会像你所期望的那样表现。"

#. type: Title ====
#: upstream/_guides/command-mode-reference.adoc:109
#, fuzzy, no-wrap
msgid "Multiple Main Methods"
msgstr "多种主要方法"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:115
#, fuzzy
msgid "It is possible to have multiple main methods in an application, and select between them at build time.  The `@QuarkusMain` annotation takes an optional 'name' parameter, and this can be used to select the main to run using the `quarkus.package.main-class` build time configuration option. If you don't want to use annotations this can also be used to specify the fully qualified name of a main class."
msgstr "在一个应用程序中可以有多个main方法，并在构建时对它们进行选择。 `@QuarkusMain` 注解需要一个可选的'name'参数，这可以用来选择使用 `quarkus.package.main-class` 构建时间配置选项运行的main。如果你不想使用注解，也可以用它来指定一个主类的完全合格的名称。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:119
#, fuzzy
msgid "By default, the `@QuarkusMain` with no name (i.e. the empty string) will be used, and if it is not present and `quarkus.package.main-class` is not specified then Quarkus will automatically generate a main class that just runs the application."
msgstr "默认情况下，将使用没有名字的 `@QuarkusMain` （即空字符串），如果它不存在，并且没有指定 `quarkus.package.main-class` ，那么Quarkus将自动生成一个只运行应用程序的主类。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:123
#, fuzzy
msgid "The `name` of `@QuarkusMain` must be unique (including the default of the empty string). If you have multiple `@QuarkusMain` annotations in your application the build will fail if the names are not unique."
msgstr " `@QuarkusMain` 的 `name` 必须是唯一的（包括默认的空字符串）。如果你的应用程序中有多个 `@QuarkusMain` 注释，如果名称不唯一，构建将失败。"

#. type: Title ===
#: upstream/_guides/command-mode-reference.adoc:124
#, fuzzy, no-wrap
msgid "The command mode lifecycle"
msgstr "命令模式的生命周期"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:127
#, fuzzy
msgid "When running a command mode application the basic lifecycle is as follows:"
msgstr "当运行一个命令模式的应用程序时，其基本生命周期如下。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:129
#, fuzzy
msgid "Start Quarkus"
msgstr "启动Quarkus"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:130
#, fuzzy
msgid "Run the `QuarkusApplication` main method"
msgstr "运行 `QuarkusApplication` 主方法"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:131
#, fuzzy
msgid "Shut down Quarkus and exit the JVM after the main method returns"
msgstr "在main方法返回后关闭Quarkus并退出JVM。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:135
#, fuzzy
msgid "Shutdown is always initiated by the application main thread returning. If you want to run some logic on startup, and then run like a normal application (i.e. not exit) then you should call `Quarkus.waitForExit` from the main thread (A non-command mode application is essentially just running an application that just calls `waitForExit`)."
msgstr "关机总是由应用程序的主线程返回发起的。如果你想在启动时运行一些逻辑，然后像一个正常的应用程序一样运行（即不退出），那么你应该从主线程调用 `Quarkus.waitForExit` （一个非命令模式的应用程序本质上只是运行一个只调用 `waitForExit` ）。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:138
#, fuzzy
msgid "If you want to shut down a running application and you are not in the main thread, then you should call `Quarkus.asyncExit` in order to unblock the main thread and initiate the shutdown process."
msgstr "如果你想关闭一个正在运行的应用程序，而且你不在主线程中，那么你应该调用 `Quarkus.asyncExit` ，以便解除对主线程的封锁并启动关闭程序。"

#. type: Title ===
#: upstream/_guides/command-mode-reference.adoc:139
#, fuzzy, no-wrap
msgid "Development Mode"
msgstr "发展模式"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:143
#, fuzzy
msgid "Also, for command mode applications, the dev mode is supported.  When you start your application in dev mode, the command mode application is executed:"
msgstr "对于命令模式的应用程序，也支持dev模式。当你在开发模式下启动你的应用程序时，命令模式的应用程序会被执行。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:147
#, fuzzy
msgid "As command mode applications will often require arguments to be passed on the command line, this is also possible in dev mode:"
msgstr "由于命令模式的应用程序经常需要在命令行上传递参数，这在开发模式下也是可行的。"

#. type: Block title
#: upstream/_guides/command-mode-reference.adoc:149
#, fuzzy, no-wrap
msgid "CLI"
msgstr "CLI"

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:152
#, no-wrap
msgid "quarkus dev '--help'\n"
msgstr ""

#. type: Block title
#: upstream/_guides/command-mode-reference.adoc:155
#, fuzzy, no-wrap
msgid "Maven"
msgstr "雯雯"

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:158
#, no-wrap
msgid "./mvnw quarkus:dev -Dquarkus.args='--help'\n"
msgstr ""

#. type: Block title
#: upstream/_guides/command-mode-reference.adoc:161
#, fuzzy, no-wrap
msgid "Gradle"
msgstr "渐进式"

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:164
#, no-wrap
msgid "./gradlew quarkusDev --quarkus-args='--help'\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:167
#, fuzzy
msgid "You should see the following down the bottom of the screen after the application is stopped:"
msgstr "在应用程序停止后，你应该看到屏幕下方有以下内容。"

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:170
#, no-wrap
msgid "--\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:172
msgid "Press [space] to restart, [e] to edit command line args (currently '-w --tags 1.0.1.Final'), [r] to resume testing, [o] Toggle test output, [h] for more options>"
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:176
#, fuzzy
msgid "You can press the `Space bar` key and the application will be started again.  You can also use the `e` hotkey to edit the command line arguments and restart your application."
msgstr "你可以按 `Space bar` 键，应用程序将再次启动。你也可以使用 `e` 热键来编辑命令行参数并重新启动你的应用程序。"

#. type: Title ==
#: upstream/_guides/command-mode-reference.adoc:177
#, fuzzy, no-wrap
msgid "Testing Command Mode Applications"
msgstr "测试命令模式的应用"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:182
#, fuzzy
msgid "Command Mode applications can be tested using the `@QuarkusMainTest` and `@QuarkusMainIntegrationTest` annotations. These work in a similar way to `@QuarkusTest` and `@QuarkusIntegrationTest` where `@QuarkusMainTest` will run the CLI tests within the current JVM, while `QuarkusIntegrationTest` is used to run the generated executable (both jars and native)."
msgstr "命令模式应用程序可以使用 `@QuarkusMainTest` 和 `@QuarkusMainIntegrationTest` 注释进行测试。这些工作方式类似于 `@QuarkusTest` 和 `@QuarkusIntegrationTest` ，其中 `@QuarkusMainTest` 将在当前JVM中运行CLI测试，而 `QuarkusIntegrationTest` 则用于运行生成的可执行文件（包括jars和native）。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:184
#, fuzzy
msgid "We can write a simple test for our CLI application above as follows:"
msgstr "我们可以为我们上面的CLI应用程序写一个简单的测试，如下所示。"

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:193
#, no-wrap
msgid ""
"import io.quarkus.test.junit.main.Launch;\n"
"import io.quarkus.test.junit.main.LaunchResult;\n"
"import io.quarkus.test.junit.main.QuarkusMainLauncher;\n"
"import io.quarkus.test.junit.main.QuarkusMainTest;\n"
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:196
#, no-wrap
msgid ""
"@QuarkusMainTest\n"
"public class HelloTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:202
#, no-wrap
msgid ""
"    @Test\n"
"    @Launch(\"World\")\n"
"    public void testLaunchCommand(LaunchResult result) {\n"
"        Assertions.assertTrue(result.getOutput().contains(\"Hello World\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:207
#, no-wrap
msgid ""
"    @Test\n"
"    @Launch(value = {}, exitCode = 1)\n"
"    public void testLaunchCommandFailed() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:215
#, no-wrap
msgid ""
"    @Test\n"
"    public void testManualLaunch(QuarkusMainLauncher launcher) {\n"
"        LaunchResult result = launcher.launch(\"Everyone\");\n"
"        Assertions.assertEquals(0, result.exitCode());\n"
"        Assertions.assertTrue(result.getOutput().contains(\"Hello Everyone\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:220
#, fuzzy
msgid "Each test method must be annotated with `@Launch` to automatically start the application or have a `QuarkusMainLauncher` parameter to manually launch the application."
msgstr "每个测试方法必须用 `@Launch` ，以自动启动应用程序，或有一个 `QuarkusMainLauncher` 参数，以手动启动应用程序。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:222
#, fuzzy
msgid "We can then extend this with an integration test that can be used to test the native executable or runnable jar:"
msgstr "然后，我们可以用一个集成测试来扩展它，该测试可以用来测试本地可执行文件或可运行的jar。"

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:226
#, no-wrap
msgid "import io.quarkus.test.junit.main.QuarkusMainIntegrationTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:230
#, no-wrap
msgid ""
"@QuarkusMainIntegrationTest\n"
"public class HelloIT extends HelloTest {\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/command-mode-reference.adoc:232
#, fuzzy, no-wrap
msgid "Mocking"
msgstr "嘲弄"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:236
#, fuzzy
msgid "CDI injection is not supported in the `@QuarkusMainTest` tests.  Consequently, mocking CDI beans with `QuarkusMock` or `@InjectMock` is not supported either."
msgstr " `@QuarkusMainTest` 测试中不支持CDI注入。因此，也不支持用 `QuarkusMock` 或 `@InjectMock` 嘲弄CDI Bean。"

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:238
msgid "It is possible to mock CDI beans by leveraging xref:getting-started-testing.adoc#testing_different_profiles[test profiles] though."
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:240
msgid "For instance, in the following test, the singleton `CdiBean1` will be mocked by `MockedCdiBean1`:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:244
#, no-wrap
msgid "package org.acme.commandmode.test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:246
#, no-wrap
msgid "import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:249
#, no-wrap
msgid ""
"import jakarta.enterprise.inject.Alternative;\n"
"import jakarta.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:252
#, no-wrap
msgid ""
"import org.junit.jupiter.api.Test;\n"
"import org.acme.commandmode.test.MyCommandModeTest.MyTestProfile;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:258
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTestProfile;\n"
"import io.quarkus.test.junit.TestProfile;\n"
"import io.quarkus.test.junit.main.Launch;\n"
"import io.quarkus.test.junit.main.LaunchResult;\n"
"import io.quarkus.test.junit.main.QuarkusMainTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:262
#, no-wrap
msgid ""
"@QuarkusMainTest\n"
"@TestProfile(MyTestProfile.class)\n"
"public class MyCommandModeTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:268
#, no-wrap
msgid ""
"    @Test\n"
"    @Launch(value = {})\n"
"    public void testLaunchCommand(LaunchResult result) {\n"
"        // ... assertions ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:270
#, no-wrap
msgid "    public static class MyTestProfile implements QuarkusTestProfile {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:276
#, no-wrap
msgid ""
"        @Override\n"
"        public Set<Class<?>> getEnabledAlternatives() {\n"
"            return Set.of(MockedCdiBean1.class); <1>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:280
#, no-wrap
msgid ""
"    @Alternative <2>\n"
"    @Singleton <3>\n"
"    public static class MockedCdiBean1 implements CdiBean1 {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/command-mode-reference.adoc:287
#, no-wrap
msgid ""
"        @Override\n"
"        public String myMethod() {\n"
"            return \"mocked value\";\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:289
msgid "List all the CDI beans for which you want to enable an alternative mocked bean."
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:290
msgid "Use `@Alternative` without a `@Priority`. Make sure you don't use `@Mock`."
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:291
msgid "The scope of the mocked bean should be consistent with the original one."
msgstr ""

#. type: Plain text
#: upstream/_guides/command-mode-reference.adoc:292
msgid "Using this pattern, you can enable specific alternatives for any given test."
msgstr ""
