# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-17 15:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/writing-extensions.adoc:6
#, fuzzy, no-wrap
msgid "Writing Your Own Extension"
msgstr "编写您自己的扩展"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:16
#, fuzzy
msgid "Quarkus extensions add a new developer focused behavior to the core offering, and consist of two distinct parts, buildtime augmentation and runtime container. The augmentation part is responsible for all metadata processing, such as reading annotations, XML descriptors etc. The output of this augmentation phase is recorded bytecode which is responsible for directly instantiating the relevant runtime services."
msgstr "Quarkus扩展为核心产品添加了新的以开发者为中心的行为，由两个不同的部分组成，即构建时增强和运行时容器。增强部分负责所有的元数据处理，如读取注释、XML描述符等。这个增强阶段的输出是记录的字节码，负责直接实例化相关的运行时服务。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:19
#, fuzzy
msgid "This means that metadata is only processed once at build time, which both saves on startup time, and also on memory usage as the classes etc that are used for processing are not loaded (or even present) in the runtime JVM."
msgstr "这意味着元数据只在构建时被处理一次，这既节省了启动时间，也节省了内存的使用，因为用于处理的类等在运行时的JVM中没有被加载（甚至不存在）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:21
#, fuzzy
msgid "This is an in-depth documentation, see the xref:building-my-first-extension.adoc[building my first extension] if you need an introduction."
msgstr "这是一个深入的文档，如果你需要一个介绍，请看 link:building-my-first-extension.html[构建我的第一个扩展] 。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:22
#, fuzzy, no-wrap
msgid "Extension philosophy"
msgstr "推广理念"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:25
#, fuzzy
msgid "This section is a work in progress and gathers the philosophy under which extensions should be designed and written."
msgstr "本节是一项正在进行的工作，收集了设计和编写扩展的理念。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:26
#, fuzzy, no-wrap
msgid "Why an extension framework"
msgstr "为什么要有一个扩展框架"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:32
#, fuzzy
msgid "Quarkus’s mission is to transform your entire application including the libraries it uses, into an artifact that uses significantly less resources than traditional approaches. These can then be used to build native applications using GraalVM.  To do this you need to analyze and understand the full \"closed world\" of the application.  Without the full and complete context, the best that can be achieved is partial and limited generic support.  By using the Quarkus extension approach, we can bring Java applications in line with memory footprint constrained environments like Kubernetes or cloud platforms."
msgstr "Quarkus的任务是将你的整个应用程序，包括它所使用的库，转化为一个人工制品，其使用的资源明显少于传统方法。然后，这些可以被用来构建使用GraalVM的本地应用程序。要做到这一点，你需要分析和理解应用程序的完整 \"封闭世界\"。如果没有充分和完整的上下文，能实现的最好结果就是部分和有限的通用支持。通过使用Quarkus扩展方法，我们可以使Java应用程序与Kubernetes或云平台等内存占用率受限的环境保持一致。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:35
#, fuzzy
msgid "The Quarkus extension framework results in significantly improved resource utilization even when GraalVM is not used (e.g. in HotSpot).  Let’s list the actions an extension performs:"
msgstr "Quarkus扩展框架的结果是，即使不使用GraalVM（例如在HotSpot中），也能显著提高资源利用率。让我们列出一个扩展所执行的动作。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:37
#, fuzzy
msgid "Gather build time metadata and generate code"
msgstr "收集构建时间元数据并生成代码"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:38
#, fuzzy
msgid "This part has nothing to do with GraalVM, it is how Quarkus starts frameworks “at build time”"
msgstr "这一部分与GraalVM无关，它是Quarkus \"在构建时 \"启动框架的方式。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:39
#, fuzzy
msgid "The extension framework facilitates reading metadata, scanning classes as well as generating classes as needed"
msgstr "该扩展框架便于读取元数据、扫描类以及根据需要生成类。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:40
#, fuzzy
msgid "A small part of the extension work is executed at runtime via the generated classes, while the bulk of the work is done at build time (called deployment time)"
msgstr "一小部分扩展工作是在运行时通过生成的类执行的，而大部分工作是在构建时（称为部署时）完成的。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:41
#, fuzzy
msgid "Enforce opinionated and sensible defaults based on the close world view of the application (e.g. an application with no `@Entity` does not need to start Hibernate ORM)"
msgstr "根据应用程序的密切世界观，执行有主见和合理的默认值（例如，一个没有 `@Entity` 的应用程序不需要启动Hibernate ORM）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:42
#, fuzzy
msgid "An extension hosts Substrate VM code substitution so that libraries can run on GraalVM"
msgstr "一个扩展主持Substrate VM的代码替换，以便库可以在GraalVM上运行"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:43
#, fuzzy
msgid "Most changes are pushed upstream to help the underlying library run on GraalVM"
msgstr "大多数变化都是向上游推送的，以帮助底层库在GraalVM上运行。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:44
#, fuzzy
msgid "Not all changes can be pushed upstream, extensions host Substrate VM substitutions - which is a form of code patching - so that libraries can run"
msgstr "并非所有的变化都能被推送到上游，扩展程序承载了底层虚拟机的替换--这是一种代码补丁的形式--以便库可以运行"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:45
#, fuzzy
msgid "Host Substrate VM code substitution to help dead code elimination based on the application needs"
msgstr "主机底层虚拟机代码替换，帮助根据应用需求消除死代码"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:46
#, fuzzy
msgid "This is application dependant and cannot really be shared in the library itself"
msgstr "这取决于应用程序，不能真正在库本身中共享。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:47
#, fuzzy
msgid "For example, Quarkus optimizes the Hibernate code because it knows it only needs a specific connection pool and cache provider"
msgstr "例如，Quarkus优化了Hibernate代码，因为它知道它只需要一个特定的连接池和缓存提供者"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:48
#, fuzzy
msgid "Send metadata to GraalVM for example classes in need of reflection"
msgstr "将元数据发送到GraalVM，用于需要反射的实例类。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:49
#, fuzzy
msgid "This information is not static per library (e.g. Hibernate) but the framework has the semantic knowledge and knows which classes need to have reflection (for example @Entity classes)"
msgstr "这些信息不是每个库都是静态的（例如Hibernate），但是框架有语义知识，知道哪些类需要有反射（例如@Entity类）。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:50
#, fuzzy, no-wrap
msgid "Favor build time work over runtime work"
msgstr "倾向于构建时间的工作而不是运行时间的工作"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:54
#, fuzzy
msgid "As much as possible favor doing work at build time (deployment part of the extension) as opposed to let the framework do work at startup time (runtime).  The more is done there, the smaller Quarkus applications using that extension will be and the faster they will load."
msgstr "尽可能在构建时进行工作（扩展的部署部分），而不是让框架在启动时（运行时）进行工作。在那里做的越多，使用该扩展的Quarkus应用程序就越小，加载速度就越快。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:55
#, fuzzy, no-wrap
msgid "How to expose configuration"
msgstr "如何暴露配置"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:59
#, fuzzy
msgid "Quarkus simplifies the most common usages.  This means that its defaults might be different than the library it integrates."
msgstr "Quarkus简化了最常见的使用方法。这意味着它的默认值可能与它集成的库不同。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:62
#, fuzzy
msgid "To make the simple experience easiest, unify the configuration in `application.properties` via SmallRye Config.  Avoid library specific configuration files, or at least make them optional: e.g. `persistence.xml` for Hibernate ORM is optional."
msgstr "为了使简单的体验变得最简单，通过SmallRye Config在 `application.properties` ，统一配置。避免使用特定库的配置文件，或者至少让它们成为可选项：例如，Hibernate ORM的 `persistence.xml` 是可选项。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:67
#, fuzzy
msgid "Extensions should see the configuration holistically as a Quarkus application instead of focusing on the library experience.  For example `quarkus.database.url` and friends are shared between extensions as defining a database access is a shared task (instead of a `hibernate.` property for example).  The most useful configuration options should be exposed as `quarkus.[extension].` instead of the natural namespace of the library.  Less common properties can live in the library namespace."
msgstr "扩展应该把配置作为Quarkus应用程序的整体来看待，而不是专注于库的体验。例如， `quarkus.database.url` 和朋友在扩展之间共享，因为定义数据库访问是一项共享任务（而不是例如 `hibernate.` 属性）。最有用的配置选项应该作为 `quarkus.[extension].` ，而不是库的自然命名空间来公开。不太常见的属性可以住在库的命名空间中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:71
#, fuzzy
msgid "To fully enable the close world assumptions that Quarkus can optimize best, it is better to consider configuration options as build time settled vs overridable at runtime.  Of course properties like host, port, password should be overridable at runtime.  But many properties like enable caching or setting the JDBC driver can safely require a rebuild of the application."
msgstr "为了完全实现Quarkus可以最优化的近似世界的假设，最好把配置选项看作是构建时解决的与运行时可重写的。当然，像主机、端口、密码这样的属性在运行时应该是可重写的。但许多属性，如启用缓存或设置JDBC驱动程序，可以安全地要求重建应用程序。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:72
#, fuzzy, no-wrap
msgid "Static Init Config"
msgstr "静态初始配置"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:75
#, fuzzy
msgid "If the extension provides additional Config Sources and if these are required during Static Init, these must be registered with `StaticInitConfigSourceProviderBuildItem`. Configuration in Static Init does not scan for additional sources to avoid double initialization at application startup time."
msgstr "如果扩展提供了额外的配置源，并且在静态初始化过程中需要这些配置源，这些配置源必须在 `StaticInitConfigSourceProviderBuildItem` 。静态初始化中的配置不会扫描额外的源，以避免在应用程序启动时进行双重初始化。"

#
#
#
#. === API
#. TODO: Describe where to put APIs
#. I wonder if that content should be in the technical aspects
#. === Substitution and recorders
#. TODO: Describe where Substitutions and recorders should live
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:87
#, fuzzy, no-wrap
msgid "Expose your components via CDI"
msgstr "通过CDI暴露你的组件"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:92
#, fuzzy
msgid "Since CDI is the central programming model when it comes to component composition, frameworks and extensions should expose their components as beans that are easily consumable by user applications.  For example, Hibernate ORM exposes `EntityManagerFactory` and `EntityManager` beans, the connection pool exposes `DataSource` beans etc.  Extensions must register these bean definitions at build time."
msgstr "由于CDI是涉及到组件组成的核心编程模型，框架和扩展应该将他们的组件暴露为用户应用程序可以轻松消费的Bean。例如，Hibernate ORM暴露了 `EntityManagerFactory` 和 `EntityManager` Bean，连接池暴露了 `DataSource` Bean等。扩展必须在构建时注册这些Bean定义。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:93
#, fuzzy, no-wrap
msgid "Beans backed by classes"
msgstr "由类支持的豆子"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:96
#, fuzzy
msgid "An extension can produce an <<cdi-reference.adoc#additional_beans,`AdditionalBeanBuildItem`>> to instruct the container to read a bean definition from a class as if it was part of the original application:"
msgstr "一个扩展可以产生一个 link:cdi-reference.html#additional_beans[`AdditionalBeanBuildItem`] 来指示容器从一个类中读取 bean 定义，就好像它是原始应用程序的一部分。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:97
#, fuzzy, no-wrap
msgid "Bean Class Registered by `AdditionalBeanBuildItem`"
msgstr "注册的豆类 `AdditionalBeanBuildItem` "

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:102
#, no-wrap
msgid ""
"@Singleton <1>\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:107
#, no-wrap
msgid ""
"   public String echo(String val) {\n"
"      return val;\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:109
#, fuzzy
msgid "If a bean registered by an `AdditionalBeanBuildItem` does not specify a scope then `@Dependent` is assumed."
msgstr "如果一个由 `AdditionalBeanBuildItem` 注册的Bean没有指定一个范围，那么就假定 `@Dependent` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:111
#, fuzzy
msgid "All other beans can inject such a bean:"
msgstr "所有其他的豆子都可以注射这样的豆子。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:112
#, fuzzy, no-wrap
msgid "Bean Injecting a Bean Produced by an `AdditionalBeanBuildItem`"
msgstr "注入一个豆子，由一个豆子生产出来的。 `AdditionalBeanBuildItem` "

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:117
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class ExampleResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:120
#, no-wrap
msgid ""
"    @Inject\n"
"    Echo echo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:127
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello(String foo) {\n"
"        return echo.echo(foo);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:130
#, fuzzy
msgid "And vice versa - the extension bean can inject application beans and beans provided by other extensions:"
msgstr "反之亦然--扩展Bean可以注入应用Bean和其他扩展提供的Bean。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:131
#, fuzzy, no-wrap
msgid "Extension Bean Injection Example"
msgstr "扩展豆注入实例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:136
#, no-wrap
msgid ""
"@Singleton\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:139
#, no-wrap
msgid ""
"    @Inject\n"
"    DataSource dataSource;  <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:142
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<List<String>> listsOfStrings; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:145
#, no-wrap
msgid ""
"    //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:147
#, fuzzy
msgid "Inject a bean provided by other extension."
msgstr "注入一个由其他扩展提供的bean。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:148
#, fuzzy
msgid "Inject all beans matching the type `List<String>`."
msgstr "注入所有符合类型的豆子 `List<String>` 。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:150
#, fuzzy, no-wrap
msgid "Bean initialization"
msgstr "Bean初始化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:157
#, fuzzy
msgid "Some components may require additional initialization based on information collected during augmentation.  The most straightforward solution is to obtain a bean instance and call a method directly from a build step.  However, it is _illegal_ to obtain a bean instance during the augmentation phase.  The reason is that the CDI container is not started yet.  It's started during the <<bootstrap-three-phases,Static init bootstrap phase>>."
msgstr "一些组件可能需要根据增强期间收集的信息进行额外的初始化。最直接的解决方案是获得一个Bean实例并直接从构建步骤中调用一个方法。然而，在增强阶段获得一个bean实例是 _不合法的_ 。原因是CDI容器还没有启动。它是在 link:#bootstrap-three-phases[Static init bootstrap阶段] 开始的。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:159
#, fuzzy
msgid "`BUILD_AND_RUN_TIME_FIXED` and `RUN_TIME` config roots can be injected in any bean. `RUN_TIME` config roots should only be injected after the bootstrap though."
msgstr " `BUILD_AND_RUN_TIME_FIXED` 和 配置根可以被注入到任何bean中。 配置根应该只在bootstrap之后被注入。 `RUN_TIME` `RUN_TIME` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:165
#, fuzzy
msgid "It is possible to invoke a bean method from a <<bytecode-recording,recorder method>> though.  If you need to access a bean in a `@Record(STATIC_INIT)` build step then is must either depend on the `BeanContainerBuildItem` or wrap the logic in a `BeanContainerListenerBuildItem`.  The reason is simple - we need to make sure the CDI container is fully initialized and started.  However, it is safe to expect that the CDI container is fully initialized and running in a `@Record(RUNTIME_INIT)` build step.  You can obtain a reference to the container via `CDI.current()` or Quarkus-specific `Arc.container()`."
msgstr "不过，从 link:#bytecode-recording[记录器方法] 中调用Bean方法是可能的。如果你需要在 `@Record(STATIC_INIT)` 构建步骤中访问一个Bean，那么必须依赖于 `BeanContainerBuildItem` ，或者将逻辑包裹在 `BeanContainerListenerBuildItem` 。原因很简单--我们需要确保CDI容器被完全初始化和启动。然而，在 `@Record(RUNTIME_INIT)` 构建步骤中，期望CDI容器被完全初始化并运行是安全的。你可以通过 `CDI.current()` 或Quarkus专用的 `Arc.container()` ，获得对容器的引用。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:167
#, fuzzy
msgid "Don't forget to make sure the bean state guarantees the visibility, e.g. via the `volatile` keyword."
msgstr "不要忘记确保Bean状态保证可见性，例如通过 `volatile` 关键字。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:171
#, fuzzy
msgid "There is one significant drawback of this \"late initialization\" approach.  An _uninitialized_ bean may be accessed by other extensions or application components that are instantiated during bootstrap.  We'll cover a more robust solution in the <<synthetic_beans>>."
msgstr "这种 \"晚期初始化 \"的方法有一个明显的缺点。一个 _未初始化的_ Bean可能会被其他扩展或在引导过程中被实例化的应用组件所访问。我们将在 link:#synthetic_beans[[synthetic_beans]] 中介绍一个更强大的解决方案。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:172
#, fuzzy, no-wrap
msgid "Default beans"
msgstr "默认的豆子"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:177
#, fuzzy
msgid "A very useful pattern of creating such beans but also giving application code the ability to easily override some of the beans with custom implementations, is to use the `@DefaultBean` that Quarkus provides.  This is best explained with an example."
msgstr "创建这种Bean的一个非常有用的模式是使用Quarkus提供的 `@DefaultBean` ，同时也让应用程序代码能够轻松地用自定义的实现来覆盖一些Bean。这最好用一个例子来解释。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:179
#, fuzzy
msgid "Let us assume that the Quarkus extension needs to provide a `Tracer` bean which application code is meant to inject into its own beans."
msgstr "让我们假设Quarkus扩展需要提供一个 `Tracer` bean，应用程序代码要将其注入到自己的bean中。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:184
#, no-wrap
msgid ""
"@Dependent\n"
"public class TracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:189
#, no-wrap
msgid ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:195
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:202
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:205
#, fuzzy
msgid "If for example application code wants to use `Tracer`, but also needs to use a custom `Reporter` bean, such a requirement could easily be done using something like:"
msgstr "例如，如果应用程序代码想使用 `Tracer` ，但也需要使用一个自定义的 `Reporter` bean，这样的要求可以很容易地使用类似的东西来完成。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:211
#, no-wrap
msgid ""
"@Dependent\n"
"public class CustomTracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:217
#, no-wrap
msgid ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:219
#, fuzzy, no-wrap
msgid "How to Override a Bean Defined by a Library/Quarkus Extension that doesn't use @DefaultBean"
msgstr "如何覆盖一个不使用@DefaultBean的库/Quarkus扩展所定义的Bean？"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:224
#, fuzzy
msgid "Although `@DefaultBean` is the recommended approach, it is also possible for application code to override beans provided by an extension by marking beans as a CDI `@Alternative` and including `@Priority` annotation.  Let's show a simple example.  Suppose we work on an imaginary \"quarkus-parser\" extension and we have a default bean implementation:"
msgstr "虽然 `@DefaultBean` 是推荐的方法，但应用程序代码也可以通过将Bean标记为CDI `@Alternative` ，并包括 `@Priority` 注解来覆盖扩展提供的Bean。让我们来看看一个简单的例子。假设我们在一个假想的 \"quarkus-parser \"扩展上工作，我们有一个默认的bean实现。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:229
#, no-wrap
msgid ""
"@Dependent\n"
"class Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:234
#, no-wrap
msgid ""
"  String[] parse(String expression) {\n"
"    return expression.split(\"::\");\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:237
#, fuzzy
msgid "And our extension also consumes this parser:"
msgstr "而我们的扩展也会消耗这个解析器。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:242
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class ParserService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:245
#, no-wrap
msgid ""
"  @Inject\n"
"  Parser parser;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:248
#, no-wrap
msgid ""
"  //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:251
#, fuzzy
msgid "Now, if a user or even some other extension needs to override the default implementation of the `Parser` the simplest solution is to use CDI `@Alternative` + `@Priority`:"
msgstr "现在，如果用户甚至其他一些扩展需要覆盖 `Parser` 的默认实现，最简单的解决方案是使用CDI `@Alternative` + `@Priority` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:258
#, no-wrap
msgid ""
"@Alternative <1>\n"
"@Priority(1) <2>\n"
"@Singleton\n"
"class MyParser extends Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:263
#, no-wrap
msgid ""
"  String[] parse(String expression) {\n"
"    // my super impl...\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:265
#, fuzzy
msgid "`MyParser` is an alternative bean."
msgstr " `MyParser` 是一种替代性的豆子。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:266
#, fuzzy
msgid "Enables the alternative. The priority could be any number to override the default bean but if there are multiple alternatives the highest priority wins."
msgstr "启用替代品。优先级可以是任何数字，以覆盖默认的豆子，但如果有多个替代品，则优先级最高的会获胜。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:268
#, fuzzy
msgid "CDI alternatives are only considered during injection and type-safe resolution. For example the default implementation would still receive observer notifications."
msgstr "CDI替代方案只在注入和类型安全的解决过程中被考虑。例如，默认实现仍然会接收观察者的通知。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:270
#, fuzzy, no-wrap
msgid "Synthetic beans"
msgstr "合成豆"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:275
#, fuzzy
msgid "Sometimes it is very useful to be able to register a synthetic bean.  Bean attributes of a synthetic bean are not derived from a java class, method or field.  Instead, the attributes are specified by an extension."
msgstr "有时候，能够注册一个合成Bean是非常有用的。合成Bean的Bean属性不是从java类、方法或字段派生出来的。相反，这些属性是由一个扩展指定的。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:278
#, fuzzy
msgid "Since the CDI container does not control the instantiation of a synthetic bean the dependency injection and other services (such as interceptors) are not supported.  In other words, it's up to the extension to provide all required services to a synthetic bean instance."
msgstr "由于CDI容器不控制合成Bean的实例化，所以不支持依赖性注入和其他服务（如拦截器）。换句话说，要靠扩展来为合成Bean实例提供所有需要的服务。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:281
#, fuzzy
msgid "There are several ways to register a <<cdi-reference.adoc#synthetic_beans,synthetic bean>> in Quarkus.  In this chapter, we will cover a use case that can be used to initialize extension beans in a safe manner (compared to <<bean_init>>)."
msgstr "在Quarkus中，有几种方法可以注册 link:cdi-reference.html#synthetic_beans[合成Bean] 。在这一章中，我们将介绍一个可以用来以安全的方式初始化扩展Bean的用例（与 link:#bean_init[[bean_init]] 相比）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:283
#, fuzzy
msgid "The `SyntheticBeanBuildItem` can be used to register a synthetic bean:"
msgstr " `SyntheticBeanBuildItem` ，可以用来注册一个合成豆。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:285
#, fuzzy
msgid "whose instance can be easily produced through a <<bytecode-recording,recorder>>,"
msgstr "其实例可以通过 link:#bytecode-recording[录音机] 轻松制作。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:286
#, fuzzy
msgid "to provide a \"context\" bean that holds all the information collected during augmentation so that the real components do not need any \"late initialization\" because they can inject the context bean directly."
msgstr "提供一个 \"上下文 \"Bean，持有在增强过程中收集到的所有信息，这样真正的组件就不需要任何 \"后期初始化\"，因为它们可以直接注入上下文Bean。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:287
#, fuzzy, no-wrap
msgid "Instance Produced Through Recorder"
msgstr "通过录音机制作的实例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:297
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo(\"parameters are recorder in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:299
#, fuzzy
msgid "The string value is recorded in the bytecode and used to initialize the instance of `Foo`."
msgstr "该字符串值被记录在字节码中，并用于初始化 `Foo` 的实例。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:300
#, fuzzy, no-wrap
msgid "\"Context\" Holder"
msgstr "\"背景 \"持有人"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:310
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(TestContext.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createContext(\"parameters are recorder in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:312
#, fuzzy
msgid "The \"real\" components can inject the `TestContext` directly."
msgstr "真正的 \"组件可以直接注入 `TestContext` 。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:313
#, fuzzy, no-wrap
msgid "Some types of extensions"
msgstr "某些类型的扩展"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:316
#, fuzzy
msgid "There exist multiple stereotypes of extension, let's list a few."
msgstr "存在着多种陈规定型的扩展，让我们列举几个。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:317
#, fuzzy, no-wrap
msgid "Bare library running"
msgstr "裸库运行"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:322
#, fuzzy
msgid "This is the less sophisticated extension.  It consists of a set of patches to make sure a library runs on GraalVM.  If possible, contribute these patches upstream, not in extensions.  Second best is to write Substrate VM substitutions, which are patches applied during native image compilation."
msgstr "这是不太复杂的扩展。它由一组补丁组成，以确保一个库在GraalVM上运行。如果可能的话，将这些补丁贡献给上游，而不是在扩展中。第二种方法是编写Substrate VM替换，这是在本地镜像编译过程中应用的补丁。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:323
#, fuzzy, no-wrap
msgid "Get a framework running"
msgstr "运行一个框架"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:326
#, fuzzy
msgid "A framework at runtime typically reads configuration, scan the classpath and classes for metadata (annotations, getters etc), build a metamodel on top of which it runs, find options via the service loader pattern, prepare invocation calls (reflection), proxy interfaces, etc. + These operations should be done at build time and the metamodel be passed to the recorder DSL that will generate classes that will be executed at runtime and boot the framework."
msgstr "一个框架在运行时通常会读取配置，扫描classpath和类的元数据（注解、getters等），建立一个元模型，在此基础上运行，通过服务加载器模式找到选项，准备调用（反射），代理接口等。+ 这些操作应该在构建时完成，并将元模型传递给记录器DSL，该DSL将生成将在运行时执行的类，并启动框架。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:327
#, fuzzy, no-wrap
msgid "Get a CDI portable extension running"
msgstr "让CDI便携式扩展运行"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:332
#, fuzzy
msgid "The CDI portable extension model is very flexible.  Too flexible to benefit from the build time boot promoted by Quarkus.  Most extension we have seen do not make use of these extreme flexibility capabilities.  The way to port a CDI extension to Quarkus is to rewrite it as a Quarkus extension which will define the various beans at build time (deployment time in extension parlance)."
msgstr "CDI的便携式扩展模型非常灵活。太灵活了，以至于无法从Quarkus所提倡的构建时间引导中获益。我们看到的大多数扩展都没有利用这些极度灵活的能力。将CDI扩展移植到Quarkus的方法是将其重写为Quarkus扩展，在构建时（用扩展的说法是部署时）定义各种Bean。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:333
#, fuzzy, no-wrap
msgid "Technical aspect"
msgstr "技术方面"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:336
#, fuzzy, no-wrap
msgid "Three Phases of Bootstrap and Quarkus Philosophy"
msgstr "Bootstrap的三个阶段和Quarkus哲学"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:339
#, fuzzy
msgid "There are three distinct bootstrap phases of a Quarkus app:"
msgstr "Quarkus应用程序有三个不同的引导阶段。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:340
#, fuzzy, no-wrap
msgid "Augmentation"
msgstr "扩容"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:345
#, fuzzy
msgid "This is the first phase, and is done by the <<Build Step Processors>>. These processors have access to Jandex annotation information and can parse any descriptors and read annotations, but should not attempt to load any application classes. The output of these build steps is some recorded bytecode, using an extension of the ObjectWeb ASM project called Gizmo(ext/gizmo), that is used to actually bootstrap the application at runtime. Depending on the `io.quarkus.deployment.annotations.ExecutionTime` value of the `@io.quarkus.deployment.annotations.Record` annotation associated with the build step, the step may be run in a different JVM based on the following two modes."
msgstr "这是第一个阶段，由 link:#Build Step Processors[[构建步骤处理器]] 完成。这些处理器可以访问Jandex注解信息，可以解析任何描述符并读取注解，但不应该尝试加载任何应用类。这些构建步骤的输出是一些记录的字节码，使用ObjectWeb ASM项目的一个扩展，叫做Gizmo(ext/gizmo)，它被用来在运行时实际引导应用程序。根据与构建步骤相关的 `@io.quarkus.deployment.annotations.Record` 注释的 `io.quarkus.deployment.annotations.ExecutionTime` 值，该步骤可以根据以下两种模式在不同的JVM中运行。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:346
#, fuzzy, no-wrap
msgid "Static Init"
msgstr "静态启动"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:352
#, fuzzy
msgid "If bytecode is recorded with `@Record(STATIC_INIT)` then it will be executed from a static init method on the main class. For a native executable build, this code is executed in a normal JVM as part of the native build process, and any retained objects that are produced in this stage will be directly serialized into the native executable via an image mapped file.  This means that if a framework can boot in this phase then it will have its booted state directly written to the image, and so the boot code does not need to be executed when the image is started."
msgstr "如果字节码被记录在 `@Record(STATIC_INIT)` ，那么它将从主类的静态init方法中执行。对于本地可执行的构建，这段代码在正常的JVM中执行，作为本地构建过程的一部分，在这个阶段产生的任何保留对象都将通过一个镜像映射文件直接序列化到本地可执行文件中。这意味着，如果一个框架可以在这个阶段启动，那么它的启动状态将直接写入镜像，因此启动代码不需要在镜像启动时执行。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:354
#, fuzzy
msgid "There are some restrictions on what can be done in this stage as the Substrate VM disallows some objects in the native executable. For example you should not attempt to listen on a port or start threads in this phase. In addition, it is disallowed to read run time configuration during static initialization."
msgstr "在这个阶段可以做的事情有一些限制，因为底层虚拟机不允许本地可执行文件中的一些对象。例如，你不应该在这个阶段尝试监听一个端口或启动线程。此外，在静态初始化期间，不允许读取运行时配置。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:359
#, fuzzy
msgid "In non-native pure JVM mode, there is no real difference between Static and Runtime Init, except that Static Init is always executed first. This mode benefits from the same build phase augmentation as native mode as the descriptor parsing and annotation scanning are done at build time and any associated class/framework dependencies can be removed from the build output jar. In servers like WildFly, deployment related classes such as XML parsers hang around for the life of the application, using up valuable memory. Quarkus aims to eliminate this, so that the only classes loaded at runtime are actually used at runtime."
msgstr "在非原生的纯JVM模式下，静态和运行时初始化之间没有真正的区别，只是静态初始化总是先执行。这种模式得益于与本地模式相同的构建阶段增强，因为描述符解析和注释扫描是在构建时完成的，任何相关的类/框架依赖都可以从构建输出罐中移除。在WildFly这样的服务器中，与部署相关的类（如XML解析器）会在应用程序的生命周期中一直存在，占用宝贵的内存。Quarkus的目标是消除这一点，因此在运行时加载的类只有在运行时才会被真正使用。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:362
#, fuzzy
msgid "As an example, the only reason that a Quarkus application should load an XML parser is if the user is using XML in their application. Any XML parsing of configuration should be done in the Augmentation phase."
msgstr "举例来说，Quarkus应用程序应该加载一个XML解析器的唯一原因是用户在他们的应用程序中使用XML。任何配置的XML解析都应该在增强阶段完成。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:363
#, fuzzy, no-wrap
msgid "Runtime Init"
msgstr "运行时启动"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:367
#, fuzzy
msgid "If bytecode is recorded with `@Record(RUNTIME_INIT)` then it is executed from the application's main method. This code will be run on native executable boot. In general as little code as possible should be executed in this phase, and should be restricted to code that needs to open ports etc."
msgstr "如果字节码被记录在 `@Record(RUNTIME_INIT)` ，那么它将从应用程序的主方法中执行。这段代码将在本地可执行启动时运行。一般来说，在这个阶段应该尽可能少地执行代码，应该限制在需要打开端口等的代码上。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:369
#, fuzzy
msgid "Pushing as much as possible into the `@Record(STATIC_INIT)` phase allows for two different optimizations:"
msgstr "将尽可能多的东西推到 `@Record(STATIC_INIT)` 阶段，可以实现两种不同的优化。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:371
#, fuzzy
msgid "In both native executable and pure JVM mode this allows the app to start as fast as possible since processing was done during build time. This also minimizes the classes/native code needed in the application to pure runtime related behaviors."
msgstr "在本地可执行程序和纯JVM模式下，这使得应用程序可以尽可能快地启动，因为处理是在构建时间内完成的。这也使应用程序中需要的类/原生代码最小化为纯运行时相关行为。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:374
#, fuzzy
msgid "Another benefit with native executable mode is that Substrate can more easily eliminate features that are not used. If features are directly initialized via bytecode, Substrate can detect that a method is never called and eliminate that method. If config is read at runtime, Substrate cannot reason about the contents of the config and so needs to keep all features in case they are required."
msgstr "本机可执行模式的另一个好处是，Substrate可以更容易地消除不使用的特性。如果特征是通过字节码直接初始化的，Substrate可以检测到某个方法从未被调用，并消除该方法。如果配置是在运行时读取的，Substrate无法推理出配置的内容，因此需要保留所有的特性，以备需要。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:376
#, fuzzy, no-wrap
msgid "Project setup"
msgstr "项目设置"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:379
#, fuzzy
msgid "Your extension project should be setup as a multi-module project with two submodules:"
msgstr "你的扩展项目应该被设置为一个有两个子模块的多模块项目。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:381
#, fuzzy
msgid "A deployment time submodule that handles the build time processing and bytecode recording."
msgstr "一个部署时间子模块，处理构建时间处理和字节码记录。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:383
#, fuzzy
msgid "A runtime submodule that contains the runtime behavior that will provide the extension behavior in the native executable or runtime JVM."
msgstr "一个运行时子模块，它包含运行时行为，将在本地可执行文件或运行时JVM中提供扩展行为。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:388
#, fuzzy
msgid "Your runtime artifact should depend on `io.quarkus:quarkus-core`, and possibly the runtime artifacts of other Quarkus modules if you want to use functionality provided by them.  Your deployment time module should depend on `io.quarkus:quarkus-core-deployment`, your runtime artifact, and possibly the deployment artifacts of other Quarkus modules if you want to use functionality provided by them."
msgstr "你的运行时工件应该依赖于 `io.quarkus:quarkus-core` ，如果你想使用其他Quarkus模块提供的功能，可能还有其他Quarkus模块的运行时工件。你的部署时间模块应该依赖于 `io.quarkus:quarkus-core-deployment` ，你的运行时间工件，如果你想使用其他Quarkus模块提供的功能，可能还有其他Quarkus模块的部署工件。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:393
#, fuzzy
msgid "Under no circumstances can the runtime module depend on a deployment artifact. This would result in pulling all the deployment time code into runtime scope, which defeats the purpose of having the split."
msgstr "在任何情况下，运行时模块都不能依赖于部署工件。这将导致把所有部署时间的代码拉到运行时范围内，这违背了分割的目的。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:395
#, fuzzy, no-wrap
msgid "Using Maven"
msgstr "使用Maven"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:399
#, fuzzy
msgid "You will need to include the `io.quarkus:quarkus-bootstrap-maven-plugin` to generate the Quarkus extension descriptor included into the runtime artifact, if you are using the Quarkus parent pom it will automatically inherit the correct configuration.  Furthermore, you'll need to configure the `maven-compiler-plugin` to detect the `quarkus-extension-processor` annotation processor."
msgstr "你将需要包括 `io.quarkus:quarkus-bootstrap-maven-plugin` ，以生成Quarkus扩展描述符包含在运行时工件中，如果你使用Quarkus父pom，它将自动继承正确的配置。此外，你需要配置 `maven-compiler-plugin` 来检测 `quarkus-extension-processor` 注释处理器。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:401
#, fuzzy
msgid "You may want to use the `create-extension` mojo of `io.quarkus.platform:quarkus-maven-plugin` to create these Maven modules - see the next section."
msgstr "你可能想使用 `create-extension` mojo of `io.quarkus.platform:quarkus-maven-plugin` 来创建这些Maven模块--见下一节。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:404
#, fuzzy
msgid "By convention the deployment time artifact has the `-deployment` suffix, and the runtime artifact has no suffix (and is what the end user adds to their project)."
msgstr "按照惯例，部署时间的工件有 `-deployment` 后缀，而运行时间的工件没有后缀（是最终用户添加到他们项目中的东西）。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:414
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"      <groupId>io.quarkus</groupId>\n"
"      <artifactId>quarkus-core</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:446
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n"
"            <!-- Executions configuration can be inherited from quarkus-build-parent -->\n"
"            <executions>\n"
"                <execution>\n"
"                    <goals>\n"
"                        <goal>extension-descriptor</goal>\n"
"                    </goals>\n"
"                    <configuration>\n"
"                         <deployment>${project.groupId}:${project.artifactId}-deployment:${project.version}</deployment>\n"
"                   </configuration>\n"
"               </execution>\n"
"           </executions>\n"
"        </plugin>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:449
#, fuzzy
msgid "The above `maven-compiler-plugin` configuration requires version 3.5+."
msgstr "上述 `maven-compiler-plugin` 配置需要3.5以上版本。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:451
#, fuzzy
msgid "You will also need to configure the `maven-compiler-plugin` of the deployment module to detect the `quarkus-extension-processor` annotation processor."
msgstr "你还需要配置部署模块的 `maven-compiler-plugin` ，以检测 `quarkus-extension-processor` 注释处理器。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:460
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-core-deployment</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:477
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:479
#, fuzzy, no-wrap
msgid "Create new Quarkus Core extension modules using Maven"
msgstr "使用Maven创建新的Quarkus Core扩展模块"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:482
#, fuzzy
msgid "Quarkus provides `create-extension` Maven Mojo to initialize your extension project."
msgstr "Quarkus提供 `create-extension` Maven Mojo来初始化你的扩展项目。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:484
#, fuzzy
msgid "It will try to auto-detect its options:"
msgstr "它将尝试自动检测其选项。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:486
#, fuzzy
msgid "from `quarkus` (Quarkus Core) or `quarkus/extensions` directory, it will use the 'Quarkus Core' extension layout and defaults."
msgstr "从 `quarkus` （Quarkus Core）或 `quarkus/extensions` 目录，它将使用'Quarkus Core'扩展布局和默认值。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:487
#, fuzzy
msgid "with `-DgroupId=io.quarkiverse.[extensionId]`, it will use the 'Quarkiverse' extension layout and defaults."
msgstr "用 `-DgroupId=io.quarkiverse.[extensionId]` ，它将使用'Quarkiverse'扩展布局和默认值。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:488
#, fuzzy
msgid "in other cases it will use the 'Standalone' extension layout and defaults."
msgstr "在其他情况下，它将使用 \"独立 \"扩展布局和默认值。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:489
#, fuzzy
msgid "we may introduce other layout types in the future."
msgstr "我们可能在未来引入其他布局类型。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:491
#, fuzzy
msgid "You may not specify any parameter to use the interactive mode: `mvn io.quarkus.platform:quarkus-maven-plugin:{quarkus-version}:create-extension -N`"
msgstr "你可以不指定任何参数来使用互动模式。 `mvn io.quarkus.platform:quarkus-maven-plugin:{quarkus-version}:create-extension -N` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:493
#, fuzzy
msgid "As and example, let's add a new extension called `my-ext` to the Quarkus source tree:"
msgstr "作为例子，让我们在Quarkus源码树上添加一个新的扩展，名为 `my-ext` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:501
#, no-wrap
msgid ""
"git clone https://github.com/quarkusio/quarkus.git\n"
"cd quarkus\n"
"mvn io.quarkus.platform:quarkus-maven-plugin:{quarkus-version}:create-extension -N \\\n"
"    -DextensionId=my-ext \\\n"
"    -Dname=\"My Extension\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:504
#, fuzzy
msgid "by default, the `groupId`, `version`, `quarkusVersion`, `namespaceId`, and `namespaceName` will be consistent with other Quarkus core extensions."
msgstr "默认情况下， `groupId` , `version` , `quarkusVersion` , `namespaceId` , 和 `namespaceName` 将与其他Quarkus核心扩展一致。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:506
#, fuzzy
msgid "The above sequence of commands does the following:"
msgstr "上面的命令序列做了以下工作。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:508
#, fuzzy
msgid "Creates four new Maven modules:"
msgstr "创建四个新的Maven模块。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:509
#, fuzzy
msgid "`quarkus-my-ext-parent` in the `extensions/my-ext` directory"
msgstr " `quarkus-my-ext-parent` 在 目录中 `extensions/my-ext` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:510
#, fuzzy
msgid "`quarkus-my-ext` in the `extensions/my-ext/runtime` directory"
msgstr " `quarkus-my-ext` 在 目录中 `extensions/my-ext/runtime` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:511
#, fuzzy
msgid "`quarkus-my-ext-deployment` in the `extensions/my-ext/deployment` directory; a basic `MyExtProcessor` class is generated in this module."
msgstr " `quarkus-my-ext-deployment` 在 目录中；在这个模块中生成了一个基本的 类。 `extensions/my-ext/deployment` `MyExtProcessor` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:512
#, fuzzy
msgid "`quarkus-my-ext-integration-test` in the `integration-tests/my-ext/deployment` directory; an empty JAX-RS Resource class and two test classes (for JVM mode and native mode) are generated in this module."
msgstr " `quarkus-my-ext-integration-test` 在 目录中；一个空的 JAX-RS 资源类和两个测试类（用于 JVM 模式和本地模式）在该模块中生成。 `integration-tests/my-ext/deployment` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:513
#, fuzzy
msgid "Links these three modules where necessary:"
msgstr "必要时链接这三个模块。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:514
#, fuzzy
msgid "`quarkus-my-ext-parent` is added to the `<modules>` of `quarkus-extensions-parent`"
msgstr " `quarkus-my-ext-parent` 被添加到 的 `<modules>` `quarkus-extensions-parent` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:515
#, fuzzy
msgid "`quarkus-my-ext` is added to the `<dependencyManagement>` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr " `quarkus-my-ext` 被添加到Quarkus BOM（材料清单）的 。 `<dependencyManagement>` `bom/application/pom.xml` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:516
#, fuzzy
msgid "`quarkus-my-ext-deployment` is added to the `<dependencyManagement>` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr " `quarkus-my-ext-deployment` 被添加到Quarkus BOM（材料清单）的 。 `<dependencyManagement>` `bom/application/pom.xml` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:517
#, fuzzy
msgid "`quarkus-my-ext-integration-test` is added to the `<modules>` of `quarkus-integration-tests-parent`"
msgstr " `quarkus-my-ext-integration-test` 被添加到 的 `<modules>` `quarkus-integration-tests-parent` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:519
#, fuzzy
msgid "You also have to fill the `quarkus-extension.yaml` file that describe your extension inside the runtime module `src/main/resources/META-INF` folder."
msgstr "你还必须在运行模块 `src/main/resources/META-INF` 文件夹中填写描述你的扩展的 `quarkus-extension.yaml` 文件。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:521
#, fuzzy
msgid "This is the `quarkus-extension.yaml` of the `quarkus-agroal` extension, you can use it as an example:"
msgstr "这是 `quarkus-agroal` 扩展的 `quarkus-extension.yaml` ，你可以把它作为一个例子。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:535
#, no-wrap
msgid ""
"name: \"Agroal - Database connection pool\"\n"
"metadata:\n"
"  keywords:\n"
"  - \"agroal\"\n"
"  - \"database-connection-pool\"\n"
"  - \"datasource\"\n"
"  - \"jdbc\"\n"
"  guide: \"https://quarkus.io/guides/datasource\"\n"
"  categories:\n"
"  - \"data\"\n"
"  status: \"stable\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:540
#, fuzzy
msgid "The `name` parameter of the mojo is optional.  If you do not specify it on the command line, the plugin will derive it from `extensionId` by replacing dashes with spaces and uppercasing each token.  So you may consider omitting explicit `name` in some cases."
msgstr "mojo的 `name` 参数是可选的。如果你不在命令行中指定它，该插件将从 `extensionId` ，用空格替换破折号，并对每个标记进行大写。所以你可以考虑在某些情况下省略明确的 `name` 。"

#.  The following link should point to the mojo page once https://github.com/quarkusio/quarkusio.github.io/issues/265 is fixed
#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:543
#, fuzzy
msgid "Please refer to https://github.com/quarkusio/quarkus/blob/{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java[CreateExtensionMojo JavaDoc] for all the available options of the mojo."
msgstr "请参考 link:https://github.com/quarkusio/quarkus/blob/{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java[CreateExtensionMojo JavaDoc] ，了解Mojo的所有可用选项。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:544
#, fuzzy, no-wrap
msgid "Using Gradle"
msgstr "使用Gradle"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:550
#, fuzzy
msgid "You will need to apply the `io.quarkus.extension` plugin in the `runtime` module of your extension project.  The plugin includes the `extensionDescriptor` task that will generate `META-INF/quarkus-extension.properties` and `META-INF/quarkus-extension.yml` files.  The plugin also enables the `io.quarkus:quarkus-extension-processor` annotation processor in both `deployment` and `runtime` modules.  The name of the deployment module can be configured in the plugin by setting the `deploymentModule` property. The property is set to `deployment` by default:"
msgstr "你将需要在你的扩展项目的 `runtime` 模块中应用 `io.quarkus.extension` 插件。该插件包括 `extensionDescriptor` 任务，将生成 `META-INF/quarkus-extension.properties` 和 `META-INF/quarkus-extension.yml` 文件。该插件还在 `deployment` 和 `runtime` 模块中启用了 `io.quarkus:quarkus-extension-processor` 注释处理器。部署模块的名称可以通过设置 `deploymentArtifact` 属性在插件中进行配置。该属性默认被设置为 `deployment` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:557
#, no-wrap
msgid ""
"plugins {\n"
"    id 'java'\n"
"    id 'io.quarkus.extensions'\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:561
#, no-wrap
msgid ""
"quarkusExtension {\n"
"    deploymentModule = 'deployment'\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:565
#, no-wrap
msgid ""
"dependencies {\n"
"    implementation platform('io.quarkus:quarkus-bom:{quarkus-version}')\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:570
#, fuzzy
msgid "This plugin is still experimental, it does not validate the extension dependencies as the equivalent Maven plugin does."
msgstr "该插件仍处于试验阶段，它不像Maven插件那样验证扩展的依赖性。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:572
#, fuzzy, no-wrap
msgid "Build Step Processors"
msgstr "建立步骤处理器"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:577
#, fuzzy
msgid "Work is done at augmentation time by _build steps_ which produce and consume _build items_.  The build steps found in the deployment modules that correspond to the extensions in the project build are automatically wired together and executed to produce the final build artifact(s)."
msgstr "工作是由生成和消费 _构建项目_ 的 _构建步骤_ 在增强时间完成的。在部署模块中发现的与项目构建中的扩展相对应的构建步骤被自动连接起来并执行，以产生最终的构建工件。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:578
#, fuzzy, no-wrap
msgid "Build steps"
msgstr "建设步骤"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:583
#, fuzzy
msgid "A _build step_ is a non-static method which is annotated with the `@io.quarkus.deployment.annotations.BuildStep` annotation.  Each build step may <<consuming-values,consume>> items that are produced by earlier stages, and <<producing-values,produce>> items that can be consumed by later stages. Build steps are normally only run when they produce a build item that is ultimately consumed by another step."
msgstr " _构建步骤_ 是一个非静态方法，它被注解为 `@io.quarkus.deployment.annotations.BuildStep` 。每个构建步骤都可以 link:#consuming-values[消耗] 由早期阶段产生的项目，并 link:#producing-values[产生] 可由后期阶段消耗的项目。构建步骤通常只在其产生的构建项目最终被另一个步骤消耗时才会运行。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:586
#, fuzzy
msgid "Build steps are normally placed on plain classes within an extension's deployment module.  The classes are automatically instantiated during the augment process and utilize <<injection,injection>>."
msgstr "构建步骤通常被放置在扩展的部署模块中的普通类上。这些类在增强过程中被自动实例化，并利用 link:#injection[注入] 。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:588
#, fuzzy, no-wrap
msgid "Build items"
msgstr "构建项目"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:594
#, fuzzy
msgid "Build items are concrete, final subclasses of the abstract `io.quarkus.builder.item.BuildItem` class.  Each build item represents some unit of information that must be passed from one stage to another.  The base `BuildItem` class may not itself be directly subclassed; rather, there are abstract subclasses for each of the kinds of build item subclasses that _may_ be created: <<simple-build-items,simple>>, <<multi-build-items,multi>>, and <<empty-build-items,empty>>."
msgstr "构建项是抽象的 `io.quarkus.builder.item.BuildItem` 类的具体的、最终的子类。每个构建项代表了一些必须从一个阶段传递到另一个阶段的信息单位。基 `BuildItem` 类本身不能直接被子类化；相反，对于 _可能_ 被创建的每一种构建项子类都有抽象的子类： link:#simple-build-items[简单] 、 link:#empty-build-items[多和空] 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:596
#, fuzzy
msgid "Think of build items as a way for different extensions to communicate with one another.  For example, a build item can:"
msgstr "把构建项目看成是不同的扩展模块之间相互交流的一种方式。例如，一个构建项可以。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:598
#, fuzzy
msgid "expose the fact that a database configuration exists"
msgstr "暴露一个数据库配置存在的事实"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:599
#, fuzzy
msgid "consume that database configuration (e.g. a connection pool extension or an ORM extension)"
msgstr "消费该数据库配置（如连接池扩展或ORM扩展）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:601
#, fuzzy
msgid "ask an extension to do work for another extension: e.g. an extension wanting to define a new CDI bean and asking the ArC extension to do so"
msgstr "要求一个扩展为另一个扩展做工作：例如，一个扩展想定义一个新的CDI Bean并要求ArC扩展这样做。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:603
#, fuzzy
msgid "This is a very flexible mechanism."
msgstr "这是一个非常灵活的机制。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:606
#, fuzzy
msgid "`BuildItem` instances should be immutable, as the producer/consumer model does not allow for mutation to be correctly ordered. This is not enforced but failure to adhere to this rule can result in race conditions."
msgstr " `BuildItem` 实例应该是不可变的，因为生产者/消费者模型不允许突变被正确排序。这一点没有被强制执行，但如果不遵守这一规则，就会导致竞赛条件。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:608
#, fuzzy, no-wrap
msgid "Simple build items"
msgstr "简单的建造项目"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:614
#, fuzzy
msgid "Simple build items are final classes which extend `io.quarkus.builder.item.SimpleBuildItem`.  Simple build items may only be produced by one step in a given build; if multiple steps in a build declare that they produce the same simple build item, an error is raised.  Any number of build steps may consume a simple build item.  A build step which consumes a simple build item will always run _after_ the build step which produced that item."
msgstr "简单构建项是扩展 `io.quarkus.builder.item.SimpleBuildItem` 的最终类。在一个特定的构建中，简单构建项只能由一个步骤产生；如果一个构建中的多个步骤声明它们产生相同的简单构建项，则会产生一个错误。任何数量的构建步骤都可以消耗一个简单构建项。消耗一个简单构建项的构建步骤将总是 _在_ 产生该项目的构建步骤 _之后_ 运行。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:615
#, fuzzy, no-wrap
msgid "Example of a single build item"
msgstr "单一建筑项目的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:624
#, no-wrap
msgid ""
"/**\n"
" * The build item which represents the Jandex index of the application,\n"
" * and would normally be used by many build steps to find usages\n"
" * of annotations.\n"
" */\n"
"public final class ApplicationIndexBuildItem extends SimpleBuildItem {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:626
#, no-wrap
msgid "    private final Index index;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:630
#, no-wrap
msgid ""
"    public ApplicationIndexBuildItem(Index index) {\n"
"        this.index = index;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:635
#, no-wrap
msgid ""
"    public Index getIndex() {\n"
"        return index;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:639
#, fuzzy, no-wrap
msgid "Multi build items"
msgstr "多项建设的项目"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:644
#, fuzzy
msgid "Multiple or \"multi\" build items are final classes which extend `io.quarkus.builder.item.MultiBuildItem`.  Any number of multi build items of a given class may be produced by any number of steps, but any steps which consume multi build items will only run _after_ every step which can produce them has run."
msgstr "多重或 \"多重 \"构建项是扩展 `io.quarkus.builder.item.MultiBuildItem` 的最终类。任何数量的类的多重构建项可以由任何数量的步骤产生，但任何消耗多重构建项的步骤只有 _在_ 每个可以产生它们的步骤运行 _后_ 才会运行。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:645
#, fuzzy, no-wrap
msgid "Example of a multiple build item"
msgstr "多重构建项目的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:651
#, no-wrap
msgid ""
"public final class ServiceWriterBuildItem extends MultiBuildItem {\n"
"    private final String serviceName;\n"
"    private final List<String> implementations;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:661
#, no-wrap
msgid ""
"    public ServiceWriterBuildItem(String serviceName, String... implementations) {\n"
"        this.serviceName = serviceName;\n"
"        // Make sure it's immutable\n"
"        this.implementations = Collections.unmodifiableList(\n"
"            Arrays.asList(\n"
"                implementations.clone()\n"
"            )\n"
"        );\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:665
#, no-wrap
msgid ""
"    public String getServiceName() {\n"
"        return serviceName;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:670
#, no-wrap
msgid ""
"    public List<String> getImplementations() {\n"
"        return implementations;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:672
#, fuzzy, no-wrap
msgid "Example of multiple build item usage"
msgstr "多个构建项目的使用实例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:687
#, no-wrap
msgid ""
"/**\n"
" * This build step produces a single multi build item that declares two\n"
" * providers of one configuration-related service.\n"
" */\n"
"@BuildStep\n"
"public ServiceWriterBuildItem registerOneService() {\n"
"    return new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyFirstConfigConverterImpl.class.getName(),\n"
"        MySecondConfigConverterImpl.class.getName()\n"
"    );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:706
#, no-wrap
msgid ""
"/**\n"
" * This build step produces several multi build items that declare multiple\n"
" * providers of multiple configuration-related services.\n"
" */\n"
"@BuildStep\n"
"public void registerSeveralServices(\n"
"    BuildProducer<ServiceWriterBuildItem> providerProducer\n"
") {\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyThirdConfigConverterImpl.class.getName(),\n"
"        MyFourthConfigConverterImpl.class.getName()\n"
"    ));\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        ConfigSource.class.getName(),\n"
"        MyConfigSourceImpl.class.getName()\n"
"    ));\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:717
#, no-wrap
msgid ""
"/**\n"
" * This build step aggregates all the produced service providers\n"
" * and outputs them as resources.\n"
" */\n"
"@BuildStep\n"
"public void produceServiceFiles(\n"
"    List<ServiceWriterBuildItem> items,\n"
"    BuildProducer<GeneratedResourceBuildItem> resourceProducer\n"
") throws IOException {\n"
"    // Aggregate all of the providers\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:728
#, no-wrap
msgid ""
"    Map<String, Set<String>> map = new HashMap<>();\n"
"    for (ServiceWriterBuildItem item : items) {\n"
"        String serviceName = item.getName();\n"
"        for (String implName : item.getImplementations()) {\n"
"            map.computeIfAbsent(\n"
"                serviceName,\n"
"                (k, v) -> new LinkedHashSet<>()\n"
"            ).add(implName);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:749
#, no-wrap
msgid ""
"    // Now produce the resource(s) for the SPI files\n"
"    for (Map.Entry<String, Set<String>> entry : map.entrySet()) {\n"
"        String serviceName = entry.getKey();\n"
"        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n"
"            try (OutputStreamWriter w = new OutputStreamWriter(os, StandardCharsets.UTF_8)) {\n"
"                for (String implName : entry.getValue()) {\n"
"                    w.write(implName);\n"
"                    w.write(System.lineSeparator());\n"
"                }\n"
"                w.flush();\n"
"            }\n"
"            resourceProducer.produce(\n"
"                new GeneratedResourceBuildItem(\n"
"                    \"META-INF/services/\" + serviceName,\n"
"                    os.toByteArray()\n"
"                )\n"
"            );\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:752
#, fuzzy, no-wrap
msgid "Empty build items"
msgstr "空建项目"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:757
#, fuzzy
msgid "Empty build items are final (usually empty) classes which extend `io.quarkus.builder.item.EmptyBuildItem`.  They represent build items that don't actually carry any data, and allow such items to be produced and consumed without having to instantiate empty classes.  They cannot themselves be instantiated."
msgstr "空构建项是扩展 `io.quarkus.builder.item.EmptyBuildItem` 的最终（通常是空）类。它们代表了实际上不携带任何数据的构建项，并允许此类项目被生产和消费，而无需实例化空类。它们本身不能被实例化。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:758
#, fuzzy, no-wrap
msgid "Example of an empty build item"
msgstr "一个空的构建项目的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:764
#, no-wrap
msgid ""
"public final class NativeImageBuildItem extends EmptyBuildItem {\n"
"    // empty\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:769
#, fuzzy
msgid "Empty build items can represent \"barriers\" which can impose ordering between steps.  They can also be used in the same way that popular build systems use \"pseudo-targets\", which is to say that the build item can represent a conceptual goal that does not have a concrete representation."
msgstr "空的构建项可以代表 \"障碍\"，它可以在步骤之间强加排序。它们也可以用流行的构建系统使用 \"伪目标 \"的方式来使用，也就是说，构建项可以代表一个没有具体表现的概念性目标。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:770
#, fuzzy, no-wrap
msgid "Example of usage of an empty build item in a \"pseudo-target\" style"
msgstr "在 \"伪目标 \"风格中使用空构建项的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:785
#, no-wrap
msgid ""
"/**\n"
" * Contrived build step that produces the native image on disk.  The main augmentation\n"
" * step (which is run by Maven or Gradle) would be declared to consume this empty item,\n"
" * causing this step to be run.\n"
" */\n"
"@BuildStep\n"
"@Produce(NativeImageBuildItem.class)\n"
"void produceNativeImage() {\n"
"    // ...\n"
"    // (produce the native image)\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:787
#, fuzzy, no-wrap
msgid "Example of usage of an empty build item in a \"barrier\" style"
msgstr "在 \"障碍 \"风格中使用空的建筑项目的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:799
#, no-wrap
msgid ""
"/**\n"
" * This would always run after {@link #produceNativeImage()} completes, producing\n"
" * an instance of {@code SomeOtherBuildItem}.\n"
" */\n"
"@BuildStep\n"
"@Consume(NativeImageBuildItem.class)\n"
"SomeOtherBuildItem secondBuildStep() {\n"
"    return new SomeOtherBuildItem(\"foobar\");\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:802
#, fuzzy, no-wrap
msgid "Injection"
msgstr "注射"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:805
#, fuzzy
msgid "Classes which contain build steps support the following types of injection:"
msgstr "包含构建步骤的类支持以下类型的注入。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:807
#, fuzzy
msgid "Constructor parameter injection"
msgstr "构造函数参数注入"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:808
#, fuzzy
msgid "Field injection"
msgstr "现场注射"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:809
#, fuzzy
msgid "Method parameter injection (for build step methods only)"
msgstr "方法参数注入（仅适用于构建步骤方法）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:812
#, fuzzy
msgid "Build step classes are instantiated and injected for each build step invocation, and are discarded afterwards.  State should only be communicated between build steps by way of build items, even if the steps are on the same class."
msgstr "构建步骤类被实例化并为每个构建步骤调用注入，之后被丢弃。状态只能通过构建项的方式在构建步骤之间进行交流，即使这些步骤是在同一个类上。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:815
#, fuzzy
msgid "Final fields are not considered for injection, but can be populated by way of constructor parameter injection if desired.  Static fields are never considered for injection."
msgstr "最终字段不被考虑注入，但如果需要的话，可以通过构造函数参数注入的方式来填充。静态字段从不考虑注入。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:817
#, fuzzy
msgid "The types of values that can be injected include:"
msgstr "可以注入的值的类型包括。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:819
#, fuzzy
msgid "<<build-items,Build items>> produced by previous build steps"
msgstr "以前的构建步骤所产生的 link:#build-items[构建项目]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:820
#, fuzzy
msgid "<<producing-values,Build producers>> to produce items for subsequent build steps"
msgstr "link:#producing-values[构建生产者] ，为后续构建步骤生产物品"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:821
#, fuzzy
msgid "<<configuration-roots,Configuration root>> types"
msgstr "link:#configuration-roots[配置根基] 类型"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:822
#, fuzzy
msgid "Template objects for <<bytecode-recording,bytecode recording>>"
msgstr "用于 link:#bytecode-recording[字节码记录] 的模板对象"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:825
#, fuzzy
msgid "Objects which are injected into a build step method or its class _must not_ be used outside of that method's execution."
msgstr "被注入到构建步骤方法或其类中的对象 _不得_ 在该方法的执行之外使用。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:828
#, fuzzy
msgid "Injection is resolved at compile time via an annotation processor, and the resulting code does not have permission to inject private fields or invoke private methods."
msgstr "注入是在编译时通过注解处理器解决的，产生的代码没有权限注入私有字段或调用私有方法。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:830
#, fuzzy, no-wrap
msgid "Producing values"
msgstr "产生的价值"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:833
#, fuzzy
msgid "A build step may produce values for subsequent steps in several possible ways:"
msgstr "一个构建步骤可以通过几种可能的方式为后续步骤产生数值。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:835
#, fuzzy
msgid "By returning a <<simple-build-items,simple build item>> or <<multi-build-items,multi build item>> instance"
msgstr "通过返回一个 link:#simple-build-items[简单的构建项] 或 link:#multi-build-items[多构建项] 实例"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:836
#, fuzzy
msgid "By returning a `List` of a multi build item class"
msgstr "通过返回一个 `List` ，一个多建筑项目的类别"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:837
#, fuzzy
msgid "By injecting a `BuildProducer` of a simple or multi build item class"
msgstr "通过注入一个简单或多建项目类的 `BuildProducer` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:839
#, fuzzy
msgid "By annotating the method with `@io.quarkus.deployment.annotations.Produce`, giving the class name of a <<empty-build-items,empty build item>>"
msgstr "通过用 `@io.quarkus.deployment.annotations.Produce` 注释方法，给出一个 link:#empty-build-items[空的构建项] 的类名"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:842
#, fuzzy
msgid "If a simple build item is declared on a build step, it _must_ be produced during that build step, otherwise an error will result.  Build producers which are injected into steps _must not_ be used outside of that step."
msgstr "如果一个简单的构建项被声明在一个构建步骤上，它 _必须_ 在该构建步骤中被生产出来，否则将导致错误。被注入到步骤中的构建生产者 _不能_ 在该步骤之外使用。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:848
#, fuzzy
msgid "Note that a `@BuildStep` method will only be called if it produces something that another consumer or the final output requires. If there is no consumer for a particular item then it will not be produced. What is required will depend on the final target that is being produced.  For example, when running in developer mode the final output will not ask for GraalVM-specific build items such as `ReflectiveClassBuildItem`, so methods that only produce these items will not be invoked."
msgstr "请注意，只有当一个 `@BuildStep` 方法产生了另一个消费者或最终输出需要的东西时，它才会被调用。如果一个特定的项目没有消费者，那么它将不会被生产。需要什么将取决于正在产生的最终目标。例如，当在开发者模式下运行时，最终输出将不会要求GraalVM特定的构建项目，如 `ReflectiveClassBuildItem` ，所以只产生这些项目的方法将不会被调用。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:850
#, fuzzy, no-wrap
msgid "Consuming values"
msgstr "消耗价值"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:853
#, fuzzy
msgid "A build step may consume values from previous steps in the following ways:"
msgstr "构建步骤可以通过以下方式消耗先前步骤的值。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:855
#, fuzzy
msgid "By injecting a <<simple-build-items,simple build item>>"
msgstr "通过注入一个 link:#simple-build-items[简单的构建项]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:856
#, fuzzy
msgid "By injecting an `Optional` of a simple build item class"
msgstr "通过注入一个简单构建项目类的 `Optional` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:857
#, fuzzy
msgid "By injecting a `List` of a <<multi-build-items,multi build item>> class"
msgstr "通过注入一个 `List` 的 link:#multi-build-items[多建筑项目] 类"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:859
#, fuzzy
msgid "By annotating the method with `@io.quarkus.deployment.annotations.Consume`, giving the class name of a <<empty-build-items,empty build item>>"
msgstr "通过用 `@io.quarkus.deployment.annotations.Consume` 注释方法，给出一个 link:#empty-build-items[空的构建项] 的类名"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:862
#, fuzzy
msgid "Normally it is an error for a step which is included to consume a simple build item that is not produced by any other step.  In this way, it is guaranteed that all of the declared values will be present and non-`null` when a step is run."
msgstr "通常情况下，如果一个被包含的步骤消耗了一个没有被其他步骤产生的简单构建项，那是一个错误。通过这种方式，可以保证在运行一个步骤时，所有声明的值都会存在，并且不 `null` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:865
#, fuzzy
msgid "Sometimes a value isn't necessary for the build to complete, but might inform some behavior of the build step if it is present.  In this case, the value can be optionally injected."
msgstr "有时，一个值对于完成构建并不是必须的，但如果它存在的话，可能会告知构建步骤的某些行为。在这种情况下，该值可以被选择性地注入。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:867
#, fuzzy
msgid "Multi build values are always considered _optional_.  If not present, an empty list will be injected."
msgstr "多重构建值总是被认为是 _可选的_ 。如果不存在，将注入一个空列表。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:869
#, fuzzy, no-wrap
msgid "Weak value production"
msgstr "价值生产疲软"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:874
#, fuzzy
msgid "Normally a build step is included whenever it produces any build item which is in turn consumed by any other build step.  In this way, only the steps necessary to produce the final artifact(s) are included, and steps which pertain to extensions which are not installed or which only produce build items which are not relevant for the given artifact type are excluded."
msgstr "通常情况下，只要一个构建步骤产生了任何构建项，而这些构建项又被其他的构建步骤所消耗，就会被包括在内。这样，只有产生最终工件的必要步骤被包括在内，而与未安装的扩展有关的步骤或只产生与特定工件类型无关的构建项的步骤被排除在外。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:877
#, fuzzy
msgid "For cases where this is not desired behavior, the `@io.quarkus.deployment.annotations.Weak` annotation may be used.  This annotation indicates that the build step should not automatically be included solely on the basis of producing the annotated value."
msgstr "对于不希望出现这种行为的情况，可以使用 `@io.quarkus.deployment.annotations.Weak` 注释。这个注解表明，构建步骤不应该仅仅因为产生注解的值而被自动包含。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:878
#, fuzzy, no-wrap
msgid "Example of producing a build item weakly"
msgstr "弱化生产构建项目的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:894
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the ExecutorClassBuildItem.\n"
" */\n"
"@BuildStep\n"
"void createExecutor(\n"
"        @Weak BuildProducer<GeneratedClassBuildItem> classConsumer,\n"
"        BuildProducer<ExecutorClassBuildItem> executorClassConsumer\n"
") {\n"
"        ClassWriter cw = new ClassWriter(Gizmo.ASM_API_VERSION);\n"
"        String className = generateClassThatCreatesExecutor(cw); // <1>\n"
"        classConsumer.produce(new GeneratedClassBuildItem(true, className, cw.toByteArray()));\n"
"        executorClassConsumer.produce(new ExecutorClassBuildItem(className));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:896
#, fuzzy
msgid "This method (not provided in this example) would generate the class using the ASM API."
msgstr "这个方法（在这个例子中没有提供）将使用ASM API生成这个类。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:903
#, fuzzy
msgid "Certain types of build items are generally always consumed, such as generated classes or resources.  An extension might produce a build item along with a generated class to facilitate the usage of that build item.  Such a build step would use the `@Weak` annotation on the generated class build item, while normally producing the other build item.  If the other build item is ultimately consumed by something, then the step would run and the class would be generated.  If nothing consumes the other build item, the step would not be included in the build process."
msgstr "某些类型的构建项通常总是被消耗的，如生成的类或资源。一个扩展可能会在生成类的同时产生一个构建项，以促进该构建项的使用。这样的构建步骤会在生成类的构建项上使用 `@Weak` 注释，同时通常会生成另一个构建项。如果其他构建项最终被某些东西消耗了，那么这个步骤就会运行，类也会被生成。如果没有什么东西消耗了另一个构建项，那么这个步骤就不会被包含在构建过程中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:906
#, fuzzy
msgid "In the example above, `GeneratedClassBuildItem` would only be produced if `ExecutorClassBuildItem` is consumed by some other build step."
msgstr "在上面的例子中，只有当 `ExecutorClassBuildItem` 被其他构建步骤所消耗时，才会产生 `GeneratedClassBuildItem` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:909
#, fuzzy
msgid "Note that when using <<bytecode-recording,bytecode recording>>, the implicitly generated class can be declared to be weak by using the `optional` attribute of the `@io.quarkus.deployment.annotations.Record` annotation."
msgstr "注意，当使用 link:#bytecode-recording[字节码记录] 时，隐式生成的类可以通过使用 `@io.quarkus.deployment.annotations.Record` 注解的 `optional` 属性来声明为弱类。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:910
#, fuzzy, no-wrap
msgid "Example of using a bytecode recorder where the generated class is weakly produced"
msgstr "使用字节码记录器的例子，其中生成的类是弱生成的"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:922
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the ExecutorBuildItem.\n"
" */\n"
"@BuildStep\n"
"@Record(value = ExecutionTime.RUNTIME_INIT, optional = true) // <1>\n"
"ExecutorBuildItem createExecutor( // <2>\n"
"        ExecutorTemplate executorTemplate,\n"
"        ThreadPoolConfig threadPoolConfig\n"
") {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:931
#, no-wrap
msgid ""
"    return new ExecutorBuildItem(\n"
"        setupTemplate.setupRunTime(\n"
"            shutdownContextBuildItem,\n"
"            threadPoolConfig,\n"
"            launchModeBuildItem.getLaunchMode()\n"
"        )\n"
"    );\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:933
#, fuzzy
msgid "Note the `optional` attribute."
msgstr "注意 `optional` 属性。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:934
#, fuzzy
msgid "This example is using recorder proxies; see the section on <<bytecode-recording,bytecode recording>> for more information."
msgstr "这个例子是使用记录器代理，更多信息请看 link:#bytecode-recording[字节码记录] 一节。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:935
#, fuzzy, no-wrap
msgid "Application Archives"
msgstr "应用档案"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:941
#, fuzzy
msgid "The `@BuildStep` annotation can also register marker files that determine which archives on the class path are considered to be 'Application Archives', and will therefore get indexed. This is done via the `applicationArchiveMarkers`. For example the ArC extension registers `META-INF/beans.xml`, which means that all archives on the class path with a `beans.xml` file will be indexed."
msgstr " `@BuildStep` 注释也可以注册标记文件，以确定类路径上的哪些档案被认为是 \"应用档案\"，因此会被索引。这是通过 `applicationArchiveMarkers` 。例如，ArC扩展注册了 `META-INF/beans.xml` ，这意味着类路径上所有带有 `beans.xml` 文件的档案将被索引。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:942
#, fuzzy, no-wrap
msgid "Using Thread's Context Class Loader"
msgstr "使用线程的上下文类加载器"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:948
#, fuzzy
msgid "The build step will be run with a TCCL that can load user classes from the deployment in a transformer-safe way.  This class loader only lasts for the life of the augmentation, and is discarded afterwards.  The classes will be loaded again in a different class loader at runtime.  This means that loading a class during augmentation does not stop it from being transformed when running in the development/test mode."
msgstr "构建步骤将与一个TCCL一起运行，该TCCL可以以一种转化器安全的方式从部署中加载用户类。这个类加载器只在增强的过程中持续存在，之后就被丢弃了。这些类将在运行时在一个不同的类加载器中被再次加载。这意味着，在增强期间加载一个类并不会阻止它在开发/测试模式下运行时被转换。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:949
#, fuzzy, no-wrap
msgid "Adding external JARs to the indexer with IndexDependencyBuildItem"
msgstr "用IndexDependencyBuildItem向索引器添加外部JARs"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:953
#, fuzzy
msgid "The index of scanned classes will not automatically include your external class dependencies.  To add dependencies, create a `@BuildStep` that produces `IndexDependencyBuildItem` objects, for a `groupId` and `artifactId`."
msgstr "扫描的类的索引不会自动包括你的外部类的依赖关系。要添加依赖关系，创建一个 `@BuildStep` ，产生 `IndexDependencyBuildItem` 对象，为 `groupId` 和 `artifactId` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:955
#, fuzzy
msgid "It is important to specify all the required artifacts to be added to the indexer. No artifacts are implicitly added transitively."
msgstr "重要的是要指定所有需要添加到索引器的工件。没有任何工件会被隐含地添加到索引器中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:957
#, fuzzy
msgid "The `Amazon Alexa` extension adds dependent libraries from the Alexa SDK that are used in Jackson JSON transformations, in order for the reflective classes to identified and included at `BUILD_TIME`."
msgstr " `Amazon Alexa` 扩展添加了来自Alexa SDK的依赖性库，这些库在Jackson JSON转换中使用，以便在 `BUILD_TIME` 中识别和包含反射类。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:971
#, no-wrap
msgid ""
"   @BuildStep\n"
"    void addDependencies(BuildProducer<IndexDependencyBuildItem> indexDependency) {\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-runtime\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-model\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-lambda-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-servlet-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-dynamodb-persistence-adapter\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-apache-client\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-model-runtime\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:974
#, fuzzy
msgid "With the artifacts added to the `Jandex` indexer, you can now search the index to identify classes implementing an interface, sub-classes of a specific class, or classes with a target annotation."
msgstr "有了添加到 `Jandex` 索引器的工件，你现在可以搜索索引来识别实现接口的类、特定类的子类或具有目标注释的类。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:977
#, fuzzy
msgid "For example, the `Jackson` extension uses code like below to search for annotations used in JSON deserialization, and add them to the reflective hierarchy for `BUILD_TIME` analysis."
msgstr "例如， `Jackson` 扩展使用下面这样的代码来搜索JSON反序列化中使用的注释，并将它们添加到反射层次结构中，以便进行 `BUILD_TIME` 分析。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:982
#, no-wrap
msgid "    DotName JSON_DESERIALIZE = DotName.createSimple(JsonDeserialize.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:984
#, no-wrap
msgid "    IndexView index = combinedIndexBuildItem.getIndex();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:993
#, no-wrap
msgid ""
"    // handle the various @JsonDeserialize cases\n"
"    for (AnnotationInstance deserializeInstance : index.getAnnotations(JSON_DESERIALIZE)) {\n"
"        AnnotationTarget annotationTarget = deserializeInstance.target();\n"
"        if (CLASS.equals(annotationTarget.kind())) {\n"
"            DotName dotName = annotationTarget.asClass().name();\n"
"            Type jandexType = Type.create(dotName, Type.Kind.CLASS);\n"
"            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:995
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:998
#, fuzzy, no-wrap
msgid "Visualizing build step dependencies"
msgstr "构建步骤依赖性的可视化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1002
#, fuzzy
msgid "It can occasionally be useful to see a visual representation of the interactions between the various build steps. For such cases, adding `-Djboss.builder.graph-output=build.dot` when building an application will result in the creation of the `build.dot` file in the project's root directory. See link:https://graphviz.org/resources/[this] for a list of software that can open the file and show the actual visual representation."
msgstr "偶尔，看到各种构建步骤之间的互动的可视化表示是很有用的。对于这种情况，在构建一个应用程序时添加 `-Djboss.builder.graph-output=build.dot` ，将导致在项目的根目录下创建 `build.dot` 文件。请看 link:https://graphviz.org/resources/[这个] 可以打开该文件并显示实际视觉表现的软件列表。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1004
#, fuzzy, no-wrap
msgid "Configuration"
msgstr "配置"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1009
#, fuzzy
msgid "Configuration in Quarkus is based on SmallRye Config, an implementation of the MicroProfile Config specification.  All of the standard features of MP-Config are supported; in addition, there are several extensions which are made available by the SmallRye Config project as well as by Quarkus itself."
msgstr "Quarkus中的配置是基于SmallRye Config的，它是MicroProfile Config规范的实现。MP-Config的所有标准功能都被支持；此外，SmallRye Config项目和Quarkus本身还提供了一些扩展功能。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1011
#, fuzzy
msgid "The value of these properties is configured in a `application.properties` file that follows the MicroProfile config format."
msgstr "这些属性的值是在一个 `application.properties` 文件中配置的，该文件遵循MicroProfile的配置格式。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1013
#, fuzzy
msgid "Configuration of Quarkus extensions is injection-based, using annotations."
msgstr "Quarkus扩展的配置是基于注入的，使用注释。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1014
#, fuzzy, no-wrap
msgid "Configuration Keys"
msgstr "配置键"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1017
#, fuzzy
msgid "Leaf configuration keys are mapped to non-`private` fields via the `@io.quarkus.runtime.annotations.ConfigItem` annotation."
msgstr "叶子配置键通过 `@io.quarkus.runtime.annotations.ConfigItem` 注释被映射到非 `private` 字段。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1020
#, fuzzy
msgid "Though the SmallRye Config project is used for implementation, the standard `@ConfigProperty` annotation does not have the same semantics that are needed to support configuration within extensions."
msgstr "尽管SmallRye Config项目被用于实现，但标准的 `@ConfigProperty` 注释并不具有支持扩展内配置所需的相同语义。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1023
#, fuzzy
msgid "Configuration keys are normally derived from the field names that they are tied to.  This is done by de-camel-casing the name and then joining the segments with hyphens (`-`).  Some examples:"
msgstr "配置键通常来自于它们所绑定的字段名。这是通过去掉名称的camel-casing，然后用连字符（ `-` ）连接这些段来完成的。一些例子。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1025
#, fuzzy
msgid "`bindAddress` becomes `bind-address`"
msgstr " `bindAddress` 成为 `bind-address` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1026
#, fuzzy
msgid "`keepAliveTime` becomes `keep-alive-time`"
msgstr " `keepAliveTime` 成为 `keep-alive-time` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1027
#, fuzzy
msgid "`requestDNSTimeout` becomes `request-dns-timeout`"
msgstr " `requestDNSTimeout` 成为 `request-dns-timeout` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1029
#, fuzzy
msgid "The name can also be explicitly specified by giving a `name` attribute to the `@ConfigItem` annotation."
msgstr "名字也可以通过给 `@ConfigItem` 注释一个 `name` 属性来明确指定。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1032
#, fuzzy
msgid "Though it is possible to override the configuration key name using the `name` attribute of `@ConfigItem`, normally this should only be done in cases where (for example) the configuration key name is the same as a Java keyword."
msgstr "尽管可以使用 `@ConfigItem` 的 `name` 属性来覆盖配置键的名称，但通常这只应在配置键的名称与Java关键字相同的情况下进行（例如）。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1033
#, fuzzy, no-wrap
msgid "Configuration Value types"
msgstr "配置值类型"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1037
#, fuzzy
msgid "The type of the field with the `@ConfigItem` annotation determines the conversion that is applied to it.  Quarkus extensions may use the full range of configuration types made available by SmallRye Config, which includes:"
msgstr "带有 `@ConfigItem` 注释的字段的类型决定了应用于它的转换。Quarkus扩展可以使用SmallRye Config提供的全部配置类型，其中包括。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1039
#, fuzzy
msgid "All primitive types and primitive wrapper types"
msgstr "所有原始类型和原始包装类型"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1040
#, fuzzy
msgid "`String`"
msgstr " `String` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1041
#, fuzzy
msgid "Any type which has a constructor accepting a single argument of type `String` or `CharSequence`"
msgstr "任何类型都有一个接受单一参数的构造函数，其类型为 `String` 或 `CharSequence` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1042
#, fuzzy
msgid "Any type which has a static method named `of` which accepts a single argument of type `String`"
msgstr "任何类型都有一个名为 `of` 的静态方法，该方法接受一个类型为 的单一参数。 `String` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1043
#, fuzzy
msgid "Any type which has a static method named `valueOf` or `parse` which accepts a single argument of type `CharSequence` or `String`"
msgstr "任何类型都有一个名为 `valueOf` 或 `parse` 的静态方法，该方法接受类型为 `CharSequence` 或 的单个参数。 `String` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1044
#, fuzzy
msgid "`java.time.Duration`"
msgstr " `java.time.Duration` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1045
#, fuzzy
msgid "`java.util.regex.Pattern`"
msgstr " `java.util.regex.Pattern` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1046
#, fuzzy
msgid "`java.nio.file.Path`"
msgstr " `java.nio.file.Path` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1047
#, fuzzy
msgid "`io.quarkus.runtime.configuration.MemorySize` to represent data sizes"
msgstr " `io.quarkus.runtime.configuration.MemorySize` 来表示数据大小"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1048
#, fuzzy
msgid "`java.net.InetSocketAddress`, `java.net.InetAddress` and `org.wildfly.common.net.CidrAddress`"
msgstr " `java.net.InetSocketAddress` , `java.net.InetAddress` 和 `org.wildfly.common.net.CidrAddress` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1049
#, fuzzy
msgid "`java.util.Locale` where the string value is an IETF BCP 47 language tag"
msgstr " `java.util.Locale` 其中字符串值是IETF BCP 47语言标签"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1050
#, fuzzy
msgid "`java.nio.charset.Charset` where the string value is a canonical name or an alias"
msgstr " `java.nio.charset.Charset` 其中字符串值是一个规范的名称或别名"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1051
#, fuzzy
msgid "`java.time.ZoneId` where the string value is parsed via `java.time.ZoneId.of(String)`"
msgstr " `java.time.ZoneId` 其中字符串值是通过 `java.time.ZoneId.of(String)` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1052
#, fuzzy
msgid "A `List` or `Optional` of any of the above types"
msgstr "一个 `List` 或 `Optional` 以上任何类型。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1053
#, fuzzy
msgid "`OptionalInt`, `OptionalLong`, `OptionalDouble`"
msgstr " `OptionalInt` , `OptionalLong` 。 `OptionalDouble` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1056
#, fuzzy
msgid "In addition, custom converters may be registered by adding their fully qualified class name in file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`."
msgstr "此外，自定义转换器可以通过在文件 `META-INF/services/org.eclipse.microprofile.config.spi.Converter` 中添加其完全合格的类名来注册。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1058
#, fuzzy
msgid "Though these implicit converters use reflection, Quarkus will automatically ensure that they are loaded at the appropriate time."
msgstr "尽管这些隐式转换器使用反射，Quarkus会自动确保它们在适当的时候被加载。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1059
#, fuzzy, no-wrap
msgid "Optional Values"
msgstr "可选值"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1065
#, fuzzy
msgid "If the configuration type is one of the optional types, then empty values are allowed for the configuration key; otherwise, specification of an empty value will result in a configuration error which prevents the application from starting.  This is especially relevant to configuration properties of inherently emptiable values such as `List`, `Set`, and `String`.  Such value types will never be empty; in the event of an empty value, an empty `Optional` is always used."
msgstr "如果配置类型是可选类型之一，则允许配置键为空值；否则，指定一个空值将导致配置错误，使应用程序无法启动。这与固有的可清空值的配置属性特别相关，如 `List` , `Set` , 和 `String` 。这样的值类型永远不会是空的；在空值的情况下，总是使用一个空的 `Optional` 。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1066
#, fuzzy, no-wrap
msgid "Configuration Default Values"
msgstr "配置默认值"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1070
#, fuzzy
msgid "A configuration item can be marked to have a default value.  The default value is used when no matching configuration key is specified in the configuration."
msgstr "一个配置项可以被标记为有一个默认值。当配置中没有指定匹配的配置键时，将使用默认值。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1073
#, fuzzy
msgid "Configuration items with a primitive type (such as `int` or `boolean`) implicitly use a default value of `0` or `false`.  The sole exception to this rule is the `char` type which does not have an implicit default value."
msgstr "具有原始类型的配置项（如 `int` 或 `boolean` ）隐含地使用 `0` 或 `false` 的默认值。这一规则的唯一例外是 `char` 类型，它没有隐含的默认值。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1077
#, fuzzy
msgid "A property with a default value is not implicitly optional.  If a non-optional configuration item with a default value is explicitly specified to have an empty value, the application will report a configuration error and will not start.  If it is desired for a property to have a default value and also be optional, it must have an `Optional` type as described above."
msgstr "具有默认值的属性不是隐含的可选。如果一个具有默认值的非可选配置项被明确指定为具有空值，应用程序将报告一个配置错误，并且不会启动。如果希望一个属性有一个默认值，同时也是可选的，那么它必须有一个如上所述的 `Optional` 类型。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1078
#, fuzzy, no-wrap
msgid "Configuration Groups"
msgstr "配置组"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1082
#, fuzzy
msgid "Configuration values are always collected into grouping classes which are marked with the `@io.quarkus.runtime.annotations.ConfigGroup` annotation.  These classes contain a field for each key within its group.  In addition, configuration groups can be nested."
msgstr "配置值总是被收集到分组类中，这些分组类被标记为 `@io.quarkus.runtime.annotations.ConfigGroup` 注释。这些类包含其组内每个键的一个字段。此外，配置组可以被嵌套。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1083
#, fuzzy, no-wrap
msgid "Optional Configuration Groups"
msgstr "可选的配置组"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1089
#, fuzzy
msgid "A nested configuration group may be wrapped with an `Optional` type.  In this case, the group is not populated unless one or more properties within that group are specified in the configuration.  If the group is populated, then any required properties in the group must also be specified otherwise a configuration error will be reported and the application will not start."
msgstr "一个嵌套的配置组可以用一个 `Optional` 类型来包装。在这种情况下，该组不会被填充，除非该组中的一个或多个属性在配置中被指定。如果该组被填充，那么该组中的任何所需属性也必须被指定，否则将报告一个配置错误，应用程序将无法启动。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1090
#, fuzzy, no-wrap
msgid "Configuration Maps"
msgstr "配置图"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1095
#, fuzzy
msgid "A `Map` can be used for configuration at any position where a configuration group would be allowed.  The key type of such a map *must* be `String`, and its value may be either a configuration group class or a valid leaf type.  The configuration key segment following the map's key segment will be used as the key for map values."
msgstr "一个 `Map` ，可以在允许配置组的任何位置用于配置。这种地图的键类型 *必须* 是 `String` ，其值可以是一个配置组类或一个有效的叶子类型。在地图的键段之后的配置键段将被用作地图值的键。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1097
#, fuzzy, no-wrap
msgid "Configuration Roots"
msgstr "配置根基"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1103
#, fuzzy
msgid "Configuration roots are configuration groups that appear in the root of the configuration tree.  A configuration property's full name is determined by joining the string `quarkus.` with the hyphenated name of the fields that form the path from the root to the leaf field.  For example, if I define a configuration root group called `ThreadPool`, with a nested group in a field named `sizing` that in turn contains a field called `minSize`, the final configuration property will be called `quarkus.thread-pool.sizing.min-size`."
msgstr "配置根是出现在配置树根部的配置组。一个配置属性的全名是通过将字符串 `quarkus.` 与构成从根到叶子字段的路径的字段的连字符名称连接起来确定的。例如，如果我定义了一个名为 `ThreadPool` 的配置根组，其嵌套组包含一个名为 `sizing` 的字段，该字段又包含一个名为 `minSize` 的字段，最终的配置属性将被称为 `quarkus.thread-pool.sizing.min-size` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1107
#, fuzzy
msgid "A configuration root's name can be given with the `name` property, or it can be inferred from the class name.  If the latter, then the configuration key will be the class name, minus any `Config` or `Configuration` suffix, broken up by camel-case, lowercased, and re-joined using hyphens (`-`)."
msgstr "一个配置根的名字可以通过 `name` 属性给出，也可以从类的名字中推断出来。如果是后者，那么配置键将是类的名称，减去任何 `Config` 或 `Configuration` 的后缀，由骆驼大写字母分割，小写字母，并使用连字符重新连接 ( `-` )。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1113
#, fuzzy
msgid "A configuration root's class name can contain an extra suffix segment for the case where there are configuration roots for multiple <<Configuration Root Phases>>.  Classes which correspond to the `BUILD_TIME` and `BUILD_AND_RUN_TIME_FIXED` may end with `BuildTimeConfig` or `BuildTimeConfiguration`, classes which correspond to the `RUN_TIME` phase may end with `RuntimeConfig`, `RunTimeConfig`, `RuntimeConfiguration` or `RunTimeConfiguration` while classes which correspond to the `BOOTSTRAP` configuration may end with `BootstrapConfig` or `BootstrapConfiguration`."
msgstr "一个配置根的类名可以包含一个额外的后缀段，以应对有多个 link:#Configuration Root Phases[[配置根阶段]] 的配置根的情况。对应于 `BUILD_TIME` 和 `BUILD_AND_RUN_TIME_FIXED` 的类可以以 `BuildTimeConfig` 或 `BuildTimeConfiguration` 结尾，对应于 `RUN_TIME` 阶段的类可以以 `RuntimeConfig` 、 `RunTimeConfig` 、 `RuntimeConfiguration` 或 `RunTimeConfiguration` 结尾，而对应于 `BOOTSTRAP` 配置的类可以以 `BootstrapConfig` 或 `BootstrapConfiguration` 结束。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1117
#, fuzzy
msgid "Note: The current implementation is still using injection site to determine the root set, so to avoid migration problems, it is recommended that the injection site (field or parameter) have the same name as the configuration root class until this change is complete."
msgstr "注意：目前的实现仍然使用注入站点来确定根集，所以为了避免迁移问题，建议注入站点（字段或参数）的名称与配置根类相同，直到这一变化完成。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1118
#, fuzzy, no-wrap
msgid "Configuration Root Phases"
msgstr "配置根基阶段"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1122
#, fuzzy
msgid "Configuration roots are strictly bound by configuration phase, and attempting to access a configuration root from outside of its corresponding phase will result in an error.  A configuration root dictates when its contained keys are read from configuration, and when they are available to applications.  The phases defined by `io.quarkus.runtime.annotations.ConfigPhase` are as follows:"
msgstr "配置根受配置阶段的严格约束，试图从其相应阶段之外访问配置根将导致错误。一个配置根决定了何时从配置中读取其包含的键，以及何时可供应用程序使用。 `io.quarkus.runtime.annotations.ConfigPhase` 所定义的阶段如下。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1126
#, fuzzy, no-wrap
msgid "Phase name"
msgstr "阶段名称"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1127
#, fuzzy, no-wrap
msgid "Read & avail. at build time"
msgstr "阅读并在建造时使用"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1128
#, fuzzy, no-wrap
msgid "Avail. at run time"
msgstr "可在运行时使用"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1129
#, fuzzy, no-wrap
msgid "Read during static init"
msgstr "在静态启动时读取"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1130
#, fuzzy, no-wrap
msgid "Re-read during startup (native executable)"
msgstr "在启动期间重新读取（本地可执行文件）。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1132
#, fuzzy, no-wrap
msgid "Notes"
msgstr "笔记"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1133
#, fuzzy, no-wrap
msgid "BUILD_TIME"
msgstr "构建时间（BUILD_TIME"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1134
#: upstream/_guides/writing-extensions.adoc:1141
#: upstream/_guides/writing-extensions.adoc:1142
#: upstream/_guides/writing-extensions.adoc:1149
#: upstream/_guides/writing-extensions.adoc:1151
#: upstream/_guides/writing-extensions.adoc:1156
#: upstream/_guides/writing-extensions.adoc:1157
#: upstream/_guides/writing-extensions.adoc:1158
#, fuzzy, no-wrap
msgid "✓"
msgstr "✓"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1135
#: upstream/_guides/writing-extensions.adoc:1136
#: upstream/_guides/writing-extensions.adoc:1137
#: upstream/_guides/writing-extensions.adoc:1143
#: upstream/_guides/writing-extensions.adoc:1144
#: upstream/_guides/writing-extensions.adoc:1148
#: upstream/_guides/writing-extensions.adoc:1150
#: upstream/_guides/writing-extensions.adoc:1155
#, fuzzy, no-wrap
msgid "✗"
msgstr "✗"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1139
#, fuzzy, no-wrap
msgid "Appropriate for things which affect build."
msgstr "适合于影响建设的事情。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1140
#, fuzzy, no-wrap
msgid "BUILD_AND_RUN_TIME_FIXED"
msgstr "构建和运行时间是固定的"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1146
#, fuzzy, no-wrap
msgid "Appropriate for things which affect build and must be visible for run time code.  Not read from config at run time."
msgstr "适用于影响构建的东西，并且必须对运行时代码可见。不是在运行时从配置中读取。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1147
#, fuzzy, no-wrap
msgid "BOOTSTRAP"
msgstr "靴套"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1153
#, fuzzy, no-wrap
msgid "Used when runtime configuration needs to be obtained from an external system (like `Consul`), but details of that system need to be configurable (for example Consul's URL). The high level way this works is by using the standard Quarkus config sources (such as properties files, system properties, etc.) and producing `ConfigSourceProvider` objects which are subsequently taken into account by Quarkus when creating the final runtime `Config` object."
msgstr "当运行时配置需要从外部系统获得时（如 `Consul` ），但该系统的细节需要可配置（例如Consul的URL）。这个工作的高级方式是使用标准的Quarkus配置源（如属性文件、系统属性等），并产生 `ConfigSourceProvider` 对象，随后Quarkus在创建最终的运行时 `Config` 对象时将考虑到这些对象。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1154
#, fuzzy, no-wrap
msgid "RUN_TIME"
msgstr "运转时间"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1160
#, fuzzy, no-wrap
msgid "Not available at build, read at start in all modes."
msgstr "构建时不可用，在所有模式下启动时读取。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1163
#, fuzzy
msgid "For all cases other than the `BUILD_TIME` case, the configuration root class and all of the configuration groups and types contained therein must be located in, or reachable from, the extension's run time artifact.  Configuration roots of phase `BUILD_TIME` may be located in or reachable from either of the extension's run time or deployment artifacts."
msgstr "对于 `BUILD_TIME` 情况以外的所有情况，配置根类和其中包含的所有配置组和类型必须位于扩展的运行时间工件中，或可从该工件中到达。 `BUILD_TIME` 阶段的配置根可位于扩展的运行时间或部署工件中，或可从其中获取。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1165
#, fuzzy
msgid "_Bootstrap_ configuration steps are executed during runtime-init *before* any of other runtime steps. This means that code executed as part of this step cannot access anything that gets initialized in runtime init steps (runtime synthetic CDI beans being one such example)."
msgstr " _Bootstrap_ 配置步骤是在运行时初始化期间执行的， *在* 其他运行时步骤 *之前* 。这意味着作为这个步骤的一部分执行的代码不能访问任何在运行时初始化步骤中被初始化的东西（运行时合成CDI豆就是这样一个例子）。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1166
#, fuzzy, no-wrap
msgid "Configuration Example"
msgstr "配置实例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1173
#, no-wrap
msgid ""
"import io.quarkus.runtime.annotations.ConfigItem;\n"
"import io.quarkus.runtime.annotations.ConfigGroup;\n"
"import io.quarkus.runtime.annotations.DefaultConverter\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1176
#, no-wrap
msgid ""
"import java.io.File;\n"
"import java.util.logging.Level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1179
#, no-wrap
msgid ""
"@ConfigGroup <1>\n"
"public class FileConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1185
#, no-wrap
msgid ""
"    /**\n"
"     * Enable logging to a file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"true\")\n"
"    boolean enable;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1191
#, no-wrap
msgid ""
"    /**\n"
"     * The log format.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{1.}] (%t) %s%e%n\")\n"
"    String format;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1197
#, no-wrap
msgid ""
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1203
#, no-wrap
msgid ""
"    /**\n"
"     * The name of the file in which logs will be written.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"application.log\")\n"
"    File path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1205
#: upstream/_guides/writing-extensions.adoc:1413
#: upstream/_guides/writing-extensions.adoc:1999
#, no-wrap
msgid "}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1211
#, no-wrap
msgid ""
"/**\n"
" * Logging configuration.\n"
" */\n"
"@ConfigRoot(phase = ConfigPhase.RUN_TIME) <2>\n"
"public class LogConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1213
#, no-wrap
msgid "    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1219
#, no-wrap
msgid ""
"    /**\n"
"     * Configuration properties for the logging file handler.\n"
"     */\n"
"    FileConfig file;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1222
#, no-wrap
msgid ""
"public class LoggingProcessor {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1229
#, no-wrap
msgid ""
"    /**\n"
"     * Logging configuration.\n"
"     */\n"
"    <3>\n"
"    LogConfiguration config;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1233
#, fuzzy
msgid "A configuration property name can be split into segments. For example, a property name like `quarkus.log.file.enable` can be split into the following segments:"
msgstr "一个配置属性名称可以被分割成若干段。例如，像 `quarkus.log.file.enable` 这样的属性名称可以被分割成以下几个部分。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1235
#, fuzzy
msgid "`quarkus` - a namespace claimed by Quarkus which is a prefix for all `@ConfigRoot` classes,"
msgstr " `quarkus` - 是Quarkus声称的一个命名空间，是所有 类的前缀。 `@ConfigRoot` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1236
#, fuzzy
msgid "`log` - a name segment which corresponds to the `LogConfiguration` class annotated with `@ConfigRoot`,"
msgstr " `log` - 一个名称段，对应于用 注释的 类。 `@ConfigRoot` `LogConfiguration` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1237
#, fuzzy
msgid "`file` - a name segment which corresponds to the `file` field in this class,"
msgstr " `file` - 一个名称段，它与该类中的 字段相对应。 `file` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1238
#, fuzzy
msgid "`enabled` - a name segment which corresponds to `enable` field in `FileConfig` class annotated with `@ConfigGroup`."
msgstr " `enabled` - 一个名称段，对应于 类中的 字段，并注有 。 `FileConfig` `enable` `@ConfigGroup` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1242
#, fuzzy
msgid "The `FileConfig` class is annotated with `@ConfigGroup` to indicate that this is an aggregate configuration object containing a collection of configurable properties, rather than being a simple configuration key type."
msgstr " `FileConfig` 类被注解为 `@ConfigGroup` ，以表明这是一个包含可配置属性集合的聚合配置对象，而不是一个简单的配置键类型。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1247
#, fuzzy
msgid "The `@ConfigRoot` annotation indicates that this object is a configuration root group, in this case one which corresponds to a `log` segment. A class name is used to link configuration root group with the segment from a property name. The `Configuration` part is stripped off from a `LogConfiguration` class name and the remaining `Log` is lowercased to become a `log`. Since all `@ConfigRoot` annotated classes uses `quarkus` as a prefix, this finally becomes `quarkus.log` and represents the properties which names begin with `quarkus.log.*`."
msgstr " `@ConfigRoot` 注释表明该对象是一个配置根组，在这种情况下，它对应于一个 `log` 段。一个类名被用来将配置根组与段从属性名中联系起来。 `Configuration` 的部分被从 `LogConfiguration` 类名中剥离，剩下的 `Log` 被小写，成为 `log` 。由于所有 `@ConfigRoot` 注释的类都使用 `quarkus` 作为前缀，这最终成为 `quarkus.log` ，代表名称以 `quarkus.log.*` 开始的属性。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1249
#, fuzzy
msgid "Here the `LoggingProcessor` injects a `LogConfiguration` instance automatically by detecting the `@ConfigRoot` annotation."
msgstr "这里 `LoggingProcessor` ，通过检测 `@ConfigRoot` 注释，自动注入一个 `LogConfiguration` 实例。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1251
#, fuzzy
msgid "A corresponding `application.properties` for the above example could be:"
msgstr "上述例子对应的 `application.properties` ，可以是。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1257
#, no-wrap
msgid ""
"quarkus.log.file.enable=true\n"
"quarkus.log.file.level=DEBUG\n"
"quarkus.log.file.path=/tmp/debug.log\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1260
#, fuzzy
msgid "Since `format` is not defined in these properties, the default value from `@ConfigItem` will be used instead."
msgstr "由于 `format` 没有在这些属性中定义，所以将使用 `@ConfigItem` 的默认值来代替。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1262
#, fuzzy, no-wrap
msgid "Enhanced conversion"
msgstr "加强转换"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1266
#, fuzzy
msgid "You can use enhanced conversion of a config item by using the `@ConvertWith` annotation which accepts a `Converter` class object.  If the annotation is present on a config item, the implicit or custom built in converter in use will be overridden by the value provided.  To do, see the example below which converts `YES` or `NO` values to `boolean`."
msgstr "你可以通过使用 `@ConvertWith` 注解来使用配置项的增强转换，该注解接受一个 `Converter` 类对象。如果配置项上有注解，使用中的隐式或自定义内置转换器将被提供的值所覆盖。要做到这一点，请看下面的例子，它将 `YES` 或 `NO` 的值转换为 `boolean` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1276
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Config item with enhanced converter\n"
"     */\n"
"    @ConvertWith(YesNoConverter.class) // <1>\n"
"    @ConfigItem(defaultValue = \"NO\")\n"
"    Boolean answer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1279
#, no-wrap
msgid "    public static class YesNoConverter implements Converter<Boolean> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1281
#, no-wrap
msgid "        public YesNoConverter() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1287
#, no-wrap
msgid ""
"        @Override\n"
"        public Boolean convert(String s) {\n"
"            if (s == null || s.isEmpty()) {\n"
"                return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1294
#, no-wrap
msgid ""
"            switch (s) {\n"
"                case \"YES\":\n"
"                    return true;\n"
"                case \"NO\":\n"
"                    return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1299
#, no-wrap
msgid ""
"            throw new IllegalArgumentException(\"Unsupported value \" + s + \" given\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1301
#, fuzzy
msgid "Override the default `Boolean` converter and use the provided converter which accepts a `YES` or `NO` config values."
msgstr "覆盖默认的 `Boolean` 转换器，并使用提供的转换器，它接受 `YES` 或 `NO` 配置值。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1304
#, fuzzy
msgid "The corresponding `application.properties` will look like."
msgstr "相应的 `application.properties` ，看起来会是这样。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1307
#, no-wrap
msgid "quarkus.some.answer=YES\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1312
#, fuzzy
msgid "Enum values (config items) are translated to skewed-case (hyphenated) by default. The table below illustrates an enum name and their canonical equivalence:"
msgstr "枚举值（配置项）默认被翻译成倾斜的大写字母（连字符）。下表说明了一个枚举名称和它们的规范性等价物。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1314
#, fuzzy, no-wrap
msgid "Java enu"
msgstr "Java enu"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1316
#, fuzzy, no-wrap
msgid "Canonical equivalent"
msgstr "相当于卡农"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1317
#, fuzzy, no-wrap
msgid "DISCARD"
msgstr "DISCARD"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1319
#, fuzzy, no-wrap
msgid "discard"
msgstr "弃置"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1320
#, fuzzy, no-wrap
msgid "READ_UNCOMMITTED"
msgstr "读_未承诺的"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1322
#, fuzzy, no-wrap
msgid "read-uncommitted"
msgstr "读-未承诺的"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1323
#, fuzzy, no-wrap
msgid "SIGUSR1"
msgstr "证券代码：SIGUSR1"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1325
#, fuzzy, no-wrap
msgid "sigusr1"
msgstr "sigusr1"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1326
#, fuzzy, no-wrap
msgid "JavaEnum"
msgstr "爪哇人"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1328
#, fuzzy, no-wrap
msgid "java-enum"
msgstr "java-enum"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1329
#, fuzzy, no-wrap
msgid "MAKING_LifeDifficult"
msgstr "使生活变得困难"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1331
#, fuzzy, no-wrap
msgid "making-life-difficult"
msgstr "使生活变得困难"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1332
#, fuzzy, no-wrap
msgid "YeOldeJBoss"
msgstr "姚明"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1334
#, fuzzy, no-wrap
msgid "ye-olde-jboss"
msgstr "ye-old-jboss"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1335
#, fuzzy, no-wrap
msgid "camelCaseEnum"
msgstr "CamelCaseEnum"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1337
#, fuzzy, no-wrap
msgid "camel-case-enum"
msgstr "骆驼壳-enum"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1340
#, fuzzy
msgid "To use the default behaviour which is based on implicit converter or a custom defined one add `@DefaultConverter` annotation to the configuration item"
msgstr "要使用基于隐式转换器的默认行为或自定义定义的行为，请在配置项中添加 `@DefaultConverter` 注释"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1351
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeLogConfig {\n"
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @DefaultConverter // <1>\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1353
#, fuzzy
msgid "Use the default converter (built in or a custom converter) to convert `Level.class` enum."
msgstr "使用默认转换器（内置或自定义转换器）转换 `Level.class` 枚举。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1356
#, fuzzy, no-wrap
msgid "Conditional Step Inclusion"
msgstr "有条件的阶梯式包容"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1362
#, fuzzy
msgid "It is possible to only include a given `@BuildStep` under certain conditions.  The `@BuildStep` annotation has two optional parameters: `onlyIf` and `onlyIfNot`.  These parameters can be set to one or more classes which implement `BooleanSupplier`.  The build step will only be included when the method returns `true` (for `onlyIf`) or `false` (for `onlyIfNot`)."
msgstr "在某些条件下，有可能只包括一个特定的 `@BuildStep` 。 `@BuildStep` 注解有两个可选的参数： `onlyIf` 和 `onlyIfNot` 。这些参数可以被设置为一个或多个实现 `BooleanSupplier` 的类。只有当该方法返回 `true` （对于 `onlyIf` ）或 `false` （对于 `onlyIfNot` ）时，构建步骤才会被包含。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1365
#, fuzzy
msgid "The condition class can inject <<configuration-roots,configuration roots>> as long as they belong to a build-time phase.  Run time configuration is not available for condition classes."
msgstr "条件类可以注入 link:#configuration-roots[配置根基] ，只要它们属于构建时阶段。运行时的配置对条件类来说是不可用的。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1368
#, fuzzy
msgid "The condition class may also inject a value of type `io.quarkus.runtime.LaunchMode`.  Constructor parameter and field injection is supported."
msgstr "条件类也可以注入一个类型为 `io.quarkus.runtime.LaunchMode` 的值。支持构造函数参数和字段注入。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:1369
#, fuzzy, no-wrap
msgid "An example of a conditional build step"
msgstr "一个有条件的构建步骤的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1376
#, no-wrap
msgid ""
"@BuildStep(onlyIf = IsDevMode.class)\n"
"LogCategoryBuildItem enableDebugLogging() {\n"
"    return new LogCategoryBuildItem(\"org.your.quarkus.extension\", Level.DEBUG);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1379
#, no-wrap
msgid ""
"static class IsDevMode implements BooleanSupplier {\n"
"    LaunchMode launchMode;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1384
#, no-wrap
msgid ""
"    public boolean getAsBoolean() {\n"
"        return launchMode == LaunchMode.DEVELOPMENT;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1388
#, fuzzy
msgid "If you need to make your build step conditional on the presence or absence of another extension, you can use <<capabilities>> for that."
msgstr "如果你需要使你的构建步骤以另一个扩展的存在或不存在为条件，你可以使用 link:#capabilities[[功能]] 来实现这一点。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1390
#, fuzzy, no-wrap
msgid "Bytecode Recording"
msgstr "字节码记录"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1394
#, fuzzy
msgid "One of the main outputs of the build process is recorded bytecode. This bytecode actually sets up the runtime environment. For example, in order to start Undertow, the resulting application will have some bytecode that directly registers all Servlet instances and then starts Undertow."
msgstr "构建过程的主要输出之一是记录的字节码。这个字节码实际上设置了运行时环境。例如，为了启动Undertow，生成的应用程序将有一些字节码，直接注册所有Servlet实例，然后启动Undertow。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1400
#, fuzzy
msgid "As writing bytecode directly is complex, this is instead done via bytecode recorders. At deployment time, invocations are made on recorder objects that contain the actual runtime logic, but instead of these invocations proceeding as normal they are intercepted and recorded (hence the name). This recording is then used to generate bytecode that performs the same sequence of invocations at runtime. This is essentially a form of deferred execution where invocations made at deployment time get deferred until runtime."
msgstr "由于直接编写字节码是很复杂的，所以这是由字节码记录器来完成的。在部署时，调用包含实际运行时逻辑的记录器对象，但这些调用不是正常进行的，而是被拦截和记录的（因此得名）。然后，这种记录被用来生成字节码，在运行时执行相同的调用序列。这实质上是一种延迟执行的形式，在部署时进行的调用被推迟到运行时。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1402
#, fuzzy
msgid "Let's look at the classic 'Hello World' type example. To do this the Quarkus way we would create a recorder as follows:"
msgstr "让我们看一下经典的 \"Hello World \"类型的例子。用Quarkus的方式来做，我们将创建一个记录器，如下所示。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1407
#, no-wrap
msgid ""
"@Recorder\n"
"class HelloRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1411
#, no-wrap
msgid ""
"  public void sayHello(String name) {\n"
"    System.out.println(\"Hello\" + name);\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1416
#, fuzzy
msgid "And then create a build step that uses this recorder:"
msgstr "然后创建一个使用这个记录器的构建步骤。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1424
#, no-wrap
msgid ""
"@Record(RUNTIME_INIT)\n"
"@BuildStep\n"
"public void helloBuildStep(HelloRecorder recorder) {\n"
"    recorder.sayHello(\"World\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1429
#, fuzzy
msgid "When this build step is run nothing is printed to the console. This is because the `HelloRecorder` that is injected is actually a proxy that records all invocations. Instead if we run the resulting Quarkus program we will see 'Hello World' printed to the console."
msgstr "当这个构建步骤运行时，没有任何东西被打印到控制台。这是因为被注入的 `HelloRecorder` 实际上是一个记录所有调用的代理。相反，如果我们运行生成的Quarkus程序，我们将看到 \"Hello World \"打印到控制台。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1434
#, fuzzy
msgid "Methods on a recorder can return a value, which must be proxiable (if you want to return a non-proxiable item wrap it in `io.quarkus.runtime.RuntimeValue`). These proxies may not be invoked directly, however they can be passed into other recorder methods. This can be any recorder method, including from other `@BuildStep` methods, so a common pattern is to produce `BuildItem` instances that wrap the results of these recorder invocations."
msgstr "记录器上的方法可以返回一个值，这个值必须是可代理的（如果你想返回一个不可代理的项目，请用 `io.quarkus.runtime.RuntimeValue` ）。这些代理不能被直接调用，但是它们可以被传递到其他记录器方法中。这可以是任何记录器方法，包括来自其他 `@BuildStep` 方法，所以一个常见的模式是产生 `BuildItem` 实例，包裹这些记录器调用的结果。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1438
#, fuzzy
msgid "For instance, in order to make arbitrary changes to a Servlet deployment Undertow has a `ServletExtensionBuildItem`, which is a `MultiBuildItem` that wraps a `ServletExtension` instance. I can return a `ServletExtension` from a recorder in another module, and Undertow will consume it and pass it into the recorder method that starts Undertow."
msgstr "例如，为了对Servlet部署进行任意修改，Undertow有一个 `ServletExtensionBuildItem` ，这是一个包裹着 `ServletExtension` 实例的 `MultiBuildItem` 。我可以从另一个模块的记录器中返回一个 `ServletExtension` ，Undertow会消费它并把它传到启动Undertow的记录器方法中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1442
#, fuzzy
msgid "At runtime the bytecode will be invoked in the order it is generated. This means that build step dependencies implicitly control the order that generated bytecode is run. In the example above we know that the bytecode that produces a `ServletExtensionBuildItem` will be run before the bytecode that consumes it."
msgstr "在运行时，字节码将按照其生成的顺序被调用。这意味着构建步骤的依赖性隐含地控制了生成的字节码的运行顺序。在上面的例子中，我们知道产生 `ServletExtensionBuildItem` 的字节码将在消耗它的字节码之前运行。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1444
#, fuzzy
msgid "The following objects can be passed to recorders:"
msgstr "以下对象可以被传递给记录者。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1446
#, fuzzy
msgid "Primitives"
msgstr "基本原理"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1447
#, fuzzy
msgid "String"
msgstr "字符串"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1448
#, fuzzy
msgid "Class<?> objects"
msgstr "类<?>对象"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1449
#, fuzzy
msgid "Objects returned from a previous recorder invocation"
msgstr "从以前的记录器调用中返回的对象"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1450
#, fuzzy
msgid "Objects with a no-arg constructor and getter/setters for all properties (or public fields)"
msgstr "具有无参数构造函数和所有属性（或公共字段）的getter/setters的对象"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1451
#, fuzzy
msgid "Objects with a constructor annotated with `@RecordableConstructor` with parameter names that match field names"
msgstr "具有构造函数注释的对象， `@RecordableConstructor` ，参数名称与字段名称相匹配"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1452
#, fuzzy
msgid "Any arbitrary object via the `io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)` mechanism"
msgstr "通过 `io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)` 机制，任何任意的对象"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1453
#, fuzzy
msgid "Arrays, Lists and Maps of the above"
msgstr "上述的数组、列表和地图"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1454
#, fuzzy, no-wrap
msgid "Injecting Configuration into Recorders"
msgstr "将配置注入记录器中"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1461
#, fuzzy
msgid "Configuration objects with phase `RUNTIME` or `BUILD_AND_RUNTIME_FIXED` can be injected into recorders via constructor injection. Just create a constructor that takes the configuration objects the recorder needs. If the recorder has multiple constructors you can annotate the one you want Quarkus to use with `@Inject`. If the recorder wants to inject runtime config but is also used at static init time then it needs to inject a `RuntimeValue<ConfigObject>`, this value will only be set when the runtime methods are being invoked."
msgstr "具有相 `RUNTIME` 或 `BUILD_AND_RUNTIME_FIXED` 的配置对象可以通过构造函数注入到记录器中。只要创建一个构造函数，接收记录器需要的配置对象。如果记录器有多个构造函数，你可以用 `@Inject` 注释你希望Quarkus使用的构造函数。如果记录器想注入运行时配置，但也在静态启动时使用，那么它需要注入一个 `RuntimeValue<ConfigObject>` ，这个值只有在运行时方法被调用时才会被设置。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1462
#, fuzzy, no-wrap
msgid "RecorderContext"
msgstr "录音机上下文"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1468
#, fuzzy
msgid "`io.quarkus.deployment.recording.RecorderContext` provides some convenience methods to enhance bytecode recording, this includes the ability to register creation functions for classes without no-arg constructors, to register an object substitution (basically a transformer from a non-serializable object to a serializable one and vice versa), and to create a class proxy. This interface can be directly injected as a method parameter into any `@Record` method."
msgstr " `io.quarkus.deployment.recording.RecorderContext` 提供了一些方便的方法来加强字节码记录，这包括为没有无参数构造函数的类注册创建函数，注册一个对象替换（基本上是一个从不可序列化对象到可序列化对象的转化器，反之亦然），以及创建一个类代理。这个接口可以作为一个方法参数直接注入到任何 方法中。 `@Record` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1472
#, fuzzy
msgid "Calling `classProxy` with a given class name will create a `Class` that can be passed into recorder methods, and at runtime will be substituted with the class whose name was passed in to `classProxy`. This is basically a convenience to avoid the need to explicitly load classes in the recorders."
msgstr "用一个给定的类名调用 `classProxy` ，将创建一个 `Class` ，该类可以被传递到记录器方法中，并在运行时被替换成名字被传递到 `classProxy` 的类。这基本上是一个便利，以避免在记录器中明确加载类的需要。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1473
#, fuzzy, no-wrap
msgid "Printing step execution time"
msgstr "印刷步骤的执行时间"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1478
#, fuzzy
msgid "At times, it can be useful to know how the exact time each startup task (which is the result of each bytecode recording) takes when the application is run.  The simplest way to determine this information is to launch the Quarkus application with the `-Dquarkus.debug.print-startup-times=true` system property.  The output will look something like:"
msgstr "有时，了解应用程序运行时每个启动任务（也就是每个字节码记录的结果）的确切时间是很有用的。确定这一信息的最简单方法是用 `-Dquarkus.debug.print-startup-times=true` 系统属性启动Quarkus应用程序。输出结果会是这样的。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1491
#, no-wrap
msgid ""
"Build step LoggingResourceProcessor.setupLoggingRuntimeInit completed in: 42ms\n"
"Build step ConfigGenerationBuildStep.checkForBuildTimeConfigChange completed in: 4ms\n"
"Build step SyntheticBeansProcessor.initRuntime completed in: 0ms\n"
"Build step ConfigBuildStep.validateConfigProperties completed in: 1ms\n"
"Build step ResteasyStandaloneBuildStep.boot completed in: 95ms\n"
"Build step VertxHttpProcessor.initializeRouter completed in: 1ms\n"
"Build step VertxHttpProcessor.finalizeRouter completed in: 4ms\n"
"Build step LifecycleEventsBuildStep.startupEvent completed in: 1ms\n"
"Build step VertxHttpProcessor.openSocket completed in: 93ms\n"
"Build step ShutdownListenerBuildStep.setupShutdown completed in: 1ms\n"
msgstr ""

#. TODO: config integration
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1496
#, fuzzy, no-wrap
msgid "Contexts and Dependency Injection"
msgstr "上下文和依赖性注入"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1498
#, fuzzy, no-wrap
msgid "Extension Points"
msgstr "扩展点"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1503
#, fuzzy
msgid "As a CDI based runtime, Quarkus extensions often make CDI beans available as part of the extension behavior.  However, Quarkus DI solution does not support CDI Portable Extensions.  Instead, Quarkus extensions can make use of various xref:cdi-reference.adoc[Build Time Extension Points]."
msgstr "作为一个基于CDI的运行时，Quarkus扩展经常将CDI beans作为扩展行为的一部分来使用。然而，Quarkus DI解决方案并不支持CDI便携式扩展。相反，Quarkus扩展可以利用各种 link:cdi-reference.html[构建时间扩展点] 。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1504
#, fuzzy, no-wrap
msgid "Quarkus Dev UI"
msgstr "Quarkus Dev UI"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1507
#, fuzzy
msgid "You can make your extension support the xref:dev-ui.adoc[Quarkus Dev UI] for a greater developer experience."
msgstr "你可以让你的扩展支持 link:dev-ui.html[Quarkus Dev UI] ，以获得更多的开发者体验。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1508
#, fuzzy, no-wrap
msgid "Extension-defined endpoints"
msgstr "扩展定义的端点"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1512
#, fuzzy
msgid "Your extension can add additional, non-application endpoints to be served alongside endpoints for Health, Metrics, OpenAPI, Swagger UI, etc."
msgstr "你的扩展可以添加额外的、非应用的端点，与健康、指标、OpenAPI、Swagger UI等的端点一起提供服务。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1514
#, fuzzy
msgid "Use a `NonApplicationRootPathBuildItem` to define an endpoint:"
msgstr "使用 `NonApplicationRootPathBuildItem` 来定义一个端点。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1525
#, no-wrap
msgid ""
"@BuildStep\n"
"RouteBuildItem myExtensionRoute(NonApplicationRootPathBuildItem nonApplicationRootPathBuildItem) {\n"
"    return nonApplicationRootPathBuildItem.routeBuilder()\n"
"                .route(\"custom-endpoint\")\n"
"                .handler(new MyCustomHandler())\n"
"                .displayOnNotFoundPage()\n"
"                .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1530
#, fuzzy
msgid "Note that the path above does not start with a '/', indicating it is a relative path. The above endpoint will be served relative to the configured non-application endpoint root. The non-application endpoint root is `/q` by default, which means the resulting endpoint will be found at `/q/custom-endpoint`."
msgstr "注意，上面的路径不是以'/'开头的，表明它是一个相对路径。上述端点将相对于配置的非应用端点根提供服务。非应用端点根默认为 `/q` ，这意味着产生的端点将在 `/q/custom-endpoint` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1533
#, fuzzy
msgid "Absolute paths are handled differently. If the above called `route(\"/custom-endpoint\")`, the resulting endpoint will be found at `/custom-endpoint`."
msgstr "绝对路径的处理方式不同。如果上面调用 `route(\"/custom-endpoint\")` ，结果端点将被发现在 `/custom-endpoint` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1535
#, fuzzy
msgid "If an extension needs nested non-application endpoints:"
msgstr "如果一个扩展需要嵌套的非应用端点。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1546
#, no-wrap
msgid ""
"@BuildStep\n"
"RouteBuildItem myNestedExtensionRoute(NonApplicationRootPathBuildItem nonApplicationRootPathBuildItem) {\n"
"    return nonApplicationRootPathBuildItem.routeBuilder()\n"
"                .nestedRoute(\"custom-endpoint\", \"deep\")\n"
"                .handler(new MyCustomHandler())\n"
"                .displayOnNotFoundPage()\n"
"                .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1549
#, fuzzy
msgid "Given a default non-application endpoint root of `/q`, this will create an endpoint at `/q/custom-endpoint/deep`."
msgstr "给定一个默认的非应用端点根 `/q` ，这将创建一个端点在 `/q/custom-endpoint/deep` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1552
#, fuzzy
msgid "Absolute paths also have an impact on nested endpoints. If the above called `nestedRoute(\"custom-endpoint\", \"/deep\")`, the resulting endpoint will be found at `/deep`."
msgstr "绝对路径对嵌套的端点也有影响。如果上面调用 `nestedRoute(\"custom-endpoint\", \"/deep\")` ，结果端点将在 `/deep` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1555
#, fuzzy
msgid "Refer to the xref:all-config.adoc#quarkus-vertx-http_quarkus.http.non-application-root-path[Quarkus Vertx HTTP configuration reference] for details on how the non-application root path is configured."
msgstr "请参考 link:all-config.html#quarkus-vertx-http_quarkus.http.non-application-root-path[Quarkus Vertx HTTP配置参考] ，了解如何配置非应用根路径的细节。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1556
#, fuzzy, no-wrap
msgid "Extension Health Check"
msgstr "延期健康检查"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1559
#, fuzzy
msgid "Health checks are provided via the `quarkus-smallrye-health` extension. It provides both liveness and readiness checks capabilities."
msgstr "健康检查是通过 `quarkus-smallrye-health` 扩展提供的。它同时提供有效性和准备性检查功能。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1561
#, fuzzy
msgid "When writing an extension, it's beneficial to provide health checks for the extension, that can be automatically included without the developer needing to write their own."
msgstr "在编写扩展时，为扩展提供健康检查是有益的，它可以自动包含，而不需要开发人员自己编写。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1563
#, fuzzy
msgid "In order to provide a health check, you should do the following:"
msgstr "为了提供健康检查，你应该做到以下几点。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1566
#, fuzzy
msgid "Import the `quarkus-smallrye-health` extension as an **optional** dependency in your runtime module so it will not impact the size of the application if health check is not included."
msgstr "在你的运行模块中，将 `quarkus-smallrye-health` 扩展作为一个 *可选的* 依赖项导入，这样，如果不包括健康检查，它将不会影响应用程序的大小。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1568
#, fuzzy
msgid "Create your health check following the xref:smallrye-health.adoc[SmallRye Health] guide. We advise providing only readiness check for an extension (liveness check is designed to express the fact that an application is up and needs to be lightweight)."
msgstr "按照 link:smallrye-health.html[SmallRye健康] 指南创建你的健康检查。我们建议只为一个扩展提供就绪性检查（活跃性检查是为了表达一个应用程序已经启动并需要轻量级的事实）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1569
#, fuzzy
msgid "Import the `quarkus-smallrye-health-spi` library in your deployment module."
msgstr "在你的部署模块中导入 `quarkus-smallrye-health-spi` 库。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1570
#, fuzzy
msgid "Add a build step in your deployment module that produces a `HealthBuildItem`."
msgstr "在你的部署模块中添加一个构建步骤，产生一个 `HealthBuildItem` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1571
#, fuzzy
msgid "Add a way to disable the extension health check via a config item `quarkus.<extension>.health.enabled` that should be enabled by default."
msgstr "增加一个通过配置项禁用扩展健康检查的方法 `quarkus.<extension>.health.enabled` ，默认情况下应该是启用的。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1573
#, fuzzy
msgid "Following is an example from the Agroal extension that provides a `DataSourceHealthCheck` to validate the readiness of a datasource."
msgstr "以下是Agroal扩展的一个例子，它提供了一个 `DataSourceHealthCheck` ，以验证数据源的准备情况。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1581
#, no-wrap
msgid ""
"@BuildStep\n"
"HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) {\n"
"    return new HealthBuildItem(\"io.quarkus.agroal.runtime.health.DataSourceHealthCheck\",\n"
"            agroalBuildTimeConfig.healthEnabled);\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1583
#, fuzzy, no-wrap
msgid "Extension Metrics"
msgstr "扩展指标"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1588
#, fuzzy
msgid "The `quarkus-micrometer` extension and the `quarkus-smallrye-metrics` extension provide support for collecting metrics.  As a compatibility note, the `quarkus-micrometer` extension adapts the MP Metrics API to Micrometer library primitives, so the `quarkus-micrometer` extension can be enabled without breaking code that relies on the MP Metrics API.  Note that the metrics emitted by Micrometer are different, see the `quarkus-micrometer` extension documentation for more information."
msgstr " `quarkus-micrometer` 扩展和 `quarkus-smallrye-metrics` 扩展提供对收集度量的支持。作为兼容性说明， `quarkus-micrometer` 扩展将MP Metrics API改编为Micrometer库基元，因此 `quarkus-micrometer` 扩展可以被启用而不破坏依赖MP Metrics API的代码。请注意，Micrometer发出的度量是不同的，更多信息请看 `quarkus-micrometer` 扩展文档。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1590
#, fuzzy
msgid "The compatibility layer for MP Metrics APIs will move to a different extension in the future."
msgstr "MP Metrics APIs的兼容层将来会转移到一个不同的扩展。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1592
#, fuzzy
msgid "There are two broad patterns that extensions can use to interact with an optional metrics extension to add their own metrics:"
msgstr "有两种广泛的模式，扩展可以用来与可选的度量衡扩展互动，以添加他们自己的度量衡。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1594
#, fuzzy
msgid "Consumer pattern: An extension declares a `MetricsFactoryConsumerBuildItem` and uses that to provide a bytecode recorder to the metrics extension. When the metrics extension has initialized, it will iterate over registered consumers to initialize them with a `MetricsFactory`. This factory can be used to declare API-agnostic metrics, which can be a good fit for extensions that provide an instrumentable object for gathering statistics (e.g. Hibernate's `Statistics` class)."
msgstr "消费者模式。一个扩展声明了一个 `MetricsFactoryConsumerBuildItem` ，并使用它来为度量衡扩展提供一个字节码记录器。当度量衡扩展初始化后，它将遍历已注册的消费者，用一个 `MetricsFactory` 来初始化它们。这个工厂可以用来声明与API无关的度量衡，这可以很好地适用于为收集统计数据提供一个可测量对象的扩展（例如Hibernate?s `Statistics` 类）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1596
#, fuzzy
msgid "Binder pattern: An extension can opt to use completely different gathering implementations depending on the metrics system. An `Optional<MetricsCapabilityBuildItem> metricsCapability` build step parameter can be used to declare or otherwise initialize API-specific metrics based on the active metrics extension (e.g. \"smallrye-metrics\" or \"micrometer\"). This pattern can be combined with the consumer pattern by using `MetricsFactory::metricsSystemSupported()` to test the active metrics extension within the recorder."
msgstr "捆绑模式。一个扩展可以根据度量系统选择使用完全不同的收集实现。一个 `Optional<MetricsCapabilityBuildItem> metricsCapability` build step参数可以用来声明或以其他方式初始化基于活动度量衡扩展的API特定度量衡（例如 \"smallrye-metrics \"或 \"micrometer\"）。这种模式可以通过使用 `MetricsFactory::metricsSystemSupported()` ，与消费者模式相结合，在记录器中测试活动度量衡扩展。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1598
#, fuzzy
msgid "Remember that support for metrics is optional. Extensions can use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter in their build step to test for the presence of an enabled metrics extension. Consider using additional configuration to control behavior of metrics. Datasource metrics can be expensive, for example, so additional configuration flags are used enable metrics collection on individual datasources."
msgstr "记住，对度量的支持是可选的。扩展可以在其构建步骤中使用 `Optional<MetricsCapabilityBuildItem> metricsCapability` 参数来测试是否存在已启用的度量衡扩展。考虑使用额外的配置来控制度量的行为。例如，数据源度量可能是昂贵的，所以使用额外的配置标志来实现对单个数据源的度量收集。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1600
#, fuzzy
msgid "When adding metrics for your extension, you may find yourself in one of the following situations:"
msgstr "当为你的扩展添加指标时，你可能发现自己处于以下情况之一。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1602
#, fuzzy
msgid "An underlying library used by the extension is using a specific Metrics API directly (either MP Metrics, Micrometer, or some other)."
msgstr "扩展使用的底层库直接使用特定的Metrics API（MP Metrics、Micrometer或其他）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1603
#, fuzzy
msgid "An underlying library uses its own mechanism for collecting metrics and makes them available at runtime using its own API, e.g. Hibernate's `Statistics` class, or Vert.x `MetricsOptions`."
msgstr "一个底层库使用它自己的机制来收集指标，并在运行时使用它自己的API来提供这些指标，例如Hibernate的 `Statistics` 类，或Vert.x `MetricsOptions` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1604
#, fuzzy
msgid "An underlying library does not provide metrics (or there is no library at all) and you want to add instrumentation."
msgstr "一个底层库不提供指标（或者根本就没有库），而你想添加仪器。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1605
#, fuzzy, no-wrap
msgid "Case 1: The library uses a metrics library directly"
msgstr "案例1：图书馆直接使用一个度量衡库"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1608
#, fuzzy
msgid "If the library directly uses a metrics API, there are two options:"
msgstr "如果该库直接使用度量衡API，有两个选择。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1610
#, fuzzy
msgid "Use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter to test which metrics API is supported (e.g. \"smallrye-metrics\" or \"micrometer\") in your build step, and use that to selectively declare or initialize API-specific beans or build items."
msgstr "在你的构建步骤中，使用 `Optional<MetricsCapabilityBuildItem> metricsCapability` 参数来测试哪个度量衡API被支持（例如 \"smallrye-metrics \"或 \"micrometer\"），并使用它来选择性地声明或初始化API特定的bean或构建项目。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1612
#, fuzzy
msgid "Create a separate build step that consumes a `MetricsFactory`, and use the `MetricsFactory::metricsSystemSupported()` method within the bytecode recorder to initialize required resources if the desired metrics API is supported (e.g. \"smallrye-metrics\" or \"micrometer\")."
msgstr "创建一个单独的构建步骤，消耗一个 `MetricsFactory` ，如果支持所需的度量API（如 \"smallrye-metrics \"或 \"micrometer\"），则使用字节码记录器中的 `MetricsFactory::metricsSystemSupported()` 方法来初始化所需资源。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1614
#, fuzzy
msgid "Extensions may need to provide a fallback if there is no active metrics extension or the extension doesn't support the API required by the library."
msgstr "如果没有活动的度量衡扩展，或者扩展不支持库所要求的API，扩展可能需要提供一个回退。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1615
#, fuzzy, no-wrap
msgid "Case 2: The library provides its own metric API"
msgstr "案例2：库提供自己的度量衡API"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1618
#, fuzzy
msgid "There are two examples of a library providing its own metrics API:"
msgstr "有两个例子是一个库提供自己的度量衡API。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1620
#, fuzzy
msgid "The extension defines an instrumentable object as Agroal does with `io.agroal.api.AgroalDataSourceMetrics`, or"
msgstr "该扩展定义了一个工具化的对象，就像Agroal用 `io.agroal.api.AgroalDataSourceMetrics` ，或"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1621
#, fuzzy
msgid "The extension provides its own abstraction of metrics, as Jaeger does with `io.jaegertracing.spi.MetricsFactory`."
msgstr "该扩展提供了自己的度量衡抽象，正如Jaeger对 `io.jaegertracing.spi.MetricsFactory` 。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1622
#, fuzzy, no-wrap
msgid "Observing instrumentable objects"
msgstr "观察可测量的物体"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1625
#, fuzzy
msgid "Let's take the instrumentable object (`io.agroal.api.AgroalDataSourceMetrics`) case first. In this case, you can do the following:"
msgstr "让我们先来看看可被记录的对象( `io.agroal.api.AgroalDataSourceMetrics` )的情况。在这种情况下，你可以做以下工作。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1627
#, fuzzy
msgid "Define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` consumer. For example, the following creates a `MetricsFactoryConsumerBuildItem` if and only if metrics are enabled both for Agroal generally, and for a datasource specifically:"
msgstr "定义一个 `BuildStep` ，产生一个 `MetricsFactoryConsumerBuildItem` ，使用一个 `RUNTIME_INIT` 或 `STATIC_INIT` 记录器来定义一个 `MetricsFactory` 消费者。例如，下面创建了一个 `MetricsFactoryConsumerBuildItem` ，当且仅当Agroal总体上启用了度量标准，以及具体的数据源的度量标准。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1636
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void registerMetrics(AgroalMetricsRecorder recorder,\n"
"        DataSourcesBuildTimeConfig dataSourcesBuildTimeConfig,\n"
"        BuildProducer<MetricsFactoryConsumerBuildItem> datasourceMetrics,\n"
"        List<AggregatedDataSourceBuildTimeConfigBuildItem> aggregatedDataSourceBuildTimeConfigs) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1648
#, no-wrap
msgid ""
"    for (AggregatedDataSourceBuildTimeConfigBuildItem aggregatedDataSourceBuildTimeConfig : aggregatedDataSourceBuildTimeConfigs) {\n"
"        // Create a MetricsFactory consumer to register metrics for a data source\n"
"        // IFF metrics are enabled globally and for the data source\n"
"        // (they are enabled for each data source by default if they are also enabled globally)\n"
"        if (dataSourcesBuildTimeConfig.metricsEnabled &&\n"
"                aggregatedDataSourceBuildTimeConfig.getJdbcConfig().enableMetrics.orElse(true)) {\n"
"            datasourceMetrics.produce(new MetricsFactoryConsumerBuildItem(\n"
"                    recorder.registerDataSourceMetrics(aggregatedDataSourceBuildTimeConfig.getName())));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1651
#, fuzzy
msgid "The associated recorder should use the provided `MetricsFactory` to register metrics. For Agroal, this means using the `MetricFactory` API to observe `io.agroal.api.AgroalDataSourceMetrics` methods. For example:"
msgstr "相关的记录器应该使用所提供的 `MetricsFactory` 来注册度量。对于Agroal，这意味着使用 `MetricFactory` API来观察 `io.agroal.api.AgroalDataSourceMetrics` 方法。比如说。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1661
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerDataSourceMetrics(String dataSourceName) {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            String tagValue = DataSourceUtil.isDefault(dataSourceName) ? \"default\" : dataSourceName;\n"
"            AgroalDataSourceMetrics metrics = getDataSource(dataSourceName).getMetrics();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1669
#, no-wrap
msgid ""
"            // When using MP Metrics, the builder uses the VENDOR registry by default.\n"
"            metricsFactory.builder(\"agroal.active.count\")\n"
"                    .description(\n"
"                            \"Number of active connections. These connections are in use and not available to be acquired.\")\n"
"                    .tag(\"datasource\", tagValue)\n"
"                    .buildGauge(metrics::activeCount);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1672
#, fuzzy
msgid "The `MetricsFactory` provides a fluid builder for registration of metrics, with the final step constructing gauges or counters based on a `Supplier` or `ToDoubleFunction`. Timers can either wrap `Callable`, `Runnable`, or `Supplier` implementations, or can use a `TimeRecorder` to accumulate chunks of time. The underlying metrics extension will create appropriate artifacts to observe or measure the defined functions."
msgstr " `MetricsFactory` 提供了一个用于注册度量衡的流体构建器，最后一步是基于 `Supplier` 或 `ToDoubleFunction` 构建仪表或计数器。计时器可以包裹 `Callable` 、 `Runnable` 或 `Supplier` 的实现，或者可以使用 `TimeRecorder` 来积累时间块。底层的度量衡扩展将创建适当的工件来观察或测量定义的功能。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1673
#, fuzzy, no-wrap
msgid "Using a Metrics API-specific implementation"
msgstr "使用特定的度量衡API实现"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1676
#, fuzzy
msgid "Using metrics-API specific implementations may be preferred in some cases. Jaeger, for example, defines its own metrics interface, `io.jaegertracing.spi.MetricsFactory`, that it uses to define counters and gauges. A direct mapping from that interface to the metrics system will be the most efficient. In this case, it is important to isolate these specialized implementations and to avoid eager classloading to ensure the metrics API remains an optional, compile-time dependency."
msgstr "在某些情况下，使用度量衡-API的具体实现可能是首选。例如，Jaeger定义了它自己的度量衡接口， `io.jaegertracing.spi.MetricsFactory` ，它用来定义计数器和仪表。从该接口直接映射到度量系统将是最有效的。在这种情况下，重要的是隔离这些专门的实现，并避免急切的类加载，以确保度量API仍然是一个可选的、编译时的依赖。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1678
#, fuzzy
msgid "`Optional<MetricsCapabilityBuildItem> metricsCapability` can be used in the build step to selectively control initialization of beans or the production of other build items. The Jaeger extension, for example, can use the following to control initialization of specialized Metrics API adapters:"
msgstr " `Optional<MetricsCapabilityBuildItem> metricsCapability` 可以在构建步骤中使用，以选择性地控制豆的初始化或其他构建项目的产生。例如，Jaeger扩展可以使用以下方法来控制专门的Metrics API适配器的初始化。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1686
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void setupTracer(JaegerDeploymentRecorder jdr, JaegerBuildTimeConfig buildTimeConfig, JaegerConfig jaeger,\n"
"        ApplicationConfig appConfig, Optional<MetricsCapabilityBuildItem> metricsCapability) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1689
#, no-wrap
msgid ""
"    // Indicates that this extension would like the SSL support to be enabled\n"
"    extensionSslNativeSupport.produce(new ExtensionSslNativeSupportBuildItem(Feature.JAEGER.getName()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1703
#, no-wrap
msgid ""
"    if (buildTimeConfig.enabled) {\n"
"        // To avoid dependency creep, use two separate recorder methods for the two metrics systems\n"
"        if (buildTimeConfig.metricsEnabled && metricsCapability.isPresent()) {\n"
"            if (metricsCapability.get().metricsSupported(MetricsFactory.MICROMETER)) {\n"
"                jdr.registerTracerWithMicrometerMetrics(jaeger, appConfig);\n"
"            } else {\n"
"                jdr.registerTracerWithMpMetrics(jaeger, appConfig);\n"
"            }\n"
"        } else {\n"
"            jdr.registerTracerWithoutMetrics(jaeger, appConfig);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1706
#, fuzzy
msgid "A recorder consuming a `MetricsFactory` can use `MetricsFactory::metricsSystemSupported()` can be used to control initialization of metrics objects during bytecode recording in a similar way."
msgstr "消费 `MetricsFactory` 的记录器可以使用 `MetricsFactory::metricsSystemSupported()` ，可以用类似的方式在字节码记录期间控制度量对象的初始化。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1707
#, fuzzy, no-wrap
msgid "Case 3: It is necessary to collect metrics within the extension code"
msgstr "案例3：有必要在扩展代码内收集指标"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1710
#, fuzzy
msgid "To define your own metrics from scratch, you have two basic options: Use the generic `MetricFactory` builders, or follow the binder pattern, and create instrumentation specific to the enabled metrics extension."
msgstr "要从头开始定义你自己的度量，你有两个基本选择。使用通用的 `MetricFactory` 构建器，或者遵循捆绑模式，并为启用的度量衡扩展创建特定的仪器。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1712
#, fuzzy
msgid "To use the extension-agnostic `MetricFactory` API, your processor can define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` consumer."
msgstr "要使用扩展无关的 `MetricFactory` API，你的处理器可以定义一个 `BuildStep` ，产生一个 `MetricsFactoryConsumerBuildItem` ，使用 `RUNTIME_INIT` 或 `STATIC_INIT` 记录器来定义一个 `MetricsFactory` 消费者。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1720
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"MetricsFactoryConsumerBuildItem registerMetrics(MyExtensionRecorder recorder) {\n"
"    return new MetricsFactoryConsumerBuildItem(recorder.registerMetrics());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1723
#, fuzzy
msgid "The associated recorder should use the provided `MetricsFactory` to register metrics, for example"
msgstr "相关的记录器应该使用所提供的 `MetricsFactory` ，以登记指标，例如"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1727
#, no-wrap
msgid "final LongAdder extensionCounter = new LongAdder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1736
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerMetrics() {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            metricsFactory.builder(\"my.extension.counter\")\n"
"                    .buildGauge(extensionCounter::longValue);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1739
#, fuzzy
msgid "Remember that metrics extensions are optional. Keep metrics-related initialization isolated from other setup for your extension, and structure your code to avoid eager imports of metrics APIs. Gathering metrics can also be expensive. Consider using additional extension-specific configuration to control behavior of metrics if the presence/absence of metrics support isn't sufficient."
msgstr "记住，度量衡扩展是可选的。将度量相关的初始化与你的扩展的其他设置隔离开来，并构建你的代码以避免急于导入度量API。收集度量标准也可能是昂贵的。如果有/没有度量衡支持还不够，可以考虑使用额外的扩展特定配置来控制度量衡的行为。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1740
#, fuzzy, no-wrap
msgid "Customizing JSON handling from an extension"
msgstr "从一个扩展中定制JSON处理"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1743
#, fuzzy
msgid "Extensions often need to register serializers and/or deserializers for types the extension provides."
msgstr "扩展经常需要为扩展提供的类型注册序列化器和/或反序列化器。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1746
#, fuzzy
msgid "For this, both Jackson and JSON-B extensions provide a way to register serializer/deserializer from within an extension deployment module."
msgstr "为此，Jackson和JSON-B扩展都提供了一种从扩展部署模块中注册序列化器/反序列化器的方法。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1748
#, fuzzy
msgid "Keep in mind that not everybody will need JSON, so you need to make it optional."
msgstr "请记住，不是每个人都需要JSON，所以你需要让它成为可选项。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1751
#, fuzzy
msgid "If an extension intends to provide JSON related customization, it is strongly advised to provide customization for both Jackson and JSON-B."
msgstr "如果一个扩展打算提供与JSON相关的定制，我们强烈建议它为Jackson和JSON-B提供定制。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1752
#, fuzzy, no-wrap
msgid "Customizing Jackson"
msgstr "定制杰克逊"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1755
#, fuzzy
msgid "First, add an *optional* dependency to `quarkus-jackson` on your extension's runtime module."
msgstr "首先，在你的扩展的运行时模块上添加一个 *可选的* 依赖关系到 `quarkus-jackson` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1763
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1766
#, fuzzy
msgid "Then create a serializer or a deserializer (or both) for Jackson, an example of which can be seen in the `mongodb-panache` extension."
msgstr "然后为Jackson创建一个序列化器或反序列化器（或两者），其中的一个例子可以在 `mongodb-panache` 扩展中看到。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1781
#, no-wrap
msgid ""
"public class ObjectIdSerializer extends StdSerializer<ObjectId> {\n"
"    public ObjectIdSerializer() {\n"
"        super(ObjectId.class);\n"
"    }\n"
"    @Override\n"
"    public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)\n"
"            throws IOException {\n"
"        if (objectId != null) {\n"
"            jsonGenerator.writeString(objectId.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1784
#, fuzzy
msgid "Add a dependency to `quarkus-jackson-spi` on your extension's deployment module."
msgstr "在你的扩展的部署模块上添加一个依赖性到 `quarkus-jackson-spi` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1791
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1795
#, fuzzy
msgid "Add a build step to your processor to register a Jackson module via the `JacksonModuleBuildItem`.  You need to name your module in a unique way across all Jackson modules."
msgstr "在你的处理器中添加一个构建步骤，通过 `JacksonModuleBuildItem` 注册一个Jackson模块。 你需要在所有Jackson模块中以独特的方式命名你的模块。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1806
#, no-wrap
msgid ""
"@BuildStep\n"
"JacksonModuleBuildItem registerJacksonSerDeser() {\n"
"    return new JacksonModuleBuildItem.Builder(\"ObjectIdModule\")\n"
"                    .add(io.quarkus.mongodb.panache.jackson.ObjectIdSerializer.class.getName(),\n"
"                            io.quarkus.mongodb.panache.jackson.ObjectIdDeserializer.class.getName(),\n"
"                            ObjectId.class.getName())\n"
"                    .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1809
#, fuzzy
msgid "The Jackson extension will then use the produced build item to register a module within Jackson automatically."
msgstr "然后，Jackson扩展将使用产生的构建项，在Jackson中自动注册一个模块。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1813
#, fuzzy
msgid "If you need more customization capabilities than registering a module, you can produce a CDI bean that implements `io.quarkus.jackson.ObjectMapperCustomizer` via an `AdditionalBeanBuildItem`.  More info about customizing Jackson can be found on the JSON guide xref:rest-json.adoc#configuring-json-support[Configuring JSON support]"
msgstr " `io.quarkus.jackson.ObjectMapperCustomizer` 如果你需要比注册模块更多的定制功能，你可以制作一个CDI Bean，通过 `AdditionalBeanBuildItem` 。关于定制Jackson的更多信息可以在JSON指南中找到 link:rest-json.html#configuring-json-support[配置JSON支持]"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1814
#, fuzzy, no-wrap
msgid "Customizing JSON-B"
msgstr "定制JSON-B"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1816
#, fuzzy
msgid "First, add an *optional* dependency to `quarkus-jsonb` on your extension's runtime module."
msgstr "首先，在你的扩展的运行时模块上添加一个 *可选的* 依赖关系到 `quarkus-jsonb` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1824
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1827
#, fuzzy
msgid "Then create a serializer and/or a deserializer for JSON-B, an example of which can be seen in the `mongodb-panache` extension."
msgstr "然后为JSON-B创建一个序列化器和/或反序列化器，其中的一个例子可以在 `mongodb-panache` 扩展中看到。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1838
#, no-wrap
msgid ""
"public class ObjectIdSerializer implements JsonbSerializer<ObjectId> {\n"
"    @Override\n"
"    public void serialize(ObjectId obj, JsonGenerator generator, SerializationContext ctx) {\n"
"        if (obj != null) {\n"
"            generator.write(obj.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1841
#, fuzzy
msgid "Add a dependency to `quarkus-jsonb-spi` on your extension's deployment module."
msgstr "在你的扩展的部署模块上添加一个依赖性到 `quarkus-jsonb-spi` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1848
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1851
#, fuzzy
msgid "Add a build step to your processor to register the serializer via the `JsonbSerializerBuildItem`."
msgstr "在你的处理器中添加一个构建步骤，通过 `JsonbSerializerBuildItem` .NET来注册序列化器。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1858
#, no-wrap
msgid ""
"@BuildStep\n"
"JsonbSerializerBuildItem registerJsonbSerializer() {\n"
"    return new JsonbSerializerBuildItem(io.quarkus.mongodb.panache.jsonb.ObjectIdSerializer.class.getName()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1861
#, fuzzy
msgid "The JSON-B extension will then use the produced build item to register your serializer/deserializer automatically."
msgstr "然后JSON-B扩展将使用产生的构建项来自动注册你的序列化器/反序列化器。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1865
#, fuzzy
msgid "If you need more customization capabilities than registering a serializer or a deserializer, you can produce a CDI bean that implements `io.quarkus.jsonb.JsonbConfigCustomizer` via an `AdditionalBeanBuildItem`.  More info about customizing JSON-B can be found on the JSON guide xref:rest-json.adoc#configuring-json-support[Configuring JSON support]"
msgstr " `io.quarkus.jsonb.JsonbConfigCustomizer` 如果你需要比注册一个序列化器或反序列化器更多的定制功能，你可以制作一个CDI Bean，通过一个 `AdditionalBeanBuildItem` 。关于定制JSON-B的更多信息可以在JSON指南中找到 link:rest-json.html#configuring-json-support[配置JSON支持]"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1866
#, fuzzy, no-wrap
msgid "Integrating with Development Mode"
msgstr "与开发模式的整合"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1869
#, fuzzy
msgid "There are various APIS that you can use to integrate with development mode, and to get information about the current state."
msgstr "有各种APIS，你可以用来与开发模式整合，并获得关于当前状态的信息。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1870
#, fuzzy, no-wrap
msgid "Handling restarts"
msgstr "处理重新启动"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1874
#, fuzzy
msgid "When Quarkus is starting the `io.quarkus.deployment.builditem.LiveReloadBuildItem` is guaranteed to be present that gives information about this start, in particular:"
msgstr "当Quarkus启动时，保证有 `io.quarkus.deployment.builditem.LiveReloadBuildItem` ，它特别给出了关于这次启动的信息。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1876
#, fuzzy
msgid "Is this a clean start or a live reload"
msgstr "这是一个干净的开始还是一个活的重装"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1877
#, fuzzy
msgid "If this is a live reload which changed files / classes triggered the reload"
msgstr "如果这是一个实时重载，其中改变的文件/类触发了重载。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1880
#, fuzzy
msgid "It also provides a global context map you can use to store information between restarts, without needing to resort to static fields."
msgstr "它还提供了一个全局上下文图，你可以用来在重新启动之间存储信息，而不需要借助于静态字段。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1881
#, fuzzy, no-wrap
msgid "Triggering Live Reload"
msgstr "触发实时重新加载"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1886
#, fuzzy
msgid "Live reload is generally triggered by a HTTP request, however not all applications are HTTP applications and some extensions may want to trigger live reload based on other events. To do this you need to implement `io.quarkus.dev.spi.HotReplacementSetup` in your runtime module, and add a `META-INF/services/io.quarkus.dev.spi.HotReplacementSetup` that lists your implementation."
msgstr "实时重载一般是由HTTP请求触发的，然而并不是所有的应用程序都是HTTP应用程序，有些扩展可能想根据其他事件来触发实时重载。要做到这一点，你需要在你的运行时模块中实现 `io.quarkus.dev.spi.HotReplacementSetup` ，并添加一个 `META-INF/services/io.quarkus.dev.spi.HotReplacementSetup` ，列出你的实现。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1889
#, fuzzy
msgid "On startup the `setupHotDeployment` method will be called, and you can use the provided `io.quarkus.dev.spi.HotReplacementContext` to initiate a scan for changed files."
msgstr "在启动时， `setupHotDeployment` 方法将被调用，你可以使用提供的 `io.quarkus.dev.spi.HotReplacementContext` 来启动对更改的文件的扫描。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1890
#, fuzzy, no-wrap
msgid "Testing Extensions"
msgstr "测试扩展"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1897
#, fuzzy
msgid "Testing of Quarkus extensions should be done with the `io.quarkus.test.QuarkusUnitTest` JUnit 5 extension.  This extension allows for Arquillian-style tests that test specific functionalities.  It is not intended for testing user applications, as this should be done via `io.quarkus.test.junit.QuarkusTest`.  The main difference is that `QuarkusTest` simply boots the application once at the start of the run, while `QuarkusUnitTest` deploys a custom Quarkus application for each test class."
msgstr "Quarkus扩展的测试应该用 `io.quarkus.test.QuarkusUnitTest` JUnit 5扩展来完成。这个扩展允许进行Arquillian风格的测试，测试特定的功能。它不打算用于测试用户应用程序，因为这应该通过 `io.quarkus.test.junit.QuarkusTest` 来完成。主要区别在于， `QuarkusTest` 只是在运行开始时启动一次应用程序，而 `QuarkusUnitTest` 为每个测试类部署一个自定义的Quarkus应用程序。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1900
#, fuzzy
msgid "These tests should be placed in the deployment module, if additional Quarkus modules are required for testing their deployment modules should also be added as test scoped dependencies."
msgstr "这些测试应该放在部署模块中，如果测试需要额外的Quarkus模块，它们的部署模块也应该作为测试范围内的依赖项加入。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1902
#, fuzzy
msgid "Note that `QuarkusUnitTest` is in the `quarkus-junit5-internal` module."
msgstr "请注意， `QuarkusUnitTest` 是在 `quarkus-junit5-internal` 模块中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1904
#, fuzzy
msgid "An example test class may look like:"
msgstr "一个测试类的例子可能看起来像。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1908
#, no-wrap
msgid "package io.quarkus.health.test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1910
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1913
#, no-wrap
msgid ""
"import java.util.ArrayList;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1916
#, no-wrap
msgid ""
"import javax.enterprise.inject.Instance;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1926
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.Liveness;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.asset.EmptyAsset;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1928
#, no-wrap
msgid "import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1930
#, no-wrap
msgid "public class FailingUnitTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1938
#, no-wrap
msgid ""
"    @RegisterExtension                                                                  // <1>\n"
"    static final QuarkusUnitTest config = new QuarkusUnitTest()\n"
"            .setArchiveProducer(() ->\n"
"                    ShrinkWrap.create(JavaArchive.class)                                // <2>\n"
"                            .addClasses(FailingHealthCheck.class)\n"
"                            .addAsManifestResource(EmptyAsset.INSTANCE, \"beans.xml\")\n"
"            );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1942
#, no-wrap
msgid ""
"    @Inject                                                                             // <3>\n"
"    @Liveness\n"
"    Instance<HealthCheck> checks;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1947
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthServlet() {\n"
"        RestAssured.when().get(\"/q/health\").then().statusCode(503);                       // <4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1958
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthBeans() {\n"
"        List<HealthCheck> check = new ArrayList<>();                                    // <5>\n"
"        for (HealthCheck i : checks) {\n"
"            check.add(i);\n"
"        }\n"
"        assertEquals(1, check.size());\n"
"        assertEquals(HealthCheckResponse.State.DOWN, check.get(0).call().getState());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1961
#, fuzzy
msgid "The `QuarkusUnitTest` extension must be used with a static field. If used with a non-static field, the test application is not started."
msgstr " `QuarkusUnitTest` 扩展必须与一个静态字段一起使用。如果与非静态字段一起使用，测试应用程序就不会启动。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1962
#, fuzzy
msgid "This producer is used to build the application to be tested. It uses Shrinkwrap to create a JavaArchive to test"
msgstr "这个生产者被用来建立要测试的应用程序。它使用Shrinkwrap来创建一个JavaArchive来测试"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1963
#, fuzzy
msgid "It is possible to inject beans from our test deployment directly into the test case"
msgstr "可以将我们的测试部署中的Bean直接注入到测试案例中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1964
#, fuzzy
msgid "This method directly invokes the health check Servlet and verifies the response"
msgstr "这个方法直接调用健康检查Servlet，并验证响应。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1965
#, fuzzy
msgid "This method uses the injected health check bean to verify it is returning the expected result"
msgstr "这个方法使用注入的健康检查豆来验证它是否返回预期的结果"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1967
#, fuzzy
msgid "If you want to test that an extension properly fails at build time, use the `setExpectedException` method:"
msgstr "如果你想测试一个扩展在构建时是否正确失败，请使用 `setExpectedException` 方法。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1972
#, no-wrap
msgid "package io.quarkus.hibernate.orm;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1980
#, no-wrap
msgid ""
"import io.quarkus.runtime.configuration.ConfigurationException;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1982
#, no-wrap
msgid "public class PersistenceAndQuarkusConfigTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1989
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    static QuarkusUnitTest runner = new QuarkusUnitTest()\n"
"            .setExpectedException(ConfigurationException.class)                     <1>\n"
"            .withApplicationRoot((jar) -> jar\n"
"                    .addAsManifestResource(\"META-INF/some-persistence.xml\", \"persistence.xml\")\n"
"                    .addAsResource(\"application.properties\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1997
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPersistenceAndConfigTest() {\n"
"        // should not be called, deployment exception should happen first:\n"
"        // it's illegal to have Hibernate configuration properties in both the\n"
"        // application.properties and in the persistence.xml\n"
"        Assertions.fail();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2002
#, fuzzy
msgid "This tells JUnit that the Quarkus deployment should fail with a specific exception"
msgstr "这告诉JUnit，Quarkus的部署应该以一个特定的异常失败。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2004
#, fuzzy, no-wrap
msgid "Testing hot reload"
msgstr "测试热重装"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2008
#, fuzzy
msgid "It is also possible to write tests that verify an extension works correctly in development mode and can correctly handle updates."
msgstr "也可以编写测试来验证一个扩展在开发模式下正确工作，并能正确处理更新。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2011
#, fuzzy
msgid "For most extensions this will just work 'out of the box', however it is still a good idea to have a smoke test to verify that this functionality is working as expected. To test this we use `QuarkusDevModeTest`:"
msgstr "对于大多数扩展来说，这只是 \"开箱即用\"，然而，有一个烟雾测试的好主意，以验证该功能是否按预期工作。为了测试这一点，我们使用 `QuarkusDevModeTest` 。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2016
#, no-wrap
msgid "public class ServletChangeTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2027
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    final static QuarkusDevModeTest test = new QuarkusDevModeTest()\n"
"            .setArchiveProducer(new Supplier<>() {\n"
"                @Override\n"
"                public JavaArchive get() {\n"
"                    return ShrinkWrap.create(JavaArchive.class)   <1>\n"
"                            .addClass(DevServlet.class)\n"
"                            .addAsManifestResource(new StringAsset(\"Hello Resource\"), \"resources/file.txt\");\n"
"                }\n"
"            });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2033
#, no-wrap
msgid ""
"    @Test\n"
"    public void testServletChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello World\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2035
#, no-wrap
msgid "        test.modifySourceFile(\"DevServlet.java\", new Function<String, String>() {  <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2041
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return s.replace(\"Hello World\", \"Hello Quarkus\");\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2046
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Quarkus\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2051
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddServlet() throws InterruptedException {\n"
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2053
#, no-wrap
msgid "        test.addSourceFile(NewServlet.class);                                       <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2058
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new Servlet\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2064
#, no-wrap
msgid ""
"    @Test\n"
"    public void testResourceChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Resource\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2066
#, no-wrap
msgid "        test.modifyResourceFile(\"META-INF/resources/file.txt\", new Function<String, String>() { <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2072
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return \"A new resource\";\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2077
#, no-wrap
msgid ""
"        RestAssured.when().get(\"file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new resource\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2080
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddResource() throws InterruptedException {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2083
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2085
#, no-wrap
msgid "        test.addResourceFile(\"META-INF/resources/new.txt\", \"New File\");  <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2089
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"New File\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2092
#, no-wrap
msgid ""
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2096
#, fuzzy
msgid "This starts the deployment, your test can modify it as part of the test suite. Quarkus will be restarted between each test method so every method starts with a clean deployment."
msgstr "这就开始部署，你的测试可以修改它作为测试套件的一部分。Quarkus将在每个测试方法之间被重新启动，所以每个方法都以一个干净的部署开始。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2099
#, fuzzy
msgid "This method allows you to modify the source of a class file. The old source is passed into the function, and the updated source is returned."
msgstr "这个方法允许你修改一个类文件的源代码。旧的源文件被传入该函数，而更新后的源文件被返回。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2102
#, fuzzy
msgid "This method adds a new class file to the deployment. The source that is used will be the original source that is part of the current project."
msgstr "这个方法在部署中添加一个新的类文件。所使用的源将是属于当前项目的原始源。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2104
#, fuzzy
msgid "This method modifies a static resource"
msgstr "该方法修改了一个静态资源"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2106
#, fuzzy
msgid "This method adds a new static resource"
msgstr "这个方法添加了一个新的静态资源"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2107
#, fuzzy, no-wrap
msgid "Native Executable Support"
msgstr "本地可执行文件支持"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2112
#, fuzzy
msgid "There Quarkus provides a lot of build items that control aspects of the native executable build. This allows for extensions to programmatically perform tasks such as registering classes for reflection or adding static resources to the native executable. Some of these build items are listed below:"
msgstr "Quarkus提供了很多控制本地可执行文件构建方面的构建项。这允许扩展程序以编程方式执行任务，例如为反射注册类或向本地可执行文件添加静态资源。下面列出了其中的一些构建项。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2113
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"
msgstr " `io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2115
#, fuzzy
msgid "Includes static resources into the native executable."
msgstr "将静态资源纳入本地可执行文件。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2116
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`"
msgstr " `io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2118
#, fuzzy
msgid "Includes directory's static resources into the native executable."
msgstr "将目录的静态资源纳入本地可执行文件。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2119
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`"
msgstr " `io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2121
#, fuzzy
msgid "A class that will be reinitialized at runtime by Substrate. This will result in the static initializer running twice."
msgstr "一个将在运行时被Substrate重新初始化的类。这将导致静态初始化器运行两次。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2122
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem`"
msgstr " `io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2124
#, fuzzy
msgid "A system property that will be set at native executable build time."
msgstr "一个系统属性，将在本地可执行文件构建时被设置。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2125
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem`"
msgstr " `io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2127
#, fuzzy
msgid "Includes a resource bundle in the native executable."
msgstr "在本地可执行文件中包括一个资源包。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2128
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"
msgstr " `io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2130
#, fuzzy
msgid "Registers a class for reflection in Substrate. Constructors are always registered, while methods and fields are optional."
msgstr "在 Substrate 中注册一个用于反射的类。构造函数总是被注册的，而方法和字段是可选的。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2131
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem`"
msgstr " `io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2133
#, fuzzy
msgid "A class that will be initialized at runtime rather than build time. This will cause the build to fail if the class is initialized as part of the native executable build process, so care must be taken."
msgstr "一个将在运行时而非构建时被初始化的类。如果该类作为本地可执行构建过程的一部分被初始化，这将导致构建失败，所以必须小心。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2134
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"
msgstr " `io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2136
#, fuzzy
msgid "A convenience feature that allows you to control most of the above features from a single build item."
msgstr "一个方便的功能，允许你从一个单一的构建项目中控制上述大部分功能。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2137
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"
msgstr " `io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2139
#, fuzzy
msgid "Indicates that all charsets should be enabled in native image."
msgstr "表示在本地图像中应启用所有字符集。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2140
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"
msgstr " `io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2143
#, fuzzy
msgid "A convenient way to tell Quarkus that the extension requires SSL and it should be enabled during native image build.  When using this feature, remember to add your extension to the list of extensions that offer SSL support automatically on the https://github.com/quarkusio/quarkus/blob/main/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide]."
msgstr "一个方便的方法是告诉Quarkus扩展需要SSL，并且在本地镜像构建过程中应该启用它。使用这个功能时，记得把你的扩展添加到 link:https://github.com/quarkusio/quarkus/blob/main/docs/src/main/asciidoc/native-and-ssl.adoc[本地和ssl指南] 上自动提供SSL支持的扩展列表中。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2144
#, fuzzy, no-wrap
msgid "IDE support tips"
msgstr "IDE支持提示"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2146
#, fuzzy, no-wrap
msgid "Writing Quarkus extensions in Eclipse"
msgstr "在Eclipse中编写Quarkus扩展"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2149
#, fuzzy
msgid "The only particular aspect of writing Quarkus extensions in Eclipse is that APT (Annotation Processing Tool) is required as part of extension builds, which means you need to:"
msgstr "在Eclipse中编写Quarkus扩展的唯一特殊之处在于，APT（注释处理工具）是扩展构建的一部分，这意味着你需要。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2151
#, fuzzy
msgid "Install `m2e-apt` from https://marketplace.eclipse.org/content/m2e-apt"
msgstr "从 https://marketplace.eclipse.org/content/m2e-apt ，安装 `m2e-apt` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2152
#, fuzzy
msgid "Define this property in your `pom.xml`: `<m2e.apt.activation>jdt_apt</m2e.apt.activation>`, although if you rely on `io.quarkus:quarkus-build-parent` you will get it for free."
msgstr "在你的 `pom.xml` ： `<m2e.apt.activation>jdt_apt</m2e.apt.activation>` ，定义这个属性，尽管如果你依靠 `io.quarkus:quarkus-build-parent` ，你会免费得到它。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2153
#, fuzzy
msgid "If you have the `io.quarkus:quarkus-extension-processor` project open at the same time in your IDE (for example, if you have the Quarkus sources checked out and open in your IDE) you will need to close that project. Otherwise, Eclipse will not invoke the APT plugin that it contains."
msgstr "如果你在你的IDE中同时打开了 `io.quarkus:quarkus-extension-processor` 项目（例如，如果你在你的IDE中签出并打开了Quarkus的源代码），你需要关闭该项目。否则，Eclipse将不会调用它所包含的APT插件。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2154
#, fuzzy
msgid "If you just closed the extension processor project, be sure to do `Maven > Update Project` on the other projects in order for Eclipse to pick up the extension processor from the Maven repository."
msgstr "如果你刚刚关闭了扩展处理器项目，请确保在其他项目上做 `Maven > Update Project` ，以便Eclipse从Maven仓库中获取扩展处理器。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2155
#, fuzzy, no-wrap
msgid "Troubleshooting / Debugging Tips"
msgstr "故障排除/调试技巧"

#.  This id was previously used for the "Dump the Generated Classes to the File System" section
#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2159
#, fuzzy, no-wrap
msgid "Inspecting the Generated/Transformed Classes"
msgstr "检查生成的/转换的类"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2163
#, fuzzy
msgid "Quarkus generates a lot of classes during the build phase and in many cases also transforms existing classes.  It is often extremely useful to see the generated bytecode and transformed classes during the development of an extension."
msgstr "Quarkus在构建阶段会生成大量的类，在很多情况下也会对现有的类进行转换。在扩展的开发过程中，看到生成的字节码和转换的类往往是非常有用的。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2165
#, fuzzy
msgid "If you set the `quarkus.package.fernflower.enabled` property to `true` then Quarkus will download and invoke the https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine[Fernflower decompiler] and dump the result in the `decompiled` directory of the build tool output (`target/decompiled` for Maven for example)."
msgstr "如果你将 `quarkus.package.fernflower.enabled` 属性设置为 `true` ，那么Quarkus将下载并调用 link:https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine[Fernflower反编译器] ，并将结果转储到构建工具输出的 `decompiled` 目录中（例如Maven的 `target/decompiled` ）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2167
#, fuzzy
msgid "This property only works during a normal production build (i.e. not for dev mode/tests) and when `fast-jar` packaging type is used (the default behavior)."
msgstr "这个属性只在正常的生产构建过程中起作用（即不用于开发模式/测试），并且当使用 `fast-jar` 包装类型时（默认行为）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2169
#, fuzzy
msgid "There are also three system properties that allow you to dump the generated/transformed classes to the filesystem and inspect them later, for example via a decompiler in your IDE."
msgstr "还有三个系统属性，允许你将生成/转换的类转储到文件系统中，并在以后检查它们，例如通过IDE中的反编译器。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2171
#, fuzzy
msgid "`quarkus.debug.generated-classes-dir` - to dump the generated classes, such as bean metadata"
msgstr " `quarkus.debug.generated-classes-dir` - 来转储生成的类，如bean元数据"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2172
#, fuzzy
msgid "`quarkus.debug.transformed-classes-dir` - to dump the transformed classes, e.g. Panache entities"
msgstr " `quarkus.debug.transformed-classes-dir` - 来转储转换后的类，例如Panache实体"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2173
#, fuzzy
msgid "`quarkus.debug.generated-sources-dir` - to dump the ZIG files; ZIG file is a textual representation of the generated code that is referenced in the stack traces"
msgstr " `quarkus.debug.generated-sources-dir` - 转储ZIG文件；ZIG文件是生成代码的文本表示，在堆栈跟踪中被引用。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2175
#, fuzzy
msgid "These properties are especially useful in the development mode or when running the tests where the generated/transformed classes are only held in memory in a class loader."
msgstr "这些属性在开发模式下或运行测试时特别有用，因为生成/转换的类只被保存在类加载器的内存中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2177
#, fuzzy
msgid "For example, you can specify the `quarkus.debug.generated-classes-dir` system property to have these classes written out to disk for inspection in the development mode:"
msgstr "例如，你可以指定 `quarkus.debug.generated-classes-dir` 系统属性，以便在开发模式下将这些类写出到磁盘上供检查。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2181
#, no-wrap
msgid "./mvnw quarkus:dev -Dquarkus.debug.generated-classes-dir=dump-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2184
#, fuzzy
msgid "The property value could be either an absolute path, such as `/home/foo/dump` on a Linux machine, or a path relative to the user working directory, i.e. `dump` corresponds to the `{user.dir}/target/dump` in the dev mode and `{user.dir}/dump` when running the tests."
msgstr "该属性值可以是一个绝对路径，如Linux机器上的 `/home/foo/dump` ，也可以是一个相对于用户工作目录的路径，即 `dump` ，对应于开发模式下的 `{user.dir}/target/dump` ，运行测试时的 `{user.dir}/dump` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2186
#, fuzzy
msgid "You should see a line in the log for each class written to the directory:"
msgstr "你应该在日志中看到每一个写到目录中的类的一行。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2190
#, no-wrap
msgid "INFO  [io.qua.run.boo.StartupActionImpl] (main) Wrote /path/to/my/app/target/dump-classes/io/quarkus/arc/impl/ActivateRequestContextInterceptor_Bean.class\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2193
#, fuzzy
msgid "The property is also honored when running tests:"
msgstr "该属性在运行测试时也会被尊重。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2197
#, no-wrap
msgid "./mvnw clean test -Dquarkus.debug.generated-classes-dir=target/dump-generated-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2200
#, fuzzy
msgid "Analogously, you can use the `quarkus.debug.transformed-classes-dir` and `quarkus.debug.transformed-classes-dir` properties to dump the relevant output."
msgstr "类似地，你可以使用 `quarkus.debug.transformed-classes-dir` 和 `quarkus.debug.transformed-classes-dir` 属性来转储相关的输出。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2201
#, fuzzy, no-wrap
msgid "Multi-module Maven Projects and the Development Mode"
msgstr "多模块Maven项目和开发模式"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2206
#, fuzzy
msgid "It's not uncommon to develop an extension in a multi-module Maven project that also contains an \"example\" module.  However, if you want to run the example in the development mode then the `-DnoDeps` system property must be used in order to exclude the local project dependencies.  Otherwise, Quarkus attempts to monitor the extension classes and this may result in weird class loading issues."
msgstr "在一个多模块的Maven项目中开发一个扩展，并包含一个 \"示例 \"模块的情况并不少见。然而，如果您想在开发模式下运行示例，那么必须使用 `-DnoDeps` 系统属性，以排除本地项目的依赖性。否则，Quarkus会尝试监控扩展类，这可能导致奇怪的类加载问题。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2210
#, no-wrap
msgid "./mvnw compile quarkus:dev -DnoDeps\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2212
#, fuzzy, no-wrap
msgid "Indexer does not include your external dependency"
msgstr "索引器不包括你的外部依赖性"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2215
#, fuzzy
msgid "Remember to add `IndexDependencyBuildItem` artifacts to your `@BuildStep`."
msgstr "记得在你的 `@BuildStep` ，添加 `IndexDependencyBuildItem` 工件。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2216
#, fuzzy, no-wrap
msgid "Sample Test Extension"
msgstr "样品测试扩展"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2219
#, fuzzy
msgid "We have an extension that is used to test for regressions in the extension processing. It is located in {quarkus-tree-url}/integration-tests/test-extension/extension directory. In this section we touch on some of the tasks an extension author will typically need to perform using the test-extension code to illustrate how the task could be done."
msgstr "我们有一个扩展，用来测试扩展处理中的退步情况。它位于{quarkus-tree-url}/integration-tests/test-extension/extension目录中。在这一节中，我们将触及扩展作者通常需要使用test-extension代码执行的一些任务，以说明如何完成该任务。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2220
#, fuzzy, no-wrap
msgid "Features and Capabilities"
msgstr "特点和能力"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2222
#, fuzzy, no-wrap
msgid "Features"
msgstr "特点"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2226
#, fuzzy
msgid "A _feature_ represents a functionality provided by an extension.  The name of the feature gets displayed in the log during application bootstrap."
msgstr "一个 _特性_ 代表一个扩展所提供的功能。该功能的名称在应用程序启动时显示在日志中。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2227
#, fuzzy, no-wrap
msgid "Example Startup Lines"
msgstr "示例启动线"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2232
#, no-wrap
msgid ""
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 0.061s.\n"
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Installed features: [cdi, test-extension] <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2234
#, fuzzy
msgid "A list of features installed in the runtime image"
msgstr "安装在运行时映像中的功能列表"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2236
#, fuzzy
msgid "A feature can be registered in a <<Build Step Processors>> method that produces a `FeatureBuildItem`:"
msgstr "一个特征可以在 link:#Build Step Processors[[Build Step Processors]] 方法中注册，产生一个 `FeatureBuildItem` 。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2237
#, fuzzy, no-wrap
msgid "TestProcessor#feature()"
msgstr "TestProcessor#feature()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2244
#, no-wrap
msgid ""
"    @BuildStep\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(\"test-extension\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2249
#, fuzzy
msgid "The name of the feature should only contain lowercase characters, words are separated by dash; e.g. `security-jpa`.  An extension should provide at most one feature and the name must be unique.  If multiple extensions register a feature of the same name the build fails."
msgstr "特征的名称应该只包含小写字母，单词之间用破折号隔开；例如： `security-jpa` 。一个扩展最多只能提供一个特性，而且名称必须是唯一的。如果多个扩展注册了相同名称的特征，则构建失败。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2253
#, fuzzy
msgid "The feature name should also map to a label in the extension's `devtools/common/src/main/filtered/extensions.json` entry so that the feature name displayed by the startup line matches a label that one can used to select the extension when creating a project using the Quarkus maven plugin as shown in this example taken from the xref:rest-json.adoc[Writing JSON REST Services] guide where the `resteasy-reactive-jackson` feature is referenced:"
msgstr "该特性名称也应与扩展的 `devtools/common/src/main/filtered/extensions.json` 条目中的标签相对应，以便在使用Quarkus maven插件创建项目时，启动行显示的特性名称与选择该扩展的标签相匹配，如本例所示，该例子摘自《 link:rest-json.html[编写JSON REST服务指南] 》，其中引用了 `resteasy-reactive-jackson` 特性。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2263
#, no-wrap
msgid ""
"mvn io.quarkus.platform:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-reactive,resteasy-reactive-jackson\"\n"
"cd rest-json\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2265
#, fuzzy, no-wrap
msgid "Capabilities"
msgstr "能力"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2271
#, fuzzy
msgid "A _capability_ represents a technical capability that can be queried by other extensions.  An extension may provide multiple capabilities and multiple extensions can provide the same capability.  By default, capabilities are not displayed to users.  Capabilities should be used when checking for the presence of an extension rather than class path based checks."
msgstr "一个 _能力_ 代表一个可以被其他扩展查询的技术能力。一个扩展可以提供多种能力，多个扩展可以提供相同的能力。默认情况下，能力不显示给用户。在检查一个扩展是否存在时，应该使用能力，而不是基于类路径的检查。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2273
#, fuzzy
msgid "Capabilities can be registered in a <<Build Step Processors>> method that produces a `CapabilityBuildItem`:"
msgstr "能力可以在 link:#Build Step Processors[[构建步骤处理器]] 方法中注册，产生一个 `CapabilityBuildItem` 。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2274
#, fuzzy, no-wrap
msgid "TestProcessor#capability()"
msgstr "TestProcessor#capability()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2282
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void capabilities(BuildProducer<CapabilityBuildItem> capabilityProducer) {\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-transactions\"));\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-metrics\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2285
#, fuzzy
msgid "Extensions can consume registered capabilities using the `Capabilities` build item:"
msgstr "扩展可以使用 `Capabilities` 构建项来消费已注册的能力。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2286
#, fuzzy, no-wrap
msgid "TestProcessor#doSomeCoolStuff()"
msgstr "TestProcessor#doSomeCoolStuff()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2295
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void doSomeCoolStuff(Capabilities capabilities) {\n"
"        if (capabilities.isPresent(Capability.TRANSACTIONS)) {\n"
"          // do something only if JTA transactions are in...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2299
#, fuzzy
msgid "Capabilities should follow the naming conventions of Java packages; e.g. `io.quarkus.security.jpa`.  Capabilities provided by core extensions should be listed in the `io.quarkus.deployment.Capability` enum and their name should always start with the `io.quarkus` prefix."
msgstr "能力应该遵循Java包的命名惯例；例如： `io.quarkus.security.jpa` 。由核心扩展提供的能力应该被列在 `io.quarkus.deployment.Capability` 枚举中，其名称应该总是以 `io.quarkus` 前缀开始。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2300
#, fuzzy, no-wrap
msgid "Bean Defining Annotations"
msgstr "Bean定义注解"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2302
#, fuzzy
msgid "The CDI layer processes CDI beans that are either explicitly registered or that it discovers based on bean defining annotations as defined in https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[2.5.1. Bean defining annotations]. You can expand this set of annotations to include annotations your extension processes using a `BeanDefiningAnnotationBuildItem` as shown in this `TestProcessor#registerBeanDefinningAnnotations` example:"
msgstr "CDI层处理显式注册的CDI Bean，或者它根据 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[2.5.1] 中定义的Bean定义注释发现的CDI Bean。 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[Bean定义注] 解。你可以扩展这组注解，以包括你的扩展使用 `BeanDefiningAnnotationBuildItem` 处理的注解，如这个 `TestProcessor#registerBeanDefinningAnnotations` 例子所示。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2303
#, fuzzy, no-wrap
msgid "Register a Bean Defining Annotation"
msgstr "注册一个豆类的定义注释"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2309
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import org.jboss.jandex.DotName;\n"
"import io.quarkus.extest.runtime.TestAnnotation;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2313
#, no-wrap
msgid ""
"public final class TestProcessor {\n"
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());\n"
"    static DotName TEST_ANNOTATION_SCOPE = DotName.createSimple(ApplicationScoped.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2315
#: upstream/_guides/writing-extensions.adoc:2341
#, no-wrap
msgid "...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2323
#, no-wrap
msgid ""
"    @BuildStep\n"
"    BeanDefiningAnnotationBuildItem registerX() {\n"
"        <1>\n"
"        return new BeanDefiningAnnotationBuildItem(TEST_ANNOTATION, TEST_ANNOTATION_SCOPE);\n"
"    }\n"
"...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2333
#, no-wrap
msgid ""
"/**\n"
" * Marker annotation for test configuration target beans\n"
" */\n"
"@Target({ TYPE })\n"
"@Retention(RUNTIME)\n"
"@Documented\n"
"@Inherited\n"
"public @interface TestAnnotation {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2339
#, no-wrap
msgid ""
"/**\n"
" * A sample bean\n"
" */\n"
"@TestAnnotation <2>\n"
"public class ConfiguredBean implements IConfigConsumer {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2343
#, fuzzy
msgid "Register the annotation class and CDI default scope using the Jandex `DotName` class."
msgstr "使用Jandex `DotName` 类注册注解类和CDI默认范围。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2344
#, fuzzy
msgid "`ConfiguredBean` will be processed by the CDI layer the same as a bean annotated with the CDI standard @ApplicationScoped."
msgstr " `ConfiguredBean` 将被CDI层处理，就像用CDI标准@ApplicationScoped注解的bean一样。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2345
#, fuzzy, no-wrap
msgid "Parsing Config to Objects"
msgstr "将配置解析为对象"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2347
#, fuzzy
msgid "One of the main things an extension is likely to do is completely separate the configuration phase of behavior from the runtime phase. Frameworks often do parsing/load of configuration on startup that can be done during build time to both reduce the runtime dependencies on frameworks like xml parsers as well as reducing the startup time the parsing incurs."
msgstr "一个扩展可能要做的主要事情之一是将行为的配置阶段与运行时阶段完全分开。框架通常在启动时进行解析/加载配置，这可以在构建时完成，以减少对xml解析器等框架的运行时依赖，并减少解析所带来的启动时间。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2349
#, fuzzy
msgid "An example of parsing a XML config file using JAXB is shown in the `TestProcessor#parseServiceXmlConfig` method:"
msgstr "一个使用JAXB解析XML配置文件的例子显示在 `TestProcessor#parseServiceXmlConfig` 方法中。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2349
#, fuzzy, no-wrap
msgid "Parsing an XML Configuration into Runtime XmlConfig Instance"
msgstr "将XML配置解析为运行时XmlConfig实例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2366
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\"); <1>\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is); <2>\n"
"...\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2369
#, fuzzy
msgid "Look for a config.xml classpath resource"
msgstr "寻找一个config.xml classpath资源"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2370
#, fuzzy
msgid "If found, parse using JAXB context for `XmlConfig.class`"
msgstr "如果找到了，则使用JAXB上下文解析为 `XmlConfig.class` "

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2374
#, fuzzy
msgid "If there was no /config.xml resource available in the build environment, then a null `RuntimeServiceBuildItem` would be returned and no subsequent logic based on a `RuntimeServiceBuildItem` being produced would execute."
msgstr "如果在构建环境中没有/config.xml资源可用，那么将返回一个空的 `RuntimeServiceBuildItem` ，并且不会执行基于正在产生的 `RuntimeServiceBuildItem` 的后续逻辑。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2377
#, fuzzy
msgid "Typically one is loading a configuration to create some runtime component/service as `parseServiceXmlConfig` is doing. We will come back to the rest of the behavior in `parseServiceXmlConfig` in the following <<Manage Non-CDI Service>> section."
msgstr "通常情况下，人们正在加载一个配置来创建一些运行时组件/服务，就像 `parseServiceXmlConfig` 。我们将在下面的 link:#Manage Non-CDI Service[[管理非CDI服务]] 部分再来讨论 `parseServiceXmlConfig` 中的其他行为。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2379
#, fuzzy
msgid "If for some reason you need to parse the config and use it in other build steps in an extension processor, you would need to create an `XmlConfigBuildItem` to pass the parsed XmlConfig instance around."
msgstr "如果出于某种原因，你需要解析配置并在扩展处理器的其他构建步骤中使用它，你将需要创建一个 `XmlConfigBuildItem` ，以传递解析后的XmlConfig实例。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2383
#, fuzzy
msgid "If you look at the XmlConfig code you will see that it does carry around the JAXB annotations. If you don't want these in the runtime image, you could clone the XmlConfig instance into some POJO object graph and then replace XmlConfig with the POJO class. We will do this in <<Replacing Classes in the Native Image>>."
msgstr "如果你看一下XmlConfig的代码，你会发现它确实带着JAXB注释。如果你不希望这些在运行时映像中出现，你可以将XmlConfig实例克隆到一些POJO对象图中，然后用POJO类替换XmlConfig。我们将在 link:#Replacing Classes in the Native Image[[替换本地映像中的类]中] 这样做。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2385
#, fuzzy, no-wrap
msgid "Scanning Deployments Using Jandex"
msgstr "使用Jandex扫描部署情况"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2387
#, fuzzy
msgid "If your extension defines annotations or interfaces that mark beans needing to be processed, you can locate these beans using the Jandex API, a Java annotation indexer and offline reflection library. The following `TestProcessor#scanForBeans` method shows how to find the beans annotated with our `@TestAnnotation` that also implement the `IConfigConsumer` interface:"
msgstr "如果你的扩展定义了标记需要处理的Bean的注解或接口，你可以使用Jandex API，一个Java注解索引器和离线反射库来定位这些Bean。下面的 `TestProcessor#scanForBeans` 方法显示了如何找到用我们的 `@TestAnnotation` 注释的Bean，这些Bean也实现了 `IConfigConsumer` 接口。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2388
#, fuzzy, no-wrap
msgid "Example Jandex Usage"
msgstr "Jandex使用实例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2393
#, no-wrap
msgid ""
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2416
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    void scanForBeans(TestRecorder recorder, BeanArchiveIndexBuildItem beanArchiveIndex, <1>\n"
"            BuildProducer<TestBeanBuildItem> testBeanProducer) {\n"
"        IndexView indexView = beanArchiveIndex.getIndex(); <2>\n"
"        Collection<AnnotationInstance> testBeans = indexView.getAnnotations(TEST_ANNOTATION); <3>\n"
"        for (AnnotationInstance ann : testBeans) {\n"
"            ClassInfo beanClassInfo = ann.target().asClass();\n"
"            try {\n"
"                boolean isConfigConsumer = beanClassInfo.interfaceNames()\n"
"                        .stream()\n"
"                        .anyMatch(dotName -> dotName.equals(DotName.createSimple(IConfigConsumer.class.getName()))); <4>\n"
"                if (isConfigConsumer) {\n"
"                    Class<IConfigConsumer> beanClass = (Class<IConfigConsumer>) Class.forName(beanClassInfo.name().toString(), false, Thread.currentThread().getContextClassLoader());\n"
"                    testBeanProducer.produce(new TestBeanBuildItem(beanClass)); <5>\n"
"                    log.infof(\"Configured bean: %s\", beanClass);\n"
"                }\n"
"            } catch (ClassNotFoundException e) {\n"
"                log.warn(\"Failed to load bean class\", e);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2418
#, fuzzy
msgid "Depend on a `BeanArchiveIndexBuildItem` to have the build step be run after the deployment has been indexed."
msgstr "依赖于一个 `BeanArchiveIndexBuildItem` ，以便在部署被索引后运行构建步骤。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2419
#, fuzzy
msgid "Retrieve the index."
msgstr "检索索引。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2420
#, fuzzy
msgid "Find all beans annotated with `@TestAnnotation`."
msgstr "查找所有注有 `@TestAnnotation` 的豆子。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2421
#, fuzzy
msgid "Determine which of these beans also has the `IConfigConsumer` interface."
msgstr "确定这些豆子中哪个也有 `IConfigConsumer` 接口。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2422
#, fuzzy
msgid "Save the bean class in a `TestBeanBuildItem` for use in a latter RUNTIME_INIT build step that will interact with the bean instances."
msgstr "将Bean类保存在 `TestBeanBuildItem` ，以便在后面的RUNTIME_INIT构建步骤中使用，该步骤将与Bean实例交互。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2423
#, fuzzy, no-wrap
msgid "Interacting With Extension Beans"
msgstr "与扩展豆互动"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2425
#, fuzzy
msgid "You can use the `io.quarkus.arc.runtime.BeanContainer` interface to interact with your extension beans. The following `configureBeans` methods illustrate interacting with the beans scanned for in the previous section:"
msgstr "你可以使用 `io.quarkus.arc.runtime.BeanContainer` 接口来与你的扩展Bean进行交互。下面的 `configureBeans` 方法说明了与上一节中扫描到的Bean进行交互。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2426
#, fuzzy, no-wrap
msgid "Using CDI BeanContainer Interface"
msgstr "使用CDI BeanContainer接口"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2435
#, no-wrap
msgid ""
"// TestProcessor#configureBeans\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    void configureBeans(TestRecorder recorder, List<TestBeanBuildItem> testBeans, <1>\n"
"            BeanContainerBuildItem beanContainer, <2>\n"
"            TestRunTimeConfig runTimeConfig) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2441
#, no-wrap
msgid ""
"        for (TestBeanBuildItem testBeanBuildItem : testBeans) {\n"
"            Class<IConfigConsumer> beanClass = testBeanBuildItem.getConfigConsumer();\n"
"            recorder.configureBeans(beanContainer.getValue(), beanClass, buildAndRunTimeConfig, runTimeConfig); <3>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2451
#, no-wrap
msgid ""
"// TestRecorder#configureBeans\n"
"    public void configureBeans(BeanContainer beanContainer, Class<IConfigConsumer> beanClass,\n"
"            TestBuildAndRunTimeConfig buildTimeConfig,\n"
"            TestRunTimeConfig runTimeConfig) {\n"
"        log.info(\"Begin BeanContainerListener callback\\n\");\n"
"        IConfigConsumer instance = beanContainer.instance(beanClass); <4>\n"
"        instance.loadConfig(buildTimeConfig, runTimeConfig); <5>\n"
"        log.infof(\"configureBeans, instance=%s\\n\", instance);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2453
#, fuzzy
msgid "Consume the `TestBeanBuildItem`s produced from the scanning build step."
msgstr "吸收从扫描构建步骤中产生的`TestBeanBuildItem's。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2454
#, fuzzy
msgid "Consume the `BeanContainerBuildItem` to order this build step to run after the CDI bean container has been created."
msgstr "消耗 `BeanContainerBuildItem` ，以便在CDI bean容器创建后命令这个构建步骤运行。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2455
#, fuzzy
msgid "Call the runtime recorder to record the bean interactions."
msgstr "调用运行时记录器来记录Bean的交互。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2456
#, fuzzy
msgid "Runtime recorder retrieves the bean using its type."
msgstr "运行时记录器使用其类型检索Bean。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2457
#, fuzzy
msgid "Runtime recorder invokes the `IConfigConsumer#loadConfig(...)` method passing in the configuration objects with runtime information."
msgstr "运行时记录器调用 `IConfigConsumer#loadConfig(…​)` 方法，传入带有运行时信息的配置对象。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2458
#, fuzzy, no-wrap
msgid "Manage Non-CDI Service"
msgstr "管理非CDI服务"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2460
#, fuzzy
msgid "A common purpose for an extension is to integrate a non-CDI aware service into the CDI based Quarkus runtime. Step 1 of this task is to load any configuration needed in a STATIC_INIT build step as we did in <<Parsing Config to Objects>>. Now we need to create an instance of the service using the configuration. Let's return to the `TestProcessor#parseServiceXmlConfig` method to see how this can be done."
msgstr "扩展的一个常见目的是将一个非CDI感知的服务集成到基于CDI的Quarkus运行时中。这项任务的第1步是在STATIC_INIT构建步骤中加载任何需要的配置，就像我们在 link:#Parsing Config to Objects[[将配置解析为对象]] 中做的那样。现在我们需要使用配置来创建一个服务的实例。让我们回到 `TestProcessor#parseServiceXmlConfig` 方法，看看如何做到这一点。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2461
#, fuzzy, no-wrap
msgid "Creating a Non-CDI Service"
msgstr "创建一个非CDI服务"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2481
#, no-wrap
msgid ""
"// TestProcessor#parseServiceXmlConfig\n"
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\");\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is);\n"
"            log.info(\"Loaded XmlConfig, creating service\");\n"
"            RuntimeValue<RuntimeXmlConfigService> service = recorder.initRuntimeService(config); //<1>\n"
"            serviceBuildItem = new RuntimeServiceBuildItem(service); //<3>\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2487
#, no-wrap
msgid ""
"// TestRecorder#initRuntimeService\n"
"    public RuntimeValue<RuntimeXmlConfigService> initRuntimeService(XmlConfig config) {\n"
"        RuntimeXmlConfigService service = new RuntimeXmlConfigService(config); //<2>\n"
"        return new RuntimeValue<>(service);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2491
#, no-wrap
msgid ""
"// RuntimeServiceBuildItem\n"
"    final public class RuntimeServiceBuildItem extends SimpleBuildItem {\n"
"    private RuntimeValue<RuntimeXmlConfigService> service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2495
#, no-wrap
msgid ""
"    public RuntimeServiceBuildItem(RuntimeValue<RuntimeXmlConfigService> service) {\n"
"        this.service = service;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2500
#, no-wrap
msgid ""
"    public RuntimeValue<RuntimeXmlConfigService> getService() {\n"
"        return service;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2502
#, fuzzy
msgid "Call into the runtime recorder to record the creation of the service."
msgstr "调用到运行时记录器，记录服务的创建过程。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2503
#, fuzzy
msgid "Using the parsed `XmlConfig` instance, create an instance of `RuntimeXmlConfigService` and wrap it in a `RuntimeValue`. Use a `RuntimeValue` wrapper for non-interface objects that are non-proxiable."
msgstr "使用解析过的 `XmlConfig` 实例，创建一个 `RuntimeXmlConfigService` 的实例，并将其包装在一个 `RuntimeValue` 中。对于不可代理的非界面对象，使用一个 `RuntimeValue` 包装器。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2504
#, fuzzy
msgid "Wrap the return service value in a `RuntimeServiceBuildItem` for use in a RUNTIME_INIT build step that will start the service."
msgstr "将返回的服务值包裹在一个 `RuntimeServiceBuildItem` ，用于启动服务的RUNTIME_INIT构建步骤中。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2505
#, fuzzy, no-wrap
msgid "Starting a Service"
msgstr "开始一项服务"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2507
#, fuzzy
msgid "Now that you have recorded the creation of a service during the build phase, you need to record how to start the service at runtime during booting. You do this with a RUNTIME_INIT build step as shown in the `TestProcessor#startRuntimeService` method."
msgstr "现在你已经记录了在构建阶段创建服务的过程，你需要记录如何在启动过程中运行时启动服务。你用RUNTIME_INIT构建步骤来做这件事，如 `TestProcessor#startRuntimeService` 方法所示。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2508
#, fuzzy, no-wrap
msgid "Starting/Stopping a Non-CDI Service"
msgstr "开始/停止一项非CDI服务"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2524
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem , // <1>\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException { // <2>\n"
"        if (serviceBuildItem != null) {\n"
"            log.info(\"Registering service start\");\n"
"            recorder.startRuntimeService(shutdownContextBuildItem, serviceBuildItem.getService()); // <3>\n"
"        } else {\n"
"            log.info(\"No RuntimeServiceBuildItem seen, check config.xml\");\n"
"        }\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2532
#, no-wrap
msgid ""
"// TestRecorder#startRuntimeService\n"
"    public void startRuntimeService(ShutdownContext shutdownContext, RuntimeValue<RuntimeXmlConfigService> runtimeValue)\n"
"            throws IOException {\n"
"        RuntimeXmlConfigService service = runtimeValue.getValue();\n"
"        service.startService(); //<5>\n"
"        shutdownContext.addShutdownTask(service::stopService); //<6>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2534
#, fuzzy
msgid "We consume a ShutdownContextBuildItem to register the service shutdown."
msgstr "我们消耗一个ShutdownContextBuildItem来注册服务关机。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2535
#, fuzzy
msgid "We consume the previously initialized service captured in `RuntimeServiceBuildItem`."
msgstr "我们消耗先前在 `RuntimeServiceBuildItem` 中捕获的初始化服务。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2536
#, fuzzy
msgid "Call the runtime recorder to record the service start invocation."
msgstr "调用运行时记录器来记录服务的启动调用。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2537
#, fuzzy
msgid "Produce a `ServiceStartBuildItem` to indicate the startup of a service. See <<Startup and Shutdown Events>> for details."
msgstr "产生一个 `ServiceStartBuildItem` ，以表明一个服务的启动。详见 link:#Startup and Shutdown Events[【启动和关闭事件】] 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2538
#, fuzzy
msgid "Runtime recorder retrieves the service instance reference and calls its `startService` method."
msgstr "运行时记录器检索服务实例引用并调用其 `startService` 方法。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2539
#, fuzzy
msgid "Runtime recorder registers an invocation of the service instance `stopService` method with the Quarkus `ShutdownContext`."
msgstr "运行时记录器将服务实例 `stopService` 方法的调用登记在Quarkus `ShutdownContext` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2542
#, fuzzy
msgid "The code for the `RuntimeXmlConfigService` can be viewed here: {quarkus-blob-url}/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"
msgstr " `RuntimeXmlConfigService` 的代码可以在这里查看。{quarkus-blob-url}/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2544
#, fuzzy
msgid "The testcase for validating that the `RuntimeXmlConfigService` has started can be found in the `testRuntimeXmlConfigService` test of `ConfiguredBeanTest` and `NativeImageIT`."
msgstr "验证 `RuntimeXmlConfigService` 已经启动的测试案例可以在 `ConfiguredBeanTest` 和 `NativeImageIT` 的 `testRuntimeXmlConfigService` 测试中找到。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2545
#, fuzzy, no-wrap
msgid "Startup and Shutdown Events"
msgstr "开机和关机事件"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2548
#, fuzzy
msgid "The Quarkus container supports startup and shutdown lifecycle events to notify components of the container startup and shutdown. There are CDI events fired that components can observe are illustrated in this example:"
msgstr "Quarkus容器支持启动和关闭生命周期事件，以通知组件容器的启动和关闭。有一些CDI事件被触发，组件可以观察到，在这个例子中说明了。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2549
#, fuzzy, no-wrap
msgid "Observing Container Startup"
msgstr "观察容器的启动"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2554
#, no-wrap
msgid ""
"import io.quarkus.runtime.ShutdownEvent;\n"
"import io.quarkus.runtime.StartupEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2563
#, no-wrap
msgid ""
"public class SomeBean {\n"
"    /**\n"
"     * Called when the runtime has started\n"
"     * @param event\n"
"     */\n"
"    void onStart(@Observes StartupEvent event) { // <1>\n"
"        System.out.printf(\"onStart, event=%s%n\", event);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2572
#, no-wrap
msgid ""
"    /**\n"
"     * Called when the runtime is shutting down\n"
"     * @param event\n"
"    */\n"
"    void onStop(@Observes ShutdownEvent event) { // <2>\n"
"        System.out.printf(\"onStop, event=%s%n\", event);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2574
#, fuzzy
msgid "Observe a `StartupEvent` to be notified the runtime has started."
msgstr "观察一个 `StartupEvent` ，以得到运行时间已经开始的通知。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2575
#, fuzzy
msgid "Observe a `ShutdownEvent` to be notified when the runtime is going to shutdown."
msgstr "观察一个 `ShutdownEvent` ，以便在运行时要关闭时得到通知。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2579
#, fuzzy
msgid "What is the relevance of startup and shutdown events for extension authors? We have already seen the use of a `ShutdownContext` to register a callback to perform shutdown tasks in the <<Starting a Service>> section. These shutdown tasks would be called after a `ShutdownEvent` had been sent."
msgstr "启动和关闭事件与扩展作者的关系是什么？我们已经在 link:#Starting a Service[[启动服务]] 一节中看到了使用 `ShutdownContext` 来注册一个回调，以执行关机任务。这些关机任务将在 `ShutdownEvent` 发送后被调用。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2585
#, fuzzy
msgid "A `StartupEvent` is fired after all `io.quarkus.deployment.builditem.ServiceStartBuildItem` producers have been consumed.  The implication of this is that if an extension has services that application components would expect to have been started when they observe a `StartupEvent`, the build steps that invoke the runtime code to start those services needs to produce a `ServiceStartBuildItem` to ensure that the runtime code is run before the `StartupEvent` is sent. Recall that we saw the production of a `ServiceStartBuildItem` in the previous section, and it is repeated here for clarity:"
msgstr " `StartupEvent` 是在所有 `io.quarkus.deployment.builditem.ServiceStartBuildItem` 生产者被消耗后触发的。这意味着，如果一个扩展有一些服务，应用组件希望在观察到 `StartupEvent` 时已经启动，那么调用运行时代码启动这些服务的构建步骤需要产生一个 `ServiceStartBuildItem` ，以确保运行时代码在 `StartupEvent` 发送之前已经运行。回顾一下，我们在上一节中看到了 `ServiceStartBuildItem` 的产生，为了清楚起见，这里再重复一下。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2586
#, fuzzy, no-wrap
msgid "Example of Producing a ServiceStartBuildItem"
msgstr "制作服务启动构建项目的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2597
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem,\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException {\n"
"...\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2599
#, fuzzy
msgid "Produce a `ServiceStartBuildItem` to indicate that this is a service starting step that needs to run before the `StartupEvent` is sent."
msgstr "产生一个 `ServiceStartBuildItem` ，表明这是一个服务启动步骤，需要在发送 `StartupEvent` 之前运行。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2600
#, fuzzy, no-wrap
msgid "Register Resources for Use in Native Image"
msgstr "注册资源用于本地图像"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2602
#, fuzzy
msgid "Not all configuration or resources can be consumed at build time. If you have classpath resources that the runtime needs to access, you need to inform the build phase that these resources need to be copied into the native image. This is done by producing one or more `NativeImageResourceBuildItem` or `NativeImageResourceBundleBuildItem` in the case of resource bundles. Examples of this are shown in this sample `registerNativeImageResources` build step:"
msgstr "并非所有的配置或资源都能在构建时被消耗。如果你有运行时需要访问的classpath资源，你需要通知构建阶段，这些资源需要被复制到本地镜像中。这可以通过产生一个或多个 `NativeImageResourceBuildItem` ，或者在资源包的情况下产生 `NativeImageResourceBundleBuildItem` 。这方面的例子显示在这个示例 `registerNativeImageResources` 构建步骤中。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2603
#, fuzzy, no-wrap
msgid "Registering Resources and ResourceBundles"
msgstr "注册资源和资源包"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2611
#, no-wrap
msgid ""
"public final class MyExtProcessor {\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBuildItem> resource;\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBundleBuildItem> resourceBundle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2615
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources() {\n"
"        resource.produce(new NativeImageResourceBuildItem(\"/security/runtime.keys\")); //<1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2618
#, no-wrap
msgid ""
"        resource.produce(new NativeImageResourceBuildItem(\n"
"                \"META-INF/my-descriptor.xml\")); //<2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2622
#, no-wrap
msgid ""
"        resourceBundle.produce(new NativeImageResourceBuildItem(\"javax.xml.bind.Messages\")); //<3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2624
#, fuzzy
msgid "Indicate that the /security/runtime.keys classpath resource should be copied into native image."
msgstr "表示/security/runtime.keys classpath资源应被复制到本地镜像中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2625
#, fuzzy
msgid "Indicate that the `META-INF/my-descriptor.xml` resource should be copied into native image"
msgstr "表明 `META-INF/my-descriptor.xml` 资源应被复制到本地图像中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2626
#, fuzzy
msgid "Indicate that the \"javax.xml.bind.Messages\" resource bundle should be copied into native image."
msgstr "表示 \"javax.xml.bind.Messages \"资源包应被复制到本地镜像中。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2627
#, fuzzy, no-wrap
msgid "Service files"
msgstr "服务文件"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2631
#, fuzzy
msgid "If you are using `META-INF/services` files you need to register the files as resources so that your native image can find them, but you also need to register each listed class for reflection so they can be instantiated or inspected at run-time:"
msgstr "如果你使用 `META-INF/services` 文件，你需要将这些文件注册为资源，以便你的本地图像可以找到它们，但你也需要为反射注册每个列出的类，以便它们可以在运行时被实例化或检查。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2635
#: upstream/_guides/writing-extensions.adoc:2665
#: upstream/_guides/writing-extensions.adoc:2694
#, no-wrap
msgid "public final class MyExtProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2639
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> services) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2644
#, no-wrap
msgid ""
"        // find out all the implementation classes listed in the service files\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                          service);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2652
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be instantiated\n"
"        // in native-image at run-time\n"
"        services.produce(\n"
"            new ServiceProviderBuildItem(io.quarkus.SomeService.class.getName(),\n"
"                                         implementations.toArray(new String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2658
#, fuzzy
msgid "`ServiceProviderBuildItem` takes a list of service implementation classes as parameters: if you are not reading them from the service file, make sure that they correspond to the service file contents because the service file will still be read and used at run-time. This is not a substitute for writing a service file."
msgstr " `ServiceProviderBuildItem` 需要一个服务实现类的列表作为参数：如果你不是从服务文件中读取它们，请确保它们与服务文件的内容相对应，因为服务文件仍将在运行时被读取和使用。这并不能代替编写服务文件。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2661
#, fuzzy
msgid "This only registers the implementation classes for instantiation via reflection (you will not be able to inspect its fields and methods). If you need to do that, you can do it this way:"
msgstr "这只是注册了实现类，以便通过反射进行实例化（你将不能检查其字段和方法）。如果你需要这样做，你可以这样做。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2670
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources(BuildProducer<NativeImageResourceBuildItem> resource,\n"
"                                     BuildProducer<ReflectiveClassBuildItem> reflectionClasses) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2673
#, no-wrap
msgid ""
"        // register the service file so it is visible in native-image\n"
"        resource.produce(new NativeImageResourceBuildItem(service));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2683
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be inspected/instantiated\n"
"        // in native-image at run-time\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                          service);\n"
"        reflectionClasses.produce(\n"
"            new ReflectiveClassBuildItem(true, true, implementations.toArray(new String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2687
#, fuzzy
msgid "While this is the easiest way to get your services running natively, it's less efficient than scanning the implementation classes at build time and generating code that registers them at static-init time instead of relying on reflection."
msgstr "虽然这是让你的服务原生运行的最简单方法，但它的效率不如在构建时扫描实现类，并在静态启动时生成注册它们的代码，而不是依赖反射。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2690
#, fuzzy
msgid "You can achieve that by adapting the previous build step to use a static-init recorder instead of registering classes for reflection:"
msgstr "你可以通过调整前面的构建步骤来实现这一点，即使用静态-init记录器而不是注册类来进行反射。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2700
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(ExecutionTime.STATIC_INIT)\n"
"    void registerNativeImageResources(RecorderContext recorderContext,\n"
"                                     SomeServiceRecorder recorder) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2709
#, no-wrap
msgid ""
"        // read the implementation classes\n"
"        Collection<Class<? extends io.quarkus.SomeService>> implementationClasses = new LinkedHashSet<>();\n"
"        Set<String> implementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                                                    service);\n"
"        for(String implementation : implementations) {\n"
"            implementationClasses.add((Class<? extends io.quarkus.SomeService>)\n"
"                recorderContext.classProxy(implementation));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2714
#, no-wrap
msgid ""
"        // produce a static-initializer with those classes\n"
"        recorder.configure(implementationClasses);\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2717
#, no-wrap
msgid ""
"@Recorder\n"
"public class SomeServiceRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2722
#, no-wrap
msgid ""
"    public void configure(List<Class<? extends io.quarkus.SomeService>> implementations) {\n"
"        // configure our service statically\n"
"        SomeServiceProvider serviceProvider = SomeServiceProvider.instance();\n"
"        SomeServiceBuilder builder = serviceProvider.getSomeServiceBuilder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2732
#, no-wrap
msgid ""
"        List<io.quarkus.SomeService> services = new ArrayList<>(implementations.size());\n"
"        // instantiate the service implementations\n"
"        for (Class<? extends io.quarkus.SomeService> implementationClass : implementations) {\n"
"            try {\n"
"                services.add(implementationClass.getConstructor().newInstance());\n"
"            } catch (Exception e) {\n"
"                throw new IllegalArgumentException(\"Unable to instantiate service \" + implementationClass, e);\n"
"            }\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2736
#, no-wrap
msgid ""
"        // build our service\n"
"        builder.withSomeServices(implementations.toArray(new io.quarkus.SomeService[0]));\n"
"        ServiceManager serviceManager = builder.build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2741
#, no-wrap
msgid ""
"        // register it\n"
"        serviceProvider.registerServiceManager(serviceManager, Thread.currentThread().getContextClassLoader());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2744
#, fuzzy, no-wrap
msgid "Object Substitution"
msgstr "对象替代"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2746
#, fuzzy
msgid "Objects created during the build phase that are passed into the runtime need to have a default constructor in order for them to be created and configured at startup of the runtime from the build time state. If an object does not have a default constructor you will see an error similar to the following during generation of the augmented artifacts:"
msgstr "在构建阶段创建的、被传入运行时的对象需要有一个默认的构造函数，以便在运行时启动时从构建时的状态创建和配置它们。如果一个对象没有默认的构造函数，在生成增强的工件时，你会看到一个类似于以下的错误。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2747
#, fuzzy, no-wrap
msgid "DSAPublicKey Serialization Error"
msgstr "DSAP公共密钥序列化错误"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2756
#, no-wrap
msgid ""
"\t[error]: Build step io.quarkus.deployment.steps.MainClassBuildStep#build threw an exception: java.lang.RuntimeException: Unable to serialize objects of type class sun.security.provider.DSAPublicKeyImpl to bytecode as it has no default constructor\n"
"\tat io.quarkus.builder.Execution.run(Execution.java:123)\n"
"\tat io.quarkus.builder.BuildExecutionBuilder.execute(BuildExecutionBuilder.java:136)\n"
"\tat io.quarkus.deployment.QuarkusAugmentor.run(QuarkusAugmentor.java:110)\n"
"\tat io.quarkus.runner.RuntimeRunner.run(RuntimeRunner.java:99)\n"
"\t... 36 more\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2759
#, fuzzy
msgid "There is a `io.quarkus.runtime.ObjectSubstitution` interface that can be implemented to tell Quarkus how to handle such classes. An example implementation for the `DSAPublicKey` is shown here:"
msgstr "有一个 `io.quarkus.runtime.ObjectSubstitution` 接口，可以实现它来告诉Quarkus如何处理这样的类。这里显示了一个实现 `DSAPublicKey` 的例子。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2760
#, fuzzy, no-wrap
msgid "DSAPublicKeyObjectSubstitution Example"
msgstr "DSAPublicKeyObjectSubstitution示例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2764
#, no-wrap
msgid "package io.quarkus.extest.runtime.subst;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2771
#, no-wrap
msgid ""
"import java.security.KeyFactory;\n"
"import java.security.NoSuchAlgorithmException;\n"
"import java.security.interfaces.DSAPublicKey;\n"
"import java.security.spec.InvalidKeySpecException;\n"
"import java.security.spec.X509EncodedKeySpec;\n"
"import java.util.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2773
#, no-wrap
msgid "import io.quarkus.runtime.ObjectSubstitution;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2784
#, no-wrap
msgid ""
"public class DSAPublicKeyObjectSubstitution implements ObjectSubstitution<DSAPublicKey, KeyProxy> {\n"
"    private static final Logger log = Logger.getLogger(\"DSAPublicKeyObjectSubstitution\");\n"
"    @Override\n"
"    public KeyProxy serialize(DSAPublicKey obj) { //<1>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.serialize\");\n"
"        byte[] encoded = obj.getEncoded();\n"
"        KeyProxy proxy = new KeyProxy();\n"
"        proxy.setContent(encoded);\n"
"        return proxy;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2794
#, no-wrap
msgid ""
"    @Override\n"
"    public DSAPublicKey deserialize(KeyProxy obj) { //<2>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.deserialize\");\n"
"        byte[] encoded = obj.getContent();\n"
"        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encoded);\n"
"        DSAPublicKey dsaPublicKey = null;\n"
"        try {\n"
"            KeyFactory kf = KeyFactory.getInstance(\"DSA\");\n"
"            dsaPublicKey = (DSAPublicKey) kf.generatePublic(publicKeySpec);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2801
#, no-wrap
msgid ""
"        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return dsaPublicKey;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2803
#, fuzzy
msgid "The serialize method takes the object without a default constructor and creates a `KeyProxy` that contains the information necessary to recreate the `DSAPublicKey`."
msgstr "序列化方法接收没有默认构造函数的对象，并创建一个 `KeyProxy` ，其中包含重新创建 `DSAPublicKey` 的必要信息。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2804
#, fuzzy
msgid "The deserialize method uses the `KeyProxy` to recreate the `DSAPublicKey` from its encoded form using the key factory."
msgstr "解序列化方法使用 `KeyProxy` ，使用密钥工厂从其编码形式重新创建 `DSAPublicKey` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2806
#, fuzzy
msgid "An extension registers this substitution by producing an `ObjectSubstitutionBuildItem` as shown in this `TestProcessor#loadDSAPublicKey` fragment:"
msgstr "一个扩展程序通过产生一个 `ObjectSubstitutionBuildItem` ，来登记这种替换，如这个 `TestProcessor#loadDSAPublicKey` 片段所示。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2807
#, fuzzy, no-wrap
msgid "Registering an Object Substitution"
msgstr "注册一个对象替代物"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2820
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    PublicKeyBuildItem loadDSAPublicKey(TestRecorder recorder,\n"
"            BuildProducer<ObjectSubstitutionBuildItem> substitutions) throws IOException, GeneralSecurityException {\n"
"...\n"
"        // Register how to serialize DSAPublicKey\n"
"        ObjectSubstitutionBuildItem.Holder<DSAPublicKey, KeyProxy> holder = new ObjectSubstitutionBuildItem.Holder(\n"
"                DSAPublicKey.class, KeyProxy.class, DSAPublicKeyObjectSubstitution.class);\n"
"        ObjectSubstitutionBuildItem keysub = new ObjectSubstitutionBuildItem(holder);\n"
"        substitutions.produce(keysub);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2824
#, no-wrap
msgid ""
"        log.info(\"loadDSAPublicKey run\");\n"
"        return new PublicKeyBuildItem(publicKey);\n"
"    }\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2826
#, fuzzy, no-wrap
msgid "Replacing Classes in the Native Image"
msgstr "替换本地图像中的类"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2828
#, fuzzy
msgid "The Graal SDK supports substitutions of classes in the native image. An example of how one could replace the `XmlConfig/XmlData` classes with versions that have no JAXB annotation dependencies is shown in these example classes:"
msgstr "Graal SDK支持对本地图像中的类进行替换。关于如何用没有JAXB注解依赖性的版本来替换 `XmlConfig/XmlData` ，在这些示例类中有一个例子。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2829
#, fuzzy, no-wrap
msgid "Substitution of XmlConfig/XmlData Classes Example"
msgstr "替换XmlConfig/XmlData类的例子"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2837
#, no-wrap
msgid ""
"package io.quarkus.extest.runtime.graal;\n"
"import java.util.Date;\n"
"import com.oracle.svm.core.annotate.Substitute;\n"
"import com.oracle.svm.core.annotate.TargetClass;\n"
"import io.quarkus.extest.runtime.config.XmlData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2841
#, no-wrap
msgid ""
"@TargetClass(XmlConfig.class)\n"
"@Substitute\n"
"public final class Target_XmlConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2848
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String address;\n"
"    @Substitute\n"
"    private int port;\n"
"    @Substitute\n"
"    private ArrayList<XData> dataList;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2853
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getAddress() {\n"
"        return address;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2858
#, no-wrap
msgid ""
"    @Substitute\n"
"    public int getPort() {\n"
"        return port;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2863
#, no-wrap
msgid ""
"    @Substitute\n"
"    public ArrayList<XData> getDataList() {\n"
"        return dataList;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2874
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlConfig{\" +\n"
"                \"address='\" + address + '\\'' +\n"
"                \", port=\" + port +\n"
"                \", dataList=\" + dataList +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2878
#, no-wrap
msgid ""
"@TargetClass(XmlData.class)\n"
"@Substitute\n"
"public final class Target_XmlData {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2885
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String name;\n"
"    @Substitute\n"
"    private String model;\n"
"    @Substitute\n"
"    private Date date;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2890
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2895
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getModel() {\n"
"        return model;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2900
#, no-wrap
msgid ""
"    @Substitute\n"
"    public Date getDate() {\n"
"        return date;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2911
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlData{\" +\n"
"                \"name='\" + name + '\\'' +\n"
"                \", model='\" + model + '\\'' +\n"
"                \", date='\" + date + '\\'' +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:2913
#, fuzzy, no-wrap
msgid "Configuration reference documentation"
msgstr "配置参考文件"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2917
#, fuzzy
msgid "The configuration is an important part of each extension and therefore needs to be properly documented.  Each configuration property should have a proper Javadoc comment."
msgstr "配置是每个扩展的重要部分，因此需要适当地记录下来。每个配置属性都应该有一个适当的Javadoc注释。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2920
#, fuzzy
msgid "While it is handy to have the documentation available when coding, this configuration documentation must also be available in the extension guides.  The Quarkus build automatically generates the configuration documentation for you based on the Javadoc comments but you need to explicitly include it in your guide."
msgstr "虽然在编码时有这些文档是很方便的，但这些配置文档也必须在扩展指南中提供。Quarkus构建会根据Javadoc注释自动为你生成配置文档，但你需要在指南中明确包含它。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2922
#, fuzzy
msgid "In this section, we will explain everything you need to know about the configuration reference documentation."
msgstr "在本节中，我们将解释你需要知道的关于配置参考文件的一切。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2923
#, fuzzy, no-wrap
msgid "Writing the documentation"
msgstr "编写文件"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2926
#, fuzzy
msgid "For each configuration property, you need to write some Javadoc explaining its purpose."
msgstr "对于每个配置属性，你需要写一些Javadoc来解释其用途。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2930
#, fuzzy
msgid "Always make the first sentence meaningful and self-contained as it is included in the summary table."
msgstr "始终使第一句话有意义，并自成一体，因为它包含在汇总表中。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2933
#, fuzzy
msgid "You can either use standard Javadoc comments or Asciidoc directly as a Javadoc comment."
msgstr "你可以使用标准的Javadoc注释或直接使用Asciidoc作为Javadoc注释。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2937
#, fuzzy
msgid "We assume you are familiar with writing Javadoc comments so let's focus on our Asciidoc support.  While standard Javadoc comments are perfectly fine for simple documentation (recommended even), if you want to include tips, source code extracts, lists... Asciidoc comes in handy."
msgstr "我们假设你对编写Javadoc注释很熟悉，所以让我们关注一下我们的Asciidoc支持。虽然标准的Javadoc注释对于简单的文档来说是完全没问题的（甚至是推荐的），但如果你想包括提示、源代码摘录、列表......Asciidoc就很方便了。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2939
#, fuzzy
msgid "Here is a typical configuration property commented with Asciidoc:"
msgstr "下面是一个用Asciidoc注释的典型配置属性。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2956
#, no-wrap
msgid ""
"/**\n"
" * Class name of the Hibernate ORM dialect. The complete list of bundled dialects is available in the\n"
" * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/dialect/package-summary.html[Hibernate ORM JavaDoc].\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Not all the dialects are supported in GraalVM native executables: we currently provide driver extensions for PostgreSQL,\n"
" * MariaDB, Microsoft SQL Server and H2.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"@ConfigItem\n"
"public Optional<String> dialect;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2960
#, fuzzy
msgid "This is the simple case: you just have to write Asciidoc and mark the comment with the `@asciidoclet` tag.  This tag has two purposes: it is used as a marker for our generation tool but it is also used by the `javadoc` process for proper Javadoc generation."
msgstr "这是简单的情况：你只需要写Asciidoc并在注释中标上 `@asciidoclet` 标签。这个标签有两个目的：它被用作我们的生成工具的标记，但它也被 `javadoc` 流程用来正确生成Javadoc。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2962
#, fuzzy
msgid "Now let's consider a more complicated example:"
msgstr "现在我们来考虑一个更复杂的例子。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3000
#, no-wrap
msgid ""
"// @formatter:off\n"
"/**\n"
" * Name of the file containing the SQL statements to execute when Hibernate ORM starts.\n"
" * Its default value differs depending on the Quarkus launch mode:\n"
" *\n"
" * * In dev and test modes, it defaults to `import.sql`.\n"
" *   Simply add an `import.sql` file in the root of your resources directory\n"
" *   and it will be picked up without having to set this property.\n"
" *   Pass `no-file` to force Hibernate ORM to ignore the SQL import file.\n"
" * * In production mode, it defaults to `no-file`.\n"
" *   It means Hibernate ORM won't try to execute any SQL import file by default.\n"
" *   Pass an explicit value to force Hibernate ORM to execute the SQL import file.\n"
" *\n"
" * If you need different SQL statements between dev mode, test (`@QuarkusTest`) and in production, use Quarkus\n"
" * https://quarkus.io/guides/config#configuration-profiles[configuration profiles facility].\n"
" *\n"
" * [source,property]\n"
" * .application.properties\n"
" * ----\n"
" * %dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql\n"
" * %test.quarkus.hibernate-orm.sql-load-script = import-test.sql\n"
" * %prod.quarkus.hibernate-orm.sql-load-script = no-file\n"
" * ----\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Quarkus supports `.sql` file with SQL statements or comments spread over multiple lines.\n"
" * Each SQL statement must be terminated by a semicolon.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"// @formatter:on\n"
"@ConfigItem\n"
"public Optional<String> sqlLoadScript;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3003
#, fuzzy
msgid "A few comments on this one:"
msgstr "对这个问题有几点评论。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3009
#, fuzzy
msgid "Every time you will need the indentation to be respected in the Javadoc comment (think list items spread on multiple lines or indented source code), you will need to disable temporarily the automatic Eclipse formatter (this, even if you don't use Eclipse as the formatter is included in our build).  To do so, use the `// @formatter:off`/`// @formatter:on` markers.  Note the fact that they are separate comments and there is a space after the `//` marker. This is required."
msgstr "每次你需要在Javadoc注释中尊重缩进（想想分布在多行上的列表项或缩进的源代码），你将需要暂时禁用自动的Eclipse格式化器（这一点，即使你不使用Eclipse，因为格式化器包含在我们的构建中）。要做到这一点，请使用 `// @formatter:off` / `// @formatter:on` 标记。请注意，它们是独立的注释，而且在 `//` 标记后面有一个空格。这是必须的。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3010
#, fuzzy
msgid "As you can see, you can use the full power of Asciidoctor (except for the limitation below)"
msgstr "正如你所看到的，你可以使用Asciidoctor的全部功能（除了下面的限制）。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:3015
#, fuzzy
msgid "You cannot use open blocks (`--`) in your Asciidoctor documentation.  All the other types of blocks (source, admonitions...) are supported."
msgstr "你不能在你的Asciidoctor文档中使用开放块( `--` )。所有其他类型的块（源码、训诫...）都支持。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:3022
#, fuzzy
msgid "By default, the doc generator will use the hyphenated field name as the key of a `java.util.Map` configuration item.  To override this default and have a user friendly key (independent of implementation details), you may use the `io.quarkus.runtime.annotations.ConfigDocMapKey` annotation.  See the following example,"
msgstr "默认情况下，文档生成器将使用连字符的字段名作为 `java.util.Map` 配置项的键。为了覆盖这个默认值并拥有一个用户友好的键（独立于实现细节），你可以使用 `io.quarkus.runtime.annotations.ConfigDocMapKey` 注释。请看下面的例子。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3033
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Namespace configuration.\n"
"     */\n"
"    @ConfigItem(name = ConfigItem.PARENT)\n"
"    @ConfigDocMapKey(\"cache-name\") <1>\n"
"    Map<String, CaffeineNamespaceConfig> namespace;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3035
#, fuzzy
msgid "This will generate a configuration map key named `quarkus.some.\"cache-name\"` instead of `quarkus.some.\"namespace\"`."
msgstr "这将产生一个名为 `quarkus.some.\"cache-name\"` 的配置映射键，而不是 `quarkus.some.\"namespace\"` 。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:3037
#, fuzzy, no-wrap
msgid "Writing section documentation"
msgstr "编写章节文件"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:3041
#, fuzzy
msgid "If you wish to generate configuration section of a given `@ConfigGroup`, Quarkus has got you covered with the `@ConfigDocSection` annotation.  See the code example below:"
msgstr "如果你希望生成一个给定的 `@ConfigGroup` 的配置部分，Quarkus已经用 `@ConfigDocSection` 注释为你提供了保障。请看下面的代码例子。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3050
#, no-wrap
msgid ""
"/**\n"
"* Config group related configuration.\n"
"* Amazing introduction here\n"
"*/\n"
"@ConfigItem\n"
"@ConfigDocSection <1>\n"
"public ConfigGroupConfig configGroup;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3054
#, fuzzy
msgid "This will add a section documentation for the `configGroup` config item in the generated documentation.  Section's title and introduction will be derived from the javadoc of the configuration item. The first sentence from the javadoc is considered as the section title and the remaining sentences used as section introduction.  You can also use the `@asciidoclet` tag as shown above."
msgstr "这将在生成的文档中为 `configGroup` 配置项添加一个章节文档。节的标题和介绍将从配置项的javadoc中提取。javadoc中的第一句话被视为章节标题，其余的句子被用作章节介绍。你也可以使用 `@asciidoclet` 标签，如上所示。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:3055
#, fuzzy, no-wrap
msgid "Generating the documentation"
msgstr "生成文件"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3058
#, fuzzy
msgid "Generating the documentation is easy:"
msgstr "生成文件很容易。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3060
#, fuzzy
msgid "Running `./mvnw clean install -DskipTests -DskipITs` will do."
msgstr "运行 `./mvnw clean install -DskipTests -DskipITs` 就可以了。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3061
#, fuzzy
msgid "You can either do it globally or in a specific extension directory (e.g. `extensions/mailer`)."
msgstr "你可以在全局范围内进行，也可以在特定的扩展目录下进行（例如： `extensions/mailer` ）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3063
#, fuzzy
msgid "The documentation is generated in the global `target/asciidoc/generated/config/` located at the root of the project."
msgstr "文档是在位于项目根部的全局 `target/asciidoc/generated/config/` 。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:3064
#, fuzzy, no-wrap
msgid "Including the documentation in the extension guide"
msgstr "包括扩展指南中的文件"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3067
#, fuzzy
msgid "Now that you have generated the configuration reference documentation for your extension, you need to include it in your guide (and review it)."
msgstr "现在你已经为你的扩展生成了配置参考文档，你需要把它纳入你的指南（并审查它）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3069
#, fuzzy
msgid "This is simple, include the generated documentation in your guide:"
msgstr "这很简单，在你的指南中包括生成的文档。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3073
#, no-wrap
msgid "\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3076
#, fuzzy
msgid "If you are interested in including the generated documentation for the config group, you can use the include statement below"
msgstr "如果你对包括生成的配置组的文档感兴趣，你可以使用下面的include语句"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3079
#, no-wrap
msgid "\\include::{generated-dir}/config/hyphenated-config-group-class-name-with-runtime-or-deployment-namespace-replaced-by-config-group-namespace.adoc[opts=optional, leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3082
#, fuzzy
msgid "For example, the `io.quarkus.vertx.http.runtime.FormAuthConfig` configuration group will be generated in a file named `quarkus-vertx-http-config-group-form-auth-config.adoc`."
msgstr "例如， `io.quarkus.vertx.http.runtime.FormAuthConfig` 配置组将在一个名为 `quarkus-vertx-http-config-group-form-auth-config.adoc` 的文件中生成。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3085
#, fuzzy
msgid "A few recommendations:"
msgstr "一些建议。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3087
#, fuzzy
msgid "`opts=optional` is mandatory as we don't want the build to fail if only part of the configuration documentation has been generated"
msgstr " `opts=optional` 是强制性的，因为我们不希望在只生成部分配置文档的情况下构建失败。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3090
#, fuzzy
msgid "The documentation is generated with a title level of 2 (i.e. `==`).  You usually need to adjust it.  It can be done with `leveloffset=+N`."
msgstr "文件生成时的标题级别为2（即 `==` ）。你通常需要调整它。它可以用 `leveloffset=+N` 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3093
#, fuzzy
msgid "It is not recommended to include the whole configuration documentation in the middle of your guide as it's heavy.  If you have an `application.properties` extract with your configuration, just do as follows."
msgstr "不建议在你的指南中间包括整个配置文档，因为它很重。如果你有一个 `application.properties` ，与你的配置一起提取，只需按以下方式进行。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3095
#, fuzzy
msgid "First, include a tip just below your `application.properties` extract:"
msgstr "首先，在你的 `application.properties` ，包括一个提示。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3100
#, no-wrap
msgid ""
"[TIP]\n"
"For more information about the extension configuration please refer to the <<configuration-reference, Configuration Reference>>.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3103
#, fuzzy
msgid "Then, at the end of your documentation, include the extensive documentation:"
msgstr "然后，在你的文件的最后，包括广泛的文件。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3107
#, no-wrap
msgid "[[configuration-reference]]\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3107
#, fuzzy, no-wrap
msgid "Configuration Reference"
msgstr "配置参考"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3110
msgid "\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3113
#, fuzzy
msgid "Finally, generate the documentation and check it out."
msgstr "最后，生成文件并检查。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3115
#, fuzzy, no-wrap
msgid "Continuous testing of your extension"
msgstr "对你的扩展进行持续测试"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3121
#, fuzzy
msgid "In order to make it easy for extension authors to test their extensions daily against the latest snapshot of Quarkus, Quarkus has introduced the notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/main/README.adoc[README] has all the details on how to set up a GitHub Actions job to take advantage of this capability, while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides an overview of what the process looks like."
msgstr "为了方便扩展作者每天根据Quarkus的最新快照测试他们的扩展，Quarkus引入了Ecosystem CI的概念。Ecosystem CI的 link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/main/README.adoc[README] 有关于如何设置GitHub Actions作业以利用这一功能的所有细节，而这个 link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[视频] 提供了一个关于这一过程的概述。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3122
#, fuzzy, no-wrap
msgid "Publish your extension in registry.quarkus.io"
msgstr "在registry.quarkus.io中发布你的扩展。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3125
#, fuzzy
msgid "Before publishing your extension to the xref:tooling.adoc[Quarkus tooling], make sure that the following requirements are met:"
msgstr "在发布你的扩展到 link:tooling.html[Quarkus工具] 之前，请确保满足以下要求。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3127
#, fuzzy
msgid "The `quarkus-extension.yaml` file (in the extension's `runtime/` module) has the minimum metadata set:"
msgstr " `quarkus-extension.yaml` 文件（在扩展的 `runtime/` 模块中）具有最小的元数据集。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3128
#, fuzzy
msgid "`name`"
msgstr " `name` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3129
#, fuzzy
msgid "`description` (unless you have it already set in the ``runtime/pom.xml``'s `<description>` element, which is the recommended approach)"
msgstr " `description` (除非你已经在 元素中设置了它，这是推荐的方法) `runtime/pom.xml’s `<description>` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3131
#, fuzzy
msgid "Your extension is published in Maven Central"
msgstr "您的扩展已在Maven中心发布"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3133
#, fuzzy
msgid "Your extension repository is configured to use the <<ecosystem-ci, Ecosystem CI>>."
msgstr "你的扩展库被配置为使用 link:#ecosystem-ci[Ecosystem CI] 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3135
#, fuzzy
msgid "Then you must create a pull request adding a `your-extension.yaml` file in the `extensions/` directory in the link:https://github.com/quarkusio/quarkus-extension-catalog[Quarkus Extension Catalog]. The YAML must have the following structure:"
msgstr "然后你必须创建一个拉动请求，在 link:https://github.com/quarkusio/quarkus-extension-catalog[Quarkus扩展目录] 的 `extensions/` 目录中添加一个 `your-extension.yaml` 文件。该YAML必须具有以下结构。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3140
#, fuzzy
msgid "```yaml group-id: <YOUR_EXTENSION_RUNTIME_GROUP_ID> artifact-id: <YOUR_EXTENSION_RUNTIME_ARTIFACT_ID> ```"
msgstr " `` "

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3142
msgid "That's all. Once the pull request is merged, a scheduled job will check Maven Central for new versions and update the xref:extension-registry-user.adoc[Quarkus Extension Registry]."
msgstr ""
