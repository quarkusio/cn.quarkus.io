# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-04-26 15:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi-reference.adoc:6
#, fuzzy, no-wrap
msgid "Contexts and Dependency Injection"
msgstr "上下文和依赖性注入"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:18
#, fuzzy
msgid "Quarkus DI solution (also called ArC) is based on the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[Jakarta Contexts and Dependency Injection 4.0, window=\"_blank\"] specification.  It aims to implement the CDI Lite specification, with selected improvements on top.  It is not a CDI Full implementation and is not verified by the TCK yet.  See also xref:supported_features[the list of supported features] and xref:limitations[the list of limitations]."
msgstr "Quarkus DI解决方案（也叫ArC）是基于 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[Java 2.0, target=\"_blank\"] 规范 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[的上下文和依赖注入, target=\"_blank\"] 。然而，它并不是一个经过TCK验证的完整的CDI实现。只实现了CDI功能的一个子集--请参见 link:#supported_features[支持的功能列表] 和 link:#limitations[限制列表] 。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:20
#, fuzzy
msgid "If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] first."
msgstr "如果你是CDI的新手，那么我们建议你先阅读 link:cdi.html[CDI简介] 。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:22
#, fuzzy
msgid "Most of the existing CDI code should work just fine but there are some small differences which follow from the Quarkus architecture and goals."
msgstr "大部分现有的CDI代码应该可以正常工作，但有一些小的差异，这些差异来自Quarkus的架构和目标。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:24
#, fuzzy, no-wrap
msgid "Bean Discovery"
msgstr "豆类的发现"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:29
#, fuzzy
msgid "Bean discovery in CDI is a complex process which involves legacy deployment structures and accessibility requirements of the underlying module architecture.  However, Quarkus is using a *simplified bean discovery*.  There is only single bean archive with the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"] and no visibility boundaries."
msgstr "CDI中的Bean发现是一个复杂的过程，涉及到传统的部署结构和底层模块架构的可访问性要求。然而，Quarkus使用的是 *简化的Bean发现* 。只有单一的Bean存档， link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#default_bean_discovery[Bean发现模式 `annotated`, target=\"_blank\"] ，没有可见性的界限。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:31
#, fuzzy
msgid "The bean archive is synthesized from:"
msgstr "豆类档案是由以下内容合成的。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:33
#, fuzzy
msgid "the application classes,"
msgstr "的应用类。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:34
#, fuzzy
msgid "dependencies that contain a `beans.xml` descriptor (content is ignored),"
msgstr "包含一个 `beans.xml` 描述符的依赖关系（内容被忽略）。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:35
#, fuzzy
msgid "dependencies that contain a Jandex index - `META-INF/jandex.idx`,"
msgstr "包含Jandex索引的依赖性 - `META-INF/jandex.idx` ,"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:36
#, fuzzy
msgid "dependencies referenced by `quarkus.index-dependency` in `application.properties`,"
msgstr " `quarkus.index-dependency` 中引用的依赖性， `application.properties` 。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:37
#, fuzzy
msgid "and Quarkus integration code."
msgstr "和Quarkus集成代码。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:42
#, fuzzy
msgid "Bean classes that don't have a https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are not discovered.  This behavior is defined by CDI.  But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation (this behavior is different to what is defined in CDI).  In fact, the declaring bean classes are considered annotated with `@Dependent`."
msgstr "没有Bean link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[定义注解, target=\"_blank\"] 的Bean类不会被发现。这种行为是由CDI定义的。但是生产者方法和字段以及观察者方法是可以被发现的，即使声明的类没有用Bean定义的注解（这种行为与CDI中定义的不同）。事实上，声明的Bean类被认为是用 `@Dependent` 注释的。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:44
#, fuzzy
msgid "Quarkus extensions may declare additional discovery rules. For example, `@Scheduled` business methods are registered even if the declaring class is not annotated with a bean defining annotation."
msgstr "Quarkus扩展可以声明额外的发现规则。例如， `@Scheduled` 业务方法被注册，即使声明的类没有用Bean定义注解。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:45
#, fuzzy, no-wrap
msgid "How to Generate a Jandex Index"
msgstr "如何生成一个Jandex索引"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:49
#, fuzzy
msgid "A dependency with a Jandex index is automatically scanned for beans.  To generate the index just add the following plugin to your build file:"
msgstr "具有Jandex索引的依赖关系会被自动扫描为豆类。要生成索引，只需将以下内容添加到你的 `pom.xml` :"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:51
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:72
#, no-wrap
msgid ""
"<build>\n"
"  <plugins>\n"
"    <plugin>\n"
"      <groupId>io.smallrye</groupId>\n"
"      <artifactId>jandex-maven-plugin</artifactId>\n"
"      <version>{jandex-version}</version>\n"
"      <executions>\n"
"        <execution>\n"
"          <id>make-index</id>\n"
"          <goals>\n"
"            <goal>jandex</goal>\n"
"          </goals>\n"
"        </execution>\n"
"      </executions>\n"
"    </plugin>\n"
"  </plugins>\n"
"</build>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:76
#, no-wrap
msgid "Gradle (Groovy DSL)"
msgstr "Gradle (Groovy DSL)"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:84
#, no-wrap
msgid ""
"plugins {\n"
"    id 'org.kordamp.gradle.jandex' version '{jandex-gradle-plugin-version}'\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:89
#, no-wrap
msgid "Gradle (Kotlin DSL)"
msgstr "或者，如果您使用Gradle Kotlin DSL。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:97
#, no-wrap
msgid ""
"plugins {\n"
"    id(\"org.kordamp.gradle.jandex\") version '{jandex-gradle-plugin-version}'\n"
"}\n"
msgstr ""

#. type: delimited block *
#: upstream/_guides/cdi-reference.adoc:102
#, fuzzy
msgid "If you can't modify the dependency, you can still index it by adding `quarkus.index-dependency` entries to your `application.properties`:"
msgstr "如果你不能修改依赖关系，你仍然可以通过在你的 `application.properties` ，添加 `quarkus.index-dependency` 条目来索引它。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:108
#, no-wrap
msgid ""
"quarkus.index-dependency.<name>.group-id=\n"
"quarkus.index-dependency.<name>.artifact-id=\n"
"quarkus.index-dependency.<name>.classifier=(this one is optional)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:111
#, fuzzy
msgid "For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:"
msgstr "例如，以下条目确保 `org.acme:acme-api` 依赖关系被编入索引。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:112
#: upstream/_guides/cdi-reference.adoc:137
#: upstream/_guides/cdi-reference.adoc:149
#: upstream/_guides/cdi-reference.adoc:489
#: upstream/_guides/cdi-reference.adoc:673
#, fuzzy, no-wrap
msgid "Example application.properties"
msgstr "示例application.properties"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:117
#, no-wrap
msgid ""
"quarkus.index-dependency.acme.group-id=org.acme <1>\n"
"quarkus.index-dependency.acme.artifact-id=acme-api <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:119
#: upstream/_guides/cdi-reference.adoc:156
#, fuzzy
msgid "Value is a group id for a dependency identified by name `acme`."
msgstr "值是由名称 `acme` 确定的依赖关系的组ID。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:120
#: upstream/_guides/cdi-reference.adoc:157
#, fuzzy
msgid "Value is an artifact id for a dependency identified by name `acme`."
msgstr "值是由名称识别的依赖关系的工件ID `acme` 。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:121
#, fuzzy, no-wrap
msgid "How To Exclude Types and Dependencies from Discovery"
msgstr "如何从发现中排除类型和依赖关系"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:127
#, fuzzy
msgid "It may happen that some beans from third-party libraries do not work correctly in Quarkus.  A typical example is a bean injecting a portable extension.  In such case, it's possible to exclude types and dependencies from the bean discovery.  The `quarkus.arc.exclude-types` property accepts a list of string values that are used to match classes that should be excluded."
msgstr "可能会发生一些来自第三方库的Bean在Quarkus中不能正常工作。一个典型的例子是一个注入了可移植扩展的Bean。在这种情况下，有可能从Bean发现中排除类型和依赖关系。 `quarkus.arc.exclude-types` 属性接受一个字符串值的列表，用来匹配应该被排除的类。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:128
#: upstream/_guides/cdi-reference.adoc:480
#: upstream/_guides/cdi-reference.adoc:664
#, fuzzy, no-wrap
msgid "Value Examples"
msgstr "价值实例"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:130
#: upstream/_guides/cdi-reference.adoc:482
#: upstream/_guides/cdi-reference.adoc:666
#, fuzzy, no-wrap
msgid "Valu"
msgstr "价值"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:131
#: upstream/_guides/cdi-reference.adoc:483
#: upstream/_guides/cdi-reference.adoc:667
#, fuzzy, no-wrap
msgid "Description"
msgstr "描述"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:131
#: upstream/_guides/cdi-reference.adoc:483
#: upstream/_guides/cdi-reference.adoc:667
#, fuzzy, no-wrap
msgid "`org.acme.Foo`"
msgstr " `org.acme.Foo` "

#. type: Table
#: upstream/_guides/cdi-reference.adoc:132
#, fuzzy, no-wrap
msgid "Match the fully qualified name of the class"
msgstr "匹配类的完全合格名称"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:132
#: upstream/_guides/cdi-reference.adoc:484
#: upstream/_guides/cdi-reference.adoc:668
#, fuzzy, no-wrap
msgid "`org.acme.*`"
msgstr " `org.acme.*` "

#. type: Table
#: upstream/_guides/cdi-reference.adoc:133
#, fuzzy, no-wrap
msgid "Match classes with package `org.acme`"
msgstr "匹配类与包 `org.acme` "

#. type: Table
#: upstream/_guides/cdi-reference.adoc:133
#: upstream/_guides/cdi-reference.adoc:485
#: upstream/_guides/cdi-reference.adoc:669
#, fuzzy, no-wrap
msgid "`org.acme.**`"
msgstr " `org.acme.**` "

#. type: Table
#: upstream/_guides/cdi-reference.adoc:134
#, fuzzy, no-wrap
msgid "Match classes where the package starts with `org.acme`"
msgstr "匹配包的开头为 `org.acme` "

#. type: Table
#: upstream/_guides/cdi-reference.adoc:134
#: upstream/_guides/cdi-reference.adoc:486
#: upstream/_guides/cdi-reference.adoc:670
#, fuzzy, no-wrap
msgid "`Bar`"
msgstr " `Bar` "

#. type: Table
#: upstream/_guides/cdi-reference.adoc:135
#, fuzzy, no-wrap
msgid "Match the simple name of the class"
msgstr "匹配类的简单名称"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:141
#, no-wrap
msgid "quarkus.arc.exclude-types=org.acme.Foo,org.acme.*,Bar <1><2><3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:143
#, fuzzy
msgid "Exclude the type `org.acme.Foo`."
msgstr "排除类型 `org.acme.Foo` 。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:144
#, fuzzy
msgid "Exclude all types from the `org.acme` package."
msgstr "从 `org.acme` 包中排除所有类型。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:145
#, fuzzy
msgid "Exclude all types whose simple name is `Bar`"
msgstr "排除所有类型，其简单名称为 `Bar` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:148
#, fuzzy
msgid "It is also possible to exclude a dependency artifact that would be otherwise scanned for beans.  For example, because it contains a `beans.xml` descriptor."
msgstr "也有可能排除一个依赖性工件，否则会被扫描为豆类。例如，因为它包含一个 `beans.xml` 描述符。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:154
#, no-wrap
msgid ""
"quarkus.arc.exclude-dependency.acme.group-id=org.acme <1>\n"
"quarkus.arc.exclude-dependency.acme.artifact-id=acme-services <2>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:158
#, fuzzy, no-wrap
msgid "Native Executables and Private Members"
msgstr "本地可执行文件和私有成员"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:164
#, fuzzy
msgid "Quarkus is using GraalVM to build a native executable.  One of the limitations of GraalVM is the usage of https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/Reflection/[Reflection, window=\"_blank\"].  Reflective operations are supported but all relevant members must be registered for reflection explicitly.  Those registrations result in a bigger native executable."
msgstr "Quarkus正在使用GraalVM来构建一个本地可执行文件。GraalVM的限制之一是 link:https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Limitations.md#reflection[反射, target=\"_blank\"] 的使用。反射操作是被支持的，但所有相关的成员都必须明确注册为反射。这些注册会导致一个更大的本地可执行文件。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:168
#, fuzzy
msgid "And if Quarkus DI needs to access a private member it *has to use reflection*.  That's why Quarkus users are encouraged __not to use private members__ in their beans.  This involves injection fields, constructors and initializers, observer methods, producer methods and fields, disposers and interceptor methods."
msgstr "如果Quarkus DI需要访问一个私有成员，就 *必须使用反射* 。这就是为什么我们鼓励Quarkus用户 _不要_ 在他们的bean中 _使用私有成员_ 。这涉及到注入字段、构造器和初始化器、观察者方法、生产者方法和字段、处置者和拦截者方法。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:171
#, fuzzy
msgid "How to avoid using private members? You can use package-private modifiers:"
msgstr "如何避免使用私有成员？你可以使用包-私有修饰符。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:176
#: upstream/_guides/cdi-reference.adoc:193
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CounterBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:179
#, no-wrap
msgid ""
"    @Inject\n"
"    CounterService counterService; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:183
#, no-wrap
msgid ""
"    void onMessage(@Observes Event msg) { <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:185
#, fuzzy
msgid "A package-private injection field."
msgstr "一个包-私密的注入字段。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:186
#, fuzzy
msgid "A package-private observer method."
msgstr "一个包内私有的观察者方法。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:188
#, fuzzy
msgid "Or constructor injection:"
msgstr "或构造器注入。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:195
#, no-wrap
msgid "    private CounterService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:200
#, no-wrap
msgid ""
"    CounterBean(CounterService service) { <1>\n"
"      this.service = service;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:202
#, fuzzy
msgid "A package-private constructor injection. `@Inject` is optional in this particular case."
msgstr " `@Inject` ，在这种特殊情况下是可选的。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:204
#, fuzzy, no-wrap
msgid "Supported Features"
msgstr "支持的功能"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:207
#, fuzzy
msgid "Programming model"
msgstr "编程模式"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:208
#, fuzzy
msgid "Managed beans implemented by a Java class"
msgstr "由一个Java类实现的管理型豆类"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:209
#, fuzzy
msgid "`@PostConstruct` and `@PreDestroy` lifecycle callbacks"
msgstr " `@PostConstruct` 和 生命周期的回调 `@PreDestroy` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:210
#, fuzzy
msgid "Producer methods and fields, disposers"
msgstr "生产者的方法和领域，处置者"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:211
#, fuzzy
msgid "Qualifiers"
msgstr "资格赛"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:212
#, fuzzy
msgid "Alternatives"
msgstr "替代品"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:213
#, fuzzy
msgid "Stereotypes"
msgstr "陈规定型观念"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:214
#, fuzzy
msgid "Dependency injection and lookup"
msgstr "依赖性注入和查询"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:215
#, fuzzy
msgid "Field, constructor and initializer/setter injection"
msgstr "字段、构造器和初始化器/设置器注入"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:216
#, fuzzy
msgid "Type-safe resolution"
msgstr "类型安全的分辨率"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:217
#, fuzzy
msgid "Programmatic lookup via `jakarta.enterprise.inject.Instance`"
msgstr "程序化查询通过 `javax.enterprise.inject.Instance` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:218
#, fuzzy
msgid "Client proxies"
msgstr "客户端代理"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:219
#, fuzzy
msgid "Injection point metadata"
msgstr "注射点元数据"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:220
msgid "Scopes and contexts; see xref:cdi.adoc#bean-scope-available[here] for details"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:221
#, fuzzy
msgid "Interceptors"
msgstr "拦截器"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:222
#, fuzzy
msgid "Business method interceptors: `@AroundInvoke`"
msgstr "业务方法拦截器。 `@AroundInvoke` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:223
#, fuzzy
msgid "Interceptors for lifecycle event callbacks: `@PostConstruct`, `@PreDestroy`, `@AroundConstruct`"
msgstr "生命周期事件回调的拦截器。 `@PostConstruct` , `@PreDestroy` 。 `@AroundConstruct` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:224
#, fuzzy
msgid "Decorators"
msgstr "装饰公司"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:225
#, fuzzy
msgid "Events and observer methods, including asynchronous events and transactional observer methods"
msgstr "事件和观察者方法，包括异步事件和事务性观察者方法"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:227
#: upstream/_guides/cdi-reference.adoc:737
#, fuzzy, no-wrap
msgid "Limitations"
msgstr "限制条件"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:230
#, fuzzy
msgid "`@ConversationScoped` is not supported"
msgstr " `@ConversationScoped` 不支持"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:231
#, fuzzy
msgid "Portable Extensions are not supported"
msgstr "不支持便携式扩展"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:232
#, fuzzy
msgid "`BeanManager` - only the following methods are implemented: `getBeans()`, `createCreationalContext()`, `getReference()`, `getInjectableReference()` , `resolve()`, `getContext()`, `fireEvent()`, `getEvent()` and `createInstance()`"
msgstr " `BeanManager` - 只实现了以下方法。, , , , , , , 和 `getBeans()` `createCreationalContext()` `getReference()` `getInjectableReference()` `resolve()` `getContext()` `fireEvent()` `getEvent()` `createInstance()` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:233
#, fuzzy
msgid "Specialization is not supported"
msgstr "不支持专门化"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:234
#, fuzzy
msgid "`beans.xml` descriptor content is ignored"
msgstr " `beans.xml` 描述符的内容被忽略"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:235
#, fuzzy
msgid "Passivation and passivating scopes are not supported"
msgstr "不支持钝化和被钝化的范围"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:236
#, fuzzy
msgid "Interceptor methods on superclasses are not implemented yet"
msgstr "超类上的拦截器方法还没有实现"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:237
#, fuzzy
msgid "`@Interceptors` is not supported"
msgstr " `@Interceptors` 不支持"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:238
#, fuzzy
msgid "Decoration of built-in beans, such as `Event`, is not supported"
msgstr "不支持对内置豆类的装饰，如 `Event` ，。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:240
#, fuzzy, no-wrap
msgid "Non-standard Features"
msgstr "非标准功能"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:242
#, fuzzy, no-wrap
msgid "Eager Instantiation of Beans"
msgstr "豆类的急切实例化"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:245
#, fuzzy, no-wrap
msgid "Lazy By Default"
msgstr "默认的懒惰"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:249
#, fuzzy
msgid "By default, CDI beans are created lazily, when needed.  What exactly \"needed\" means depends on the scope of a bean."
msgstr "默认情况下，CDI Bean在需要时被懒散地创建。需要 \"到底是什么意思，取决于Bean的范围。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:251
#, fuzzy
msgid "A *normal scoped bean* (`@ApplicationScoped`, `@RequestScoped`, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification)."
msgstr "当一个方法在一个注入的实例上被调用时（根据规范的上下文引用），需要一个 *正常范围的Bean* （ `@ApplicationScoped` , `@RequestScoped` , 等等）。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:253
#, fuzzy
msgid "In other words, injecting a normal scoped bean will not suffice because a _client proxy_ is injected instead of a contextual instance of the bean."
msgstr "换句话说，注入一个正常范围的Bean是不够的，因为注入的是一个 _客户端代理_ 而不是Bean的上下文实例。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:255
#, fuzzy
msgid "A *bean with a pseudo-scope* (`@Dependent` and `@Singleton` ) is created when injected."
msgstr "当注入时，一个 *具有伪范围的Bean* ( `@Dependent` 和 `@Singleton` ) 被创建。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:256
#, fuzzy, no-wrap
msgid "Lazy Instantiation Example"
msgstr "懒惰实例化实例"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:265
#, no-wrap
msgid ""
"@Singleton // => pseudo-scope\n"
"class AmazingService {\n"
"  String ping() {\n"
"    return \"amazing\";\n"
"  }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:272
#, no-wrap
msgid ""
"@ApplicationScoped // => normal scope\n"
"class CoolService {\n"
"  String ping() {\n"
"    return \"cool\";\n"
"  }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:275
#, no-wrap
msgid ""
"@Path(\"/ping\")\n"
"public class PingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:278
#, no-wrap
msgid ""
"  @Inject\n"
"  AmazingService s1; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:281
#, no-wrap
msgid ""
"  @Inject\n"
"  CoolService s2; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:287
#, no-wrap
msgid ""
"  @GET\n"
"  public String ping() {\n"
"    return s1.ping() + s2.ping(); <3>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:289
#, fuzzy
msgid "Injection triggers the instantiation of `AmazingService`."
msgstr "注入触发了 `AmazingService` 的实例化。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:290
#, fuzzy
msgid "Injection itself does not result in the instantiation of `CoolService`. A client proxy is injected."
msgstr "注入本身并不导致 `CoolService` 。一个客户代理被注入了。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:291
#, fuzzy
msgid "The first invocation upon the injected proxy triggers the instantiation of `CoolService`."
msgstr "对注入的代理的第一次调用触发了 `CoolService` 的实例化。"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:293
#, fuzzy, no-wrap
msgid "Startup Event"
msgstr "初创企业活动"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:296
#, fuzzy
msgid "However, if you really need to instantiate a bean eagerly you can:"
msgstr "然而，如果你真的需要急切地实例化一个bean，你可以。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:298
#, fuzzy
msgid "Declare an observer of the `StartupEvent` - the scope of the bean does not matter in this case:"
msgstr "声明一个 `StartupEvent` 的观察者--在这种情况下，bean的范围并不重要。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:306
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class CoolService {\n"
"  void startup(@Observes StartupEvent event) { <1>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:308
#, fuzzy
msgid "A `CoolService` is created during startup to service the observer method invocation."
msgstr "在启动过程中会创建一个 `CoolService` ，以服务于观察者方法的调用。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:310
#, fuzzy
msgid "Use the bean in an observer of the `StartupEvent` - normal scoped beans must be used as described in xref:lazy_by_default[Lazy By Default]:"
msgstr "在 `StartupEvent` 的观察者中使用Bean - 必须按照 link:#lazy_by_default[[lazy_by_default]] 中的描述使用正常范围的Bean。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:315
#, no-wrap
msgid ""
"@Dependent\n"
"class MyBeanStarter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:320
#, no-wrap
msgid ""
"  void startup(@Observes StartupEvent event, AmazingService amazing, CoolService cool) { <1>\n"
"    cool.toString(); <2>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:322
#, fuzzy
msgid "The `AmazingService` is created during injection."
msgstr " `AmazingService` 是在注射过程中产生的。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:323
#, fuzzy
msgid "The `CoolService` is a normal scoped bean, so we have to invoke a method upon the injected proxy to force the instantiation."
msgstr " `CoolService` 是一个正常范围的bean，所以我们必须在注入的代理上调用一个方法来强制实例化。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:325
#, fuzzy
msgid "Annotate the bean with `@io.quarkus.runtime.Startup` as described in xref:lifecycle.adoc#startup_annotation[Startup annotation]:"
msgstr "按照 link:lifecycle.html#startup_annotation[Startup annotation] 中的描述，用 `@io.quarkus.runtime.Startup` 来注解bean。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:331
#, no-wrap
msgid ""
"@Startup // <1>\n"
"@ApplicationScoped\n"
"public class EagerAppBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:333
#, no-wrap
msgid "   private final String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:338
#, no-wrap
msgid ""
"   EagerAppBean(NameGenerator generator) { // <2>\n"
"     this.name = generator.createName();\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:340
#, fuzzy
msgid "For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used."
msgstr "对于每个用 `@Startup` 注释的Bean，会生成一个 `StartupEvent` 的合成观察者。使用的是默认的优先级。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:341
#, fuzzy
msgid "The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context."
msgstr "当应用程序启动时，Bean构造函数被调用，产生的上下文实例被存储在应用程序上下文中。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:343
#, fuzzy
msgid "Quarkus users are encouraged to always prefer the `@Observes StartupEvent` to `@Initialized(ApplicationScoped.class)` as explained in the xref:lifecycle.adoc[Application Initialization and Termination] guide."
msgstr "我们鼓励Quarkus用户总是首选 `@Observes StartupEvent` ，而不是 `@Initialized(ApplicationScoped.class)` ，这在 link:lifecycle.html[应用程序初始化和终止] 指南中有所解释。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:344
#, fuzzy, no-wrap
msgid "Request Context Lifecycle"
msgstr "请求语境的生命周期"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:347
#, fuzzy
msgid "The request context is also active:"
msgstr "请求环境也是活跃的。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:349
#, fuzzy
msgid "during notification of a synchronous observer method."
msgstr "在同步观察者方法的通知期间。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:351
#, fuzzy
msgid "The request context is destroyed:"
msgstr "请求上下文被销毁。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:353
#, fuzzy
msgid "after the observer notification completes for an event, if it was not already active when the notification started."
msgstr "在事件的观察者通知完成后，如果通知开始时它还没有被激活的话。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:355
#, fuzzy
msgid "An event with qualifier `@Initialized(RequestScoped.class)` is fired when the request context is initialized for an observer notification. Moreover, the events with qualifiers `@BeforeDestroyed(RequestScoped.class)` and `@Destroyed(RequestScoped.class)` are fired when the request context is destroyed."
msgstr "当请求上下文被初始化为观察者通知时，带有限定词 `@Initialized(RequestScoped.class)` 的事件被触发。此外，当请求上下文被销毁时，带有限定词 `@BeforeDestroyed(RequestScoped.class)` 和 `@Destroyed(RequestScoped.class)` 的事件被触发。"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:356
#, fuzzy, no-wrap
msgid "How to Enable Trace Logging for Request Context Activation"
msgstr "如何启用请求上下文激活的跟踪记录"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:359
#, fuzzy
msgid "You can set the `TRACE` level for the logger `io.quarkus.arc.requestContext` and try to analyze the log output afterwards."
msgstr "你可以为记录仪设置 `TRACE` ， `io.quarkus.arc.requestContext` ，之后再尝试分析日志输出。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:360
#, fuzzy, no-wrap
msgid "`application.properties` Example"
msgstr "示例application.properties"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:365
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.arc.requestContext\".min-level=TRACE <1>\n"
"quarkus.log.category.\"io.quarkus.arc.requestContext\".level=TRACE\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:367
#, fuzzy
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "你还需要调整相关类别的最小日志级别。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:368
#, fuzzy, no-wrap
msgid "Qualified Injected Fields"
msgstr "合格的注射场"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:371
#, fuzzy
msgid "In CDI, if you declare a field injection point you need to use `@Inject` and optionally a set of qualifiers."
msgstr "在CDI中，如果你声明一个字段注入点，你需要使用 `@Inject` ，并且可以选择一组限定词。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:377
#: upstream/_guides/cdi-reference.adoc:690
#, no-wrap
msgid ""
"  @Inject\n"
"  @ConfigProperty(name = \"cool\")\n"
"  String coolProperty;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:380
#, fuzzy
msgid "In Quarkus, you can skip the `@Inject` annotation completely if the injected field declares at least one qualifier."
msgstr "在Quarkus中，如果注入的字段至少声明了一个限定词，你可以完全跳过 `@Inject` 注释。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:385
#: upstream/_guides/cdi-reference.adoc:707
#, no-wrap
msgid ""
"  @ConfigProperty(name = \"cool\")\n"
"  String coolProperty;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:388
#, fuzzy
msgid "With the notable exception of one special case discussed below, `@Inject` is still required for constructor and method injection."
msgstr "除了下面讨论的一种特殊情况外， `@Inject` ，构造函数和方法注入仍然需要。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:389
#, fuzzy, no-wrap
msgid "Simplified Constructor Injection"
msgstr "简化的构造函数注入"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:393
#, fuzzy
msgid "In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).  However, this requirement complicates constructor injection - you need to provide a dummy no-args constructor to make things work in CDI."
msgstr "在CDI中，一个正常范围的Bean必须始终声明一个no-args构造函数（这个构造函数通常由编译器生成，除非你声明任何其他构造函数）。然而，这个要求使构造函数注入变得复杂--你需要提供一个假的无args构造函数来使事情在CDI中运作。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:398
#: upstream/_guides/cdi-reference.adoc:418
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyCoolService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:400
#: upstream/_guides/cdi-reference.adoc:420
#, no-wrap
msgid "  private SimpleProcessor processor;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:403
#, no-wrap
msgid ""
"  MyCoolService() { // dummy constructor needed\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:409
#, no-wrap
msgid ""
"  @Inject // constructor injection\n"
"  MyCoolService(SimpleProcessor processor) {\n"
"    this.processor = processor;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:413
#, fuzzy
msgid "There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.  Also, if there's only one constructor there is no need for `@Inject`."
msgstr "在Quarkus中不需要为普通范围的Bean声明虚拟构造函数--它们是自动生成的。另外，如果只有一个构造函数，就不需要 `@Inject` 。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:425
#, no-wrap
msgid ""
"  MyCoolService(SimpleProcessor processor) {\n"
"    this.processor = processor;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:428
#, fuzzy
msgid "We don't generate a no-args constructor automatically if a bean class extends a class that does not declare a no-args constructor."
msgstr "如果一个Bean类扩展了一个没有声明no-args构造函数的类，我们不会自动生成一个no-args构造函数。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:430
#, fuzzy, no-wrap
msgid "Removing Unused Beans"
msgstr "移除未使用的豆子"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:438
#, fuzzy
msgid "The container attempts to remove all unused beans, interceptors and decorators during build by default.  This optimization helps to minimize the amount of generated classes, thus conserving memory.  However, Quarkus can't detect the programmatic lookup performed via the `CDI.current()` static method.  Therefore, it is possible that a removal results in a false positive error, i.e. a bean is removed although it's actually used.  In such cases, you'll notice a big warning in the log.  Users and extension authors have several options xref:eliminate_false_positives[how to eliminate false positives]."
msgstr "容器在构建过程中，默认会尝试删除所有未使用的Bean、拦截器和装饰器。这种优化有助于尽量减少生成的类的数量，从而节约内存。然而，Quarkus无法检测到通过 `CDI.current()` 静态方法进行的程序化查询。因此，删除有可能导致假阳性错误，即一个Bean被删除，尽管它实际上被使用。在这种情况下，你会在日志中看到一个很大的警告。用户和扩展作者有几个选项可以 link:#eliminate_false_positives[消除假阳性] 错误。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:442
#, fuzzy
msgid "The optimization can be disabled by setting `quarkus.arc.remove-unused-beans` to `none` or `false`.  Quarkus also provides a middle ground where application beans are never removed whether or not they are unused, while the optimization proceeds normally for non application classes.  To use this mode, set `quarkus.arc.remove-unused-beans` to `fwk` or `framework`."
msgstr "可以通过将 `quarkus.arc.remove-unused-beans` 设置为 `none` 或 `false` 来禁用该优化。Quarkus还提供了一种中间模式，即无论应用Bean是否未被使用都不会被移除，而对非应用类的优化则正常进行。要使用这种模式，将 `quarkus.arc.remove-unused-beans` 设置为 `fwk` 或 `framework` 。"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:443
#, fuzzy, no-wrap
msgid "What's Removed?"
msgstr "移除的是什么？"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:447
#, fuzzy
msgid "Quarkus first identifies so-called _unremovable_ beans that form the roots in the dependency tree.  A good example is a Jakarta REST resource class or a bean which declares a `@Scheduled` method."
msgstr "Quarkus首先识别了所谓的 _不可移动_ 的Bean，这些Bean构成了依赖树中的根部。一个很好的例子是一个JAX-RS资源类或一个声明了 `@Scheduled` 方法的bean。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:449
#, fuzzy
msgid "An _unremovable_ bean:"
msgstr "一颗 _不_ 可拆卸的豆子。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:451
#, fuzzy
msgid "is excluded from removal by an extension, or"
msgstr "因延期而被排除在清除之外，或"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:452
#, fuzzy
msgid "has a name designated via `@Named`, or"
msgstr "有一个通过 `@Named` 指定的名称，或"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:453
#, fuzzy
msgid "declares an observer method."
msgstr "声明了一个观察者方法。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:455
#, fuzzy
msgid "An _unused_ bean:"
msgstr "一个 _未使用的_ 豆子。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:457
#, fuzzy
msgid "is not _unremovable_, and"
msgstr "并非 _不可移除_ ，而且"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:458
#, fuzzy
msgid "is not eligible for injection to any injection point in the dependency tree, and"
msgstr "没有资格被注入到依赖树中的任何注入点，并且"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:459
#, fuzzy
msgid "does not declare any producer which is eligible for injection to any injection point in the dependency tree, and"
msgstr "没有声明任何有资格被注入到依赖树中任何注入点的生产者，并且"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:460
#, fuzzy
msgid "is not eligible for injection into any `jakarta.enterprise.inject.Instance` or `jakarta.inject.Provider` injection point."
msgstr "没有资格注射到任何 `javax.enterprise.inject.Instance` 或 `javax.inject.Provider` 注射点。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:462
#, fuzzy
msgid "Unused interceptors and decorators are not associated with any bean."
msgstr "未使用的拦截器和装饰器不与任何Bean关联。"

#. type: delimited block =
#: upstream/_guides/cdi-reference.adoc:466
#, fuzzy
msgid "When using the dev mode (running `./mvnw clean compile quarkus:dev`), you can see more information about which beans are being removed:"
msgstr "当使用dev模式（运行 `./mvnw clean compile quarkus:dev` ）时，你可以看到更多关于哪些bean被移除的信息。"

#. type: delimited block =
#: upstream/_guides/cdi-reference.adoc:468
#, fuzzy
msgid "In the console - just enable the DEBUG level in your `application.properties`, i.e. `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG`"
msgstr "在控制台--只要在你的 `application.properties` ，启用DEBUG级别，即 `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` "

#. type: delimited block =
#: upstream/_guides/cdi-reference.adoc:469
#, fuzzy
msgid "In the relevant Dev UI page"
msgstr "在相关的开发用户界面页面中"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:472
#, fuzzy, no-wrap
msgid "How To Eliminate False Positives"
msgstr "如何消除假阳性反应"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:476
#, fuzzy
msgid "Users can instruct the container to not remove any of their specific beans (even if they satisfy all the rules specified above) by annotating them with `@io.quarkus.arc.Unremovable`.  This annotation can be declared on a class, a producer method or field."
msgstr "用户可以通过用 `@io.quarkus.arc.Unremovable` 注释来指示容器不删除他们的任何特定的 bean（即使他们满足上面指定的所有规则）。这种注解可以在类、生产者方法或字段上声明。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:479
#, fuzzy
msgid "Since this is not always possible, there is an option to achieve the same via `application.properties`.  The `quarkus.arc.unremovable-types` property accepts a list of string values that are used to match beans based on their name or package."
msgstr "因为这并不总是可能的，所以有一个选项可以通过 `application.properties` 来实现同样的目的。 `quarkus.arc.unremovable-types` 属性接受一个字符串值的列表，用于根据名字或包来匹配Bean。"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:484
#, fuzzy, no-wrap
msgid "Match the fully qualified name of the bean class"
msgstr "匹配Bean类的完全合格名称"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:485
#: upstream/_guides/cdi-reference.adoc:669
#, fuzzy, no-wrap
msgid "Match beans where the package of the bean class is `org.acme`"
msgstr "匹配豆类的包是什么的豆类 `org.acme` "

#. type: Table
#: upstream/_guides/cdi-reference.adoc:486
#: upstream/_guides/cdi-reference.adoc:670
#, fuzzy, no-wrap
msgid "Match beans where the package of the bean class starts with `org.acme`"
msgstr "匹配豆类的包以\"\"开头的豆类。 `org.acme` "

#. type: Table
#: upstream/_guides/cdi-reference.adoc:487
#, fuzzy, no-wrap
msgid "Match the simple name of the bean class"
msgstr "匹配豆类的简单名称"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:493
#, no-wrap
msgid "quarkus.arc.unremovable-types=org.acme.Foo,org.acme.*,Bar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:496
#, fuzzy
msgid "Furthermore, extensions can eliminate false positives by producing an `UnremovableBeanBuildItem`."
msgstr "此外，扩展可以消除假阳性，产生一个 `UnremovableBeanBuildItem` 。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:498
#, fuzzy, no-wrap
msgid "Default Beans"
msgstr "默认豆类"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:502
#, fuzzy
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally declare a bean if no other bean with equal types and qualifiers was declared by any available means (bean class, producer, synthetic bean, ...)  This is done using the `@io.quarkus.arc.DefaultBean` annotation and is best explained with an example."
msgstr "Quarkus增加了一项CDI目前不支持的能力，即如果没有其他具有相同类型和限定符的bean被任何可用的手段（bean类、生产者、合成bean......）声明，则有条件地声明一个bean。这是用 `@io.quarkus.arc.DefaultBean` 注解完成的，最好用一个例子来解释。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:504
#, fuzzy
msgid "Say there is a Quarkus extension that among other things declares a few CDI beans like the following code does:"
msgstr "假设有一个Quarkus扩展，除此之外还声明了一些CDI Bean，就像下面的代码那样。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:509
#: upstream/_guides/cdi-reference.adoc:563
#: upstream/_guides/cdi-reference.adoc:584
#: upstream/_guides/cdi-reference.adoc:614
#: upstream/_guides/cdi-reference.adoc:637
#, no-wrap
msgid ""
"@Dependent\n"
"public class TracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:514
#, no-wrap
msgid ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:520
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:527
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:532
#, fuzzy
msgid "The idea is that the extension autoconfigures things for the user, eliminating a lot of boilerplate - we can just `@Inject` a `Tracer` wherever it is needed.  Now imagine that in our application we would like to utilize the configured `Tracer`, but we need to customize it a little, for example by providing a custom `Reporter`.  The only thing that would be needed in our application would be something like the following:"
msgstr " `@Inject` 我们的想法是，该扩展为用户自动配置东西，消除大量的模板--我们只需在需要的地方设置一个 `Tracer` 。现在想象一下，在我们的应用程序中，我们想利用配置好的 `Tracer` ，但我们需要对它进行一些定制，例如，提供一个自定义的 `Reporter` 。在我们的应用程序中，唯一需要的是类似以下的东西。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:538
#, no-wrap
msgid ""
"@Dependent\n"
"public class CustomTracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:544
#, no-wrap
msgid ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:548
#, fuzzy
msgid "`@DefaultBean` allows extensions (or any other code for that matter) to provide defaults while backing off if beans of that type are supplied in any way Quarkus supports."
msgstr " `@DefaultBean` 允许扩展（或任何其他代码）提供默认值，同时在该类型的豆子以Quarkus支持的任何方式提供时进行回退。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:550
#, fuzzy, no-wrap
msgid "Enabling Beans for Quarkus Build Profile"
msgstr "启用Quarkus Build Profile的豆类"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:555
#, fuzzy
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time profile is enabled, via the `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc.profile.UnlessBuildProfile` annotations.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, these annotations allow for the creation of different bean configurations for different build profiles."
msgstr "Quarkus增加了一项CDI目前不支持的功能，即通过 `@io.quarkus.arc.profile.IfBuildProfile` 和 `@io.quarkus.arc.profile.UnlessBuildProfile` 注解，在Quarkus构建时间配置文件启用时有条件地启用Bean。当与 `@io.quarkus.arc.DefaultBean` 一起使用时，这些注解允许为不同的构建配置文件创建不同的bean配置。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:558
#, fuzzy
msgid "Imagine for instance that an application contains a bean named `Tracer`, which needs to do nothing when in tests or in dev mode, but works in its normal capacity for the production artifact.  An elegant way to create such beans is the following:"
msgstr "想象一下，例如，一个应用程序包含一个名为 `Tracer` 的bean，它在测试或开发模式下需要什么都不做，但在生产工件中以正常身份工作。创建这种Bean的一个优雅的方法是如下。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:569
#, no-wrap
msgid ""
"    @Produces\n"
"    @IfBuildProfile(\"prod\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:576
#: upstream/_guides/cdi-reference.adoc:597
#: upstream/_guides/cdi-reference.adoc:627
#: upstream/_guides/cdi-reference.adoc:650
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Tracer noopTracer() {\n"
"        return new NoopTracer();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:579
#, fuzzy
msgid "If instead, it is required that the `Tracer` bean also works in dev mode and only default to doing nothing for tests, then `@UnlessBuildProfile` would be ideal. The code would look like:"
msgstr "如果相反，要求 `Tracer` bean也能在开发模式下工作，并且只在测试时默认为不做任何事情，那么 `@UnlessBuildProfile` 将是理想的。代码将看起来像。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:590
#, no-wrap
msgid ""
"    @Produces\n"
"    @UnlessBuildProfile(\"test\") // this will be enabled for both prod and dev build time profiles\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:600
#, fuzzy
msgid "The runtime profile has absolutely no effect on the bean resolution using `@IfBuildProfile` and `@UnlessBuildProfile`."
msgstr "运行时配置文件对使用 `@IfBuildProfile` 和 `@UnlessBuildProfile` 的bean解析完全没有影响。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:602
#, fuzzy, no-wrap
msgid "Enabling Beans for Quarkus Build Properties"
msgstr "为Quarkus构建属性启用豆类"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:607
#, fuzzy
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time property has/has not a specific value, via the `@io.quarkus.arc.properties.IfBuildProperty` and `@io.quarkus.arc.properties.UnlessBuildProperty` annotations.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, this annotation allow for the creation of different bean configurations for different build properties."
msgstr "Quarkus增加了一项CDI目前不支持的功能，即通过 `@io.quarkus.arc.properties.IfBuildProperty` 和 `@io.quarkus.arc.properties.UnlessBuildProperty` 注释，在Quarkus构建时间属性有/无特定值时有条件地启用Bean。当与 `@io.quarkus.arc.DefaultBean` 一起使用时，该注解允许为不同的构建属性创建不同的bean配置。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:609
#, fuzzy
msgid "The scenario we mentioned above with `Tracer` could also be implemented in the following way:"
msgstr "我们上面提到的用 `Tracer` ，也可以用以下方式实现。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:620
#, no-wrap
msgid ""
"    @Produces\n"
"    @IfBuildProperty(name = \"some.tracer.enabled\", stringValue = \"true\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:630
#, fuzzy
msgid "`@IfBuildProperty` and `@UnlessBuildProperty` are repeatable annotations, i.e. a bean will only be enabled if **all** the conditions defined by these annotations are satisfied."
msgstr " `@IfBuildProperty` 和 是可重复的注解，也就是说，只有当这些注解所定义的 `@UnlessBuildProperty` *所有* 条件得到满足时，Bean才会被启用。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:632
#, fuzzy
msgid "If instead, it is required that the `RealTracer` bean is only used if the `some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` would be ideal. The code would look like:"
msgstr "相反，如果要求 `RealTracer` Bean只在 `some.tracer.enabled` 属性不是 `false` 的情况下使用，那么 `@UnlessBuildProperty` 将是最理想的。代码将看起来像。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:643
#, no-wrap
msgid ""
"    @Produces\n"
"    @UnlessBuildProperty(name = \"some.tracer.enabled\", stringValue = \"false\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:653
#, fuzzy
msgid "Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`."
msgstr "在运行时设置的属性对使用 `@IfBuildProperty` 的bean解析绝对没有影响。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:654
#, fuzzy, no-wrap
msgid "Declaring Selected Alternatives"
msgstr "宣布选定的替代品"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:658
#, fuzzy
msgid "In CDI, an alternative bean may be selected either globally for an application by means of `@Priority`, or for a bean archive using a `beans.xml` descriptor.  Quarkus has a simplified bean discovery and the content of `beans.xml` is ignored."
msgstr "在CDI中，可以通过 `@Priority` ，为一个应用程序全局性地选择一个备选Bean，也可以通过 `beans.xml` 描述符为一个Bean存档。Quarkus有一个简化的bean发现， `beans.xml` 的内容被忽略了。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:663
#, fuzzy
msgid "However, it is also possible to select alternatives for an application using the unified configuration.  The `quarkus.arc.selected-alternatives` property accepts a list of string values that are used to match alternative beans.  If any value matches then the priority of `Integer#MAX_VALUE` is used for the relevant bean.  The priority declared via `@Priority` or inherited from a stereotype is overridden."
msgstr "然而，也可以使用统一的配置为一个应用程序选择替代方案。 `quarkus.arc.selected-alternatives` 属性接受一个字符串值的列表，用于匹配备选Bean。如果有任何值匹配，那么 `Integer#MAX_VALUE` 的优先级将用于相关的Bean。通过 `@Priority` 或 `@AlternativePriority` 声明的优先级被覆盖。"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:668
#, fuzzy, no-wrap
msgid "Match the fully qualified name of the bean class or the bean class of the bean that declares the producer"
msgstr "匹配Bean类的完全合格名称或声明生产者的Bean类"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:671
#, fuzzy, no-wrap
msgid "Match the simple name of the bean class or the bean class of the bean that declares the producer"
msgstr "匹配豆类的简单名称或声明生产者的豆类的豆类"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:677
#, no-wrap
msgid "quarkus.arc.selected-alternatives=org.acme.Foo,org.acme.*,Bar\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:679
#, fuzzy, no-wrap
msgid "Simplified Producer Method Declaration"
msgstr "简化生产者方法申报"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:682
#, fuzzy
msgid "In CDI, a producer method must be always annotated with `@Produces`."
msgstr "在CDI中，生产者方法必须总是被注解为 `@Produces` 。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:686
#: upstream/_guides/cdi-reference.adoc:704
#, no-wrap
msgid "class Producers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:697
#, no-wrap
msgid ""
"  @Produces\n"
"  @ApplicationScoped\n"
"  MyService produceService() {\n"
"    return new MyService(coolProperty);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:700
#, fuzzy
msgid "In Quarkus, you can skip the `@Produces` annotation completely if the producer method is annotated with a scope annotation, a stereotype or a qualifier."
msgstr "在Quarkus中，如果生产者方法被注解了范围注解、定型或限定符，你可以完全跳过 `@Produces` 注解。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:713
#, no-wrap
msgid ""
"  @ApplicationScoped\n"
"  MyService produceService() {\n"
"    return new MyService(coolProperty);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:715
#, fuzzy, no-wrap
msgid "Interception of Static Methods"
msgstr "静态方法的拦截"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:721
#, fuzzy
msgid "The Interceptors specification is clear that _around-invoke_ methods must not be declared static.  However, this restriction was driven mostly by technical limitations.  And since Quarkus is a build-time oriented stack that allows for additional class transformations, those limitations don't apply anymore.  It's possible to annotate a non-private static method with an interceptor binding:"
msgstr "拦截器规范中明确规定， _invoke周围的_ 方法不能被声明为静态。然而，这种限制主要是由技术限制所驱动的。而由于Quarkus是一个面向构建时间的堆栈，允许额外的类转换，这些限制不再适用了。我们可以用拦截器绑定来注释一个非私有的静态方法。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:725
#, no-wrap
msgid "class Services {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:733
#, no-wrap
msgid ""
"  @Logged <1>\n"
"  static BigDecimal computePrice(long amount) { <2>\n"
"    BigDecimal price;\n"
"    // Perform computations...\n"
"    return price;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:735
#, fuzzy
msgid "`Logged` is an interceptor binding."
msgstr " `Logged` 是一个拦截器绑定。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:736
#, fuzzy
msgid "Each method invocation is intercepted if there is an interceptor associated with `Logged`."
msgstr "如果有一个与 `Logged` 相关的拦截器，每个方法的调用都会被拦截。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:740
#, fuzzy
msgid "Only *method-level bindings* are considered for backward compatibility reasons (otherwise static methods of bean classes that declare class-level bindings would be suddenly intercepted)"
msgstr "出于向后兼容的原因，只考虑 *方法级绑定* （否则声明类级绑定的bean类的静态方法会突然被拦截）。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:741
#, fuzzy
msgid "Private static methods are never intercepted"
msgstr "私有静态方法从不被拦截"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:742
#, fuzzy
msgid "`InvocationContext#getTarget()` returns `null` for obvious reasons; therefore not all existing interceptors may behave correctly when intercepting static methods"
msgstr " `InvocationContext#getTarget()` 返回 ，原因显而易见；因此，并不是所有现有的拦截器在拦截静态方法时都会表现得正确。 `null` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:744
#, fuzzy
msgid "Interceptors can use `InvocationContext.getMethod()` to detect static methods and adjust the behavior accordingly."
msgstr "拦截器可以使用 `InvocationContext.getMethod()` 来检测静态方法并相应地调整行为。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:746
#, fuzzy, no-wrap
msgid "Ability to handle 'final' classes and methods"
msgstr "有能力处理 \"最终 \"类和方法"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:751
#, fuzzy
msgid "In normal CDI, classes that are marked as `final` and / or have `final` methods are not eligible for proxy creation, which in turn means that interceptors and normal scoped beans don't work properly.  This situation is very common when trying to use CDI with alternative JVM languages like Kotlin where classes and methods are `final` by default."
msgstr "在正常的CDI中，被标记为 `final` 和/或有 `final` 方法的类没有资格进行代理创建，这反过来意味着拦截器和正常范围的Bean不能正常工作。这种情况在试图将CDI与其他JVM语言（如Kotlin）一起使用时非常常见，因为Kotlin的类和方法默认是 `final` 。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:753
#, fuzzy
msgid "Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value)."
msgstr " `true` 然而，当 `quarkus.arc.transform-unproxyable-classes` （这是默认值）时，Quarkus可以克服这些限制。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:754
#, fuzzy, no-wrap
msgid "Container-managed Concurrency"
msgstr "容器管理的并发性"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:762
#, fuzzy
msgid "There is no standard concurrency control mechanism for CDI beans.  Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.  In that case it should be thread-safe.  You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access.  Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for this interceptor binding.  Each interceptor instance associated with a contextual instance of an intercepted bean holds a separate `ReadWriteLock` with non-fair ordering policy."
msgstr "CDI Bean没有标准的并发控制机制。尽管如此，一个Bean实例可以被共享，并从多个线程中并发访问。在这种情况下，它应该是线程安全的。你可以使用标准的Java结构（ `volatile` , `synchronized` , `ReadWriteLock` 等）或者让容器控制并发访问。Quarkus为这种拦截器绑定提供了 `@io.quarkus.arc.Lock` 和一个内置的拦截器。与被拦截Bean的上下文实例相关联的每个拦截器实例都持有一个单独的 `ReadWriteLock` ，具有非公平排序策略。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:764
#, fuzzy
msgid "`io.quarkus.arc.Lock` is a regular interceptor binding and as such can be used for any bean with any scope. However, it is especially useful for \"shared\" scopes, e.g. `@Singleton` and `@ApplicationScoped`."
msgstr " `io.quarkus.arc.Lock` 是一个常规的拦截器绑定，因此可以用于任何作用域的bean。然而，它对 \"共享 \"作用域特别有用，例如： 和 。 `@Singleton` `@ApplicationScoped` "

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:765
#, fuzzy, no-wrap
msgid "Container-managed Concurrency Example"
msgstr "容器管理的并发性实例"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:769
#, no-wrap
msgid "import io.quarkus.arc.Lock;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:773
#, no-wrap
msgid ""
"@Lock <1>\n"
"@ApplicationScoped\n"
"class SharedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:777
#, no-wrap
msgid ""
"  void addAmount(BigDecimal amount) {\n"
"    // ...changes some internal state of the bean\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:783
#, no-wrap
msgid ""
"  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) <2> <3>\n"
"  BigDecimal getAmount() {\n"
"    // ...it is safe to read the value concurrently\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:785
#, fuzzy
msgid "`@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has \"exclusive access\" and no concurrent invocations will be allowed."
msgstr " `@Lock` (映射到 )声明的类指示容器为任何业务方法的任何调用锁定Bean实例，也就是说，客户有 \"排他性访问\"，不允许并发调用。 `@Lock(Lock.Type.WRITE)` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:786
#, fuzzy
msgid "`@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`."
msgstr " `@Lock(Lock.Type.READ)` 覆盖了在类级别指定的值。这意味着任何数量的客户端都可以并发地调用该方法，除非Bean实例被 锁定。 `@Lock(Lock.Type.WRITE)` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:787
#, fuzzy
msgid "You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown."
msgstr "你也可以指定 \"等待时间\"。如果在给定的时间内不可能获得锁，就会抛出一个 `LockException` 。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:788
#, fuzzy, no-wrap
msgid "Repeatable interceptor bindings"
msgstr "可重复的拦截器绑定"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:791
#, fuzzy
msgid "Quarkus has limited support for `@Repeatable` interceptor binding annotations."
msgstr "Quarkus对 `@Repeatable` 拦截器绑定注释的支持有限。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:795
#, fuzzy
msgid "When binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.  Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.  This might be added in the future."
msgstr "当把拦截器绑定到一个组件时，你可以在方法上声明多个 `@Repeatable` 注释。不支持在类和定型上声明的可重复的拦截器绑定，因为围绕着与拦截器规范的交互还有一些开放性问题。这在未来可能会被加入。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:799
#, fuzzy
msgid "As an example, suppose we have an interceptor that clears a cache.  The corresponding interceptor binding would be called `@CacheInvalidateAll` and would be declared as `@Repeatable`.  If we wanted to clear two caches at the same time, we would add `@CacheInvalidateAll` twice:"
msgstr "作为一个例子，假设我们有一个清除缓存的拦截器。相应的拦截器绑定将被称为 `@CacheInvalidateAll` ，并被声明为 `@Repeatable` 。如果我们想同时清除两个缓存，我们会添加两次 `@CacheInvalidateAll` 。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:813
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class CachingService {\n"
"  @CacheInvalidateAll(cacheName = \"foo\")\n"
"  @CacheInvalidateAll(cacheName = \"bar\")\n"
"  void heavyComputation() {\n"
"    // ...\n"
"    // some computation that updates a lot of data\n"
"    // and requires 2 caches to be invalidated\n"
"    // ...\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:817
#, fuzzy
msgid "This is how interceptors are used.  What about creating an interceptor?"
msgstr "这就是拦截器的使用方法。创建一个拦截器呢？"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:820
#, fuzzy
msgid "When declaring interceptor bindings of an interceptor, you can add multiple `@Repeatable` annotations to the interceptor class as usual.  This is useless when the annotation members are `@Nonbinding`, as would be the case for the `@Cached` annotation, but is important otherwise."
msgstr "在声明拦截器绑定的时候，你可以像往常一样给拦截器类添加多个 `@Repeatable` 注解。当注解成员是 `@Nonbinding` ，这一点是无用的，就像 `@Cached` 注解的情况一样，但在其他情况下是很重要的。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:824
#, fuzzy
msgid "For example, suppose we have an interceptor that can automatically log method invocations to certain targets.  The interceptor binding annotation `@Logged` would have a member called `target`, which specifies where to store the log.  Our implementation could be restricted to console logging and file logging:"
msgstr "例如，假设我们有一个拦截器，可以自动记录对某些目标的方法调用。拦截器的绑定注解 `@Logged` ，它将有一个名为 `target` 的成员，指定了存储日志的位置。我们的实现可以限制在控制台日志和文件日志上。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:833
#, no-wrap
msgid ""
"@Interceptor\n"
"@Logged(target = \"console\")\n"
"@Logged(target = \"file\")\n"
"class NaiveLoggingInterceptor {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:836
#, fuzzy
msgid "Other interceptors could be provided to log method invocations to different targets."
msgstr "可以提供其他拦截器来记录对不同目标的方法调用。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:837
#, fuzzy, no-wrap
msgid "Caching the Result of Programmatic Lookup"
msgstr "缓存程序化查询的结果"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:847
#, fuzzy
msgid "In certain situations, it is practical to obtain a bean instance programmatically via an injected `jakarta.enterprise.inject.Instance` and `Instance.get()`.  However, according to the specification the `get()` method must identify the matching bean and obtain a contextual reference.  As a consequence, a new instance of a `@Dependent` bean is returned from each invocation of `get()`.  Moreover, this instance is a dependent object of the injected `Instance`.  This behavior is well-defined, but it may lead to unexpected errors and memory leaks.  Therefore, Quarkus comes with the `io.quarkus.arc.WithCaching` annotation.  An injected `Instance` annotated with this annotation will cache the result of the `Instance#get()` operation.  The result is computed on the first call and the same value is returned for all subsequent calls, even for `@Dependent` beans."
msgstr "在某些情况下，通过注入的 `javax.enterprise.inject.Instance` 和 `Instance.get()` 以编程方式获得 bean 实例是可行的。然而，根据规范， `get()` 方法必须识别匹配的 bean 并获得上下文引用。因此，每次调用 `get()` 都会返回一个新的 `@Dependent` Bean 实例。此外，这个实例是注入的 `Instance` 的一个依赖对象。这种行为被很好地定义了，但它可能会导致意外的错误和内存泄漏。因此，Quarkus附带了 `io.quarkus.arc.WithCaching` 注解。被注入的 `Instance` 注释了这个注解，将缓存 `Instance#get()` 操作的结果。这个结果在第一次调用时就被计算出来，并且在所有后续的调用中都返回相同的值，甚至对于 `@Dependent` beans。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:851
#, no-wrap
msgid "class Producer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:854
#, no-wrap
msgid ""
"  AtomicLong nextLong = new AtomicLong();\n"
"  AtomicInteger nextInt = new AtomicInteger();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:860
#, no-wrap
msgid ""
"   @Dependent\n"
"   @Produces\n"
"   Integer produceInt() {\n"
"     return nextInt.incrementAndGet();\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:867
#, no-wrap
msgid ""
"   @Dependent\n"
"   @Produces\n"
"   Long produceLong() {\n"
"     return nextLong.incrementAndGet();\n"
"   }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:869
#, no-wrap
msgid "class Consumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:872
#, no-wrap
msgid ""
"  @Inject\n"
"  Instance<Long> longInstance;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:876
#, no-wrap
msgid ""
"  @Inject\n"
"  @WithCaching\n"
"  Instance<Integer> intInstance;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:882
#, no-wrap
msgid ""
"  // this method should always return true\n"
"  // Producer#produceInt() is only called once\n"
"  boolean pingInt() {\n"
"    return intInstance.get().equals(intInstance.get());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:889
#, no-wrap
msgid ""
"  // this method should always return false\n"
"  // Producer#produceLong() is called twice per each pingLong() invocation\n"
"  boolean pingLong() {\n"
"    return longInstance.get().equals(longInstance.get());\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:892
#, fuzzy
msgid "It is also possible to clear the cached value via `io.quarkus.arc.InjectableInstance.clearCache()`. In this case, you'll need to inject the Quarkus-specific `io.quarkus.arc.InjectableInstance` instead of `jakarta.enterprise.inject.Instance`."
msgstr "也可以通过 `io.quarkus.arc.InjectableInstance.clearCache()` 来清除缓存的值。在这种情况下，你需要注入Quarkus专用的 `io.quarkus.arc.InjectableInstance` ，而不是 `javax.enterprise.inject.Instance` 。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:893
#, fuzzy, no-wrap
msgid "Declaratively Choose Beans That Can Be Obtained by Programmatic Lookup"
msgstr "声明性地选择可通过程序化查询获得的豆类"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:897
#, fuzzy
msgid "It is sometimes useful to narrow down the set of beans that can be obtained by programmatic lookup via `jakarta.enterprise.inject.Instance`.  Typically, a user needs to choose the appropriate implementation of an interface based on a runtime configuration property."
msgstr "有时，通过 `javax.enterprise.inject.Instance` ，缩小可以通过编程查询获得的Bean集合是很有用的。通常情况下，用户需要根据运行时的配置属性来选择一个接口的适当实现。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:904
#, fuzzy
msgid "Imagine that we have two beans implementing the interface `org.acme.Service`.  You can't inject the `org.acme.Service` directly unless your implementations declare a CDI qualifier.  However, you can inject the `Instance<Service>` instead, then iterate over all implementations and choose the correct one manually.  Alternatively, you can use the `@LookupIfProperty` and `@LookupUnlessProperty` annotations.  `@LookupIfProperty` indicates that a bean should only be obtained if a runtime configuration property matches the provided value.  `@LookupUnlessProperty`, on the other hand, indicates that a bean should only be obtained if a runtime configuration property does not match the provided value."
msgstr "想象一下，我们有两个bean实现了接口 `org.acme.Service` 。你不能直接注入 `org.acme.Service` ，除非你的实现声明了一个CDI限定词。然而，你可以注入 `Instance<Service>` ，然后遍历所有的实现，并手动选择正确的一个。另外，你可以使用 `@LookupIfProperty` 和 `@LookupUnlessProperty` 注解。 `@LookupIfProperty` 表示只有在运行时配置属性与所提供的值相匹配时，才可以获得一个bean。 `@LookupUnlessProperty` 另一方面，表示只有在运行时配置属性与所提供的值不匹配的情况下才可以获得Bean。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:905
#, fuzzy, no-wrap
msgid "`@LookupIfProperty` Example"
msgstr " `@LookupIfProperty` 例子"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:911
#, no-wrap
msgid ""
" interface Service {\n"
"    String name();\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:915
#, no-wrap
msgid ""
" @LookupIfProperty(name = \"service.foo.enabled\", stringValue = \"true\")\n"
" @ApplicationScoped\n"
" class ServiceFoo implements Service {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:920
#, no-wrap
msgid ""
"    public String name() {\n"
"       return \"foo\";\n"
"    }\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:923
#, no-wrap
msgid ""
" @ApplicationScoped\n"
" class ServiceBar implements Service {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:928
#, no-wrap
msgid ""
"    public String name() {\n"
"       return \"bar\";\n"
"    }\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:931
#, no-wrap
msgid ""
" @ApplicationScoped\n"
" class Client {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:934
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<Service> service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:941
#, no-wrap
msgid ""
"    void printServiceName() {\n"
"       // This will print \"bar\" if the property \"service.foo.enabled\" is NOT set to \"true\"\n"
"       // If \"service.foo.enabled\" is set to \"true\" then service.get() would result in an AmbiguousResolutionException\n"
"       System.out.println(service.get().name());\n"
"    }\n"
" }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:943
#, fuzzy, no-wrap
msgid "Injecting Multiple Bean Instances Intuitively"
msgstr "直观地注入多个Bean实例"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:949
#, fuzzy
msgid "In CDI, it's possible to inject multiple bean instances (aka contextual references) via the `jakarta.enterprise.inject.Instance` which implements `java.lang.Iterable`.  However, it's not exactly intuitive.  Therefore, a new way was introduced in Quarkus - you can inject a `java.util.List` annotated with the `io.quarkus.arc.All` qualifier.  The type of elements in the list is used as the required type when performing the lookup."
msgstr " `java.lang.Iterable` 在CDI中，可以通过实现 `javax.enterprise.inject.Instance` ，注入多个bean实例（又称上下文引用）。然而，这并不是很直观。因此，在Quarkus中引入了一种新的方式--你可以注入一个用 `io.quarkus.arc.All` 修饰符注释的 `java.util.List` 。在执行查找时，列表中的元素类型被用作所需类型。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:954
#: upstream/_guides/cdi-reference.adoc:974
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Processor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:959
#, no-wrap
msgid ""
"     @Inject\n"
"     @All\n"
"     List<Service> services; <1> <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:961
#, fuzzy
msgid "The injected instance is an _immutable list_ of the contextual references of the _disambiguated_ beans."
msgstr "注入的实例是一个 _不可变的列表_ ，其中包含了 _被消除歧义的_ Bean的上下文引用。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:962
#, fuzzy
msgid "For this injection point the required type is `Service` and no additional qualifiers are declared."
msgstr "对于这个注入点，所需的类型是 `Service` ，没有声明额外的限定符。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:964
#, fuzzy
msgid "The list is sorted by priority as defined by `io.quarkus.arc.InjectableBean#getPriority()`. Higher priority goes first. In general, the `@jakarta.annotation.Priority` and `@io.quarkus.arc.Priority` annotations can be used to assign the priority to a class bean, producer method or producer field."
msgstr "列表按照 `io.quarkus.arc.InjectableBean#getPriority()` 所定义的优先级进行排序。优先级越高越好。一般来说， `@javax.annotation.Priority` 和 `@io.quarkus.arc.Priority` 注解可以用来给类豆、生产者方法或生产者字段分配优先级。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:966
#, fuzzy
msgid "If an injection point declares no other qualifier than `@All` then `@Any` is used, i.e. the behavior is equivalent to `@Inject @Any Instance<Service>`."
msgstr "如果一个注入点除了 `@All` ，没有声明其他限定词，那么就使用 `@Any` ，即行为等同于 `@Inject @Any Instance<Service>` 。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:969
#, fuzzy
msgid "You can also inject a list of bean instances wrapped in `io.quarkus.arc.InstanceHandle`.  This can be useful if you need to inspect the related bean metadata."
msgstr "你也可以注入一个用 `io.quarkus.arc.InstanceHandle` 包装的Bean实例列表。如果你需要检查相关的Bean元数据，这可能很有用。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:978
#, no-wrap
msgid ""
"     @Inject\n"
"     @All\n"
"     List<InstanceHandle<Service>> services;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:988
#, no-wrap
msgid ""
"     public void doSomething() {\n"
"       for (InstanceHandle<Service> handle : services) {\n"
"         if (handle.getBean().getScope().equals(Dependent.class)) {\n"
"           handle.get().process();\n"
"           break;\n"
"         }\n"
"       }\n"
"     }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:991
#, fuzzy
msgid "Neither a type variable nor a wildcard is a legal type parameter for an `@All List<>` injection point, i.e. `@Inject @All List<?> all` is not supported and results in a deployment error."
msgstr "类型变量和通配符都不是 `@All List<>` 注入点的合法类型参数，即不支持 `@Inject @All List<?> all` ，导致部署错误。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:993
#, fuzzy
msgid "It is also possible to obtain the list of all bean instance handles programmatically via the `Arc.container().listAll()` methods."
msgstr "也可以通过 `Arc.container().listAll()` 方法以编程方式获得所有bean实例柄的列表。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:994
#, fuzzy, no-wrap
msgid "Ignoring Class-Level Interceptor Bindings for Methods and Constructors"
msgstr "忽略方法和构造器的类级拦截器绑定"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:998
#, fuzzy
msgid "If a managed bean declares interceptor binding annotations on the class level, the corresponding `@AroundInvoke` interceptors will apply to all business methods.  Similarly, the corresponding `@AroundConstruct` interceptors will apply to the bean constructor."
msgstr "如果一个托管Bean在类级别上声明了拦截器绑定注释，那么相应的 `@AroundInvoke` 拦截器将适用于所有业务方法。同样地，相应的 `@AroundConstruct` 拦截器将适用于Bean构造函数。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1000
#, fuzzy
msgid "For example, suppose we have a logging interceptor with the `@Logged` binding annotation and a tracing interceptor with the `@Traced` binding annotation:"
msgstr "例如，假设我们有一个带有 `@Logged` 绑定注释的日志拦截器和一个带有 `@Traced` 绑定注释的追踪拦截器。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1009
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Logged\n"
"public class MyService {\n"
"    public void doSomething() {\n"
"        ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1015
#, no-wrap
msgid ""
"    @Traced\n"
"    public void doSomethingElse() {\n"
"        ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1019
#, fuzzy
msgid "In this example, both `doSomething` and `doSomethingElse` will be intercepted by the hypothetical logging interceptor.  Additionally, the `doSomethingElse` method will be intercepted by the hypothetical tracing interceptor."
msgstr "在这个例子中， `doSomething` 和 `doSomethingElse` 都会被假想的日志拦截器拦截。此外， `doSomethingElse` 方法将被假设的追踪拦截器拦截。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1022
#, fuzzy
msgid "Now, if that `@Traced` interceptor also performed all the necessary logging, we'd like to skip the `@Logged` interceptor for this method, but keep it for all other methods.  To achieve that, you can annotate the method with `@NoClassInterceptors`:"
msgstr "现在，如果那个 `@Traced` 拦截器也进行了所有必要的记录，我们希望在这个方法中跳过 `@Logged` 拦截器，但在所有其他方法中保留它。为了达到这个目的，你可以用 `@NoClassInterceptors` 来注解这个方法。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1030
#, no-wrap
msgid ""
"@Traced\n"
"@NoClassInterceptors\n"
"public void doSomethingElse() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1034
#, fuzzy
msgid "The `@NoClassInterceptors` annotation may be put on methods and constructors and means that all class-level interceptors are ignored for these methods and constructors.  In other words, if a method/constructor is annotated `@NoClassInterceptors`, then the only interceptors that will apply to this method/constructor are interceptors declared directly on the method/constructor."
msgstr " `@NoClassInterceptors` 注解可以放在方法和构造函数上，意味着所有类级拦截器对这些方法和构造函数都是忽略的。换句话说，如果一个方法/构造函数被注解为 `@NoClassInterceptors` ，那么适用于这个方法/构造函数的唯一拦截器就是直接在这个方法/构造函数上声明的拦截器。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1036
#, fuzzy
msgid "This annotation affects only business method interceptors (`@AroundInvoke`) and constructor lifecycle callback interceptors (`@AroundConstruct`)."
msgstr "这个注解只影响业务方法拦截器 ( `@AroundInvoke` ) 和构造函数生命周期回调拦截器 ( `@AroundConstruct` )。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:1037
#, fuzzy, no-wrap
msgid "Exceptions Thrown By An Asynchronous Observer Method"
msgstr "异步观察者方法抛出的异常情况"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1044
#, fuzzy
msgid "If an exception is thrown by an asynchronous observer then the `CompletionStage` returned by the `fireAsync()` method completes exceptionally so that the event producer may react appropriately.  However, if the event producer does not care then the exception is ignored silently.  Therefore, Quarkus logs an error message by default.  It is also possible to implement a custom `AsyncObserverExceptionHandler`.  A bean that implements this interface should be `@jakarta.inject.Singleton` or `@jakarta.enterprise.context.ApplicationScoped`."
msgstr "如果一个异步观察者抛出了一个异常，那么由 `fireAsync()` 方法返回的 `CompletionStage` 会例外地完成，这样事件生产者就可以做出适当的反应。然而，如果事件生产者不关心，那么这个异常就会被无声地忽略。因此，Quarkus默认会记录一条错误信息。也可以实现一个自定义的 `AsyncObserverExceptionHandler` 。实现这个接口的Bean应该是 `@javax.inject.Singleton` 或 `@javax.enterprise.context.ApplicationScoped` 。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:1045
#, fuzzy, no-wrap
msgid "`NoopAsyncObserverExceptionHandler`"
msgstr " `NoopAsyncObserverExceptionHandler` "

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1050
#, no-wrap
msgid ""
"@Singleton\n"
"public class NoopAsyncObserverExceptionHandler implements AsyncObserverExceptionHandler {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1054
#, no-wrap
msgid ""
"  void handle(Throwable throwable, ObserverMethod<?> observerMethod, EventContext<?> eventContext) {\n"
"    // do nothing\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1056
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:1059
#, fuzzy, no-wrap
msgid "Build Time Extensions"
msgstr "延长建造时间"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1065
#, fuzzy
msgid "Quarkus incorporates build-time optimizations in order to provide instant startup and low memory footprint.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, most of the functionality can be achieved using Quarkus xref:writing-extensions.adoc[extensions].  See the xref:cdi-integration.adoc[integration guide] for more information."
msgstr "Quarkus结合了构建时的优化，以提供即时启动和低内存占用。这种方法的缺点是不能支持CDI便携扩展。尽管如此，大部分的功能还是可以通过Quarkus link:writing-extensions.html[扩展] 来实现。更多信息请参见 link:cdi-integration.html[集成指南] 。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:1066
#, fuzzy, no-wrap
msgid "Development Mode"
msgstr "发展模式"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1069
#, fuzzy
msgid "In the development mode, two special endpoints are registered automatically to provide some basic debug info in the JSON format:"
msgstr "在开发模式下，两个特殊的端点被自动注册，以提供一些JSON格式的基本调试信息。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1071
#, fuzzy
msgid "HTTP GET `/q/arc` - returns the summary; number of beans, config properties, etc."
msgstr "HTTP GET `/q/arc` - 返回摘要；豆的数量、配置属性等。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1072
#, fuzzy
msgid "HTTP GET `/q/arc/beans` - returns the list of all beans"
msgstr "HTTP GET `/q/arc/beans` - 返回所有豆子的列表"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1073
#, fuzzy
msgid "You can use query params to filter the output:"
msgstr "你可以使用查询参数来过滤输出。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1074
#, fuzzy
msgid "`scope` - include beans with scope that ends with the given value, i.e. `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`"
msgstr " `scope` - 包括具有以给定值结束的范围的豆子，即 `<a href=\"http://localhost:8080/q/arc/beans?scope=ApplicationScoped\" class=\"bare\">http://localhost:8080/q/arc/beans?scope=ApplicationScoped</a>` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1075
#, fuzzy
msgid "`beanClass` - include beans with bean class that starts with the given value, i.e. `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`"
msgstr " `beanClass` - 包括具有以给定值开头的豆类的豆子，即 `<a href=\"http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo\" class=\"bare\">http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo</a>` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1076
#, fuzzy
msgid "`kind` - include beans of the specified kind (`CLASS`, `PRODUCER_FIELD`, `PRODUCER_METHOD`, `INTERCEPTOR` or `SYNTHETIC`), i.e. `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`"
msgstr " `kind` - 包括指定种类的豆子（ , , , 或 ），即 `CLASS` `PRODUCER_FIELD` `PRODUCER_METHOD` `INTERCEPTOR` `SYNTHETIC` `<a href=\"http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD\" class=\"bare\">http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD</a>` "

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1077
#, fuzzy
msgid "HTTP GET `/q/arc/removed-beans` - returns the list of unused beans removed during build"
msgstr "HTTP GET `/q/arc/removed-beans` - 返回在构建过程中移除的未使用的Bean列表。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1078
msgid "HTTP GET `/q/arc/observers` - returns the list of all observer methods"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1080
msgid "These endpoints are only available in the development mode, i.e. when you run your application via `mvn quarkus:dev` (or `./gradlew quarkusDev`)."
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:1081
#, no-wrap
msgid "Monitoring Business Method Invocations and Events"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1085
msgid "In the development mode, it is also possible to enable monitoring of business method invocations and fired events.  Simply set the `quarkus.arc.dev-mode.monitoring-enabled` configuration property to `true` and explore the relevant Dev UI pages."
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:1087
#, no-wrap
msgid "Strict Mode"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1091
msgid "By default, ArC does not perform all validations required by the CDI specification.  It also improves CDI usability in many ways, some of them being directly against the specification."
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1094
msgid "To be able to eventually pass the CDI Lite TCK, ArC also has a _strict_ mode.  This mode enables additional validations and disables certain improvements that conflict with the specification."
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1096
msgid "To enable the strict mode, use the following configuration:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1100
#, no-wrap
msgid "quarkus.arc.strict-compatibility=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1103
msgid "Some other features affect specification compatibility as well:"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1105
msgid "xref:unproxyable_classes_transformation[Transformation of unproxyable classes]"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1106
msgid "xref:remove_unused_beans[Unused beans removal]"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1108
msgid "To get a behavior closer to the specification, these features should also be disabled."
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1111
msgid "Applications are recommended to use the default, non-strict mode, which makes CDI more convenient to use.  The \"strictness\" of the strict mode (the set of additional validations and the set of disabled improvements on top of the CDI specification) may change over time."
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:1113
#, no-wrap
msgid "ArC Configuration Reference"
msgstr ""

#, fuzzy
#~ msgid "The disadvantage of `@javax.annotation.Priority` is that it has `@Target({ TYPE, PARAMETER })` and so it cannot be used for producer methods and fields.  This problem should be fixed in Common Annotations 2.1.  Users are encouraged to use `@io.quarkus.arc.Priority` instead, until Quarkus upgrades to this version of `jakarta.annotation-api`."
#~ msgstr " `@javax.annotation.Priority` 的缺点是它有 `@Target({ TYPE, PARAMETER })` ，所以它不能用于生产者方法和字段。这个问题应该在Common Annotations 2.1中得到解决。我们鼓励用户使用 `@io.quarkus.arc.Priority` 来代替，直到Quarkus升级到这个版本的 `jakarta.annotation-api` 。"

#, fuzzy
#~ msgid "Scopes and contexts"
#~ msgstr "范围和背景"

#, fuzzy
#~ msgid "`@Dependent`, `@ApplicationScoped`, `@Singleton`, `@RequestScoped` and `@SessionScoped`"
#~ msgstr " `@Dependent` , `@ApplicationScoped` , `@Singleton` , `@RequestScoped` 和 `@SessionScoped` "

#, fuzzy
#~ msgid "Custom scopes and contexts"
#~ msgstr "自定义作用域和语境"

#, fuzzy
#~ msgid "If you are using gradle, you can apply the following plugin to your `build.gradle`:"
#~ msgstr "如果你正在使用gradle，你可以将以下插件应用到你的 `build.gradle` 。"
