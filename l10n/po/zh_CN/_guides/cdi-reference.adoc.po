# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-25 13:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Contexts and Dependency Injection"
msgstr "上下文和依赖性注入"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus DI solution (also called ArC) is based on the https://jakarta.ee/"
"specifications/cdi/4.1/jakarta-cdi-spec-4.1.html[Jakarta Contexts and "
"Dependency Injection 4.1, window=\"_blank\"] specification.\n"
"It implements the CDI Lite specification, with selected improvements on top, "
"and passes the CDI Lite TCK.\n"
"It does not implement CDI Full.\n"
"See also <<supported_features_and_limitations,the list of supported features "
"and limitations>>.\n"
"Most of the existing CDI code should work just fine but there are some small "
"differences which follow from the Quarkus architecture and goals."
msgstr ""
"Quarkus DI 解决方案（又称 ArC）基于 link:https://jakarta.ee/specifications/cdi/4.1/"
"jakarta-cdi-spec-4.1.html[Jakarta Contexts 和依赖注入 4.1] 规范。它实现了 CDI Lite "
"规范，并在此基础上进行了改进，还通过了 CDI Lite TCK。它没有实现 CDI Full。另请参阅 xref:"
"supported_features_and_limitations[支持的功能和限制列表] 。大部分现有的 CDI 代码都能正常运行，但与 "
"Quarkus 架构和目标有一些细微差别。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If you're new to CDI we recommend you to read the xref:cdi.adoc[Introduction "
"to CDI] first."
msgstr "如果您是 CDI 新手，我们建议您先阅读 xref:cdi.adoc[CDI 简介] 。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The xref:cdi-integration.adoc[CDI integration guide] has more detail on "
"common CDI-related integration use cases, and example code for solutions."
msgstr ""
"xref:cdi-integration.adoc[CDI 集成指南] 更详细地介绍了与 CDI 相关的常见集成用例，以及解决方案的示例代码。"

#. type: Title ==
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Bean Discovery"
msgstr "豆类的发现"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Bean discovery in CDI is a complex process which involves legacy deployment "
"structures and accessibility requirements of the underlying module "
"architecture.\n"
"However, Quarkus is using a *simplified bean discovery*.\n"
"There is only single bean archive with the https://jakarta.ee/specifications/"
"cdi/4.1/jakarta-cdi-spec-4.1.html#default_bean_discovery[bean discovery mode "
"`annotated`, window=\"_blank\"] and no visibility boundaries."
msgstr ""
"CDI 中的 Bean 发现是一个复杂的过程，涉及到传统的部署结构和底层模块架构的可访问性要求。然而，Quarkus 使用的是 *简化的* Bean "
"发现。只有一个豆归档， link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-"
"4.1.html#default_bean_discovery[豆发现模式] 为 link:https://jakarta.ee/"
"specifications/cdi/4.1/jakarta-cdi-spec-4.1."
"html#default_bean_discovery[annotated ，没有可见性边界。]"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "The bean archive is synthesized from:"
msgstr "豆类档案是由以下内容合成的。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "the application classes,"
msgstr "的应用类。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"dependencies that contain a `beans.xml` descriptor (content is ignored),"
msgstr "包含一个 `beans.xml` 描述符的依赖关系（内容被忽略）。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "dependencies that contain a Jandex index - `META-INF/jandex.idx`,"
msgstr "包含Jandex索引的依赖性 - `META-INF/jandex.idx` ,"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"dependencies referenced by `quarkus.index-dependency` in `application."
"properties`,"
msgstr " `quarkus.index-dependency` 中引用的依赖性， `application.properties` 。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "and Quarkus integration code."
msgstr "和Quarkus集成代码。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Bean classes that don't have a https://jakarta.ee/specifications/cdi/4.1/"
"jakarta-cdi-spec-4.1.html#bean_defining_annotations[bean defining "
"annotation, window=\"_blank\"] are not discovered.\n"
"This behavior is defined by CDI.\n"
"But producer methods and fields and observer methods are discovered even if "
"the declaring class is not annotated with a bean defining annotation (this "
"behavior is different to what is defined in CDI).\n"
"In fact, the declaring bean classes are considered annotated with "
"`@Dependent`."
msgstr ""
"没有 bean link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1."
"html#bean_defining_annotations[定义注解] 的 Bean 类不会被发现。这种行为由 CDI 定义。但是，即使声明类没有注释 "
"Bean 定义注解，生产者方法和字段以及观察者方法也会被发现（这种行为与 CDI 中定义的不同）。事实上，声明的 Bean 类被认为注释了 "
"`@Dependent` 。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus extensions may declare additional discovery rules. For example, "
"`@Scheduled` business methods are registered even if the declaring class is "
"not annotated with a bean defining annotation."
msgstr "Quarkus扩展可以声明额外的发现规则。例如， `@Scheduled` 业务方法被注册，即使声明的类没有用Bean定义注解。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "How to Generate a Jandex Index"
msgstr "如何生成一个Jandex索引"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"A dependency with a Jandex index is automatically scanned for beans.\n"
"To generate the index, just add the following plugin to your build file:"
msgstr "带有 Jandex 索引的依赖关系会自动扫描豆类。要生成索引，只需在构建文件中添加以下插件即可："

#. type: Block title
#: _guides/cdi-reference.adoc
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: Block title
#: _guides/cdi-reference.adoc
#, no-wrap
msgid "Gradle (Groovy DSL)"
msgstr "Gradle (Groovy DSL)"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"You can find the latest plugin version in the https://plugins.gradle.org/"
"plugin/org.kordamp.gradle.jandex[Gradle Plugin Portal]"
msgstr ""
"您可以在 link:https://plugins.gradle.org/plugin/org.kordamp.gradle.jandex[Gradle "
"插件门户] 中找到最新的插件版本"

#. type: Block title
#: _guides/cdi-reference.adoc
#, no-wrap
msgid "Gradle (Kotlin DSL)"
msgstr "或者，如果您使用Gradle Kotlin DSL。"

#. type: delimited block *
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If you can't modify the dependency, you can still index it by adding "
"`quarkus.index-dependency` entries to your `application.properties`:"
msgstr ""
"如果你不能修改依赖关系，你仍然可以通过在你的 `application.properties` ，添加 `quarkus.index-"
"dependency` 条目来索引它。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If no `artifact-id` is specified then all dependencies with the specified "
"`group-id` are indexed."
msgstr "如果未指定 `artifact-id` ，则会索引指定 `group-id` 的所有依赖关系。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"For example, the following entries ensure that the `org.acme:acme-api` "
"dependency is indexed:"
msgstr "例如，以下条目确保 `org.acme:acme-api` 依赖关系被编入索引。"

#. type: Block title
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Example application.properties"
msgstr "示例application.properties"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Value is a group id for a dependency identified by name `acme`."
msgstr "值是由名称 `acme` 确定的依赖关系的组ID。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Value is an artifact id for a dependency identified by name `acme`."
msgstr "值是由名称识别的依赖关系的工件ID `acme` 。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "How To Exclude Types and Dependencies from Discovery"
msgstr "如何从发现中排除类型和依赖关系"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It may happen that some beans from third-party libraries do not work "
"correctly in Quarkus.\n"
"A typical example is a bean injecting a portable extension.\n"
"In such case, it's possible to exclude types and dependencies from the bean "
"discovery.\n"
"The `quarkus.arc.exclude-types` property accepts a list of string values "
"that are used to match classes that should be excluded."
msgstr ""
"第三方库中的某些 Bean 可能无法在 Quarkus 中正常工作。一个典型的例子就是注入了可移植扩展的 Bean。在这种情况下，可以从 bean "
"发现中排除类型和依赖关系。 `quarkus.arc.exclude-types` 属性接受一个字符串值列表，用于匹配应排除的类。"

#. type: Block title
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Value Examples"
msgstr "价值实例"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Value"
msgstr "价值"

#. type: Table
#: _guides/cdi-reference.adoc
#, no-wrap
msgid "Description"
msgstr "描述"

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`org.acme.Foo`"
msgstr " `org.acme.Foo` "

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the fully qualified name of the class"
msgstr "匹配类的完全合格名称"

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`org.acme.*`"
msgstr " `org.acme.*` "

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match classes with package `org.acme`"
msgstr "匹配类与包 `org.acme` "

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`org.acme.**`"
msgstr " `org.acme.**` "

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match classes where the package starts with `org.acme`"
msgstr "匹配包的开头为 `org.acme` "

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`Bar`"
msgstr " `Bar` "

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the simple name of the class"
msgstr "匹配类的简单名称"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Exclude the type `org.acme.Foo`."
msgstr "排除类型 `org.acme.Foo` 。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Exclude all types from the `org.acme` package."
msgstr "从 `org.acme` 包中排除所有类型。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Exclude all types whose simple name is `Bar`"
msgstr "排除所有类型，其简单名称为 `Bar` "

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It is also possible to exclude a dependency artifact that would be otherwise "
"scanned for beans.\n"
"For example, because it contains a `beans.xml` descriptor."
msgstr "也可以排除在其他情况下扫描豆类的依赖工件。例如，因为它包含 `beans.xml` 描述符。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "String-Based Qualifiers"
msgstr "基于字符串的限定符"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `@Named` qualifier, which you might be familiar with, is a _string-based "
"qualifier_.\n"
"That is, it's the string value of the qualifier annotation who determines "
"whether the qualifier matches or not.\n"
"This is not type-safe and should not be the norm in CDI applications.\n"
"Specific qualifier types should be preferred."
msgstr ""
"`@Named` 限定符是一种 _基于字符串的限定符_ "
"，大家可能对它并不陌生。也就是说，限定符注解的字符串值决定了限定符是否匹配。这不是类型安全的，不应成为 CDI 应用程序的规范。应首选特定的限定符类型。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"However, sometimes string-based qualifiers are necessary.\n"
"In that case, avoid the `@Named` qualifier, because in CDI, it works "
"differently to all other qualifiers."
msgstr ""
"不过，有时需要使用基于字符串的限定符。在这种情况下，请避免使用 `@Named` 限定符，因为在 CDI 中，它的工作方式与所有其他限定符不同。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Specifically: if the only qualifier a bean has is `@Named`, it also "
"automatically gets `@Default`.\n"
"This means that if multiple beans of the same type exist, one of them "
"without qualifiers and the others with `@Named`, they _all_ get the "
"`@Default` qualifier and bean resolution will error with ambiguity.\n"
"For example:"
msgstr ""
"具体来说：如果一个 Bean 的唯一限定符是 `@Named` ，那么它也会自动获得 `@Default` 。这意味着，如果存在多个相同类型的 "
"Bean，其中一个没有限定符，其他的 _都_ 有 `@Named` ，那么它们 _都_ 会得到 `@Default` 限定符，Bean "
"的解析就会出现歧义错误。例如"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In this case, the `Consumer#bean` injection point will cause ambiguity "
"error, because both `MyBean` producers will have the `@Default` qualifier."
msgstr ""
"在这种情况下， `Consumer#bean` 注入点会导致歧义错误，因为两个 `MyBean` 生产者都会有 `@Default` 限定符。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Instead of `@Named`, use `@io.smallrye.common.annotation.Identifier`.\n"
"This is a regular qualifier that works like all others.\n"
"So if we rewrite the example to use `@Identifier`:"
msgstr ""
"使用 `@io.smallrye.common.annotation.Identifier` 代替 `@Named` "
"。这是一个常规限定符，与其他限定符一样有效。因此，如果我们重写示例，使用 `@Identifier` ："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Only the first producer will get the `@Default` qualifier, the second will "
"not.\n"
"Hence, there will be no error, and everything will work as expected."
msgstr "只有第一个生产者会获得 `@Default` 限定符，第二个生产者不会。因此，不会出现错误，一切都会按预期运行。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "When To Use `@Named`?"
msgstr "何时使用 `@Named` ？"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"There is one case where `@Named` is the right thing to use: specifying an "
"external identifier for a different language that doesn't support dependency "
"injection directly."
msgstr "在一种情况下，使用 `@Named` 是正确的：为不直接支持依赖注入的不同语言指定外部标识符。"

#: _guides/cdi-reference.adoc
msgid "For example:"
msgstr "例如："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"As you can see, in the application code, the bean is injected without a "
"qualifier.\n"
"The bean name is only used to refer to the bean in the other language."
msgstr "正如您所看到的，在应用程序代码中，注入 Bean 时没有使用限定符。Bean 名称仅用于在其他语言中引用 Bean。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Historically, the most common external language that used bean names was JSF."
"\n"
"In Quarkus, we have xref:qute-reference.adoc#injecting-beans-directly-in-"
"templates[Qute].\n"
"In a Qute template, one would refer to the bean using its name:"
msgstr ""
"在历史上，使用 Bean 名称的最常见外部语言是 JSF。在 Quarkus 中，我们有 xref:qute-reference."
"adoc#injecting-beans-directly-in-templates[Qute] 。在 Qute 模板中，人们会使用 bean "
"的名称来引用 bean："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Outside of this use-case, just use `@Identifier`."
msgstr "除此使用情况外，只需使用 `@Identifier` 。"

#. type: Title ==
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Native Executables and Private Members"
msgstr "本地可执行文件和私有成员"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus is using GraalVM to build a native executable.\n"
"One of the limitations of GraalVM is the usage of link:https://www.graalvm."
"org/{graalvm-docs-version}/reference-manual/native-image/Reflection/"
"[Reflection, window=\"_blank\"].\n"
"Reflective operations are supported, but all relevant members must be "
"registered for reflection explicitly.\n"
"Those registrations result in a bigger native executable."
msgstr ""
"Quarkus 正在使用 GraalVM 构建本地可执行文件。GraalVM 的限制之一是 link:https://www.graalvm.org/"
"{graalvm-docs-version}/reference-manual/native-image/Reflection/[反射] "
"的使用。它支持反射操作，但所有相关成员都必须明确注册为反射。这些注册会导致本地可执行文件体积增大。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"And if Quarkus DI needs to access a private member it, *has to use "
"reflection*.\n"
"That's why Quarkus users are encouraged __not to use private members__ in "
"their beans.\n"
"This involves injection fields, constructors and initializers, observer "
"methods, producer methods and fields, disposers, and interceptor methods."
msgstr ""
"如果 Quarkus DI 需要访问私有成员，就 *必须使用反射* 。这就是为什么我们鼓励 Quarkus 用户 _不要_ 在他们的 Bean 中 "
"_使用私有成员_ 。这涉及到注入字段、构造函数和初始化器、观察者方法、生产者方法和字段、处置器和拦截器方法。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"How to avoid using private members?\n"
"You can use package-private modifiers:"
msgstr "如何避免使用私有成员？您可以使用包私有修饰符："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "A package-private injection field."
msgstr "一个包-私密的注入字段。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "A package-private observer method."
msgstr "一个包内私有的观察者方法。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Or constructor injection:"
msgstr "或构造器注入。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"A package-private constructor injection. `@Inject` is optional in this "
"particular case."
msgstr " `@Inject` ，在这种特殊情况下是可选的。"

#. type: Title ==
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid ""
"[[supported_features]][[limitations]] Supported Features and Limitations"
msgstr "  支持的功能和限制"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The CDI Lite specification is fully supported.\n"
"The following features from CDI Full are also supported:"
msgstr "完全支持 CDI Lite 规范。还支持 CDI 完全版的以下功能："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Decorators"
msgstr "装饰公司"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Decoration of built-in beans, such as `Event`, is not supported"
msgstr "不支持对内置豆类的装饰，如 `Event` ，。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "`BeanManager`"
msgstr " `BeanContainer` "

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In addition to the `BeanContainer` methods, the following methods are "
"supported: `getInjectableReference()`, `resolveDecorators()`"
msgstr ""
" `BeanManager` ：除了 `BeanContainer` 方法外，只支持以下方法： `getInjectableReference()` , "
"`resolveDecorators()` "

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "`@SessionScoped`"
msgstr "`@SessionScoped`"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Only with the Undertow extension; see xref:cdi.adoc#bean-scope-"
"available[here] for details"
msgstr "范围和背景；详见 link:cdi.html#bean-scope-available[这里]"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The _method invokers_ implementation supports asynchronous methods.\n"
"The following methods are considered asynchronous and `@Dependent` instances "
"are only destroyed when the asynchronous action completes:"
msgstr "_方法调用者_ 实现支持异步方法。以下方法被视为异步方法， `@Dependent` 实例只有在异步操作完成时才会被销毁："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"methods that declare a return type of `CompletionStage`, `Uni`, or `Multi`"
msgstr "声明返回类型为 `CompletionStage` , `Uni` , 或 `Multi`"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "These additional features are not covered by the CDI Lite TCK."
msgstr "CDI Lite TCK 不包括这些附加功能。"

#. type: Title ==
#: _guides/cdi-reference.adoc
#, no-wrap
msgid "Non-standard Features"
msgstr "非标准功能"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Eager Instantiation of Beans"
msgstr "豆类的急切实例化"

#. type: Title ====
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Lazy By Default"
msgstr "默认的懒惰"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"By default, CDI beans are created lazily, when needed.\n"
"What exactly \"needed\" means depends on the scope of a bean."
msgstr "默认情况下，CDI Bean 是在需要时才创建的。需要 \"的确切含义取决于 Bean 的作用域。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"A *normal scoped bean* (`@ApplicationScoped`, `@RequestScoped`, etc.) is "
"needed when a method is invoked upon an injected instance (contextual "
"reference per the specification)."
msgstr ""
"当一个方法在一个注入的实例上被调用时（根据规范的上下文引用），需要一个 *正常范围的Bean* （ `@ApplicationScoped` , "
"`@RequestScoped` , 等等）。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In other words, injecting a normal scoped bean will not suffice because a "
"_client proxy_ is injected instead of a contextual instance of the bean."
msgstr "换句话说，注入一个正常范围的Bean是不够的，因为注入的是一个 _客户端代理_ 而不是Bean的上下文实例。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"A *bean with a pseudo-scope* (`@Dependent` and `@Singleton` ) is created "
"when injected."
msgstr "当注入时，一个 *具有伪范围的Bean* ( `@Dependent` 和 `@Singleton` ) 被创建。"

#. type: Block title
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Lazy Instantiation Example"
msgstr "懒惰实例化实例"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Injection triggers the instantiation of `AmazingService`."
msgstr "注入触发了 `AmazingService` 的实例化。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Injection itself does not result in the instantiation of `CoolService`. A "
"client proxy is injected."
msgstr "注入本身并不导致 `CoolService` 。一个客户代理被注入了。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The first invocation upon the injected proxy triggers the instantiation of "
"`CoolService`."
msgstr "对注入的代理的第一次调用触发了 `CoolService` 的实例化。"

#. type: Title ====
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Startup Event"
msgstr "初创企业活动"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "However, if you really need to instantiate a bean eagerly, you can:"
msgstr "不过，如果您真的需要急切地实例化一个 Bean，也是可以的："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Declare an observer of the `StartupEvent` - the scope of the bean does not "
"matter in this case:"
msgstr "声明一个 `StartupEvent` 的观察者--在这种情况下，bean的范围并不重要。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"A `CoolService` is created during startup to service the observer method "
"invocation."
msgstr "在启动过程中会创建一个 `CoolService` ，以服务于观察者方法的调用。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Use the bean in an observer of the `StartupEvent` - normal scoped beans must "
"be used as described in <<lazy_by_default>>:"
msgstr ""
"在 `StartupEvent` 的观察者中使用 Bean - 必须按照 <<lazy_by_default>> 中的说明使用普通作用域 Bean："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "The `AmazingService` is created during injection."
msgstr " `AmazingService` 是在注射过程中产生的。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `CoolService` is a normal scoped bean, so we have to invoke a method "
"upon the injected proxy to force the instantiation."
msgstr " `CoolService` 是一个正常范围的bean，所以我们必须在注入的代理上调用一个方法来强制实例化。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Annotate the bean with `@io.quarkus.runtime.Startup` as described in xref:"
"lifecycle.adoc#startup_annotation[Startup annotation]:"
msgstr ""
"按照 link:lifecycle.html#startup_annotation[Startup annotation] 中的描述，用 `@io."
"quarkus.runtime.Startup` 来注解bean。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"For each bean annotated with `@Startup` a synthetic observer of "
"`StartupEvent` is generated. The default priority is used."
msgstr "对于每个用 `@Startup` 注释的Bean，会生成一个 `StartupEvent` 的合成观察者。使用的是默认的优先级。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The bean constructor is called when the application starts and the resulting "
"contextual instance is stored in the application context."
msgstr "当应用程序启动时，Bean构造函数被调用，产生的上下文实例被存储在应用程序上下文中。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus users are encouraged to always prefer the `@Observes StartupEvent` "
"to `@Initialized(ApplicationScoped.class)` as explained in the xref:"
"lifecycle.adoc[Application Initialization and Termination] guide."
msgstr ""
"我们鼓励Quarkus用户总是首选 `@Observes StartupEvent` ，而不是 "
"`@Initialized(ApplicationScoped.class)` ，这在 link:lifecycle.html[应用程序初始化和终止] "
"指南中有所解释。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Request Context Lifecycle"
msgstr "请求语境的生命周期"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "The request context is also active:"
msgstr "请求环境也是活跃的。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "during notification of a synchronous observer method."
msgstr "在同步观察者方法的通知期间。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "The request context is destroyed:"
msgstr "请求上下文被销毁。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"after the observer notification completes for an event, if it was not "
"already active when the notification started."
msgstr "在事件的观察者通知完成后，如果通知开始时它还没有被激活的话。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"An event with qualifier `@Initialized(RequestScoped.class)` is fired when "
"the request context is initialized for an observer notification. Moreover, "
"the events with qualifiers `@BeforeDestroyed(RequestScoped.class)` and "
"`@Destroyed(RequestScoped.class)` are fired when the request context is "
"destroyed."
msgstr ""
"当请求上下文被初始化为观察者通知时，带有限定词 `@Initialized(RequestScoped.class)` "
"的事件被触发。此外，当请求上下文被销毁时，带有限定词 `@BeforeDestroyed(RequestScoped.class)` 和 "
"`@Destroyed(RequestScoped.class)` 的事件被触发。"

#. type: Title ====
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "How to Enable Trace Logging for Request Context Activation"
msgstr "如何启用请求上下文激活的跟踪记录"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"You can set the `TRACE` level for the logger `io.quarkus.arc.requestContext` "
"and try to analyze the log output afterwards."
msgstr "你可以为记录仪设置 `TRACE` ， `io.quarkus.arc.requestContext` ，之后再尝试分析日志输出。"

#. type: Block title
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`application.properties` Example"
msgstr " `application.properties` 例子"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"You also need to adjust the minimum log level for the relevant category."
msgstr "你还需要调整相关类别的最小日志级别。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Qualified Injected Fields"
msgstr "合格的注射场"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In CDI, if you declare a field injection point you need to use `@Inject` and "
"optionally a set of qualifiers."
msgstr "在CDI中，如果你声明一个字段注入点，你需要使用 `@Inject` ，并且可以选择一组限定词。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In Quarkus, you can skip the `@Inject` annotation completely if the injected "
"field declares at least one qualifier."
msgstr "在Quarkus中，如果注入的字段至少声明了一个限定词，你可以完全跳过 `@Inject` 注释。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"With the notable exception of one special case discussed below, `@Inject` is "
"still required for constructor and method injection."
msgstr "除了下面讨论的一种特殊情况外， `@Inject` ，构造函数和方法注入仍然需要。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Simplified Constructor Injection"
msgstr "简化的构造函数注入"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In CDI, a normal scoped bean must always declare a no-args constructor (this "
"constructor is normally generated by the compiler unless you declare any "
"other constructor).\n"
"However, this requirement complicates constructor injection - you need to "
"provide a dummy no-args constructor to make things work in CDI."
msgstr ""
"在 CDI 中，正常作用域的 Bean "
"必须始终声明一个无参数构造函数（该构造函数通常由编译器生成，除非您声明任何其他构造函数）。然而，这一要求使构造函数注入变得复杂--"
"您需要提供一个虚假的无参数构造函数，才能在 CDI 中正常工作。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"There is no need to declare dummy constructors for normal scoped bean in "
"Quarkus - they are generated automatically.\n"
"Also, if there's only one constructor there is no need for `@Inject`."
msgstr ""
"在 Quarkus 中，无需为普通作用域 Bean 声明虚拟构造函数，它们会自动生成。此外，如果只有一个构造函数，就不需要 `@Inject` 。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"We don't generate a no-args constructor automatically if a bean class "
"extends a class that does not declare a no-args constructor."
msgstr "如果一个Bean类扩展了一个没有声明no-args构造函数的类，我们不会自动生成一个no-args构造函数。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Removing Unused Beans"
msgstr "移除未使用的豆子"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The container attempts to remove all unused beans, interceptors and "
"decorators during build by default.\n"
"This optimization helps to minimize the amount of generated classes, thus "
"conserving memory.\n"
"However, Quarkus can't detect the programmatic lookup performed via the `CDI."
"current()` static method.\n"
"Therefore, it is possible that a removal results in a false positive error, "
"i.e. a bean is removed although it's actually used.\n"
"In such cases, you'll notice a big warning in the log.\n"
"Users and extension authors have several options "
"<<eliminate_false_positives,how to eliminate false positives>>."
msgstr ""
"默认情况下，容器会在构建过程中移除所有未使用的 Bean、拦截器和装饰器。这种优化有助于最大限度地减少生成类的数量，从而节省内存。不过，Quarkus "
"无法检测通过 `CDI.current()` 静态方法执行的编程查找。因此，删除可能会导致误报，即一个 bean "
"被删除了，但它实际上还在使用。在这种情况下，您会在日志中注意到一个很大的警告。用户和扩展作者有几种 xref:"
"eliminate_false_positives[消除误报的方法] 。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The optimization can be disabled by setting `quarkus.arc.remove-unused-"
"beans` to `none` or `false`.\n"
"Quarkus also provides a middle ground where application beans are never "
"removed, whether or not they are unused, while the optimization proceeds "
"normally for non application classes.\n"
"To use this mode, set `quarkus.arc.remove-unused-beans` to `fwk` or "
"`framework`."
msgstr ""
"可以通过将 `quarkus.arc.remove-unused-beans` 设置为 `none` 或 `false` 来禁用优化。Quarkus "
"还提供了一种中间模式，即应用程序 Bean 无论是否未被使用，都不会被移除，而非应用程序类的优化则正常进行。要使用这种模式，可将 `quarkus."
"arc.remove-unused-beans` 设置为 `fwk` 或 `framework` 。"

#. type: Title ====
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "What's Removed?"
msgstr "移除的是什么？"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus first identifies so-called _unremovable_ beans that form the roots "
"in the dependency tree.\n"
"A good example is a Jakarta REST resource class or a bean which declares a "
"`@Scheduled` method."
msgstr ""
"Quarkus 首先会识别所谓的 _不可移除_ Bean，这些 Bean 构成了依赖关系树的根。Jakarta REST 资源类或声明了 "
"`@Scheduled` 方法的 Bean 就是一个很好的例子。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "An _unremovable_ bean:"
msgstr "一颗 _不_ 可拆卸的豆子。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "is <<eliminate_false_positives,excluded from removal>>, or"
msgstr "xref:eliminate_false_positives[不在清除之列] ，或"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "has a name designated via `@Named`, or"
msgstr "有一个通过 `@Named` 指定的名称，或"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "declares an observer method."
msgstr "声明了一个观察者方法。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "An _unused_ bean:"
msgstr "一个 _未使用的_ 豆子。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "is not _unremovable_, and"
msgstr "并非 _不可移除_ ，而且"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"is not eligible for injection to any injection point in the dependency tree "
"of _unremovable_ beans, and"
msgstr "不能被注入到 _不可移除_ 豆子依赖树中的任何注入点，并且"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"does not declare any producer which is eligible for injection to any "
"injection point in the dependency tree, and"
msgstr "没有声明任何有资格被注入到依赖树中任何注入点的生产者，并且"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"is not eligible for injection into any `jakarta.enterprise.inject.Instance` "
"or `jakarta.inject.Provider` injection point, and"
msgstr ""
"不能注射到任何 `jakarta.enterprise.inject.Instance` 或 `jakarta.inject.Provider` "
"注射点，以及"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"is not eligible for injection into any <<injecting-multiple-bean-instances-"
"intuitively,`@Inject @All List<>`>> injection point."
msgstr ""
"不能注入任何 xref:injecting-multiple-bean-instances-intuitively[@Inject @All "
"List<>] 注射点。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Unused interceptors and decorators are not associated with any bean."
msgstr "未使用的拦截器和装饰器不与任何Bean关联。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"When using the dev mode (running `./mvnw quarkus:dev`), you can see more "
"information about which beans are being removed:"
msgstr "在使用开发模式（运行 `./mvnw quarkus:dev` ）时，可以看到更多关于哪些豆被移除的信息："

#. type: delimited block =
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In the console - just enable the DEBUG level in your `application."
"properties`, i.e. `quarkus.log.category.\"io.quarkus.arc.processor\".level="
"DEBUG`"
msgstr ""
"在控制台--只要在你的 `application.properties` ，启用DEBUG级别，即 `quarkus.log.category.\"io."
"quarkus.arc.processor\".level=DEBUG` "

#. type: delimited block =
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "In the relevant Dev UI page"
msgstr "在相关的开发用户界面页面中"

#. type: Title ====
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "How To Eliminate False Positives"
msgstr "如何消除假阳性反应"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Users can instruct the container to not remove any of their specific beans "
"(even if they satisfy all the rules specified above) by annotating them with "
"`@io.quarkus.arc.Unremovable`.\n"
"This annotation can be declared on a class, a producer method or field."
msgstr ""
"用户可以用 `@io.quarkus.arc.Unremovable` 注释容器，指示容器不删除任何特定的 Bean（即使这些 Bean "
"符合上述规定的所有规则）。这种注解可以在类、生产者方法或字段上声明。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Since this is not always possible, there is an option to achieve the same "
"via `application.properties`.\n"
"The `quarkus.arc.unremovable-types` property accepts a list of string values "
"that are used to match beans based on their name or package."
msgstr ""
"由于并非总能做到这一点，因此可以通过 `application.properties` 来实现同样的目的。 `quarkus.arc."
"unremovable-types` 属性接受一个字符串值列表，用于根据豆子的名称或包匹配豆子。"

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the fully qualified name of the bean class"
msgstr "匹配Bean类的完全合格名称"

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match beans where the package of the bean class is `org.acme`"
msgstr "匹配豆类的包是什么的豆类 `org.acme` "

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match beans where the package of the bean class starts with `org.acme`"
msgstr "匹配豆类的包以\"\"开头的豆类。 `org.acme` "

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the simple name of the bean class"
msgstr "匹配豆类的简单名称"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Furthermore, extensions can eliminate false positives by producing an "
"`UnremovableBeanBuildItem`."
msgstr "此外，扩展可以消除假阳性，产生一个 `UnremovableBeanBuildItem` 。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Default Beans"
msgstr "默认豆类"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus adds a capability that CDI currently does not support which is to "
"conditionally declare a bean if no other bean with equal types and "
"qualifiers was declared by any available means (bean class, producer, "
"synthetic bean, ...)\n"
"This is done using the `@io.quarkus.arc.DefaultBean` annotation and is best "
"explained with an example."
msgstr ""
"Quarkus 增加了一项 CDI 目前不支持的功能，即如果没有其他具有相同类型和限定符的 Bean 通过任何可用的方法（Bean 类、生产者、合成 "
"Bean 等）被声明，则有条件地声明一个 Bean。该功能使用 `@io.quarkus.arc.DefaultBean` "
"注解实现，最好用一个示例来解释。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Say there is a Quarkus extension that, among other things, declares a few "
"CDI beans like the following code does:"
msgstr "假设有一个 Quarkus 扩展，其中声明了一些 CDI Bean，就像下面的代码一样："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The idea is that the extension autoconfigures things for the user, "
"eliminating a lot of boilerplate - we can just `@Inject` a `Tracer` wherever "
"it is needed.\n"
"Now imagine that in our application we would like to utilize the configured "
"`Tracer`, but we need to customize it a little, for example by providing a "
"custom `Reporter`.\n"
"The only thing that would be needed in our application would be something "
"like the following:"
msgstr ""
"这样做的目的是让扩展为用户自动配置，省去大量的模板--我们只需在需要的地方 `@Inject` `Tracer` "
"。现在设想一下，在我们的应用程序中，我们希望使用配置好的 `Tracer` ，但我们需要对其进行一些定制，例如提供一个自定义的 `Reporter` "
"。在我们的应用程序中，唯一需要的就是类似下面这样的内容："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`@DefaultBean` allows extensions (or any other code for that matter) to "
"provide defaults while backing off if beans of that type are supplied in any\n"
"way Quarkus supports."
msgstr ""
"`@DefaultBean` 允许扩展程序（或任何其他代码）提供默认值，同时在以任何 Quarkus 支持的方式提供该类型的 bean 时退出。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Default beans can optionally declare `@jakarta.annotation.Priority`.\n"
"If there is no priority defined, `@Priority(0)` is assumed.\n"
"Priority value is used for bean ordering and during typesafe resolution to "
"disambiguate multiple matching default beans."
msgstr ""
"默认 Bean 可以选择声明 `@jakarta.annotation.Priority` 。如果没有定义优先级，则假定为 `@Priority(0)` "
"。优先级值用于豆排序和类型安全解析，以消除多个匹配默认豆的歧义。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Enabling Beans for Quarkus Build Profile"
msgstr "启用Quarkus Build Profile的豆类"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus adds a capability that CDI currently does not support, which is to "
"conditionally enable a bean when a Quarkus build time profile is enabled,\n"
"via the `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc."
"profile.UnlessBuildProfile` annotations.\n"
"When used in conjunction with `@io.quarkus.arc.DefaultBean`, these "
"annotations allow for the creation of different bean configurations for "
"different build profiles."
msgstr ""
"Quarkus 增加了一项 CDI 目前不支持的功能，即通过 `@io.quarkus.arc.profile.IfBuildProfile` 和 "
"`@io.quarkus.arc.profile.UnlessBuildProfile` 注释，在启用 Quarkus 构建时间配置文件时有条件地启用 "
"Bean。与 `@io.quarkus.arc.DefaultBean` 结合使用时，这些注解允许为不同的构建配置文件创建不同的 Bean 配置。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Imagine, for instance that an application contains a bean named `Tracer`, "
"which needs to do nothing when in tests or in dev mode, but works in its "
"normal capacity for the production artifact.\n"
"An elegant way to create such beans is the following:"
msgstr ""
"例如，设想一个应用程序包含一个名为 `Tracer` 的 Bean，它在测试或开发模式下不需要做任何事情，但在生产模式下可以正常工作。创建此类 Bean "
"的一种优雅方法如下："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If instead, it is required that the `Tracer` bean also works in dev mode and "
"only default to doing nothing for tests, then `@UnlessBuildProfile` would be "
"ideal. The code would look like:"
msgstr ""
"如果相反，要求 `Tracer` bean也能在开发模式下工作，并且只在测试时默认为不做任何事情，那么 `@UnlessBuildProfile` "
"将是理想的。代码将看起来像。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The runtime profile has absolutely no effect on the bean resolution using "
"`@IfBuildProfile` and `@UnlessBuildProfile`."
msgstr "运行时配置文件对使用 `@IfBuildProfile` 和 `@UnlessBuildProfile` 的bean解析完全没有影响。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`@IfBuildProfile` and `@UnlessBuildProfile` may be put on a stereotype.\n"
"A bean will only be enabled if **all** the conditions defined by these "
"annotations are satisfied."
msgstr ""
"`@IfBuildProfile` 和 `@UnlessBuildProfile` 可以放在一个定型上。只有满足这些注解定义的 *所有* 条件，Bean "
"才会启用。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Enabling Beans for Quarkus Build Properties"
msgstr "为Quarkus构建属性启用豆类"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus adds a capability that CDI currently does not support which is to "
"conditionally enable a bean when a Quarkus build time property has or does "
"not have a specific value,\n"
"via the `@io.quarkus.arc.properties.IfBuildProperty` and `@io.quarkus.arc."
"properties.UnlessBuildProperty` annotations.\n"
"When used in conjunction with `@io.quarkus.arc.DefaultBean`, these "
"annotations allow for the creation of different bean configurations for "
"different build properties."
msgstr ""
"Quarkus 增加了一项 CDI 目前不支持的功能，即通过 `@io.quarkus.arc.properties.IfBuildProperty` "
"和 `@io.quarkus.arc.properties.UnlessBuildProperty` 注释，在 Quarkus "
"构建时间属性具有或不具有特定值时，有条件地启用 Bean。与 `@io.quarkus.arc.DefaultBean` "
"结合使用时，这些注解允许针对不同的构建属性创建不同的 Bean 配置。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The scenario we mentioned above with `Tracer` could also be implemented in "
"the following way:"
msgstr "我们上面提到的用 `Tracer` ，也可以用以下方式实现。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`@IfBuildProperty` and `@UnlessBuildProperty` are repeatable annotations and "
"may be put on a stereotype.\n"
"A bean will only be enabled if **all** the conditions defined by these "
"annotations are satisfied."
msgstr ""
"`@IfBuildProperty` 和 `@UnlessBuildProperty` 是可重复的注解，可以放在定型上。只有满足这些注解定义的 *所有* "
"条件，Bean 才会启用。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If instead, it is required that the `RealTracer` bean is only used if the "
"`some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` "
"would be ideal. The code would look like:"
msgstr ""
"相反，如果要求 `RealTracer` Bean只在 `some.tracer.enabled` 属性不是 `false` 的情况下使用，那么 "
"`@UnlessBuildProperty` 将是最理想的。代码将看起来像。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Properties set at runtime have absolutely no effect on the bean resolution "
"using `@IfBuildProperty` / `@UnlessBuildProperty`."
msgstr ""
"运行时设置的属性对使用 `@IfBuildProperty` / `@UnlessBuildProperty` 进行的 Bean 解析完全没有影响。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Declaring Selected Alternatives"
msgstr "宣布选定的替代品"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In CDI, an alternative bean may be selected either globally for an "
"application by means of `@Priority`, or for a bean archive using a `beans."
"xml` descriptor.\n"
"Quarkus has a simplified bean discovery, and the content of `beans.xml` is "
"ignored."
msgstr ""
"在 CDI 中，可以通过 `@Priority` 为应用程序全局选择替代 bean，也可以通过 `beans.xml` 描述符为 bean 档案选择替代 "
"bean。Quarkus 有一个简化的 Bean 发现功能，而且 `beans.xml` 的内容会被忽略。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"However, it is also possible to select alternatives for an application using "
"the unified configuration.\n"
"The `quarkus.arc.selected-alternatives` property accepts a list of string "
"values that are used to match alternative beans.\n"
"If any value matches, then the priority of `Integer#MAX_VALUE` is used for "
"the relevant bean.\n"
"The priority declared via `@Priority` or inherited from a stereotype is "
"overridden."
msgstr ""
"不过，也可以使用统一配置为应用程序选择替代豆。 `quarkus.arc.selected-alternatives` 属性接受用于匹配替代 bean "
"的字符串值列表。如果有任何值匹配，则 `Integer#MAX_VALUE` 的优先级将用于相关 Bean。通过 `@Priority` "
"声明或从定型继承的优先级会被覆盖。"

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid ""
"Match the fully qualified name of the bean class or the bean class of the "
"bean that declares the producer"
msgstr "匹配Bean类的完全合格名称或声明生产者的Bean类"

#. type: Table
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid ""
"Match the simple name of the bean class or the bean class of the bean that "
"declares the producer"
msgstr "匹配豆类的简单名称或声明生产者的豆类的豆类"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Simplified Producer Method Declaration"
msgstr "简化生产者方法申报"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "In CDI, a producer method must be always annotated with `@Produces`."
msgstr "在CDI中，生产者方法必须总是被注解为 `@Produces` 。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In Quarkus, you can skip the `@Produces` annotation completely if the "
"producer method is annotated with a scope annotation, a stereotype or a "
"qualifier."
msgstr "在Quarkus中，如果生产者方法被注解了范围注解、定型或限定符，你可以完全跳过 `@Produces` 注解。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Interception of Static Methods"
msgstr "静态方法的拦截"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The Interceptors specification is clear that _around-invoke_ methods must "
"not be declared static.\n"
"However, this restriction was driven mostly by technical limitations.\n"
"And since Quarkus is a build-time oriented stack that allows for additional "
"class transformations, those limitations don't apply anymore.\n"
"It's possible to annotate a non-private static method with an interceptor "
"binding:"
msgstr ""
"拦截器规范明确规定，\" _周围唤醒_ \"方法不得声明为静态方法。不过，这一限制主要是受技术限制所驱使。由于 Quarkus "
"是面向构建时间的堆栈，允许额外的类转换，因此这些限制不再适用。使用拦截器绑定注解非私有静态方法是可能的："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "`Logged` is an interceptor binding."
msgstr " `Logged` 是一个拦截器绑定。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Each method invocation is intercepted if there is an interceptor associated "
"with `Logged`."
msgstr "如果有一个与 `Logged` 相关的拦截器，每个方法的调用都会被拦截。"

#. type: Title ====
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Limitations"
msgstr "限制条件"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Only *method-level bindings* are considered for backward compatibility "
"reasons (otherwise static methods of bean classes that declare class-level "
"bindings would be suddenly intercepted)"
msgstr "出于向后兼容的原因，只考虑 *方法级绑定* （否则声明类级绑定的bean类的静态方法会突然被拦截）。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Private static methods are never intercepted"
msgstr "私有静态方法从不被拦截"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`InvocationContext#getTarget()` returns `null` for obvious reasons; "
"therefore, not all existing interceptors may behave correctly when "
"intercepting static methods"
msgstr ""
"`InvocationContext#getTarget()` 返回 `null` "
"，原因显而易见；因此，在拦截静态方法时，并非所有现有拦截器都能正确运行"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Interceptors can use `InvocationContext.getMethod()` to detect static "
"methods and adjust the behavior accordingly."
msgstr "拦截器可以使用 `InvocationContext.getMethod()` 来检测静态方法并相应地调整行为。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Ability to handle 'final' classes and methods"
msgstr "有能力处理 \"最终 \"类和方法"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In normal CDI, classes that are marked as `final` and / or have `final` "
"methods are not eligible for proxy creation,\n"
"which in turn means that interceptors and normal scoped beans don't work "
"properly.\n"
"This situation is very common when trying to use CDI with alternative JVM "
"languages like Kotlin, where classes and methods are `final` by default."
msgstr ""
"在普通 CDI 中，被标记为 `final` 和/或具有 `final` 方法的类不符合代理创建条件，这反过来又意味着拦截器和普通作用域 Bean "
"无法正常工作。在尝试将 CDI 与 Kotlin 等其他 JVM 语言结合使用时，这种情况非常常见，因为 Kotlin 的类和方法默认为 `final` "
"。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus however, can overcome these limitations when `quarkus.arc.transform-"
"unproxyable-classes` is set to `true` (which is the default value)."
msgstr ""
" `true` 然而，当 `quarkus.arc.transform-unproxyable-classes` "
"（这是默认值）时，Quarkus可以克服这些限制。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Container-managed Concurrency"
msgstr "容器管理的并发性"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"There is no standard concurrency control mechanism for CDI beans.\n"
"Nevertheless, a bean instance can be shared and accessed concurrently from "
"multiple threads.\n"
"In that case, it should be thread-safe.\n"
"You can use standard Java constructs (`volatile`, `synchronized`, "
"`ReadWriteLock`, etc.) or let the container control the concurrent access.\n"
"Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for this "
"interceptor binding.\n"
"Each interceptor instance associated with a contextual instance of an "
"intercepted bean holds a separate `ReadWriteLock` with non-fair ordering "
"policy."
msgstr ""
"CDI Bean 没有标准的并发控制机制。不过，Bean 实例可以共享，并由多个线程并发访问。在这种情况下，它应该是线程安全的。您可以使用标准的 "
"Java 结构（ `volatile` , `synchronized` , `ReadWriteLock` "
"等），也可以让容器来控制并发访问。Quarkus 为这种拦截器绑定提供了 `@io.quarkus.arc.Lock` 和内置拦截器。与被拦截 Bean "
"的上下文实例相关联的每个拦截器实例都拥有一个单独的、采用非公平排序策略的 `ReadWriteLock` 。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`io.quarkus.arc.Lock` is a regular interceptor binding and as such can be "
"used for any bean with any scope. However, it is especially useful for "
"\"shared\" scopes, e.g. `@Singleton` and `@ApplicationScoped`."
msgstr ""
" `io.quarkus.arc.Lock` 是一个常规的拦截器绑定，因此可以用于任何作用域的bean。然而，它对 \"共享 \"作用域特别有用，例如： "
"和 。 `@Singleton` `@ApplicationScoped` "

#. type: Block title
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Container-managed Concurrency Example"
msgstr "容器管理的并发性实例"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class "
"instructs the container to lock the bean instance for any invocation of any "
"business method, i.e. the client has \"exclusive access\" and no concurrent "
"invocations will be allowed."
msgstr ""
" `@Lock` (映射到 )声明的类指示容器为任何业务方法的任何调用锁定Bean实例，也就是说，客户有 \"排他性访问\"，不允许并发调用。 "
"`@Lock(Lock.Type.WRITE)` "

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`@Lock(Lock.Type.READ)` overrides the value specified at class level. It "
"means that any number of clients can invoke the method concurrently, unless "
"the bean instance is locked by `@Lock(Lock.Type.WRITE)`."
msgstr ""
" `@Lock(Lock.Type.READ)` 覆盖了在类级别指定的值。这意味着任何数量的客户端都可以并发地调用该方法，除非Bean实例被 锁定。 "
"`@Lock(Lock.Type.WRITE)` "

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"You can also specify the \"wait time\". If it's not possible to acquire the "
"lock in the given time a `LockException` is thrown."
msgstr "你也可以指定 \"等待时间\"。如果在给定的时间内不可能获得锁，就会抛出一个 `LockException` 。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Repeatable interceptor bindings"
msgstr "可重复的拦截器绑定"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus has limited support for `@Repeatable` interceptor binding "
"annotations."
msgstr "Quarkus对 `@Repeatable` 拦截器绑定注释的支持有限。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"When binding an interceptor to a component, you can declare multiple "
"`@Repeatable` annotations on methods.\n"
"Repeatable interceptor bindings declared on classes and stereotypes are not "
"supported, because there are some open questions around interactions with "
"the Interceptors specification.\n"
"This might be added in the future."
msgstr ""
"将拦截器绑定到组件时，可以在方法上声明多个 `@Repeatable` "
"注释。由于与拦截器规范的交互还存在一些未决问题，因此不支持在类和定型上声明可重复的拦截器绑定。将来可能会添加。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"As an example, suppose we have an interceptor that clears a cache.\n"
"The corresponding interceptor binding would be called `@CacheInvalidateAll` "
"and would be declared as `@Repeatable`.\n"
"If we wanted to clear two caches at the same time, we would add "
"`@CacheInvalidateAll` twice:"
msgstr ""
"举例来说，假设我们有一个拦截器可以清除缓存。相应的拦截器绑定将被称为 `@CacheInvalidateAll` ，并声明为 `@Repeatable` "
"。如果我们想同时清除两个缓存，就需要添加两次 `@CacheInvalidateAll` ："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "This is how interceptors are used.\n"
"What about creating an interceptor?"
msgstr "这就是拦截器的使用方法。如何创建拦截器？"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"When declaring interceptor bindings of an interceptor, you can add multiple "
"`@Repeatable` annotations to the interceptor class as usual.\n"
"This is useless when the annotation members are `@Nonbinding`, as would be "
"the case for the `@Cached` annotation, but is important otherwise."
msgstr ""
"在声明拦截器的拦截器绑定时，可以像往常一样向拦截器类添加多个 `@Repeatable` 注释。当注解成员为 `@Nonbinding` "
"时，这一点毫无用处，如 `@Cached` 注解的情况，但在其他情况下，这一点非常重要。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"For example, suppose we have an interceptor that can automatically log "
"method invocations to certain targets.\n"
"The interceptor binding annotation `@Logged` would have a member called "
"`target`, which specifies where to store the log.\n"
"Our implementation could be restricted to console logging and file logging:"
msgstr ""
"例如，假设我们有一个拦截器，可以自动记录对某些目标的方法调用。拦截器绑定注解 `@Logged` 将有一个名为 `target` "
"的成员，它指定了日志的存储位置。我们的实现可能仅限于控制台日志和文件日志："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Other interceptors could be provided to log method invocations to different "
"targets."
msgstr "可以提供其他拦截器来记录对不同目标的方法调用。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Caching the Result of Programmatic Lookup"
msgstr "缓存程序化查询的结果"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In certain situations, it is practical to obtain a bean instance "
"programmatically via an injected `jakarta.enterprise.inject.Instance` and "
"`Instance.get()`.\n"
"However, according to the specification, the `get()` method must identify "
"the matching bean and obtain a contextual reference.\n"
"As a consequence, a new instance of a  `@Dependent` bean is returned from "
"each invocation of `get()`.\n"
"Moreover, this instance is a dependent object of the injected `Instance`.\n"
"This behavior is well-defined, but it may lead to unexpected errors and "
"memory leaks.\n"
"Therefore, Quarkus comes with the `io.quarkus.arc.WithCaching` annotation.\n"
"An injected `Instance` annotated with this annotation will cache the result "
"of the `Instance#get()` operation.\n"
"The result is computed on the first call, and the same value is returned for "
"all subsequent calls, even for `@Dependent` beans."
msgstr ""
"在某些情况下，通过注入的 `jakarta.enterprise.inject.Instance` 和 `Instance.get()` 以编程方式获取 "
"Bean 实例是可行的。但是，根据规范， `get()` 方法必须识别匹配的 Bean 并获取上下文引用。因此，每次调用 `get()` "
"时，都会返回一个 `@Dependent` Bean 的新实例。此外，该实例是注入的 `Instance` "
"的从属对象。这种行为定义明确，但可能会导致意外错误和内存泄漏。因此，Quarkus 附带了 `io.quarkus.arc.WithCaching` "
"注释。注入了该注解的 `Instance` 将缓存 `Instance#get()` "
"操作的结果。第一次调用会计算出结果，随后的所有调用都会返回相同的值，即使是 `@Dependent` bean 也不例外。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It is also possible to clear the cached value via `io.quarkus.arc."
"InjectableInstance.clearCache()`. In this case, you'll need to inject the "
"Quarkus-specific `io.quarkus.arc.InjectableInstance` instead of `jakarta."
"enterprise.inject.Instance`."
msgstr ""
"也可以通过 `io.quarkus.arc.InjectableInstance.clearCache()` "
"来清除缓存的值。在这种情况下，你需要注入Quarkus专用的 `io.quarkus.arc.InjectableInstance` ，而不是 "
"`javax.enterprise.inject.Instance` 。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Declaratively Choose Beans That Can Be Obtained by Programmatic Lookup"
msgstr "声明性地选择可通过程序化查询获得的豆类"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It is sometimes useful to narrow down the set of beans that can be obtained "
"by programmatic lookup via `jakarta.enterprise.inject.Instance`.\n"
"Typically, a user needs to choose the appropriate implementation of an "
"interface based on a runtime configuration property."
msgstr ""
"有时，通过 `jakarta.enterprise.inject.Instance` 缩小可通过编程查找获得的 Bean "
"集范围是非常有用的。通常情况下，用户需要根据运行时配置属性来选择合适的接口实现。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Imagine that we have two beans implementing the interface `org.acme.Service`."
"\n"
"You can't inject the `org.acme.Service` directly unless your implementations "
"declare a CDI qualifier.\n"
"However, you can inject the `Instance<Service>` instead, then iterate over "
"all implementations and choose the correct one manually.\n"
"Alternatively, you can use the `@LookupIfProperty` and "
"`@LookupUnlessProperty` annotations.\n"
"`@LookupIfProperty` indicates that a bean should only be obtained if a "
"runtime configuration property matches the provided value.\n"
"`@LookupUnlessProperty`, on the other hand, indicates that a bean should "
"only be obtained if a runtime configuration property does not match the "
"provided value."
msgstr ""
"想象一下，我们有两个实现接口 `org.acme.Service` 的 Bean。您不能直接注入 `org.acme.Service` "
"，除非您的实现声明了 CDI 限定符。不过，您可以注入 `Instance<Service>` "
"，然后遍历所有实现并手动选择正确的实现。另外，您还可以使用 `@LookupIfProperty` 和 `@LookupUnlessProperty` "
"注释。 `@LookupIfProperty` 表示，只有当运行时配置属性与提供的值相匹配时，才能获取 bean。 "
"`@LookupUnlessProperty` 而  注解则表示，只有当运行时配置属性与提供的值不匹配时，才应获取 Bean。"

#. type: Block title
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`@LookupIfProperty` Example"
msgstr " `@LookupIfProperty` 例子"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`@LookupIfProperty` and `@LookupUnlessProperty` are repeatable annotations "
"and may be put on a stereotype.\n"
"A bean will only be obtained if **all** the conditions defined by these "
"annotations are satisfied."
msgstr ""
"`@LookupIfProperty` 和 `@LookupUnlessProperty` "
"是可重复的注解，可以放在一个定型上。只有满足了这些注解所定义的 *所有* 条件，才能获得一个 Bean。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Sorting beans obtained with programmatic lookup"
msgstr "使用编程查找对豆子进行排序"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If there is more than one bean that matches the required type and qualifiers "
"and is eligible for injection, it is possible to iterate (or stream) "
"available bean instances.\n"
"Beans returned by both stream and iterator methods are sorted by priority as "
"defined by `io.quarkus.arc.InjectableBean#getPriority()`. Higher priority "
"goes first.\n"
"If no priority is explicitly declared, 0 is assumed."
msgstr ""
"如果有一个以上的 Bean 符合所需的类型和限定条件，并且有资格被注入，那么就可以对可用的 Bean 实例进行迭代（或流）。由流和迭代器方法返回的 "
"Bean 都是按 `io.quarkus.arc.InjectableBean#getPriority()` "
"所定义的优先级排序的。优先级越高，排序越靠前。如果没有明确声明优先级，则假定为 0。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Injecting Multiple Bean Instances Intuitively"
msgstr "直观地注入多个Bean实例"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In CDI, it's possible to inject multiple bean instances (aka contextual "
"references) via the `jakarta.enterprise.inject.Instance` which implements "
"`java.lang.Iterable`.\n"
"However, it's not exactly intuitive.\n"
"Therefore, a new way was introduced in Quarkus - you can inject a `java.util."
"List` annotated with the `io.quarkus.arc.All` qualifier.\n"
"The type of elements in the list is used as the required type when "
"performing the lookup."
msgstr ""
"在 CDI 中，可以通过实现 `java.lang.Iterable` 的 `jakarta.enterprise.inject.Instance` "
"注入多个 Bean 实例（又称上下文引用）。不过，这并不直观。因此，Quarkus 引入了一种新方法--您可以注入一个用 `io.quarkus.arc."
"All` 限定符注释的 `java.util.List` 。在执行查找时，列表中元素的类型将被用作所需的类型。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The injected instance is an _immutable list_ of the contextual references of "
"the _disambiguated_ beans."
msgstr "注入的实例是一个 _不可变的列表_ ，其中包含了 _被消除歧义的_ Bean的上下文引用。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"For this injection point the required type is `Service` and no additional "
"qualifiers are declared."
msgstr "对于这个注入点，所需的类型是 `Service` ，没有声明额外的限定符。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The list is sorted by priority as defined by `io.quarkus.arc."
"InjectableBean#getPriority()`. Higher priority goes first. In general, the "
"`@jakarta.annotation.Priority` annotation can be used to assign the priority "
"to a class bean, producer method or producer field."
msgstr ""
"列表按照 `io.quarkus.arc.InjectableBean#getPriority()` 所定义的优先级进行排序。优先级越高越好。一般来说， "
"`@javax.annotation.Priority` 和 `@io.quarkus.arc.Priority` "
"注解可以用来给类豆、生产者方法或生产者字段分配优先级。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If an injection point declares no other qualifier than `@All` then `@Any` is "
"used, i.e. the behavior is equivalent to `@Inject @Any Instance<Service>`."
msgstr ""
"如果一个注入点除了 `@All` ，没有声明其他限定词，那么就使用 `@Any` ，即行为等同于 `@Inject @Any "
"Instance<Service>` 。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"You can also inject a list of bean instances wrapped in `io.quarkus.arc."
"InstanceHandle`.\n"
"This can be useful if you need to inspect the related bean metadata."
msgstr ""
"您还可以注入用 `io.quarkus.arc.InstanceHandle` 封装的 Bean 实例列表。如果您需要检查相关的 Bean "
"元数据，这将非常有用。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Neither a type variable nor a wildcard is a legal type parameter for an "
"`@All List<>` injection point, i.e. `@Inject @All List<?> all` is not "
"supported and results in a deployment error."
msgstr ""
"类型变量和通配符都不是 `@All List<>` 注入点的合法类型参数，即不支持 `@Inject @All List<?> all` "
"，导致部署错误。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It is also possible to obtain the list of all bean instance handles "
"programmatically via the `Arc.container().listAll()` methods."
msgstr "也可以通过 `Arc.container().listAll()` 方法以编程方式获得所有bean实例柄的列表。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Ignoring Class-Level Interceptor Bindings for Methods and Constructors"
msgstr "忽略方法和构造器的类级拦截器绑定"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If a managed bean declares interceptor binding annotations on the class "
"level, the corresponding `@AroundInvoke` interceptors will apply to all "
"business methods.\n"
"Similarly, the corresponding `@AroundConstruct` interceptors will apply to "
"the bean constructor."
msgstr ""
"如果托管 bean 在类级别声明了拦截器绑定注解，则相应的 `@AroundInvoke` 拦截器将适用于所有业务方法。同样，相应的 "
"`@AroundConstruct` 拦截器也将应用于 bean 构造函数。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"For example, suppose we have a logging interceptor with the `@Logged` "
"binding annotation and a tracing interceptor with the `@Traced` binding "
"annotation:"
msgstr "例如，假设我们有一个带有 `@Logged` 绑定注释的日志拦截器和一个带有 `@Traced` 绑定注释的追踪拦截器。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In this example, both `doSomething` and `doSomethingElse` will be "
"intercepted by the hypothetical logging interceptor.\n"
"Additionally, the `doSomethingElse` method will be intercepted by the "
"hypothetical tracing interceptor."
msgstr ""
"在本例中，假定日志拦截器将拦截 `doSomething` 和 `doSomethingElse` 。此外， `doSomethingElse` "
"方法也将被假设的跟踪拦截器拦截。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Now, if that `@Traced` interceptor also performed all the necessary logging, "
"we'd like to skip the `@Logged` interceptor for this method, but keep it for "
"all other methods.\n"
"To achieve that, you can annotate the method with `@NoClassInterceptors`:"
msgstr ""
"现在，如果 `@Traced` 拦截器也执行了所有必要的日志记录，我们希望跳过该方法的 `@Logged` "
"拦截器，但在所有其他方法中保留它。要做到这一点，可以用 `@NoClassInterceptors` 来注解该方法："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `@NoClassInterceptors` annotation may be put on methods and "
"constructors, and means that all class-level interceptors are ignored for "
"these methods and constructors.\n"
"In other words, if a method/constructor is annotated `@NoClassInterceptors`, "
"then the only interceptors that will apply to this method/constructor are "
"interceptors declared directly on the method/constructor."
msgstr ""
"`@NoClassInterceptors` 注解可用于方法和构造函数，这意味着这些方法和构造函数将忽略所有类级拦截器。换句话说，如果一个方法/"
"构造函数被注解为 `@NoClassInterceptors` ，那么适用于该方法/构造函数的拦截器只能是直接在该方法/构造函数上声明的拦截器。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"This annotation affects only business method interceptors (`@AroundInvoke`) "
"and constructor lifecycle callback interceptors (`@AroundConstruct`)."
msgstr ""
"这个注解只影响业务方法拦截器 ( `@AroundInvoke` ) 和构造函数生命周期回调拦截器 ( `@AroundConstruct` )。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Exceptions Thrown By An Asynchronous Observer Method"
msgstr "异步观察者方法抛出的异常情况"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If an exception is thrown by an asynchronous observer then the "
"`CompletionStage` returned by the `fireAsync()` method completes "
"exceptionally so that the event producer may react appropriately.\n"
"However, if the event producer does not care then the exception is ignored "
"silently.\n"
"Therefore, Quarkus logs an error message by default.\n"
"It is also possible to implement a custom `AsyncObserverExceptionHandler`.\n"
"A bean that implements this interface should be `@jakarta.inject.Singleton` "
"or `@jakarta.enterprise.context.ApplicationScoped`."
msgstr ""
"如果异步观察者抛出异常，那么 `fireAsync()` 方法返回的 `CompletionStage` "
"会异常完成，以便事件生产者做出适当反应。但是，如果事件生产者并不关心，那么异常就会被无声地忽略。因此，Quarkus "
"默认会记录一条错误信息。也可以实现自定义的 `AsyncObserverExceptionHandler` 。实现该接口的 Bean 应该是 "
"`@jakarta.inject.Singleton` 或 `@jakarta.enterprise.context."
"ApplicationScoped` 。"

#. type: Block title
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`NoopAsyncObserverExceptionHandler`"
msgstr " `NoopAsyncObserverExceptionHandler` "

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Intercepted self-invocation"
msgstr "被拦截的自我召唤"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus supports what is known as intercepted self-invocation or just self-"
"interception - a scenario where CDI bean invokes its own intercepted method "
"from within another method while triggering any associated interceptors.\n"
"This is a non-standard feature as CDI specification doesn't define whether "
"self-interception should work or not."
msgstr ""
"Quarkus 支持所谓的拦截自调用（intercepted self-invocation）或自拦截（self-interception）--"
"在这种情况下，CDI Bean 会从另一个方法中调用自己的拦截方法，同时触发任何相关的拦截器。这是一种非标准功能，因为 CDI "
"规范并未定义自拦截是否有效。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Suppose we have a CDI bean with two methods, one of which has the "
"`@Transactional` interceptor binding associated with it:"
msgstr "假设我们有一个带有两个方法的 CDI Bean，其中一个方法与 `@Transactional` 拦截器绑定相关联："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "One or more interceptor bindings; `@Transactional` is just an example."
msgstr "一个或多个拦截器绑定； `@Transactional` 只是一个例子。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Non-intercepted method invoking another method from the same bean that has "
"associated binding(s); this will trigger interception."
msgstr "非拦截方法调用同一 bean 中具有相关绑定的另一个方法；这将触发拦截。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In the above example, any code calling the `doSomething()` method triggers "
"interception - in this case, the method becomes transactional.\n"
"This is regardless of whether the invocation originated directly from the "
"`MyService` bean (such as `MyService#doSomethingElse`) or from some other "
"bean."
msgstr ""
"在上面的示例中，任何调用 `doSomething()` 方法的代码都会触发拦截--在这种情况下，该方法会变成事务性的。无论调用是直接来自 "
"`MyService` Bean（如 `MyService#doSomethingElse` ）还是其他 Bean，都是如此。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Intercepting Producer Methods and Synthetic Beans"
msgstr "拦截生产方法和合成豆"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"By default, interception is only supported for managed beans (also known as "
"class-based beans).\n"
"To support interception of producer methods and synthetic beans, the CDI "
"specification includes an `InterceptionFactory`, which is a runtime oriented "
"concept and therefore cannot be supported in Quarkus."
msgstr ""
"默认情况下，拦截仅支持托管豆（也称为基于类的豆类）。为了支持对生产者方法和合成豆的拦截，CDI 规范包括一个 `InterceptionFactory` "
"，这是一个面向运行时的概念，因此 Quarkus 无法支持。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Instead, Quarkus has its own API: `InterceptionProxy` and `@BindingsSource`.\n"
"The `InterceptionProxy` is very similar to `InterceptionFactory`: it creates "
"a proxy that applies `@AroundInvoke` interceptors before forwarding the "
"method call to the target instance.\n"
"The `@BindingsSource` annotation allows setting interceptor bindings in case "
"the intercepted class is external and cannot be changed."
msgstr ""
"相反，Quarkus 有自己的 API： `InterceptionProxy` 和 `@BindingsSource` 。 "
"`InterceptionProxy` 与 `InterceptionFactory` 非常相似：它创建一个代理，在将方法调用转发给目标实例之前应用 "
"`@AroundInvoke` 拦截器。 `@BindingsSource` 注解允许设置拦截器绑定，以防被拦截的类是外部的且无法更改。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Declares an injection point of type `InterceptionProxy<MyClass>`.\n"
"This means that at build time, a subclass of `MyClass` is generated that "
"does the interception and forwarding.\n"
"Note that the type argument must be identical to the return type of the "
"producer method."
msgstr ""
"声明了 `InterceptionProxy<MyClass>` 类型的注入点。这意味着在构建时，会生成 `MyClass` "
"的子类来执行拦截和转发。请注意，类型参数必须与生产者方法的返回类型相同。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Creates an instance of the interception proxy for the given instance of "
"`MyClass`.\n"
"The method calls will be forwarded to this target instance after all "
"interceptors run."
msgstr "为 `MyClass` 的给定实例创建一个拦截代理实例。方法调用将在所有拦截器运行后转发到该目标实例。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In this example, interceptor bindings are read from the `MyClass` class."
msgstr "在本例中，拦截器绑定是从 `MyClass` 类中读取的。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Note that `InterceptionProxy` only supports `@AroundInvoke` interceptors "
"declared on interceptor classes.\n"
"Other kinds of interception, as well as `@AroundInvoke` interceptors "
"declared on the target class and its superclasses, are not supported."
msgstr ""
"请注意， `InterceptionProxy` 只支持在拦截器类上声明的 `@AroundInvoke` "
"拦截器。不支持其他类型的拦截，也不支持在目标类及其超类上声明的 `@AroundInvoke` 拦截器。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The intercepted class should be https://jakarta.ee/specifications/cdi/4.1/"
"jakarta-cdi-spec-4.1#unproxyable[proxyable] and therefore should not be "
"`final`, should not have non-private `final` methods, and should have a non-"
"private zero-parameter constructor.\n"
"If it isn't, a bytecode transformation will attempt to fix it if "
"<<unproxyable_classes_transformation,enabled>>, but note that adding a zero-"
"parameter constructor is not always possible."
msgstr ""
"被拦截的类应该是 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4."
"1#unproxyable[可代理的] ，因此不应该是 `final` ，不应该有非私有的 `final` "
"方法，并且应该有非私有的零参数构造函数。如果没有，字节码转换将尝试修复（如果 xref:"
"unproxyable_classes_transformation[启用] ），但请注意，添加零参数构造函数并不总是可行的。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It is often the case that the produced classes come from external libraries "
"and don't contain interceptor binding annotations at all.\n"
"To support such cases, the `@BindingsSource` annotation may be declared on "
"the `InterceptionProxy` parameter:"
msgstr ""
"通常情况下，生成的类来自外部库，根本不包含拦截器绑定注解。为支持这种情况，可在 `InterceptionProxy` 参数上声明 "
"`@BindingsSource` 注解："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"A class that mirrors the `MyClass` structure and contains interceptor "
"bindings."
msgstr "一个反映 `MyClass` 结构并包含拦截器绑定的类。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `@BindingsSource` annotation says that interceptor bindings for "
"`MyClass` should be read from `MyClassBindings`."
msgstr "`@BindingsSource` 注解指出，应从 `MyClassBindings` 读取 `MyClass` 的拦截器绑定。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The concept of _bindings source_ is a build-time friendly equivalent of "
"`InterceptionFactory.configure()`."
msgstr "_绑定源代码_ 的概念相当于 `InterceptionFactory.configure()` 。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Producer method interception and synthetic bean interception only works for "
"instance methods.\n"
"<<interception_of_static_methods>> is not supported for producer methods and "
"synthetic beans."
msgstr ""
"生产者方法拦截和合成 Bean 拦截仅适用于实例方法。 <<interception_of_static_methods>> 不支持生产者方法和合成 "
"Bean。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Declaring `@BindingsSource`"
msgstr "宣布 `@BindingsSource`"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `@BindingsSource` annotation specifies a class that mirrors the "
"structure of the intercepted class.\n"
"Interceptor bindings are then read from that class and treated as if they "
"were declared on the intercepted class."
msgstr ""
"`@BindingsSource` 注解指定了一个类，该类反映了被拦截类的结构。然后从该类读取拦截器绑定，并将其视为在被拦截类上声明的绑定。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Specifically: class-level interceptor bindings declared on the bindings "
"source class are treated as class-level bindings of the intercepted class.\n"
"Method-level interceptor bindings declared on the bindings source class are "
"treated as method-level bindings of a method with the same name, return "
"type, parameter types and `static` flag of the intercepted class."
msgstr ""
"具体来说：在绑定源类上声明的类级拦截器绑定被视为被拦截类的类级绑定。在绑定源类上声明的方法级拦截器绑定被视为被拦截类中具有相同名称、返回类型、参数类型和 "
"`static` 标志的方法的方法级绑定。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It is common to make the bindings source class and methods `abstract` so "
"that you don't have to write method bodies:"
msgstr "通常情况下，绑定源类和方法 `abstract` ，这样就不必编写方法体："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Since this class is never instantiated and its method are never invoked, "
"this is okay, but it's also possible to create a non-`abstract` class:"
msgstr "由于该类从未被实例化，其方法也从未被调用过，因此这样做没有问题，但也可以创建一个非 `abstract` 类："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "The method body does not matter."
msgstr "方法主体并不重要。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Note that for generic classes, the type variable names must also be "
"identical.\n"
"For example, for the following class:"
msgstr "请注意，对于泛型类，类型变量名也必须相同。例如"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The bindings source class must also use `T` as the name of the type variable:"
""
msgstr "绑定源类也必须使用 `T` 作为类型变量的名称："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"You don't need to declare methods that are not annotated simply because they "
"exist on the intercepted class.\n"
"If you want to add method-level bindings to a subset of methods, you only "
"have to declare the methods that are supposed to have an interceptor binding."
"\n"
"If you only want to add class-level bindings, you don't have to declare any "
"methods at all."
msgstr ""
"您不需要声明那些没有注释的方法，因为它们存在于被拦截类中。如果您想为一个方法子集添加方法级绑定，您只需声明应该具有拦截器绑定的方法。如果只想添加类级绑定，则无需声明任何方法。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "These annotations can be present on a bindings source class:"
msgstr "这些注解可以出现在绑定源类中："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "_interceptor bindings_: on the class and on the methods"
msgstr "_拦截器绑定_ ：在类和方法上"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "_stereotypes_: on the class"
msgstr "_定型观念_ ：关于班级"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "`@NoClassInterceptors`: on the methods"
msgstr "`@NoClassInterceptors` 关于方法"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Any other annotation present on a bindings source class is ignored."
msgstr "绑定源类上的任何其他注解都将被忽略。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Synthetic Beans"
msgstr "合成豆"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Using `InterceptionProxy` in synthetic beans is similar."
msgstr "在合成豆中使用 `InterceptionProxy` 也与此类似。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"First, you have to declare that your synthetic bean injects the "
"`InterceptionProxy`:"
msgstr "首先，您必须声明您的合成豆注入了 `InterceptionProxy` ："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Once again, this means that at build time, a subclass of `MyClass` is "
"generated that does the interception and forwarding."
msgstr "这再次意味着，在构建时，会生成一个 `MyClass` 的子类来执行拦截和转发。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Second, you have to obtain the `InterceptionProxy` from the "
"`SyntheticCreationalContext` in the `BeanCreator` and use it:"
msgstr ""
"其次，您必须从 `BeanCreator` 中的 `SyntheticCreationalContext` 获取 `InterceptionProxy` "
"并使用它："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Obtains the `InterceptionProxy` for `MyClass`, as declared above.\n"
"It would also be possible to use the `getInjectedReference()` method, "
"passing a `TypeLiteral`, but `getInterceptionProxy()` is easier."
msgstr ""
"获取上文声明的 `MyClass` 的 `InterceptionProxy` 。也可以使用 `getInjectedReference()` "
"方法，传入 `TypeLiteral` ，但 `getInterceptionProxy()` 更简单。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"There's also an equivalent of `@BindingsSource`.\n"
"The `injectInterceptionProxy()` method has an overload with a parameter:"
msgstr "`@BindingsSource` `injectInterceptionProxy()` 方法有一个带参数的重载："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "The argument is the bindings source class."
msgstr "参数是绑定源类。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "`Instance.Handle.close()` Behavior"
msgstr "`Instance.Handle.close()` 行为"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Per the CDI specification, the `Instance.Handle.close()` method always "
"delegates to `destroy()`.\n"
"In ArC, this is only true in the <<strict_mode>>."
msgstr ""
"根据 CDI 规范， `Instance.Handle.close()` 方法总是委托给 `destroy()` 。在 ArC 中，只有在 "
"<<strict_mode>> 中才是如此。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In the default mode, the `close()` method only delegates to `destroy()` when "
"the bean is `@Dependent` (or when the instance handle does not represent a "
"CDI contextual object).\n"
"When the instance handle represents a bean of any other scope, the `close()` "
"method does nothing; the bean is left as is and will be destroyed whenever "
"its context is destroyed."
msgstr ""
"在默认模式下，只有当 Bean 是 `@Dependent` （或实例句柄不代表 CDI 上下文对象）时， `close()` 方法才会委托给 "
"`destroy()` 。当实例句柄代表任何其他作用域的 Bean 时， `close()` 方法什么也不做；Bean "
"保持原样，并在其上下文被销毁时被销毁。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "This is to make the following code behave as one would naively expect:"
msgstr "这样做的目的是为了让下面的代码表现出人们天真的预期："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `@Dependent` beans are destroyed immediately, while other beans are not "
"destroyed at all.\n"
"This is important when multiple beans of different scopes might be returned "
"by the `Instance`."
msgstr ""
"`@Dependent` 的 Bean 会立即销毁，而其他 Bean 则不会销毁。当 `Instance` 可能返回多个不同作用域的 Bean "
"时，这一点非常重要。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Pitfalls with Reactive Programming"
msgstr "反应式编程的陷阱"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"CDI is a purely synchronous framework.\n"
"Its notion of asynchrony is very limited and based solely on thread pools "
"and thread offloading.\n"
"Therefore, there is a number of pitfalls when using CDI together with "
"reactive programming."
msgstr "CDI 是一个纯粹的同步框架。它的异步概念非常有限，仅基于线程池和线程卸载。因此，在将 CDI 与反应式编程结合使用时，会存在许多隐患。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Detecting When Blocking Is Allowed"
msgstr "检测何时允许阻塞"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `io.quarkus.runtime.BlockingOperationControl#isBlockingAllowed()` method "
"can be used to detect whether blocking is allowed on the current thread.\n"
"When it is not, and you need to perform a blocking operation, you have to "
"offload it to another thread.\n"
"The easiest way is to use the `Vertx.executeBlocking()` method:"
msgstr ""
"`io.quarkus.runtime.BlockingOperationControl#isBlockingAllowed()` "
"方法可用于检测当前线程是否允许阻塞。当不允许阻塞时，如果需要执行阻塞操作，就必须将其卸载到另一个线程。最简单的方法是使用 `Vertx."
"executeBlocking()` 方法："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Asynchronous Observers"
msgstr "异步观测器"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"CDI asynchronous observers (`@ObservesAsync`) are not aware of reactive "
"programming and are not meant to be used as part of reactive pipelines.\n"
"The observer methods are meant to be synchronous, they are just offloaded to "
"a thread pool."
msgstr ""
"CDI 异步观察者 ( `@ObservesAsync` ) "
"并不了解反应式编程，因此不能用作反应式管道的一部分。观察者方法本应是同步的，只是被卸载到线程池中。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `Event.fireAsync()` method returns a `CompletionStage` that completes "
"when all observers are notified.\n"
"If all observers were notified successfully, the `CompletionStage` completes "
"with the event payload.\n"
"If some observers have thrown an exception, the `CompletionStage` completes "
"exceptionally with a `CompletionException`."
msgstr ""
"`Event.fireAsync()` 方法会返回一个 `CompletionStage` "
"，当所有观察者都收到通知时，该方法就会完成。如果所有观察者都被成功通知，则 `CompletionStage` "
"将完成事件有效载荷。如果某些观察者抛出了异常， `CompletionStage` 会以 `CompletionException` 异常完成。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The return type of the observer _does not matter_.\n"
"The return value of the observer is _ignored_."
msgstr "观察者的返回类型 _无关紧要_ 。观察者的返回值将被 _忽略_ 。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"You may declare an observer method that has a return type of "
"`CompletionStage<>` or `Uni<>`, but neither the return type nor the actual "
"return value affects the result of `Event.fireAsync()`.\n"
"Further, if the observer declares a return type of `Uni<>`, the returned "
"`Uni` will not be subscribed to, so it is quite possible that part of the "
"observer logic will not even execute."
msgstr ""
"您可以声明一个返回类型为 `CompletionStage<>` 或 `Uni<>` 的观察者方法，但返回类型和实际返回值都不会影响 `Event."
"fireAsync()` 的结果。此外，如果观察者声明的返回类型为 `Uni<>` ，返回的 `Uni` "
"将不会被订阅，因此观察者的部分逻辑甚至有可能不会执行。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Therefore, it is recommended that observer methods, both synchronous and "
"asynchronous, are always declared `void`."
msgstr "因此，建议始终将观察者方法（包括同步和异步方法）声明为 `void` 。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Reactive startup methods"
msgstr "反应式启动方法"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"As documented in xref:lifecycle.adoc#startup_annotation[the `@Startup` "
"method documentation], you may define startup\n"
"methods that return a `Uni`, in which case they will be invoked on an event "
"thread instead of a blocking thread, and\n"
"their returned `Uni` will be subscribed to and awaited."
msgstr ""
"如 xref:lifecycle.adoc#startup_annotation[@Startup 方法文档] 所述，您可以定义返回 `Uni` "
"的启动方法，在这种情况下，这些方法将在事件线程而非阻塞线程上调用，其返回的 `Uni` 将被订阅和等待。"

#. type: Title ==
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Build Time Extensions"
msgstr "延长建造时间"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus incorporates build-time optimizations in order to provide instant "
"startup and low memory footprint.\n"
"The downside of this approach is that CDI Portable Extensions cannot be "
"supported.\n"
"Nevertheless, most of the functionality can be achieved using Quarkus xref:"
"writing-extensions.adoc[extensions].\n"
"See the xref:cdi-integration.adoc[integration guide] for more information."
msgstr ""
"Quarkus 在构建时进行了优化，以提供即时启动和低内存占用。这种方法的缺点是无法支持 CDI 可移植扩展。不过，大部分功能都可以通过 Quarkus "
"xref:writing-extensions.adoc[扩展] 实现。更多信息，请参阅 xref:cdi-integration.adoc[集成指南] "
"。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "[[development-mode]] Dev mode"
msgstr " 开发模式"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In dev mode, two special endpoints are registered automatically to provide "
"some basic debug info in the JSON format:"
msgstr "在开发模式下，会自动注册两个特殊端点，以 JSON 格式提供一些基本调试信息："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"HTTP GET `/q/arc` - returns the summary; number of beans, config properties, "
"etc."
msgstr "HTTP GET `/q/arc` - 返回摘要；豆的数量、配置属性等。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "HTTP GET `/q/arc/beans` - returns the list of all beans"
msgstr "HTTP GET `/q/arc/beans` - 返回所有豆子的列表"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "You can use query params to filter the output:"
msgstr "你可以使用查询参数来过滤输出。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`scope` - include beans with scope that ends with the given value, i.e. "
"`http://localhost:8080/q/arc/beans?scope=ApplicationScoped`"
msgstr ""
" `scope` - 包括具有以给定值结束的范围的豆子，即 `<a href=\"http://localhost:8080/q/arc/"
"beans?scope=ApplicationScoped\" class=\"bare\">http://localhost:8080/q/arc/"
"beans?scope=ApplicationScoped</a>` "

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`beanClass` - include beans with bean class that starts with the given "
"value, i.e. `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`"
msgstr ""
" `beanClass` - 包括具有以给定值开头的豆类的豆子，即 `<a href=\"http://localhost:8080/q/arc/"
"beans?beanClass=org.acme.Foo\" class=\"bare\">http://localhost:8080/q/arc/"
"beans?beanClass=org.acme.Foo</a>` "

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`kind` - include beans of the specified kind (`CLASS`, `PRODUCER_FIELD`, "
"`PRODUCER_METHOD`, `INTERCEPTOR` or `SYNTHETIC`), i.e. `http://localhost:"
"8080/q/arc/beans?kind=PRODUCER_METHOD`"
msgstr ""
" `kind` - 包括指定种类的豆子（ , , , 或 ），即 `CLASS` `PRODUCER_FIELD` `PRODUCER_METHOD` "
"`INTERCEPTOR` `SYNTHETIC` `<a href=\"http://localhost:8080/q/arc/beans?kind="
"PRODUCER_METHOD\" class=\"bare\">http://localhost:8080/q/arc/beans?kind="
"PRODUCER_METHOD</a>` "

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"HTTP GET `/q/arc/removed-beans` - returns the list of unused beans removed "
"during build"
msgstr "HTTP GET `/q/arc/removed-beans` - 返回在构建过程中移除的未使用的Bean列表。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "HTTP GET `/q/arc/observers` - returns the list of all observer methods"
msgstr "HTTP GET `/q/arc/observers` - 返回所有观察者方法的列表"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"These endpoints are only available in dev mode, i.e. when you run your "
"application via `mvn quarkus:dev` (or `./gradlew quarkusDev`)."
msgstr ""
"这些端点仅在开发模式下可用，即通过 `mvn quarkus:dev` （或 `./gradlew quarkusDev` ）运行应用程序时可用。"

#. type: Title ===
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Monitoring Business Method Invocations and Events"
msgstr "监测业务方法调用和事件"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In dev mode, it is also possible to enable monitoring of business method "
"invocations and fired events.\n"
"Simply set the `quarkus.arc.dev-mode.monitoring-enabled` configuration "
"property to `true` and explore the relevant Dev UI pages."
msgstr ""
"在开发模式下，还可以启用对业务方法调用和触发事件的监控。只需将 `quarkus.arc.dev-mode.monitoring-enabled` "
"配置属性设置为 `true` ，然后访问相关的开发用户界面页面即可。"

#. type: Title ==
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Strict Mode"
msgstr "严格的模式"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"By default, ArC does not perform all validations required by the CDI "
"specification.\n"
"It also improves CDI usability in many ways, some of them being directly "
"against the specification."
msgstr "默认情况下，ArC 不会执行 CDI 规范要求的所有验证。ArC 还能以多种方式提高 CDI 的可用性，其中一些方式直接与规范相对应。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"To pass the CDI Lite TCK, ArC also has a _strict_ mode.\n"
"This mode enables additional validations and disables certain improvements "
"that conflict with the specification."
msgstr "为了通过 CDI Lite TCK，ArC 还有一个 _严格_ 模式。该模式启用了额外的验证，并禁用了某些与规范冲突的改进。"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "To enable the strict mode, use the following configuration:"
msgstr "要启用严格模式，请使用以下配置："

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid "Some other features affect specification compatibility as well:"
msgstr "其他一些特征也会影响规范的兼容性："

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"<<unproxyable_classes_transformation,Transformation of unproxyable classes>>"
msgstr "xref:unproxyable_classes_transformation[不可代理类的转换]"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid "<<remove_unused_beans,Unused beans removal>>"
msgstr "xref:remove_unused_beans[清除未使用的豆子]"

#. type: Plain text
#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"To get a behavior closer to the specification, these features should be "
"disabled."
msgstr "为了获得更接近规范的行为，应该禁用这些功能。"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Applications are recommended to use the default, non-strict mode, which "
"makes CDI more convenient to use.\n"
"The \"strictness\" of the strict mode (the set of additional validations and "
"the set of disabled improvements on top of the CDI specification) may change "
"over time."
msgstr ""
"建议应用程序使用默认的非严格模式，这样可以更方便地使用 CDI。严格模式的 \"严格程度\"（附加验证集和 CDI "
"规范基础上的禁用改进集）可能会随着时间的推移而改变。"

#. type: Title ==
#: _guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "ArC Configuration Reference"
msgstr "ArC 配置参考"

#: _guides/cdi-reference.adoc
#, fuzzy
msgid ""
"<span class=\"icon\"><i class=\"fa fa-lock\" title=\"Fixed at build time\"></"
"i></span> Configuration property fixed at build time - All other "
"configuration properties are overridable at runtime <input type=\"search\" "
"id=\"config-search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"
msgstr ""
"<span class=\"icicon\"><i class=\"fa fa-lock\" title=\"在构建时固定\"></i></"
"span>在构建时固定的配置属性 - 所有其他配置属性都可在运行时重写 <input type=\"search\" id=\"config-"
"search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"
