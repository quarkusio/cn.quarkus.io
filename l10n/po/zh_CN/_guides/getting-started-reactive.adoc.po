# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/getting-started-reactive.adoc:6
#, fuzzy, no-wrap
msgid "Getting Started With Reactive"
msgstr "开始使用Reactive"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:12
#, fuzzy
msgid "_Reactive_ is a set of principles to build robust, efficient, and concurrent applications and systems.  These principles let you handle more load than traditional approaches while using the resources (CPU and memory) more efficiently while also reacting to failures gracefully."
msgstr " _反应式_ 是一套构建稳健、高效、并发的应用程序和系统的原则。这些原则让你比传统方法处理更多的负载，同时更有效地使用资源（CPU和内存），同时也能对故障做出优雅的反应。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:16
#, fuzzy
msgid "Quarkus is a _Reactive_ framework.  Since the beginning, _Reactive_ has been an essential tenet of the Quarkus architecture.  It includes many reactive features and offers a broad ecosystem."
msgstr "Quarkus是一个 _Reactive_ 框架。从一开始， _Reactive_ 就成为Quarkus架构的一个基本原则。它包括许多反应式的功能，并提供了一个广泛的生态系统。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:19
#, fuzzy
msgid "This guide is not an in-depth article about what _Reactive_ is and how Quarkus enables reactive architectures.  If you want to read more about these topics, refer to the xref:quarkus-reactive-architecture.adoc[Reactive Architecture guide], which provides an overview of the Quarkus reactive ecosystem."
msgstr "本指南不是一篇关于什么是 _反应式_ 以及Quarkus如何实现反应式架构的深入文章。如果你想阅读更多关于这些主题的内容，请参考《 link:quarkus-reactive-architecture.html[反应式架构》指南] ，它提供了Quarkus反应式生态系统的概述。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:23
#, fuzzy
msgid "In this guide, we will get you started with some reactive features of Quarkus.  We are going to implement a simple CRUD application.  Yet, unlike in the xref:hibernate-orm-panache.adoc[Hibernate with Panache guide], it uses the reactive features of Quarkus."
msgstr "在本指南中，我们将让你开始学习Quarkus的一些反应性功能。我们将实现一个简单的CRUD应用。然而，与 link:hibernate-orm-panache.html[Hibernate with Panache指南] 不同，它使用了Quarkus的反应式特性。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:25
#, fuzzy
msgid "This guide will help you with:"
msgstr "本指南将帮助你。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:27
#, fuzzy
msgid "Bootstrapping a reactive CRUD application with Quarkus"
msgstr "用Quarkus引导一个反应式CRUD应用程序"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:28
#, fuzzy
msgid "Using Hibernate Reactive with Panache to interact with a database in a reactive fashion"
msgstr "使用Hibernate Reactive与Panache以反应式方式与数据库互动"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:29
#, fuzzy
msgid "Using RESTEasy Reactive to implement HTTP API while enforcing the reactive principle"
msgstr "使用RESTEasy Reactive来实现HTTP API，同时执行反应性原则"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:30
#, fuzzy
msgid "Packaging and Running the application"
msgstr "包装和运行应用程序"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:31
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:38
#, fuzzy
msgid "Verify that Maven is using the Java version you expect.  If you have multiple JDKs installed, make sure Maven is using the expected one.  You can verify which JDK Maven uses by running `mvn --version.`"
msgstr "确认Maven使用的是你期望的Java版本。如果你安装了多个JDK，请确保Maven使用的是预期的那个。你可以通过运行以下程序验证Maven使用的JDK `mvn --version.` "

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:39
#, fuzzy, no-wrap
msgid "Imperative vs. Reactive: a question of threads"
msgstr "强迫性与反应性：一个线程问题"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:43
#, fuzzy
msgid "As mentioned above, in this guide, we are going to implement a reactive CRUD application.  But you may wonder what the differences and benefits are in comparison to the traditional and imperative model."
msgstr "如上所述，在本指南中，我们将实现一个反应式CRUD应用程序。但你可能想知道与传统的和命令式的模式相比，有什么区别和好处。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:46
#, fuzzy
msgid "To better understand the contrast, we need to explain the difference between the reactive and imperative execution models.  It's essential to comprehend that _Reactive_ is not just a different execution model, but that distinction is necessary to understand this guide."
msgstr "为了更好地理解这种对比，我们需要解释一下反应式和命令式执行模式之间的区别。理解 _Reactive_ 不仅仅是一种不同的执行模式，但这种区别对于理解本指南是必要的。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:53
#, fuzzy
msgid "In the traditional and imperative approach, frameworks assign a thread to handle the request.  So, the whole processing of the request runs on this worker thread.  This model does not scale very well.  Indeed, to handle multiple concurrent requests, you need multiple threads; and so your application concurrency is constrained by the number of threads.  In addition, these threads are blocked as soon as your code interacts with remote services.  So, it leads to inefficient usage of the resources, as you may need more threads, and each thread, as they are mapped to OS threads, has a cost in terms of memory and CPU."
msgstr "在传统的和命令式的方法中，框架分配了一个线程来处理请求。因此，整个请求的处理过程都在这个工作线程上运行。这种模式不能很好地扩展。事实上，为了处理多个并发请求，你需要多个线程；因此你的应用程序的并发性受到了线程数量的限制。此外，一旦你的代码与远程服务进行交互，这些线程就会被阻塞。所以，这导致了资源的低效使用，因为你可能需要更多的线程，而每个线程，因为它们被映射到操作系统的线程，都有内存和CPU方面的成本。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/getting-started-reactive.adoc:54
#, fuzzy, no-wrap
msgid "Imperative"
msgstr "当务之急"

#. type: Target for macro image
#: upstream/_guides/getting-started-reactive.adoc:54
#, no-wrap
msgid "blocking-threads.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:62
#, fuzzy
msgid "On the other side, the reactive model relies on non-blocking I/Os and a different execution model.  Non-blocking I/O provides an efficient way to deal with concurrent I/O.  A minimal amount of threads called I/O threads, can handle many concurrent I/O.  With such a model, request processing is not delegated to a worker thread but uses these I/O threads directly.It saves memory and CPU as there is no need to create worker threads to handle the requests.  It also improves the concurrency as it removes the constraint on the number of threads.  Finally, it also improves response time as it reduces the number of thread switches."
msgstr "另一方面，反应式模型依赖于非阻塞的I/O和不同的执行模型。非阻塞I/O为处理并发I/O提供了一种有效的方法。被称为I/O线程的最小数量的线程，可以处理许多并发的I/O。有了这样的模型，请求的处理就不会被委托给工作线程，而是直接使用这些I/O线程。它节省了内存和CPU，因为不需要创建工作线程来处理这些请求。它还改善了并发性，因为它消除了对线程数量的限制。最后，它还改善了响应时间，因为它减少了线程切换的次数。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/getting-started-reactive.adoc:63
#, fuzzy, no-wrap
msgid "Reactive"
msgstr "反应性的"

#. type: Target for macro image
#: upstream/_guides/getting-started-reactive.adoc:63
#, no-wrap
msgid "reactive-thread.png"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:66
#, fuzzy, no-wrap
msgid "From sequential to continuation style"
msgstr "从连续式到延续式"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:72
#, fuzzy
msgid "So, with the reactive execution model, the requests are processed using I/O threads.  But that's not all.  An I/O thread can handle multiple concurrent requests.  How? Here is the trick and one of the most significant differences between reactive and imperative."
msgstr "因此，在反应式执行模式下，请求是使用I/O线程处理的。但这还不是全部。一个I/O线程可以处理多个并发的请求。如何处理？这就是技巧，也是反应式和命令式之间最重要的区别之一。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:78
#, fuzzy
msgid "When processing a request requires interacting with a remote service, like an HTTP API or a database, it does not block the execution while waiting for the response.  Instead, it schedules the I/O operation and attaches a continuation, i.e., the request processing remaining code.  This continuation can be passed as a callback (a function invoked with the I/O outcome), or use more advanced constructs such as reactive programming or co-routines.  Regardless of how the continuation is expressed, the essential aspect is the release of the I/O thread and, as a consequence, the fact that this thread can be used to process another request.  When the scheduled I/O completes, the I/O thread executes the continuation, and the processing of the pending request continues."
msgstr "当处理一个请求需要与一个远程服务（如HTTP API或数据库）进行交互时，它不会在等待响应时阻塞执行。相反，它安排了I/O操作并附加了一个延续，即请求处理的剩余代码。这个延续可以作为回调（用I/O结果调用的函数）传递，或者使用更高级的结构，如反应式编程或联合程序。无论延续是如何表达的，重要的方面是释放I/O线程，以及作为一个结果，这个线程可以被用来处理另一个请求。当预定的I/O完成后，I/O线程执行延续，并继续处理未决请求。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:81
#, fuzzy
msgid "So, unlike the imperative model, where I/O blocks the execution, reactive switches to a continuation-based design, where the I/O threads are released, and continuation invoked when the I/Os complete.  As a result, the I/O thread can handle multiple concurrent requests, improving the overall concurrency of the application."
msgstr "因此，与I/O阻塞执行的命令式模型不同，反应式切换到基于延续的设计，I/O线程被释放，并在I/O完成后调用延续。因此，I/O线程可以处理多个并发请求，提高应用程序的整体并发性。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:86
#, fuzzy
msgid "But, there is a catch.  We need a way to write continuation-passing code.  There are many ways of doing this.  In Quarkus, we propose:"
msgstr "但是，有一个问题。我们需要一种方法来编写继续传递的代码。有很多方法可以做到这一点。在Quarkus中，我们提出。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:88
#, fuzzy
msgid "Mutiny - an intuitive and event-driven reactive programming library"
msgstr "Mutiny - 一个直观的、事件驱动的反应式编程库"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:89
#, fuzzy
msgid "Kotlin co-routines - a way to write asynchronous code in a sequential manner"
msgstr "Kotlin联合程序--一种以顺序方式编写异步代码的方法"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:92
#, fuzzy
msgid "In this guide, we will use Mutiny.  To know more about Mutiny, check the xref:mutiny-primer.adoc[Mutiny documentation]."
msgstr "在本指南中，我们将使用Mutiny。要了解更多关于Mutiny的信息，请查看 link:mutiny-primer.html[Mutiny文档] 。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:95
#, fuzzy
msgid "Project Loom is coming to the JDK soon and proposes a virtual thread-based model.  The Quarkus architecture is ready to support Loom as soon as it's become globally available."
msgstr "Project Loom很快就要进入JDK了，它提出了一个基于虚拟线程的模型。Quarkus架构已经准备好支持Loom，一旦它在全球可用。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:96
#, fuzzy, no-wrap
msgid "Bootstrapping the Reactive Fruits application"
msgstr "引导 \"反应果实 \"应用程序"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:99
#, fuzzy
msgid "With this in mind, let's see how we can develop a CRUD application with Quarkus, which will use the I/O thread to handle the HTTP requests, interact with a database, process the result, and write the HTTP response; in other words: a reactive CRUD application."
msgstr "考虑到这一点，让我们看看如何用Quarkus开发一个CRUD应用程序，它将使用I/O线程来处理HTTP请求，与数据库交互，处理结果，并写入HTTP响应；换句话说：一个反应式CRUD应用程序。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:101
#, fuzzy
msgid "While we recommend you to follow the step-by-step instructions, you can find the final solution on https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-reactive-panache-quickstart."
msgstr "虽然我们建议你按步骤进行，但你可以在 https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-reactive-panache-quickstart ，找到最终解决方案。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:103
#, fuzzy
msgid "First, go to https://code.quarkus.io[code.quarkus.io] and select the following extensions:"
msgstr "首先，进入 link:https://code.quarkus.io[code.quarkus.io] 并选择以下扩展。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:105
#, fuzzy
msgid "RESTEasy Reactive Jackson"
msgstr "RESTEasy 反应型杰克逊"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:106
#, fuzzy
msgid "Hibernate Reactive with Panache"
msgstr "充满魅力的休眠反应式"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:107
#, fuzzy
msgid "Reactive PostgreSQL client"
msgstr "反应式的PostgreSQL客户端"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/getting-started-reactive.adoc:108
#, fuzzy, no-wrap
msgid "Extensions"
msgstr "延伸"

#. type: Target for macro image
#: upstream/_guides/getting-started-reactive.adoc:108
#, no-wrap
msgid "reactive-guide-code.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:112
#, fuzzy
msgid "The last extension is the reactive database driver for PostgreSQL.  Hibernate Reactive uses that driver to interact with the database without blocking the caller thread."
msgstr "最后一个扩展是PostgreSQL的反应式数据库驱动。Hibernate Reactive使用该驱动与数据库交互，而不阻塞调用者线程。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:114
#, fuzzy
msgid "Once selected, click on \"Generate your application\", download the zip file, unzip it and open the code in your favorite IDE."
msgstr "选择后，点击 \"生成你的应用程序\"，下载压缩文件，解压后在你喜欢的IDE中打开代码。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:115
#, fuzzy, no-wrap
msgid "Reactive Panache Entity"
msgstr "反应性的潘奇实体"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:118
#, fuzzy
msgid "Let's start with the `Fruit` entity.Create the `src/main/java/org/acme/hibernate/orm/panache/Fruit.java` file with the following content:"
msgstr "让我们从 `Fruit` 实体开始。创建 `src/main/java/org/acme/hibernate/orm/panache/Fruit.java` 文件，内容如下。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:122
#: upstream/_guides/getting-started-reactive.adoc:183
#, no-wrap
msgid "package org.acme.hibernate.orm.panache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:126
#, no-wrap
msgid ""
"import javax.persistence.Cacheable;\n"
"import javax.persistence.Column;\n"
"import javax.persistence.Entity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:128
#, no-wrap
msgid "import io.quarkus.hibernate.reactive.panache.PanacheEntity;  // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:132
#, no-wrap
msgid ""
"@Entity\n"
"@Cacheable\n"
"public class Fruit extends PanacheEntity {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:135
#, no-wrap
msgid ""
"\t @Column(length = 40, unique = true)\n"
"\t public String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:137
#: upstream/_guides/getting-started-reactive.adoc:192
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:139
#, fuzzy
msgid "Make sure you import the reactive variant of `PanacheEntity`."
msgstr "确保你导入的是 `PanacheEntity` 的反应性变体。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:147
#, fuzzy
msgid "This class represents `Fruits`.  It's a straightforward entity with a single field (`name`).  Note that it uses `io.quarkus.hibernate.reactive.panache.PanacheEntity`, the reactive variant of `PanacheEntity`.  So, behind the scenes, Hibernate uses the execution model we described above.  It interacts with the database without blocking the thread.  In addition, this reactive `PanacheEntity` proposes a reactive API.  We will use this API to implement the REST endpoint."
msgstr "这个类代表了 `Fruits` 。它是一个直接的实体，只有一个字段( `name` )。注意，它使用了 `io.quarkus.hibernate.reactive.panache.PanacheEntity` ，即 `PanacheEntity` 的反应式变体。因此，在幕后，Hibernate使用了我们上面描述的执行模型。它与数据库进行交互而不阻塞线程。此外，这个反应式 `PanacheEntity` ，提出了一个反应式API。我们将使用这个API来实现REST端点。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:149
#, fuzzy
msgid "Before going further, open the `src/main/resource/application.properties` file and add:"
msgstr "在进一步行动之前，打开 `src/main/resource/application.properties` 文件并添加。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:154
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.hibernate-orm.database.generation=drop-and-create\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:157
#, fuzzy
msgid "It instructs the application to use PostgreSQL for the database and to handle the database schema generation."
msgstr "它指示应用程序使用PostgreSQL作为数据库并处理数据库模式的生成。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:159
#, fuzzy
msgid "In the same directory, create an `import.sql` file, which inserts a few fruits, so we don't start with an empty database in dev mode:"
msgstr "在同一目录下，创建一个 `import.sql` 文件，其中插入一些水果，这样我们在开发模式下就不会从一个空数据库开始。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:165
#, no-wrap
msgid ""
"INSERT INTO fruit(id, name) VALUES (nextval('hibernate_sequence'), 'Cherry');\n"
"INSERT INTO fruit(id, name) VALUES (nextval('hibernate_sequence'), 'Apple');\n"
"INSERT INTO fruit(id, name) VALUES (nextval('hibernate_sequence'), 'Banana');\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:169
#, fuzzy
msgid "In a terminal, launch the application in dev mode using: `./mvnw quarkus:dev`.  Quarkus automatically starts a database instance for you and configure the application. Now we only need to implement the HTTP endpoint."
msgstr "在终端中，使用： `./mvnw quarkus:dev` ，在开发模式下启动应用程序。Quarkus会自动为你启动一个数据库实例并配置应用程序。现在我们只需要实现HTTP端点。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:171
#, fuzzy, no-wrap
msgid "Reactive Resource"
msgstr "反应性资源"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:177
#, fuzzy
msgid "Because the interaction with the database is non-blocking and asynchronous, we need to use asynchronous constructs to implement our HTTP resource.  Quarkus uses Mutiny as its central reactive programming model.  So, it supports returning Mutiny types (`Uni` and `Multi`) from HTTP endpoints.  Also, our Fruit Panache entity exposes methods using these types, so we only need to implement the _glue_."
msgstr "因为与数据库的交互是非阻塞和异步的，我们需要使用异步结构来实现我们的HTTP资源。Quarkus使用Mutiny作为其中心反应式编程模型。因此，它支持从HTTP端点返回Mutiny类型（ `Uni` 和 `Multi` ）。而且，我们的Fruit Panache实体暴露了使用这些类型的方法，所以我们只需要实现 _胶水_ 。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:179
#, fuzzy
msgid "Create the `src/main/java/org/acme/hibernate/orm/panache/FruitResource.java` file with the following content:"
msgstr "创建具有以下内容的 `src/main/java/org/acme/hibernate/orm/panache/FruitResource.java` 文件。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:186
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:190
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"@ApplicationScoped\n"
"public class FruitResource {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:196
#, fuzzy
msgid "Let's start with the `getAll` method. The `getAll` method returns all the fruits stored in the database.  In the `FruitResource`, add the following code:"
msgstr "让我们从 `getAll` 方法开始。 `getAll` 方法返回存储在数据库中的所有水果。在 `FruitResource` ，添加以下代码。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:203
#, no-wrap
msgid ""
"@GET\n"
"public Uni<List<Fruit>> get() {\n"
"    return Fruit.listAll(Sort.by(\"name\"));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:206
#, fuzzy
msgid "Open http://localhost:8080/fruits to invoke this method:"
msgstr "打开 http://localhost:8080/fruits 来调用这个方法。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:210
#, no-wrap
msgid "[{\"id\":2,\"name\":\"Apple\"},{\"id\":3,\"name\":\"Banana\"},{\"id\":1,\"name\":\"Cherry\"},{\"id\":4,\"name\":\"peach\"}]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:214
#, fuzzy
msgid "We get the expected JSON array.  RESTEasy Reactive automatically maps the list into a JSON Array, except if instructed otherwise."
msgstr "我们得到预期的JSON数组。除非另有指示，否则RESTEasy Reactive会自动将列表映射成一个JSON数组。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:221
#, fuzzy
msgid "Look at the return type; it returns a `Uni` of `List<Fruit>`.  `Uni` is an asynchronous type.  It's a bit like a future.  It's a placeholder that will get its value (item) later.  When it receives the item (Mutiny says it _emits_ its item), you can attach some behavior.  That's how we express the continuation: get a uni, and when the uni emits its item, execute the rest of the processing."
msgstr "看一下返回类型；它返回一个 `List<Fruit>` 的 `Uni` 。 `Uni` 是一个异步类型。它有点像一个未来。它是一个占位符，以后会得到它的值（项目）。当它收到项目时（Mutiny说它 _发射了_ 它的项目），你可以附加一些行为。这就是我们表达延续的方式：得到一个uni，当uni发出它的项目时，执行其余的处理。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:231
#, fuzzy
msgid "Reactive developers may wonder why we can't return a stream of fruits directly.  It tends to be a bad idea when dealing with a database.  Relational databases do not handle streaming well.  It’s a problem of protocols not designed for this use case.  So, to stream rows from the database, you need to keep a connection (and sometimes a transaction) open until all the rows are consumed.  If you have slow consumers, you break the golden rule of databases: don’t hold connections for too long.  Indeed, the number of connections is rather low, and having consumers keeping them for too long will dramatically reduce the concurrency of your application.  So, when possible, use a `Uni<List<T>>` and load the content.  If you have a large set of results, implement pagination."
msgstr "反应式开发者可能会想，为什么我们不能直接返回水果流呢？在与数据库打交道时，这往往是一个坏主意。关系型数据库不能很好地处理流。这是一个协议的问题，不是为这个用例设计的。所以，要从数据库中流传行，你需要保持一个连接（有时是一个事务），直到所有的行被消耗掉。如果你有缓慢的消费者，你就打破了数据库的黄金法则：不要保持连接时间过长。事实上，连接的数量是相当少的，让消费者保持连接的时间过长会大大降低你的应用程序的并发性。所以，在可能的情况下，使用一个 `Uni<List<T>>` ，并加载内容。如果你有一个大的结果集，实现分页。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:233
#, fuzzy
msgid "Let's continue our API with `getSingle`:"
msgstr "让我们继续我们的API， `getSingle` 。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:241
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/{id}\")\n"
"public Uni<Fruit> getSingle(Long id) {\n"
"    return Fruit.findById(id);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:245
#, fuzzy
msgid "In this case, we use `Fruit.findById` to retrieve the fruit.  It returns a `Uni`, which will complete when the database has retrieved the row."
msgstr "在这种情况下，我们使用 `Fruit.findById` 来检索水果。它返回一个 `Uni` ，当数据库检索到该行时，它将完成。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:247
#, fuzzy
msgid "The `create` method allows adding a new fruit to the database:"
msgstr " `create` 方法允许向数据库添加一个新的水果。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:255
#, no-wrap
msgid ""
"@POST\n"
"public Uni<Response> create(Fruit fruit) {\n"
"    return Panache.<Fruit>withTransaction(fruit::persist)\n"
"            .onItem().transform(inserted -> Response.created(URI.create(\"/fruits/\" + inserted.id)).build());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:264
#, fuzzy
msgid "The code is a bit more involved.  To write to a database, we need a transaction.  So we use `Panache.withTransaction` to get one (asynchronously) and call the `persist` method when we receive the transaction.  The `persist` method is also returning a `Uni`.  This `Uni` emits the result of the insertion of the fruit in the database.  Once the insertion completes (and that's our continuation), we create a `201 CREATED` response.  RESTEasy Reactive automatically reads the request body as JSON and creates the `Fruit` instance."
msgstr "代码就比较麻烦了。要写到数据库，我们需要一个事务。所以我们使用 `Panache.withTransaction` 来获得一个（异步的），当我们收到事务时，调用 `persist` 方法。 `persist` 方法也要返回一个 `Uni` 。这个 `Uni` 发出了在数据库中插入水果的结果。一旦插入完成（这也是我们的延续），我们就创建一个 `201 CREATED` 响应。RESTEasy Reactive会自动将请求体读成JSON，并创建 `Fruit` 实例。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:267
#, fuzzy
msgid "The `.onItem().transform(...)` can be replaced with `.map(...)`.  `map` is a shortcut."
msgstr " `.onItem().transform(…​)` 可以用 `.map(…​)` 代替。 `map` 是一种快捷方式。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:269
#, fuzzy
msgid "If you have https://curl.se/[curl] on your machine, you can try the endpoint using:"
msgstr "如果你的机器上有 link:https://curl.se/[curl] ，你可以用下面的方法试试端点。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:276
#, no-wrap
msgid ""
"> curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"peach\"}' \\\n"
"  http://localhost:8080/fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:279
#, fuzzy
msgid "Following the same ideas, you can implement the other CRUD methods."
msgstr "按照同样的思路，你可以实现其他CRUD方法。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:280
#, fuzzy, no-wrap
msgid "Testing and Running"
msgstr "测试和运行"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:284
#, fuzzy
msgid "Testing a reactive application is similar to testing a non-reactive one: use the HTTP endpoint and verify the HTTP responses.  The fact that the application is reactive does not change anything."
msgstr "测试一个反应式应用程序与测试一个非反应式应用程序相似：使用HTTP端点并验证HTTP响应。应用程序是反应式的这一事实并没有改变什么。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:286
#, fuzzy
msgid "In https://github.com/quarkusio/quarkus-quickstarts/blob/main/hibernate-reactive-panache-quickstart/src/test/java/org/acme/hibernate/orm/panache/FruitsEndpointTest.java[FruitsEndpointTest.java] you can see how the test for the fruit application can be implemented."
msgstr "在 link:https://github.com/quarkusio/quarkus-quickstarts/blob/main/hibernate-reactive-panache-quickstart/src/test/java/org/acme/hibernate/orm/panache/FruitsEndpointTest.java[FruitsEndpointTest.java] 中，你可以看到如何实现对水果应用的测试。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:288
#, fuzzy
msgid "Packaging and running the application does not change either."
msgstr "包装和运行应用程序也不会改变。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:290
#, fuzzy
msgid "You can use the following command as usual:"
msgstr "你可以像往常一样使用以下命令。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:294
#, fuzzy
msgid "or to build a native executable:"
msgstr "或构建一个本地可执行文件。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:298
#, fuzzy
msgid "You can also package the application in a container."
msgstr "你也可以将应用程序打包在一个容器中。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:300
#, fuzzy
msgid "To run the application, don’t forget to start a database and provide the configuration to your application."
msgstr "要运行应用程序，不要忘记启动数据库并为你的应用程序提供配置。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:302
#, fuzzy
msgid "For example, you can use Docker to run your database:"
msgstr "例如，你可以使用Docker来运行你的数据库。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:309
#, no-wrap
msgid ""
"docker run -it --rm=true \\\n"
"    --name postgres-quarkus -e POSTGRES_USER=quarkus \\\n"
"    -e POSTGRES_PASSWORD=quarkus -e POSTGRES_DB=fruits \\\n"
"    -p 5432:5432 postgres:14.1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:312
msgid "Then, launch the application using:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:320
#, no-wrap
msgid ""
"java \\\n"
"   -Dquarkus.datasource.reactive.url=postgresql://localhost/fruits \\\n"
"   -Dquarkus.datasource.username=quarkus \\\n"
"   -Dquarkus.datasource.password=quarkus \\\n"
"   -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:323
msgid "Or, if you packaged your application as native executable, use:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:331
#, no-wrap
msgid ""
"./target/getting-started-with-reactive-runner \\\n"
"  -Dquarkus.datasource.reactive.url=postgresql://localhost/fruits \\\n"
"  -Dquarkus.datasource.username=quarkus \\\n"
"  -Dquarkus.datasource.password=quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:335
msgid "The parameters passed to the application are described in the datasource guide.  There are other ways to configure the application - please check the xref:config-reference.adoc#configuration_sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on)."
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:336
#, no-wrap
msgid "Going further"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:340
msgid "This guide is a brief introduction to some reactive features offered by Quarkus.  Quarkus is a reactive framework, and so offers a lot of reactive features."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:342
msgid "If you want to continue on this topic check:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:344
msgid "xref:quarkus-reactive-architecture.adoc[The Quarkus Reactive Architecture]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:345
msgid "xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]"
msgstr ""
