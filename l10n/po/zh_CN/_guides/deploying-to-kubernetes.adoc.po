# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-12-06 10:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Kubernetes extension"
msgstr "Kubernetes扩展"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Quarkus offers the ability to automatically generate Kubernetes resources based on sane defaults and user-supplied configuration using https://github.com/dekorateio/dekorate/[dekorate].\n"
"It currently supports generating resources for vanilla <<#kubernetes,Kubernetes>>, <<#openshift,OpenShift>> and <<#knative,Knative>>.\n"
"Furthermore, Quarkus can deploy the application to a target Kubernetes cluster by applying the generated manifests to the target cluster's API Server.\n"
"Finally, when either one of container image extensions is present (see the xref:container-image.adoc[container image guide] for more details), Quarkus has the ability to create a container image and push it to a registry *before* deploying the application to the target platform."
msgstr "Quarkus 提供了使用 link:https://github.com/dekorateio/dekorate/[dekorate] 根据正常默认值和用户提供的配置自动生成 Kubernetes 资源的功能。它目前支持为 vanilla xref:kubernetes[Kubernetes] 、 xref:openshift[OpenShift] 和 xref:knative[Knative] 生成资源。此外，Quarkus 还能将生成的清单应用到目标集群的 API 服务器，从而将应用部署到目标 Kubernetes 集群。最后，如果存在容器镜像扩展（详见 xref:container-image.adoc[容器镜像指南] ），Quarkus 还能创建容器镜像，并 *在* 将应用部署到目标平台 *之前* 将其推送到注册表。"

#. type: Title ==
#: _guides/deploying-to-kubernetes.adoc
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Access to a Kubernetes cluster (Minikube is a viable option)"
msgstr "访问一个Kubernetes集群（Minikube是一个可行的选择）"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Kubernetes"
msgstr "库伯内特斯"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Let's create a new project that contains both the Kubernetes and Jib extensions:"
msgstr "让我们创建一个新的项目，包含Kubernetes和Jib扩展。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "This added the following dependencies to the build file:"
msgstr "这在构建文件中添加了以下依赖项。"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"By adding these dependencies, we enable the generation of Kubernetes manifests each time we perform a build while also enabling the build of a container image using Jib.\n"
"For example, following the execution of:"
msgstr "通过添加这些依赖项，我们就能在每次执行构建时生成 Kubernetes 清单，同时还能使用 Jib 构建容器映像。例如，在执行"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"you will notice amongst the other files that are created, two files named\n"
"`kubernetes.json` and `kubernetes.yml` in the `target/kubernetes/` directory."
msgstr "在创建的其他文件中，你会发现 `target/kubernetes/` 目录中有两个名为 `kubernetes.json` 和 `kubernetes.yml` 的文件。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "If you look at either file you will see that it contains both a Kubernetes `Deployment` and a `Service`."
msgstr "如果你看一下这两个文件，你会发现它同时包含一个Kubernetes `Deployment` 和一个 `Service` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The full source of the `kubernetes.json` file looks something like this:"
msgstr " `kubernetes.json` 文件的完整来源看起来是这样的。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The generated manifest can be applied to the cluster from the project root using `kubectl`:"
msgstr "生成的清单可以使用 `kubectl` ，从项目根部应用到集群。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"An important thing to note about the `Deployment` (or `StatefulSet`) is that is uses `yourDockerUsername/test-quarkus-app:1.0.0-SNAPSHOT` as the container image of the `Pod`.\n"
"The name of the image is controlled by the Jib extension and can be customized using the usual `application.properties`."
msgstr "关于 `Deployment` （或 `StatefulSet` ），需要注意的一点是，它使用 `yourDockerUsername/test-quarkus-app:1.0.0-SNAPSHOT` 作为 `Pod` 的容器图像。图像名称由 Jib 扩展名控制，可使用常用的 `application.properties` 进行自定义。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For example with a configuration like:"
msgstr "例如，用这样的配置。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The image that will be used in the generated manifests will be `quarkus/demo-app:1.0`"
msgstr "生成的清单中使用的图像将是 `quarkus/demo-app:1.0` "

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Generating idempotent resources"
msgstr "利用现有资源"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "When generating the Kubernetes manifests, Quarkus automatically adds some labels and annotations to give extra information about the generation date or versions. For example:"
msgstr "在生成Kubernetes清单时，Quarkus会自动添加一些标签和注解，以提供关于生成日期或版本的额外信息。比如说："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The `app.quarkus.io/commit-id`, `app.quarkus.io/build-timestamp` labels and the `app.kubernetes.io/version` annotation might change every time we re-build the Kubernetes manifests which can be problematic when we want to deploy these resources using a Git-Ops tool (because these tools will detect differences and hence will perform a re-deployment)."
msgstr "每次我们重新构建Kubernetes清单时， `app.quarkus.io/commit-id` , `app.quarkus.io/build-timestamp` 标签和 `app.kubernetes.io/version` 注释都可能发生变化，当我们想使用Git-Ops工具部署这些资源时，就会出现问题（因为这些工具会检测到差异，因此会执行重新部署）。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To make the generated resources Git-Ops friendly and only produce idempotent resources (resources that won't change every time we build the sources), we need to add the following property:"
msgstr "为了使生成的资源对Git-Ops友好，并且只产生idempotent资源（每次构建源时不会改变的资源），我们需要添加以下属性："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Moreover, by default the directory where the generated resources are created is `target/kubernetes`, to change it, we need to use:"
msgstr "此外，默认情况下，生成资源的目录是 `target/kubernetes` ，要改变它，我们需要使用："

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Note that the property `quarkus.kubernetes.output-directory` is relative to the current project location."
msgstr "注意，属性 `quarkus.kubernetes.output-directory` ，是相对于当前项目位置而言的。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Changing the generated deployment resource"
msgstr "要在生成的资源中添加一个标签。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Besides generating a `Deployment` resource, you can also choose to generate either a `StatefulSet`, or a `Job`, or a `CronJob` resource instead via `application.properties`:"
msgstr "除了生成一个 `Deployment` ，你还可以选择通过 `application.properties` ，获得一个 `StatefulSet` 。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Generating Job resources"
msgstr "生成工作资源"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "If you want to generate a Job resource, you need to add the following property to the `application.properties`:"
msgstr "要在您的清单中指定命名空间，请在您的 `application.properties` 中定制以下属性。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "If you are using the Picocli extension, by default a Job resource will be generated."
msgstr "如果你使用Picocli扩展，默认情况下将会生成一个Job资源。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "You can provide the arguments that will be used by the Kubernetes Job via the property `quarkus.kubernetes.arguments`. For example, by adding the property `quarkus.kubernetes.arguments=A,B`."
msgstr "你可以通过属性 `quarkus.kubernetes.arguments` ，提供将被Kubernetes作业使用的参数。例如，通过添加属性 `quarkus.kubernetes.arguments=A,B` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Finally, the Kubernetes job will be launched every time it is installed in Kubernetes. You can know more about how to run Kubernetes jobs in this https://kubernetes.io/docs/concepts/workloads/controllers/job/#running-an-example-job[link]."
msgstr "最后，每次在Kubernetes中安装Kubernetes作业时，都会启动它。你可以在这个 link:https://kubernetes.io/docs/concepts/workloads/controllers/job/#running-an-example-job[链接] 中了解更多关于如何运行Kubernetes作业。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "You can configure the rest of the Kubernetes Job configuration using the properties under `quarkus.kubernetes.job.xxx` (see xref:deploying-to-kubernetes.adoc#quarkus-kubernetes-kubernetes-config_quarkus-kubernetes-job-parallelism[link])."
msgstr "您可以使用 `quarkus.kubernetes.job.xxx` 下的属性配置 Kubernetes Job 配置的其余部分（请参阅 xref:deploying-to-kubernetes.adoc#quarkus-kubernetes-kubernetes-config_quarkus-kubernetes-job-parallelism[链接] ）。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Generating CronJob resources"
msgstr "生成CronJob资源"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "If you want to generate a CronJob resource, you need to add the following property via the `application.properties`:"
msgstr "如果你想生成一个CronJob资源，你需要通过 `application.properties` ，添加以下属性。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "CronJob resources require the https://en.wikipedia.org/wiki/Cron[Cron] expression to specify when to launch the job via the property `quarkus.kubernetes.cron-job.schedule`. If not provide, the build will fail."
msgstr "CronJob资源要求 link:https://en.wikipedia.org/wiki/Cron[Cron] 表达式通过属性 `quarkus.kubernetes.cron-job.schedule` ，指定何时启动作业。如果不提供，构建将失败。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "You can configure the rest of the Kubernetes CronJob configuration using the properties under `quarkus.kubernetes.cron-job.xxx` (see xref:deploying-to-kubernetes.adoc#quarkus-kubernetes-kubernetes-config_quarkus-kubernetes-cron-job-parallelism[link])."
msgstr "您可以使用 `quarkus.kubernetes.cron-job.xxx` 下的属性配置 Kubernetes CronJob 配置的其余部分（请参阅 xref:deploying-to-kubernetes.adoc#quarkus-kubernetes-kubernetes-config_quarkus-kubernetes-cron-job-parallelism[链接] ）。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Namespace"
msgstr "名称空间"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "By default, Quarkus omits the namespace in the generated manifests, rather than enforce the `default` namespace. That means that you can apply the manifest to your chosen namespace when using `kubectl`, which in the example below is `test`:"
msgstr "默认情况下，Quarkus在生成的清单中省略了命名空间，而不是强制使用 `default` 命名空间。这意味着，在使用 `kubectl` 时，您可以将清单应用于您所选择的命名空间，在下面的例子中，命名空间是 `test` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To specify the namespace in your manifest customize with the following property in your `application.properties`:"
msgstr "要在您的清单中指定命名空间，请在您的 `application.properties` 中定制以下属性。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Defining a Docker registry"
msgstr "定义一个Docker注册表"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The Docker registry can be specified with the following property:"
msgstr "Docker注册表可以通过以下属性指定。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"By adding this property along with the rest of the container image properties of the previous section, the generated manifests will use the image `my.docker-registry.net/quarkus/demo-app:1.0`.\n"
"The image is not the only thing that can be customized in the generated manifests, as will become evident in the following sections."
msgstr "通过将此属性与上一节中的其他容器映像属性一起添加，生成的清单将使用映像 `my.docker-registry.net/quarkus/demo-app:1.0` 。图像并不是生成的清单中唯一可以定制的内容，这一点在下面的章节中将会变得很明显。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Automatic generation of pull secrets"
msgstr "自动生成提取机密"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "When docker registries are used, users often provide credentials, so that an image is built and pushed to the specified registry during the build."
msgstr "在使用 docker 注册表时，用户通常会提供凭据，以便在构建过程中构建镜像并推送到指定的注册表。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Kubernetes will also need these credentials when it comes to pull the image from the registry. This is where image pull secrets are used. An image pull secret is a special kind\n"
"of secret that contains the required credentials. Quarkus can automatically generate and configure when:"
msgstr "Kubernetes 从注册表中提取映像时也需要这些凭证。这就是图像拉取密文的用途。图像拉取秘钥是一种特殊的秘钥，其中包含所需的凭证。Quarkus 可以自动生成和配置："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "More specifically a `Secret`like the one bellow is genrated:"
msgstr "更具体地说，就是像下面这样的 \"秘密\"："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "And also `test-quarkus-app-pull-secret` is added to the `imagePullSecrets` list."
msgstr "此外， `test-quarkus-app-pull-secret` 也加入了 `imagePullSecrets` 名单。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Labels and Annotations"
msgstr "标签和注解"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Labels"
msgstr "标签"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"The generated manifests use the Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[recommended labels].\n"
"These labels can be customized using `quarkus.kubernetes.name`, `quarkus.kubernetes.version` and `quarkus.kubernetes.part-of`.\n"
"For example by adding the following configuration to your `application.properties`:"
msgstr "生成的清单使用 Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[推荐的标签] 。这些标签可使用 `quarkus.kubernetes.name` 、 `quarkus.kubernetes.version` 和 `quarkus.kubernetes.part-of` 进行自定义。例如，在 `application.properties` 中添加以下配置："

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"As is described in detail in the <<#openshift, OpenShift>> section, customizing OpenShift (or Knative) properties is done in the same way, but replacing\n"
"`kubernetes` with `openshift` (or `knative`). The previous example for OpenShift would look like this:"
msgstr "正如 xref:openshift[OpenShift] 部分所详细描述的，自定义 OpenShift（或 Knative）属性的方法与此相同，只是将 `kubernetes` 替换为 `openshift` （或 `knative` ）。之前的 OpenShift 示例如下："

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The labels in generated resources will look like:"
msgstr "生成的资源中的标签将看起来像。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "You can also remove the `app.kubernetes.io/version` label by applying the following configuration:"
msgstr "你也可以通过应用以下配置删除 `app.kubernetes.io/version` 标签。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Custom Labels"
msgstr "定制标签"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To add additional custom labels, for example `foo=bar` just apply the following configuration:"
msgstr "要添加额外的自定义标签，例如 `foo=bar` ，只需应用以下配置。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "When using the `quarkus-container-image-jib` extension to build a container image, then any label added via the aforementioned property will also be added to the generated container image."
msgstr "当使用 `quarkus-container-image-jib` 扩展来建立一个容器镜像时，那么通过上述属性添加的任何标签也将被添加到生成的容器镜像中。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Annotations"
msgstr "注释"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Out of the box, the generated resources will be annotated with version control related information that can be used either by tooling, or by the user for troubleshooting purposes."
msgstr "开箱即用，生成的资源将被注释上与版本控制相关的信息，这些信息既可以被工具使用，也可以被用户用于故障排除的目的。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Custom Annotations"
msgstr "自定义注解"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Custom annotations can be added in a way similar to labels.For example to add the annotation `foo=bar` and `app.quarkus/id=42` just apply the following configuration:"
msgstr "自定义注解的添加方式与标签类似。例如，要添加注解 `foo=bar` 和 `app.quarkus/id=42` ，只需应用以下配置。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Environment variables"
msgstr "环境变量"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Kubernetes provides multiple ways of defining environment variables:"
msgstr "Kubernetes提供了多种定义环境变量的方法。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "key/value pairs"
msgstr "键/值对"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "import all values from a Secret or ConfigMap"
msgstr "从一个Secret或ConfigMap中导入所有值"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "interpolate a single value identified by a given field in a Secret or ConfigMap"
msgstr "内插一个由Secret或ConfigMap中给定字段识别的单一值"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "interpolate a value from a field within the same resource"
msgstr "从同一资源中的一个字段中插值"

#. type: Title =====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Environment variables from key/value pairs"
msgstr "来自键/值对的环境变量"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To add a key/value pair as an environment variable in the generated resources:"
msgstr "要在生成的资源中添加一个键/值对作为环境变量。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"The command above will add `MY_ENV_VAR=foobar` as an environment variable.\n"
"Please note that the key `my-env-var` will be converted to uppercase and dashes will be replaced by underscores resulting in `MY_ENV_VAR`."
msgstr "上述命令将把 `MY_ENV_VAR=foobar` 添加为环境变量。请注意，关键字 `my-env-var` 将被转换为大写字母，破折号将被下划线替换，结果是 `MY_ENV_VAR` 。"

#. type: Title =====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Environment variables from Secret"
msgstr "来自Secret的环境变量"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"To add all key/value pairs of `Secret` as environment variables just apply the following configuration, separating each `Secret`\n"
"to be used as source by a comma (`,`):"
msgstr "要将 `Secret` 的所有键/值对添加为环境变量，只需应用以下配置，用逗号（ `,` ）分隔每个用作源的 `Secret` ："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "which would generate the following in the container definition:"
msgstr "这将在容器定义中产生以下内容。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The following extracts a value identified by the `keyName` field from the `my-secret` Secret into a `foo` environment variable:"
msgstr "下面从 `my-secret` 秘密中提取一个由 `keyName` 字段标识的值到一个 `foo` 环境变量中。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "This would generate the following in the `env` section of your container:"
msgstr "这将在你的容器的 `env` 部分产生以下内容。"

#. type: Title =====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Environment variables from ConfigMap"
msgstr "来自ConfigMap的环境变量"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"To add all key/value pairs from `ConfigMap` as environment variables just apply the following configuration, separating each\n"
"`ConfigMap` to be used as source by a comma (`,`):"
msgstr "要将 `ConfigMap` 中的所有键/值对添加为环境变量，只需应用以下配置，在每个 `ConfigMap` 之间用逗号隔开 ( `,` )："

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"The following extracts a value identified by the `keyName` field from the `my-config-map` ConfigMap into a `foo`\n"
"environment variable:"
msgstr "下文将 `keyName` 字段标识的值从 `my-config-map` ConfigMap 提取到 `foo` 环境变量中："

#. type: Title =====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Environment variables from fields"
msgstr "来自字段的环境变量"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "It's also possible to use the value from another field to add a new environment variable by specifying the path of the field to be used as a source, as follows:"
msgstr "也可以使用另一个字段的值来添加一个新的环境变量，指定字段的路径作为来源，如下所示。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"As is described in detail in the <<#openshift, OpenShift>> section, customizing OpenShift properties is done in the same way, but replacing\n"
"`kubernetes` with `openshift`. The previous example for OpenShift would look like this:"
msgstr "正如 xref:openshift[OpenShift] 部分所详细介绍的，自定义 OpenShift 属性的方法与此相同，只是将 `kubernetes` 替换为 `openshift` 。之前的 OpenShift 示例如下："

#. type: Title =====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Validation"
msgstr "审定"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "A conflict between two definitions, e.g. mistakenly assigning both a value and specifying that a variable is derived from a field, will result in an error being thrown at build time so that you get the opportunity to fix the issue before you deploy your application to your cluster where it might be more difficult to diagnose the source of the issue."
msgstr "两个定义之间的冲突，例如错误地同时赋值和指定一个变量来自一个字段，将导致在构建时抛出一个错误，这样你就有机会在将你的应用程序部署到你的集群上之前修复这个问题，因为在那里可能更难诊断出问题的来源。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Similarly, two redundant definitions, e.g. defining an injection from the same secret twice, will not cause an issue but will indeed report a warning to let you know that you might not have intended to duplicate that definition."
msgstr "同样地，两个多余的定义，例如从同一个秘密中定义两次注入，不会引起问题，但确实会报告一个警告，让你知道你可能没有打算重复这个定义。"

#. type: Title =====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Backwards compatibility"
msgstr "向后兼容"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Previous versions of the Kubernetes extension supported a different syntax to add environment variables. The older syntax is still supported but is deprecated, and it's advised that you migrate to the new syntax."
msgstr "以前版本的Kubernetes扩展支持不同的语法来添加环境变量。旧的语法仍被支持，但已被废弃，建议你迁移到新的语法。"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Old vs. new syntax"
msgstr "旧语法与新语法"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Old"
msgstr "旧的"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "New"
msgstr "新的"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Plain variable"
msgstr "普通变量"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env-vars.my-env-var.value=foobar`"
msgstr " `quarkus.kubernetes.env-vars.my-env-var.value=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env.vars.my-env-var=foobar`"
msgstr " `quarkus.kubernetes.env.vars.my-env-var=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "From field"
msgstr "来自外地的"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env-vars.my-env-var.field=foobar`"
msgstr " `quarkus.kubernetes.env-vars.my-env-var.field=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env.fields.my-env-var=foobar`"
msgstr " `quarkus.kubernetes.env.fields.my-env-var=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "All from `ConfigMap`"
msgstr "全部来自 `ConfigMap` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env-vars.xxx.configmap=foobar`"
msgstr " `quarkus.kubernetes.env-vars.xxx.configmap=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env.configmaps=foobar`"
msgstr " `quarkus.kubernetes.env.configmaps=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "All from `Secret`"
msgstr "全部来自 `Secret` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env-vars.xxx.secret=foobar`"
msgstr " `quarkus.kubernetes.env-vars.xxx.secret=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env.secrets=foobar`"
msgstr " `quarkus.kubernetes.env.secrets=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "From one `Secret` field"
msgstr "从一个 `Secret` 场"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env-vars.foo.secret=foobar`"
msgstr " `quarkus.kubernetes.env-vars.foo.secret=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env.mapping.foo.from-secret=foobar`"
msgstr " `quarkus.kubernetes.env.mapping.foo.from-secret=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env-vars.foo.value=field`"
msgstr " `quarkus.kubernetes.env-vars.foo.value=field` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env.mapping.foo.with-key=field`"
msgstr " `quarkus.kubernetes.env.mapping.foo.with-key=field` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "From one `ConfigMap` field"
msgstr "从一个 `ConfigMap` 场"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env-vars.foo.configmap=foobar`"
msgstr " `quarkus.kubernetes.env-vars.foo.configmap=foobar` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`quarkus.kubernetes.env.mapping.foo.from-configmap=foobar`"
msgstr " `quarkus.kubernetes.env.mapping.foo.from-configmap=foobar` "

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"If you redefine the same variable using the new syntax while keeping the old syntax, **ONLY** the new version will be kept\n"
"and a warning will be issued to alert you of the problem.For example, if you define both\n"
"`quarkus.kubernetes.env-vars.my-env-var.value=foobar` and `quarkus.kubernetes.env.vars.my-env-var=newValue`, the extension will\n"
"only generate an environment variable `MY_ENV_VAR=newValue` and issue a warning."
msgstr "例如，如果您同时定义了 `quarkus.kubernetes.env-vars.my-env-var.value=foobar` 和 `quarkus.kubernetes.env.vars.my-env-var=newValue` ，扩展程序将 *只* 生成一个环境变量 `MY_ENV_VAR=newValue` 并发出警告。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Mounting volumes"
msgstr "安装量"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"The Kubernetes extension allows the user to configure both volumes and mounts for the application.\n"
"Any volume can be mounted with a simple configuration:"
msgstr "Kubernetes 扩展允许用户为应用程序配置卷和挂载。只需简单配置，即可挂载任何卷："

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"This will add a mount to the pod for volume `my-volume` to path `/where/to/mount`.\n"
"The volumes themselves can be configured as shown in the sections below."
msgstr "这将为卷 `my-volume` 添加挂载到 pod 的路径 `/where/to/mount` 。卷本身可按以下部分所示进行配置。"

#. type: Title =====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Secret volumes"
msgstr "秘密卷"

#. type: Title =====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "ConfigMap volumes"
msgstr "配置图卷"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Passing application configuration"
msgstr "传递应用程序配置"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Quarkus supports passing configuration from external locations (via Smallrye Config). This usually requires setting an additional environment variable or system property.\n"
"When you need to use a secret or a config map for the purpose of application configuration, you need to:"
msgstr "Quarkus 支持从外部位置传递配置（通过 Smallrye Config）。这通常需要设置额外的环境变量或系统属性。当你需要在应用程序配置中使用秘密或配置映射时，你需要这样做："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "define a volume"
msgstr "定义一个体积"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "mount the volume"
msgstr "挂载该卷"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "create an environment variable for `SMALLRYE_CONFIG_LOCATIONS`"
msgstr "创建一个环境变量用于 `SMALLRYE_CONFIG_LOCATIONS` "

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To simplify things, quarkus provides single step alternative:"
msgstr "为了简化事情，quarkus提供了单一步骤的选择。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "or"
msgstr "或"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"When these properties are used, the generated manifests will contain everything required.\n"
"The application config volumes will be created using path: `/mnt/app-secret` and `/mnt/app-config-map` for secrets and configmaps respectively."
msgstr "使用这些属性时，生成的清单将包含所需的一切内容。应用程序配置卷将使用以下路径创建： `/mnt/app-secret` 和 `/mnt/app-config-map` ，分别用于秘密和配置映射。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Note: Users may use both properties at the same time."
msgstr "注意：用户可以同时使用这两个属性。"

#: _guides/deploying-to-kubernetes.adoc
msgid "Changing the number of replicas"
msgstr ""

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To change the number of replicas from 1 to 3:"
msgstr "要将复制的数量从1改为3。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Add readiness and liveness probes"
msgstr "添加就绪性和有效性探针"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "By default, the Kubernetes resources do not contain readiness and liveness probes in the generated `Deployment`. Adding them however is just a matter of adding the SmallRye Health extension like so:"
msgstr "默认情况下，Kubernetes资源在生成的 `Deployment` ，不包含就绪性和有效性探测。然而，添加它们只需像这样添加SmallRye Health扩展即可。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"The values of the generated probes will be determined by the configured health properties: `quarkus.smallrye-health.root-path`, `quarkus.smallrye-health.liveness-path` and `quarkus.smallrye-health.readiness-path`.\n"
"More information about the health extension can be found in the relevant xref:smallrye-health.adoc[guide]."
msgstr "生成的探针值将由配置的健康属性决定： `quarkus.smallrye-health.root-path` , `quarkus.smallrye-health.liveness-path` 和 `quarkus.smallrye-health.readiness-path` 。有关健康扩展的更多信息，请参阅相关 xref:smallrye-health.adoc[指南] 。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Customizing the readiness probe"
msgstr "定制准备好的探头。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To set the initial delay of the probe to 20 seconds and the period to 45:"
msgstr "将探头的初始延迟设置为20秒，周期为45。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Add hostAliases"
msgstr "添加hostAliases"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To add entries to a Pod's `/etc/hosts` file (more information can be found in https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/[Kubernetes documentation]), just apply the following configuration:"
msgstr "要向Pod的 `/etc/hosts` 文件添加条目（更多信息可在 link:https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/[Kubernetes文档] 中找到），只需应用以下配置。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "This would generate the following `hostAliases` section in the `deployment` definition:"
msgstr "这将在 `deployment` 定义中产生以下 `hostAliases` 部分。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Container Resources Management"
msgstr "容器资源管理"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "CPU & Memory limits and requests can be applied to a `Container` (more info in https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/[Kubernetes documentation]) using the following configuration:"
msgstr "可以使用以下配置将CPU和内存限制和请求应用到 `Container` （更多信息见 link:https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/[Kubernetes文档] ）。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "This would generate the following entry in the `container` section:"
msgstr "这将在 `container` 部分产生以下条目。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Exposing your application in Kubernetes"
msgstr "在Kubernetes中公开你的应用程序"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Kubernetes exposes applications using https://kubernetes.io/docs/concepts/services-networking/ingress[Ingress resources]. To generate the Ingress resource, just apply the following configuration:"
msgstr "要向Pod的 `/etc/hosts` 文件添加条目（更多信息可在 link:https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/[Kubernetes文档] 中找到），只需应用以下配置。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "This would generate the following Ingress resource:"
msgstr "这将在你的容器的 `env` 部分产生以下内容。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "After deploying these resources to Kubernetes, the Ingress resource will allow unsecured connections to reach out your application."
msgstr "将这些资源部署到Kubernetes后，Ingress资源将允许不安全的连接到达你的应用程序。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Adding Ingress rules"
msgstr "额外资源"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To customize the default `host` and `path` properties of the generated Ingress resources, you need to apply the following configuration:"
msgstr "要自定义生成的Ingress资源的默认 `host` 和 `path` 属性，你需要应用以下配置。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Additionally, you can also add new Ingress rules by adding the following configuration:"
msgstr "你也可以通过应用以下配置删除 `app.kubernetes.io/version` 标签。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Securing the Ingress resource"
msgstr "利用现有资源"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To secure the incoming connections, Kubernetes allows enabling https://kubernetes.io/docs/concepts/services-networking/ingress/#tls[TLS] within the Ingress resource by specifying a Secret that contains a TLS private key and certificate. You can generate a secured Ingress resource by simply adding the \"tls.secret-name\" properties:"
msgstr "为了保证传入连接的安全，Kubernetes允许在Ingress资源中启用 link:https://kubernetes.io/docs/concepts/services-networking/ingress/#tls[TLS] ，方法是指定一个包含TLS私钥和证书的秘密。你可以通过简单地添加 \"tls.secret-name \"属性来生成一个安全的Ingress资源。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "This configuration will generate the following secured Ingress resource:"
msgstr "这将在 `container` 部分产生以下条目。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Now, Kubernetes will validate all the incoming connections using SSL with the certificates provided within the secret with name \"my-secret\"."
msgstr "现在，Kubernetes将使用SSL验证所有传入的连接，并使用在名称为 \"my-secret \"的秘密中提供的证书。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "More information about how to create the secret in https://kubernetes.io/docs/concepts/services-networking/ingress/#tls[here]."
msgstr "更多关于如何在 link:https://kubernetes.io/docs/concepts/services-networking/ingress/#tls[这里] 创建秘密的信息。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Using the Kubernetes client"
msgstr "使用Kubernetes客户端"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Applications that are deployed to Kubernetes and need to access the API server will usually make use of the `kubernetes-client` extension:"
msgstr "部署到Kubernetes并需要访问API服务器的应用程序通常会利用 `kubernetes-client` 扩展。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"To access the API server from within a Kubernetes cluster, some RBAC related resources are required (e.g. a ServiceAccount, a RoleBinding).\n"
"To ease the usage of the `kubernetes-client` extension, the `kubernetes` extension is going to generate a RoleBinding resource that binds a cluster role named \"view\" to the application ServiceAccount resource. It's important to note that the cluster role \"view\" won't be generated automatically, so it's expected that you have this cluster role with name \"view\" already installed in your cluster."
msgstr "要从 Kubernetes 集群访问 API 服务器，需要一些与 RBAC 相关的资源（如 ServiceAccount、RoleBinding）。为了简化 `kubernetes-client` 扩展的使用， `kubernetes` 扩展将生成一个 RoleBinding 资源，将名为 \"view \"的群集角色绑定到应用程序的 ServiceAccount 资源上。需要注意的是，集群角色 \"view \"不会自动生成，因此预计您的集群中已经安装了名称为 \"view \"的集群角色。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "On the other hand, you can fully customize the roles, subjects and role bindings to generate using the properties under `quarkus.kubernetes.rbac.role-bindings`, and if present, the `kubernetes-client` extension will use it and hence won't generate any RoleBinding resource."
msgstr "另一方面，你可以使用 `quarkus.kubernetes.rbac.role-bindings` 下的属性完全定制要生成的角色、主题和角色绑定，如果存在， `kubernetes-client` 扩展将使用它，因此不会生成任何RoleBinding资源。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "You can disable the RBAC resources generation using the property `quarkus.kubernetes-client.generate-rbac=false`."
msgstr "你可以使用属性 `quarkus.kubernetes-client.generate-rbac=false` 停用RBAC资源的生成。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Generating RBAC resources"
msgstr "利用现有资源"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "In some scenarios, it's necessary to generate additional https://kubernetes.io/docs/reference/access-authn-authz/rbac/[RBAC] resources that are used by Kubernetes to grant or limit access to other resources. For example, in our use case, we are building https://kubernetes.io/docs/concepts/extend-kubernetes/operator/#operators-in-kubernetes[a Kubernetes operator] that needs to read the list of the installed deployments. To do this, we would need to assign a service account to our operator and link this service account with a role that grants access to the Deployment resources. Let's see how to do this using the `quarkus.kubernetes.rbac` properties:"
msgstr "在某些情况下，有必要生成额外的 link:https://kubernetes.io/docs/reference/access-authn-authz/rbac/[RBAC] 资源，由Kubernetes用于授予或限制对其他资源的访问。例如，在我们的用例中，我们正在建立 link:https://kubernetes.io/docs/concepts/extend-kubernetes/operator/#operators-in-kubernetes[一个Kubernetes操作员] ，需要读取已安装的部署列表。要做到这一点，我们需要为我们的操作员分配一个服务账户，并将这个服务账户与一个授予访问部署资源的角色联系起来。让我们看看如何使用 `quarkus.kubernetes.rbac` 属性来做到这一点："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "In this example, the role \"my-role\" will be generated with a policy rule to get the list of deployments."
msgstr "在这个例子中，角色 \"my-role \"将被生成一个策略规则，以获得部署的列表。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "By default, if one role is configured, a RoleBinding resource will be generated as well to link this role with the ServiceAccount resource."
msgstr "默认情况下，如果配置了一个角色，也将生成一个RoleBinding资源，以将这个角色与ServiceAccount资源联系起来。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Moreover, you can have more control over the RBAC resources to be generated:"
msgstr "此外，您还可以对将要生成的 RBAC 资源进行更多控制："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "In this example, the role \"my-role\" will be generated with the specified policy rules."
msgstr "在本例中，将根据指定的策略规则生成角色 \"my-role\"。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Also, the service account \"my-service-account\" will be generated."
msgstr "此外，还将生成服务账户 \"my-service-account\"。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "And we can configure the generated RoleBinding resource by selecting the role to be used and the subject."
msgstr "我们可以通过选择要使用的角色和主题来配置生成的 RoleBinding 资源。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Finally, we can also generate the cluster wide role resource of \"ClusterRole\" kind and a \"ClusterRoleBinding\" resource as follows:"
msgstr "最后，我们还可以生成 \"ClusterRole \"类型的全集群角色资源和一个 \"ClusterRoleBinding \"资源，如下所示："

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "In this example, the cluster role \"my-cluster-role\" will be generated with the specified policy rules."
msgstr "在此示例中，将使用指定的策略规则生成群集角色 \"my-cluster-role\"。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The name of the ClusterRole resource to use. Role resources are namespace-based and hence not allowed in ClusterRoleBinding resources."
msgstr "要使用的 ClusterRole 资源的名称。角色资源基于名称空间，因此不允许在 ClusterRoleBinding 资源中使用。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Deploying to local Kubernetes"
msgstr "部署到金德"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"When deploying to local Kubernetes environments, users often perform minor changes to their manifests that simplify the development process.\n"
"The most common changes are:"
msgstr "在部署到本地 Kubernetes 环境时，用户经常会对清单进行一些小改动，以简化开发流程。最常见的更改包括"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Setting `imagePullPolicy` to `IfNotPresent`"
msgstr "将 `imagePullPolicy` 设置为 `IfNotPresent`"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Using `NodePort` as `Service` type"
msgstr "使用 `NodePort` 作为 `Service` 类型"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Quarkus provides extensions that among others set these options by default.\n"
"Such extensions are:"
msgstr "Quarkus 提供的扩展程序可以默认设置这些选项。这些扩展包括"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "quarkus-minikube"
msgstr " `quarkus-mongo-client` "

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "quarkus-kind"
msgstr " `quarkus-kafka-client` "

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"If the list of extensions does not match the tool you are using (e.g. Docker Desktop, microk8s etc) then it is suggested to use the `quarkus-minikube` extension.\n"
"as its defaults should be reasonable for most environments."
msgstr "如果扩展列表与您使用的工具不匹配（如 Docker Desktop、microk8s 等），建议使用 `quarkus-minikube` 扩展，因为其默认值对大多数环境来说都是合理的。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Deploying to Minikube"
msgstr "部署到Minikube"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"https://github.com/kubernetes/minikube[Minikube] is quite popular when a Kubernetes cluster is needed for development purposes. To make the deployment to Minikube\n"
"experience as frictionless as possible, Quarkus provides the `quarkus-minikube` extension. This extension can be added to a project like so:"
msgstr "当出于开发目的需要使用 Kubernetes 集群时， link:https://github.com/kubernetes/minikube[Minikube] 相当受欢迎。为了让部署到 Minikube 的体验尽可能无摩擦，Quarkus 提供了 `quarkus-minikube` 扩展。该扩展可以像下面这样添加到项目中："

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"The purpose of this extension is to generate Kubernetes manifests (`minikube.yaml` and `minikube.json`) that are tailored to Minikube.\n"
"This extension assumes a couple of things:"
msgstr "该扩展的目的是生成为 Minikube 量身定制的 Kubernetes 清单（ `minikube.yaml` 和 `minikube.json` ）。该扩展假定了几件事："

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Users won't be using an image registry and will instead make their container image accessible to the Kubernetes cluster by building it directly\n"
"into Minikube's Docker daemon. To use Minikube's Docker daemon you must first execute:"
msgstr "用户不会使用镜像注册表，而是直接在 Minikube 的 Docker 守护进程中构建容器镜像，使 Kubernetes 集群可以访问容器镜像。要使用 Minikube 的 Docker 守护进程，必须先执行以下操作"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Applications deployed to Kubernetes won't be accessed via a Kubernetes `Ingress`, but rather as a `NodePort` `Service`.\n"
"The advantage of doing this is that the URL of an application can be retrieved trivially by executing:"
msgstr "部署到 Kubernetes 的应用程序不会通过 Kubernetes `Ingress` 访问，而是作为 `NodePort` `Service` 访问。这样做的好处是，应用程序的 URL 可以通过执行来检索："

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"To control the https://kubernetes.io/docs/concepts/services-networking/service/#nodeport[nodePort] that is used in this case, users can set `quarkus.kubernetes.node-port`.\n"
"Note however that this configuration is entirely optional because Quarkus will automatically use a proper (and non-changing) value if none is set."
msgstr "要控制在这种情况下使用的 link:https://kubernetes.io/docs/concepts/services-networking/service/#nodeport[nodePort] ，用户可以设置 `quarkus.kubernetes.node-port` 。但请注意，这一配置完全是可选的，因为如果没有设置，Quarkus 会自动使用一个合适的（且不会改变的）值。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"It is highly discouraged to use the manifests generated by the Minikube extension when deploying to production as these manifests are intended for development purposes\n"
"only. When deploying to production, consider using the vanilla Kubernetes manifests (or the OpenShift ones when targeting OpenShift)."
msgstr "在部署到生产环境时，不建议使用 Minikube 扩展生成的清单，因为这些清单仅供开发之用。在部署到生产环境时，请考虑使用 Kubernetes 清单（或 OpenShift 清单（如果使用 OpenShift））。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"If the assumptions the Minikube extension makes don't fit your workflow, nothing prevents you from using the regular Kubernetes extension to generate Kubernetes manifests\n"
"and apply those to your Minikube cluster."
msgstr "如果 Minikube 扩展所做的假设不适合你的工作流程，那么没有什么能阻止你使用常规的 Kubernetes 扩展来生成 Kubernetes 清单，并将其应用到你的 Minikube 集群。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Deploying to Kind"
msgstr "部署到金德"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"https://kind.sigs.k8s.io/[Kind] is another popular tool used as a Kubernetes cluster for development purposes. To make the deployment to Kind\n"
"experience as frictionless as possible, Quarkus provides the `quarkus-kind` extension. This extension can be added to a project like so:"
msgstr "link:https://kind.sigs.k8s.io/[Kind] 是另一种用于开发的 Kubernetes 集群工具。为了让部署到 Kind 的体验尽可能无摩擦，Quarkus 提供了 `quarkus-kind` 扩展。可以像下面这样将该扩展添加到项目中："

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"The purpose of this extension is to generate Kubernetes manifests (`kind.yaml` and `kind.json`) that are tailored to Kind and also to automate the process of loading images to the cluster\n"
"when performing container image builds. The tailor made manifests will be pretty similar (they share the same rules) with Minikube (see above)."
msgstr "该扩展的目的是生成为 Kind 量身定制的 Kubernetes 清单（ `kind.yaml` 和 `kind.json` ），并在执行容器镜像构建时自动将镜像加载到集群中。量身定制的清单将与 Minikube（见上文）非常相似（它们共享相同的规则）。"

#. type: Title ==
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Tuning the generated resources using application.properties"
msgstr "使用application.properties调整生成的资源"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"The Kubernetes extension allows tuning the generated manifest, using the `application.properties` file.\n"
"Here are some examples:"
msgstr "Kubernetes 扩展允许使用 `application.properties` 文件调整生成的清单。下面是一些示例："

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Configuration options"
msgstr "配置选项"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The table below describe all the available configuration options."
msgstr "下表描述了所有可用的配置选项。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Properties that use non-standard types, can be referenced by expanding the property.\n"
"For example to define a `kubernetes-readiness-probe` which is of type `Probe`:"
msgstr "使用非标准类型的属性可通过扩展属性来引用。例如，要定义一个 `kubernetes-readiness-probe` ，其类型为 `Probe` ："

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"In this example `initial-delay` and `period` are fields of the type `Probe`.\n"
"Below you will find tables describing all available types."
msgstr "在本例中， `initial-delay` 和 `period` 是 `Probe` 类型的字段。下面的表格介绍了所有可用类型。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Client Connection Configuration"
msgstr "客户端连接配置"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"You may need to configure the connection to your Kubernetes cluster.\n"
"By default, it automatically uses the active _context_ used by `kubectl`."
msgstr "您可能需要配置与 Kubernetes 集群的连接。默认情况下，它会自动使用 `kubectl` 使用的活动 _上下文_ 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For instance, if your cluster API endpoint uses a self-signed SSL Certificate you need to explicitly configure the client to trust it. You can achieve this by defining the following property:"
msgstr "例如，如果你的集群API端点使用一个自签名的SSL证书，你需要明确地配置客户端来信任它。你可以通过定义以下属性来实现这一点。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The full list of the Kubernetes client configuration properties is provided below."
msgstr "下面提供了Kuberneters客户端配置属性的完整列表。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "<span class=\"icon\"><i class=\"fa fa-lock\" title=\"Fixed at build time\"></i></span> Configuration property fixed at build time - All other configuration properties are overridable at runtime <input type=\"search\" id=\"config-search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"
msgstr "<span class=\"icicon\"><i class=\"fa fa-lock\" title=\"在构建时固定\"></i></span>在构建时固定的配置属性 - 所有其他配置属性都可在运行时重写 <input type=\"search\" id=\"config-search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "OpenShift"
msgstr "OpenShift"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "One way to deploy an application to OpenShift is to use s2i (source to image) to create an image stream from the source and then deploy the image stream:"
msgstr "将应用程序部署到OpenShift的一个方法是使用s2i（source to image），从源码创建一个镜像流，然后部署镜像流。"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "CLI"
msgstr "CLI"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, no-wrap
msgid "Gradle"
msgstr "Gradle"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "See further information in xref:deploying-to-openshift.adoc[Deploying to OpenShift]."
msgstr "见 link:deploying-to-openshift.html[部署到OpenShift] 中的进一步信息。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "A description of OpenShift resources and customisable properties is given below alongside Kubernetes resources to show similarities where applicable.   This includes an alternative to  `oc new-app ...` above, i.e. `oc apply -f target/kubernetes/openshift.json` ."
msgstr "以下是 OpenShift 资源和可定制属性的说明，以及 Kubernetes 资源的说明，以显示适用情况下的相似性。这包括上述 `oc new-app …​` 的替代方案，即 `oc apply -f target/kubernetes/openshift.json` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To enable the generation of OpenShift resources, you need to include OpenShift in the target platforms:"
msgstr "要启用OpenShift资源的生成，你需要在目标平台中包含OpenShift。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "If you need to generate resources for both platforms (vanilla Kubernetes and OpenShift), then you need to include both (comma separated)."
msgstr "如果你需要为两个平台（vanilla Kubernetes和OpenShift）生成资源，那么你需要包括这两个平台（逗号分隔）。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Following the execution of `./mvnw package -Dquarkus.container-image.build=true` you will notice amongst the other files that are created, two files named\n"
"`openshift.json` and `openshift.yml` in the `target/kubernetes/` directory."
msgstr "执行 `./mvnw package -Dquarkus.container-image.build=true` 后，您会发现在 `target/kubernetes/` 目录中创建了两个文件，分别名为 `openshift.json` 和 `openshift.yml` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "These manifests can be deployed as is to a running cluster, using `kubectl`:"
msgstr "这些清单可以按原样部署到正在运行的集群中，使用 `kubectl` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "OpenShift's users might want to use `oc` rather than `kubectl`:"
msgstr "OpenShift用户可能希望使用 `oc` ，而不是 `kubectl` 。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"For users that prefer to keep the `application.properties` independent of the deployment platform, the deployment target can be specified directly in the deploy command by adding `-Dquarkus.kubernetes.deployment-target=openshift`\n"
"in addition to `-Dquarkus.kubernetes.deploy=true`. Furthermore, Quarkus allows collapsing the two properties into one: `-Dquarkus.openshift.deploy=true`."
msgstr "对于希望 `application.properties` 与部署平台无关的用户，可以在部署命令中直接指定部署目标，方法是在 `-Dquarkus.kubernetes.deploy=true` 之外添加 `-Dquarkus.kubernetes.deployment-target=openshift` 。此外，Quarkus 还允许将这两个属性合并为一个： `-Dquarkus.openshift.deploy=true` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The equivalent with gradle:"
msgstr "与gradle相当。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "In case that both properties are used with conflicting values `quarkus.kubernetes.deployment-target` is used."
msgstr "如果两个属性都使用了冲突的值，则使用 `quarkus.kubernetes.deployment-target` 。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Quarkus also provides the xref:deploying-to-openshift.adoc[OpenShift] extension. This extension is basically a wrapper around the Kubernetes extension and\n"
"relieves OpenShift users of the necessity of setting the `deployment-target` property to `openshift`"
msgstr "Quarkus 还提供 xref:deploying-to-openshift.adoc[OpenShift] 扩展。该扩展基本上是对 Kubernetes 扩展的封装，使 OpenShift 用户无需将 `deployment-target` 属性设置为 `openshift`"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The OpenShift resources can be customized in a similar approach with Kubernetes."
msgstr "OpenShift的资源可以用与Kubernetes类似的方式进行定制。"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Knative"
msgstr "骑士"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To enable the generation of Knative resources, you need to include Knative in the target platforms:"
msgstr "要启用Knative资源的生成，你需要在目标平台中包含Knative。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Following the execution of `./mvnw package` you will notice amongst the other files that are created, two files named\n"
"`knative.json` and `knative.yml` in the `target/kubernetes/` directory."
msgstr "执行 `./mvnw package` 后，您会发现在 `target/kubernetes/` 目录中创建了两个文件，分别名为 `knative.json` 和 `knative.yml` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "If you look at either file you will see that it contains a Knative `Service`."
msgstr "如果你看一下这两个文件，你会发现它包含一个Knative `Service` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The full source of the `knative.json` file looks something like this:"
msgstr " `knative.json` 文件的完整来源看起来是这样的。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The generated manifest can be deployed as is to a running cluster, using `kubectl`:"
msgstr "生成的清单可以按原样部署到正在运行的集群中，使用 `kubectl` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The generated service can be customized using the following properties:"
msgstr "生成的服务可以使用以下属性进行定制。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Deployment targets"
msgstr "部署目标"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Mentioned in the previous sections was the concept of `deployment-target`. This concept allows users to control which Kubernetes manifests will be generated\n"
"and deployed to a cluster (if `quarkus.kubernetes.deploy` has been set to `true`)."
msgstr "前几节提到了 `deployment-target` 的概念。这个概念允许用户控制将生成哪些 Kubernetes 清单并部署到集群（如果 `quarkus.kubernetes.deploy` 已设置为 `true` ）。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"By default, when no `deployment-target` is set, then only vanilla Kubernetes resources are generated and deployed. When multiple values are set (for example\n"
"`quarkus.kubernetes.deployment-target=kubernetes,openshift`) then the resources for all targets are generated, but only the resources\n"
"that correspond to the *first* target are applied to the cluster (if deployment is enabled)."
msgstr "默认情况下，如果未设置 `deployment-target` ，则只生成和部署 vanilla Kubernetes 资源。如果设置了多个值（例如 `quarkus.kubernetes.deployment-target=kubernetes,openshift` ），则会生成所有目标的资源，但只有与 *第一个* 目标相对应的资源才会应用到群集（如果已启用部署）。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"For users that prefer to keep the `application.properties` independent of the deployment platform, the deployment target can be specified directly in the deploy command by adding `-Dquarkus.kubernetes.deployment-target=knative`\n"
"in addition to `-Dquarkus.knative.deploy=true`. Furthermore, Quarkus allows collapsing the two properties into one: `-Dquarkus.knative.deploy=true`."
msgstr "对于希望 `application.properties` 与部署平台无关的用户，可以在部署命令中直接指定部署目标，方法是在 `-Dquarkus.knative.deploy=true` 之外添加 `-Dquarkus.kubernetes.deployment-target=knative` 。此外，Quarkus 还允许将这两个属性合并为一个： `-Dquarkus.knative.deploy=true` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "In case that both properties are used with conflicting values `-Dquarkus.kubernetes.deployment-target` is used."
msgstr "如果两个属性都使用了冲突的值，则使用 `-Dquarkus.kubernetes.deployment-target` 。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"In the case of wrapper extensions like OpenShift and Minikube, when these extensions have been explicitly added to the project, the default `deployment-target`\n"
"is set by those extensions. For example if `quarkus-minikube` has been added to a project, then `minikube` becomes the default deployment target and its\n"
"resources will be applied to the Kubernetes cluster when deployment via `quarkus.kubernetes.deploy` has been set.\n"
"Users can still override the deployment-targets manually using `quarkus.kubernetes.deployment-target`."
msgstr "对于 OpenShift 和 Minikube 等封装扩展，当这些扩展被明确添加到项目中时，默认的 `deployment-target` 将由这些扩展设置。例如，如果 `quarkus-minikube` 已添加到项目中，那么 `minikube` 就会成为默认部署目标，当通过 `quarkus.kubernetes.deploy` 进行部署时，其资源就会应用到 Kubernetes 集群。用户仍可使用 `quarkus.kubernetes.deployment-target` 手动覆盖部署目标。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Deprecated configuration"
msgstr "废弃的配置"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The following categories of configuration properties have been deprecated."
msgstr "以下类别的配置属性已被废弃。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Properties without the quarkus prefix"
msgstr "不含夸克斯前缀的属性"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "In earlier versions of the extension, the `quarkus.` was missing from those properties. These properties are now deprecated."
msgstr "在早期版本的扩展中，这些属性中缺少 `quarkus.` 。这些属性现在已经废弃了。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Docker and S2i properties"
msgstr "Docker和S2i属性"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The properties for configuring `docker` and `s2i` are also deprecated in favor of the new container-image extensions."
msgstr "用于配置 `docker` 和 `s2i` 的属性也被弃用，转而使用新的容器-图像扩展。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Config group arrays"
msgstr "配置群组阵列"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Properties referring to config group arrays (e.g. `kubernetes.labels[0]`, `kubernetes.env-vars[0]` etc) have been converted to Maps to align with the rest of the Quarkus ecosystem."
msgstr "指向配置组阵列的属性（如 `kubernetes.labels[0]` , `kubernetes.env-vars[0]` 等）已被转换为地图，以便与Quarkus生态系统的其他部分保持一致。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The code below demonstrates the change in `labels` config:"
msgstr "下面的代码演示了 `labels` 配置中的变化。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The code below demonstrates the change in `env-vars` config:"
msgstr "下面的代码演示了 `env-vars` 配置中的变化。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`env-vars` properties"
msgstr " `env-vars` 财产"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"`quarkus.kubernetes.env-vars` are deprecated (though still currently supported as of this writing) and the new declaration style should be used instead.\n"
"See <<#env-vars>> and more specifically <<env-vars-backwards>> for more details."
msgstr "`quarkus.kubernetes.env-vars` 已被弃用（尽管截至本文撰写时仍受支持），应改用新的声明样式。详情请参见 和 。 <<env-vars>> <<env-vars-backwards>> "

#. type: Title ==
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Deployment"
msgstr "部署"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"To trigger building and deploying a container image you need to enable the `quarkus.kubernetes.deploy` flag (the flag is disabled by default - furthermore it has no effect during test runs or dev mode).\n"
"This can be easily done with the command line:"
msgstr "要触发容器镜像的构建和部署，需要启用 `quarkus.kubernetes.deploy` 标志（该标志默认为禁用，而且在测试运行或开发模式下无效）。这可以通过命令行轻松完成："

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Building a container image"
msgstr "构建一个容器镜像"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Building a container image is possible, using any of the 3 available `container-image` extensions:"
msgstr "构建一个容器镜像是可能的，使用3个可用的 `container-image` 扩展中的任何一个。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "xref:container-image.adoc#docker[Docker]"
msgstr "link:container-image.html#docker[码头]"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "xref:container-image.adoc#jib[Jib]"
msgstr "link:container-image.html#jib[Jib]"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "xref:container-image.adoc#s2i[s2i]"
msgstr "link:container-image.html#s2i[s2i]"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Each time deployment is requested, a container image build will be implicitly triggered (no additional properties are required when the Kubernetes deployment has been enabled)."
msgstr "每次请求部署时，将隐含地触发容器镜像构建（当Kubernetes部署被启用时，不需要额外的属性）。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Deploying"
msgstr "部署"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"When deployment is enabled, the Kubernetes extension will select the resources specified by `quarkus.kubernetes.deployment-target` and deploy them.\n"
"This assumes that a `.kube/config` is available in your user directory that points to the target Kubernetes cluster.\n"
"In other words the extension will use whatever cluster `kubectl` uses. The same applies to credentials."
msgstr "启用部署后，Kubernetes 扩展将选择 `quarkus.kubernetes.deployment-target` 指定的资源并进行部署。前提是用户目录中有指向目标 Kubernetes 集群的 `.kube/config` 。换句话说，扩展将使用 `kubectl` 所使用的集群。这同样适用于凭证。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "At the moment no additional options are provided for further customization."
msgstr "目前，没有提供进一步定制的额外选项。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Remote Debugging"
msgstr "远程调试"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To remotely debug applications that are running on a kubernetes environment, we need to deploy the application as described in the previous section and add as new property: `quarkus.kubernetes.remote-debug.enabled=true`. This property will automatically configure the Java application to append the java agent configuration (for example: `-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005`) and also the service resource to listen using the java agent port."
msgstr "为了远程调试运行在kubernetes环境中的应用程序，我们需要按照上一节所述部署应用程序并添加新的属性： `quarkus.kubernetes.remote-debug.enabled=true` 。这个属性将自动配置Java应用程序，以附加java代理配置（例如： `-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005` ），同时也配置服务资源，使用java代理端口进行监听。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "After your application has been deployed with the debug enabled, next you need to tunnel the traffic from your local host machine to the specified port of the java agent:"
msgstr "在你的应用程序被部署并启用了调试功能后，接下来你需要将流量从你的本地主机隧道到java代理的指定端口。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Using this command, you'll forward the traffic from the \"localhost:5005\" to the kubernetes service running the java agent using the port \"5005\" which is the one that the java agent uses by default for remote debugging. You can also configure another java agent port using the property `quarkus.kubernetes.remote-debug.address-port`."
msgstr "使用这个命令，你将把来自 \"localhost:5005 \"的流量转发到运行java代理的kubernetes服务，使用 \"5005 \"端口，这是java代理默认用于远程调试的端口。你也可以使用属性 `quarkus.kubernetes.remote-debug.address-port` ，配置另一个java代理端口。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Finally, all you need to do is to configure your favorite IDE to attach the java agent process that is forwarded to `localhost:5005` and start to debug your application. For example, in IntelliJ IDEA, you can follow https://www.jetbrains.com/help/idea/tutorial-remote-debug.html[this tutorial] to debug remote applications."
msgstr "最后，你需要做的就是配置你最喜欢的IDE，将转发的java代理进程附加到 `localhost:5005` ，并开始调试你的应用程序。例如，在IntelliJ IDEA中，你可以按照 link:https://www.jetbrains.com/help/idea/tutorial-remote-debug.html:[这个教程] 来调试远程应用程序。"

#. type: Title ==
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Using existing resources"
msgstr "利用现有资源"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Sometimes it's desirable to either provide additional resources (e.g. a ConfigMap, a Secret, a Deployment for a database) or provide custom ones that will be used as a `base` for the generation process.\n"
"Those resources can be added under `src/main/kubernetes` directory and can be named after the target environment (e.g. kubernetes.json, openshift.json, knative.json, or the yml equivalents). The correlation between provided and generated files is done by file name.\n"
"So, a `kubernetes.json`/`kubernetes.yml` file added in `src/main/kubernetes` will only affect the generated `kubernetes.json`/`kubernetes.yml`. An `openshift.json`/`openshift.yml` file added in `src/main/kubernetes` will only affect the generated `openshift.json`/`openshift.yml`.\n"
"A `knative.json`/`knative.yml` file added in `src/main/kubernetes` will only affect the generated `knative.json`/`knative.yml` and so on. The provided file may be either in json or yaml format and may contain one or more resources. These resources will end up in both generated formats (json and yaml). For example, a secret added in `src/main/kubernetes/kubernetes.yml` will be added to both the generated `kubernetes.yml` and `kubernetes.json`."
msgstr "有时，我们需要提供额外的资源（如 ConfigMap、Secret、数据库部署），或者提供自定义资源，作为生成过程的 `base` 。这些资源可添加到 `src/main/kubernetes` 目录下，并以目标环境命名（如 kubernetes.json、openshift.json、knative.json 或 yml 对应文件）。提供的文件和生成的文件之间的关联是通过文件名实现的。因此，在 `src/main/kubernetes` 中添加的 `kubernetes.json` / `kubernetes.yml` 文件只会影响生成的 `kubernetes.json` / `kubernetes.yml` 。在 `src/main/kubernetes` 中添加的 `openshift.json` / `openshift.yml` 文件只会影响生成的 `openshift.json` / `openshift.yml` 。在 `src/main/kubernetes` 中添加的 `knative.json` / `knative.yml` 文件只会影响生成的 `knative.json` / `knative.yml` ，以此类推。提供的文件可以是 json 或 yaml 格式，可以包含一个或多个资源。这些资源最终会以两种格式（json 和 yaml）生成。例如，在 `src/main/kubernetes/kubernetes.yml` 中添加的秘密将同时添加到生成的 `kubernetes.yml` 和 `kubernetes.json` 中。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Note: At the time of writing there is no mechanism in place that allows a one-to-many relationship between provided and generated files. Minikube is not an exception to the rule above, so if you want to customize the generated minikube manifests, the file placed under `src/main/kubernetes` will have to be named `minikube.json` or `minikube.yml` (naming it `kubernetes.yml` or `kubernetes.json` will result in having only the generated `kubernetes.yml` and `kubernetes.json` affected)."
msgstr "注意：在撰写本文时，还没有任何机制允许在提供的文件和生成的文件之间建立一对多的关系。Minikube不是上述规则的例外，所以如果你想定制生成的minikube清单，放在 `src/main/kubernetes` 下的文件必须命名为 `minikube.json` 或 `minikube.yml` （命名为 `kubernetes.yml` 或 `kubernetes.json` 将导致只有生成的 `kubernetes.yml` 和 `kubernetes.json` 受到影响）。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid ""
"Any resource found will be added in the generated manifests. Global modifications (e.g. labels, annotations) will also be applied to those resources.\n"
"If one of the provided resources has the same name as one of the generated ones, then the generated resource will be created on top of the provided resource, respecting existing content when possible (e.g. existing labels, annotations, environment variables, mounts, replicas etc)."
msgstr "找到的任何资源都将添加到生成的清单中。全局修改（如标签、注释）也将应用于这些资源。如果提供的资源与生成的资源名称相同，那么生成的资源将在提供的资源基础上创建，并尽可能尊重现有内容（如现有标签、注释、环境变量、挂载、副本等）。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The name of the resource is determined by the application name and may be overridden by `quarkus.kubernetes.name`, `quarkus.openshift.name` and `quarkus.knative.name`."
msgstr "资源的名称由应用名称决定，并可由 `quarkus.kubernetes.name` , `quarkus.openshift.name` 和 `quarkus.knative.name` 来覆盖。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For example, in the `kubernetes-quickstart` application, we can add a `kubernetes.yml` file in the `src/main/kubernetes` that looks like:"
msgstr "例如，在 `kubernetes-quickstart` 应用程序中，我们可以在 `src/main/kubernetes` 中添加一个 `kubernetes.yml` 文件，看起来像。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The generated `kubernetes.yml` will look like:"
msgstr "生成的 `kubernetes.yml` ，将看起来像。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The provided replicas <1>, labels <2> and environment variables <3>  were retained. However, the image <4> and container port <5> were modified. Moreover, the default annotations have been added."
msgstr "提供的副本 <1>、标签 <2> 和环境变量 <3> 被保留。但修改了映像 <4> 和容器端口 <5>。此外，还添加了默认注释。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "When the resource name does not match the application name (or the overridden name) rather than reusing the resource a new one will be added. Same goes for the container."
msgstr "当资源名称与应用程序名称（或重写名称）不匹配时，不是重复使用该资源，而是添加一个新的资源。容器也是如此。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "When the name of the container does not match the application name (or the overridden name), container specific configuration will be ignored."
msgstr "当容器的名称与应用程序的名称（或重写的名称）不一致时，容器的具体配置将被忽略。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Using common resources"
msgstr "利用现有资源"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "When generating the manifests for multiple deployment targets like Kubernetes, OpenShift or Knative, we can place the common resources in `src/main/kubernetes/common.yml`, so these resources will be integrated into the generated `kubernetes.json`/`kubernetes.yml`, and `openshift.json`/`openshift.yml` files (if you configure the Kubernetes and OpenShift extensions at the same time)."
msgstr "在为 Kubernetes、OpenShift 或 Knative 等多个部署目标生成清单时，我们可以将公共资源放在 `src/main/kubernetes/common.yml` 中，这样这些资源就会集成到生成的 `kubernetes.json` / `kubernetes.yml` 和 `openshift.json` / `openshift.yml` 文件中（如果同时配置了 Kubernetes 和 OpenShift 扩展）。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For example, we can write a ConfigMap resource only once in the file `src/main/kubernetes/common.yml`:"
msgstr "例如，我们可以在文件 `src/main/kubernetes/common.yml` 中只写一次ConfigMap资源。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "And this config map resource will be integrated into the generated `kubernetes.json`/`kubernetes.yml`, and `openshift.json`/`openshift.yml` files."
msgstr "而这个配置图资源将被整合到生成的 `kubernetes.json` / `kubernetes.yml` ，以及 `openshift.json` / `openshift.yml` 文件中。"

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Service Binding"
msgstr "服务绑定"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Quarkus supports the link:https://github.com/servicebinding/spec[Service Binding Specification for Kubernetes] to bind services to applications."
msgstr "Quarkus支持 link:https://github.com/k8s-service-bindings/spec[Kubernetes的服务绑定规范] ，将服务绑定到应用程序。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Specifically, Quarkus implements the link:https://github.com/servicebinding/spec#workload-projection[Workload Projection] part of the specification, therefore allowing applications to bind to services, such as a Database or a Broker, without the need for user configuration."
msgstr "具体来说，Quarkus实现了规范中的 link:https://github.com/k8s-service-bindings/spec#workload-projection[工作负载预测] 部分，因此允许应用程序绑定到服务，如数据库或经纪人，而不需要用户配置。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To enable Service Binding for supported extensions, add the `quarkus-kubernetes-service-binding` extension to the application dependencies."
msgstr "要为支持的扩展启用服务绑定，请将 `quarkus-kubernetes-service-binding` 扩展添加到应用程序的依赖关系中。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The following extensions can be used with Service Binding and are supported for Workload Projection:"
msgstr "以下扩展可以与服务绑定一起使用，并被支持用于工作负载预测。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-jdbc-mariadb`"
msgstr " `quarkus-jdbc-mariadb` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-jdbc-mssql`"
msgstr " `quarkus-jdbc-mssql` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-jdbc-mysql`"
msgstr " `quarkus-jdbc-mysql` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-jdbc-postgresql`"
msgstr " `quarkus-jdbc-postgresql` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-mongodb-client`"
msgstr " `quarkus-mongo-client` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-kafka-client`"
msgstr " `quarkus-kafka-client` "

#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-messaging-kafka`"
msgstr "`quarkus-messaging-kafka`"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-reactive-db2-client`"
msgstr " `quarkus-reactive-db2-client` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-reactive-mssql-client`"
msgstr " `quarkus-reactive-mssql-client` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-reactive-mysql-client`"
msgstr " `quarkus-reactive-mysql-client` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-reactive-oracle-client`"
msgstr " `quarkus-reactive-oracle-client` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-reactive-pg-client`"
msgstr " `quarkus-reactive-pg-client` "

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "`quarkus-infinispan-client`"
msgstr " `quarkus-kafka-client` "

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Workload Projection"
msgstr "工作量预测"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Workload Projection is a process of obtaining the configuration for services from the Kubernetes cluster. This configuration takes the form of directory structures that follow certain conventions and is attached to an application or to a service as a mounted volume. The `kubernetes-service-binding` extension uses this directory structure to create configuration sources, which allows you to configure additional modules, such as databases or message brokers."
msgstr "工作负载投影是一个从Kubernetes集群中获取服务配置的过程。这种配置采取遵循某些惯例的目录结构形式，并作为挂载卷附在应用程序或服务上。 `kubernetes-service-binding` 扩展使用该目录结构来创建配置源，这允许你配置额外的模块，如数据库或消息代理。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "During application development, users can use workload projection to connect their application to a development database, or other locally-run services, without changing the actual application code or configuration."
msgstr "在应用程序开发过程中，用户可以使用工作量预测将他们的应用程序连接到开发数据库，或其他本地运行的服务，而不改变实际的应用程序代码或配置。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For an example of a workload projection where the directory structure is included in the test resources and passed to integration test, see the link:https://github.com/quarkusio/quarkus/tree/e7efe6b3efba91b9c4ae26f9318f8397e23e7505/integration-tests/kubernetes-service-binding-jdbc/src/test/resources/k8s-sb[Kubernetes Service Binding datasource] GitHub repository."
msgstr "关于目录结构包含在测试资源中并传递给集成测试的工作负载投影的例子，请看 link:https://github.com/quarkusio/quarkus/tree/e7efe6b3efba91b9c4ae26f9318f8397e23e7505/integration-tests/kubernetes-service-binding-jdbc/src/test/resources/k8s-sb[Kubernetes服务绑定数据源] GitHub仓库。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The `k8s-sb` directory is the root of all service bindings. In this example, only one database called `fruit-db` is intended to be bound. This binding database has the `type` file, that indicates `postgresql` as the database type, while the other files in the directory provide the necessary information to establish the connection."
msgstr " `k8s-sb` 目录是所有服务绑定的根。在这个例子中，只有一个名为 `fruit-db` 的数据库打算被绑定。这个绑定的数据库有 `type` 文件，该文件表明 `postgresql` 为数据库类型，而目录中的其他文件提供了建立连接的必要信息。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "After your Quarkus project obtains information from `SERVICE_BINDING_ROOT` environment variables that are set by OpenShift, you can locate generated configuration files that are present in the file system and use them to map the configuration-file values to properties of certain extensions."
msgstr "在你的Quarkus项目从OpenShift设置的 `SERVICE_BINDING_ROOT` 环境变量中获取信息后，你可以找到存在于文件系统中的生成的配置文件，并使用它们将配置文件的值映射到某些扩展的属性。"

#. type: Title ==
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Introduction to the Service Binding Operator"
msgstr "服务绑定运营商介绍"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The link:https://github.com/redhat-developer/service-binding-operator[Service Binding Operator] is an Operator that implements link:https://github.com/servicebinding/spec[Service Binding Specification for Kubernetes] and is meant to simplify the binding of services to an application. Containerized applications that support link:https://github.com/servicebinding/spec#workload-projection[Workload Projection] obtain service binding information in the form of volume mounts. The Service Binding Operator reads binding service information and mounts it to the application containers that need it."
msgstr "link:https://github.com/redhat-developer/service-binding-operator[服务绑定运营商] 是一个实现 link:https://github.com/k8s-service-bindings/spec[Kubernetes服务绑定规范的] 运营商，旨在简化服务与应用程序的绑定。支持 link:https://github.com/k8s-service-bindings/spec#workload-projection[工作负载预测] 的容器化应用程序以卷挂载的形式获得服务绑定信息。服务绑定操作员读取绑定的服务信息，并将其挂载到需要它的应用程序容器中。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The correlation between application and bound services is expressed through the `ServiceBinding` resources, which declares the intent of what services are meant to be bound to what application."
msgstr "应用程序和绑定的服务之间的相关性是通过 `ServiceBinding` 资源来表达的，它声明了什么服务要绑定到什么应用程序的意图。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The Service Binding Operator watches for `ServiceBinding` resources, which inform the Operator what applications are meant to be bound with what services. When a listed application is deployed, the Service Binding Operator collects all the binding information that must be passed to the application, then upgrades the application container by attaching a volume mount with the binding information."
msgstr "服务绑定操作者观察 `ServiceBinding` ，这些资源告知操作者哪些应用程序要与哪些服务绑定。当一个列出的应用程序被部署时，服务绑定操作者会收集所有必须传递给应用程序的绑定信息，然后通过附加一个带有绑定信息的卷装载来升级应用程序容器。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The Service Binding Operator completes the following actions:"
msgstr "服务绑定操作员完成以下操作。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Observes `ServiceBinding` resources for workloads intended to be bound to a particular service"
msgstr "观察 `ServiceBinding` ，为打算与特定服务绑定的工作负载提供资源。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Applies the binding information to the workload using volume mounts"
msgstr "使用卷挂载将绑定信息应用于工作负载"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The following chapter describes the automatic and semi-automatic service binding approaches and their use cases. With either approach, the `kubernetes-service-binding` extension generates a `ServiceBinding` resource. With the semi-automatic approach, users must provide a configuration for target services manually. With the automatic approach, for a limited set of services generating the `ServiceBinding` resource, no additional configuration is needed."
msgstr "下一章描述了自动和半自动的服务绑定方法和它们的使用情况。使用这两种方法， `kubernetes-service-binding` 扩展会生成 `ServiceBinding` 资源。在半自动方法中，用户必须手动提供目标服务的配置。在自动方法中，对于生成 `ServiceBinding` 资源的一组有限的服务，不需要额外的配置。"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Semi-automatic service binding"
msgstr "半自动服务绑定"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "A service binding process starts with a user specification of required services that will be bound to a certain application. This expression is summarized in the `ServiceBinding` resource that is generated by the `kubernetes-service-binding` extension. The use of the `kubernetes-service-binding` extensions helps users to generate `ServiceBinding` resources with minimal configuration, therefore simplifying the process overall."
msgstr "服务绑定过程从用户对将被绑定到某个应用程序的所需服务的规范开始。这种表达方式被总结在由 `kubernetes-service-binding` 扩展生成的 `ServiceBinding` 资源中。使用 `kubernetes-service-binding` 扩展可以帮助用户以最小的配置生成 `ServiceBinding` 资源，因此从整体上简化了这个过程。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The Service Binding Operator responsible for the binding process then reads the information from the `ServiceBinding` resource and mounts the required files to a container accordingly."
msgstr "然后，负责绑定过程的服务绑定操作员从 `ServiceBinding` 资源中读取信息，并相应地将所需的文件挂载到一个容器中。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "An example of the `ServiceBinding` resource:"
msgstr " `ServiceBinding` 资源的一个例子。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The `quarkus-kubernetes-service-binding` extension provides a more compact way of expressing the same information. For example:"
msgstr " `quarkus-kubernetes-service-binding` 扩展提供了一种更紧凑的方式来表达相同的信息。比如说。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "After adding the earlier configuration properties inside your `application.properties`, the `quarkus-kubernetes`, in combination with the `quarkus-kubernetes-service-binding` extension, automatically generates the `ServiceBinding` resource."
msgstr "在你的 `application.properties` 里面添加了前面的配置属性后， `quarkus-kubernetes` ，结合 `quarkus-kubernetes-service-binding` 扩展，自动生成 `ServiceBinding` 资源。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The earlier mentioned `db-demo` property-configuration identifier now has a double role and also completes the following actions:"
msgstr "先前提到的 `db-demo` 属性-配置标识符现在有了双重作用，也完成了以下动作。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Correlates and groups `api-version` and `kind` properties together"
msgstr "将 `api-version` 和 `kind` 属性联系起来，并将其分组。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Defines the `name` property for the custom resource with a possibility for a later edit. For example:"
msgstr "定义自定义资源的 `name` 属性，以后可以编辑。例如。"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Additional resources"
msgstr "额外资源"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For a semi-automatic service binding demonstration, see link:https://developers.redhat.com/articles/2021/12/22/how-use-quarkus-service-binding-operator#create_the_quarkus_application[How to use Quarkus with the Service Binding Operator]"
msgstr "关于半自动服务绑定的演示，请看 link:https://developers.redhat.com/articles/2021/12/22/how-use-quarkus-service-binding-operator#create_the_quarkus_application[如何使用Quarkus与服务绑定操作者] 的关系。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "link:https://github.com/redhat-developer/service-binding-operator#known-bindable-operators[List of bindable Operators]"
msgstr "列表中的 link:https://github.com/redhat-developer/service-binding-operator#known-bindable-operators[可绑定操作符] 的列表"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Automatic service binding"
msgstr "自动服务绑定"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The `quarkus-kubernetes-service-binding` extension can generate the `ServiceBinding` resource automatically after detecting that an application requires access to the external services that are provided by available bindable Operators."
msgstr " `quarkus-kubernetes-service-binding` 扩展可以在检测到一个应用程序需要访问由可用的可绑定操作符提供的外部服务后，自动生成 `ServiceBinding` 资源。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Automatic service binding can be generated for a limited number of service types. To be consistent with established terminology for Kubernetes and Quarkus services, this chapter refers to these service types as kinds."
msgstr "自动服务绑定可以为数量有限的服务类型生成。为了与Kubernetes和Quarkus服务的既定术语一致，本章将这些服务类型称为种类。"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Operators that support the service auto-binding"
msgstr "支持服务自动绑定的操作者"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Operator"
msgstr "运营商"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "API Version"
msgstr "API版本"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Kind"
msgstr "种类"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`postgresql`"
msgstr " `postgresql` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "link:https://operatorhub.io/operator/postgresql[CrunchyData Postgres]"
msgstr "link:https://operatorhub.io/operator/postgresql[CrunchyData Postgres]"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "postgres-operator.crunchydata.com/v1beta1"
msgstr "postgres-operator.crunchydata.com/v1beta1"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "PostgresCluster"
msgstr "簇拥而至的PostgresCluster"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`mysql`"
msgstr " `mysql` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "link:https://operatorhub.io/operator/percona-xtradb-cluster-operator[Percona XtraDB Cluster]"
msgstr "link:https://operatorhub.io/operator/percona-xtradb-cluster-operator[Percona XtraDB群集]"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "pxc.percona.com/v1-9-0"
msgstr "pxc.percona.com/v1-9-0"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "PerconaXtraDBCluster"
msgstr "霹雳火"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "`mongo`"
msgstr " `mongo` "

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "link:https://operatorhub.io/operator/percona-server-mongodb-operator[Percona Mongo]"
msgstr "link:https://operatorhub.io/operator/percona-server-mongodb-operator[Percona Mongo]"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "psmdb.percona.com/v1-9-0"
msgstr "psmdb.percona.com/v1-9-0"

#. type: Table
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "PerconaServerMongoDB"
msgstr "淘宝网"

#. type: Title ===
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Automatic datasource binding"
msgstr "自动数据源绑定"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For traditional databases, automatic binding is initiated whenever a datasource is configured as follows:"
msgstr "对于传统的数据库，每当数据源被配置成如下样子时，就会启动自动绑定。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The previous configuration, combined with the presence of `quarkus-datasource`, `quarkus-jdbc-postgresql`, `quarkus-kubernetes`, and `quarkus-kubernetes-service-binding` properties in the application, results in the generation of the `ServiceBinding` resource for the `postgresql` database type."
msgstr "前面的配置，结合应用程序中存在的 `quarkus-datasource` 、 `quarkus-jdbc-postgresql` 、 `quarkus-kubernetes` 和 `quarkus-kubernetes-service-binding` 属性，导致为 `postgresql` 数据库类型生成 `ServiceBinding` 资源。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "By using the `apiVersion` and `kind` properties of the Operator resource, which matches the used `postgresql` Operator, the generated `ServiceBinding` resource binds the service or resource to the application."
msgstr "通过使用操作员资源的 `apiVersion` 和 `kind` 属性，与使用的 `postgresql` 操作员相匹配，生成的 `ServiceBinding` 资源将服务或资源绑定到应用程序。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "When you do not specify a name for your database service, the value of the `db-kind` property is used as the default name."
msgstr "当你没有为你的数据库服务指定一个名称时， `db-kind` 属性的值被用作默认名称。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Specified the name of the datasource as follows:"
msgstr "指定数据源的名称，如下所示。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The `service` in the generated `ServiceBinding` then displays as follows:"
msgstr "然后，在生成的 `ServiceBinding` ， `service` ，显示如下。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Similarly, if you use `mysql`, the name of the datasource can be specified as follows:"
msgstr "同样，如果你使用 `mysql` ，数据源的名称可以按如下方式指定。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The generated `service` contains the following:"
msgstr "生成的 `service` ，包含以下内容。"

#. type: Title ====
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Customizing Automatic Service Binding"
msgstr "定制自动服务绑定"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Even though automatic binding was developed to eliminate as much manual configuration as possible, there are cases where modifying the generated `ServiceBinding` resource might still be needed. The generation process exclusively relies on information extracted from the application and the knowledge of the supported Operators, which may not reflect what is deployed in the cluster. The generated resource is based purely on the knowledge of the supported bindable Operators for popular service kinds and a set of conventions that were developed to prevent possible mismatches, such as:"
msgstr "尽管自动绑定的开发是为了尽可能地消除手动配置，但在某些情况下，可能仍然需要修改生成的 `ServiceBinding` 。生成过程完全依赖于从应用程序中提取的信息和支持的操作符的知识，这可能不反映集群中部署的内容。生成的资源完全基于流行的服务种类所支持的可绑定操作符的知识，以及为防止可能的不匹配而开发的一组约定，例如。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The target resource name does not match the datasource name"
msgstr "目标资源名称与数据源名称不一致"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "A specific Operator needs to be used rather than the default Operator for that service kind"
msgstr "需要使用一个特定的操作员，而不是该服务种类的默认操作员。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "Version conflicts that occur when a user needs to use any other version than default or latest"
msgstr "当用户需要使用默认或最新以外的任何其他版本时发生的版本冲突"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Conventions"
msgstr "公约"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The target resource coordinates are determined based on the type of Operator and the kind of service."
msgstr "目标资源坐标是根据运营商的类型和服务种类来确定的。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The target resource name is set by default to match the service kind, such as `postgresql`, `mysql`, `mongo`."
msgstr "目标资源名称默认设置为与服务种类相匹配，如： `postgresql` , `mysql` , `mongo` 。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For named datasources, the name of the datasource is used."
msgstr "对于命名的数据源，使用的是数据源的名称。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For named `mongo` clients, the name of the client is used."
msgstr "对于命名的 `mongo` 客户端，使用的是客户的名字。"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Example 1 - Name mismatch"
msgstr "例1--名称不匹配"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For cases in which you need to modify the generated `ServiceBinding` to fix a name mismatch, use the `quarkus.kubernetes-service-binding.services` properties and specify the service's name as the service key."
msgstr "对于需要修改生成的 `ServiceBinding` 以修复名称不匹配的情况，请使用 `quarkus.kubernetes-service-binding.services` 属性并指定服务的名称作为服务键。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The `service key` is usually the name of the service, for example the name of the datasource, or the name of the `mongo` client. When this value is not available, the datasource type, such as `postgresql`, `mysql`, `mongo`, is used instead."
msgstr " `service key` 通常是服务的名称，例如数据源的名称，或 `mongo` 客户端的名称。当这个值不可用时，就用数据源类型，如 `postgresql` , `mysql` , `mongo` ，来代替。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "To avoid naming conflicts between different types of services, prefix the `service key` with a specific datasource type, such as `postgresql-__<person>__`."
msgstr "为了避免不同类型的服务之间的命名冲突，在 `service key` ，以特定的数据源类型作为前缀，例如 `postgresql- _<person>_` ."

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The following example shows how to customize the `apiVersion` property of the `PostgresCluster` resource:"
msgstr "下面的例子显示了如何定制 `PostgresCluster` 资源的 `apiVersion` 属性。"

#. type: Block title
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy, no-wrap
msgid "Example 2: Application of a custom name for a datasource"
msgstr "例2：数据源自定义名称的应用"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "In Example 1, the `db-kind`(`postgresql`) was used as a service key. In this example, because the datasource is named, according to convention, the datasource name (`fruits-db`) is used instead."
msgstr "在例1中， `db-kind` ( `postgresql` )被用来作为服务键。在这个例子中，由于数据源是被命名的，根据惯例，用数据源名称( `fruits-db` )代替。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "The following example shows that for a named datasource, the datasource name is used as the name of the target resource:"
msgstr "下面的例子显示，对于一个命名的数据源，数据源名称被用作目标资源的名称。"

#. type: Plain text
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "This has the same effect as the following configuration:"
msgstr "这与下面的配置有相同的效果。"

#. type: delimited block =
#: _guides/deploying-to-kubernetes.adoc
#, fuzzy
msgid "For more details about the available properties and how do they work, see the link:https://github.com/servicebinding/spec#workload-projection[Workload Projection] part of the Service Binding specification."
msgstr "有关可用属性及其工作原理的详细信息，请参阅服务绑定规范的 link:https://github.com/servicebinding/spec#workload-projection[工作量预测] 部分。"
