# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-17 15:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/hibernate-orm.adoc:6
#, fuzzy, no-wrap
msgid "Using Hibernate ORM and JPA"
msgstr "使用Hibernate ORM和JPA"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:14
#, fuzzy
msgid "Hibernate ORM is the de facto standard JPA implementation and offers you the full breadth of an Object Relational Mapper.  It works beautifully in Quarkus."
msgstr "Hibernate ORM是事实上的标准JPA实现，为你提供了对象关系映射器的全部范围。它在Quarkus中运行得非常好。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:15
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:19
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。然而，你可以直接进入已完成的例子。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:21
#, fuzzy
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库。 `git clone {quickstarts-clone-url}` ，或者下载一个{quickstarts-archive-url}[存档]。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:23
#, fuzzy
msgid "The solution is located in the `hibernate-orm-quickstart` {quickstarts-tree-url}/hibernate-orm-quickstart[directory]."
msgstr "该解决方案位于 `hibernate-orm-quickstart` {quickstarts-treeurl}/hibernate-orm-quickstart[目录]中。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:24
#, fuzzy, no-wrap
msgid "Setting up and configuring Hibernate ORM"
msgstr "设置和配置Hibernate ORM"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:27
#, fuzzy
msgid "When using Hibernate ORM in Quarkus, you don't need to have a `persistence.xml` resource to configure it."
msgstr "在Quarkus中使用Hibernate ORM时，你不需要有 `persistence.xml` 资源来配置它。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:30
#, fuzzy
msgid "Using such a classic configuration file is an option, but unnecessary unless you have specific advanced needs; so we'll see first how Hibernate ORM can be configured without a `persistence.xml` resource."
msgstr "使用这样一个经典的配置文件是一种选择，但没有必要，除非你有特定的高级需求；所以我们先看看如何在没有 `persistence.xml` 资源的情况下配置Hibernate ORM。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:32
#, fuzzy
msgid "In Quarkus, you only need to:"
msgstr "在Quarkus，你只需要。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:34
#, fuzzy
msgid "add your configuration settings in `{config-file}`"
msgstr "中添加你的配置设置。 `{config-file}` "

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:35
#, fuzzy
msgid "annotate your entities with `@Entity` and any other mapping annotation as usual"
msgstr "像往常一样用 `@Entity` 和任何其他的映射注解来注解你的实体"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:37
#, fuzzy
msgid "Other configuration needs have been automated: Quarkus will make some opinionated choices and educated guesses."
msgstr "其他的配置需求已经自动化了。Quarkus会做出一些有意见的选择和有根据的猜测。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:39
#, fuzzy
msgid "Add the following dependencies to your project:"
msgstr "在你的项目中添加以下依赖项。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:41
#, fuzzy
msgid "the Hibernate ORM extension: `io.quarkus:quarkus-hibernate-orm`"
msgstr "Hibernate ORM扩展。 `io.quarkus:quarkus-hibernate-orm` "

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:42
#, fuzzy
msgid "your JDBC driver extension; the following options are available:"
msgstr "你的JDBC驱动扩展；以下是可用的选项。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:43
#, fuzzy
msgid "`quarkus-jdbc-db2` for link:https://www.ibm.com/products/db2-database[IBM DB2]"
msgstr " `quarkus-jdbc-db2` 用于 link:https://www.ibm.com/products/db2-database[IBM DB2]"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:44
#, fuzzy
msgid "`quarkus-jdbc-derby` for link:https://db.apache.org/derby/[Apache Derby]"
msgstr " `quarkus-jdbc-derby` 为 link:https://db.apache.org/derby/[阿帕奇德比]"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:45
#, fuzzy
msgid "`quarkus-jdbc-h2` for link:https://www.h2database.com/html/main.html[H2]"
msgstr " `quarkus-jdbc-h2` 为 link:https://www.h2database.com/html/main.html[H2]"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:46
#, fuzzy
msgid "`quarkus-jdbc-mariadb` for link:https://mariadb.com/[MariaDB]"
msgstr " `quarkus-jdbc-mariadb` 用于 link:https://mariadb.com/[MariaDB]"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:47
#, fuzzy
msgid "`quarkus-jdbc-mssql` for link:https://www.microsoft.com/en-gb/sql-server/[Microsoft SQL Server]"
msgstr " `quarkus-jdbc-mssql` 适用于 link:https://www.microsoft.com/en-gb/sql-server/[Microsoft SQL Server]"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:48
#, fuzzy
msgid "`quarkus-jdbc-mysql` for link:https://www.mysql.com/[MySQL]"
msgstr " `quarkus-jdbc-mysql` 用于 link:https://www.mysql.com/[MySQL]"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:49
#, fuzzy
msgid "`quarkus-jdbc-oracle` for link:https://www.oracle.com/database/[Oracle Database]"
msgstr " `quarkus-jdbc-oracle` 用于 link:https://www.oracle.com/database/[Oracle数据库]"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:50
#, fuzzy
msgid "`quarkus-jdbc-postgresql` for link:https://www.postgresql.org/[PostgreSQL]"
msgstr " `quarkus-jdbc-postgresql` 用于 link:https://www.postgresql.org/[PostgreSQL]"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:52
#, fuzzy
msgid "For instance:"
msgstr "比如说。"

#. type: Block title
#: upstream/_guides/hibernate-orm.adoc:54
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:61
#, no-wrap
msgid ""
"<!-- Hibernate ORM specific dependencies -->\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-hibernate-orm</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:67
#, no-wrap
msgid ""
"<!-- JDBC driver dependencies -->\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jdbc-postgresql</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/hibernate-orm.adoc:70
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:74
#, no-wrap
msgid ""
"// Hibernate ORM specific dependencies\n"
"implementation(\"io.quarkus:quarkus-hibernate-orm\")\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:77
#, no-wrap
msgid ""
"// JDBC driver dependencies\n"
"implementation(\"io.quarkus:quarkus-jdbc-postgresql\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:81
#, fuzzy
msgid "Annotate your persistent objects with `@Entity`, then add the relevant configuration properties in `{config-file}`."
msgstr "用 `@Entity` 注释你的持久性对象，然后在 `{config-file}` 添加相关的配置属性。"

#. type: Block title
#: upstream/_guides/hibernate-orm.adoc:83
#, fuzzy, no-wrap
msgid "Example `{config-file}`"
msgstr "例子 `{config-file}` "

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:90
#, no-wrap
msgid ""
"# datasource configuration\n"
"quarkus.datasource.db-kind = postgresql\n"
"quarkus.datasource.username = hibernate\n"
"quarkus.datasource.password = hibernate\n"
"quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/hibernate_db\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:93
#, no-wrap
msgid ""
"# drop and create the database at startup (use `update` to only update the schema)\n"
"quarkus.hibernate-orm.database.generation=drop-and-create\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:97
#, fuzzy
msgid "Note that these configuration properties are not the same ones as in your typical Hibernate ORM configuration file.  They will often map to Hibernate ORM configuration properties but could have different names and don't necessarily map 1:1 to each other."
msgstr "请注意，这些配置属性与典型的Hibernate ORM配置文件中的属性不一样。它们通常会映射到Hibernate ORM的配置属性，但可能有不同的名字，而且不一定能1:1地相互映射。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:99
#, fuzzy
msgid "Also, Quarkus will set many Hibernate ORM configuration settings automatically, and will often use more modern defaults."
msgstr "另外，Quarkus会自动设置许多Hibernate ORM的配置设置，并经常使用更现代的默认值。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:101
#, fuzzy
msgid "Please see below section <<hibernate-configuration-properties, Hibernate ORM configuration properties>> for the list of properties you can set in `{config-file}`."
msgstr "请参阅下面的 link:#hibernate-configuration-properties[Hibernate ORM配置属性] 部分，了解你可以在 `{config-file}` 中设置的属性列表。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:103
#, fuzzy
msgid "An `EntityManagerFactory` will be created based on the Quarkus `datasource` configuration as long as the Hibernate ORM extension is listed among your project dependencies."
msgstr "只要Hibernate ORM扩展被列在你的项目依赖中，就会根据Quarkus `datasource` 配置创建一个 `EntityManagerFactory` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:105
#, fuzzy
msgid "The dialect will be selected based on the JDBC driver - unless you set one explicitly."
msgstr "方言将根据JDBC驱动程序来选择--除非你明确设置了一个。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:107
#, fuzzy
msgid "You can then happily inject your `EntityManager`:"
msgstr "然后，你可以愉快地注入你的 `EntityManager` 。"

#. type: Block title
#: upstream/_guides/hibernate-orm.adoc:109
#, fuzzy, no-wrap
msgid "Example application bean using Hibernate"
msgstr "使用Hibernate的应用豆实例"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:115
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class SantaClausService {\n"
"    @Inject\n"
"    EntityManager em; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:123
#, no-wrap
msgid ""
"    @Transactional <2>\n"
"    public void createGift(String giftDescription) {\n"
"        Gift gift = new Gift();\n"
"        gift.setName(giftDescription);\n"
"        em.persist(gift);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:126
#, fuzzy
msgid "Inject your entity manager and have fun"
msgstr "注入你的实体管理人并获得乐趣"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:127
#, fuzzy
msgid "Mark your CDI bean method as `@Transactional` and the `EntityManager` will enlist and flush at commit."
msgstr "将你的CDI Bean方法标记为 `@Transactional` ， `EntityManager` ，并在提交时进行enlist和flush。"

#. type: Block title
#: upstream/_guides/hibernate-orm.adoc:129
#, fuzzy, no-wrap
msgid "Example Entity"
msgstr "实体实例"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:135
#, no-wrap
msgid ""
"@Entity\n"
"public class Gift {\n"
"    private Long id;\n"
"    private String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:142
#, no-wrap
msgid ""
"    @Id\n"
"    @SequenceGenerator(name = \"giftSeq\", sequenceName = \"gift_id_seq\", allocationSize = 1, initialValue = 1)\n"
"    @GeneratedValue(generator = \"giftSeq\")\n"
"    public Long getId() {\n"
"        return id;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:146
#, no-wrap
msgid ""
"    public void setId(Long id) {\n"
"        this.id = id;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:150
#, no-wrap
msgid ""
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:155
#, no-wrap
msgid ""
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:160
#, fuzzy
msgid "To load SQL statements when Hibernate ORM starts, add an `import.sql` file to the root of your resources directory.  This script can contain any SQL DML statements.  Make sure to terminate each statement with a semicolon."
msgstr "为了在Hibernate ORM启动时加载SQL语句，在资源目录的根部添加一个 `import.sql` 文件。这个脚本可以包含任何SQL DML语句。确保每条语句都用分号来结束。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:162
#, fuzzy
msgid "This is useful to have a data set ready for your tests or demos."
msgstr "这对于为你的测试或演示准备一个数据集是很有用的。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:166
#, fuzzy
msgid "Make sure to wrap methods modifying your database (e.g. `entity.persist()`) within a transaction. Marking a CDI bean method `@Transactional` will do that for you and make that method a transaction boundary. We recommend doing so at your application entry point boundaries like your REST endpoint controllers."
msgstr "请确保将修改数据库的方法（例如： `entity.persist()` ）包裹在一个事务中。将CDI bean方法标记为 `@Transactional` ，将为你做到这一点，并使该方法成为一个事务边界。我们建议在你的应用入口点边界这样做，比如你的REST端点控制器。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:168
#, fuzzy, no-wrap
msgid "Hibernate ORM configuration properties"
msgstr "Hibernate ORM配置属性"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:171
#, fuzzy
msgid "There are various optional properties useful to refine your `EntityManagerFactory` or guide guesses of Quarkus."
msgstr "有各种可选的属性，对完善你的 `EntityManagerFactory` ，或指导猜测Quarkus很有用。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:173
#, fuzzy
msgid "There are no required properties, as long as a default datasource is configured."
msgstr "只要配置了一个默认的数据源，就没有必要的属性。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:176
#, fuzzy
msgid "When no property is set, Quarkus can typically infer everything it needs to setup Hibernate ORM and will have it use the default datasource."
msgstr "当没有设置任何属性时，Quarkus通常可以推断出设置Hibernate ORM所需的一切，并让它使用默认的数据源。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:178
#, fuzzy
msgid "The configuration properties listed here allow you to override such defaults, and customize and tune various aspects."
msgstr "这里列出的配置属性允许你覆盖这些默认值，并自定义和调整各方面。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:186
#, fuzzy
msgid "Do not mix `persistence.xml` and `quarkus.hibernate-orm.*` properties in `{config-file}`.  Quarkus will raise an exception.  Make up your mind on which approach you want to use."
msgstr "不要把 `persistence.xml` 和 `quarkus.hibernate-orm.*` 属性混在一起，在 `{config-file}` 。Quarkus会引发一个异常。在你想使用哪种方法时要下定决心。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:191
#, fuzzy
msgid "Want to start a PostgreSQL server on the side with Docker?"
msgstr "想用Docker启动一个PostgreSQL服务器吗？"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:197
#, no-wrap
msgid ""
"docker run --rm=true --name postgres-quarkus-hibernate -e POSTGRES_USER=hibernate \\\n"
"           -e POSTGRES_PASSWORD=hibernate -e POSTGRES_DB=hibernate_db \\\n"
"           -p 5432:5432 postgres:14.1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:200
#, fuzzy
msgid "This will start a non-durable empty database: ideal for a quick experiment!"
msgstr "这将启动一个非持久性的空数据库：是快速实验的理想选择。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:203
#, fuzzy, no-wrap
msgid "Multiple persistence units"
msgstr "多个持久性单元"

#. type: Title ====
#: upstream/_guides/hibernate-orm.adoc:205
#, fuzzy, no-wrap
msgid "Setting up multiple persistence units"
msgstr "设置多个持久性单元"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:208
#, fuzzy
msgid "It is possible to define multiple persistence units using the Quarkus configuration properties."
msgstr "可以使用Quarkus配置属性来定义多个持久化单元。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:211
#, fuzzy
msgid "The properties at the root of the `quarkus.hibernate-orm.` namespace define the default persistence unit.  For instance, the following snippet defines a default datasource and a default persistence unit:"
msgstr " `quarkus.hibernate-orm.` 命名空间根部的属性定义了默认持久化单元。例如，下面的片段定义了一个默认的数据源和一个默认的持久化单元。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:216
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=h2\n"
"quarkus.datasource.jdbc.url=jdbc:h2:mem:default;DB_CLOSE_DELAY=-1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:219
#, no-wrap
msgid ""
"quarkus.hibernate-orm.dialect=org.hibernate.dialect.H2Dialect\n"
"quarkus.hibernate-orm.database.generation=drop-and-create\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:222
#, fuzzy
msgid "Using a map based approach, it is possible to define named persistence units:"
msgstr "使用基于地图的方法，有可能定义命名的持久化单元。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:227
#, no-wrap
msgid ""
"quarkus.datasource.\"users\".db-kind=h2 <1>\n"
"quarkus.datasource.\"users\".jdbc.url=jdbc:h2:mem:users;DB_CLOSE_DELAY=-1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:230
#, no-wrap
msgid ""
"quarkus.datasource.\"inventory\".db-kind=h2 <2>\n"
"quarkus.datasource.\"inventory\".jdbc.url=jdbc:h2:mem:inventory;DB_CLOSE_DELAY=-1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:234
#, no-wrap
msgid ""
"quarkus.hibernate-orm.\"users\".database.generation=drop-and-create <3>\n"
"quarkus.hibernate-orm.\"users\".datasource=users <4>\n"
"quarkus.hibernate-orm.\"users\".packages=org.acme.model.user <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:238
#, no-wrap
msgid ""
"quarkus.hibernate-orm.\"inventory\".database.generation=drop-and-create <6>\n"
"quarkus.hibernate-orm.\"inventory\".datasource=inventory\n"
"quarkus.hibernate-orm.\"inventory\".packages=org.acme.model.inventory\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:240
#, fuzzy
msgid "Define a datasource named `users`."
msgstr "定义一个名为 `users` 的数据源。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:241
#, fuzzy
msgid "Define a datasource named `inventory`."
msgstr "定义一个名为 `inventory` 的数据源。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:242
#, fuzzy
msgid "Define a persistence unit called `users`."
msgstr "定义一个名为 `users` 的持久化单元。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:243
#, fuzzy
msgid "Define the datasource used by the persistence unit."
msgstr "定义持久化单元所使用的数据源。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:244
#, fuzzy
msgid "This configuration property is important but we will discuss it a bit later."
msgstr "这个配置属性很重要，但我们稍后会讨论它。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:245
#, fuzzy
msgid "Define a persistence unit called `inventory` pointing to the `inventory` datasource."
msgstr "定义一个名为 `inventory` 的持久化单元，指向 `inventory` 数据源。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:249
#, fuzzy
msgid "You can mix the default datasource and named datasources or only have one or the other."
msgstr "你可以混合使用默认数据源和命名数据源，也可以只使用其中一种。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:257
#, fuzzy
msgid "The default persistence unit points to the default datasource by default.  For named persistence units, the `datasource` property is mandatory.  You can point your persistence unit to the default datasource by setting it to `<default>` (which is the internal name of the default datasource)."
msgstr "默认的持久化单元默认指向默认的数据源。对于命名的持久化单元， `datasource` 属性是强制性的。你可以将你的持久化单元指向默认数据源，方法是将其设置为 `<default>` （这是默认数据源的内部名称）。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:259
#, fuzzy
msgid "It is perfectly valid to have several persistence units pointing to the same datasource."
msgstr "有几个持久化单元指向同一个数据源是完全有效的。"

#. type: Title ====
#: upstream/_guides/hibernate-orm.adoc:262
#, fuzzy, no-wrap
msgid "Attaching model classes to persistence units"
msgstr "将模型类附加到持久性单元"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:265
#, fuzzy
msgid "There are two ways to attach model classes to persistence units, and they should not be mixed:"
msgstr "有两种方法可以将模型类附加到持久化单元上，它们不应该被混合使用。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:267
#, fuzzy
msgid "Via the `packages` configuration property;"
msgstr "通过 `packages` 配置属性。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:268
#, fuzzy
msgid "Via the `@io.quarkus.hibernate.orm.PersistenceUnit` package-level annotation."
msgstr "通过 `@io.quarkus.hibernate.orm.PersistenceUnit` 包级注解。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:270
#, fuzzy
msgid "If both are mixed, the annotations are ignored and only the `packages` configuration properties are taken into account."
msgstr "如果两者混合在一起，注释将被忽略，只考虑 `packages` 配置属性。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:272
#, fuzzy
msgid "Using the `packages` configuration property is simple:"
msgstr "使用 `packages` 配置属性很简单。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:277
#, no-wrap
msgid ""
"quarkus.hibernate-orm.database.generation=drop-and-create\n"
"quarkus.hibernate-orm.packages=org.acme.model.defaultpu\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:281
#, no-wrap
msgid ""
"quarkus.hibernate-orm.\"users\".database.generation=drop-and-create\n"
"quarkus.hibernate-orm.\"users\".datasource=users\n"
"quarkus.hibernate-orm.\"users\".packages=org.acme.model.user\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:284
#, fuzzy
msgid "This configuration snippet will create two persistence units:"
msgstr "这个配置片段将创建两个持久化单元。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:286
#, fuzzy
msgid "The default one which will contain all the model classes under the `org.acme.model.defaultpu` package, subpackages included."
msgstr "默认的将包含 `org.acme.model.defaultpu` 包下的所有模型类，包括子包。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:287
#, fuzzy
msgid "A named `users` persistence unit which will contain all the model classes under the `org.acme.model.user` package, subpackages included."
msgstr "一个名为 `users` 的持久化单元，它将包含 `org.acme.model.user` 包下的所有模型类，包括子包。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:289
#, fuzzy
msgid "You can attach several packages to a persistence unit:"
msgstr "你可以在一个持久化单元上附加几个包。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:293
#, no-wrap
msgid "quarkus.hibernate-orm.\"users\".packages=org.acme.model.shared,org.acme.model.user\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:296
#, fuzzy
msgid "All the model classes under the `org.acme.model.shared` and `org.acme.model.user` packages will be attached to the `users` persistence unit."
msgstr " `org.acme.model.shared` 和 `org.acme.model.user` 包下的所有模型类将被附加到 `users` 持久性单元。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:298
#, fuzzy
msgid "It is also supported to attach a given model class to several persistence units."
msgstr "它也支持将一个给定的模型类附加到几个持久化单元。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:304
#, fuzzy
msgid "Model classes need to be consistently added to a given persistence unit.  That meant that all dependent model classes of a given entity (mapped super classes, embeddables...) are required to be attached to the persistence unit.  As we are dealing with the persistence unit at the package level, it should be simple enough."
msgstr "模型类需要被一致地添加到一个给定的持久化单元中。这意味着一个给定实体的所有从属模型类（映射的超级类、可嵌入类......）都需要被附加到持久化单元。由于我们是在包级处理持久化单元，这应该是很简单的。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:309
#, fuzzy
msgid "Panache entities can be attached to only one persistence unit."
msgstr "Panache实体只能连接到一个持久性单元。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:312
#, fuzzy
msgid "For entities attached to several persistence units, you cannot use Panache.  You can mix the two approaches though and mix Panache entities and traditional entities where multiple persistence units are required."
msgstr "对于连接到几个持久化单元的实体，你不能使用Panache。不过你可以混合这两种方法，在需要多个持久化单元的地方混合使用Panache实体和传统实体。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:315
#, fuzzy
msgid "If you have a use case for that and clever ideas about how to implement it without cluttering the simplified Panache approach, contact us on the link:{quarkus-mailing-list-index}[quarkus-dev mailing list]."
msgstr "如果你有这方面的用例，以及关于如何实现它而不使简化的Panache方法变得混乱的聪明想法，请在 link:{quarkus-mailing-list-index}[quarkus-dev邮件列表] 中与我们联系。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:319
#, fuzzy
msgid "The second approach to attach model classes to a persistence unit is to use package-level `@io.quarkus.hibernate.orm.PersistenceUnit` annotations.  Again, the two approaches cannot be mixed."
msgstr "将模型类附加到持久化单元的第二种方法是使用包级 `@io.quarkus.hibernate.orm.PersistenceUnit` 注释。同样，这两种方法不能混合使用。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:321
#, fuzzy
msgid "To obtain a configuration similar to the one above with the `packages` configuration property, create a `package-info.java` file with the following content:"
msgstr "为了获得类似于上述 `packages` 配置属性的配置，请创建一个 `package-info.java` 文件，内容如下。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:326
#, no-wrap
msgid ""
"@PersistenceUnit(\"users\") <1>\n"
"package org.acme.model.user;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:328
#, no-wrap
msgid "import io.quarkus.hibernate.orm.PersistenceUnit;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:330
#, fuzzy
msgid "Be careful, use the `@io.quarkus.hibernate.orm.PersistenceUnit` annotation, not the JPA one."
msgstr "请注意，使用 `@io.quarkus.hibernate.orm.PersistenceUnit` 注解，而不是JPA注解。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:335
#, fuzzy
msgid "We only support defining the `@PersistenceUnit` for model classes at the package level, using the `@PersistenceUnit` annotation at the class level is not supported in this case."
msgstr "我们只支持在包级别为模型类定义 `@PersistenceUnit` ，在这种情况下不支持在类级别使用 `@PersistenceUnit` 注解。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:338
#, fuzzy
msgid "Note that, similarly to what we do with the configuration property, we take into account the annotated package but also all its subpackages."
msgstr "请注意，与我们对配置属性所做的类似，我们不仅考虑到被注释的包，还考虑到它的所有子包。"

#. type: Title ====
#: upstream/_guides/hibernate-orm.adoc:339
#, fuzzy, no-wrap
msgid "CDI integration"
msgstr "CDI整合"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:342
#, fuzzy
msgid "If you are familiar with using Hibernate ORM in Quarkus, you probably already have injected the `EntityManager` using CDI:"
msgstr "如果你熟悉在Quarkus中使用Hibernate ORM，你可能已经使用CDI注入了 `EntityManager` 。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:347
#, no-wrap
msgid ""
"@Inject\n"
"EntityManager entityManager;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:350
#, fuzzy
msgid "This will inject the `EntityManager` of the default persistence unit."
msgstr "这将注入默认持久化单元的 `EntityManager` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:352
#, fuzzy
msgid "Injecting the `EntityManager` of a named persistence unit (`users` in our example) is as simple as:"
msgstr "注入一个命名的持久化单元（ `users` 在我们的例子中）的 `EntityManager` ，就像这样简单。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:358
#, no-wrap
msgid ""
"@Inject\n"
"@PersistenceUnit(\"users\") <1>\n"
"EntityManager entityManager;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:360
#, fuzzy
msgid "Here again, we use the same `@io.quarkus.hibernate.orm.PersistenceUnit` annotation."
msgstr "在这里，我们再次使用相同的 `@io.quarkus.hibernate.orm.PersistenceUnit` 注释。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:362
#, fuzzy
msgid "You can inject the `EntityManagerFactory` of a named persistence unit using the exact same mechanism:"
msgstr "你可以使用完全相同的机制注入一个命名的持久化单元的 `EntityManagerFactory` 。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:368
#, no-wrap
msgid ""
"@Inject\n"
"@PersistenceUnit(\"users\")\n"
"EntityManagerFactory entityManagerFactory;\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:371
#, fuzzy, no-wrap
msgid "Setting up and configuring Hibernate ORM with a `persistence.xml`"
msgstr "设置和配置Hibernate ORM与一个 `persistence.xml` "

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:375
#, fuzzy
msgid "Alternatively, you can use a `META-INF/persistence.xml` to set up Hibernate ORM.  This is useful for:"
msgstr "另外，你可以使用 `META-INF/persistence.xml` 来设置Hibernate ORM。这对以下情况很有用。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:377
#, fuzzy
msgid "migrating existing code"
msgstr "迁移现有代码"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:378
#, fuzzy
msgid "when you have relatively complex settings requiring the full flexibility of the configuration"
msgstr "当你有相对复杂的设置需要配置的全部灵活性时"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:379
#, fuzzy
msgid "or if you like it the good old way"
msgstr "或者，如果你喜欢用老方法"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:384
#, fuzzy
msgid "If you have a `persistence.xml`, then you cannot use the `quarkus.hibernate-orm.*` properties and only persistence units defined in `persistence.xml` will be taken into account."
msgstr "如果你有一个 `persistence.xml` ，那么你就不能使用 `quarkus.hibernate-orm.*` 的属性，只有在 `persistence.xml` 中定义的持久性单元才会被考虑在内。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:388
#, fuzzy
msgid "Your `pom.xml` dependencies as well as your Java code would be identical to the precedent example. The only difference is that you would specify your Hibernate ORM configuration in `META-INF/persistence.xml`:"
msgstr "你的 `pom.xml` 依赖项以及你的Java代码将与前面的例子相同。唯一的区别是，你将在 `META-INF/persistence.xml` 中指定你的Hibernate ORM配置。"

#. type: Block title
#: upstream/_guides/hibernate-orm.adoc:390
#, fuzzy, no-wrap
msgid "Example persistence.xml resource"
msgstr "例子 persistence.xml 资源"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:397
#, no-wrap
msgid ""
"<persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\"\n"
"             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"             xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence\n"
"             http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\"\n"
"             version=\"2.1\">\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:399
#, no-wrap
msgid "    <persistence-unit name=\"CustomerPU\" transaction-type=\"JTA\">\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:401
#, no-wrap
msgid "        <description>My customer entities</description>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:405
#, no-wrap
msgid ""
"        <properties>\n"
"            <!-- Connection specific -->\n"
"            <property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.PostgreSQL95Dialect\"/>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:408
#, no-wrap
msgid ""
"            <property name=\"hibernate.show_sql\" value=\"true\"/>\n"
"            <property name=\"hibernate.format_sql\" value=\"true\"/>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:414
#, no-wrap
msgid ""
"            <!--\n"
"                Optimistically create the tables;\n"
"                will cause background errors being logged if they already exist,\n"
"                but is practical to retain existing data across runs (or create as needed) -->\n"
"            <property name=\"javax.persistence.schema-generation.database.action\" value=\"drop-and-create\"/>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:417
#, no-wrap
msgid ""
"            <property name=\"javax.persistence.validation.mode\" value=\"NONE\"/>\n"
"        </properties>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:420
#, no-wrap
msgid ""
"    </persistence-unit>\n"
"</persistence>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:424
#, fuzzy
msgid "When using the `persistence.xml` configuration you are configuring Hibernate ORM directly, so in this case the appropriate reference is the link:{orm-doc-url-prefix}#configurations[documentation on hibernate.org]."
msgstr "当使用 `persistence.xml` 配置时，你是在直接配置Hibernate ORM，所以在这种情况下，适当的参考是 link:{orm-doc-url-prefix}#configurations[hibernate.org上的文档] 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:427
#, fuzzy
msgid "Please remember these are not the same property names as the ones used in the Quarkus `{config-file}`, nor will the same defaults be applied."
msgstr "请记住这些与Quarkus `{config-file}` 中使用的属性名称不同，也不会应用相同的默认值。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:429
#, fuzzy, no-wrap
msgid "XML mapping"
msgstr "XML映射"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:435
#, fuzzy
msgid "Hibernate ORM in Quarkus supports XML mapping.  You can add mapping files following the https://jakarta.ee/specifications/persistence/3.0/jakarta-persistence-spec-3.0.html#a16944[`orm.xml` format (JPA)] or the http://hibernate.org/dtd/hibernate-mapping-3.0.dtd[`hbm.xml` format (specific to Hibernate ORM, deprecated)]:"
msgstr "Quarkus中的Hibernate ORM支持XML映射。你可以按照 link:https://jakarta.ee/specifications/persistence/3.0/jakarta-persistence-spec-3.0.html#a16944[`orm.xml`] 格式（JPA）或 link:http://hibernate.org/dtd/hibernate-mapping-3.0.dtd[`hbm.xml`] 格式（Hibernate ORM专用，已废弃）添加映射文件。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:437
#, fuzzy
msgid "in `application.properties` through the (build-time) link:#quarkus-hibernate-orm_quarkus.hibernate-orm.mapping-files[`quarkus.hibernate-orm.mapping-files`] property."
msgstr "在 `application.properties` ，通过（构建时间）的 link:#quarkus-hibernate-orm_quarkus.hibernate-orm.mapping-files[`quarkus.hibernate-orm.mapping-files`] 属性。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:438
#, fuzzy
msgid "in <<persistence-xml,`persistence.xml`>> through the `<mapping-file>` element."
msgstr "在 link:#persistence-xml[`persistence.xml`] 通过 `<mapping-file>` 元素。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:440
#, fuzzy
msgid "XML mapping files are parsed at build time."
msgstr "XML映射文件在构建时被解析。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:444
#, fuzzy
msgid "The file `META-INF/orm.xml` will always be included by default, if it exists in the classpath."
msgstr "文件 `META-INF/orm.xml` ，如果它存在于classpath中，将总是被默认包含。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:446
#, fuzzy
msgid "If that is not what you want, use `quarkus.hibernate-orm.mapping-files = no-file` or `<mapping-file>no-file</mapping-file>`."
msgstr "如果这不是你想要的，请使用 `quarkus.hibernate-orm.mapping-files = no-file` 或 `<mapping-file>no-file</mapping-file>` 。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:448
#, fuzzy, no-wrap
msgid "Defining entities in external projects or jars"
msgstr "在外部项目或罐子中定义实体"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:452
#, fuzzy
msgid "Hibernate ORM in Quarkus relies on compile-time bytecode enhancements to your entities. If you define your entities in the same project where you build your Quarkus application, everything will work fine."
msgstr "Quarkus中的Hibernate ORM依赖于编译时对实体的字节码增强。如果你在构建Quarkus应用程序的同一个项目中定义你的实体，一切都会很顺利。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:455
#, fuzzy
msgid "If the entities come from external projects or jars, you can make sure that your jar is treated like a Quarkus application library by adding an empty `META-INF/beans.xml` file."
msgstr "如果实体来自外部项目或jar，你可以通过添加一个空的 `META-INF/beans.xml` 文件来确保你的jar被当作Quarkus应用程序库。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:457
#, fuzzy
msgid "This will allow Quarkus to index and enhance your entities as if they were inside the current project."
msgstr "这将允许Quarkus对你的实体进行索引和增强，就像它们在当前项目中一样。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:459
#, fuzzy, no-wrap
msgid "Hibernate ORM in development mode"
msgstr "开发模式下的Hibernate ORM"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:462
#, fuzzy
msgid "Quarkus development mode is really useful for applications that mix front end or services and database access."
msgstr "Quarkus开发模式对于混合了前端或服务和数据库访问的应用程序来说确实非常有用。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:464
#, fuzzy
msgid "There are a few common approaches to make the best of it."
msgstr "有几种常见的方法可以使其达到最佳效果。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:466
#, fuzzy
msgid "The first choice is to use `quarkus.hibernate-orm.database.generation=drop-and-create` in conjunction with `import.sql`."
msgstr "第一种选择是将 `quarkus.hibernate-orm.database.generation=drop-and-create` ，与 `import.sql` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:471
#, fuzzy
msgid "That way for every change to your app and in particular to your entities, the database schema will be properly recreated and your data fixture (stored in `import.sql`) will be used to repopulate it from scratch.  This is best to perfectly control your environment and works magic with Quarkus live reload mode: your entity changes or any change to your `import.sql` is immediately picked up and the schema updated without restarting the application!"
msgstr "这样，对于你的应用程序，特别是你的实体的每一个变化，数据库模式将被正确地重新创建，你的数据夹具（存储在 `import.sql` ）将被用来从头开始重新填充它。这对完美控制你的环境是最好的，并且在Quarkus实时重载模式下有神奇的效果：你的实体变化或对你的 `import.sql` 的任何变化都会被立即接收并更新模式，而无需重新启动应用程序"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:476
#, fuzzy
msgid "By default in `dev` and `test` modes, Hibernate ORM, upon boot, will read and execute the SQL statements in the `/import.sql` file (if present).  You can change the file name by changing the property `quarkus.hibernate-orm.sql-load-script` in `application.properties`."
msgstr "在 `dev` 和 `test` 模式下，默认情况下，Hibernate ORM在启动时将读取并执行 `/import.sql` 文件中的SQL语句（如果存在）。你可以通过改变 `application.properties` 中的属性 `quarkus.hibernate-orm.sql-load-script` 来改变文件名。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:486
#, fuzzy
msgid "The second approach is to use `quarkus.hibernate-orm.database.generation=update`.  This approach is best when you do many entity changes but still need to work on a copy of the production data or if you want to reproduce a bug that is based on specific database entries.  `update` is a best effort from Hibernate ORM and will fail in specific situations including altering your database structure which could lead to data loss.  For example if you change structures which violate a foreign key constraint, Hibernate ORM might have to bail out.  But for development, these limitations are acceptable."
msgstr "第二种方法是使用 `quarkus.hibernate-orm.database.generation=update` 。当你做了许多实体的改变，但仍然需要在生产数据的副本上工作，或者你想重现一个基于特定数据库条目的错误时，这种方法是最好的。 `update` 是Hibernate ORM的最大努力，在特定情况下会失败，包括改变你的数据库结构，可能导致数据丢失。例如，如果你改变了违反外键约束的结构，Hibernate ORM可能不得不跳出。但是对于开发来说，这些限制是可以接受的。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:490
#, fuzzy
msgid "The third approach is to use `quarkus.hibernate-orm.database.generation=none`.  This approach is best when you are working on a copy of the production data but want to fully control the schema evolution.  Or if you use a database schema migration tool like xref:flyway.adoc[Flyway] or xref:liquibase.adoc[Liquibase]."
msgstr "第三种方法是使用 `quarkus.hibernate-orm.database.generation=none` 。当你在生产数据的副本上工作，但想完全控制模式的演变时，这种方法是最好的。或者如果你使用一个数据库模式迁移工具，如 link:flyway.html[Flyway] 或 link:liquibase.html[Liquibase] 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:493
#, fuzzy
msgid "With this approach when making changes to an entity, make sure to adapt the database schema accordingly; you could also use `validate` to have Hibernate verify the schema matches its expectations."
msgstr "通过这种方法，当对实体进行修改时，确保相应地调整数据库模式；你也可以使用 `validate` ，让Hibernate验证模式是否符合它的期望。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:495
#, fuzzy
msgid "Do not use `quarkus.hibernate-orm.database.generation` `drop-and-create` and `update` in your production environment."
msgstr "不要在你的生产环境中使用 `quarkus.hibernate-orm.database.generation` `drop-and-create` 和 `update` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:501
#, fuzzy
msgid "These approaches become really powerful when combined with Quarkus configuration profiles.  You can define different xref:config.adoc#configuration-profiles[configuration profiles] to select different behaviors depending on your environment.  This is great because you can define different combinations of Hibernate ORM properties matching the development style you currently need."
msgstr "这些方法在与Quarkus配置文件相结合时变得非常强大。你可以定义不同的 link:config.html#configuration-profiles[配置文件] ，根据你的环境选择不同的行为。这很好，因为你可以定义不同的Hibernate ORM属性组合，以匹配你当前需要的开发风格。"

#. type: Block title
#: upstream/_guides/hibernate-orm.adoc:503
#: upstream/_guides/hibernate-orm.adoc:538
#, fuzzy, no-wrap
msgid "application.properties"
msgstr "应用程序.属性"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:507
#, no-wrap
msgid ""
"%dev.quarkus.hibernate-orm.database.generation = drop-and-create\n"
"%dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:510
#, no-wrap
msgid ""
"%dev-with-data.quarkus.hibernate-orm.database.generation = update\n"
"%dev-with-data.quarkus.hibernate-orm.sql-load-script = no-file\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:513
#: upstream/_guides/hibernate-orm.adoc:542
#, no-wrap
msgid ""
"%prod.quarkus.hibernate-orm.database.generation = none\n"
"%prod.quarkus.hibernate-orm.sql-load-script = no-file\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:516
#, fuzzy
msgid "You can start dev mode using a custom profile:"
msgstr "你可以使用自定义配置文件启动开发模式。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:521
#, fuzzy, no-wrap
msgid "Hibernate ORM in production mode"
msgstr "生产模式下的Hibernate ORM"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:525
#, fuzzy
msgid "Quarkus comes with default profiles (`dev`, `test` and `prod`).  And you can add your own custom profiles to describe various environments (`staging`, `prod-us`, etc)."
msgstr "Quarkus带有默认的配置文件 ( `dev` , `test` 和 `prod` ) 。而且你可以添加你自己的自定义配置文件来描述各种环境（ `staging` , `prod-us` , 等等）。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:527
#, fuzzy
msgid "The Hibernate ORM Quarkus extension sets some default configurations differently in dev and test modes than in other environments."
msgstr "Hibernate ORM Quarkus扩展在开发和测试模式下设置的一些默认配置与其他环境下不同。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:529
#, fuzzy
msgid "`quarkus.hibernate-orm.sql-load-script` is set to `no-file` for all profiles except the `dev` and `test` ones."
msgstr " `quarkus.hibernate-orm.sql-load-script` 除了 和 ，所有的配置文件都被设置为 。 `dev` `test` `no-file` "

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:533
#, fuzzy
msgid "You can override it in your `application.properties` explicitly (e.g. `%prod.quarkus.hibernate-orm.sql-load-script = import.sql`)  but we wanted you to avoid overriding your database by accident in prod :)"
msgstr "你可以在你的 `application.properties` 中明确地覆盖它（例如 `%prod.quarkus.hibernate-orm.sql-load-script = import.sql` ），但我们希望你能避免在prod中意外地覆盖你的数据库 :)"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:536
#, fuzzy
msgid "Speaking of, make sure to not drop your database schema in production! Add the following in your properties file."
msgstr "说到这里，请确保在生产中不要丢弃你的数据库模式!在你的属性文件中添加以下内容。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:545
#, fuzzy, no-wrap
msgid "Automatically transitioning to Flyway to Manage Schemas"
msgstr "自动过渡到Flyway来管理模式"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:551
#, fuzzy
msgid "If you have the xref:flyway.adoc[Flyway extension] installed when running in development mode, Quarkus provides a simple way to turn your Hibernate ORM auto generated schema into a Flyway migration file. This is intended to make is easy to move from the early development phase, where Hibernate can be used to quickly setup the schema, to the production phase, where Flyway is used to manage schema changes."
msgstr "如果你在开发模式下安装了 link:flyway.html[Flyway扩展] ，Quarkus提供了一个简单的方法，将你的Hibernate ORM自动生成的模式变成Flyway迁移文件。这样做的目的是为了方便从早期的开发阶段（Hibernate可以用来快速设置模式）到生产阶段（Flyway可以用来管理模式变化）。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:554
#, fuzzy
msgid "To use this feature simply open the Dev UI when the `quarkus-flyway` extension is installed and click in the `Datasources` link in the Flyway pane. Hit the `Create Initial Migration` button and the following will happen:"
msgstr "要使用这一功能，只需在安装了 `quarkus-flyway` 扩展后打开Dev UI，点击Flyway窗格中的 `Datasources` 链接。点击 `Create Initial Migration` 按钮，就会发生以下情况。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:556
#, fuzzy
msgid "A `db/migration/V1.0.0__\\{appname\\}.sql` file will be created, containing the SQL Hibernate is running to generate the schema"
msgstr "将创建一个 `db/migration/V1.0.0__{appname}.sql` 文件，其中包含Hibernate正在运行的SQL，以生成模式。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:557
#, fuzzy
msgid "`quarkus.flyway.baseline-on-migrate` will be set, telling Flyway to automatically create its baseline tables"
msgstr " `quarkus.flyway.baseline-on-migrate` 将被设置，告诉Flyway自动创建其基线表"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:558
#, fuzzy
msgid "`quarkus.flyway.migrate-at-start` will be set, telling Flyway to automatically apply migrations on application startup"
msgstr " `quarkus.flyway.migrate-at-start` 将被设置，告诉Flyway在应用程序启动时自动应用迁移。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:559
#, fuzzy
msgid "`%dev.quarkus.flyway.clean-at-start` and `%test.quarkus.flyway.clean-at-start` will be set, to clean the DB after reload in dev/test mode"
msgstr " `%dev.quarkus.flyway.clean-at-start` 和 ，以便在dev/test模式下重新加载后清理DB。 ``%test.quarkus.flyway.clean-at-start` "

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:562
#, fuzzy
msgid "This button is simply a convenience to quickly get you started with Flyway, it is up to you to determine how you want to manage your database schemas in production. In particular the `migrate-at-start` setting may not be right for all environments."
msgstr "这个按钮只是为了方便你快速开始使用Flyway，你可以自行决定如何在生产中管理你的数据库模式。特别是 `migrate-at-start` 的设置可能不适合所有环境。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:564
#, fuzzy, no-wrap
msgid "Caching"
msgstr "缓存"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:567
#, fuzzy
msgid "Applications that frequently read the same entities can see their performance improved when the Hibernate ORM second-level cache is enabled."
msgstr "当启用Hibernate ORM二级缓存时，经常读取相同实体的应用程序可以看到其性能得到改善。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:568
#, fuzzy, no-wrap
msgid "Caching of entities"
msgstr "缓存的实体"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:571
#, fuzzy
msgid "To enable second-level cache, mark the entities that you want cached with `@javax.persistence.Cacheable`:"
msgstr "要启用二级缓存，请用 `@javax.persistence.Cacheable` 标记您想要缓存的实体。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:580
#, no-wrap
msgid ""
"@Entity\n"
"@Cacheable\n"
"public class Country {\n"
"    int dialInCode;\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:583
#, fuzzy
msgid "When an entity is annotated with `@Cacheable`, all its field values are cached except for collections and relations to other entities."
msgstr "当一个实体被注解为 `@Cacheable` ，除了集合和与其他实体的关系，它的所有字段值都被缓存。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:585
#, fuzzy
msgid "This means the entity can be loaded without querying the database, but be careful as it implies the loaded entity might not reflect recent changes in the database."
msgstr "这意味着可以在不查询数据库的情况下加载实体，但要小心，因为这意味着加载的实体可能无法反映数据库中最近的变化。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:586
#, fuzzy, no-wrap
msgid "Caching of collections and relations"
msgstr "集合和关系的缓存"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:589
#, fuzzy
msgid "Collections and relations need to be individually annotated to be cached; in this case the Hibernate specific `@org.hibernate.annotations.Cache` should be used, which requires also to specify the `CacheConcurrencyStrategy`:"
msgstr "集合和关系需要单独注释才能被缓存；在这种情况下，应该使用Hibernate特有的 `@org.hibernate.annotations.Cache` ，这也需要指定 `CacheConcurrencyStrategy` 。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:593
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:598
#, no-wrap
msgid ""
"@Entity\n"
"@Cacheable\n"
"public class Country {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:602
#, no-wrap
msgid ""
"    @OneToMany\n"
"    @Cache(usage = CacheConcurrencyStrategy.READ_ONLY)\n"
"    List<City> cities;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:605
#, no-wrap
msgid ""
"    // ...\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:607
#, fuzzy, no-wrap
msgid "Caching of queries"
msgstr "缓存查询"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:610
#, fuzzy
msgid "Queries can also benefit from second-level caching. Cached query results can be returned immediately to the caller, avoiding to run the query on the database."
msgstr "查询也可以从第二级缓存中受益。缓存的查询结果可以立即返回给调用者，避免了在数据库上运行查询。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:612
#, fuzzy
msgid "Be careful as this implies the results might not reflect recent changes."
msgstr "要小心，因为这意味着结果可能不反映最近的变化。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:614
#, fuzzy
msgid "To cache a query, mark it as cacheable on the `Query` instance:"
msgstr "要缓存一个查询，在 `Query` 实例上把它标记为可缓存。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:619
#, no-wrap
msgid ""
"Query query = ...\n"
"query.setHint(\"org.hibernate.cacheable\", Boolean.TRUE);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:622
#, fuzzy
msgid "If you have a `NamedQuery` then you can enable caching directly on its definition, which will usually be on an entity:"
msgstr "如果你有一个 `NamedQuery` ，那么你可以直接在其定义上启用缓存，这通常是在一个实体上。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:631
#, no-wrap
msgid ""
"@Entity\n"
"@NamedQuery(name = \"Fruits.findAll\",\n"
"      query = \"SELECT f FROM Fruit f ORDER BY f.name\",\n"
"      hints = @QueryHint(name = \"org.hibernate.cacheable\", value = \"true\") )\n"
"public class Fruit {\n"
"   ...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:634
#, fuzzy
msgid "That's all! Caching technology is already integrated and enabled by default in Quarkus, so it's enough to set which ones are safe to be cached."
msgstr "这就是全部!缓存技术已经在Quarkus中集成并默认启用，所以只需设置哪些是安全的缓存。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:635
#, fuzzy, no-wrap
msgid "Tuning of Cache Regions"
msgstr "缓存区域的调整"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:638
#, fuzzy
msgid "Caches store the data in separate regions to isolate different portions of data; such regions are assigned a name, which is useful for configuring each region independently, or to monitor their statistics."
msgstr "缓存将数据存储在不同的区域中，以隔离不同的数据部分；这些区域被分配了一个名称，这对于独立配置每个区域或监控它们的统计数据很有用。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:640
#, fuzzy
msgid "By default entities are cached in regions named after their fully qualified name, e.g. `org.acme.Country`."
msgstr "默认情况下，实体被缓存在以其全称命名的区域中，例如： `org.acme.Country` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:642
#, fuzzy
msgid "Collections are cached in regions named after the fully qualified name of their owner entity and collection field name, separated by `#` character, e.g. `org.acme.Country#cities`."
msgstr "收藏品被缓存在以其所有者实体的全称和收藏品字段名命名的区域中，用 `#` 字符分隔，例如： `org.acme.Country#cities` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:644
#, fuzzy
msgid "All cached queries are by default kept in a single region dedicated to them called `default-query-results-region`."
msgstr "默认情况下，所有的缓存查询都保存在一个专门的区域内，称为 `default-query-results-region` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:646
#, fuzzy
msgid "All regions are bounded by size and time by default. The defaults are `10000` max entries, and `100` seconds as maximum idle time."
msgstr "所有区域都默认以大小和时间为界限。默认情况下， `10000` 最大条目， `100` 秒作为最大空闲时间。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:648
#, fuzzy
msgid "The size of each region can be customized via the `quarkus.hibernate-orm.cache.\"<region_name>\".memory.object-count` property (Replace _<region_name>_ with the actual region name)."
msgstr "每个区域的大小可以通过 `quarkus.hibernate-orm.cache.\"<region_name>\".memory.object-count` 属性来定制（用实际的区域名称替换 _<region_name>_ ）。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:650
#, fuzzy
msgid "To set the maximum idle time, provide the duration (see note on duration's format below) via the `quarkus.hibernate-orm.cache.\"<region_name>\".expiration.max-idle` property (Replace _<region_name>_ with the actual region name)."
msgstr "要设置最大空闲时间，通过 `quarkus.hibernate-orm.cache.\"<region_name>\".expiration.max-idle` 属性提供持续时间（见下文关于持续时间格式的说明）（用实际区域名称替换 _<region_name>_ ）。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:654
#, fuzzy
msgid "The double quotes are mandatory if your region name contains a dot. For instance:"
msgstr "如果你的区域名称包含一个点，那么双引号是必须的。例如。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:658
#, no-wrap
msgid "quarkus.hibernate-orm.cache.\"org.acme.MyEntity\".memory.object-count=1000\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:664
#, fuzzy, no-wrap
msgid "Limitations of Caching"
msgstr "缓存的局限性"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:667
#, fuzzy
msgid "The caching technology provided within Quarkus is currently quite rudimentary and limited."
msgstr "Quarkus中提供的缓存技术目前是相当初级和有限的。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:669
#, fuzzy
msgid "The team thought it was better to have _some_ caching capability to start with, than having nothing; you can expect better caching solution to be integrated in future releases, and any help and feedback in this area is very welcome."
msgstr "团队认为一开始就有 _一些_ 缓存能力，比什么都没有要好；你可以期待在未来的版本中集成更好的缓存解决方案，我们非常欢迎在这方面的任何帮助和反馈。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:673
#, fuzzy
msgid "These caches are kept locally, so they are not invalidated or updated when changes are made to the persistent store by other applications."
msgstr "这些缓存被保存在本地，所以当其他应用程序对持久性存储进行更改时，它们不会被废止或更新。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:675
#, fuzzy
msgid "Also, when running multiple copies of the same application (in a cluster, for example on Kubernetes/OpenShift), caches in separate copies of the application aren't synchronized."
msgstr "此外，当运行同一应用程序的多个副本时（在集群中，例如在Kubernetes/OpenShift上），应用程序的不同副本中的缓存并不同步。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:677
#, fuzzy
msgid "For these reasons, enabling caching is only suitable when certain assumptions can be made: we strongly recommend that only entities, collections and queries which never change are cached. Or at most, that when indeed such an entity is mutated and allowed to be read out of date (stale) this has no impact on the expectations of the application."
msgstr "由于这些原因，只有在可以做出某些假设的情况下，启用缓存才是合适的：我们强烈建议，只有永远不会改变的实体、集合和查询被缓存。或者最多，当这样的实体确实发生变化并被允许读出过时（stale）时，这对应用程序的预期没有影响。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:679
#, fuzzy
msgid "Following this advice guarantees applications get the best performance out of the second-level cache and yet avoid unexpected behaviour."
msgstr "遵循这个建议可以保证应用程序从二级缓存中获得最好的性能，同时又能避免意外行为。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:684
#, fuzzy, no-wrap
msgid ""
"On top of immutable data, in certain contexts it might be acceptable to enable caching also on mutable data; this could be a necessary tradeoff on selected\n"
" entities which are read frequently and for which some degree of staleness is acceptable; this \" acceptable degree of staleness\" can be tuned by setting eviction properties.\n"
" This is however not recommended and should be done with extreme care, as it might\n"
" produce unexpected and unforeseen effects on the data.\n"
msgstr "在不可变数据的基础上，在某些情况下，在可变数据上启用缓存也是可以接受的；这可能是对选定的实体的必要权衡，因为这些实体经常被读取，而且某种程度的呆滞是可以接受的；这种 \"可接受的呆滞程度 \"可以通过设置驱逐属性进行调整。然而，这并不推荐，而且应该非常小心，因为它可能会对数据产生意想不到的和不可预见的影响。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:686
#, fuzzy
msgid "Rather than enabling caching on mutable data, ideally a better solution would be to use a clustered cache; however at this time Quarkus doesn't provide any such implementation: feel free to get in touch and let this need known so that the team can take this into account."
msgstr "与其在易变数据上启用缓存，理想情况下，更好的解决方案是使用集群缓存；但目前Quarkus没有提供任何这样的实现：请随时联系并告知这一需求，以便团队能够考虑到这一点。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:689
#, fuzzy
msgid "Finally, the second-level cache can be disabled globally by setting `hibernate.cache.use_second_level_cache` to `false`; this is a setting that needs to be specified in the `persistence.xml` configuration file."
msgstr "最后，可以通过将 `hibernate.cache.use_second_level_cache` 设置为 `false` 来全局禁用二级缓存；这是一个需要在 `persistence.xml` 配置文件中指定的设置。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:691
#, fuzzy
msgid "When second-level cache is disabled, all cache annotations are ignored and all queries are run ignoring caches; this is generally useful only to diagnose issues."
msgstr "当二级缓存被禁用时，所有的缓存注释都会被忽略，所有的查询都会忽略缓存的运行；这通常只对诊断问题有用。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:693
#, fuzzy, no-wrap
msgid "Hibernate Envers"
msgstr "冬眠的环境"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:695
#, fuzzy
msgid "The Envers extension to Hibernate ORM aims to provide an easy auditing / versioning solution for entity classes."
msgstr "Hibernate ORM的Envers扩展旨在为实体类提供一个简单的审计/版本管理解决方案。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:697
#, fuzzy
msgid "In Quarkus, Envers has a dedicated Quarkus Extension `io.quarkus:quarkus-hibernate-envers`; you just need to add this to your project to start using it."
msgstr "在Quarkus中，Envers有一个专门的Quarkus扩展 `io.quarkus:quarkus-hibernate-envers` ；你只需要把它添加到你的项目中就可以开始使用它。"

#. type: Block title
#: upstream/_guides/hibernate-orm.adoc:699
#, fuzzy, no-wrap
msgid "Additional dependency to enable Hibernate Envers"
msgstr "启用Hibernate Envers的额外依赖性"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:706
#, no-wrap
msgid ""
"    <!-- Add the Hibernate Envers extension -->\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-hibernate-envers</artifactId>\n"
"    </dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:709
#, fuzzy
msgid "At this point the extension does not expose additional configuration properties."
msgstr "在这一点上，该扩展并没有暴露出额外的配置属性。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:711
#, fuzzy
msgid "For more information about Hibernate Envers, see link:https://hibernate.org/orm/envers/[hibernate.org/orm/envers/]."
msgstr "关于Hibernate Envers的更多信息，见 link:https://hibernate.org/orm/envers/[hibernate.org/orm/envers/] 。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:713
#, fuzzy, no-wrap
msgid "Metrics"
msgstr "度量衡"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:718
#, fuzzy
msgid "Either xref:micrometer.adoc[Micrometer] or xref:microprofile-metrics.adoc[SmallRye Metrics] are capable of exposing metrics that Hibernate ORM collects at runtime. To enable exposure of Hibernate metrics on the `/q/metrics` endpoint, make sure your project depends on a metrics extension and set the configuration property `quarkus.hibernate-orm.metrics.enabled` to `true`.  When using link:microprofile-metrics[SmallRye Metrics], metrics will be available under the `vendor` scope."
msgstr "link:micrometer.html[Micrometer] 或 link:microprofile-metrics.html[SmallRye Metrics] 都能够公开Hibernate ORM在运行时收集的度量。要在 `/q/metrics` 端点上启用Hibernate度量的暴露，请确保你的项目依赖于一个度量扩展，并将配置属性 `quarkus.hibernate-orm.metrics.enabled` 设为 `true` 。 当使用 link:microprofile-metrics[SmallRye Metrics] 时，度量将在 `vendor` 范围内可用。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:719
#, fuzzy, no-wrap
msgid "Limitations and other things you should know"
msgstr "限制和其他你应该知道的事情"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:723
#, fuzzy
msgid "Quarkus does not modify the libraries it uses; this rule applies to Hibernate ORM as well: when using this extension you will mostly have the same experience as using the original library."
msgstr "Quarkus不会修改它所使用的库；这个规则也适用于Hibernate ORM：当使用这个扩展时，你大多会有和使用原始库一样的体验。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:727
#, fuzzy
msgid "But while they share the same code, Quarkus does configure some components automatically and injects custom implementations for some extension points; this should be transparent and useful but if you're an expert of Hibernate you might want to know what is being done."
msgstr "但是，虽然它们共享相同的代码，Quarkus确实自动配置了一些组件，并为一些扩展点注入了自定义的实现；这应该是透明和有用的，但如果你是Hibernate的专家，你可能想知道正在做什么。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:728
#, fuzzy, no-wrap
msgid "Automatic build time enhancement"
msgstr "自动构建时间增强"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:732
#, fuzzy
msgid "Hibernate ORM can use build time enhanced entities; normally this is not mandatory but it's useful and will have your applications perform better."
msgstr "Hibernate ORM可以使用构建时增强的实体；通常这不是强制性的，但它很有用，会让你的应用程序性能更好。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:735
#, fuzzy
msgid "Typically you would need to adapt your build scripts to include the Hibernate Enhancement plugins; in Quarkus this is not necessary as the enhancement step is integrated in the build and analysis of the Quarkus application."
msgstr "通常情况下，你需要调整你的构建脚本，以包括Hibernate增强插件；在Quarkus中，这是没有必要的，因为增强步骤已经集成到Quarkus应用程序的构建和分析中。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:740
#, fuzzy
msgid "Due to the usage of enhancement, using the `clone()` method on entities is currently not supported as it will also clone some enhancement-specific fields that are specific to the entity."
msgstr "由于增强的用法，目前不支持在实体上使用 `clone()` 方法，因为它还会克隆一些实体所特有的增强字段。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:742
#, fuzzy
msgid "This limitation might be removed in the future."
msgstr "这一限制可能会在将来被取消。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:744
#, fuzzy, no-wrap
msgid "Automatic integration"
msgstr "自动整合"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:746
#, fuzzy, no-wrap
msgid "Transaction Manager integration"
msgstr "交易管理器集成"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:750
#, fuzzy
msgid "You don't need to set this up, Quarkus automatically injects the reference to the Narayana Transaction Manager.  The dependency is included automatically as a transitive dependency of the Hibernate ORM extension.  All configuration is optional; for more details see xref:transaction.adoc[Using Transactions in Quarkus]."
msgstr "你不需要对此进行设置，Quarkus会自动注入对Narayana事务管理器的引用。这个依赖关系是作为Hibernate ORM扩展的横向依赖关系而自动包含的。所有的配置都是可选的；更多的细节请看在 link:transaction.html[Quarkus中使用交易] 。"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:751
#, fuzzy, no-wrap
msgid "Connection pool"
msgstr "连接池"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:755
#, fuzzy
msgid "Don't need to choose one either. Quarkus automatically includes the Agroal connection pool; configure your datasource as in the above examples and it will setup Hibernate ORM to use Agroal.  More details about this connection pool can be found in xref:datasource.adoc[Quarkus - Datasources]."
msgstr "也不需要选择一个。Quarkus自动包含了Agroal连接池；按照上面的例子配置你的数据源，它将设置Hibernate ORM以使用Agroal。关于这个连接池的更多细节可以在 link:datasource.html[Quarkus - Datasources] 中找到。"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:756
#, fuzzy, no-wrap
msgid "Second Level Cache"
msgstr "第二级缓存"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:759
#, fuzzy
msgid "as explained above in section <<caching,Caching>>, you don't need to pick an implementation.  A suitable implementation based on technologies from link:https://infinispan.org/[Infinispan] and link:https://github.com/ben-manes/caffeine[Caffeine] is included as a transitive dependency of the Hibernate ORM extension, and automatically integrated during the build."
msgstr "如上文 link:#caching[缓存] 部分所解释的，你不需要选择一个实现。一个基于 link:https://infinispan.org/[Infinispan] 和 link:https://github.com/ben-manes/caffeine[Caffeine] 技术的合适的实现被包含在Hibernate ORM扩展的横向依赖中，并在构建过程中自动集成。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:760
#, fuzzy, no-wrap
msgid "Limitations"
msgstr "限制条件"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:762
#, fuzzy, no-wrap
msgid "XML mapping with duplicate files in the classpath"
msgstr "XML映射与classpath中的重复文件"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:764
#, fuzzy
msgid "<<xml-mapping,XML mapping>> files are expected to have a unique path."
msgstr "link:#xml-mapping[XML映射] 文件应该有一个唯一的路径。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:769
#, fuzzy
msgid "In practice, it's only possible to have duplicate XML mapping files in the classpath in very specific scenarios.  For example, if two JARs include a `META-INF/orm.xml` file (with the exact same path, but in different JARs), then the mapping file path `META-INF/orm.xml` can only be referenced from a `persistence.xml` **in the same JAR as the `META-INF/orm.xml` file**."
msgstr "在实践中，只有在非常特殊的情况下，才有可能在classpath中出现重复的XML映射文件。例如，如果两个JAR包含一个 `META-INF/orm.xml` 文件（路径完全相同，但在不同的JAR中），那么映射文件路径 `META-INF/orm.xml` 只能从 *与<code>META-INF/orm.xml</code> 文件相同的JAR中* 的 `persistence.xml` 引用。"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:770
#, fuzzy, no-wrap
msgid "JMX"
msgstr "JMX"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:775
#, fuzzy
msgid "Management beans are not working in GraalVM native images; therefore Hibernate's capability to register statistics and management operations with the JMX bean is disabled when compiling into a native image.  This limitation is likely permanent, as it's not a goal for native images to implement support for JMX. All such metrics can be accessed in other ways."
msgstr "管理Bean在GraalVM原生镜像中不工作；因此在编译到原生镜像时，Hibernate向JMX bean注册统计和管理操作的能力被禁用。这个限制可能是永久性的，因为实现对JMX的支持并不是原生镜像的目标。所有这些指标都可以通过其他方式访问。"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:776
#, fuzzy, no-wrap
msgid "JACC Integration"
msgstr "JACC整合"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:779
#, fuzzy
msgid "Hibernate ORM's capability to integrate with JACC is disabled when building GraalVM native images, as JACC is not available - nor useful - in native mode."
msgstr "在构建GraalVM本地镜像时，Hibernate ORM与JACC集成的能力被禁用，因为JACC在本地模式下不可用--也没有用。"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:780
#, fuzzy, no-wrap
msgid "Binding the Session to ThreadLocal context"
msgstr "将会话绑定到ThreadLocal上下文"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:785
#, fuzzy
msgid "It is not possible to use the `ThreadLocalSessionContext` helper of Hibernate ORM as support for it is not implemented.  Since Quarkus provides out of the box support for CDI, we believe using injection or programmatic CDI lookup to be a better approach.  This feature also didn't integrate well with reactive components and more modern context propagation techniques, making us believe this legacy feature has no future.  If you badly need to bind it to a ThreadLocal it should be trivial to implement in your own code."
msgstr "不可能使用Hibernate ORM的 `ThreadLocalSessionContext` helper，因为没有实现对它的支持。由于Quarkus为CDI提供了开箱即用的支持，我们认为使用注入或编程式CDI查找是一个更好的方法。这个功能也没有很好地与反应式组件和更现代的上下文传播技术整合，使我们相信这个传统的功能没有未来。如果你非常需要把它绑定到一个ThreadLocal上，在你自己的代码中实现它应该是很容易的。"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:786
#, fuzzy, no-wrap
msgid "JNDI"
msgstr "JNDI"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:793
#, fuzzy
msgid "The JNDI technology is commonly used in other runtimes to integrate different components.  A common use case is Java Enterprise servers to bind the TransactionManager and the Datasource components to a name, and then have Hibernate ORM configured to look these components up by name.  But in Quarkus this use case doesn't apply as components are injected directly, making JNDI support an unnecessary legacy.  As a precaution, to avoid unexpected use of JNDI, the whole support for JNDI has been disabled in the Hibernate ORM extension for Quarkus.  This is both a security precaution and an optimisation."
msgstr "JNDI技术常用于其他运行时中，以整合不同的组件。一个常见的用例是Java企业服务器将TransactionManager和Datasource组件绑定到一个名字上，然后让Hibernate ORM配置为通过名字来查找这些组件。但在Quarkus中，这个用例并不适用，因为组件是直接注入的，这使得JNDI支持成为不必要的遗产。作为预防措施，为了避免对JNDI的意外使用，在Quarkus的Hibernate ORM扩展中，已经禁用了对JNDI的全部支持。这既是一种安全预防措施，也是一种优化。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:794
#, fuzzy, no-wrap
msgid "Other notable differences"
msgstr "其他值得注意的差异"

#. type: Labeled list
#: upstream/_guides/hibernate-orm.adoc:796
#, fuzzy, no-wrap
msgid "Format of `import.sql`"
msgstr "样式 `import.sql` "

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:800
#, fuzzy
msgid "When importing a `import.sql` to setup your database, keep in mind that Quarkus reconfigures Hibernate ORM so to require a semicolon (';') to terminate each statement.  The default in Hibernate is to have a statement per line, without requiring a terminator other than newline: remember to convert your scripts to use the ';' terminator character if you're reusing existing scripts.  This is useful so to allow multi-line statements and human friendly formatting."
msgstr "当导入 `import.sql` 来设置你的数据库时，请记住Quarkus重新配置了Hibernate ORM，所以需要用分号（';'）来结束每条语句。在Hibernate中默认的是每行一条语句，不需要换行以外的结束符：如果你重复使用现有的脚本，记得将你的脚本转换为使用';'结束符。这对于允许多行语句和人类友好的格式化是很有用的。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:801
#, fuzzy, no-wrap
msgid "Simplifying Hibernate ORM with Panache"
msgstr "用Panache简化Hibernate ORM"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:804
#, fuzzy
msgid "The xref:hibernate-orm-panache.adoc[Hibernate ORM with Panache] extension facilitates the usage of Hibernate ORM by providing active record style entities (and repositories) and focuses on making your entities trivial and fun to write in Quarkus."
msgstr "link:hibernate-orm-panache.html[Hibernate ORM with Panache] 扩展通过提供活动记录风格的实体（和资源库）来促进Hibernate ORM的使用，并专注于使你的实体在Quarkus中编写得简单而有趣。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:805
#, fuzzy, no-wrap
msgid "Configure your datasource"
msgstr "配置你的数据源"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:809
#, fuzzy
msgid "Datasource configuration is extremely simple, but is covered in a different guide as technically it's implemented by the Agroal connection pool extension for Quarkus."
msgstr "数据源的配置非常简单，但会在另一个指南中介绍，因为从技术上讲，它是由Quarkus的Agroal连接池扩展实现的。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:811
#, fuzzy
msgid "Jump over to xref:datasource.adoc[Quarkus - Datasources] for all details."
msgstr "跳到 link:datasource.html[Quarkus - 数据源] 了解所有细节。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:813
#, fuzzy, no-wrap
msgid "Multitenancy"
msgstr "多租户"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:816
#, fuzzy
msgid "\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:{orm-doc-url-prefix}#multitenacy[Hibernate User Guide])."
msgstr "\"多租户 \"一词，一般适用于软件开发，表示一种架构，其中一个应用程序的单个运行实例同时为多个客户（租户）服务。这在SaaS解决方案中是非常常见的。在这些系统中，隔离与不同租户有关的信息（数据、定制等）是一个特别的挑战。这包括存储在数据库中的每个租户拥有的数据\" link:{orm-doc-url-prefix}#multitenacy[（Hibernate用户指南] ）。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:818
#, fuzzy
msgid "Quarkus currently supports the link:{orm-doc-url-prefix}#multitenacy-separate-database[separate database] and the link:{orm-doc-url-prefix}#multitenacy-separate-schema[separate schema] approach."
msgstr "Quarkus目前支持 link:{orm-doc-url-prefix}#multitenacy-separate-database[独立数据库] 和 link:{orm-doc-url-prefix}#multitenacy-separate-schema[独立模式] 的方法。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:820
#, fuzzy
msgid "To see multitenancy in action, you can check out the {quickstarts-tree-url}/hibernate-orm-multi-tenancy-quickstart[hibernate-orm-multi-tenancy-quickstart] quickstart."
msgstr "要看多租户的操作，你可以查看{quickstarts-tree-url}/hibernate-orm-multi-tenancy-quickstart[hibernate-orm-multi-tenancy-quickstart]快速入门。"

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:821
#, fuzzy, no-wrap
msgid "Writing the application"
msgstr "编写应用程序"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:824
#, fuzzy
msgid "Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:"
msgstr "让我们从实现 `/{tenant}` 端点开始。从下面的源代码可以看出，它只是一个普通的JAX-RS资源。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:832
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import javax.persistence.EntityManager;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:836
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Path(\"/{tenant}\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:839
#, no-wrap
msgid ""
"    @Inject\n"
"    EntityManager entityManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:846
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"fruits\")\n"
"    public Fruit[] getFruits() {\n"
"        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n"
"                .getResultList().toArray(new Fruit[0]);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:848
#: upstream/_guides/hibernate-orm.adoc:885
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:851
#, fuzzy
msgid "In order to resolve the tenant from incoming requests and map it to a specific tenant configuration, you need to create an implementation for the `io.quarkus.hibernate.orm.runtime.tenant.TenantResolver` interface."
msgstr "为了从传入的请求中解析租户并将其映射到特定的租户配置，你需要为 `io.quarkus.hibernate.orm.runtime.tenant.TenantResolver` 接口创建一个实现。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:855
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:858
#: upstream/_guides/hibernate-orm.adoc:902
#, no-wrap
msgid ""
"import io.quarkus.hibernate.orm.runtime.tenant.TenantResolver;\n"
"import io.vertx.ext.web.RoutingContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:862
#, no-wrap
msgid ""
"@PersistenceUnitExtension // <1>\n"
"@RequestScoped // <2>\n"
"public class CustomTenantResolver implements TenantResolver {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:865
#, no-wrap
msgid ""
"    @Inject\n"
"    RoutingContext context;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:870
#, no-wrap
msgid ""
"    @Override\n"
"    public String getDefaultTenantId() {\n"
"        return \"base\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:875
#, no-wrap
msgid ""
"    @Override\n"
"    public String resolveTenantId() {\n"
"        String path = context.request().path();\n"
"        String[] parts = path.split(\"/\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:880
#, no-wrap
msgid ""
"        if (parts.length == 0) {\n"
"            // resolve to default tenant config\n"
"            return getDefaultTenantId();\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:883
#, no-wrap
msgid ""
"        return parts[1];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:888
#, fuzzy
msgid "Annotate the TenantResolver implementation with the `@PersistenceUnitExtension` qualifier to tell Quarkus it should be used in the default persistence unit."
msgstr "用 `@PersistenceUnitExtension` 修饰符来注释TenantResolver的实现，以告诉Quarkus它应该被用于默认的持久化单元。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:890
#, fuzzy
msgid "For <<multiple-persistence-units,named persistence units>>, use `@PersistenceUnitExtension(\"nameOfYourPU\")`."
msgstr "对于 link:#multiple-persistence-units[命名的持久性单元] ，使用 `@PersistenceUnitExtension(\"nameOfYourPU\")` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:891
#, fuzzy
msgid "The bean is made `@RequestScoped` as the tenant resolution depends on the incoming request."
msgstr "由于租户的分辨率取决于传入的请求，所以Bean被做成 `@RequestScoped` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:893
#, fuzzy
msgid "From the implementation above, tenants are resolved from the request path so that in case no tenant could be inferred, the default tenant identifier is returned."
msgstr "从上面的实现来看，租户是从请求路径中解析出来的，因此，如果不能推断出租户，就会返回默认的租户标识。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:897
#, fuzzy
msgid "If you also use xref:security-openid-connect-multitenancy.adoc[OIDC multitenancy] and both OIDC and Hibernate ORM tenant IDs are the same and must be extracted from the Vert.x `RoutingContext` then you can pass the tenant id from the OIDC Tenant Resolver to the Hibernate ORM Tenant Resolver as a `RoutingContext` attribute, for example:"
msgstr "如果你也使用 link:security-openid-connect-multitenancy.html[OIDC多租户] ，并且OIDC和Hibernate ORM租户ID都是一样的，必须从Vert.x `RoutingContext` ，那么你可以把租户ID从OIDC租户解析器传递给Hibernate ORM租户解析器，作为一个 `RoutingContext` 属性，例如。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:906
#, no-wrap
msgid ""
"@PersistenceUnitExtension\n"
"@RequestScoped\n"
"public class CustomTenantResolver implements TenantResolver {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:916
#, no-wrap
msgid ""
"    @Inject\n"
"    RoutingContext context;\n"
"    ...\n"
"    @Override\n"
"    public String resolveTenantId() {\n"
"        // OIDC TenantResolver has already calculated the tenant id and saved it as a RoutingContext `tenantId` attribute:\n"
"        return context.get(\"tenantId\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:919
#, fuzzy, no-wrap
msgid "Configuring the application"
msgstr "配置应用程序"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:924
#, fuzzy
msgid "In general it is not possible to use the Hibernate ORM database generation feature in conjunction with a multitenancy setup.  Therefore you have to disable it and you need to make sure that the tables are created per schema.  The following setup will use the xref:flyway.adoc[Flyway] extension to achieve this goal."
msgstr "一般来说，不可能在多租户设置中使用Hibernate ORM数据库生成功能。因此，你必须禁用它，并且你需要确保表是按模式创建的。下面的设置将使用 link:flyway.html[Flyway] 扩展来实现这一目标。"

#. type: Title ====
#: upstream/_guides/hibernate-orm.adoc:925
#, fuzzy, no-wrap
msgid "SCHEMA approach"
msgstr "SCHEMA方法"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:929
#, fuzzy
msgid "The same data source will be used for all tenants and a schema has to be created for every tenant inside that data source.  CAUTION: Some databases like MariaDB/MySQL do not support database schemas. In these cases you have to use the DATABASE approach below."
msgstr "所有租户将使用相同的数据源，必须为该数据源内的每个租户创建一个模式。注意：有些数据库如MariaDB/MySQL不支持数据库模式。在这些情况下，你必须使用下面的DATABASE方法。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:934
#: upstream/_guides/hibernate-orm.adoc:989
#, no-wrap
msgid ""
"# Disable generation\n"
"quarkus.hibernate-orm.database.generation=none\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:939
#, no-wrap
msgid ""
"# Enable SCHEMA approach and use default datasource\n"
"quarkus.hibernate-orm.multitenant=SCHEMA\n"
"# You could use a non-default datasource by using the following setting \n"
"# quarkus.hibernate-orm.multitenant-schema-datasource=other\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:945
#, no-wrap
msgid ""
"# The default data source used for all tenant schemas\n"
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus_test\n"
"quarkus.datasource.password=quarkus_test\n"
"quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_test\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:950
#, no-wrap
msgid ""
"# Enable Flyway configuration to create schemas\n"
"quarkus.flyway.schemas=base,mycompany\n"
"quarkus.flyway.locations=classpath:schema\n"
"quarkus.flyway.migrate-at-start=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:953
#, fuzzy
msgid "Here is an example of the Flyway SQL (`V1.0.0__create_fruits.sql`) to be created in the configured folder `src/main/resources/schema`."
msgstr "下面是一个例子，Flyway SQL ( `V1.0.0__create_fruits.sql` )要在配置的文件夹 `src/main/resources/schema` 中创建。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:966
#, no-wrap
msgid ""
"CREATE SEQUENCE base.known_fruits_id_seq;\n"
"SELECT setval('base.\"known_fruits_id_seq\"', 3);\n"
"CREATE TABLE base.known_fruits\n"
"(\n"
"  id   INT,\n"
"  name VARCHAR(40)\n"
");\n"
"INSERT INTO base.known_fruits(id, name) VALUES (1, 'Cherry');\n"
"INSERT INTO base.known_fruits(id, name) VALUES (2, 'Apple');\n"
"INSERT INTO base.known_fruits(id, name) VALUES (3, 'Banana');\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:977
#, no-wrap
msgid ""
"CREATE SEQUENCE mycompany.known_fruits_id_seq;\n"
"SELECT setval('mycompany.\"known_fruits_id_seq\"', 3);\n"
"CREATE TABLE mycompany.known_fruits\n"
"(\n"
"  id   INT,\n"
"  name VARCHAR(40)\n"
");\n"
"INSERT INTO mycompany.known_fruits(id, name) VALUES (1, 'Avocado');\n"
"INSERT INTO mycompany.known_fruits(id, name) VALUES (2, 'Apricots');\n"
"INSERT INTO mycompany.known_fruits(id, name) VALUES (3, 'Blackberries');\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/hibernate-orm.adoc:981
#, fuzzy, no-wrap
msgid "DATABASE approach"
msgstr "DATABASE方法"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:984
#, fuzzy
msgid "For every tenant you need to create a named data source with the same identifier that is returned by the `TenantResolver`."
msgstr "对于每个租户，你需要创建一个命名的数据源，其标识符与 `TenantResolver` 。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:992
#, no-wrap
msgid ""
"# Enable DATABASE approach\n"
"quarkus.hibernate-orm.multitenant=DATABASE\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:998
#, no-wrap
msgid ""
"# Default tenant 'base'\n"
"quarkus.datasource.base.db-kind=postgresql\n"
"quarkus.datasource.base.username=quarkus_test\n"
"quarkus.datasource.base.password=quarkus_test\n"
"quarkus.datasource.base.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_test\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:1004
#, no-wrap
msgid ""
"# Tenant 'mycompany'\n"
"quarkus.datasource.mycompany.db-kind=postgresql\n"
"quarkus.datasource.mycompany.username=mycompany\n"
"quarkus.datasource.mycompany.password=mycompany\n"
"quarkus.datasource.mycompany.jdbc.url=jdbc:postgresql://localhost:5433/mycompany\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:1008
#, no-wrap
msgid ""
"# Flyway configuration for the default datasource\n"
"quarkus.flyway.locations=classpath:database/default\n"
"quarkus.flyway.migrate-at-start=true\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:1012
#, no-wrap
msgid ""
"# Flyway configuration for the mycompany datasource\n"
"quarkus.flyway.mycompany.locations=classpath:database/mycompany\n"
"quarkus.flyway.mycompany.migrate-at-start=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1015
#, fuzzy
msgid "Following are examples of the Flyway SQL files to be created in the configured folder `src/main/resources/database`."
msgstr "以下是在配置的文件夹 `src/main/resources/database` ，创建Flyway SQL文件的例子。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1017
#, fuzzy
msgid "Default schema (`src/main/resources/database/default/V1.0.0__create_fruits.sql`):"
msgstr "默认模式( `src/main/resources/database/default/V1.0.0__create_fruits.sql` )。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:1030
#, no-wrap
msgid ""
"CREATE SEQUENCE known_fruits_id_seq;\n"
"SELECT setval('known_fruits_id_seq', 3);\n"
"CREATE TABLE known_fruits\n"
"(\n"
"  id   INT,\n"
"  name VARCHAR(40)\n"
");\n"
"INSERT INTO known_fruits(id, name) VALUES (1, 'Cherry');\n"
"INSERT INTO known_fruits(id, name) VALUES (2, 'Apple');\n"
"INSERT INTO known_fruits(id, name) VALUES (3, 'Banana');\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1033
#, fuzzy
msgid "Mycompany schema (`src/main/resources/database/mycompany/V1.0.0__create_fruits.sql`):"
msgstr "我的公司模式( `src/main/resources/database/mycompany/V1.0.0__create_fruits.sql` )。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:1046
#, no-wrap
msgid ""
"CREATE SEQUENCE known_fruits_id_seq;\n"
"SELECT setval('known_fruits_id_seq', 3);\n"
"CREATE TABLE known_fruits\n"
"(\n"
"  id   INT,\n"
"  name VARCHAR(40)\n"
");\n"
"INSERT INTO known_fruits(id, name) VALUES (1, 'Avocado');\n"
"INSERT INTO known_fruits(id, name) VALUES (2, 'Apricots');\n"
"INSERT INTO known_fruits(id, name) VALUES (3, 'Blackberries');\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/hibernate-orm.adoc:1048
#, fuzzy, no-wrap
msgid "Programmatically Resolving Tenants Connections"
msgstr "有计划地解决租户的联系"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1056
#, fuzzy
msgid "If you need a more dynamic configuration for the different tenants you want to support and don't want to end up with multiple entries in your configuration file, you can use the `io.quarkus.hibernate.orm.runtime.tenant.TenantConnectionResolver` interface to implement your own logic for retrieving a connection.  Creating an application-scoped bean that implements this interface and annotating it with `@PersistenceUnitExtension` (or `@PersistenceUnitExtension(\"nameOfYourPU\")` for a <<multiple-persistence-units,named persistence unit>>)  will replace the current Quarkus default implementation `io.quarkus.hibernate.orm.runtime.tenant.DataSourceTenantConnectionResolver`.  Your custom connection resolver would allow for example to read tenant information from a database and create a connection per tenant at runtime based on it."
msgstr "如果你需要一个更动态的配置来支持不同的租户，并且不想在你的配置文件中出现多个条目，你可以使用 `io.quarkus.hibernate.orm.runtime.tenant.TenantConnectionResolver` 接口来实现你自己的逻辑来检索一个连接。创建一个实现该接口的应用范围的Bean，并用 `@PersistenceUnitExtension` （或 `@PersistenceUnitExtension(\"nameOfYourPU\")` ，用于 link:#multiple-persistence-units[命名的持久化单元] ）来注释它，将取代当前Quarkus的默认实现 `io.quarkus.hibernate.orm.runtime.tenant.DataSourceTenantConnectionResolver` 。你的自定义连接解析器将允许例如从数据库中读取租户信息，并在运行时基于它为每个租户创建一个连接。"

#. type: Title ==
#: upstream/_guides/hibernate-orm.adoc:1058
#, fuzzy, no-wrap
msgid "Interceptors"
msgstr "拦截器"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1062
#, fuzzy
msgid "You can assign an link:{orm-doc-url-prefix}#events-interceptors[`org.hibernate.Interceptor`] to your `SessionFactory` by simply defining a CDI bean with the appropriate qualifier:"
msgstr "你可以为你的 link:{orm-doc-url-prefix}#events-interceptors[`org.hibernate.Interceptor`] 到你的 `SessionFactory` ，只需用适当的限定符定义一个CDI bean。"

#. type: delimited block -
#: upstream/_guides/hibernate-orm.adoc:1074
#, no-wrap
msgid ""
"@PersistenceUnitExtension // <1>\n"
"public static class MyInterceptor extends EmptyInterceptor { // <2>\n"
"    @Override\n"
"    public boolean onLoad(Object entity, Serializable id, Object[] state, // <3>\n"
"            String[] propertyNames, Type[] types) {\n"
"        // ...\n"
"        return false;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1077
#, fuzzy
msgid "Annotate the interceptor implementation with the `@PersistenceUnitExtension` qualifier to tell Quarkus it should be used in the default persistence unit."
msgstr "用 `@PersistenceUnitExtension` 修饰符注释拦截器的实现，以告诉Quarkus它应该被用于默认的持久化单元。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1079
#, fuzzy
msgid "For <<multiple-persistence-units,named persistence units>>, use `@PersistenceUnitExtension(\"nameOfYourPU\")`"
msgstr "对于 link:#multiple-persistence-units[命名的持久化单元] ，使用 `@PersistenceUnitExtension(\"nameOfYourPU\")` "

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1080
#, fuzzy
msgid "Either extend `org.hibernate.EmptyInterceptor` or implement `org.hibernate.Interceptor` directly."
msgstr "要么扩展 `org.hibernate.EmptyInterceptor` ，要么直接实现 `org.hibernate.Interceptor` 。"

#. type: Plain text
#: upstream/_guides/hibernate-orm.adoc:1081
#, fuzzy
msgid "Implement methods as necessary."
msgstr "必要时实施方法。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:1088
#, fuzzy
msgid "By default, interceptor beans annotated with `@PersistenceUnitExtension` are application-scoped, which means only one interceptor instance will be created per application and reused across all entity managers.  For this reason, the interceptor implementation must be thread-safe."
msgstr "默认情况下，用 `@PersistenceUnitExtension` 注释的拦截器Bean是应用范围的，这意味着每个应用只会创建一个拦截器实例，并在所有实体管理器中重复使用。由于这个原因，拦截器的实现必须是线程安全的。"

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:1092
msgid "In order to create one interceptor instance per entity manager instead, annotate your bean with `@Dependent`.  In that case, the interceptor implementation doesn't need to be thread-safe."
msgstr ""

#. type: delimited block =
#: upstream/_guides/hibernate-orm.adoc:1098
msgid "Due to a limitation in Hibernate ORM itself, `@PreDestroy` methods on `@Dependent`-scoped interceptors will never get called."
msgstr ""
