# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-12-14 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi.adoc:6
#, fuzzy, no-wrap
msgid "Introduction to Contexts and Dependency Injection"
msgstr "上下文和依赖性注入简介"

#. type: Plain text
#: upstream/_guides/cdi.adoc:15
#, fuzzy
msgid "In this guide we're going to describe the basic principles of the Quarkus programming model that is based on the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification."
msgstr "在本指南中，我们将描述Quarkus编程模型的基本原则，该模型是基于 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[Java 2.0, target=\"_blank\"] 规范 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[的上下文和依赖注入, target=\"_blank\"] 。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:16
#, fuzzy, no-wrap
msgid "OK. Let's start simple. What is a bean?"
msgstr "好的。让我们从简单的开始。什么是豆子？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:19
#, fuzzy
msgid "Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors."
msgstr "好吧，Bean是一个 _容器管理_ 的对象，它支持一系列的基本服务，如依赖关系的注入、生命周期的回调和拦截器。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:20
#, fuzzy, no-wrap
msgid "Wait a minute. What does \"container-managed\" mean?"
msgstr "等一下。容器管理 \"是什么意思？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:26
#, fuzzy
msgid "Simply put, you don't control the lifecycle of the object instance directly.  Instead, you can affect the lifecycle through declarative means, such as annotations, configuration, etc.  The container is the _environment_ where your application runs.  It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans."
msgstr "简单地说，你并不直接控制对象实例的生命周期。相反，你可以通过声明的方式来影响生命周期，比如注释、配置等。容器是你的应用程序运行的 _环境_ 。它创建和销毁Bean的实例，将实例与指定的上下文相关联，并将其注入到其他Bean中。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:27
#, fuzzy, no-wrap
msgid "What is it good for?"
msgstr "它有什么好处？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:30
#, fuzzy
msgid "An application developer can focus on the business logic rather than finding out \"where and how\" to obtain a fully initialized component with all of its dependencies."
msgstr "应用程序开发人员可以专注于业务逻辑，而不是找出 \"在哪里以及如何 \"获得一个完全初始化的组件及其所有的依赖关系。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:32
#, fuzzy
msgid "You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC."
msgstr "你可能听说过 _控制反转_ （IoC）的编程原则。依赖性注入是IoC的实现技术之一。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:33
#, fuzzy, no-wrap
msgid "What does a bean look like?"
msgstr "豆子是什么样子的？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:37
#, fuzzy
msgid "There are several kinds of beans.  The most common ones are class-based beans:"
msgstr "有几种类型的豆子。最常见的是基于类的豆子。"

#. type: Block title
#: upstream/_guides/cdi.adoc:38
#, fuzzy, no-wrap
msgid "Simple Bean Example"
msgstr "简单的豆类例子"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:44
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
"import org.eclipse.microprofile.metrics.annotation.Counted;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:47
#, no-wrap
msgid ""
"@ApplicationScoped <1>\n"
"public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:50
#, no-wrap
msgid ""
"    @Inject\n"
"    Dictionary dictionary; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:56
#, no-wrap
msgid ""
"    @Counted  <3>\n"
"    String translate(String sentence) { \n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:58
#, fuzzy
msgid "This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all other beans that inject `Translator`."
msgstr "这是一个范围注解。它告诉容器要把 bean 实例与哪个上下文联系起来。在这种特殊情况下，为应用程序创建了一个 *Bean实例* ，并被所有其他注入 `Translator` 的Bean使用。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:59
#, fuzzy
msgid "This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails."
msgstr "这是一个字段注入点。它告诉容器， `Translator` 依赖于 `Dictionary` Bean。如果没有匹配的Bean，则构建失败。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:60
#, fuzzy
msgid "This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics. We will talk about <<interceptors,interceptors>> later."
msgstr "这是一个拦截器绑定注解。在这种情况下，注解来自MicroProfile度量。相关的拦截器会拦截调用并更新相关的度量。我们将在后面谈论 link:#interceptors[拦截器] 。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:62
#, fuzzy, no-wrap
msgid "Nice. How does the dependency resolution work? I see no names or identifiers."
msgstr "不错。依赖关系的解决是如何进行的？我没有看到名称或标识符。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:71
#, fuzzy
msgid "That's a good question.  In CDI the process of matching a bean to an injection point is *type-safe*.  Each bean declares a set of bean types.  In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.  Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.  We'll talk about qualifiers later.  For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`."
msgstr "这是个好问题。在CDI中，将Bean匹配到注入点的过程是 *类型安全的* 。每个Bean都声明了一组Bean类型。在我们上面的例子中， `Translator` Bean有两个bean类型： `Translator` 和 `java.lang.Object` 。随后，如果一个Bean有一个与 _所需类型_ 相匹配的Bean类型，并且有所有 _需要的限定词_ ，那么该Bean就可以被分配到一个注入点。我们将在后面讨论限定词。现在，我们只需要知道上面的Bean可以被分配到类型为 `Translator` 和 `java.lang.Object` 的注入点。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:72
#, fuzzy, no-wrap
msgid "Hm, wait a minute. What happens if multiple beans declare the same type?"
msgstr "嗯，等一下。如果多个豆子声明相同的类型会发生什么？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:78
#, fuzzy
msgid "There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.  If none is assignable the build fails with `UnsatisfiedResolutionException`.  If multiple are assignable the build fails with `AmbiguousResolutionException`.  This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point."
msgstr "有一个简单的规则： *必须有一个bean可以被分配到一个注入点，否则构建失败* 。如果没有一个可分配的Bean，则构建失败， `UnsatisfiedResolutionException` 。如果有多个可分配的Bean，则构建失败， `AmbiguousResolutionException` 。这非常有用，因为只要容器不能为任何注入点找到明确的依赖关系，你的应用程序就会快速失败。"

#. type: delimited block =
#: upstream/_guides/cdi.adoc:82
#, fuzzy
msgid "Your can use programmatic lookup via `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:"
msgstr "你可以通过 `javax.enterprise.inject.Instance` ，在运行时使用程序化的查找来解决歧义，甚至可以遍历所有实现特定类型的bean。"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:86
#, no-wrap
msgid "public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:89
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<Dictionary> dictionaries; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:96
#, no-wrap
msgid ""
"    String translate(String sentence) { \n"
"      for (Dictionary dict : dictionaries) { <2>\n"
"         // ...\n"
"      }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:98
#, fuzzy
msgid "This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type."
msgstr "即使有多个Bean实现了 `Dictionary` 类型，这个注入点也不会导致模糊的依赖关系。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:99
#, fuzzy
msgid "`javax.enterprise.inject.Instance` extends `Iterable`."
msgstr " `javax.enterprise.inject.Instance` 扩展到 。 `Iterable` "

#. type: Title ==
#: upstream/_guides/cdi.adoc:101
#, fuzzy, no-wrap
msgid "Can I use setter and constructor injection?"
msgstr "我可以使用设置器和构造器注入吗？"

#. type: delimited block =
#: upstream/_guides/cdi.adoc:106
#, fuzzy
msgid "Yes, you can.  In fact, in CDI the \"setter injection\" is superseded by more powerful https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#initializer_methods[initializer methods, window=\"_blank\"].  Initializers may accept multiple parameters and don't have to follow the JavaBean naming conventions."
msgstr "是的，你可以。事实上，在CDI中，\"setter注入 \"被更强大的 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#initializer_methods[初始化方法, target=\"_blank\"] 所取代。初始化器可以接受多个参数，而且不需要遵循JavaBean的命名规则。"

#. type: Block title
#: upstream/_guides/cdi.adoc:107
#, fuzzy, no-wrap
msgid "Initialized and Constructor Injection Example"
msgstr "初始化和构造函数注入实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:112 upstream/_guides/cdi.adoc:328
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:114
#, no-wrap
msgid "    private final TranslatorHelper helper;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:118
#, no-wrap
msgid ""
"    Translator(TranslatorHelper helper) { <1>\n"
"       this.helper = helper;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:124
#, no-wrap
msgid ""
"    @Inject <2>\n"
"    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n"
"      / ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:129
#, fuzzy
msgid "This is a constructor injection.  In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor and the bean constructor must be annotated with `@Inject`.  However, in Quarkus we detect the absence of no-args constructor and \"add\" it directly in the bytecode.  It's also not necessary to add `@Inject` if there is only one constructor present."
msgstr "这是一个构造函数注入。事实上，这段代码在常规的CDI实现中是行不通的，因为正常作用域的Bean必须始终声明一个无args的构造函数，并且Bean的构造函数必须被注解为 `@Inject` 。然而，在Quarkus中，我们检测到没有无args的构造函数，并直接在字节码中 \"添加 \"它。如果只有一个构造函数存在，也没有必要添加 `@Inject` 。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:130
#, fuzzy
msgid "An initializer method must be annotated with `@Inject`."
msgstr "一个初始化方法必须用 `@Inject` 。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:131
#, fuzzy
msgid "An initializer may accept multiple parameters - each one is an injection point."
msgstr "一个初始化器可以接受多个参数--每个参数都是一个注入点。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:132
#, fuzzy, no-wrap
msgid "You talked about some qualifiers?"
msgstr "你谈到了一些限定词？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:137
#, fuzzy
msgid "https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.  As we already said a bean is assignable to an injection point if it has all the required qualifiers.  If you declare no qualifier at an injection point the `@Default` qualifier is assumed."
msgstr "link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#qualifiers[限定符, target=\"_blank\"] 是帮助容器区分实现相同类型的Bean的注释。正如我们已经说过的，如果一个Bean拥有所有需要的限定符，它就可以被分配到一个注入点。如果你在一个注入点上没有声明任何限定符，那么就假定 `@Default` 限定符。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:139
#, fuzzy
msgid "A qualifier type is a Java annotation defined as `@Retention(RUNTIME)` and annotated with the `@javax.inject.Qualifier` meta-annotation:"
msgstr "一个限定符类型是一个定义为 `@Retention(RUNTIME)` ，并带有 `@javax.inject.Qualifier` 元注释的Java注释。"

#. type: Block title
#: upstream/_guides/cdi.adoc:140
#, fuzzy, no-wrap
msgid "Qualifier Example"
msgstr "限定词示例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:147
#, no-wrap
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface Superior {}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:150
#, fuzzy
msgid "The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types:"
msgstr "一个Bean的限定词是通过用限定词类型注释Bean类或生产者方法或字段来声明的。"

#. type: Block title
#: upstream/_guides/cdi.adoc:151
#, fuzzy, no-wrap
msgid "Bean With Custom Qualifier Example"
msgstr "带有自定义限定词的豆子示例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:157
#, no-wrap
msgid ""
"@Superior <1>\n"
"@ApplicationScoped\n"
"public class SuperiorTranslator extends Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:162 upstream/_guides/cdi.adoc:232
#, no-wrap
msgid ""
"    String translate(String sentence) { \n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:164
#, fuzzy
msgid "`@Superior` is a https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"]."
msgstr " `@Superior` 是一个 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#defining_qualifier_types[限定符注释, target=\"_blank\"] 。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:168
#, fuzzy
msgid "This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not to `@Inject Translator`.  The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.  And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable."
msgstr "这个bean可以分配给 `@Inject @Superior Translator` 和 `@Inject @Superior SuperiorTranslator` ，但不能分配给 `@Inject Translator` 。原因是 `@Inject Translator` 在 typesafe 解析过程中自动转化为 `@Inject @Default Translator` 。由于我们的 `SuperiorTranslator` 没有声明 `@Default` ，所以只有原始的 `Translator` Bean是可分配的。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:170
#, fuzzy, no-wrap
msgid "[[looks-good-what-is-the-bean-scope]] Looks good. What is the bean scope?"
msgstr "看起来不错。豆类的范围是什么？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:173
#, fuzzy
msgid "The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed."
msgstr "Bean的作用域决定了其实例的生命周期，也就是说，何时何地应该创建和销毁一个实例。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:175
#, fuzzy
msgid "Every bean has exactly one scope."
msgstr "每个豆子正好有一个范围。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:177
#, fuzzy, no-wrap
msgid "[[what-scopes-can-i-actually-use-in-my-quarkus-application]] What scopes can I actually use in my Quarkus application?"
msgstr "在我的Quarkus应用程序中，我究竟可以使用哪些作用域？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:180
#, fuzzy
msgid "You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`."
msgstr "你可以使用规范中提到的所有内置作用域，除了 `javax.enterprise.context.ConversationScoped` 。"

#. type: Table
#: upstream/_guides/cdi.adoc:183
#, fuzzy, no-wrap
msgid "Annotation"
msgstr "注释"

#. type: Table
#: upstream/_guides/cdi.adoc:185
#, fuzzy, no-wrap
msgid ""
"Description   \n"
"//----------------------"
msgstr "描述"

#. type: Table
#: upstream/_guides/cdi.adoc:185
#, fuzzy, no-wrap
msgid "`@javax.enterprise.context.ApplicationScoped`"
msgstr " `@javax.enterprise.context.ApplicationScoped` "

#. type: Table
#: upstream/_guides/cdi.adoc:186
#, fuzzy, no-wrap
msgid "A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>."
msgstr "一个单一的bean实例被用于应用程序，并在所有的注入点之间共享。这个实例是懒惰地创建的，也就是说，一旦在 link:#client_proxies[客户端代理] 上调用了一个方法，就会创建这个实例。"

#. type: Table
#: upstream/_guides/cdi.adoc:186
#, fuzzy, no-wrap
msgid "`@javax.inject.Singleton`"
msgstr " `@javax.inject.Singleton` "

#. type: Table
#: upstream/_guides/cdi.adoc:187
#, fuzzy, no-wrap
msgid "Just like `@ApplicationScoped` except that no client proxy is used. The instance is created when an injection point that resolves to a @Singleton bean is being injected."
msgstr "就像 `@ApplicationScoped` ，只是没有使用客户端代理。当解析到@Singleton Bean的注入点被注入时，该实例被创建。"

#. type: Table
#: upstream/_guides/cdi.adoc:187
#, fuzzy, no-wrap
msgid "`@javax.enterprise.context.RequestScoped`"
msgstr " `@javax.enterprise.context.RequestScoped` "

#. type: Table
#: upstream/_guides/cdi.adoc:188
#, fuzzy, no-wrap
msgid "The bean instance is associated with the current _request_ (usually an HTTP request)."
msgstr "该bean实例与当前 _请求_ （通常是HTTP请求）相关联。"

#. type: Table
#: upstream/_guides/cdi.adoc:188
#, fuzzy, no-wrap
msgid "`@javax.enterprise.context.Dependent`"
msgstr " `@javax.enterprise.context.Dependent` "

#. type: Table
#: upstream/_guides/cdi.adoc:189
#, fuzzy, no-wrap
msgid "This is a pseudo-scope. The instances are not shared and every injection point spawns a new instance of the dependent bean. The lifecycle of dependent bean is bound to the bean injecting it - it will be created and destroyed along with the bean injecting it."
msgstr "这是个伪范围。实例是不共享的，每个注入点都会产生一个新的依赖Bean的实例。从属Bean的生命周期与注入它的Bean相联系--它将与注入它的Bean一起被创建和销毁。"

#. type: Table
#: upstream/_guides/cdi.adoc:189
#, fuzzy, no-wrap
msgid "`@javax.enterprise.context.SessionScoped`"
msgstr " `@javax.enterprise.context.SessionScoped` "

#. type: Table
#: upstream/_guides/cdi.adoc:190
#, fuzzy, no-wrap
msgid "This scope is backed by a `javax.servlet.http.HttpSession` object. It's only available if the `quarkus-undertow` extension is used."
msgstr "这个范围是由一个 `javax.servlet.http.HttpSession` 对象支持的。它只有在使用 `quarkus-undertow` 扩展时才可用。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:193
#, fuzzy
msgid "There can be other custom scopes provided by Quarkus extensions. For example, xref:transaction.adoc[`quarkus-narayana-jta`] provides xref:transaction.adoc#transaction-scope[`javax.transaction.TransactionScoped`]."
msgstr "可以有其他由Quarkus扩展提供的自定义作用域。例如， `quarkus-narayana-jta` 提供 `javax.transaction.TransactionScoped` 。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:194
#, fuzzy, no-wrap
msgid "`@ApplicationScoped` and `@Singleton` look very similar. Which one should I choose for my Quarkus application?"
msgstr " `@ApplicationScoped` 和 看起来非常相似。我应该为我的Quarkus应用程序选择哪一个？ `@Singleton` "

#. type: Plain text
#: upstream/_guides/cdi.adoc:197
#, fuzzy
msgid "It depends ;-)."
msgstr "这取决于;-)。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:200
#, fuzzy
msgid "A `@Singleton` bean has no <<client_proxies,client proxy>> and hence an instance is _created eagerly_ when the bean is injected. By contrast, an instance of an `@ApplicationScoped` bean is _created lazily_, i.e.  when a method is invoked upon an injected instance for the first time."
msgstr " `@Singleton` bean没有 link:#client_proxies[客户端代理] ，因此当bean被注入时，会 _急切地创建_ 一个实例。相比之下， `@ApplicationScoped` Bean的实例是 _懒惰地创建的_ ，也就是说，当一个方法第一次在注入的实例上被调用时。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:203
#, fuzzy
msgid "Furthermore, client proxies only delegate method invocations and thus you should never read/write fields of an injected `@ApplicationScoped` bean directly.  You can read/write fields of an injected `@Singleton` safely."
msgstr "此外，客户代理只委托方法调用，因此你不应该直接读/写一个注入的 `@ApplicationScoped` Bean的字段。你可以安全地读/写一个注入的 `@Singleton` 的字段。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:205
#, fuzzy
msgid "`@Singleton` should have a slightly better performance because the is no indirection (no proxy that delegates to the current instance from the context)."
msgstr " `@Singleton` 应该有一个稍好的性能，因为没有中介（没有从上下文委托给当前实例的代理）。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:207
#, fuzzy
msgid "On the other hand, you cannot mock `@Singleton` beans using <<getting-started-testing.adoc#quarkus_mock,QuarkusMock>>."
msgstr "另一方面，你不能用 link:getting-started-testing.html#quarkus_mock[QuarkusMock] 模拟 `@Singleton` beans。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:210
#, fuzzy
msgid "`@ApplicationScoped` beans can be also destroyed and recreated at runtime.  Existing injection points just work because the injected proxy delegates to the current instance."
msgstr " `@ApplicationScoped` beans也可以在运行时被销毁和重新创建。现有的注入点只是工作，因为注入的代理委托给了当前的实例。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:212
#, fuzzy
msgid "Therefore, we recommend to stick with `@ApplicationScoped` by default unless there's a good reason to use `@Singleton`."
msgstr "因此，我们建议默认使用 `@ApplicationScoped` ，除非有充分的理由使用 `@Singleton` 。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:214
#, fuzzy, no-wrap
msgid "I don't understand the concept of client proxies."
msgstr "我不明白客户代理的概念。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:219
#, fuzzy
msgid "Indeed, the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp, but they provide some useful functionality.  A client proxy is basically an object that delegates all method invocations to a target bean instance.  It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class."
msgstr "事实上， link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#client_proxies[客户端代理, target=\"_blank\"] 可能很难掌握，但它们提供了一些有用的功能。客户端代理基本上是一个将所有方法调用委托给目标Bean实例的对象。它是一个容器结构，实现了 `io.quarkus.arc.ClientProxy` ，并扩展了Bean类。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:221
#, fuzzy
msgid "Client proxies only delegate method invocations. So never read or write a field of a normal scoped bean, otherwise you will work with non-contextual or stale data."
msgstr "客户端代理只委托方法调用。因此，永远不要读或写一个正常范围的Bean的字段，否则你将与非上下文或陈旧的数据一起工作。"

#. type: Block title
#: upstream/_guides/cdi.adoc:222
#, fuzzy, no-wrap
msgid "Generated Client Proxy Example"
msgstr "生成的客户代理实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:227
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:235
#, no-wrap
msgid ""
"// The client proxy class is generated and looks like...\n"
"class Translator_ClientProxy extends Translator { <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:243
#, no-wrap
msgid ""
"    String translate(String sentence) { \n"
"      // Find the correct translator instance...\n"
"      Translator translator = getTranslatorInstanceFromTheApplicationContext();\n"
"      // And delegate the method invocation...\n"
"      return translator.translate(sentence);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:245
#, fuzzy
msgid "The `Translator_ClientProxy` instance is always injected instead of a direct reference to a https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#contextual_instance[contextual instance, window=\"_blank\"] of the `Translator` bean."
msgstr " `Translator_ClientProxy` 实例总是被注入，而不是直接引用 `Translator` bean 的 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#contextual_instance[上下文实例, target=\"_blank\"] 。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:247
#, fuzzy
msgid "Client proxies allow for:"
msgstr "客户端代理允许。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:249
#, fuzzy
msgid "Lazy instantiation - the instance is created once a method is invoked upon the proxy."
msgstr "懒惰的实例化 - 一旦在代理上调用一个方法，就会创建实例。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:250
#, fuzzy
msgid "Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean."
msgstr "能够将具有 \"较窄 \"范围的Bean注入具有 \"较宽 \"范围的Bean；即你可以将一个 `@RequestScoped` Bean注入一个 `@ApplicationScoped` Bean。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:251
#, fuzzy
msgid "Circular dependencies in the dependency graph. Having circular dependencies is often an indication that a redesign should be considered, but sometimes it's inevitable."
msgstr "依赖关系图中的循环依赖关系。有循环的依赖关系往往表明应该考虑重新设计，但有时它是不可避免的。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:252
#, fuzzy
msgid "In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance."
msgstr "在少数情况下，手动销毁Bean是很实用的。一个直接注入的引用会导致一个陈旧的Bean实例。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:254
#, fuzzy, no-wrap
msgid "OK. You said that there are several kinds of beans?"
msgstr "好的。你说有几种豆子？"

#. type: Plain text
#: upstream/_guides/cdi.adoc:257
#, fuzzy
msgid "Yes. In general, we distinguish:"
msgstr "是的，一般来说，我们会加以区分。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:259
#, fuzzy
msgid "Class beans"
msgstr "班级豆子"

#. type: Plain text
#: upstream/_guides/cdi.adoc:260
#, fuzzy
msgid "Producer methods"
msgstr "生产者方法"

#. type: Plain text
#: upstream/_guides/cdi.adoc:261
#, fuzzy
msgid "Producer fields"
msgstr "生产者领域"

#. type: Plain text
#: upstream/_guides/cdi.adoc:262
#, fuzzy
msgid "Synthetic beans"
msgstr "合成豆"

#. type: Plain text
#: upstream/_guides/cdi.adoc:264
#, fuzzy
msgid "Synthetic beans are usually provided by extensions. Therefore, we are not going to cover them in this guide."
msgstr "合成豆通常由扩展提供。因此，我们不打算在本指南中介绍它们。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:267
#, fuzzy
msgid "Producer methods and fields are useful if you need additional control over instantiation of a bean.  They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc."
msgstr "如果你需要对Bean的实例化进行额外的控制，生产者方法和字段是非常有用的。在集成第三方库时，它们也很有用，因为你不能控制类的来源，也不能添加额外的注释等。"

#. type: Block title
#: upstream/_guides/cdi.adoc:268
#, fuzzy, no-wrap
msgid "Producers Example"
msgstr "生产者实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:273
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Producers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:276
#, no-wrap
msgid ""
"    @Produces <1>\n"
"    double pi = Math.PI; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:286
#, no-wrap
msgid ""
"    @Produces <3>\n"
"    List<String> names() {\n"
"       List<String> names = new ArrayList<>();\n"
"       names.add(\"Andy\");\n"
"       names.add(\"Adalbert\");\n"
"       names.add(\"Joachim\");\n"
"       return names; <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:289
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Consumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:292
#, no-wrap
msgid ""
"   @Inject\n"
"   double pi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:295
#, no-wrap
msgid ""
"   @Inject\n"
"   List<String> names;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:298
#, no-wrap
msgid ""
"   // ...   \n"
"} \n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:303
#, fuzzy
msgid "The container analyses the field annotations to build a bean metadata.  The _type_ is used to build the set of bean types.  In this case, it will be `double` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`."
msgstr "容器分析字段注解以构建Bean元数据。该 _类型_ 被用来构建Bean类型集。在这种情况下，它将是 `double` 和 `java.lang.Object` 。没有声明范围注解，所以默认为 `@Dependent` 。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:304
#, fuzzy
msgid "The container will read this field when creating the bean instance."
msgstr "容器将在创建Bean实例时读取这个字段。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:308
#, fuzzy
msgid "The container analyses the method annotations to build a bean metadata.  The _return type_ is used to build the set of bean types.  In this case, it will be `List<String>`, `Collection<String>`, `Iterable<String>` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`."
msgstr "容器分析方法注释以建立Bean元数据。 _返回类型_ 被用来建立Bean类型的集合。在这种情况下，它将是 `List<String>` , `Collection<String>` , `Iterable<String>` 和 `java.lang.Object` 。没有声明范围注解，所以默认为 `@Dependent` 。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:309
#, fuzzy
msgid "The container will call this method when creating the bean instance."
msgstr "容器将在创建Bean实例时调用这个方法。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:313
#, fuzzy
msgid "There's more about producers.  You can declare qualifiers, inject dependencies into the producer methods parameters, etc.  You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld docs, window=\"_blank\"]."
msgstr "关于生产者，还有更多。你可以声明限定词，将依赖关系注入生产者方法的参数中，等等。你可以在 link:https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld文档, target=\"_blank\"] 中读到更多关于生产者的信息，例如。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:314
#, fuzzy, no-wrap
msgid "OK, injection looks cool. What other services are provided?"
msgstr "好的，注射看起来很酷。还提供什么其他服务？"

#. type: Title ===
#: upstream/_guides/cdi.adoc:316
#, fuzzy, no-wrap
msgid "Lifecycle Callbacks"
msgstr "生命周期回调"

#. type: Plain text
#: upstream/_guides/cdi.adoc:319
#, fuzzy
msgid "A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:"
msgstr "一个bean类可以声明生命周期 `@PostConstruct` 和 `@PreDestroy` 回调。"

#. type: Block title
#: upstream/_guides/cdi.adoc:320
#, fuzzy, no-wrap
msgid "Lifecycle Callbacks Example"
msgstr "生命周期回调实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:325
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.annotation.PreDestroy;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:333
#, no-wrap
msgid ""
"    @PostConstruct <1>\n"
"    void init() {\n"
"       // ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:339
#, no-wrap
msgid ""
"    @PreDestroy <2>\n"
"    void destroy() {\n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:341
#, fuzzy
msgid "This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here."
msgstr "这个回调在Bean实例投入服务之前被调用。在这里执行一些初始化是安全的。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:342
#, fuzzy
msgid "This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here."
msgstr "这个回调在Bean实例被销毁之前被调用。在这里执行一些清理任务是安全的。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:344
#, fuzzy
msgid "It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks."
msgstr "保持回调中的逻辑 \"无副作用 \"是一个很好的做法，也就是说，你应该避免在回调中调用其他豆类。"

#. type: Title ===
#: upstream/_guides/cdi.adoc:346
#, fuzzy, no-wrap
msgid "Interceptors"
msgstr "拦截器"

#. type: Plain text
#: upstream/_guides/cdi.adoc:350
#, fuzzy
msgid "Interceptors are used to separate cross-cutting concerns from business logic.  There is a separate specification - Java Interceptors - that defines the basic programming model and semantics."
msgstr "拦截器被用来将跨领域的关注点与业务逻辑分开。有一个单独的规范--Java拦截器，它定义了基本的编程模型和语义。"

#. type: Block title
#: upstream/_guides/cdi.adoc:351
#, fuzzy, no-wrap
msgid "Simple Interceptor Binding Example"
msgstr "简单的拦截器实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:360
#, no-wrap
msgid ""
"import java.lang.annotation.ElementType;\n"
"import java.lang.annotation.Inherited;\n"
"import java.lang.annotation.Retention;\n"
"import java.lang.annotation.RetentionPolicy;\n"
"import java.lang.annotation.Target;\n"
"import javax.interceptor.InterceptorBinding;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:367
#, no-wrap
msgid ""
"@InterceptorBinding // <1>\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR}) // <2>\n"
"@Inherited // <3>\n"
"public @interface Logged {\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:369
#, fuzzy
msgid "This is an interceptor binding annotation. See the following examples for how it's used."
msgstr "这是一个拦截器绑定注解。关于它的使用方法，请看下面的例子。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:370
#, fuzzy
msgid "An interceptor binding annotation is always put on the interceptor type, and may be put on target types or methods."
msgstr "这是一个拦截器绑定注解，用来将我们的拦截器绑定到Bean上。只需用 `@Logged` .NET来注解一个bean类。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:371
#, fuzzy
msgid "Interceptor bindings are often `@Inherited`, but don't have to be."
msgstr "拦截器绑定通常是 `@Inherited` ，但不一定是这样。"

#. type: Block title
#: upstream/_guides/cdi.adoc:372
#, fuzzy, no-wrap
msgid "Simple Interceptor Example"
msgstr "简单的拦截器实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:379
#, no-wrap
msgid ""
"import javax.annotation.Priority;\n"
"import javax.interceptor.AroundInvoke;\n"
"import javax.interceptor.Interceptor;\n"
"import javax.interceptor.InvocationContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:384
#, no-wrap
msgid ""
"@Logged // <1>\n"
"@Priority(2020) // <2>\n"
"@Interceptor // <3>\n"
"public class LoggingInterceptor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:387
#, no-wrap
msgid ""
"   @Inject // <4>\n"
"   Logger logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:395
#, no-wrap
msgid ""
"   @AroundInvoke // <5>\n"
"   Object logInvocation(InvocationContext context) {\n"
"      // ...log before\n"
"      Object ret = context.proceed(); // <6>\n"
"      // ...log after\n"
"      return ret;\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:397 upstream/_guides/cdi.adoc:463
#: upstream/_guides/cdi.adoc:499 upstream/_guides/cdi.adoc:508
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:399
#, fuzzy
msgid "The interceptor binding annotation is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`, as in the following example."
msgstr "这是一个拦截器绑定注解，用来将我们的拦截器绑定到Bean上。只需用 `@Logged` .NET来注解一个bean类。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:400
#, fuzzy
msgid "`Priority` enables the interceptor and affects the interceptor ordering. Interceptors with smaller priority values are called first."
msgstr " `Priority` 启用拦截器并影响拦截器的排序。优先级值较小的拦截器会被首先调用。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:401
#, fuzzy
msgid "Marks an interceptor component."
msgstr "标记一个拦截器组件。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:402
#, fuzzy
msgid "An interceptor may inject dependencies."
msgstr "拦截器实例可以成为依赖性注入的目标。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:403
#, fuzzy
msgid "`AroundInvoke` denotes a method that interposes on business methods."
msgstr " `AroundInvoke` 表示穿插在业务方法上的一种方法。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:404
#, fuzzy
msgid "Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method."
msgstr "进入拦截器链中的下一个拦截器或调用被拦截的业务方法。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:406
#, fuzzy
msgid "Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepted bean."
msgstr "拦截器的实例是它们所拦截的Bean实例的依赖对象，也就是说，为每个被拦截的Bean创建一个新的拦截器实例。"

#. type: Block title
#: upstream/_guides/cdi.adoc:407
#, fuzzy, no-wrap
msgid "Simple Example of Interceptor Usage"
msgstr "简单的拦截器实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:411
#, fuzzy, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr " `@javax.enterprise.context.ApplicationScoped` "

#. type: delimited block -
#: upstream/_guides/cdi.adoc:419
#, no-wrap
msgid ""
"@Logged // <1> <2>\n"
"@ApplicationScoped\n"
"public class MyService {\n"
"   void doSomething() {\n"
"       ...\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:422
#, fuzzy
msgid "The interceptor binding annotation is put on a bean class so that all business methods are intercepted.  The annotation can also be put on individual methods, in which case, only the annotated methods are intercepted."
msgstr "拦截器绑定注解被放在Bean类上，这样所有的业务方法都被拦截了。该注释也可以放在单个方法上，在这种情况下，只有被注释的方法被拦截。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:424
#, fuzzy
msgid "Remember that the `@Logged` annotation is `@Inherited`.  If there's a bean class that inherits from `MyService`, the `LoggingInterceptor` will also apply to it."
msgstr "请记住， `@Logged` 注解是 `@Inherited` 。如果有一个继承自 `MyService` 的bean类， `LoggingInterceptor` 也将适用于它。"

#. type: Title ===
#: upstream/_guides/cdi.adoc:426
#, fuzzy, no-wrap
msgid "Decorators"
msgstr "装饰公司"

#. type: Plain text
#: upstream/_guides/cdi.adoc:429
#, fuzzy
msgid "Decorators are similar to interceptors, but because they implement interfaces with business semantics, they are able to implement business logic."
msgstr "装饰器类似于拦截器，但由于它们实现了具有业务语义的接口，所以能够实现业务逻辑。"

#. type: Block title
#: upstream/_guides/cdi.adoc:430
#, fuzzy, no-wrap
msgid "Simple Decorator Example"
msgstr "简单的装饰器实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:438
#, no-wrap
msgid ""
"import javax.decorator.Decorator;\n"
"import javax.decorator.Delegate;\n"
"import javax.annotation.Priority;\n"
"import javax.inject.Inject;\n"
"import javax.enterprise.inject.Any;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:442
#, no-wrap
msgid ""
"public interface Account {\n"
"   void withdraw(BigDecimal amount);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:446
#, no-wrap
msgid ""
"@Priority(10) <1>\n"
"@Decorator <2>\n"
"public class LargeTxAccount implements Account { <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:451
#, no-wrap
msgid ""
"   @Inject\n"
"   @Any\n"
"   @Delegate\n"
"   Account delegate; <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:454
#, no-wrap
msgid ""
"   @Inject\n"
"   LogService logService; <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:461
#, no-wrap
msgid ""
"   void withdraw(BigDecimal amount) {\n"
"      delegate.withdraw(amount); <6>\n"
"      if (amount.compareTo(1000) > 0) {\n"
"         logService.logWithdrawal(delegate, amount);\n"
"      }\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:465
#, fuzzy
msgid "`@Priority` enables the decorator. Decorators with smaller priority values are called first."
msgstr " `@Priority` 启用该装饰器。具有较小优先级值的装饰器会被首先调用。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:466
#, fuzzy
msgid "`@Decorator` marks a decorator component."
msgstr " `@Decorator` 标志着一个装饰器组件。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:467
#, fuzzy
msgid "The set of decorated types includes all bean types which are Java interfaces, except for `java.io.Serializable`."
msgstr "装饰类型的集合包括所有属于Java接口的bean类型，除了 `java.io.Serializable` 。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:468
#, fuzzy
msgid "Each decorator must declare exactly one _delegate injection point_. The decorator applies to beans that are assignable to this delegate injection point."
msgstr "每个装饰器必须准确地声明一个 _委托注入点_ 。该装饰器适用于可分配给该委托注入点的Bean。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:469
#, fuzzy
msgid "Decorators can inject other beans."
msgstr "装饰者可以注入其他豆子。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:470
#, fuzzy
msgid "The decorator may invoke any method of the delegate object. And the container invokes either the next decorator in the chain or the business method of the intercepted instance."
msgstr "装饰器可以调用委托对象的任何方法。而容器则调用链中的下一个装饰器或被拦截实例的业务方法。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:472
#, fuzzy
msgid "Instances of decorators are dependent objects of the bean instance they intercept, i.e. a new decorator instance is created for each intercepted bean."
msgstr "装饰器的实例是它们所拦截的Bean实例的依赖对象，也就是说，为每个被拦截的Bean创建一个新的装饰器实例。"

#. type: Title ===
#: upstream/_guides/cdi.adoc:473
#, fuzzy, no-wrap
msgid "Events and Observers"
msgstr "活动和观察者"

#. type: Plain text
#: upstream/_guides/cdi.adoc:478
#, fuzzy
msgid "Beans may also produce and consume events to interact in a completely decoupled fashion.  Any Java object can serve as an event payload.  The optional qualifiers act as topic selectors."
msgstr "Bean也可以产生和消费事件，以完全解耦的方式进行交互。任何Java对象都可以作为一个事件的有效载荷。可选的限定词充当主题选择器。"

#. type: Block title
#: upstream/_guides/cdi.adoc:479
#, fuzzy, no-wrap
msgid "Simple Event Example"
msgstr "简单事件实例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:486
#, no-wrap
msgid ""
"class TaskCompleted {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:489
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class ComplicatedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:492
#, no-wrap
msgid ""
"   @Inject\n"
"   Event<TaskCompleted> event; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:497
#, no-wrap
msgid ""
"   void doSomething() {\n"
"      // ...\n"
"      event.fire(new TaskCompleted()); <2>\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:502
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class Logger {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:506
#, no-wrap
msgid ""
"   void onTaskCompleted(@Observes TaskCompleted task) { <3>\n"
"      // ...log the task\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:510
#, fuzzy
msgid "`javax.enterprise.event.Event` is used to fire events."
msgstr " `javax.enterprise.event.Event` 是用来触发事件的。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:511
#, fuzzy
msgid "Fire the event synchronously."
msgstr "同步启动该事件。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:512
#, fuzzy
msgid "This method is notified when a `TaskCompleted` event is fired."
msgstr "当一个 `TaskCompleted` 事件被触发时，这个方法被通知。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:514
#, fuzzy
msgid "For more info about events/observers visit https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, window=\"_blank\"]."
msgstr "关于事件/观察者的更多信息，请访问 link:https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, target=\"_blank\"] 。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:515
#, fuzzy, no-wrap
msgid "Conclusion"
msgstr "总结"

#. type: Plain text
#: upstream/_guides/cdi.adoc:522
#, fuzzy
msgid "In this guide, we've covered some basic topics of the Quarkus programming model that is based on the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.  However, a full CDI implementation is not used under the hood.  Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.  On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.  We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future."
msgstr "在本指南中，我们已经涵盖了Quarkus编程模型的一些基本主题，该模型是基于 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[Java 2.0的上下文和依赖注入, target=\"_blank\"] 规范。然而，在引擎盖下并没有使用完整的CDI实现。Quarkus只实现了CDI功能的一个子集--参见 link:cdi-reference.html#supported_features[支持的功能列表] 和 link:cdi-reference.html#limitations[限制列表] 。另一方面，有相当多的 link:cdi-reference.html#nonstandard_features[非标准特性] 和 link:cdi-reference.html#build_time_apis[Quarkus特有的API] 。我们相信，我们的努力将推动CDI规范的创新，在未来面向构建时间的开发者堆栈。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:524
msgid "If you wish to learn more about Quarkus-specific features and limitations there is a Quarkus xref:cdi-reference.adoc[CDI Reference Guide].  We also recommend you to read the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[CDI specification] and the https://docs.jboss.org/weld/reference/latest/en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to get acquainted with more complex topics."
msgstr ""
