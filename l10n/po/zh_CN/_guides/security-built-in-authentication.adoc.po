# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-12-06 18:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-built-in-authentication.adoc:6
#, fuzzy, no-wrap
msgid "Built-In Authentication Support"
msgstr "内置的认证支持"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:11
#, fuzzy
msgid "The following section describes the Quarkus built-in authentication mechanisms for HTTP based FORM, BASIC, and Mutual TLS authentication. Proactive authentication is also described."
msgstr "这份文件描述了Quarkus内置的基于HTTP的FORM、BASIC和Mutual TLS认证以及主动认证的认证机制。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:18
#, fuzzy, no-wrap
msgid "Form Based Authentication"
msgstr "基于表格的认证"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:24
#, fuzzy
msgid "Quarkus provides form based authentication that works in a similar manner to traditional Servlet form based auth. Unlike traditional form authentication, the authenticated user is not stored in an HTTP session, as Quarkus does not provide clustered HTTP session support. Instead, the authentication information is stored in an encrypted cookie, which can be read by all members of the cluster (provided they all share the same encryption key)."
msgstr "Quarkus提供基于表单的认证，其工作方式与传统的Servlet基于表单的认证类似。与传统的表单认证不同的是，由于Quarkus不提供集群的HTTP会话支持，被认证的用户不被存储在HTTP会话中。相反，认证信息被存储在一个加密的cookie中，集群中的所有成员都可以读取（只要他们都共享相同的加密密钥）。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:30
#, fuzzy
msgid "The encryption key can be set using the `quarkus.http.auth.session.encryption-key` property, and it must be at least 16 characters long. This key is hashed using SHA-256 and the resulting digest is used as a key for AES-256 encryption of the cookie value. This cookie contains an expiry time as part of the encrypted value, so all nodes in the cluster must have their clocks synchronized. At one minute intervals a new cookie will be generated with an updated expiry time if the session is in use."
msgstr "加密密钥可以使用 `quarkus.http.auth.session.encryption-key` 属性来设置，它必须至少有16个字符长。这个密钥使用SHA-256进行散列，产生的摘要被用作对cookie值进行AES-256加密的一个密钥。这个cookie包含一个过期时间，作为加密值的一部分，所以集群中的所有节点都必须同步其时钟。如果会话正在使用中，每隔一分钟就会生成一个新的cookie，并更新其到期时间。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:32
#, fuzzy
msgid "The following properties can be used to configure form based auth:"
msgstr "以下属性可用于配置基于表单的授权。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:36
#, fuzzy, no-wrap
msgid "Mutual TLS Authentication"
msgstr "相互TLS认证"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:39
#, fuzzy
msgid "Quarkus provides mTLS authentication so that you can authenticate users based on their X.509 certificates."
msgstr "Quarkus提供了mTLS认证，这样你就可以根据用户的X.509证书进行认证。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:41
#, fuzzy
msgid "To use this authentication method, you should first enable SSL for your application. For more details, check the xref:http-reference.adoc#ssl[Supporting secure connections with SSL] guide."
msgstr "要使用这种认证方法，你应该首先为你的应用程序启用SSL。更多细节，请查看 link:http-reference.html#ssl[支持SSL的安全连接] 指南。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:45
#, fuzzy
msgid "Once your application is accepting secure connections, the next step is to configure a `quarkus.http.ssl.certificate.trust-store-file` holding all the certificates that your application should trust as well as how your application should ask for certificates when a client (e.g.: browser or another service) tries to access one of its protected resources."
msgstr "一旦你的应用程序接受了安全连接，下一步就是配置一个 `quarkus.http.ssl.certificate.trust-store-file` ，其中包含你的应用程序应该信任的所有证书，以及当客户端（如：浏览器或其他服务）试图访问其受保护的资源时，你的应用程序应该如何要求获得证书。"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:53
#, no-wrap
msgid ""
"quarkus.http.ssl.certificate.key-store-file=server-keystore.jks            <1>\n"
"quarkus.http.ssl.certificate.key-store-password=the_key_store_secret\n"
"quarkus.http.ssl.certificate.trust-store-file=server-truststore.jks        <2>\n"
"quarkus.http.ssl.certificate.trust-store-password=the_trust_store_secret\n"
"quarkus.http.ssl.client-auth=required                                      <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:56
#, no-wrap
msgid ""
"quarkus.http.auth.permission.default.paths=/*                              <4>\n"
"quarkus.http.auth.permission.default.policy=authenticated\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:58
#, fuzzy
msgid "Configures a key store where the server's private key is located."
msgstr "配置一个服务器私钥所在的密钥库。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:59
#, fuzzy
msgid "Configures a trust store from where the trusted certificates are going to be loaded from."
msgstr "配置一个信任商店，从那里加载受信任的证书。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:62
#, fuzzy
msgid "Defines that the server should *always* ask certificates from clients. You can relax this behavior by using `REQUEST` so that the server should still accept requests without a certificate. Useful when you are also supporting authentication methods other than mTLS."
msgstr "定义了服务器应该 *总是* 要求客户提供证书。你可以通过使用 `REQUEST` 来放松这种行为，这样服务器仍然应该接受没有证书的请求。当你支持除mTLS之外的其他认证方法时，这很有用。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:63
#, fuzzy
msgid "Defines a policy where only authenticated users should have access to resources from your application."
msgstr "定义了一个策略，只有经过认证的用户才能访问你的应用程序的资源。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:66
#, fuzzy
msgid "Once the incoming request matches a valid certificate in the truststore, your application should be able to obtain the subject by just injecting a `SecurityIdentity` as follows:"
msgstr "一旦传入的请求与信任库中的有效证书相匹配，你的应用程序应该能够通过注入一个 `SecurityIdentity` ，获得主题，如下所示。"

#. type: Block title
#: upstream/_guides/security-built-in-authentication.adoc:68
#, fuzzy, no-wrap
msgid "Obtaining the subject"
msgstr "获得主题"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:73
#, no-wrap
msgid ""
"@Inject\n"
"SecurityIdentity identity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:79
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"public String hello() {\n"
"    return String.format(\"Hello, %s\", identity.getPrincipal().getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:82
#, fuzzy
msgid "You should also be able to get the certificate as follows:"
msgstr "你也应该能够获得如下证书。"

#. type: Block title
#: upstream/_guides/security-built-in-authentication.adoc:84
#, fuzzy, no-wrap
msgid "Obtaining the certificate"
msgstr "获得证书"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:89
#, no-wrap
msgid ""
"import java.security.cert.X509Certificate;\n"
"import io.quarkus.security.credential.CertificateCredential;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:92
#, no-wrap
msgid ""
"CertificateCredential credential = identity.getCredential(CertificateCredential.class);\n"
"X509Certificate certificate = credential.getCertificate();\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-built-in-authentication.adoc:94
#, fuzzy, no-wrap
msgid "Authorization"
msgstr "授权书"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:98
#, fuzzy
msgid "The information from the client certificate can be used to enhance Quarkus `SecurityIdentity`. For example, one can add new roles after checking a client certificate subject name, and so on.  Please see the xref:security-customization.adoc#security-identity-customization[SecurityIdentity Customization] section for more information about customizing Quarkus `SecurityIdentity`."
msgstr "来自客户证书的信息可以用来加强Quarkus `SecurityIdentity` 。例如，人们可以在检查客户证书主题名称后添加新的角色，等等。关于定制Quarkus的更多信息，请参见 link:security-customization.html#security-identity-customization[SecurityIdentity Customization] 部分 `SecurityIdentity` 。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:100
#, fuzzy, no-wrap
msgid "Proactive Authentication"
msgstr "主动认证"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:104
#, fuzzy
msgid "By default, Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication)."
msgstr "在默认情况下，Quarkus做的是我们所说的主动认证。这意味着，如果一个传入的请求有一个证书，那么这个请求将总是被认证（即使目标页面不需要认证）。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:107
#, fuzzy
msgid "This means that requests with an invalid credential will always be rejected, even for public pages. You can change this behavior and only authenticate when required by setting `quarkus.http.auth.proactive=false`."
msgstr "这意味着带有无效凭证的请求将总是被拒绝，即使是公共页面。你可以改变这种行为，只在需要时通过设置 `quarkus.http.auth.proactive=false` 。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:111
#, fuzzy
msgid "If you disable proactive authentication then the authentication process will only be run when an identity is requested, either because there are security rules that requires the user to be authenticated, or due to programmatic access to the current identity."
msgstr "如果你禁用主动认证，那么认证过程将只在请求身份时运行，这是因为有安全规则要求用户进行认证，或由于对当前身份的程序化访问。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:119
#, fuzzy
msgid "Note that if proactive authentication is in use accessing the `SecurityIdentity` is a blocking operation. This is because authentication may not have happened yet, and accessing it may require calls to external systems such as databases that may block. For blocking applications this is no problem, however if you have disabled authentication in a reactive application this will fail (as you cannot do blocking operations on the IO thread). To work around this you need to `@Inject` an instance of `io.quarkus.security.identity.CurrentIdentityAssociation`, and call the `Uni<SecurityIdentity> getDeferredIdentity();` method. You can then subscribe to the resulting `Uni` and will be notified when authentication is complete and the identity is available."
msgstr "请注意，如果正在使用主动认证，访问 `SecurityIdentity` 是一个阻塞操作。这是因为认证可能还没有发生，访问它可能需要调用外部系统，如数据库，可能会阻塞。对于阻塞式应用程序来说，这没有问题，但是如果你在一个反应式应用程序中禁用了认证，这将会失败（因为你不能在IO线程上进行阻塞操作）。为了解决这个问题，你需要 `@Inject` 一个 `io.quarkus.security.identity.CurrentIdentityAssociation` 的实例，并调用 `Uni<SecurityIdentity> getDeferredIdentity();` 方法。然后，你可以订阅产生的 `Uni` ，当认证完成和身份可用时，你将得到通知。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:124
#, fuzzy
msgid "It's still possible to access the `SecurityIdentity` synchronously with `public SecurityIdentity getIdentity()` in the xref:resteasy-reactive.adoc[RESTEasy Reactive] from endpoints annotated with `@RolesAllowed`, `@Authenticated`, or with respective configuration authorization checks as authentication has already happened. The same is also valid for the xref:reactive-routes.adoc[Reactive routes] if a route response is synchronous."
msgstr "在 link:resteasy-reactive.html[RESTEasy Reactive] 中，仍然可以用 `public SecurityIdentity getIdentity()` ，从注有 `@RolesAllowed` 、 `@Authenticated` 、或各自配置授权检查的端点同步访问 `SecurityIdentity` ，因为认证已经发生。如果路由响应是同步的，这对 link:reactive-routes.html[Reactive路由] 也同样有效。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:128
#, fuzzy
msgid "xref:security-authorization.adoc#standard-security-annotations[Standard security annotations] on CDI beans are not supported on IO thread if a non-void secured method returns a value synchronously and proactive authentication is disabled, as they need to access the `SecurityIdentity`.  In the example below, we have defined `HelloResource` and `HelloService`. It's easy to see that any GET request to `/hello` will run on IO thread and throw `BlockingOperationNotAllowedException` exception.  There is more than one way to fix the example:"
msgstr "如果一个非void的安全方法同步返回一个值，并且主动认证被禁用，那么CDI Bean上的 link:security-authorization.html#standard-security-annotations[标准安全注释] 在IO线程上是不被支持的，因为他们需要访问 `SecurityIdentity` 。在下面的例子中，我们定义了 `HelloResource` 和 `HelloService` 。很容易看出，任何对 `/hello` 的GET请求都会在IO线程上运行，并抛出 `BlockingOperationNotAllowedException` 异常。修复这个例子的方法不止一种。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:130
#, fuzzy
msgid "switch to a worker thread (annotate `hello` endpoint with `@Blocking`)"
msgstr "切换到一个工作线程（用 `@Blocking` 注释 `hello` 端点）。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:131
#, fuzzy
msgid "change `sayHello` method return type (use reactive or asynchronous data type)"
msgstr "改变 `sayHello` 方法的返回类型（使用反应式或异步数据类型）。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:132
#, fuzzy
msgid "arguably the safest way is to move `@RolesAllowed` annotation to the endpoint, as accessing `SecurityIdentity` from endpoint methods is never the blocking operation"
msgstr "可以说，最安全的方法是将 `@RolesAllowed` 注释移至端点，因为从端点方法访问 `SecurityIdentity` ，永远不会是阻塞操作"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:139
#, no-wrap
msgid ""
"import javax.annotation.security.PermitAll;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:141
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:145
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"@PermitAll\n"
"public class HelloResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:148
#, no-wrap
msgid ""
"    @Inject\n"
"    HelloService helloService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:153
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<String> hello() {\n"
"        return Uni.createFrom().item(helloService.sayHello());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:155
#: upstream/_guides/security-built-in-authentication.adoc:171
#, no-wrap
msgid "}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:161
#, no-wrap
msgid ""
"import javax.annotation.security.RolesAllowed;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:164
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class HelloService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:169
#, no-wrap
msgid ""
"    @RolesAllowed(\"admin\")\n"
"    public String sayHello() {\n"
"        return \"Hello\";\n"
"    }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-built-in-authentication.adoc:174
#, fuzzy, no-wrap
msgid "How to customize authentication exception responses"
msgstr "如何定制认证异常响应"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:177
msgid "By default, the authentication security constraints are enforced before the JAX-RS chain starts and only way to handle Quarkus Security authentication exceptions is to provide a failure handler like this one:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:181
#: upstream/_guides/security-built-in-authentication.adoc:213
#, no-wrap
msgid "package io.quarkus.it.keycloak;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:184
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:189
#, no-wrap
msgid ""
"import io.quarkus.security.AuthenticationFailedException;\n"
"import io.vertx.core.Handler;\n"
"import io.vertx.ext.web.Router;\n"
"import io.vertx.ext.web.RoutingContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:192
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class AuthenticationFailedExceptionHandler {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:206
#, no-wrap
msgid ""
"    public void init(@Observes Router router) {\n"
"        router.route().failureHandler(new Handler<RoutingContext>() {\n"
"            @Override\n"
"            public void handle(RoutingContext event) {\n"
"                if (event.failure() instanceof AuthenticationFailedException) {\n"
"                    event.response().setStatusCode(401).end(CUSTOMIZED_RESPONSE);\n"
"                } else {\n"
"                    event.next();\n"
"                }\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:209
msgid "Disabling the proactive authentication effectively shifts this process to the moment when the JAX-RS chain starts running thus making it possible to use JAX-RS `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException`, for example:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:219
#, no-wrap
msgid ""
"import javax.annotation.Priority;\n"
"import javax.ws.rs.Priorities;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.ext.ExceptionMapper;\n"
"import javax.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:221
#, no-wrap
msgid "import io.quarkus.security.AuthenticationFailedException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:225
#, no-wrap
msgid ""
"@Provider\n"
"@Priority(Priorities.AUTHENTICATION)\n"
"public class AuthenticationFailedExceptionMapper implements ExceptionMapper<AuthenticationFailedException> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:228
#, no-wrap
msgid ""
"    @Context\n"
"    UriInfo uriInfo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:234
#, no-wrap
msgid ""
"    @Override\n"
"    public Response toResponse(AuthenticationFailedException exception) {\n"
"        return Response.status(401).header(\"WWW-Authenticate\", \"Basic realm=\\\"Quarkus\\\"\").build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:236
#, no-wrap
msgid "References"
msgstr "参考文献"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:238
msgid "xref:security.adoc[Quarkus Security]"
msgstr ""

#, fuzzy
#~ msgid "Basic Authentication"
#~ msgstr "基本认证"

#, fuzzy
#~ msgid "HTTP Basic Authentication uses fields in the HTTP header and is the easiest to set up. Also, it is one of the least resource-demanding techniques that enforce access controls to the Web resources without requiring HTTP cookies, session identifiers, or login pages."
#~ msgstr "HTTP基本认证使用HTTP标头中的字段，是最容易设置的。同时，它也是对资源要求最低的技术之一，可以在不需要HTTP cookies、会话标识符或登录页面的情况下对网络资源实施访问控制。"

#, fuzzy
#~ msgid "In the context of an HTTP request, Basic authentication is a method for an HTTP user agent, such as a web browser, to provide a user name and password when creating a request. In Basic HTTP Authentication, a request contains a header field in the form of `Authorization: Basic <credentials>`, where credentials are the Base64 encoding of a user ID and password joined by a colon as described in the following example."
#~ msgstr "在HTTP请求的上下文中，基本认证是HTTP用户代理（如Web浏览器）在创建请求时提供用户名和密码的一种方法。在基本HTTP认证中，一个请求包含一个头域，其形式为： `Authorization: Basic <credentials>` ，其中凭证是用户ID和密码的Base64编码，由冒号连接，如下面的例子中所述。"

#~ msgid "Example"
#~ msgstr "例子"

#, fuzzy
#~ msgid "If the user name is `Alice` and the password is `secret`, the HTTP authorization header looks authorization as `Authorization: Basic QWxjZTpzZWNyZXQ=`, where `QWxjZTpzZWNyZXQ=` is a Base64 encoded representation of the `Alice:secret` string."
#~ msgstr "如果用户名是 `Alice` ，密码是 `secret` ，HTTP授权头看起来授权为 `Authorization: Basic QWxjZTpzZWNyZXQ=` ，其中 `QWxjZTpzZWNyZXQ=` 是 `Alice:secret` 字符串的一个Base64编码表示。"

#, fuzzy
#~ msgid "The Basic Authentication mechanism does not provide confidentiality protection for the transmitted credentials. The credentials are merely encoded with Base64 when in transit and not encrypted or hashed in any way. Therefore, Basic Authentication is used with HTTPS to provide confidentiality."
#~ msgstr "基本认证机制并不为传输的凭证提供保密保护。在传输过程中，证书只是用Base64进行编码，而不是以任何方式进行加密或散列。因此，基本认证与HTTPS一起使用以提供保密性。"

#, fuzzy
#~ msgid "Basic Authentication is a well-specified, simple challenge and response scheme that all web browsers and most web servers understand. However, there are a few limitations associated with Basic Authentication, which include:"
#~ msgstr "基本认证是一个明确规定的、简单的挑战和响应方案，所有的网络浏览器和大多数网络服务器都能理解。然而，基本认证有一些相关的限制，其中包括。"

#, fuzzy
#~ msgid "Credentials are sent as plain text"
#~ msgstr "凭证以纯文本形式发送"

#, fuzzy
#~ msgid "It is required to use HTTPS with Basic Authentication to avoid exposing the credentials. However, if the load balancer terminates HTTPS, the risk of exposing credentials as plain text increases when a request is forwarded to Quarkus over HTTP."
#~ msgstr "需要使用带有基本认证的 HTTPS 来避免暴露凭证。然而，如果负载均衡器终止了HTTPS，当请求通过HTTP转发到Quarkus时，凭证作为纯文本暴露的风险会增加。"

#, fuzzy
#~ msgid "Also, in multi-hop deployments, the credentials can be exposed if HTTPS is used between the client and the first Quarkus endpoint only, and the credentials are propagated to the next Quarkus endpoint over HTTP."
#~ msgstr "另外，在多跳部署中，如果客户端和第一个Quarkus端点之间只使用HTTPS，而凭证通过HTTP传播到下一个Quarkus端点，那么凭证就会暴露。"

#, fuzzy
#~ msgid "Credentials are sent with each request"
#~ msgstr "每次请求时都会发送凭证"

#, fuzzy
#~ msgid "In Basic Authentication, a username and password need to be sent with each request, which increases the risk of credentials being exposed."
#~ msgstr "在基本认证中，每次请求都需要发送用户名和密码，这增加了凭证暴露的风险。"

#, fuzzy
#~ msgid "Application complexity increases"
#~ msgstr "应用的复杂性增加"

#, fuzzy
#~ msgid "The Quarkus application needs to ensure itself that usernames, passwords, and roles are managed securely, which increases the application complexity."
#~ msgstr "Quarkus应用程序需要确保自己对用户名、密码和角色进行安全管理，这就增加了应用程序的复杂性。"

#, fuzzy
#~ msgid "Enabling Basic Authentication"
#~ msgstr "基本认证"

#~ msgid "Prerequisites"
#~ msgstr "先决条件"

#, fuzzy
#~ msgid "You have installed at least one extension that provides an `IdentityProvider` based on username and password, such as xref:security-jdbc.adoc[Elytron JDBC]."
#~ msgstr "要启用基本认证，请设置 `quarkus.http.auth.basic=true` 。你还必须至少安装一个提供基于用户名/密码的扩展 `IdentityProvider` ，如 link:security-jdbc.html[Elytron JDBC] 。"

#, fuzzy
#~ msgid "Procedure"
#~ msgstr "程序"

#, fuzzy
#~ msgid "Enable Basic Authentication by setting the value of `quarkus.http.auth.basic` property to `true`."
#~ msgstr "通过将 `quarkus.http.auth.basic` 属性的值设置为 `true` ，启用基本认证。"

#, fuzzy
#~ msgid "For a Basic Authentication configuration walk-through that uses `JPA`, see the xref:security-getting-started.adoc[Getting Started With Security] guide."
#~ msgstr "关于使用 `JPA` 的基本认证配置演练，请参见 link:security-getting-started.html[安全入门] 指南。"

#, fuzzy
#~ msgid "Additional resources"
#~ msgstr "额外资源"

#, fuzzy
#~ msgid "xref:security.adoc#identity-providers[Security Identity Providers]"
#~ msgstr "更多信息请见 link:security.html#identity-providers[安全身份提供者] 。"

#, fuzzy
#~ msgid "xref:security-testing.adoc#configuring-user-information[Configuring User Information in application.properties]"
#~ msgstr "也请参见 link:security-testing.html#configuring-user-information[在application.properties] 部分配置 link:security-testing.html#configuring-user-information[用户信息] 。"
