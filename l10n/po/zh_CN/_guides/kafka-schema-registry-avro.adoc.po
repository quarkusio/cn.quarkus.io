# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-25 16:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka-schema-registry-avro.adoc:6
#, fuzzy, no-wrap
msgid "Using Apache Kafka with Schema Registry and Avro"
msgstr "使用Apache Kafka与Schema Registry和Avro"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:12
#, fuzzy
msgid "This guide shows how your Quarkus application can use Apache Kafka, http://avro.apache.org/docs/current/[Avro] serialized records, and connect to a schema registry (such as the https://docs.confluent.io/platform/current/schema-registry/index.html[Confluent Schema Registry] or https://www.apicur.io/registry/[Apicurio Registry])."
msgstr "本指南展示了你的Quarkus应用程序如何使用Apache Kafka、 link:http://avro.apache.org/docs/current/[Avro] 序列化记录，并连接到模式注册中心（如 link:https://docs.confluent.io/platform/current/schema-registry/index.html[Confluent模式注册中心] 或 link:https://www.apicur.io/registry/[Apicurio注册中心] ）。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:15
#, fuzzy
msgid "If you are not familiar with Kafka and Kafka in Quarkus in particular, consider first going through the xref:kafka.adoc[Using Apache Kafka with Reactive Messaging] guide."
msgstr "如果你不熟悉Kafka，尤其是Quarkus中的Kafka，可以考虑先看一下《 link:kafka.html[使用Apache Kafka与反应式消息传递] 》指南。"

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:16
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:22
#, fuzzy, no-wrap
msgid "Architecture"
msgstr "建筑学"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:26
#, fuzzy
msgid "In this guide we are going to implement a REST resource, namely `MovieResource`, that will consume movie DTOs and put them in a Kafka topic."
msgstr "在本指南中，我们将实现一个REST资源，即 `MovieResource` ，它将消费电影DTO，并将其放入Kafka主题中。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:30
#, fuzzy
msgid "Then, we will implement a consumer that will consume and collect messages from the same topic.  The collected messages will be then exposed by another resource, `ConsumedMovieResource`, via https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events[Server-Sent Events]."
msgstr "然后，我们将实现一个消费者，它将消费和收集来自同一主题的消息。收集到的消息将由另一个资源， `ConsumedMovieResource` ，通过 link:https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events[服务器发送的事件] 来公开。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:34
#, fuzzy
msgid "The _Movies_ will be serialized and deserialized using Avro.  The schema, describing the _Movie_, is stored in Apicurio Registry.  The same concept applies if you are using the Confluent Avro _serde_ and Confluent Schema Registry."
msgstr " _电影_ 将使用Avro进行序列化和反序列化。描述 _电影_ 的模式被存储在Apicurio Registry中。如果你使用Confluent Avro _serde_ 和Confluent Schema Registry，同样的概念也适用。"

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:35
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:39
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。然而，你可以直接进入已完成的例子。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:41
#, fuzzy
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库。 `git clone {quickstarts-clone-url}` ，或者下载一个 {quickstarts-archive-url}[存档] 。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:43
#, fuzzy
msgid "The solution is located in the `kafka-avro-schema-quickstart` {quickstarts-tree-url}/kafka-avro-schema-quickstart[directory]."
msgstr "该解决方案位于 `kafka-avro-schema-quickstart` {quickstarts-tree-url}/kafka-avro-schema-quickstart[目录]中。"

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:44
#, fuzzy, no-wrap
msgid "Creating the Maven Project"
msgstr "创建Maven项目"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:47
#, fuzzy
msgid "First, we need a new project. Create a new project with the following command:"
msgstr "首先，我们需要一个新的项目。用以下命令创建一个新项目。"

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:57
#, fuzzy
msgid "If you use Confluent Schema Registry, you don't need the `quarkus-apicurio-registry-avro` extension.  Instead, you need the `quarkus-confluent-registry-avro` extension and a few more dependencies.  Also, you need to add the Confluent Maven repository to your build file:"
msgstr "如果你使用Confluent Schema Registry，你不需要 `quarkus-apicurio-registry-avro` 这个扩展。相反，您需要 `quarkus-confluent-registry-avro` 扩展和其他一些依赖项。此外，您还需要将Confluent Maven仓库添加到您的构建文件中。"

#. type: Block title
#: upstream/_guides/kafka-schema-registry-avro.adoc:59
#: upstream/_guides/kafka-schema-registry-avro.adoc:474
#: upstream/_guides/kafka-schema-registry-avro.adoc:603
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:84
#, no-wrap
msgid ""
"<dependencies>\n"
"    ...\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-confluent-registry-avro</artifactId>\n"
"    </dependency>\n"
"    <!-- Confluent registry libraries use JAX-RS client -->\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-rest-client-reactive</artifactId>\n"
"    </dependency>\n"
"    <dependency>\n"
"        <groupId>io.confluent</groupId>\n"
"        <artifactId>kafka-avro-serializer</artifactId>\n"
"        <version>6.1.1</version>\n"
"        <exclusions>\n"
"            <exclusion>\n"
"                <groupId>jakarta.ws.rs</groupId>\n"
"                <artifactId>jakarta.ws.rs-api</artifactId>\n"
"            </exclusion>\n"
"        </exclusions>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:94
#, no-wrap
msgid ""
"<repositories>\n"
"    <repository>\n"
"        <id>confluent</id>\n"
"        <url>https://packages.confluent.io/maven/</url>\n"
"        <snapshots>\n"
"            <enabled>false</enabled>\n"
"        </snapshots>\n"
"    </repository>\n"
"</repositories>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/kafka-schema-registry-avro.adoc:97
#: upstream/_guides/kafka-schema-registry-avro.adoc:490
#: upstream/_guides/kafka-schema-registry-avro.adoc:620
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:101
#, no-wrap
msgid ""
"repositories {\n"
"    ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:106
#, no-wrap
msgid ""
"    maven {\n"
"        url \"https://packages.confluent.io/maven/\"\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:109
#, no-wrap
msgid ""
"dependencies {\n"
"    ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:111
#, no-wrap
msgid "    implementation(\"io.quarkus:quarkus-confluent-registry-avro\")\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:114
#, no-wrap
msgid ""
"    // Confluent registry libraries use JAX-RS client\n"
"    implementation(\"io.quarkus:quarkus-rest-client-reactive\")\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:119
#, no-wrap
msgid ""
"    implementation(\"io.confluent:kafka-avro-serializer:6.1.1\") {\n"
"        exclude group: \"jakarta.ws.rs\", module: \"jakarta.ws.rs-api\" \n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:122
#, fuzzy, no-wrap
msgid "Avro schema"
msgstr "Avro模式"

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:127
#, fuzzy
msgid "Apache Avro is a data serialization system. Data structures are described using schemas.  The first thing we need to do is to create a schema describing the `Movie` structure.  Create a file called `src/main/avro/movie.avsc` with the schema for our record (Kafka message):"
msgstr "Apache Avro是一个数据序列化系统。数据结构是用模式描述的。我们需要做的第一件事是创建一个描述 `Movie` 结构的模式。创建一个名为 `src/main/avro/movie.avsc` 的文件，为我们的记录（Kafka消息）提供模式。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:144
#, no-wrap
msgid ""
"{\n"
"  \"namespace\": \"org.acme.kafka.quarkus\",\n"
"  \"type\": \"record\",\n"
"  \"name\": \"Movie\",\n"
"  \"fields\": [\n"
"    {\n"
"      \"name\": \"title\",\n"
"      \"type\": \"string\"\n"
"    },\n"
"    {\n"
"      \"name\": \"year\",\n"
"      \"type\": \"int\"\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:147
#, fuzzy
msgid "If you build the project with:"
msgstr "如果你建立的项目与。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:152
#, fuzzy
msgid "the `movies.avsc` will get compiled to a `Movie.java` file placed in the `target/generated-sources/avsc` directory."
msgstr " `movies.avsc` 将被编译成一个 `Movie.java` 文件，放在 `target/generated-sources/avsc` 目录中。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:155
#, fuzzy
msgid "Take a look at the https://avro.apache.org/docs/current/spec.html#schemas[Avro specification] to learn more about the Avro syntax and supported types."
msgstr "看一下 link:https://avro.apache.org/docs/current/spec.html#schemas[Avro规范] ，了解更多关于Avro语法和支持的类型。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:157
#, fuzzy
msgid "With Quarkus, there's no need to use a specific Maven plugin to process the Avro schema, this is all done for you by the `quarkus-avro` extension!"
msgstr "有了Quarkus，就不需要使用特定的Maven插件来处理Avro模式，这一切都由 `quarkus-avro` 扩展来完成！"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:159
#, fuzzy
msgid "If you run the project with:"
msgstr "如果你在运行该项目时使用。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:164
#, fuzzy
msgid "the changes you do to the schema file will be automatically applied to the generated Java files."
msgstr "你对模式文件所做的修改将自动应用于生成的Java文件。"

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:165
#, fuzzy, no-wrap
msgid "The `Movie` producer"
msgstr " `Movie` 生产者"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:168
#, fuzzy
msgid "Having defined the schema, we can now jump to implementing the `MovieResource`."
msgstr "在定义了模式之后，我们现在可以跳到实现 `MovieResource` 。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:171
#, fuzzy
msgid "Let's open the `MovieResource`, inject an https://quarkus.io/blog/reactive-messaging-emitter/[`Emitter`] of `Movie` DTO and implement a `@POST` method that consumes `Movie` and sends it through the `Emitter`:"
msgstr "让我们打开 `MovieResource` ，注入一个 link:https://quarkus.io/blog/reactive-messaging-emitter/[`Emitter`] 的 `Movie` DTO，并实现一个 `@POST` 方法，消耗 `Movie` ，并通过 `Emitter` 发送。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:175
#: upstream/_guides/kafka-schema-registry-avro.adoc:242
#: upstream/_guides/kafka-schema-registry-avro.adoc:502
#: upstream/_guides/kafka-schema-registry-avro.adoc:630
#, no-wrap
msgid "package org.acme.kafka;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:180
#, no-wrap
msgid ""
"import org.acme.kafka.quarkus.Movie;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:184
#, no-wrap
msgid ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.core.Response;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:188
#, no-wrap
msgid ""
"@Path(\"/movies\")\n"
"public class MovieResource {\n"
"    private static final Logger LOGGER = Logger.getLogger(MovieResource.class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:191
#, no-wrap
msgid ""
"    @Channel(\"movies\")\n"
"    Emitter<Movie> emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:198
#, no-wrap
msgid ""
"    @POST\n"
"    public Response enqueueMovie(Movie movie) {\n"
"        LOGGER.infof(\"Sending movie %s to Kafka\", movie.getTitle());\n"
"        emitter.send(movie);\n"
"        return Response.accepted().build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:200
#: upstream/_guides/kafka-schema-registry-avro.adoc:590
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:204
#, fuzzy
msgid "Now, we need to _map_ the `movies` channel (the `Emitter` emits to this channel) to a Kafka topic.  To achieve this, edit the `application.properties` file, and add the following content:"
msgstr "现在，我们需要 _将_ `movies` 通道（ `Emitter` 发出到这个通道） _映射_ 到一个Kafka主题。为了实现这一点，编辑 `application.properties` 文件，并添加以下内容。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:209
#, no-wrap
msgid ""
"# set the connector for the outgoing channel to `smallrye-kafka`\n"
"mp.messaging.outgoing.movies.connector=smallrye-kafka\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:212
#, no-wrap
msgid ""
"# set the topic name for the channel to `movies`\n"
"mp.messaging.outgoing.movies.topic=movies\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:215
#, no-wrap
msgid ""
"# automatically register the schema with the registry, if not present\n"
"mp.messaging.outgoing.movies.apicurio.registry.auto-register=true\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:222
#, fuzzy
msgid "You might have noticed that we didn't define the `value.serializer`.  That's because Quarkus can xref:kafka.adoc#serialization-autodetection[autodetect] that `io.apicurio.registry.serde.avro.AvroKafkaSerializer` is appropriate here, based on the `@Channel` declaration, structure of the `Movie` type, and presence of the Apicurio Registry libraries.  We still have to define the `apicurio.registry.auto-register` property."
msgstr "你可能已经注意到，我们没有定义 `value.serializer` 。这是因为Quarkus可以根据 `@Channel` 的声明、 `Movie` 类型的结构以及Apicurio注册库的存在， link:kafka.html#serialization-autodetection[自动检测] 到 `io.apicurio.registry.serde.avro.AvroKafkaSerializer` 在这里是合适的。我们仍然需要定义 `apicurio.registry.auto-register` 这个属性。"

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:228
#, fuzzy
msgid "If you use Confluent Schema Registry, you don't have to configure `value.serializer` either.  It is also detected automatically.  The Confluent Schema Registry analogue of `apicurio.registry.auto-register` is called `auto.register.schemas`.  It defaults to `true`, so it doesn't have to be configured in this example.  It can be explicitly set to `false` if you want to disable automatic schema registration."
msgstr "如果你使用Confluent Schema Registry，你也不需要配置 `value.serializer` 。它也会被自动检测到。Confluent Schema Registry的类似物 `apicurio.registry.auto-register` ，叫做 `auto.register.schemas` 。它的默认值是 `true` ，所以在这个例子中不需要配置它。如果你想禁用自动模式注册，可以明确地将它设置为 `false` 。"

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:230
#, fuzzy, no-wrap
msgid "The `Movie` consumer"
msgstr " `Movie` 消费者"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:235
#, fuzzy
msgid "So, we can write records into Kafka containing our `Movie` data.  That data is serialized using Avro.  Now, it's time to implement a consumer for them."
msgstr "因此，我们可以向Kafka写入包含我们的 `Movie` 数据的记录。这些数据用Avro进行了序列化。现在，是时候为它们实现一个消费者了。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:238
#, fuzzy
msgid "Let's create `ConsumedMovieResource` that will consume `Movie` messages from the `movies-from-kafka` channel and will expose it via Server-Sent Events:"
msgstr "让我们创建 `ConsumedMovieResource` ，它将从 `movies-from-kafka` 通道中消费 `Movie` 消息，并将通过服务器发送的事件公开。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:248
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:252
#, no-wrap
msgid ""
"import org.acme.kafka.quarkus.Movie;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.jboss.resteasy.reactive.RestStreamElementType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:254
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:258
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Path(\"/consumed-movies\")\n"
"public class ConsumedMovieResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:261
#, no-wrap
msgid ""
"    @Channel(\"movies-from-kafka\")\n"
"    Multi<Movie> movies;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:269
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @RestStreamElementType(MediaType.TEXT_PLAIN)\n"
"    public Multi<String> stream() {\n"
"        return movies.map(movie -> String.format(\"'%s' from %s\", movie.getTitle(), movie.getYear()));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:273
#, fuzzy
msgid "The last bit of the application's code is the configuration of the `movies-from-kafka` channel in `application.properties`:"
msgstr "应用程序的最后一点代码是配置 `application.properties` 中的 `movies-from-kafka` 通道。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:278
#, no-wrap
msgid ""
"# set the connector for the incoming channel to `smallrye-kafka`\n"
"mp.messaging.incoming.movies-from-kafka.connector=smallrye-kafka\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:281
#, no-wrap
msgid ""
"# set the topic name for the channel to `movies`\n"
"mp.messaging.incoming.movies-from-kafka.topic=movies\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:284
#, no-wrap
msgid ""
"# disable auto-commit, Reactive Messaging handles it itself\n"
"mp.messaging.incoming.movies-from-kafka.enable.auto.commit=false\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:286
#, no-wrap
msgid "mp.messaging.incoming.movies-from-kafka.auto.offset.reset=earliest\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:293
#, fuzzy
msgid "You might have noticed that we didn't define the `value.deserializer`.  That's because Quarkus can xref:kafka.adoc#serialization-autodetection[autodetect] that `io.apicurio.registry.serde.avro.AvroKafkaDeserializer` is appropriate here, based on the `@Channel` declaration, structure of the `Movie` type, and presence of the Apicurio Registry libraries.  We don't have to define the `apicurio.registry.use-specific-avro-reader` property either, that is also configured automatically."
msgstr "你可能已经注意到，我们没有定义 `value.deserializer` 。这是因为Quarkus可以根据 `@Channel` 的声明、 `Movie` 类型的结构以及Apicurio注册库的存在， link:kafka.html#serialization-autodetection[自动检测] 到 `io.apicurio.registry.serde.avro.AvroKafkaDeserializer` 在这里是合适的。我们也不需要定义 `apicurio.registry.use-specific-avro-reader` 属性，那也是自动配置的。"

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:296
#, fuzzy
msgid "If you use Confluent Schema Registry, you don't have to configure `value.deserializer` or `specific.avro.reader` either.  They are both detected automatically."
msgstr "如果你使用Confluent Schema Registry，你也不需要配置 `value.deserializer` 或 `specific.avro.reader` 。它们都是自动检测的。"

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:298
#, fuzzy, no-wrap
msgid "Running the application"
msgstr "运行应用程序"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:301
#, fuzzy
msgid "Start the application in dev mode:"
msgstr "在开发模式下启动应用程序。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:306
#, fuzzy
msgid "Kafka broker and Apicurio Registry instance are started automatically thanks to Dev Services.  See xref:kafka-dev-services.adoc[Dev Services for Kafka] and xref:apicurio-registry-dev-services.adoc[Dev Services for Apicurio Registry] for more details."
msgstr "由于Dev Services，Kafka代理和Apicurio Registry实例被自动启动。更多细节请见 link:kafka-dev-services.html[Kafka的Dev Services] 和 link:apicurio-registry-dev-services.html[Apicurio Registry的Dev Services] 。"

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:311
#, fuzzy
msgid "You might have noticed that we didn't configure the schema registry URL anywhere.  This is because Dev Services for Apicurio Registry configures all Kafka channels in SmallRye Reactive Messaging to use the automatically started registry instance."
msgstr "你可能已经注意到，我们没有在任何地方配置模式注册表的URL。这是因为Dev Services for Apicurio Registry将SmallRye Reactive Messaging中的所有Kafka通道配置为使用自动启动的注册表实例。"

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:314
#, fuzzy
msgid "Apicurio Registry, in addition to its native API, also exposes an endpoint that is API-compatible with Confluent Schema Registry.  Therefore, this automatic configuration works both for Apicurio Registry serde and Confluent Schema Registry serde."
msgstr "Apicurio Registry除了它的本地API外，还暴露了一个与Confluent Schema Registry API兼容的端点。因此，这个自动配置对Apicurio Registry serde和Confluent Schema Registry serde都适用。"

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:317
#, fuzzy
msgid "However, note that there's no Dev Services support for running Confluent Schema Registry itself.  If you want to use a running instance of Confluent Schema Registry, configure its URL, together with the URL of a Kafka broker:"
msgstr "然而，请注意，Dev Services并不支持运行Confluent Schema Registry本身。如果你想使用Confluent Schema Registry的运行实例，请配置它的URL，以及Kafka代理的URL。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:322
#, no-wrap
msgid ""
"kafka.bootstrap.servers=PLAINTEXT://localhost:9092\n"
"mp.messaging.connector.smallrye-kafka.schema.registry.url=http://localhost:8081\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka-schema-registry-avro.adoc:326
#, fuzzy
msgid "In the second terminal, query the `ConsumedMovieResource` resource with `curl`:"
msgstr "在第二个终端，用 `curl` 查询 `ConsumedMovieResource` 资源。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:330
#, no-wrap
msgid "curl -N http://localhost:8080/consumed-movies\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:333
#, fuzzy
msgid "In the third one, post a few movies:"
msgstr "在第三种情况下，发布一些电影。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:340
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"title\":\"The Shawshank Redemption\",\"year\":1994}' \\\n"
"  http://localhost:8080/movies\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:345
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"title\":\"The Godfather\",\"year\":1972}' \\\n"
"  http://localhost:8080/movies\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:350
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"title\":\"The Dark Knight\",\"year\":2008}' \\\n"
"  http://localhost:8080/movies\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:355
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"title\":\"12 Angry Men\",\"year\":1957}' \\\n"
"  http://localhost:8080/movies\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:358
#, fuzzy
msgid "Observe what is printed in the second terminal. You should see something along the lines of:"
msgstr "观察第二个终端中打印的内容。你应该看到类似以下内容。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:362
#, no-wrap
msgid "data:'The Shawshank Redemption' from 1994\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:364
#, no-wrap
msgid "data:'The Godfather' from 1972\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:366
#, no-wrap
msgid "data:'The Dark Knight' from 2008\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:368
#, no-wrap
msgid "data:'12 Angry Men' from 1957\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:370
#, fuzzy, no-wrap
msgid "Running in JVM or Native mode"
msgstr "在JVM或本地模式下运行"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:374
#, fuzzy
msgid "When not running in dev or test mode, you will need to start your own Kafka broker and Apicurio Registry.  The easiest way to get them running is to use `docker-compose` to start the appropriate containers."
msgstr "当不在开发或测试模式下运行时，你将需要启动你自己的Kafka代理和Apicurio注册表。让它们运行的最简单方法是使用 `docker-compose` 来启动相应的容器。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:377
#, fuzzy
msgid "If you use Confluent Schema Registry, you already have a Kafka broker and Confluent Schema Registry instance running and configured.  You can ignore the `docker-compose` instructions here, as well as the Apicurio Registry configuration."
msgstr "如果你使用Confluent Schema Registry，你已经有一个Kafka代理和Confluent Schema Registry实例在运行和配置了。你可以忽略这里的 `docker-compose` 说明，以及Apicurio Registry的配置。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:379
#, fuzzy
msgid "Create a `docker-compose.yaml` file at the root of the project with the following content:"
msgstr "在项目的根部创建一个 `docker-compose.yaml` ，内容如下。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:383
#, no-wrap
msgid "version: '2'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:385
#, no-wrap
msgid "services:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:396
#, no-wrap
msgid ""
"  zookeeper:\n"
"    image: quay.io/strimzi/kafka:0.22.1-kafka-2.7.0\n"
"    command: [\n"
"        \"sh\", \"-c\",\n"
"        \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:412
#, no-wrap
msgid ""
"  kafka:\n"
"    image: quay.io/strimzi/kafka:0.22.1-kafka-2.7.0\n"
"    command: [\n"
"        \"sh\", \"-c\",\n"
"        \"bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:421
#, no-wrap
msgid ""
"  schema-registry:\n"
"    image: apicurio/apicurio-registry-mem:2.1.5.Final\n"
"    ports:\n"
"      - 8081:8080\n"
"    depends_on:\n"
"      - kafka\n"
"    environment:\n"
"      QUARKUS_PROFILE: prod\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:424
#, fuzzy
msgid "Before starting the application, let's first start the Kafka broker and Apicurio Registry:"
msgstr "在启动应用程序之前，让我们先启动Kafka broker和Apicurio Registry。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:428
#, no-wrap
msgid "docker-compose up\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:432
#, fuzzy
msgid "To stop the containers, use `docker-compose down`. You can also clean up the containers with `docker-compose rm`"
msgstr "要停止容器，请使用 `docker-compose down` 。你也可以用以下方法清理容器 `docker-compose rm` "

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:434
#, fuzzy
msgid "You can build the application with:"
msgstr "你可以用以下方法来构建应用程序。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:438
#, fuzzy
msgid "And run it in JVM mode with:"
msgstr "并在JVM模式下运行它，用。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:442
#, no-wrap
msgid "java -Dmp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v2 -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:446
#, fuzzy
msgid "By default, the application tries to connect to a Kafka broker listening at `localhost:9092`.  You can configure the bootstrap server using: `java -Dkafka.bootstrap.servers=\\... -jar target/quarkus-app/quarkus-run.jar`"
msgstr "默认情况下，应用程序会尝试连接到监听在 `localhost:9092` 的Kafka代理。你可以用以下方式配置引导服务器。 `java -Dkafka.bootstrap.servers=... -jar target/quarkus-app/quarkus-run.jar` "

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:448
#, fuzzy
msgid "Specifying the registry URL on the command line is not very convenient, so you can add a configuration property only for the `prod` profile:"
msgstr "在命令行上指定注册表的URL不是很方便，所以你可以只为 `prod` 配置文件添加一个配置属性。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:452
#, no-wrap
msgid "%prod.mp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:455
#, fuzzy
msgid "You can build a native executable with:"
msgstr "你可以用以下方法构建一个本地可执行文件。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:459
#, fuzzy
msgid "and run it with:"
msgstr "并运行它与。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:463
#, no-wrap
msgid "./target/kafka-avro-schema-quickstart-1.0.0-SNAPSHOT-runner -Dkafka.bootstrap.servers=localhost:9092\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:465
#, fuzzy, no-wrap
msgid "Testing the application"
msgstr "测试应用程序"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:470
#, fuzzy
msgid "As mentioned above, Dev Services for Kafka and Apicurio Registry automatically start and configure a Kafka broker and Apicurio Registry instance in dev mode and for tests.  Hence, we don't have to set up Kafka and Apicurio Registry ourselves.  We can just focus on writing the test."
msgstr "如上所述，Kafka和Apicurio Registry的Dev服务在开发模式和测试中自动启动和配置Kafka代理和Apicurio Registry实例。因此，我们不需要自己设置Kafka和Apicurio Registry。我们可以只专注于编写测试。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:472
#, fuzzy
msgid "First, let's add test dependencies on REST Client and Awaitility to the build file:"
msgstr "首先，让我们在构建文件中添加对REST客户端和Awaitility的测试依赖。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:487
#, no-wrap
msgid ""
"<!-- we'll use JAX-RS Client for talking to the SSE endpoint -->\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-rest-client-reactive</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>org.awaitility</groupId>\n"
"    <artifactId>awaitility</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:494
#, no-wrap
msgid ""
"testImplementation(\"io.quarkus:quarkus-rest-client-reactive\")\n"
"testImplementation(\"org.awaitility:awaitility\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:498
#, fuzzy
msgid "In the test, we will send movies in a loop and check if the `ConsumedMovieResource` returns what we send."
msgstr "在测试中，我们将在一个循环中发送电影，并检查 `ConsumedMovieResource` 是否返回我们发送的内容。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:509
#, no-wrap
msgid ""
"import io.quarkus.test.common.QuarkusTestResource;\n"
"import io.quarkus.test.common.http.TestHTTPResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.restassured.http.ContentType;\n"
"import org.hamcrest.Matchers;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:519
#, no-wrap
msgid ""
"import javax.ws.rs.client.Client;\n"
"import javax.ws.rs.client.ClientBuilder;\n"
"import javax.ws.rs.client.WebTarget;\n"
"import javax.ws.rs.sse.SseEventSource;\n"
"import java.net.URI;\n"
"import java.util.List;\n"
"import java.util.concurrent.CopyOnWriteArrayList;\n"
"import java.util.concurrent.ExecutorService;\n"
"import java.util.concurrent.Executors;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:525
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static java.util.concurrent.TimeUnit.MILLISECONDS;\n"
"import static java.util.concurrent.TimeUnit.SECONDS;\n"
"import static org.awaitility.Awaitility.await;\n"
"import static org.hamcrest.MatcherAssert.assertThat;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:528
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class MovieResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:531
#, no-wrap
msgid ""
"    @TestHTTPResource(\"/consumed-movies\")\n"
"    URI consumedMovies;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:537
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() throws InterruptedException {\n"
"        // create a client for `ConsumedMovieResource` and collect the consumed resources in a list\n"
"        Client client = ClientBuilder.newClient();\n"
"        WebTarget target = client.target(consumedMovies);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:539
#, no-wrap
msgid "        List<String> received = new CopyOnWriteArrayList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:542
#, no-wrap
msgid ""
"        SseEventSource source = SseEventSource.target(target).build();\n"
"        source.register(inboundSseEvent -> received.add(inboundSseEvent.readData()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:545
#, no-wrap
msgid ""
"        // in a separate thread, feed the `MovieResource`\n"
"        ExecutorService movieSender = startSendingMovies();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:547
#, no-wrap
msgid "        source.open();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:553
#, no-wrap
msgid ""
"        // check if, after at most 5 seconds, we have at least 2 items collected, and they are what we expect\n"
"        await().atMost(5, SECONDS).until(() -> received.size() >= 2);\n"
"        assertThat(received, Matchers.hasItems(\"'The Shawshank Redemption' from 1994\",\n"
"                \"'12 Angry Men' from 1957\"));\n"
"        source.close();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:558
#, no-wrap
msgid ""
"        // shutdown the executor that is feeding the `MovieResource`\n"
"        movieSender.shutdownNow();\n"
"        movieSender.awaitTermination(5, SECONDS);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:570
#, no-wrap
msgid ""
"    private ExecutorService startSendingMovies() {\n"
"        ExecutorService executorService = Executors.newSingleThreadExecutor();\n"
"        executorService.execute(() -> {\n"
"            while (true) {\n"
"                given()\n"
"                        .contentType(ContentType.JSON)\n"
"                        .body(\"{\\\"title\\\":\\\"The Shawshank Redemption\\\",\\\"year\\\":1994}\")\n"
"                .when()\n"
"                        .post(\"/movies\")\n"
"                .then()\n"
"                        .statusCode(202);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:578
#, no-wrap
msgid ""
"                given()\n"
"                        .contentType(ContentType.JSON)\n"
"                        .body(\"{\\\"title\\\":\\\"12 Angry Men\\\",\\\"year\\\":1957}\")\n"
"                .when()\n"
"                        .post(\"/movies\")\n"
"                .then()\n"
"                        .statusCode(202);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:588
#, no-wrap
msgid ""
"                try {\n"
"                    Thread.sleep(200L);\n"
"                } catch (InterruptedException e) {\n"
"                    break;\n"
"                }\n"
"            }\n"
"        });\n"
"        return executorService;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:595
#, fuzzy
msgid "We modified the `MovieResourceTest` that was generated together with the project. This test class has a subclass, `NativeMovieResourceIT`, that runs the same test against the native executable.  To run it, execute:"
msgstr "我们修改了与该项目一起生成的 `MovieResourceTest` 。这个测试类有一个子类， `NativeMovieResourceIT` ，它针对本地可执行文件运行相同的测试。要运行它，请执行。"

#. type: Title ===
#: upstream/_guides/kafka-schema-registry-avro.adoc:598
#, fuzzy, no-wrap
msgid "Manual setup"
msgstr "手动设置"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:601
#, fuzzy
msgid "If we couldn't use Dev Services and wanted to start a Kafka broker and Apicurio Registry instance manually, we would define a xref:getting-started-testing.adoc#quarkus-test-resource[QuarkusTestResourceLifecycleManager]."
msgstr "如果我们不能使用Dev Services，想手动启动Kafka代理和Apicurio注册表实例，我们会定义一个 link:getting-started-testing.html#quarkus-test-resource[QuarkusTestResourceLifecycleManager] 。"

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:617
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>strimzi-test-container</artifactId>\n"
"    <version>0.22.1</version>\n"
"    <scope>test</scope>\n"
"    <exclusions>\n"
"        <exclusion>\n"
"            <groupId>org.apache.logging.log4j</groupId>\n"
"            <artifactId>log4j-core</artifactId>\n"
"        </exclusion>\n"
"    </exclusions>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:625
#, no-wrap
msgid ""
"testImplementation(\"io.strimzi:strimzi-test-container:0.22.1\") {\n"
"    exclude group: \"org.apache.logging.log4j\", module: \"log4j-core\" \n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:633
#, no-wrap
msgid ""
"import java.util.HashMap;\n"
"import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:635
#, no-wrap
msgid "import org.testcontainers.containers.GenericContainer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:638
#, no-wrap
msgid ""
"import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n"
"import io.strimzi.StrimziKafkaContainer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:640
#, no-wrap
msgid "public class KafkaAndSchemaRegistryTestResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:642
#, no-wrap
msgid "    private final StrimziKafkaContainer kafka = new StrimziKafkaContainer();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:644
#, no-wrap
msgid "    private GenericContainer<?> registry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:658
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        registry = new GenericContainer<>(\"apicurio/apicurio-registry-mem:2.1.5.Final\")\n"
"                .withExposedPorts(8080)\n"
"                .withEnv(\"QUARKUS_PROFILE\", \"prod\");\n"
"        registry.start();\n"
"        Map<String, String> properties = new HashMap<>();\n"
"        properties.put(\"mp.messaging.connector.smallrye-kafka.apicurio.registry.url\",\n"
"                \"http://\" + registry.getContainerIpAddress() + \":\" + registry.getMappedPort(8080) + \"/apis/registry/v2\");\n"
"        properties.put(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());\n"
"        return properties;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:665
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        registry.stop();\n"
"        kafka.stop();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-schema-registry-avro.adoc:674
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaAndSchemaRegistryTestResource.class)\n"
"public class MovieResourceTest {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:676
#, fuzzy, no-wrap
msgid "Avro code generation details"
msgstr "Avro代码生成细节"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:680
#, fuzzy
msgid "In this guide we used the Quarkus code generation mechanism to generate Java files from Avro schema."
msgstr "在本指南中，我们使用Quarkus代码生成机制，从Avro模式中生成Java文件。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:682
#, fuzzy
msgid "Under the hood, the mechanism uses `org.apache.avro:avro-compiler`."
msgstr "在引擎盖下，该机制使用 `org.apache.avro:avro-compiler` 。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:684
#, fuzzy
msgid "You can use the following configuration properties to alter how it works:"
msgstr "你可以使用以下配置属性来改变其工作方式。"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:688
#, fuzzy
msgid "`avro.codegen.[avsc|avdl|avpr].imports` - a list of files or directories that should be compiled first thus making them importable by subsequently compiled schemas. Note that imported files should not reference each other. All paths should be relative to the `src/[main|test]/avro` directory. Passed as a comma-separated list."
msgstr " `avro.codegen.[avsc|avdl|avpr].imports` - 一个文件或目录的列表，这些文件或目录应该首先被编译，从而使它们可以被随后编译的模式导入。请注意，导入的文件不应相互引用。所有的路径应该是相对于 目录的。以逗号分隔的列表形式传递。 `src/[main|test]/avro` "

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:690
#, fuzzy
msgid "`avro.codegen.stringType` - the Java type to use for Avro strings. May be one of `CharSequence`, `String` or `Utf8`. Defaults to `String`"
msgstr " `avro.codegen.stringType` - 用于Avro字符串的Java类型。可以是 , 或 中的一个。默认为 `CharSequence` `String` `Utf8` `String` "

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:692
#, fuzzy
msgid "`avro.codegen.createOptionalGetters` - enables generating the `getOptional...` methods that return an Optional of the requested type. Defaults to `false`"
msgstr " `avro.codegen.createOptionalGetters` - 可以生成返回所请求类型的Optional的 方法。默认为 `getOptional…​` `false` "

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:693
#, fuzzy
msgid "`avro.codegen.enableDecimalLogicalType` - determines whether to use Java classes for decimal types, defaults to `false`"
msgstr " `avro.codegen.enableDecimalLogicalType` - 决定是否对小数类型使用Java类，默认为 `false` "

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:695
#, fuzzy
msgid "`avro.codegen.createSetters` - determines whether to create setters for the fields of the record.  Defaults to `false`"
msgstr " `avro.codegen.createSetters` - 决定是否为记录的字段创建设置器。默认为 `false` "

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:697
#, fuzzy
msgid "`avro.codegen.gettersReturnOptional` - enables generating `get...` methods that return an Optional of the requested type. Defaults to `false`"
msgstr " `avro.codegen.gettersReturnOptional` - 可以生成返回所请求类型的Optional的 方法。默认为 `get…​` `false` "

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:700
#, fuzzy
msgid "`avro.codegen.optionalGettersForNullableFieldsOnly`, works in conjunction with `gettersReturnOptional` option.  If it is set, `Optional` getters will be generated only for fields that are nullable. If the field is mandatory, regular getter will be generated. Defaults to `false`"
msgstr " `avro.codegen.optionalGettersForNullableFieldsOnly` ，与 `gettersReturnOptional` 选项一起工作。如果它被设置， `Optional` getter将只为可归零的字段生成。如果该字段是强制性的，将生成常规的getter。默认值为 `false` "

#. type: Title ==
#: upstream/_guides/kafka-schema-registry-avro.adoc:701
#, fuzzy, no-wrap
msgid "Further reading"
msgstr "进一步阅读"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:704
#, fuzzy
msgid "link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.9/kafka/kafka.html[SmallRye Reactive Messaging Kafka] documentation"
msgstr "link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.9/kafka/kafka.html[SmallRye Reactive Messaging Kafka] 文档"

#. type: Plain text
#: upstream/_guides/kafka-schema-registry-avro.adoc:705
msgid "link:https://quarkus.io/blog/kafka-avro/[How to Use Kafka, Schema Registry and Avro with Quarkus] - a blog post on which the guide is based. It gives a good introduction to Avro and the concept of schema registry"
msgstr ""
