# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-16 16:23+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: _guides/security-proactive-authentication.adoc
#, no-wrap
msgid "Proactive authentication"
msgstr "主动认证"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "Proactive authentication is enabled in Quarkus by default. This means that if an incoming request has a credential then that request will always be authenticated, even if the target page does not require authentication."
msgstr "Quarkus默认启用了主动认证。这意味着，如果一个传入的请求有一个证书，那么这个请求将总是被认证，即使目标页面不需要认证。"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "Requests with an invalid credential will always be rejected, even when the page is public."
msgstr "无效凭证的请求将总是被拒绝，即使页面是公开的。"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "If you only want to authenticate when the target page requires authentication, you can change the default behavior."
msgstr "如果你只想在目标页面需要认证时进行认证，你可以改变默认行为。"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "To disable proactive authentication in Quarkus, set the following attribute in the `application.properties` configuration file:"
msgstr "要在Quarkus中禁用主动认证，请在 `application.properties` 配置文件中设置以下属性："

#: _guides/security-proactive-authentication.adoc
msgid ""
"If you disable proactive authentication, the authentication process runs only when an identity is requested.\n"
"An identity can be requested because of security rules that require the user to authenticate or because programmatic access to the current identity is required."
msgstr ""

#: _guides/security-proactive-authentication.adoc
msgid ""
"If proactive authentication is in use, accessing `SecurityIdentity` is a blocking operation.\n"
"This is because authentication might have yet to happen and accessing `SecurityIdentity` might require calls to external systems, such as databases, that might block the operation.\n"
"For blocking applications, this is not an issue.\n"
"However, if you have disabled authentication in a reactive application, this will fail because you cannot do blocking operations on the I/O thread.\n"
"To work around this, you need to `@Inject` an instance of `io.quarkus.security.identity.CurrentIdentityAssociation` and call the `Uni<SecurityIdentity> getDeferredIdentity();` method.\n"
"Then, you can subscribe to the resulting `Uni` and will be notified when authentication is complete and the identity is available."
msgstr ""

#: _guides/security-proactive-authentication.adoc
msgid ""
"You can still access `SecurityIdentity` synchronously with `public SecurityIdentity getIdentity()` in xref:resteasy-reactive.adoc[RESTEasy Reactive] from endpoints that are annotated with `@RolesAllowed`, `@Authenticated`, or with respective configuration authorization checks because authentication has already happened.\n"
"The same is also valid for xref:reactive-routes.adoc[Reactive routes] if a route response is synchronous."
msgstr ""

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "xref:security-authorize-web-endpoints-reference.adoc#standard-security-annotations[Standard security annotations] on CDI beans are not supported on an I/O thread if a non-void secured method returns a value synchronously and proactive authentication is disabled because they need to access `SecurityIdentity`."
msgstr "如果一个非void的安全方法同步返回一个值，并且因为需要访问 `SecurityIdentity` ，所以在I/O线程上不支持CDI Bean上的 link:security-authorization.html#standard-security-annotations[标准安全注解] ，主动认证被禁用。"

#: _guides/security-proactive-authentication.adoc
msgid ""
"In the following example, `HelloResource` and `HelloService` are defined.\n"
"Any GET request to `/hello` will run on the I/O thread and throw a `BlockingOperationNotAllowedException` exception."
msgstr ""

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "There is more than one way to fix the example:"
msgstr "修复这个例子的方法不止一种："

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "Switch to a worker thread by annotating the `hello` endpoint with `@Blocking`."
msgstr "通过用 `@Blocking` 注释 `hello` 端点来切换到一个工作线程。"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "Change the `sayHello` method return type by using a reactive or asynchronous data type."
msgstr "通过使用反应式或异步数据类型，改变 `sayHello` 方法的返回类型。"

#: _guides/security-proactive-authentication.adoc
msgid ""
"Move `@RolesAllowed` annotation to the endpoint.\n"
"This could be one of the safest ways because accessing `SecurityIdentity` from endpoint methods is never the blocking operation."
msgstr ""

#. type: Title ==
#: _guides/security-proactive-authentication.adoc
#, fuzzy, no-wrap
msgid "Customize authentication exception responses"
msgstr "自定义认证异常响应"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "You can use Jakarta REST `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException`, for example:"
msgstr "你可以使用Jakarta REST `ExceptionMapper` 来捕获Quarkus Security认证异常，例如： `io.quarkus.security.AuthenticationFailedException` ："

#: _guides/security-proactive-authentication.adoc
msgid ""
"Some HTTP authentication mechanisms need to handle authentication exceptions themselves to create a correct authentication challenge.\n"
"For example, `io.quarkus.oidc.runtime.CodeAuthenticationMechanism`, which manages OpenID Connect (OIDC) authorization code flow authentication, needs to build a correct redirect URL, cookies, and so on.\n"
"For that reason, avoid using custom exception mappers to customize authentication exceptions thrown by such mechanisms.\n"
"Instead, a safer approach is to ensure that proactive authentication is enabled and to use Vert.x HTTP route failure handlers.\n"
"This is because events come to the handler with the correct response status and headers.\n"
"You then only need to customize the response, as shown in the following example:"
msgstr ""

#. type: Title ==
#: _guides/security-proactive-authentication.adoc
#, no-wrap
msgid "References"
msgstr "参考文献"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "xref:security-overview.adoc[Quarkus Security overview]"
msgstr "link:security-overview.html[Quarkus安全概述]"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "xref:security-architecture.adoc[Quarkus Security architecture]"
msgstr "link:security-architecture.html[Quarkus安全架构]"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
#, fuzzy
msgid "xref:security-authentication-mechanisms.adoc[Authentication mechanisms in Quarkus]"
msgstr "link:security-authentication-mechanisms.html[Quarkus的认证机制]"

#. type: Plain text
#: _guides/security-proactive-authentication.adoc
msgid "xref:security-identity-providers.adoc[Identity providers]"
msgstr ""
