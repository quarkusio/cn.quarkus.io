# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-06-29 15:31+0000\n"
"PO-Revision-Date: 2022-08-08 08:35+0800\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.1.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/getting-started-testing.adoc:6
#, no-wrap
msgid "Testing Your Application"
msgstr "测试您的应用程序"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:23
msgid "Learn how to test your Quarkus Application.  This guide covers:"
msgstr "学习如何测试您的Quarkus应用程序。本指南包括："

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:25
msgid "Testing in JVM mode"
msgstr "在JVM模式下测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:26
msgid "Testing in native mode"
msgstr "在本地模式下测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:27
msgid "Injection of resources into tests"
msgstr "将资源注入测试中"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:28
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:32
msgid "The completed greeter application from the xref:getting-started.adoc[Getting Started Guide]"
msgstr "来自 link:getting-started.html[《入门指南》]  的完整的greeter应用程序"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:33
#, no-wrap
msgid "Architecture"
msgstr "架构"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:37
msgid "In this guide, we expand on the initial test that was created as part of the Getting Started Guide.  We cover injection into tests and also how to test native executables."
msgstr "在本指南中，我们对作为入门指南的一部分而创建的初始测试进行扩展。我们涵盖了注入测试以及如何测试本地可执行文件。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:39
msgid "Quarkus supports Continuous testing, but this is covered by the xref:continuous-testing.adoc[Continuous Testing Guide]."
msgstr "Quarkus支持持续测试，但这是 link:continuous-testing.html[持续测试指南] 所讨论的。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:40
#, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:44
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议您按照下面几节的说明，一步一步地创建应用程序。但您也可以直接跳到已完成的例子。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:46
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库： `git clone {quickstarts-clone-url}` ，或者下载 {quickstarts-archive-url}[存档] 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:48
msgid "The solution is located in the `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[directory]."
msgstr "该解决方案位于 `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[目录]中。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:50
msgid "This guide assumes you already have the completed application from the `getting-started` directory."
msgstr "本指南假设您已经准备好了 `getting-started` 目录中的应用。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:51
#, no-wrap
msgid "Recap of HTTP based Testing in JVM mode"
msgstr "对JVM模式中基于HTTP的测试的回顾"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:55
msgid "If you have started from the Getting Started example you should already have a completed test, including the correct tooling setup."
msgstr "如果您已从入门的例子开始，那您应该已经有了一个完成的测试例子，包括正确的安装了工具。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:57
msgid "In your build file you should see 2 test dependencies:"
msgstr "在您的构建文件中应该有2个测试依赖："

#. type: Block title
#: upstream/_guides/getting-started-testing.adoc:58
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:72
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-junit5</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.rest-assured</groupId>\n"
"    <artifactId>rest-assured</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/getting-started-testing.adoc:75
#, no-wrap
msgid "Gradle"
msgstr "Gradle"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:83
#, no-wrap
msgid ""
"dependencies {\n"
"    testImplementation(\"io.quarkus:quarkus-junit5\")\n"
"    testImplementation(\"io.rest-assured:rest-assured\")\n"
"}\n"
msgstr ""

#. type: delimited block *
#: upstream/_guides/getting-started-testing.adoc:89
msgid "`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.  `rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically sets the correct URL so no configuration is required."
msgstr "`quarkus-junit5` 是测试所必需的，因为它提供 `@QuarkusTest` 注解来控制测试框架。而 `rest-assured` 不是必需的，但它是测试HTTP节点的一种便捷方式，我们还集成对自动设置正确URL的支持，因此不需要配置。"

#. type: delimited block *
#: upstream/_guides/getting-started-testing.adoc:92
msgid "Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:"
msgstr "因为我们使用的是JUnit 5，所以必须设置 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven插件] 的版本，因为默认版本不支持Junit 5："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:105
#, no-wrap
msgid ""
"<plugin>\n"
"    <artifactId>maven-surefire-plugin</artifactId>\n"
"    <version>${surefire-plugin.version}</version>\n"
"    <configuration>\n"
"       <systemPropertyVariables>\n"
"          <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"          <maven.home>${maven.home}</maven.home>\n"
"       </systemPropertyVariables>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:109
msgid "We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any)."
msgstr "我们还设置了 `java.util.logging.manager` 系统属性，以确保测试使用正确的日志管理器。同时设置 `maven.home` 属性，以确保 `${maven.home}/conf/settings.xml` 的自定义配置被设置（如果有的话）。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:111
msgid "The project should also contain a simple test:"
msgstr "该项目还应该包含一个简单的测试："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:115
#: upstream/_guides/getting-started-testing.adoc:210
#: upstream/_guides/getting-started-testing.adoc:274
#: upstream/_guides/getting-started-testing.adoc:315
#: upstream/_guides/getting-started-testing.adoc:354
#: upstream/_guides/getting-started-testing.adoc:440
#: upstream/_guides/getting-started-testing.adoc:503
#, no-wrap
msgid "package org.acme.getting.started.testing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:118
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:120
#: upstream/_guides/getting-started-testing.adoc:321
#, no-wrap
msgid "import java.util.UUID;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:123
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:126
#: upstream/_guides/getting-started-testing.adoc:1039
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class GreetingResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:135
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:146
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreetingEndpoint() {\n"
"        String uuid = UUID.randomUUID().toString();\n"
"        given()\n"
"          .pathParam(\"name\", uuid)\n"
"          .when().get(\"/hello/greeting/{name}\")\n"
"          .then()\n"
"            .statusCode(200)\n"
"            .body(is(\"hello \" + uuid));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:148
#: upstream/_guides/getting-started-testing.adoc:414
#: upstream/_guides/getting-started-testing.adoc:736
#: upstream/_guides/getting-started-testing.adoc:1056
#: upstream/_guides/getting-started-testing.adoc:1273
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:152
msgid "This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before the test is run."
msgstr "该测试使用HTTP来直接测试我们的REST节点。当运行测试时，应用程序将在测试运行前被启动。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:153
#, no-wrap
msgid "Controlling the test port"
msgstr "控制测试端口"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:157
msgid "While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run tests while having the application running in parallel."
msgstr "虽然Quarkus默认会监听端口 `8080` ，但当运行测试时，它会默认设为 `8081` 。这允许您在运行测试的同时让应用程序并行运行。"

#. type: Block title
#: upstream/_guides/getting-started-testing.adoc:159
#, no-wrap
msgid "Changing the test port"
msgstr "改变测试端口"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:162
msgid "You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:"
msgstr "您可以通过 `quarkus.http.test-port` 和 `quarkus.http.test-ssl-port` 来配置用于HTTP和HTTPS测试的端口："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:166
#, no-wrap
msgid ""
"quarkus.http.test-port=8083\n"
"quarkus.http.test-ssl-port=8446\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:168
msgid "`0` will result in the use of a random port (assigned by the operating system)."
msgstr "设置为 `0` 则会使用随机端口（由操作系统分配）。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:172
msgid "Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run, so no additional configuration should be required."
msgstr "Quarkus还提供了RestAssured集成用以在测试运行前更新RestAssured使用的默认端口，因而不需要额外的配置。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:173
#, no-wrap
msgid "Controlling HTTP interaction timeout"
msgstr "控制HTTP交互超时时间"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:177
msgid "When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.  You can override this setting with the `quarkus.http.test-timeout` property:"
msgstr "当在您的测试中使用REST Assured时，连接和响应超时默认设置为30秒。可以通过 `quarkus.http.test-timeout` 属性覆盖该设置："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:181
#, no-wrap
msgid "quarkus.http.test-timeout=10s\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:183
#, no-wrap
msgid "Injecting a URI"
msgstr "注入URI"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:187
msgid "It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is done via the `@TestHTTPResource` annotation."
msgstr "也可以直接将URL注入测试中，从而可以更容易的使用不同的客户端。可通过 `@TestHTTPResource` 注解完成。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:190
msgid "Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in `src/main/resources/META-INF/resources/index.html` :"
msgstr "让我们写一个简单的测试来演示如何加载一些静态资源。首先创建一个简单的HTML文件 `src/main/resources/META-INF/resources/index.html` ："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:202
#, no-wrap
msgid ""
"<html>\n"
"    <head>\n"
"        <title>Testing Guide</title>\n"
"    </head>\n"
"    <body>\n"
"        Information about testing\n"
"    </body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:205
msgid "We will create a simple test to ensure that this is being served correctly:"
msgstr "我们将创建一个简单的测试以确保这个文件被正确的加载："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:215
#: upstream/_guides/getting-started-testing.adoc:279
#, no-wrap
msgid ""
"import java.io.IOException;\n"
"import java.io.InputStream;\n"
"import java.net.URL;\n"
"import java.nio.charset.StandardCharsets;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:218
#: upstream/_guides/getting-started-testing.adoc:282
#: upstream/_guides/getting-started-testing.adoc:359
#, no-wrap
msgid ""
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:221
#, no-wrap
msgid ""
"import io.quarkus.test.common.http.TestHTTPResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:224
#: upstream/_guides/getting-started-testing.adoc:289
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class StaticContentTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:227
#, no-wrap
msgid ""
"    @TestHTTPResource(\"index.html\") // <1>\n"
"    URL url;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:236
#, no-wrap
msgid ""
"    @Test\n"
"    public void testIndexHtml() throws IOException {\n"
"        try (InputStream in = url.openStream()) {\n"
"            String contents = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n"
"            Assertions.assertTrue(contents.contains(\"<title>Testing Guide</title>\"));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:238
msgid "This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL"
msgstr "该注解允许您将URL直接注入为Quarkus实例，注解的值将是URL的路径"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:240
msgid "For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL."
msgstr "目前为止 `@TestHTTPResource` 允许您注入 `URI` 、 `URL` 以及 `String` 的URL表示。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:241
#, no-wrap
msgid "Testing a specific endpoint"
msgstr "测试特定的节点"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:246
msgid "Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding a path. This currently supports both JAX-RS endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints a given test is testing."
msgstr "RESTassured和 `@TestHTTPResource` 都允许您指定要测试的节点类，而不是对路径硬编码。这目前支持JAX-RS节点、Servlets和Reactive Routes。这使您更容易查看给定的测试用例到底在测试哪些节点。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:248
msgid "For the purposes of these examples I am going to assume we have an endpoint that looks like the following:"
msgstr "为了演示这些例子的目的，这里将假设我们有一个类似于下面的节点："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:253
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:260
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:264
msgid "This currently does not support the `@ApplicationPath()` annotation to set the JAX-RS context path. Use the `quarkus.resteasy.path` config value instead if you want a custom context path."
msgstr "目前不支持使用 `@ApplicationPath()` 注解来设置 JAX-RS 上下文路径。如果您想要一个自定义的上下文路径，请使用 `quarkus.resteasy.path` 代替。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:265
#, no-wrap
msgid "TestHTTPResource"
msgstr "TestHTTPResource"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:270
msgid "You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will be appended to the end of the endpoint path."
msgstr "您可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注释来指定节点路径，该路径会从提供的节点中提取。如果您还为 `TestHTTPResource` 节点指定了另外的值，它将被附加到节点路径后。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:286
#, no-wrap
msgid ""
"import io.quarkus.test.common.http.TestHTTPEndpoint;\n"
"import io.quarkus.test.common.http.TestHTTPResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:293
#, no-wrap
msgid ""
"    @TestHTTPEndpoint(GreetingResource.class)  // <1>\n"
"    @TestHTTPResource\n"
"    URL url;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:302
#, no-wrap
msgid ""
"    @Test\n"
"    public void testIndexHtml() throws IOException {\n"
"        try (InputStream in = url.openStream()) {\n"
"            String contents = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n"
"            Assertions.assertEquals(\"hello\", contents);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:305
msgid "Because `GreetingResource` is annotated with `@Path(\"/hello\")` the injected URL will end with `/hello`."
msgstr "因为 `GreetingResource` 用到了注解 `@Path(\"/hello\")` ，注入的URL会以 `/hello` 结束。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:306
#, no-wrap
msgid "RESTassured"
msgstr "RESTassured"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:311
msgid "To control the RESTassured base path (i.e. the default path that serves as the root for every request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can be applied at the class or method level. To test out greeting resource we would do:"
msgstr "为了控制RESTassured基础路径（即作为每个请求根路径的默认路径），您可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注解。可以在类或方法层面上使用。为了测试greeting资源类，我们可以这样做："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:319
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.common.http.TestHTTPEndpoint;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:324
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.when;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:328
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestHTTPEndpoint(GreetingResource.class) //<1>\n"
"public class GreetingResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:337
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        when().get()    //<2>\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:339
msgid "This tells RESTAssured to prefix all requests with `/hello`."
msgstr "这将使RESTAssured在所有请求之前加上 `/hello` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:340
msgid "Note we don't need to specify a path here, as `/hello` is the default for this test"
msgstr "注意我们不需要在此指定路径，因为 `/hello` 是这个测试的默认路径"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:341
#, no-wrap
msgid "Injection into tests"
msgstr "注入测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:345
msgid "So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit testing and test our beans directly?"
msgstr "到目前为止，我们只涉及了通过HTTP节点测试应用程序的集成式测试，但如果我们想做单元测试并直接测试我们的Bean又该怎么办？"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:349
msgid "Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting service directly without using HTTP:"
msgstr "Quarkus支持这种方式。它允许使用 `@Inject` 注解来将CDI Bean注入您的测试中（事实上，Quarkus中的测试是完整的CDI Bean，所以您可以使用所有的CDI功能）。让我们创建一个简单的测试，直接测试greeting服务，而非使用HTTP："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:356
#, no-wrap
msgid "import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:361
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:364
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class GreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:367
#, no-wrap
msgid ""
"    @Inject // <1>\n"
"    GreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:373
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreetingService() {\n"
"        Assertions.assertEquals(\"hello Quarkus\", service.greeting(\"Quarkus\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:375
msgid "The `GreetingService` bean will be injected into the test"
msgstr "`GreetingService` bean将被注入到测试类中"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:376
#, no-wrap
msgid "Applying Interceptors to Tests"
msgstr "在测试中使用拦截器"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:381
msgid "As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the `@Transactional` annotation to the method and the transaction interceptor will handle it."
msgstr "如上所述，Quarkus测试实际上是完整的CDI Bean，因此您可以自由的使用CDI拦截器。举个例子，如果您想让测试方法在事务上下文中运行，您可以将 `@Transactional` 注解加到该方法上，之后事务拦截器将会处理。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:384
msgid "In addition to this you can also create your own test stereotypes. For example, we could create a `@TransactionalQuarkusTest` as follows:"
msgstr "除此以外，您还可以创建您自己的测试 stereotypes。例如，我们可以创建一个 `@TransactionalQuarkusTest` ，如下所示："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:394
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@Stereotype\n"
"@Transactional\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target(ElementType.TYPE)\n"
"public @interface TransactionalQuarkusTest {\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:398
msgid "If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and `@Transactional` annotations, e.g.:"
msgstr "如果我们将这个注解应用于测试类，那它就类似于我们同时应用了 `@QuarkusTest` 和 `@Transactional` 注解一样，例如："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:404
#, no-wrap
msgid ""
"@TransactionalQuarkusTest\n"
"public class TestStereotypeTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:407
#, no-wrap
msgid ""
"    @Inject\n"
"    UserTransaction userTransaction;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:412
#, no-wrap
msgid ""
"    @Test\n"
"    public void testUserTransaction() throws Exception {\n"
"        Assertions.assertEquals(Status.STATUS_ACTIVE, userTransaction.getStatus());\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:416
#, no-wrap
msgid "Tests and Transactions"
msgstr "测试与事务"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:422
msgid "You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your test makes to the database will be persistent. If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes."
msgstr "您可以在测试中使用标准的Quarkus `@Transactional` 注解，但这意味着您的测试对数据库的改变将是持久的。如果您想在测试结束时回滚所做的任何改变，您可以使用 `io.quarkus.test.TestTransaction` 注释。这将在一个事务中运行测试方法，但一旦测试方法完成，事务就会回滚从而以恢复所有数据库变化。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:423
#, no-wrap
msgid "Enrichment via QuarkusTest*Callback"
msgstr "通过QuarkusTest*Callback来增强"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:426
msgid "Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:"
msgstr "作为拦截器的替代或补充，您可以通过实现以下回调接口来增强 *所有* 的 `@QuarkusTest` 类："

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:428
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:429
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:430
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:431
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeTestExecutionCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:432
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterTestExecutionCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:433
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:435
msgid "Such a callback implementation has to be registered as a \"service provider\" as defined by `java.util.ServiceLoader`."
msgstr "这种回调实现必须作为java \"服务提供者(service provider) \"注册，从而被 `java.util.ServiceLoader` 来加载。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:437
msgid "E.g. the following sample callback:"
msgstr "例如下面的回调例子："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:443
#, no-wrap
msgid ""
"import io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback;\n"
"import io.quarkus.test.junit.callback.QuarkusTestMethodContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:445
#, no-wrap
msgid "public class MyQuarkusTestBeforeEachCallback implements QuarkusTestBeforeEachCallback {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:451
#, no-wrap
msgid ""
"    @Override\n"
"    public void beforeEach(QuarkusTestMethodContext context) {\n"
"        System.out.println(\"Executing \" + context.getTestMethod());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:453
msgid "has to be registered via `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` as follows:"
msgstr "该回调类必须通过 `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` 注册，具体如下："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:456
#, no-wrap
msgid "org.acme.getting.started.testing.MyQuarkusTestBeforeEachCallback\n"
msgstr "org.acme.getting.started.testing.MyQuarkusTestBeforeEachCallback\n"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:459
msgid "It is possible to read annotations from the test class or method to control what the callback shall be doing."
msgstr "可以从测试类或方法中读取注解，从而控制回调应做什么。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:462
#, no-wrap
msgid ""
"While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has\n"
"         to run tests in a custom classloader which JUnit is not aware of.\n"
msgstr "虽然可以使用JUnit Jupiter回调接口，如 `BeforeEachCallback` ，但您可能会遇到类加载问题，因为Quarkus必须在一个JUnit无法感知的自定义类加载器中运行测试。\n"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:464
#, no-wrap
msgid "Testing Different Profiles"
msgstr "测试不同的Profiles"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:469
msgid "So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot, then all tests will run, then Quarkus will shut down at the end. This makes for a very fast testing experience however it is a bit limited as you can't test different configurations."
msgstr "到目前为止，在我们所有的例子中，我们只为所有的测试启动Quarkus一次。在第一个测试运行之前，Quarkus会启动，然后所有测试都会在这次启动中运行，最后Quarkus会关闭。这使得测试体验非常快，但是它有一点局限性，因为您无法测试不同的配置。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:473
msgid "To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility."
msgstr "为了解决这个问题，Quarkus支持测试profile。如果一个测试有一个与之前运行的测试不同的profile，那么Quarkus将被停止，并在运行对应的测试之前使用新的profile启动。这显然会有些许变慢，因为它在测试时间上增加了一个停止/启动周期，但同时也提供了很大的灵活性。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:481
msgid "To reduce the amount of times Quarkus needs to restart, `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` is registered as a global `ClassOrderer` as described in the link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5 User Guide].  The behavior of this `ClassOrderer` is configurable via `junit-platform.properties` (see the source code or javadoc for more details).  It can also be disabled entirely by setting another `ClassOrderer` that is provided by JUnit 5 or even your own custom one. + Please note that as of JUnit 5.8.2 link:https://github.com/junit-team/junit5/issues/2794[only a single `junit-platform.properties` is picked up and a warning is logged if more than one is found].  If you encounter such warnings, you can get rid of them by removing the Quarkus-supplied `junit-platform.properties` from the classpath via an exclusion:"
msgstr "为了减少Quarkus需要重启的次数， `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` 被注册为全局 `ClassOrderer` ，如 link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5用户指南] 中所述。这个orderer的行为可以通过 `junit-platform.properties` （更多细节见源代码或javadoc）来配置。它也可以通过配置另一个由JUnit 5所提供的ClassOrderer，甚至是您自己的自定义Orderer来完全禁用。+ 请注意，从JUnit 5.8.2开始 link:https://github.com/junit-team/junit5/issues/2794[只能有一个 `junit-platform.properties` 被使用，如果超过一个就会有警告记录] 。如果您遇到这样的警告，您可以通过从classpath中移除Quarkus提供的 `junit-platform.properties` 来删除它们："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:494
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-junit5</artifactId>\n"
"    <scope>test</scope>\n"
"    <exclusions>\n"
"        <exclusion>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-junit5-properties</artifactId>\n"
"        </exclusion>\n"
"    </exclusions>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:496
#, no-wrap
msgid "Writing a Profile"
msgstr "编写Profile"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:499
msgid "To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:"
msgstr "为了实现一个测试profile，我们需要实现 `io.quarkus.test.junit.QuarkusTestProfile` ："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:508
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.List;\n"
"import java.util.Map;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:511
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTestProfile;\n"
"import io.quarkus.test.junit.QuarkusTestProfile.TestResourceEntry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:513
#, no-wrap
msgid "public class MockGreetingProfile implements QuarkusTestProfile { <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:526
#, no-wrap
msgid ""
"    /**\n"
"     * Returns additional config to be applied to the test. This\n"
"     * will override any existing config (including in application.properties),\n"
"     * however existing config will be merged with this (i.e. application.properties\n"
"     * config will still take effect, unless a specific config key has been overridden).\n"
"     *\n"
"     * Here we are changing the JAX-RS root path.\n"
"     */\n"
"    @Override\n"
"    public Map<String, String> getConfigOverrides() {\n"
"        return Collections.singletonMap(\"quarkus.resteasy.path\",\"/api\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:537
#, no-wrap
msgid ""
"    /**\n"
"     * Returns enabled alternatives.\n"
"     *\n"
"     * This has the same effect as setting the 'quarkus.arc.selected-alternatives' config key,\n"
"     * however it may be more convenient.\n"
"     */\n"
"    @Override\n"
"    public Set<Class<?>> getEnabledAlternatives() {\n"
"        return Collections.singleton(MockGreetingService.class);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:548
#, no-wrap
msgid ""
"    /**\n"
"     * Allows the default config profile to be overridden. This basically just sets the quarkus.test.profile system\n"
"     * property before the test is run.\n"
"     *\n"
"     * Here we are setting the profile to test-mocked\n"
"     */\n"
"    @Override\n"
"    public String getConfigProfile() {\n"
"        return \"test-mocked\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:560
#, no-wrap
msgid ""
"    /**\n"
"     * Additional {@link QuarkusTestResourceLifecycleManager} classes (along with their init params) to be used from this\n"
"     * specific test profile.\n"
"     *\n"
"     * If this method is not overridden, then only the {@link QuarkusTestResourceLifecycleManager} classes enabled via the {@link io.quarkus.test.common.QuarkusTestResource} class\n"
"     * annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all).\n"
"     */\n"
"    @Override\n"
"    public List<TestResourceEntry> testResources() {\n"
"        return Collections.singletonList(new TestResourceEntry(CustomWireMockServerManager.class));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:570
#, no-wrap
msgid ""
"    /**\n"
"     * If this returns true then only the test resources returned from {@link #testResources()} will be started,\n"
"     * global annotated test resources will be ignored.\n"
"     */\n"
"    @Override\n"
"    public boolean disableGlobalTestResources() {\n"
"        return false;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:581
#, no-wrap
msgid ""
"    /**\n"
"     * The tags this profile is associated with.\n"
"     * When the {@code quarkus.test.profile.tags} System property is set (its value is a comma separated list of strings)\n"
"     * then Quarkus will only execute tests that are annotated with a {@code @TestProfile} that has at least one of the\n"
"     * supplied (via the aforementioned system property) tags.\n"
"     */\n"
"    @Override\n"
"    public Set<String> tags() {\n"
"        return Collections.emptySet();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:589
#, no-wrap
msgid ""
"    /**\n"
"     * The command line parameters that are passed to the main method on startup.\n"
"     */\n"
"    @Override\n"
"    public String[] commandLineParameters() {\n"
"        return new String[0];\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:597
#, no-wrap
msgid ""
"    /**\n"
"     * If the main method should be run.\n"
"     */\n"
"    @Override\n"
"    public boolean runMainMethod() {\n"
"        return false;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:607
#, no-wrap
msgid ""
"    /**\n"
"     * If this method returns true then all {@code StartupEvent} and {@code ShutdownEvent} observers declared on application\n"
"     * beans should be disabled.\n"
"     */\n"
"    @Override\n"
"    public boolean disableApplicationLifecycleObservers() {\n"
"        return false;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:609
msgid "All these methods have default implementations so just override the ones you need to override."
msgstr "所有这些方法都有默认的实现，所以只要覆盖您需要覆盖的方法就可以。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:612
msgid "Now we have defined our profile we need to include it on our test class.  We do this by annotating the test class with `@TestProfile(MockGreetingProfile.class)`."
msgstr "现在我们已经定义了我们自己的profile，我们需要在我们的测试类中引入它。我们通过在测试类中注解 `@TestProfile(MockGreetingProfile.class)` 来做到这一点。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:615
msgid "All the test profile configuration is stored in a single class, which makes it easy to tell if the previous test ran with the same configuration."
msgstr "所有的测试profile配置都存储在一个单一的类中，这使得我们很容易知道之前的测试是否以相同的配置运行。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:616
#, no-wrap
msgid "Running specific tests"
msgstr "运行特定的测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:620
msgid "Quarkus provides the ability to limit test execution to tests with specific `@TestProfile` annotations.  This works by leveraging the `tags` method of `QuarkusTestProfile` in conjunction with the `quarkus.test.profile.tags` system property."
msgstr "Quarkus提供了将测试限制在具有特定 `@TestProfile` 注释的测试中执行的能力。这是通过联合利用 `QuarkusTestProfile` 的 `tags` 方法和 `quarkus.test.profile.tags` 系统属性来实现的。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:624
msgid "Essentially, any `QuarkusTestProfile` with at least one matching tag matching the value of `quarkus.test.profile.tags` will be considered active and all the tests annotated with `@TestProfile` of active profiles, will be run while the rest will be skipped.  This is best shown in the following example."
msgstr "本质上，任何至少有一个标签与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 将被认为是激活的，并且所有被激活的profiles中注解了 `@TestProfile` 的测试将被运行，而其余的将被跳过。这在下面的例子中得到了最好的体现。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:626
msgid "First let's define a few `QuarkusTestProfile` implementations like so:"
msgstr "首先让我们定义这么几个 `QuarkusTestProfile` 实现："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:629
#, no-wrap
msgid "public class Profiles {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:631
#, no-wrap
msgid "    public static class NoTags implements QuarkusTestProfile {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:633
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:640
#, no-wrap
msgid ""
"    public static class SingleTag implements QuarkusTestProfile {\n"
"        @Override\n"
"        public Set<String> tags() {\n"
"            return Collections.singleton(\"test1\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:648
#, no-wrap
msgid ""
"    public static class MultipleTags implements QuarkusTestProfile {\n"
"        @Override\n"
"        public Set<String> tags() {\n"
"            return new HashSet<>(Arrays.asList(\"test1\", \"test2\"));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:651
msgid "Now let's assume that we have the following tests:"
msgstr "现在让我们假设有以下测试："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:656
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class NoQuarkusProfileTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:662
#: upstream/_guides/getting-started-testing.adoc:675
#: upstream/_guides/getting-started-testing.adoc:688
#: upstream/_guides/getting-started-testing.adoc:701
#, no-wrap
msgid ""
"    @Test\n"
"    public void test() {\n"
"        // test something\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:669
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.NoTags.class)\n"
"public class NoTagsTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:682
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.SingleTag.class)\n"
"public class SingleTagTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:695
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.MultipleTags.class)\n"
"public class MultipleTagsTest {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:704
msgid "Let's consider the following scenarios:"
msgstr "让我们考虑以下场景："

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:706
msgid "`quarkus.test.profile.tags` is not set: All tests will be executed."
msgstr "`quarkus.test.profile.tags` 未被设置。所有的测试都将被执行。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:708
msgid "`quarkus.test.profile.tags=foo`: In this case none of tests will be executed because none of the tags defined on the `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`.  Note that `NoQuarkusProfileTest` is not executed either because it is not annotated with `@TestProfile`."
msgstr "`quarkus.test.profile.tags=foo` :在这种情况下，所欧测试都不会被执行，因为在 `QuarkusTestProfile` 实现上定义的标签中没有一个与 `quarkus.test.profile.tags` 的值相匹配。注意， `NoQuarkusProfileTest` 也不会被执行，因为它没有 `@TestProfile` 注解。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:710
msgid "`quarkus.test.profile.tags=test1`: In this case `SingleTagTest` and `MultipleTagsTest` will be run because the tags on their respective `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`."
msgstr "`quarkus.test.profile.tags=test1` :在这种情况下， `SingleTagTest` 和 `MultipleTagsTest` 将被运行，因为它们各自的 `QuarkusTestProfile` 实现的标签与 `quarkus.test.profile.tags` 的值一致。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:711
msgid "`quarkus.test.profile.tags=test1,test3`: This case results in the same tests being executed as the previous case."
msgstr "`quarkus.test.profile.tags=test1,test3` :这种情况下，执行的测试与前一种情况相同。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:713
msgid "`quarkus.test.profile.tags=test2,test3`: In this case only `MultipleTagsTest` will be run because `MultipleTagsTest` is the only `QuarkusTestProfile` implementation whose `tags` method matches the value of `quarkus.test.profile.tags`."
msgstr "`quarkus.test.profile.tags=test2,test3` :在这种情况下，只有 `MultipleTagsTest` 会被运行，因为 `MultipleTagsTest` 是唯一一个 `tags` 方法与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 实现。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:714
#, no-wrap
msgid "Mock Support"
msgstr "Mock支持"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:718
msgid "Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis."
msgstr "Quarkus支持使用两种不同的方法来mock对象。您可以使用CDI alternatives来mock出所有测试类的Bean，也可以使用 `QuarkusMock` 来mock出每个测试类的Bean。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:719
#, no-wrap
msgid "CDI `@Alternative` mechanism."
msgstr "CDI `@Alternative` 机制。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:725
msgid "To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.  Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.  This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.  For example if I have the following service:"
msgstr "要使用这个方法，只需用 `src/test/java` 目录中的一个类来覆盖您想mock的Bean，并在Bean上加上 `@Alternative` 和 `@Priority(1)` 注解。另外，也可以使用 `io.quarkus.test.Mock` stereotype注释。这个内置的stereotype声明了 `@Alternative` 、 `@Priority(1)` 和 `@Dependent` 。例如，如果我有以下的服务："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:730
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ExternalService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:734
#, no-wrap
msgid ""
"    public String service() {\n"
"        return \"external\";\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:739
msgid "I could mock it with the following class in `src/test/java`:"
msgstr "我可以在 `src/test/java` 中用以下类来mock它："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:745
#, no-wrap
msgid ""
"@Mock\n"
"@ApplicationScoped // <1>\n"
"public class MockExternalService extends ExternalService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:751
#, no-wrap
msgid ""
"    @Override\n"
"    public String service() {\n"
"        return \"mock\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:753
msgid "Overrides the `@Dependent` scope declared on the `@Mock` stereotype."
msgstr "对 `@Mock` stereotype上声明的 `@Dependent` 范围的覆盖。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:756
msgid "It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise it will take effect all the time, not just when testing."
msgstr "注意，alternative要放置于 `src/test/java` 目录中而不是 `src/main/java` ，否则它将不仅仅只是在测试时生效。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:759
msgid "Note that at present this approach does not work with native image testing, as this would require the test alternatives to be baked into the native image."
msgstr "另外需要注意的是，目前这种方法不能用于本地镜像测试，因为这需要将测试用的alternatives加入本地镜像中。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:761
#, no-wrap
msgid "Mocking using QuarkusMock"
msgstr "使用QuarkusMock进行mock"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:766
msgid "The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class, while if you use this in a test method the mock will only take effect for the duration of the current test."
msgstr "`io.quarkus.test.junit.QuarkusMock` 类可以被用来临时mock任何正常scope的bean。如果您在 `@BeforeAll` 方法中使用这个方法，mock将对当前类的所有测试生效，而如果您在测试方法中使用这个方法，mock将只在当前测试方法范围内生效。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:769
msgid "This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically every scope except `@Singleton` and `@Dependent`)."
msgstr "该方法可以用于任何正常scope的CDI Bean（例如： `@ApplicationScoped` , `@RequestScoped` 等，基本上是除了 `@Singleton` 和 `@Dependent` 以外的scope ）。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:771
msgid "An example usage could look like:"
msgstr "示例用法如下所示："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:776
#: upstream/_guides/getting-started-testing.adoc:848
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class MockTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:779
#, no-wrap
msgid ""
"    @Inject\n"
"    MockableBean1 mockableBean1;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:782
#, no-wrap
msgid ""
"    @Inject\n"
"    MockableBean2 mockableBean2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:789
#, no-wrap
msgid ""
"    @BeforeAll\n"
"    public static void setup() {\n"
"        MockableBean1 mock = Mockito.mock(MockableBean1.class);\n"
"        Mockito.when(mock.greet(\"Stuart\")).thenReturn(\"A mock for Stuart\");\n"
"        QuarkusMock.installMockForType(mock, MockableBean1.class);  // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:795
#, no-wrap
msgid ""
"    @Test\n"
"    public void testBeforeAll() {\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Hello Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:802
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPerTestMock() {\n"
"        QuarkusMock.installMockForInstance(new BonjourGreeter(), mockableBean2); // <2>\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Bonjour Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:805
#: upstream/_guides/getting-started-testing.adoc:875
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class MockableBean1 {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:810
#: upstream/_guides/getting-started-testing.adoc:818
#: upstream/_guides/getting-started-testing.adoc:880
#, no-wrap
msgid ""
"        public String greet(String name) {\n"
"            return \"Hello \" + name;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:813
#: upstream/_guides/getting-started-testing.adoc:883
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class MockableBean2 {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:826
#, no-wrap
msgid ""
"    public static class BonjourGreeter extends MockableBean2 {\n"
"        @Override\n"
"        public String greet(String name) {\n"
"            return \"Bonjour \" + name;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:828
msgid "As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods"
msgstr "由于注入的实例在这里不可用，我们使用了 `installMockForType` ，这个mock用在于所有两个测试方法中"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:829
msgid "We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method."
msgstr "我们使用 `installMockForInstance` 以取代注入的bean，它在整个测试方法的持续时间内生效。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:832
msgid "Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the objects to provide the behaviour you require."
msgstr "请注意，这里并不依赖Mockito，您可以使用任何您喜欢的mocking库，甚至可以手动覆盖对象以提供您需要的行为。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:836
msgid "Using `@Inject` will get you a CDI proxy to the mock instance you install, which is not suitable for passing to methods such as `Mockito.verify` which want the mock instance itself. So if you need to call methods such as `verify` you need to hang on to the mock instance in your test, or use `@InjectMock` as shown below."
msgstr "使用 `@Inject` ，您会得到一个对您安装的mock实例的CDI代理，它并不适合传递给诸如 `Mockito.verify` 这样的方法，这些方法会需要mock实例本身。因此，如果您需要调用诸如 `verify` 这样的方法，您需要在您的测试中挂载mock实例，或者使用 `@InjectMock` ，如下所示。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:837
#, no-wrap
msgid "Further simplification with `@InjectMock`"
msgstr "使用 `@InjectMock` 进行进一步简化"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:841
msgid "Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectMock` annotation which is available in the `quarkus-junit5-mockito` dependency."
msgstr "基于 `QuarkusMock` 所提供的功能，Quarkus还允许用户很容易地利用 link:https://site.mockito.org/[Mockito] 来mock `QuarkusMock` 所支持的bean。该功能可以通过 `@io.quarkus.test.junit.mockito.InjectMock` 注解来实现，该注解可以通过添加 `quarkus-junit5-mockito` 依赖而导入。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:843
msgid "Using `@InjectMock`, the previous example could be written as follows:"
msgstr "使用 `@InjectMock` ，前面的例子可以写成下面形式："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:851
#, no-wrap
msgid ""
"    @InjectMock\n"
"    MockableBean1 mockableBean1; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:854
#, no-wrap
msgid ""
"    @InjectMock\n"
"    MockableBean2 mockableBean2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:859
#, no-wrap
msgid ""
"    @BeforeEach\n"
"    public void setup() {\n"
"        Mockito.when(mockableBean1.greet(\"Stuart\")).thenReturn(\"A mock for Stuart\"); // <2>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:865
#, no-wrap
msgid ""
"    @Test\n"
"    public void firstTest() {\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(null, mockableBean2.greet(\"Stuart\")); // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:872
#, no-wrap
msgid ""
"    @Test\n"
"    public void secondTest() {\n"
"        Mockito.when(mockableBean2.greet(\"Stuart\")).thenReturn(\"Bonjour Stuart\"); // <4>\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Bonjour Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:889
#, no-wrap
msgid ""
"        public String greet(String name) {\n"
"            return \"Hello \" + name;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:891
msgid "`@InjectMock` results in a mock being and is available in test methods of the test class (other test classes are *not* affected by this)"
msgstr "`@InjectMock` 可以生成一个mock并使其在测试类的所有测试方法中可用（其他测试 类*不受* 此影响）"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:892
msgid "The `mockableBean1` is configured here for every test method of the class"
msgstr "`mockableBean1` 被mockito配置并可以为类的每个测试方法所用"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:893
msgid "Since the `mockableBean2` mock has not been configured, it will return the default Mockito response."
msgstr "由于 `mockableBean2` mock还没有被配置，它将返回默认的Mockito响应。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:894
msgid "In this test the `mockableBean2` is configured, so it returns the configured response."
msgstr "在这个测试中， `mockableBean2` 进行了配置，所以它返回配置好的响应。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:898
msgid "Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test we would most likely configure a mock, but then test a bean that uses the mocked bean.  Here is an example:"
msgstr "尽管上面的测试很好地展示了 `@InjectMock` 的能力，但它并不能很好地表示一个真实的测试案例。在一个真实的测试案例中，我们很可能会配置一个mock，然后测试一个使用了mocked Bean的Bean。下面是一个例子："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:903
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class MockGreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:906
#, no-wrap
msgid ""
"    @InjectMock\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:916
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreeting() {\n"
"        when(greetingService.greet()).thenReturn(\"hi\");\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hi\")); // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:919
#: upstream/_guides/getting-started-testing.adoc:989
#, no-wrap
msgid ""
"    @Path(\"greeting\")\n"
"    public static class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:921
#: upstream/_guides/getting-started-testing.adoc:991
#, no-wrap
msgid "        final GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:925
#: upstream/_guides/getting-started-testing.adoc:995
#, no-wrap
msgid ""
"        public GreetingResource(GreetingService greetingService) {\n"
"            this.greetingService = greetingService;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:932
#: upstream/_guides/getting-started-testing.adoc:1002
#, no-wrap
msgid ""
"        @GET\n"
"        @Produces(\"text/plain\")\n"
"        public String greet() {\n"
"            return greetingService.greet();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:940
#: upstream/_guides/getting-started-testing.adoc:1010
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class GreetingService {\n"
"        public String greet(){\n"
"            return \"hello\";\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:942
msgid "Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean"
msgstr "由于我们将 `greetingService` 配置为一个mock，那么在使用了 `GreetingService` Bean的 `GreetingResource` 中，我们得到的是mock的响应，而不是正常的 `GreetingService` Bean的响应"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:946
msgid "By default, the `@InjectMock` annotation can be used for any normal CDI scoped bean (e.g. `@ApplicationScoped`, `@RequestScoped`).  Mocking `@Singleton` beans can be performed by setting the `convertScopes` property to true (such as `@InjectMock(convertScopes = true`).  This will convert the `@Singleton` bean to an `@ApplicationScoped` bean for the test."
msgstr "默认情况下， `@InjectMock` 注解可用于任何正常的CDI scoped的Bean（例如 `@ApplicationScoped` , `@RequestScoped` ）。如果要mock `@Singleton` Bean则可以通过设置 `convertScopes` 属性为true来达到目的（如 `@InjectMock(convertScopes = true)` ）。这会把 `@Singleton` bean转换为 `@ApplicationScoped` bean来测试。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:948
msgid "This is considered an advanced option and should only be performed if you fully understand the consequences of changing the scope of the bean."
msgstr "这是一个高级选项，只有在您完全了解改变Bean scope的后果时才可以执行。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:949
#, no-wrap
msgid "Using Spies instead of Mocks with `@InjectSpy`"
msgstr "通过 `@InjectSpy` 用Spies来代替Mocks"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:953
msgid "Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency."
msgstr "基于 `InjectMock` 所提供的功能，Quarkus还允许用户很容易利用 link:https://site.mockito.org/[Mockito] 来对 `QuarkusMock` 所支持的bean进行spy操作。这个功能可以通过 `@io.quarkus.test.junit.mockito.InjectSpy` 注解来实现，该注解通过 `quarkus-junit5-mockito` 依赖导入。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:957
msgid "Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito documentation] for more details on Spy partial mocks.  In either of those situations a Spy of the object is preferable.  Using `@InjectSpy`, the previous example could be written as follows:"
msgstr "有时在测试时您只需要验证某个逻辑路径，或者您只想对某一个方法的响应进行stub，同时仍保持执行Spied clone上的其他方法。关于Spy部分mock的更多细节，请参见 link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito文档] 。在这两种情况下，推荐使用针对对象的Spy。使用 `@InjectSpy` ，前面的例子可以写成这样："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:962
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class SpyGreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:965
#, no-wrap
msgid ""
"    @InjectSpy\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:973
#, no-wrap
msgid ""
"    @Test\n"
"    public void testDefaultGreeting() {\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hello\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:976
#, no-wrap
msgid ""
"        Mockito.verify(greetingService, Mockito.times(1)).greet(); <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:986
#, no-wrap
msgid ""
"    @Test\n"
"    public void testOverrideGreeting() {\n"
"        when(greetingService.greet()).thenReturn(\"hi\"); <2>\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hi\")); <3>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1012
msgid "Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test."
msgstr "我们没有覆盖这个值，而只是想确保我们的 `GreetingService` 上的greet方法被这个测试所调用。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1013
msgid "Here we are telling the Spy to return \"hi\" instead of \"hello\". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean"
msgstr "这里我们令Spy返回 \"hi \"而不是 \"hello\"。当 `GreetingResource` 向 `GreetingService` 请求greeting时，我们得到的是mock的响应，而不是正常的 `GreetingService` Bean的响应"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1014
msgid "We are verifying that we get the mocked response from the Spy."
msgstr "这里我们正在验证从Spy那里得到了mock响应。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:1015
#, no-wrap
msgid "Using `@InjectMock` with `@RestClient`"
msgstr "使用 `@InjectMock` 与 `@RestClient`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1018
msgid "The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`."
msgstr "`@RegisterRestClient` 在运行时注册了rest-client的实现，并且由于bean需要保证使用了一个正常的scope，您必须使用 `@ApplicationScoped` 来注释您的接口。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1025
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"@ApplicationScoped\n"
"@RegisterRestClient\n"
"public interface GreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1031
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/hello\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    String hello();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1034
msgid "For the test class here is an example:"
msgstr "对于测试类，这里有一个例子："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1043
#, no-wrap
msgid ""
"    @InjectMock\n"
"    @RestClient // <1>\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1047
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        Mockito.when(greetingService.hello()).thenReturn(\"hello from mockito\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1054
#, no-wrap
msgid ""
"        given()\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello from mockito\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1058
msgid "Indicate that this injection point is meant to use an instance of `RestClient`."
msgstr "这里表示这个注入点使用了 `RestClient` 的实例。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1059
#, no-wrap
msgid "Mocking with Panache"
msgstr "使用Panache mock"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1062
msgid "If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the xref:hibernate-orm-panache.adoc#mocking[Hibernate ORM with Panache Mocking] and xref:mongodb-panache.adoc#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access."
msgstr "如果您使用 `quarkus-hibernate-orm-panache` 或 `quarkus-mongodb-panache` 扩展，请查看 link:hibernate-orm-panache.html#mocking[Hibernate ORM with Panache Mocking] 和 link:mongodb-panache.html#mocking[MongoDB with Panache Mocking] 文档，以了解mock数据访问的最简单方式。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1063
#, no-wrap
msgid "Testing Security"
msgstr "测试安全性"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1066
msgid "If you are using Quarkus Security, check out the xref:security-testing.adoc[Testing Security] section for information on how to easily test security features of the application."
msgstr "如果您正在使用Quarkus Security，请查看 link:security-testing.html[测试安全] 部分，了解如何轻松测试应用程序的安全功能。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1068
#, no-wrap
msgid "Starting services before the Quarkus application starts"
msgstr "在Quarkus应用程序启动之前启动服务"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1071
msgid "A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."
msgstr "一个很常见的需求是在Quarkus应用程序启动测试之前，启动一些您的Quarkus应用程序所依赖的服务。为了解决这个需求，Quarkus提供了 `@io.quarkus.test.common.QuarkusTestResource` 和 `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1074
msgid "By simply annotating any test in the test suite with `@QuarkusTestResource`, Quarkus will run the corresponding `QuarkusTestResourceLifecycleManager` before any tests are run.  A test suite is also free to utilize multiple `@QuarkusTestResource` annotations, in which case all the corresponding `QuarkusTestResourceLifecycleManager` objects will be run before the tests. When using multiple test resources they can be started concurrently. For that you need to set `@QuarkusTestResource(parallel = true)`."
msgstr "通过简单地在测试套件中用 `@QuarkusTestResource` 注释测试，Quarkus将在测试运行之前运行相应的 `QuarkusTestResourceLifecycleManager` 。测试套件也可以自由地利用多个 `@QuarkusTestResource` 注释，从而使所有对应的 `QuarkusTestResourceLifecycleManager` 对象在测试前运行。当使用多个测试资源时，它们可以并行启动。为此，您需要设置 `@QuarkusTestResource(parallel = true)` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1077
msgid "Test resources are global, even if they are defined on a test class or custom profile, which means they will all be activated for all tests, even though we do remove duplicates. If you want to only enable a test resource on a single test class or test profile, you can use `@QuarkusTestResource(restrictToAnnotatedClass = true)`."
msgstr "测试资源是全局性的，即使它们被定义在一个测试类或自定义profile上，这意味着它们将全部被激活从而用于所有的测试，尽管我们删除了重复的测试。如果您只想针对一个测试类或测试profile启用某一个测试资源，您可以使用 `@QuarkusTestResource(restrictToAnnotatedClass = true)` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1082
msgid "Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[here]), or starting a mock HTTP server using https://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here])."
msgstr "Quarkus提供了一些开箱即用的 `QuarkusTestResourceLifecycleManager` （见 `io.quarkus.test.h2.H2DatabaseTestResource` ，它启动了一个H2数据库；或 `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` ，它启动了一个模拟的Kubernetes API服务器），但创建自定义的实现来满足特定的应用需求也是很常见的。常见的情况包括使用 link:https://www.testcontainers.org/[Testcontainers] 启动docker容器（例子 link:https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[见这里] ），或使用 link:http://wiremock.org/[Wiremock] 启动一个模拟的HTTP服务器（例子 link:https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[见这里] ）。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1084
msgid "Altering the test class"
msgstr "改动测试类"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1087
msgid "When creating a custom `QuarkusTestResourceLifecycleManager` that needs to inject the something into the test class, the `inject` methods can be used.  If for example you have a test like the following:"
msgstr "当创建一个自定义的 `QuarkusTestResourceLifecycleManager` 来将某些资源注入到测试类时，可以使用 `inject` 方法。例如，如果您有一个像下面这样的测试："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1093
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(MyWireMockResource.class)\n"
"public class MyTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1096
#, no-wrap
msgid ""
"    @InjectWireMock // this a custom annotation you are defining in your own application\n"
"    WireMockServer wireMockServer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1102
#, no-wrap
msgid ""
"    @Test\n"
"    public someTest() {\n"
"        // control wiremock in some way and perform test\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1105
msgid "Making `MyWireMockResource` inject the `wireMockServer` field can be done as shown in the `inject` method of the following code snippet:"
msgstr "为了使 `MyWireMockResource` 注入 `wireMockServer` 字段，可按以下代码片断中的 `inject` 方法进行："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1109
#, no-wrap
msgid "public class MyWireMockResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1111
#, no-wrap
msgid "    WireMockServer wireMockServer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1116
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        wireMockServer = new WireMockServer(8090);\n"
"        wireMockServer.start();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1118
#, no-wrap
msgid "        // create some stubs\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1121
#, no-wrap
msgid ""
"        return Map.of(\"some.service.url\", \"localhost:\" + wireMockServer.port());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1129
#, no-wrap
msgid ""
"    @Override\n"
"    public synchronized void stop() {\n"
"        if (wireMockServer != null) {\n"
"            wireMockServer.stop();\n"
"            wireMockServer = null;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1135
#, no-wrap
msgid ""
"    @Override\n"
"    public void inject(TestInjector testInjector) {\n"
"        testInjector.injectIntoFields(wireMockServer, new TestInjector.AnnotatedAndMatchesType(InjectWireMock.class, WireMockServer.class));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1139
msgid "It is worth mentioning that this injection into the test class is not under the control of CDI and happens after CDI has performed any necessary injections into the test class."
msgstr "值得一提的是，这种对测试类的注入并不在CDI的控制之下，而是发生在CDI对测试类进行了所有必要的注入之后。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1140
#, no-wrap
msgid "Annotation-based test resources"
msgstr "基于注解的测试资源"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1144
msgid "It is possible to write test resources that are enabled and configured using annotations. This is enabled by placing the `@QuarkusTestResource` on an annotation which will be used to enable and configure the test resource."
msgstr "我们也可以编写使用注解来启用和配置的测试资源。这可以通过在一个注解上使用 `@QuarkusTestResource` 来启用，该注解将被用来启用和配置测试资源。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1147
msgid "For example, this defines the `@WithKubernetesTestServer` annotation, which you can use on your tests to activate the `KubernetesServerTestResource`, but only for the annotated test class. You can also place them on your `QuarkusTestProfile` test profiles."
msgstr "例如，下面代码定义了 `@WithKubernetesTestServer` 注释，您可以在您的测试上使用它来激活 `KubernetesServerTestResource` ，但只针对被注释的测试类。您也可以把它们加入到您的 `QuarkusTestProfile` 测试profile中。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1158
#, no-wrap
msgid ""
"@QuarkusTestResource(KubernetesServerTestResource.class)\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target(ElementType.TYPE)\n"
"public @interface WithKubernetesTestServer {\n"
"    /**\n"
"     * Start it with HTTPS\n"
"     */\n"
"    boolean https() default false;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1163
#, no-wrap
msgid ""
"    /**\n"
"     * Start it in CRUD mode\n"
"     */\n"
"    boolean crud() default true;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1169
#, no-wrap
msgid ""
"    /**\n"
"     * Port to use, defaults to any available port\n"
"     */\n"
"    int port() default 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1173
msgid "The `KubernetesServerTestResource` class has to implement the `QuarkusTestResourceConfigurableLifecycleManager` interface in order to be configured using the previous annotation:"
msgstr "`KubernetesServerTestResource` 类必须实现 `QuarkusTestResourceConfigurableLifecycleManager` 接口，以便使用前面的注解进行配置："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1178
#, no-wrap
msgid ""
"public class KubernetesServerTestResource\n"
"        implements QuarkusTestResourceConfigurableLifecycleManager<WithKubernetesTestServer> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1182
#, no-wrap
msgid ""
"    private boolean https = false;\n"
"    private boolean crud = true;\n"
"    private int port = 0;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1189
#, no-wrap
msgid ""
"    @Override\n"
"    public void init(WithKubernetesTestServer annotation) {\n"
"        this.https = annotation.https();\n"
"        this.crud = annotation.crud();\n"
"        this.port = annotation.port();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1192
#, no-wrap
msgid ""
"    // ...\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1194
#, no-wrap
msgid "Hang Detection"
msgstr "挂起侦测"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1199
msgid "`@QuarkusTest` has support for hang detection to help diagnose any unexpected hangs. If no progress is made for a specified time (i.e. no JUnit callbacks are invoked) then Quarkus will print a stack trace to the console to help diagnose the hang.  The default value for this timeout is 10 minutes."
msgstr "`@QuarkusTest` 支持挂起侦测，以帮助诊断任何意外的挂起。如果在指定的时间内没有进展（即没有调用JUnit回调），那么Quarkus将打印一个堆栈跟踪到控制台以帮助诊断挂起。这个超时的默认值是10分钟。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1204
msgid "No further action will be taken, and the tests will continue as normal (generally until CI times out), however the printed stack traces should help diagnose why the build has failed. You can control this timeout with the `quarkus.test.hang-detection-timeout` system property (you can also set this in application.properties, but this won't be read until Quarkus has started, so the timeout for Quarkus start will be the default of 10 minutes)."
msgstr "不会有进一步的动作执行，测试将继续正常进行（通常直到CI超时），但是打印出来的堆栈信息应该有助于诊断为什么构建失败了。您可以用 `quarkus.test.hang-detection-timeout` 系统属性来控制这个超时值（您也可以在application.properties中设置这个值，但是在Quarkus启动之前它不会被读取，所以Quarkus启动的默认超时时间将是10分钟）。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1205
#, no-wrap
msgid "Native Executable Testing"
msgstr "本地可执行程序测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1209
msgid "It is also possible to test native executables using `@QuarkusIntegrationTest`. This supports all the features mentioned in this guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible)."
msgstr "您也可以使用 `@QuarkusIntegrationTest` 来测试本地可执行文件。除了注入测试（本地可执行文件在一个单独的非JVM进程中运行，所以它实际上是不可能做到的）以外，该特性支持本指南中提到的所有功能。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1212
msgid "This is covered in the xref:building-native-image.adoc[Native Executable Guide]."
msgstr "这在《 link:building-native-image.html[本地可执行文件指南》] 中有所涉及。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1214
#, no-wrap
msgid "Using `@QuarkusIntegrationTest`"
msgstr "使用@QuarkusIntegrationTest"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1221
msgid "`@QuarkusIntegrationTest` should be used to launch and test the artifact produced by the Quarkus build, and supports testing a jar (of whichever type), a native image or container image.  Put simply, this means that if the result of a Quarkus build (`mvn package` or `gradle build`) is a jar, that jar will be launched as `java -jar ...` and tests run against it.  If instead a native image was built, then the application is launched as `./application ...` and again the tests run against the running application.  Finally, if a container image was created during the build (by including the `quarkus-container-image-jib` or `quarkus-container-image-docker` extensions and having the `quarkus.container-image.build=true` property configured), then a container is created and run (this requires the `docker` executable being present)."
msgstr "`@QuarkusIntegrationTest` 应该被用来启动和测试由Quarkus构建产生的物件，而且支持测试一个jar（无论哪种类型），一个本地镜像或容器镜像。简单地说，这意味着如果Quarkus构建（ `mvn package` 或者 `gradle build`）的结果是一个jar，这个jar将以 `java -jar ...` 方式启动 ，并针对它运行测试。如果构建的是一个本地镜像，那么应用程序将以 `./application ...` 方式启动，并再次针对运行中的应用程序进行测试。最后，如果在构建过程中创建了一个容器镜像（通过引入 `quarkus-container-image-jib` 或 `quarkus-container-image-docker` 扩展并使用了 `quarkus.container-image.build=true` 属性），那么将创建并运行一个容器（这需要 `docker` 可执行文件的存在）。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1223
msgid "As is the case with `@NativeImageTest`, this is a black box test that supports the same set features and has the same limitations."
msgstr "如同 `@NativeImageTest` ，这是一个黑盒测试，支持相同的功能集且具有相同的限制。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1228
msgid "As a test annotated with `@QuarkusIntegrationTest` tests the result of the build, it should be run as part of the integration test suite - i.e. by setting `-DskipITs=false` if using Maven or the `quarkusIntTest` task if using Gradle.  These tests will **not** work if run in the same phase as `@QuarkusTest` as Quarkus has not yet created the final artifact."
msgstr "由于用 `@QuarkusIntegrationTest` 注释的测试是对构建结果的测试，它应该作为集成测试套件的一部分来运行--即如果使用Maven，则设置 `-DskipITs=false`，而如果使用Gradle，则通过 `quarkusIntTest` 任务。如果与 `@QuarkusTest` 在同一阶段运行，这些测试将 *无法* 工作，因为Quarkus还没有产生出最终的artifact。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1231
msgid "The `pom.xml` file contains:"
msgstr "`pom.xml` 文件包括："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1254
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>org.apache.maven.plugins</groupId>\n"
"    <artifactId>maven-failsafe-plugin</artifactId>\n"
"    <version>${surefire-plugin.version}</version>\n"
"    <executions>\n"
"        <execution>\n"
"            <goals>\n"
"                <goal>integration-test</goal>\n"
"                <goal>verify</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <systemPropertyVariables>\n"
"                    <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>\n"
"                    <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"                    <maven.home>${maven.home}</maven.home>\n"
"                </systemPropertyVariables>\n"
"            </configuration>\n"
"        </execution>\n"
"    </executions>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1257
msgid "This instructs the failsafe-maven-plugin to run integration-test."
msgstr "这将通知failsafe-maven-plugin去运行继承测试。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1259
msgid "Then, open the `src/test/java/org/acme/quickstart/GreetingResourceIT.java`. It contains:"
msgstr "然后，打开 `src/test/java/org/acme/quickstart/GreetingResourceIT.java` 。它包含了："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1263
#, no-wrap
msgid "package org.acme.quickstart;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1266
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusIntegrationTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1269
#, no-wrap
msgid ""
"@QuarkusIntegrationTest // <1>\n"
"public class GreetingResourceIT extends GreetingResourceTest { // <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1271
#, no-wrap
msgid "    // Run the same tests\n"
msgstr "    // 运行相同测试\n"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1276
msgid "Use another test runner that starts the application from the native file before the tests.  The executable is retrieved by the _Failsafe Maven Plugin_."
msgstr "这里使用另一个测试runner来通过本地文件在测试之前启动应用。该执行文件通过  _Failsafe Maven Plugin_ 来获取。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1277
msgid "We extend our previous tests as a convenience, but you can also implement your tests."
msgstr "为了方便起见，我们扩展了之前的测试，但您也可以实现您自己的测试。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1279
msgid "More information can be found in the link:building-native-image#testing-the-native-executable[Testing the native executable Guide]."
msgstr "更多的信息可以在 link:building-native-image#testing-the-native-executable[Testing the native executable Guide] 里找到。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1280
#, no-wrap
msgid "Launching containers"
msgstr "启动容器"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1285
msgid "When `@QuarkusIntegrationTest` results in launching a container (because the application was built with `quarkus.container-image.build` set to `true`), the container is launched on a predictable container network. This facilitates writing integration tests that need to launch services to support the application.  This means that `@QuarkusIntegrationTest` works out of the box with containers launched via xref:dev-services.adoc[Dev Services], but it also means that it enables using <<quarkus-test-resource,QuarkusTestLifecycleManager>> resources that launch additional containers.  This can be achieved by having your `QuarkusTestLifecycleManager` implement `io.quarkus.test.common.DevServicesContext.ContextAware`. A simple example could be the following:"
msgstr "当 `@QuarkusIntegrationTest` 启动一个容器时（因为应用程序在构建时将 `quarkus.container-image.build` 设置为 `true` ），该容器会在一个可预测的容器网络上启动。这有利于编写需要启动服务以支持应用程序的集成测试。这意味着 `@QuarkusIntegrationTest` 能够与通过 link:dev-services.html[Dev Services] 启动的容器一起开箱即用，但这也意味着它能够使用 link:#quarkus-test-resource[QuarkusTestLifecycleManager] 资源来启动额外的容器。这可以通过让您的 `QuarkusTestLifecycleManager` 实现 `io.quarkus.test.common.DevServicesContext.ContextAware` 来获得。一个简单的例子："

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1289
msgid "The container running the resource to test against, for example PostgreSQL via Testcontainers, is assigned an IP address from the container's network.  Use the container's \"public\" IP from its network and the \"unmapped\" port number to connect to the service.  The Testcontainers library usually return connection strings without respecting the container network, so additional code is needed to provide Quarkus the \"correct\" connection string using the container's IP on the container network and the _unmapped_ port number."
msgstr "运行要测试资源的容器，例如通过Testcontainers启用的PostgreSQL，会从容器的网络中分配到一个IP地址。使用容器网络中的 \"公共 \"IP和 \"未映射 \"的端口号来连接到服务。Testcontainers库通常在不遵从容器网络规则的情况下返回连接字符串，所以需要额外的代码来为Quarkus提供 \"正确的 \"连接字符串，以使用容器网络中的IP和 _未映射_ 的端口号。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1291
msgid "The following example illustrates the use with PostgreSQL, but the approach is applicable to all containers."
msgstr "下面的例子展示了在PostgreSQL上的使用，但这个方法也适用于所有的容器。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1296
#, no-wrap
msgid ""
"import io.quarkus.test.common.DevServicesContext;\n"
"import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1299
#, no-wrap
msgid ""
"import org.testcontainers.containers.JdbcDatabaseContainer;\n"
"import org.testcontainers.containers.PostgreSQLContainer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1303
#, no-wrap
msgid ""
"import java.util.HashMap;\n"
"import java.util.Map;\n"
"import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1305
#, no-wrap
msgid "public class CustomResource implements QuarkusTestResourceLifecycleManager, DevServicesContext.ContextAware {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1308
#, no-wrap
msgid ""
"    private Optional<String> containerNetworkId;\n"
"    private JdbcDatabaseContainer container;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1313
#, no-wrap
msgid ""
"    @Override\n"
"    public void setIntegrationTestContext(DevServicesContext context) {\n"
"        containerNetworkId = context.containerNetworkId();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1318
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        // start a container making sure to call withNetworkMode() with the value of containerNetworkId if present\n"
"        container = new PostgreSQLContainer<>(\"postgres:latest\").withLogConsumer(outputFrame -> {});\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1321
#, no-wrap
msgid ""
"        // apply the network to the container\n"
"        containerNetworkId.ifPresent(container::withNetworkMode);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1324
#, no-wrap
msgid ""
"        // start container before retrieving its URL or other properties\n"
"        container.start();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1331
#, no-wrap
msgid ""
"        String jdbcUrl = container.getJdbcUrl();\n"
"        if (containerNetworkId.isPresent()) {\n"
"            // Replace hostname + port in the provided JDBC URL with the hostname of the Docker container\n"
"            // running PostgreSQL and the listening port.\n"
"            jdbcUrl = fixJdbcUrl(jdbcUrl);\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1338
#, no-wrap
msgid ""
"        // return a map containing the configuration the application needs to use the service\n"
"        return ImmutableMap.of(\n"
"            \"quarkus.datasource.username\", container.getUsername(),\n"
"            \"quarkus.datasource.password\", container.getPassword(),\n"
"            \"quarkus.datasource.jdbc.url\", jdbcUrl);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1342
#, no-wrap
msgid ""
"    private String fixJdbcUrl(String jdbcUrl) {\n"
"        // Part of the JDBC URL to replace\n"
"        String hostPort = container.getHost() + ':' + container.getMappedPort(PostgreSQLContainer.POSTGRESQL_PORT);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1348
#, no-wrap
msgid ""
"        // Host/IP on the container network plus the unmapped port\n"
"        String networkHostPort =\n"
"            container.getCurrentContainerInfo().getConfig().getHostName()\n"
"            + ':'\n"
"            + PostgreSQLContainer.POSTGRESQL_PORT;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1351
#, no-wrap
msgid ""
"        return jdbcUrl.replace(hostPort, networkHostPort);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1357
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        // close container\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1360
msgid "`CustomResource` would be activated on a `@QuarkusIntegrationTest` using `@QuarkusTestResource` as is described in the corresponding section of this doc."
msgstr "`CustomResource` 将在 `@QuarkusIntegrationTest` 上通过使用 `@QuarkusTestResource` 激活，就如本文档对应部分所述。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1361
#, no-wrap
msgid "Executing against a running application"
msgstr "对正在运行的应用程序执行测试"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1366
msgid "This feature is considered experimental and is likely to change in future versions of Quarkus."
msgstr "这个功能是实验性的，在未来的Quarkus版本中可能会有变化。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1370
msgid "`@QuarkusIntegrationTest` supports executing tests against an already running instance of the application. This can be achieved by setting the `quarkus.http.test-host` system property when running the tests."
msgstr "`@QuarkusIntegrationTest` 支持对已经在运行的应用程序实例执行测试。这可以通过在运行测试时设置 `quarkus.http.test-host` 属性来实现。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1372
msgid "An example use of this could be the following Maven command, that forces `@QuarkusIntegrationTest` to execute against that is accessible at `http://1.2.3.4:4321`:"
msgstr "这方面的一个例子是下面的Maven命令，该命令强制 `@QuarkusIntegrationTest` 对位于 `link:http://1.2.3.4:4321[http://1.2.3.4:4321]` 节点执行测试 :"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1376
#, no-wrap
msgid "./mvnw verify -Dquarkus.http.test-host=1.2.3.4 -Dquarkus.http.test-port=4321\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1379
#, no-wrap
msgid "Mixing `@QuarkusTest` with other type of tests"
msgstr "混合使用 `@QuarkusTest` 与其他类型的测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1384
msgid "Mixing tests annotated with `@QuarkusTest` with tests annotated with either `@QuarkusDevModeTest`, `@QuarkusProdModeTest` or `@QuarkusUnitTest` is not allowed in a single execution run (in a single Maven Surefire Plugin execution, for instance), while the latter three can coexist."
msgstr "在一次执行中（例如在一次Maven Surefire Plugin执行中），将注释为 `@QuarkusTest` 的测试与注释为 `@QuarkusDevModeTest` 、 `@QuarkusProdModeTest` 或 `@QuarkusUnitTest` 的测试混合执行是不被允许的，但是后三者可以共存。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1387
msgid "The reason of this restriction is that `@QuarkusTest` starts a Quarkus server for the whole lifetime of the tests execution run, thus preventing the other tests to start their own Quarkus server."
msgstr "这个限制的原因是 `@QuarkusTest` 会在测试执行的整个生命周期内启动一个Quarkus服务器，从而防止其他测试启动自己的Quarkus服务器。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1390
msgid "To alleviate this restriction, the `@QuarkusTest` annotation defines a JUnit 5 `@Tag`: `io.quarkus.test.junit.QuarkusTest`.  You can use this tag to isolate the `@QuarkusTest` test in a specific execution run, for example with the Maven Surefire Plugin:"
msgstr "为缓解这一限制， `@QuarkusTest` 注解定义了一个 JUnit 5 的 `@Tag` : `io.quarkus.test.junit.QuarkusTest` 。您可以使用该标记在特定的执行中隔离 `@QuarkusTest` 测试，例如使用Maven Surefire插件："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1422
#, no-wrap
msgid ""
"<plugin>\n"
"    <artifactId>maven-surefire-plugin</artifactId>\n"
"    <version>${surefire-plugin.version}</version>\n"
"    <executions>\n"
"        <execution>\n"
"            <id>default-test</id>\n"
"            <goals>\n"
"                <goal>test</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <excludedGroups>io.quarkus.test.junit.QuarkusTest</excludedGroups>\n"
"            </configuration>\n"
"        </execution>\n"
"        <execution>\n"
"            <id>quarkus-test</id>\n"
"            <goals>\n"
"                <goal>test</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <groups>io.quarkus.test.junit.QuarkusTest</groups>\n"
"            </configuration>\n"
"        </execution>\n"
"    </executions>\n"
"    <configuration>\n"
"        <systemProperties>\n"
"            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"        </systemProperties>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1425
#, no-wrap
msgid "Running `@QuarkusTest` from an IDE"
msgstr "从IDE中运行 `@QuarkusTest`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1428
msgid "Most IDEs offer the possibility to run a selected class as a JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:"
msgstr "大多数IDE都提供了将选定的类直接作为JUnit测试运行的可能性。为了做到这点，您需要在您选择的IDE的设置中设置一些属性："

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1430
msgid "`java.util.logging.manager` (see xref:logging.adoc[Logging Guide])"
msgstr "`java.util.logging.manager` (见 link:logging.html[日志指南] )"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1432
msgid "`maven.home` (only if there are any custom settings in `${maven.home}/conf/settings.xml`, see xref:maven-tooling.adoc[Maven Guide])"
msgstr "`maven.home` (仅当 `${maven.home}/conf/settings.xml` 中有自定义设置时，见link:maven-tooling.html[Maven指南] )"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1434
msgid "`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)"
msgstr "`maven.settings` (以备在测试中使用自定义的 `settings.xml` 文件)"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1435
#, no-wrap
msgid "Eclipse separate JRE definition"
msgstr "Eclipse中独立的JRE定义"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1438
msgid "Copy your current \"Installed JRE\" definition into a new one, where you will add the properties as a new VM arguments:"
msgstr "将您当前的 \"已安装的JRE \"定义复制为一个新的定义，在这里您会将其作为新的虚拟机参数配置来添加属性："

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1440
msgid "`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1442
msgid "`-Dmaven.home=<path-to-your-maven-installation>`"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1444
msgid "Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any \"Run as JUnit\" configuration."
msgstr "使用这个JRE定义作为您的Quarkus项目的目标运行时，该运行时将被用于所有 \"作为JUnit运行(Run as JUnit) \"的配置。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1445
#, no-wrap
msgid "VSCode \"run with\" configuration"
msgstr "VSCode \"run with \"配置"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1448
msgid "The `settings.json` placed in the root of your project directory or in the workspace will need the following workaround in your test configuration:"
msgstr "在您的项目根目录或工作区的 `settings.json` 文件中，针对测试配置添加以下配置项目："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1458
#, no-wrap
msgid ""
"\"java.test.config\": [\n"
"    {\n"
"        \"name\": \"quarkusConfiguration\",\n"
"        \"vmargs\": [ \"-Djava.util.logging.manager=org.jboss.logmanager.LogManager -Dmaven.home=<path-to-your-maven-installation> ...\" ],\n"
"        ...\n"
"    },\n"
"  ...\n"
"]\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1460
#, no-wrap
msgid "IntelliJ IDEA JUnit template"
msgstr "IntelliJ IDEA JUnit模板"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1463
msgid "Nothing needed in IntelliJ IDEA because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`."
msgstr "在IntelliJ中不需要任何改动，因为IDE会从 `pom.xml` 中的surefire插件配置中选择 `systemPropertyVariables` 。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1464
#, no-wrap
msgid "Testing Dev Services"
msgstr "测试开发服务"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1468
msgid "By default, tests should just work with xref:dev-services.adoc[Dev Services], however from some use cases you may need access to the automatically configured properties in your tests."
msgstr "默认情况下，测试应该只与 link:dev-services.html[开发服务] 一起工作，然而在一些用例中，您可能需要访问测试中自动配置的属性。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1473
msgid "You can do this with `io.quarkus.test.common.DevServicesContext`, which can be injected directly into any `@QuarkusTest` or `@QuarkusIntegrationTest`. All you need to do is define a field of type `DevServicesContext` and it will be automatically injected. Using this you can retrieve any properties that have been set. Generally this is used to directly connect to a resource from the test itself, e.g. to connect to kafka to send messages to the application under test."
msgstr "您可以使用 `io.quarkus.test.common.DevServicesContext` 来达到目的，它可以直接注入到任何 `@QuarkusTest` 或 `@QuarkusIntegrationTest` 中。您所需要做的就是定义一个类型为 `DevServicesContext` 的字段，然后它就会自动被注入。使用该方法，您可以检索到任何已经设置的属性。一般来说，这被用来直接连接到测试本身的资源，例如，连接到kafka来发送消息到被测试的应用程序。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1478
msgid "Injection is also supported into objects that implement `io.quarkus.test.common.DevServicesContext.ContextAware`. If you have a field that implements `io.quarkus.test.common.DevServicesContext.ContextAware` Quarkus will call the `setIntegrationTestContext` method to pass the context into this object. This allows client logic to be encapsulated in a utility class."
msgstr "该注入也支持在实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的对象中。如果您有一个实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的字段，Quarkus将调用 `setIntegrationTestContext` 方法来将上下文传入这个对象中。这将允许客户端逻辑被允许封装在一个实用类中。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1481
msgid "`QuarkusTestResourceLifecycleManager` implementations can also implement `ContextAware` to get access to these properties, which allows you to set up the resource before Quarkus starts (e.g. configure a KeyCloak instance, add data to a database etc)."
msgstr "`QuarkusTestResourceLifecycleManager` 实现也可以实现 `ContextAware` 接口，以获得对这些属性的访问，这允许您在Quarkus启动之前来配置资源（例如，配置一个KeyCloak实例，向数据库添加数据等）。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1487
msgid "For `@QuarkusIntegrationTest` tests that result in launcher the application as a container, `io.quarkus.test.common.DevServicesContext` also provides access to the id of the container network on which the application container was launched (via the `containerNetworkId` method).  This can be used by `QuarkusTestResourceLifecycleManager` that need to launch additional containers that the application will communicate with."
msgstr "对于将应用程序作为容器启动的 `@QuarkusIntegrationTest` 测试，`io.quarkus.test.common.DevServicesContext` 也提供了对应用容器所启动的容器网络id的访问(通过 `containerNetworkId` 方法)。这可以被 `QuarkusTestResourceLifecycleManager` 使用来启动一些应用程序需要通信的其他容器。"
