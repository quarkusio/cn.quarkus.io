# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/mongodb.adoc:6
#, fuzzy, no-wrap
msgid "Using the MongoDB Client"
msgstr "使用MongoDB客户端"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:10
#, fuzzy
msgid "MongoDB is a well known NoSQL Database that is widely used."
msgstr "MongoDB是一个众所周知的NoSQL数据库，被广泛使用。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:12
#, fuzzy
msgid "In this guide, we see how you can get your REST services to use the MongoDB database."
msgstr "在本指南中，我们看到如何让你的REST服务使用MongoDB数据库。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:13
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:17
#, fuzzy
msgid "MongoDB installed or Docker installed"
msgstr "安装了MongoDB或安装了Docker"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:18
#, fuzzy, no-wrap
msgid "Architecture"
msgstr "建筑学"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:21
#, fuzzy
msgid "The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated."
msgstr "本指南中构建的应用程序非常简单：用户可以使用一个表单在列表中添加元素，然后列表被更新。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:23
#, fuzzy
msgid "All the information between the browser and the server is formatted as JSON."
msgstr "浏览器和服务器之间的所有信息都被格式化为JSON。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:25
#, fuzzy
msgid "The elements are stored in MongoDB."
msgstr "这些元素被存储在MongoDB中。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:26
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:30
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。然而，你可以直接进入已完成的例子。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:32
#, fuzzy
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库。 `git clone {quickstarts-clone-url}` ，或者下载一个{quickstarts-archive-url}[存档]。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:34
#, fuzzy
msgid "The solution is located in the `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[directory]."
msgstr "该解决方案位于 `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[目录]中。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:35
#, fuzzy, no-wrap
msgid "Creating the Maven project"
msgstr "创建Maven项目"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:38
#, fuzzy
msgid "First, we need a new project. Create a new project with the following command:"
msgstr "首先，我们需要一个新的项目。用以下命令创建一个新项目。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:45
#, fuzzy
msgid "This command generates a Maven structure importing the RESTEasy Reactive Jackson and MongoDB Client extensions.  After this, the `quarkus-mongodb-client` extension has been added to your build file."
msgstr "该命令生成一个Maven结构，导入RESTEasy Reactive Jackson和MongoDB客户端扩展。在此之后， `quarkus-mongodb-client` 扩展已被添加到您的构建文件中。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:48
#, fuzzy
msgid "If you already have your Quarkus project configured, you can add the `mongodb-client` extension to your project by running the following command in your project base directory:"
msgstr "如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `mongodb-client` 扩展到你的项目。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:53
#, fuzzy
msgid "This will add the following to your `pom.xml`:"
msgstr "这将在你的 `pom.xml` 中添加以下内容。"

#. type: Block title
#: upstream/_guides/mongodb.adoc:55 upstream/_guides/mongodb.adoc:639
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:61
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-mongodb-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/mongodb.adoc:64 upstream/_guides/mongodb.adoc:648
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:67
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-mongodb-client\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/mongodb.adoc:69
#, fuzzy, no-wrap
msgid "Creating your first JSON REST service"
msgstr "创建你的第一个JSON REST服务"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:72
#, fuzzy
msgid "In this example, we will create an application to manage a list of fruits."
msgstr "在这个例子中，我们将创建一个应用程序来管理一个水果列表。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:74
#, fuzzy
msgid "First, let's create the `Fruit` bean as follows:"
msgstr "首先，让我们创建 `Fruit` bean，如下所示。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:78 upstream/_guides/mongodb.adoc:144
#: upstream/_guides/mongodb.adoc:349 upstream/_guides/mongodb.adoc:393
#: upstream/_guides/mongodb.adoc:539
#, no-wrap
msgid "package org.acme.mongodb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:80
#, no-wrap
msgid "import java.util.Objects;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:82
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:86
#, no-wrap
msgid ""
"    private String name;\n"
"    private String description;\n"
"    private String id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:89
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:94
#, no-wrap
msgid ""
"    public Fruit(String name, String description) {\n"
"        this.name = name;\n"
"        this.description = description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:98
#, no-wrap
msgid ""
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:102
#, no-wrap
msgid ""
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:106
#, no-wrap
msgid ""
"    public String getDescription() {\n"
"        return description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:110
#, no-wrap
msgid ""
"    public void setDescription(String description) {\n"
"        this.description = description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:116
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean equals(Object obj) {\n"
"        if (!(obj instanceof Fruit)) {\n"
"            return false;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:118
#, no-wrap
msgid "        Fruit other = (Fruit) obj;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:121
#, no-wrap
msgid ""
"        return Objects.equals(other.name, this.name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:126
#, no-wrap
msgid ""
"    @Override\n"
"    public int hashCode() {\n"
"        return Objects.hash(this.name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:130
#, no-wrap
msgid ""
"    public void setId(String id) {\n"
"        this.id = id;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:135
#, no-wrap
msgid ""
"    public String getId() {\n"
"        return id;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:138
#, fuzzy
msgid "Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer."
msgstr "没有什么花哨的。需要注意的一件事是，拥有一个默认的构造函数是JSON序列化层的要求。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:140
#, fuzzy
msgid "Now create a `org.acme.mongodb.FruitService` that will be the business layer of our application and store/load the fruits from the mongoDB database."
msgstr "现在创建一个 `org.acme.mongodb.FruitService` ，它将是我们应用程序的业务层，并从mongoDB数据库存储/加载水果。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:149
#, no-wrap
msgid ""
"import com.mongodb.client.MongoClient;\n"
"import com.mongodb.client.MongoCollection;\n"
"import com.mongodb.client.MongoCursor;\n"
"import org.bson.Document;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:154 upstream/_guides/mongodb.adoc:548
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import java.util.ArrayList;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:157
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:159 upstream/_guides/mongodb.adoc:553
#, no-wrap
msgid "    @Inject MongoClient mongoClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:163
#, no-wrap
msgid ""
"    public List<Fruit> list(){\n"
"        List<Fruit> list = new ArrayList<>();\n"
"        MongoCursor<Document> cursor = getCollection().find().iterator();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:177
#, no-wrap
msgid ""
"        try {\n"
"            while (cursor.hasNext()) {\n"
"                Document document = cursor.next();\n"
"                Fruit fruit = new Fruit();\n"
"                fruit.setName(document.getString(\"name\"));\n"
"                fruit.setDescription(document.getString(\"description\"));\n"
"                list.add(fruit);\n"
"            }\n"
"        } finally {\n"
"            cursor.close();\n"
"        }\n"
"        return list;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:184
#, no-wrap
msgid ""
"    public void add(Fruit fruit){\n"
"        Document document = new Document()\n"
"                .append(\"name\", fruit.getName())\n"
"                .append(\"description\", fruit.getDescription());\n"
"        getCollection().insertOne(document);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:189
#, no-wrap
msgid ""
"    private MongoCollection getCollection(){\n"
"        return mongoClient.getDatabase(\"fruit\").getCollection(\"fruit\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:192
#, fuzzy
msgid "Now, create the `org.acme.mongodb.FruitResource` class as follows:"
msgstr "现在，创建 `org.acme.mongodb.FruitResource` 类，如下所示。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:197
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:199
#, no-wrap
msgid "    @Inject FruitService fruitService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:204
#, no-wrap
msgid ""
"    @GET\n"
"    public List<Fruit> list() {\n"
"        return fruitService.list();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:211
#, no-wrap
msgid ""
"    @POST\n"
"    public List<Fruit> add(Fruit fruit) {\n"
"        fruitService.add(fruit);\n"
"        return list();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:214
#, fuzzy
msgid "The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitService` to list/add new fruits."
msgstr "实现起来非常简单，你只需要使用JAX-RS注解来定义你的端点，并使用 `FruitService` 来列出/添加新的水果。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:215
#, fuzzy, no-wrap
msgid "Configuring the MongoDB database"
msgstr "配置MongoDB数据库"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:217
#, fuzzy
msgid "The main property to configure is the URL to access to MongoDB, almost all configuration can be included in the connection URI so we advise you to do so, you can find more information in the MongoDB documentation: https://docs.mongodb.com/manual/reference/connection-string/"
msgstr "要配置的主要属性是访问MongoDB的URL，几乎所有的配置都可以包含在连接URI中，所以我们建议你这样做，你可以在MongoDB文档中找到更多信息 https://docs.mongodb.com/manual/reference/connection-string/ "

#. type: Plain text
#: upstream/_guides/mongodb.adoc:219
#, fuzzy
msgid "A sample configuration should look like this:"
msgstr "一个配置样本应该是这样的。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:224
#, no-wrap
msgid ""
"# configure the mongoDB client for a replica set of two nodes\n"
"quarkus.mongodb.connection-string = mongodb://mongo1:27017,mongo2:27017\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:227
#, fuzzy
msgid "In this example, we are using a single instance running on localhost:"
msgstr "在这个例子中，我们使用的是一个运行在localhost上的单一实例。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:232
#, no-wrap
msgid ""
"# configure the mongoDB client for a single instance on localhost\n"
"quarkus.mongodb.connection-string = mongodb://localhost:27017\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:235
#, fuzzy
msgid "If you need more configuration properties, there is a full list at the end of this guide."
msgstr "如果你需要更多的配置属性，在本指南的末尾有一个完整的列表。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:238
#, fuzzy
msgid "By default Quarkus will restrict the use of JNDI within an application, as a precaution to try and mitigate any future vulnerabilities similar to log4shell.  Because the `mongo+srv` protocol often used to connect to MongoDB requires JNDI, this protection is automatically disabled when using the MongoDB client extension."
msgstr "默认情况下，Quarkus会限制在应用程序中使用JNDI，作为一种预防措施，试图减轻任何类似log4shell的未来漏洞。因为通常用于连接MongoDB的 `mongo+srv` 协议需要JNDI，所以在使用MongoDB客户端扩展时，这种保护会自动关闭。"

#. type: Title ===
#: upstream/_guides/mongodb.adoc:240
#, fuzzy, no-wrap
msgid "Dev Services (Configuration Free Databases)"
msgstr "开发服务（免配置数据库）。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:245
#, fuzzy
msgid "Quarkus supports a feature called Dev Services that allows you to create various datasources without any config. In the case of MongoDB this support extends to the default MongoDB connection.  What that means practically, is that if you have not configured `quarkus.mongodb.connection-string` Quarkus will automatically start a MongoDB container when running tests or dev-mode, and automatically configure the connection."
msgstr "Quarkus支持一个叫做Dev Services的功能，它允许你在没有任何配置的情况下创建各种数据源。在MongoDB的情况下，这种支持延伸到默认的MongoDB连接。这实际上意味着，如果你没有配置 `quarkus.mongodb.connection-string` ，Quarkus会在运行测试或开发模式时自动启动一个MongoDB容器，并自动配置连接。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:248
#, fuzzy
msgid "When running the production version of the application, the MongoDB connection need to be configured as normal, so if you want to include a production database config in your `application.properties` and continue to use Dev Services we recommend that you use the `%prod.` profile to define your MongoDB settings."
msgstr "当运行应用程序的生产版本时，MongoDB连接需要正常配置，因此如果你想在 `application.properties` ，并继续使用Dev Services，我们建议你使用 `%prod.` 配置文件来定义你的MongoDB设置。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:251
#, fuzzy, no-wrap
msgid "Multiple MongoDB Clients"
msgstr "多个MongoDB客户端"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:255
#, fuzzy
msgid "MongoDB allows you to configure multiple clients.  Using several clients works the same way as having a single client."
msgstr "MongoDB允许你配置多个客户端。使用多个客户端的方式与拥有一个客户端的方式相同。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:259
#, no-wrap
msgid "quarkus.mongodb.connection-string = mongodb://login:pass@mongo1:27017/database\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:262
#, no-wrap
msgid ""
"quarkus.mongodb.users.connection-string = mongodb://mongo2:27017/userdb\n"
"quarkus.mongodb.inventory.connection-string = mongodb://mongo3:27017/invdb,mongo4:27017/invdb\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:267
#, fuzzy
msgid "Notice there's an extra bit in the key (the `users` and `inventory` segments).  The syntax is as follows: `quarkus.mongodb.[optional name.][mongo connection property]`.  If the name is omitted, it configures the default client."
msgstr "注意在键中有一个额外的位（ `users` 和 `inventory` 段）。语法如下。 `quarkus.mongodb.[optional name.][mongo connection property]` .如果省略了名称，就会配置默认的客户端。"

#. type: delimited block =
#: upstream/_guides/mongodb.adoc:274
#, fuzzy
msgid "The use of multiple MongoDB clients enables multi-tenancy for MongoDB by allowing to connect to multiple MongoDB clusters. + If you want to connect to multiple databases inside the same cluster, multiple clients are **not** necessary as a single client is able to access all databases in the same cluster (like a JDBC connection is able to access to multiple schemas inside the same database)."
msgstr "使用多个MongoDB客户端可以实现MongoDB的多租户，允许连接到多个MongoDB集群。+ 如果你想连接同一集群内的多个数据库，则 *不* 需要使用多个客户端，因为单个客户端能够访问同一集群内的所有数据库（就像JDBC连接能够访问同一数据库内的多个模式）。"

#. type: Title ===
#: upstream/_guides/mongodb.adoc:276
#, fuzzy, no-wrap
msgid "Named Mongo client Injection"
msgstr "命名的Mongo客户端注入"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:280
#, fuzzy
msgid "When using multiple clients, each `MongoClient`, you can select the client to inject using the `io.quarkus.mongodb.MongoClientName` qualifier.  Using the above properties to configure three different clients, you can also inject each one as follows:"
msgstr "当使用多个客户端时，每个 `MongoClient` ，你可以使用 `io.quarkus.mongodb.MongoClientName` 修饰语选择要注入的客户端。使用上述属性来配置三个不同的客户端，你也可以按以下方式来注入每个客户端。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:285
#, no-wrap
msgid ""
"@Inject\n"
"MongoClient defaultMongoClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:289
#, no-wrap
msgid ""
"@Inject\n"
"@MongoClientName(\"users\")\n"
"MongoClient mongoClient1;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:293
#, no-wrap
msgid ""
"@Inject\n"
"@MongoClientName(\"inventory\")\n"
"ReactiveMongoClient mongoClient2;\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/mongodb.adoc:295
#, fuzzy, no-wrap
msgid "Running a MongoDB Database"
msgstr "运行MongoDB数据库"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:297
#, fuzzy
msgid "As by default, `MongoClient` is configured to access a local MongoDB database on port 27017 (the default MongoDB port), if you have a local running database on this port, there is nothing more to do before being able to test it!"
msgstr "由于默认情况下， `MongoClient` 被配置为访问端口为27017（默认的MongoDB端口）的本地MongoDB数据库，如果你在这个端口上有一个本地运行的数据库，那么在能够测试之前，没有什么需要做的了"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:299
#, fuzzy
msgid "If you want to use Docker to run a MongoDB database, you can use the following command to launch one:"
msgstr "如果你想使用Docker来运行MongoDB数据库，你可以使用以下命令来启动一个数据库。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:302
#, no-wrap
msgid "docker run -ti --rm -p 27017:27017 mongo:4.0\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/mongodb.adoc:307
#, fuzzy
msgid "If you use <<dev-services,Dev Services>>, launching the container manually is not necessary!"
msgstr "如果你使用 link:#dev-services[开发服务] ，手动启动容器是没有必要的。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:310
#, fuzzy, no-wrap
msgid "Creating a frontend"
msgstr "创建一个前台"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:315
#, fuzzy
msgid "Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it."
msgstr "现在让我们添加一个简单的网页来与我们的 `FruitResource` 。Quarkus会自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含这个{quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[水果.html]文件的内容。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:317
#, fuzzy
msgid "You can now interact with your REST service:"
msgstr "现在你可以与你的REST服务进行交互。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:320
#, fuzzy
msgid "start Quarkus with:"
msgstr "开始Quarkus与。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:323
#, fuzzy
msgid "open a browser to `http://localhost:8080/fruits.html`"
msgstr "打开浏览器以 `<a href=\"http://localhost:8080/fruits.html\" class=\"bare\">http://localhost:8080/fruits.html</a>` "

#. type: Plain text
#: upstream/_guides/mongodb.adoc:324
#, fuzzy
msgid "add new fruits to the list via the form"
msgstr "通过表格添加新的水果到列表中"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:327
#, fuzzy, no-wrap
msgid "Reactive MongoDB Client"
msgstr "反应式MongoDB客户端"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:331
#, fuzzy
msgid "A reactive MongoDB Client is included in Quarkus.  Using it is as easy as using the classic MongoDB Client.  You can rewrite the previous example to use it like the following."
msgstr "Quarkus中包含一个反应式MongoDB客户端。使用它就像使用经典的MongoDB客户端一样简单。你可以重写前面的例子来使用它，如下所示。"

#. type: Block title
#: upstream/_guides/mongodb.adoc:333
#, fuzzy, no-wrap
msgid "Deprecation"
msgstr "撤消"

#. type: delimited block =
#: upstream/_guides/mongodb.adoc:337
#, fuzzy
msgid "The `io.quarkus.mongodb.ReactiveMongoClient` client is deprecated and will be removed in the future.  It is recommended to switch to the `io.quarkus.mongodb.reactive.ReactiveMongoClient` client providing the `Mutiny` API."
msgstr " `io.quarkus.mongodb.ReactiveMongoClient` 客户端已被废弃，并将在未来被删除。建议切换到提供 `Mutiny` API的 `io.quarkus.mongodb.reactive.ReactiveMongoClient` 客户端。"

#. type: Block title
#: upstream/_guides/mongodb.adoc:340
#, fuzzy, no-wrap
msgid "Mutiny"
msgstr "叛变"

#. type: delimited block =
#: upstream/_guides/mongodb.adoc:344
#, fuzzy
msgid "The MongoDB reactive client uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "MongoDB的反应式客户端使用Mutiny反应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的反应式编程库] 。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:354
#, no-wrap
msgid ""
"import io.quarkus.mongodb.reactive.ReactiveMongoClient;\n"
"import io.quarkus.mongodb.reactive.ReactiveMongoCollection;\n"
"import io.smallrye.mutiny.Uni;\n"
"import org.bson.Document;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:358
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:361
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveFruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:364
#, no-wrap
msgid ""
"    @Inject\n"
"    ReactiveMongoClient mongoClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:374
#, no-wrap
msgid ""
"    public Uni<List<Fruit>> list() {\n"
"        return getCollection().find()\n"
"                .map(doc -> {\n"
"                    Fruit fruit = new Fruit();\n"
"                    fruit.setName(doc.getString(\"name\"));\n"
"                    fruit.setDescription(doc.getString(\"description\"));\n"
"                    return fruit;\n"
"                }).collect().asList();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:382
#, no-wrap
msgid ""
"    public Uni<Void> add(Fruit fruit) {\n"
"        Document document = new Document()\n"
"                .append(\"name\", fruit.getName())\n"
"                .append(\"description\", fruit.getDescription());\n"
"        return getCollection().insertOne(document)\n"
"                .onItem().ignore().andContinueWithNull();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:387
#, no-wrap
msgid ""
"    private ReactiveMongoCollection<Document> getCollection() {\n"
"        return mongoClient.getDatabase(\"fruit\").getCollection(\"fruit\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:395
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:397
#, no-wrap
msgid "import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:405
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:410
#, no-wrap
msgid ""
"@Path(\"/reactive_fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class ReactiveFruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:413
#, no-wrap
msgid ""
"    @Inject\n"
"    ReactiveFruitService fruitService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:418
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<List<Fruit>> list() {\n"
"        return fruitService.list();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:425
#, no-wrap
msgid ""
"    @POST\n"
"    public Uni<List<Fruit>> add(Fruit fruit) {\n"
"        return fruitService.add(fruit)\n"
"                .onItem().ignore().andSwitchTo(this::list);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/mongodb.adoc:427
#, fuzzy, no-wrap
msgid "Simplifying MongoDB Client usage using BSON codec"
msgstr "使用BSON编解码器简化MongoDB客户端的使用"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:430
#, fuzzy
msgid "By using a Bson `Codec`, the MongoDB Client will take care of the transformation of your domain object to/from a MongoDB `Document` automatically."
msgstr "通过使用Bson `Codec` ，MongoDB客户端将自动处理你的领域对象到/从MongoDB `Document` 的转换。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:434
#, fuzzy
msgid "First you need to create a Bson `Codec` that will tell Bson how to transform your entity to/from a MongoDB `Document`.  Here we use a `CollectibleCodec` as our object is retrievable from the database (it has a MongoDB identifier), if not we would have used a `Codec` instead.  More information in the codec documentation: https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs."
msgstr "首先你需要创建一个Bson `Codec` ，它将告诉Bson如何将你的实体转换为/从MongoDB `Document` 。这里我们使用一个 `CollectibleCodec` ，因为我们的对象可以从数据库中检索到（它有一个MongoDB标识符），如果不是这样，我们会使用一个 `Codec` 。更多信息见编解码器文档 https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs "

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:438 upstream/_guides/mongodb.adoc:512
#, no-wrap
msgid "package org.acme.mongodb.codec;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:450
#, no-wrap
msgid ""
"import com.mongodb.MongoClientSettings;\n"
"import org.acme.mongodb.Fruit;\n"
"import org.bson.Document;\n"
"import org.bson.BsonWriter;\n"
"import org.bson.BsonValue;\n"
"import org.bson.BsonReader;\n"
"import org.bson.BsonString;\n"
"import org.bson.codecs.Codec;\n"
"import org.bson.codecs.CollectibleCodec;\n"
"import org.bson.codecs.DecoderContext;\n"
"import org.bson.codecs.EncoderContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:452
#, no-wrap
msgid "import java.util.UUID;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:454
#, no-wrap
msgid "public class FruitCodec implements CollectibleCodec<Fruit> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:456
#, no-wrap
msgid "    private final Codec<Document> documentCodec;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:460
#, no-wrap
msgid ""
"    public FruitCodec() {\n"
"        this.documentCodec = MongoClientSettings.getDefaultCodecRegistry().get(Document.class);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:468
#, no-wrap
msgid ""
"    @Override\n"
"    public void encode(BsonWriter writer, Fruit fruit, EncoderContext encoderContext) {\n"
"        Document doc = new Document();\n"
"        doc.put(\"name\", fruit.getName());\n"
"        doc.put(\"description\", fruit.getDescription());\n"
"        documentCodec.encode(writer, doc, encoderContext);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:473
#, no-wrap
msgid ""
"    @Override\n"
"    public Class<Fruit> getEncoderClass() {\n"
"        return Fruit.class;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:481
#, no-wrap
msgid ""
"    @Override\n"
"    public Fruit generateIdIfAbsentFromDocument(Fruit document) {\n"
"        if (!documentHasId(document)) {\n"
"            document.setId(UUID.randomUUID().toString());\n"
"        }\n"
"        return document;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:486
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean documentHasId(Fruit document) {\n"
"        return document.getId() != null;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:491
#, no-wrap
msgid ""
"    @Override\n"
"    public BsonValue getDocumentId(Fruit document) {\n"
"        return new BsonString(document.getId());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:504
#, no-wrap
msgid ""
"    @Override\n"
"    public Fruit decode(BsonReader reader, DecoderContext decoderContext) {\n"
"        Document document = documentCodec.decode(reader, decoderContext);\n"
"        Fruit fruit = new Fruit();\n"
"        if (document.getString(\"id\") != null) {\n"
"            fruit.setId(document.getString(\"id\"));\n"
"        }\n"
"        fruit.setName(document.getString(\"name\"));\n"
"        fruit.setDescription(document.getString(\"description\"));\n"
"        return fruit;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:508
#, fuzzy
msgid "Then you need to create a `CodecProvider` to link this `Codec` to the `Fruit` class."
msgstr "然后你需要创建一个 `CodecProvider` ，把这个 `Codec` 和 `Fruit` 类联系起来。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:517
#, no-wrap
msgid ""
"import org.acme.mongodb.Fruit;\n"
"import org.bson.codecs.Codec;\n"
"import org.bson.codecs.configuration.CodecProvider;\n"
"import org.bson.codecs.configuration.CodecRegistry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:526
#, no-wrap
msgid ""
"public class FruitCodecProvider implements CodecProvider {\n"
"    @Override\n"
"    public <T> Codec<T> get(Class<T> clazz, CodecRegistry registry) {\n"
"        if (clazz.equals(Fruit.class)) {\n"
"            return (Codec<T>) new FruitCodec();\n"
"        }\n"
"        return null;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:528
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:531
#, fuzzy
msgid "Quarkus takes care of registering the `CodecProvider` for you as a CDI bean of `@Singleton` scope."
msgstr "Quarkus负责为你注册 `CodecProvider` ，作为 `@Singleton` 范围的CDI豆。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:533
#, fuzzy
msgid "Finally, when getting the `MongoCollection` from the database you can use directly the `Fruit` class instead of the `Document` one, the codec will automatically map the `Document` to/from your `Fruit` class."
msgstr "最后，当从数据库中获取 `MongoCollection` ，你可以直接使用 `Fruit` 类，而不是 `Document` ，编解码器会自动将 `Document` 映射到/来自你的 `Fruit` 类。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:535
#, fuzzy
msgid "Here is an example of using a `MongoCollection` with the `FruitCodec`."
msgstr "下面是一个使用 `MongoCollection` 与 `FruitCodec` 的例子。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:543
#, no-wrap
msgid ""
"import com.mongodb.client.MongoClient;\n"
"import com.mongodb.client.MongoCollection;\n"
"import com.mongodb.client.MongoCursor;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:551
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CodecFruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:557
#, no-wrap
msgid ""
"    public List<Fruit> list(){\n"
"        List<Fruit> list = new ArrayList<>();\n"
"        MongoCursor<Fruit> cursor = getCollection().find().iterator();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:567
#, no-wrap
msgid ""
"        try {\n"
"            while (cursor.hasNext()) {\n"
"                list.add(cursor.next());\n"
"            }\n"
"        } finally {\n"
"            cursor.close();\n"
"        }\n"
"        return list;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:571
#, no-wrap
msgid ""
"    public void add(Fruit fruit){\n"
"        getCollection().insertOne(fruit);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:576
#, no-wrap
msgid ""
"    private MongoCollection<Fruit> getCollection(){\n"
"        return mongoClient.getDatabase(\"fruit\").getCollection(\"fruit\", Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/mongodb.adoc:578
#, fuzzy, no-wrap
msgid "The POJO Codec"
msgstr "POJO编解码器"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:582
#, fuzzy
msgid "The link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO Codec] provides a set of annotations that enable the customization of the way a POJO is mapped to a MongoDB collection and this codec is initialized automatically by Quarkus"
msgstr "link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO编解码器] 提供了一组注解，可以自定义POJO映射到MongoDB集合的方式，该编解码器由Quarkus自动初始化。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:585
#, fuzzy
msgid "One of these annotations is the `@BsonDiscriminator` annotation that allows to storage multiple Java types in a single MongoDB collection by adding a discriminator field inside the document. It can be useful when working with abstract types or interfaces."
msgstr "这些注解之一是 `@BsonDiscriminator` 注解，它允许通过在文档中添加一个判别字段来在单个MongoDB集合中存储多个Java类型。在处理抽象类型或接口时，它可能很有用。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:587
#, fuzzy
msgid "Quarkus will automatically register all the classes annotated with `@BsonDiscriminator` with the POJO codec."
msgstr "Quarkus会自动将所有用 `@BsonDiscriminator` 注释的类注册为POJO编解码器。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:591
#, fuzzy
msgid "The POJO Codec have enhanced generic support via `PropertyCodecProvider`, Quarkus will automatically register any `PropertyCodecProvider` with the POJO Codec (these classes are automatically made CDI beans of `@Singleton` scope).  When building native executables and using generic types, you might need to register the type arguments for reflection."
msgstr "POJO Codec通过 `PropertyCodecProvider` ，增强了对泛型的支持，Quarkus会自动在POJO Codec中注册任何 `PropertyCodecProvider` （这些类会自动成为 `@Singleton` 范围的CDI豆）。当构建本地可执行文件并使用通用类型时，你可能需要为反射注册类型参数。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:592
#, fuzzy, no-wrap
msgid "Simplifying MongoDB with Panache"
msgstr "用Panache简化MongoDB"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:595
#, fuzzy
msgid "The xref:mongodb-panache.adoc[MongoDB with Panache] extension facilitates the usage of MongoDB by providing active record style entities (and repositories) like you have in xref:hibernate-orm-panache.adoc[Hibernate ORM with Panache] and focuses on making your entities trivial and fun to write in Quarkus."
msgstr "link:mongodb-panache.html[MongoDB with Panache] 扩展通过提供像 link:hibernate-orm-panache.html[Hibernate ORM] 中的 link:hibernate-orm-panache.html[Panache] 一样的活动记录式实体（和存储库）来促进MongoDB的使用，并专注于使你的实体在Quarkus中的编写变得简单而有趣。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:596
#, fuzzy, no-wrap
msgid "Connection Health Check"
msgstr "连接健康检查"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:600
#, fuzzy
msgid "If you are using the `quarkus-smallrye-health` extension, `quarkus-mongodb-client` will automatically add a readiness health check to validate the connection to the cluster."
msgstr "如果你使用 `quarkus-smallrye-health` 扩展， `quarkus-mongodb-client` 将自动添加一个准备就绪健康检查，以验证与集群的连接。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:602
#, fuzzy
msgid "So when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status."
msgstr "因此，当你访问你的应用程序的 `/q/health/ready` 端点时，你将有关于连接验证状态的信息。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:604
#, fuzzy
msgid "This behavior can be disabled by setting the `quarkus.mongodb.health.enabled` property to `false` in your `application.properties`."
msgstr " `false` 这种行为可以通过在你的 `application.properties` 中设置 `quarkus.mongodb.health.enabled` 属性来禁用。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:605
#, fuzzy, no-wrap
msgid "Metrics"
msgstr "度量衡"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:609
#, fuzzy
msgid "If you are using the `quarkus-micrometer` or `quarkus-smallrye-metrics` extension, `quarkus-mongodb-client` can provide metrics about the connection pools.  This behavior must first be enabled by setting the `quarkus.mongodb.metrics.enabled` property to `true` in your `application.properties`."
msgstr "如果你使用 `quarkus-micrometer` 或 `quarkus-smallrye-metrics` 扩展， `quarkus-mongodb-client` 可以提供关于连接池的度量。这种行为必须首先通过在你的 `application.properties` 中设置 `quarkus.mongodb.metrics.enabled` 属性为 `true` 来启用。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:612
#, fuzzy
msgid "So when you access the `/q/metrics` endpoint of your application you will have information about the connection pool status.  When using xref:smallrye-metrics.adoc[SmallRye Metrics], connection pool metrics will be available under the `vendor` scope."
msgstr "因此，当你访问你的应用程序的 `/q/metrics` 端点时，你将得到有关连接池状态的信息。当使用 link:smallrye-metrics.html[SmallRye Metrics] 时，连接池指标将在 `vendor` 范围内可用。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:613
#, fuzzy, no-wrap
msgid "Tracing"
msgstr "追踪"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:617
#, fuzzy
msgid "If you are using the `quarkus-smallrye-opentracing` extension, `quarkus-mongodb-client` can register traces about the commands executed.  This behavior must be enabled by setting the `quarkus.mongodb.tracing.enabled` property to `true` in your `application.properties` and adding the dependency `io.opentracing.contrib:opentracing-mongo-common` to your pom.xml (for more info read the xref:opentracing.adoc#mongodb-client[OpenTracing - MongoDB client] section)."
msgstr "如果你使用 `quarkus-smallrye-opentracing` 扩展， `quarkus-mongodb-client` 可以注册关于所执行命令的跟踪。必须通过在你的 `application.properties` 中将 `quarkus.mongodb.tracing.enabled` 属性设置为 `true` 并在你的 pom.xml 中添加依赖性 `io.opentracing.contrib:opentracing-mongo-common` 来启用这一行为（更多信息请阅读 link:opentracing.html#mongodb-client[OpenTracing - MongoDB 客户端] 部分）。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:619
#, fuzzy
msgid "Read the xref:opentracing.adoc[OpenTracing] guide, for how to configure OpenTracing and how to use the Jaeger tracer."
msgstr "阅读 link:opentracing.html[OpenTracing] 指南，了解如何配置OpenTracing以及如何使用Jaeger追踪器。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:620
#, fuzzy, no-wrap
msgid "Testing helpers"
msgstr "测试帮手"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:623
#, fuzzy
msgid "To start a MongoDB database for your unit tests, Quarkus provides two `QuarkusTestResourceLifecycleManager` that relies on link:https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[Flapdoodle embedded MongoDB]."
msgstr "为了给你的单元测试启动MongoDB数据库，Quarkus提供了两个 `QuarkusTestResourceLifecycleManager` ，依靠 link:https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[Flapdoodle嵌入MongoDB] 。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:625
#, fuzzy
msgid "`io.quarkus.test.mongodb.MongoTestResource` will start a single instance on port 27017."
msgstr " `io.quarkus.test.mongodb.MongoTestResource` 将在27017端口启动一个单一的实例。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:626
#, fuzzy
msgid "`io.quarkus.test.mongodb.MongoReplicaSetTestResource` will start a replicaset with two instances, one on port 27017 and the other on port 27018."
msgstr " `io.quarkus.test.mongodb.MongoReplicaSetTestResource` 将启动一个有两个实例的复制集，一个在27017端口，另一个在27018端口。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:628
#, fuzzy
msgid "To use them, you need to add the `io.quarkus:quarkus-test-mongodb` dependency to your pom.xml."
msgstr "要使用它们，你需要在你的pom.xml中添加 `io.quarkus:quarkus-test-mongodb` 依赖关系。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:630
#, fuzzy
msgid "For more information about the usage of a `QuarkusTestResourceLifecycleManager` please read xref:getting-started-testing.adoc#quarkus-test-resource[Quarkus test resource]."
msgstr "有关 `QuarkusTestResourceLifecycleManager` 的更多信息，请阅读 link:getting-started-testing.html#quarkus-test-resource[Quarkus测试资源] 。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:631
#, fuzzy, no-wrap
msgid "The legacy client"
msgstr "遗留的客户"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:635
#, fuzzy
msgid "We don't include the legacy MongoDB client by default. It contains the now retired MongoDB Java API (DB, DBCollection,... )  and the `com.mongodb.MongoClient` that is now superseded by `com.mongodb.client.MongoClient`."
msgstr "我们默认不包括传统的MongoDB客户端。它包含现已退役的MongoDB Java API（DB、DBCollection......）以及现已被 `com.mongodb.client.MongoClient` 所取代的 `com.mongodb.MongoClient` 。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:637
#, fuzzy
msgid "If you want to use the legacy API, you need to add the following dependency to your build file:"
msgstr "如果你想使用传统的API，你需要在你的构建文件中添加以下依赖关系。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:645
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>org.mongodb</groupId>\n"
"    <artifactId>mongodb-driver-legacy</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:651
#, no-wrap
msgid "implementation(\"org.mongodb:mongodb-driver-legacy\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/mongodb.adoc:653
#, fuzzy, no-wrap
msgid "Building a native executable"
msgstr "构建一个本地可执行文件"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:656
#, fuzzy
msgid "You can use the MongoDB client in a native executable."
msgstr "你可以在一个本地可执行文件中使用MongoDB客户端。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:658
#, fuzzy
msgid "If you want to use SSL/TLS encryption, you need to add these properties in your `application.properties`:"
msgstr "如果你想使用SSL/TLS加密，你需要在你的 `application.properties` ，添加这些属性。"

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:663
#, no-wrap
msgid ""
"quarkus.mongodb.tls=true\n"
"quarkus.mongodb.tls-insecure=true # only if TLS certificate cannot be validated\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:666
#, fuzzy
msgid "You can then build a native executable with the usual command:"
msgstr "然后你可以用通常的命令建立一个本地可执行文件。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:670
#, fuzzy
msgid "Running it is as simple as executing `./target/mongodb-quickstart-1.0.0-SNAPSHOT-runner`."
msgstr "运行它就像执行 `./target/mongodb-quickstart-1.0.0-SNAPSHOT-runner` 一样简单。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:672
#, fuzzy
msgid "You can then point your browser to `http://localhost:8080/fruits.html` and use your application."
msgstr "然后你可以将你的浏览器指向 `<a href=\"http://localhost:8080/fruits.html\" class=\"bare\">http://localhost:8080/fruits.html</a>` 并使用你的应用程序。"

#. type: delimited block =
#: upstream/_guides/mongodb.adoc:676
#, fuzzy
msgid "Currently, Quarkus doesn't support link:https://docs.mongodb.com/manual/core/security-client-side-encryption/[Client-Side Field Level Encryption] in native mode."
msgstr "目前，Quarkus在本地模式下不支持 link:https://docs.mongodb.com/manual/core/security-client-side-encryption/[客户端字段级加密] 。"

#. type: delimited block =
#: upstream/_guides/mongodb.adoc:684
#, fuzzy
msgid "If you encounter the following error when running your application in native mode: + `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can't find a codec for class org.acme.MyVariable.` + This means that the `org.acme.MyVariable` class is not known to GraalVM, the remedy is to add the `@RegisterForReflection` annotation to your `MyVariable class`.  More details about the `@RegisterForReflection` annotation can be found on the xref:writing-native-applications-tips.adoc#registerForReflection[native application tips] page."
msgstr "如果你在本地模式下运行你的应用程序时遇到以下错误。+ `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can’t find a codec for class org.acme.MyVariable.` + 这意味着GeralVM不知道 `org.acme.MyVariable` 类，补救措施是将 `@RegisterForReflection` 注解添加到你的 `MyVariable class` 。关于 `@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips.html#registerForReflection[本地应用程序提示] 页面找到。"

#. type: Title ==
#: upstream/_guides/mongodb.adoc:686
#, fuzzy, no-wrap
msgid "Using mongo+srv:// urls"
msgstr "使用mongo+srv:// urls"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:690
#, fuzzy
msgid "`mongo+srv://` urls are supported out of the box in JVM mode.  However, in native, the default DNS resolver, provided by the MongoDB client, uses JNDI and does not work in native mode."
msgstr " `mongo+srv://` urls在JVM模式下支持开箱即用。然而，在本地模式下，MongoDB客户端提供的默认DNS解析器使用JNDI，在本地模式下无法工作。"

#. type: Plain text
#: upstream/_guides/mongodb.adoc:693
msgid "If you need to use `mongo+srv://` in native mode, you can configure an alternative DNS resolver.  This feature is **experimental** and may introduce a difference between JVM applications and native applications."
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:695
msgid "To enable the alternative DNS resolver, use:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:699
#, no-wrap
msgid "quarkus.mongodb.native.dns.use-vertx-dns-resolver=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:704
msgid "As indicated in the property name, it uses Vert.x to retrieve the DNS records.  By default, it tries to read the first `nameserver` from `/etc/resolv.conf`, if this file exists.  You can also configure your DNS server:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:710
#, no-wrap
msgid ""
"quarkus.mongodb.native.dns.use-vertx-dns-resolver=true\n"
"quarkus.mongodb.native.dns.server-host=10.0.0.1\n"
"quarkus.mongodb.native.dns.server-port=53 # 53 is the default port\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mongodb.adoc:713
msgid "Also, you can configure the lookup timeout using:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mongodb.adoc:718
#, no-wrap
msgid ""
"quarkus.mongodb.native.dns.use-vertx-dns-resolver=true\n"
"quarkus.mongodb.native.dns.lookup-timeout=10s # the default is 5s\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/mongodb.adoc:720
#, no-wrap
msgid "Configuration Reference"
msgstr "配置参考"
