# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-10-19 16:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cassandra.adoc:6
#, fuzzy, no-wrap
msgid "Using the Cassandra Client"
msgstr "使用卡桑德拉客户端"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:14
#, fuzzy
msgid "Apache Cassandra® is a free and open-source, distributed, wide column store, NoSQL database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure."
msgstr "Apache Cassandra®是一个免费的、开源的、分布式的、宽列存储的、NoSQL数据库管理系统，旨在处理许多商品服务器上的大量数据，提供高可用性，没有单点故障。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:16
#, fuzzy
msgid "In this guide, we will see how you can get your REST services to use a Cassandra database."
msgstr "在本指南中，我们将看到如何让你的REST服务使用Cassandra数据库。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:19
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:26
#, fuzzy
msgid "A running link:https://cassandra.apache.org[Apache Cassandra], link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise] (DSE) or link:https://astra.datastax.com[DataStax Astra] database; or alternatively, a fresh Docker installation."
msgstr "一个正在运行的 link:https://cassandra.apache.org[Apache Cassandra] 、 link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise] （DSE）或 link:https://astra.datastax.com[DataStax Astra] 数据库；或者，一个新的Docker安装。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:27
#, fuzzy, no-wrap
msgid "Architecture"
msgstr "建筑学"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:33
#, fuzzy
msgid "This quickstart guide shows how to build a REST application using the link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkus extension], which allows you to connect to an Apache Cassandra, DataStax Enterprise (DSE) or DataStax Astra database, using the link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Java driver]."
msgstr "本快速入门指南展示了如何使用 link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkus扩展] 构建一个REST应用程序，该 link:https://github.com/datastax/cassandra-quarkus[扩展] 允许您使用 link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Java驱动程序] 连接到Apache Cassandra、DataStax Enterprise（DSE）或DataStax Astra数据库。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:38
#, fuzzy
msgid "This guide will also use the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] – a powerful Java-to-CQL mapping framework that greatly simplifies your application's data access layer code by sparing you the hassle of writing your CQL queries by hand."
msgstr "本指南还将使用 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] --一个强大的Java到CQL的映射框架，通过免除你手工编写CQL查询的麻烦，大大简化了你的应用程序的数据访问层代码。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:42
#, fuzzy
msgid "The application built in this quickstart guide is quite simple: the user can add elements in a list using a form, and the items list is updated. All the information between the browser and the server is formatted as JSON, and the elements are stored in the Cassandra database."
msgstr "本快速入门指南中构建的应用程序非常简单：用户可以使用表单在列表中添加元素，而项目列表则被更新。浏览器和服务器之间的所有信息都被格式化为JSON，这些元素被存储在Cassandra数据库中。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:43
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:47
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example."
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。然而，你可以直接进入已完成的例子。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:51
#, fuzzy
msgid "The solution is located in the link:https://github.com/datastax/cassandra-quarkus/tree/main/quickstart[quickstart directory] of the Cassandra Quarkus extension GitHub repository."
msgstr "该解决方案位于Cassandra Quarkus扩展GitHub仓库的 link:https://github.com/datastax/cassandra-quarkus/tree/main/quickstart[quickstart] 目录下。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:52
#, fuzzy, no-wrap
msgid "Creating a Blank Maven Project"
msgstr "创建一个空白的Maven项目"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:56
#, fuzzy
msgid "First, create a new Maven project and copy the `pom.xml` file that is present in the `quickstart` directory."
msgstr "首先，创建一个新的Maven项目，复制 `quickstart` 目录中的 `pom.xml` 文件。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:58
#, fuzzy
msgid "The `pom.xml` is importing all the Quarkus extensions and dependencies you need."
msgstr " `pom.xml` 是导入所有你需要的Quarkus扩展和依赖。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:59
#, fuzzy, no-wrap
msgid "Creating the Data Model and Data Access Objects"
msgstr "创建数据模型和数据访问对象"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:62
#, fuzzy
msgid "In this example, we will create an application to manage a list of fruits."
msgstr "在这个例子中，我们将创建一个应用程序来管理一个水果列表。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:64
#, fuzzy
msgid "First, let's create our data model – represented by the `Fruit` class – as follows:"
msgstr "首先，让我们创建我们的数据模型--由 `Fruit` 类表示--如下。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:70
#, no-wrap
msgid ""
"@Entity\n"
"@PropertyStrategy(mutable = false)\n"
"public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:73
#, no-wrap
msgid ""
"    @PartitionKey\n"
"    private final String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:75
#, no-wrap
msgid "    private final String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:82
#, no-wrap
msgid ""
"    public Fruit(String name, String description) {\n"
"      this.name = name;\n"
"      this.description = description;\n"
"    }\n"
"  // getters, hashCode, equals, toString methods omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:87
#, fuzzy
msgid "As stated above, we are using the DataStax Object Mapper. In other words, we are not going to write our CQL queries manually; instead, we will annotate our data model with a few annotations, and the mapper will generate proper CQL queries underneath."
msgstr "如上所述，我们正在使用DataStax Object Mapper。换句话说，我们不打算手动编写我们的CQL查询；相反，我们将用一些注释来注解我们的数据模型，而映射器将在下面生成适当的CQL查询。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:92
#, fuzzy
msgid "This is why the `Fruit` class is annotated with `@Entity`: this annotation marks it as an _entity class_ that is mapped to a Cassandra table. Its instances are meant to be automatically persisted into, and retrieved from, the Cassandra database. Here, the table name will be inferred from the class name: `fruit`."
msgstr "这就是为什么 `Fruit` 类被注解为 `@Entity` ：这个注解标志着它是一个 _实体类_ ，被映射到一个Cassandra表。它的实例将被自动持久化到Cassandra数据库，并从该数据库中检索。这里，表的名字将从类的名字中推断出来： `fruit` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:95
#, fuzzy
msgid "Also, the `name` field represents a Cassandra partition key, and so we are annotating it with `@PartitionKey` – another annotation from the Object Mapper library."
msgstr "另外， `name` 字段代表一个Cassandra分区键，所以我们用 `@PartitionKey` --另一个来自Object Mapper库的注解来注释它。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:98
#, fuzzy
msgid "Entity classes are normally required to have a default no-arg constructor, unless they are annotated with `@PropertyStrategy(mutable = false)`, which is the case here."
msgstr "实体类通常需要有一个默认的无参数构造函数，除非它们被注解为 `@PropertyStrategy(mutable = false)` ，这里就是这种情况。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:101
#, fuzzy
msgid "The next step is to create a DAO (Data Access Object) interface that will manage instances of `Fruit` entities:"
msgstr "下一步是创建一个DAO（数据访问对象）接口，它将管理 `Fruit` 实体的实例。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:108
#, no-wrap
msgid ""
"@Dao\n"
"public interface FruitDao {\n"
"  @Update\n"
"  void update(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:112
#, no-wrap
msgid ""
"  @Select\n"
"  PagingIterable<Fruit> findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:117
#, fuzzy
msgid "This interface exposes operations that will be used in our REST service. Again, the annotation `@Dao` comes from the DataStax Object Mapper, which will also automatically generate an implementation of this interface for you."
msgstr "这个接口暴露了将在我们的REST服务中使用的操作。同样，注释 `@Dao` ，它来自于DataStax Object Mapper，它也会自动为你生成这个接口的实现。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:121
#, fuzzy
msgid "Note also the special return type of the `findAll` method, link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[`PagingIterable`]: it's the base type of result sets returned by the driver."
msgstr "还要注意 `findAll` 方法的特殊返回类型。 link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[`PagingIterable`] ：它是驱动程序返回的结果集的基本类型。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:123
#, fuzzy
msgid "Finally, let's create the Mapper interface:"
msgstr "最后，让我们创建一个Mapper接口。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:131
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  @DaoFactory\n"
"  FruitDao fruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:136
#, fuzzy
msgid "The `@Mapper` annotation is yet another annotation recognized by the DataStax Object Mapper. A mapper is responsible for constructing instances of DAOs – in this case, out mapper is constructing an instance of our only DAO, `FruitDao`."
msgstr " `@Mapper` 注解是 DataStax Object Mapper 认可的另一个注解。映射器负责构造DAO的实例--在这种情况下，映射器正在构造我们唯一的DAO的实例， `FruitDao` 。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:137
#, fuzzy, no-wrap
msgid "Creating a Service & JSON REST Endpoint"
msgstr "创建一个服务和JSON REST端点"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:141
#, fuzzy
msgid "Now let's create a `FruitService` that will be the business layer of our application and store/load the fruits from the Cassandra database."
msgstr "现在让我们创建一个 `FruitService` ，它将是我们应用程序的业务层，并从Cassandra数据库存储/加载水果。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:146
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:148
#, no-wrap
msgid "  @Inject FruitDao dao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:152
#, no-wrap
msgid ""
"  public void save(Fruit fruit) {\n"
"    dao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:157
#, no-wrap
msgid ""
"  public List<Fruit> getAll() {\n"
"    return dao.findAll().all();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:161
#, fuzzy
msgid "Note how the service is being injected a `FruitDao` instance. This DAO instance is injected automatically."
msgstr "注意服务是如何被注入一个 `FruitDao` 实例的。这个DAO实例是自动注入的。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:164
#, fuzzy
msgid "The Cassandra Quarkus extension allows you to inject any of the following beans in your own components:"
msgstr "Cassandra Quarkus扩展允许你在自己的组件中注入以下任何一个bean。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:166
#, fuzzy
msgid "All `@Mapper`-annotated interfaces in your project."
msgstr "你的项目中所有 `@Mapper` -注释的接口。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:168
#, fuzzy
msgid "All `@Dao`-annotated interfaces in your project, as long as they are produced by a corresponding `@DaoFactory`-annotated method declared in a mapper interface from your project."
msgstr "你项目中所有 `@Dao` -注释的接口，只要它们是由你项目中的映射器接口中声明的相应 `@DaoFactory` -注释的方法产生的。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:173
#, fuzzy
msgid "The link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`] bean: this application-scoped, singleton bean is your main entry point to the Cassandra client; it is a specialized Cassandra driver session instance with a few methods tailored especially for Quarkus. Read its javadocs carefully!"
msgstr "的 link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`] Bean：这个应用范围的单子Bean是你进入Cassandra客户端的主要入口；它是一个专门的Cassandra驱动会话实例，有几个特别为Quarkus定制的方法。请仔细阅读它的javadocs!"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:176
#, fuzzy
msgid "In our example, both `FruitMapper` and `FruitDao` could be injected anywhere. We chose to inject `FruitDao` in `FruitService`."
msgstr "在我们的例子中， `FruitMapper` 和 `FruitDao` 都可以被注入到任何地方。我们选择在 `FruitService` 中注入 `FruitDao` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:178
#, fuzzy
msgid "The last missing piece is the REST API that will expose GET and POST methods:"
msgstr "最后缺少的部分是REST API，它将暴露GET和POST方法。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:185
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:187
#, no-wrap
msgid "  @Inject FruitService fruitService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:192
#, no-wrap
msgid ""
"  @GET\n"
"  public List<FruitDto> getAll() {\n"
"    return fruitService.getAll().stream().map(this::convertToDto).collect(Collectors.toList());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:197
#, no-wrap
msgid ""
"  @POST\n"
"  public void add(FruitDto fruit) {\n"
"    fruitService.save(convertFromDto(fruit));\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:201 upstream/_guides/cassandra.adoc:503
#, no-wrap
msgid ""
"  private FruitDto convertToDto(Fruit fruit) {\n"
"    return new FruitDto(fruit.getName(), fruit.getDescription());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:206 upstream/_guides/cassandra.adoc:508
#, no-wrap
msgid ""
"  private Fruit convertFromDto(FruitDto fruitDto) {\n"
"    return new Fruit(fruitDto.getName(), fruitDto.getDescription());\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:209
#, fuzzy
msgid "Notice how `FruitResource` is being injected a `FruitService` instance automatically."
msgstr "注意到 `FruitResource` 是如何被自动注入一个 `FruitService` 实例的。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:215
#, fuzzy
msgid "It is generally not recommended using the same entity object between the REST API and the data access layer. These layers should indeed be decoupled and use distinct APIs in order to allow each API to evolve independently of the other. This is the reason why our REST API is using a different object: the `FruitDto` class – the word DTO stands for \"Data Transfer Object\". This DTO object will be automatically converted to and from JSON in HTTP messages:"
msgstr "通常不建议在REST API和数据访问层之间使用同一个实体对象。这些层确实应该被解耦，并使用不同的API，以允许每个API独立于其他API而发展。这就是为什么我们的REST API要使用一个不同的对象： `FruitDto` 类--DTO这个词代表 \"数据传输对象\"。这个DTO对象将在HTTP消息中自动转换为JSON，或从JSON中转换。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:219
#, no-wrap
msgid "public class FruitDto {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:222
#, no-wrap
msgid ""
"  private String name;\n"
"  private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:224
#, no-wrap
msgid "  public FruitDto() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:231
#, no-wrap
msgid ""
"  public FruitDto(String name, String description) {\n"
"    this.name = name;\n"
"    this.description = description;\n"
"  }\n"
"  // getters and setters omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:236
#, fuzzy
msgid "The translation to and from JSON is done automatically by the Quarkus RESTEasy Reactive extension, which is included in this guide's pom.xml file. If you want to add it manually to your application, add the below snippet to your application's ppm.xml file:"
msgstr "与JSON的转换是由Quarkus RESTEasy Reactive扩展自动完成的，它包含在本指南的pom.xml文件中。如果你想手动将其添加到你的应用程序中，请将下面的片段添加到你的应用程序的ppm.xml文件中。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:247
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:251
#, fuzzy
msgid "DTO classes used by the JSON serialization layer are required to have a default no-arg constructor."
msgstr "由JSON序列化层使用的DTO类被要求有一个默认的无参数构造函数。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:255
#, fuzzy
msgid "The conversion from DTO to JSON is handled automatically for us, but we still must convert from `Fruit` to `FruitDto` and vice versa. This must be done manually, which is why we have two conversion methods declared in `FruitResource`: `convertToDto` and `convertFromDto`."
msgstr "从DTO到JSON的转换是自动为我们处理的，但我们仍然必须从 `Fruit` 到 `FruitDto` ，反之亦然。这必须手动完成，这就是为什么我们在 `FruitResource` 中声明了两个转换方法： `convertToDto` 和 `convertFromDto` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:259
#, fuzzy
msgid "In our example, `Fruit` and `FruitDto` are very similar, so you might wonder why not use `Fruit` everywhere. In real life cases though, it's not uncommon to see DTOs and entities having very different structures."
msgstr "在我们的例子中， `Fruit` 和 `FruitDto` 是非常相似的，所以你可能会想为什么不在所有地方都使用 `Fruit` 。不过在现实生活中，DTO和实体的结构非常不同的情况并不少见。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:260
#, fuzzy, no-wrap
msgid "Connecting to the Cassandra Database"
msgstr "连接到Cassandra数据库"

#. type: Title ===
#: upstream/_guides/cassandra.adoc:262
#, fuzzy, no-wrap
msgid "Connecting to Apache Cassandra or DataStax Enterprise (DSE)"
msgstr "连接到Apache Cassandra或DataStax Enterprise（DSE）。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:266
#, fuzzy
msgid "The main properties to configure are: `contact-points`, to access the Cassandra database; `local-datacenter`, which is required by the driver; and – optionally – the keyspace to bind to."
msgstr "需要配置的主要属性是。 `contact-points` ，用于访问Cassandra数据库； `local-datacenter` ，这是驱动程序所要求的；以及--可选的--要绑定的密钥空间。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:268
#, fuzzy
msgid "A sample configuration should look like this:"
msgstr "一个配置样本应该是这样的。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:274
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points={cassandra_ip}:9042\n"
"quarkus.cassandra.local-datacenter={dc_name}\n"
"quarkus.cassandra.keyspace={keyspace}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:278
#, fuzzy
msgid "In this example, we are using a single instance running on localhost, and the keyspace containing our data is `k1`:"
msgstr "在这个例子中，我们使用一个运行在localhost上的单一实例，包含我们数据的钥匙空间是 `k1` 。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:284
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points=127.0.0.1:9042\n"
"quarkus.cassandra.local-datacenter=datacenter1\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:288
#, fuzzy
msgid "If your cluster requires plain text authentication, you must also provide two more settings: `username` and `password`."
msgstr "如果你的集群需要纯文本认证，你还必须提供另外两个设置： `username` 和 `password` 。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:293
#, no-wrap
msgid ""
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:295
#, fuzzy, no-wrap
msgid "Connecting to a DataStax Astra Cloud Database"
msgstr "连接到DataStax Astra云数据库"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:301
#, fuzzy
msgid "When connecting to link:https://astra.datastax.com[DataStax Astra], instead of providing a contact point and a datacenter, you should provide a so-called _secure connect bundle_, which should point to a valid path to an Astra secure connect bundle file. You can download your secure connect bundle from the Astra web console."
msgstr "当连接到 link:https://astra.datastax.com[DataStax Astra] 时，你应该提供一个所谓的 _安全连接包_ ，而不是提供一个联络点和一个数据中心，它应该指向一个Astra安全连接包文件的有效路径。你可以从Astra网络控制台下载你的安全连接包。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:304
#, fuzzy
msgid "You will also need to provide a username and password, since authentication is always required on Astra clusters."
msgstr "你还需要提供一个用户名和密码，因为Astra集群上总是需要认证。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:306
#, fuzzy
msgid "A sample configuration for DataStax Astra should look like this:"
msgstr "DataStax Astra的样本配置应该是这样的。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:313
#, no-wrap
msgid ""
"quarkus.cassandra.cloud.secure-connect-bundle=/path/to/secure-connect-bundle.zip\n"
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:315
#, fuzzy, no-wrap
msgid "Advanced Driver Configuration"
msgstr "高级驱动程序配置"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:322
#, fuzzy
msgid "You can configure other Java driver settings using `application.conf` or `application.json` files.  They need to be located in the classpath of your application. All settings will be passed automatically to the underlying driver configuration mechanism. Settings defined in `application.properties` with the `quarkus.cassandra` prefix will have priority over settings defined in `application.conf` or `application.json`."
msgstr "你可以使用 `application.conf` 或 `application.json` 文件来配置其他的Java驱动设置。它们需要位于你的应用程序的classpath中。所有的设置将被自动传递给底层驱动配置机制。在 `application.properties` 中定义的带有 `quarkus.cassandra` 前缀的设置将优先于在 `application.conf` 或 `application.json` 中定义的设置。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:326
#, fuzzy
msgid "To see the full list of settings, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference]."
msgstr "要查看完整的设置清单，请参考 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[驱动程序设置参考] 。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:327
#, fuzzy, no-wrap
msgid "Running a Local Cassandra Database"
msgstr "运行本地卡桑德拉数据库"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:331
#, fuzzy
msgid "By default, the Cassandra client is configured to access a local Cassandra database on port 9042 (the default Cassandra port)."
msgstr "默认情况下，Cassandra客户端被配置为在9042端口（默认的Cassandra端口）访问本地Cassandra数据库。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:334
#, fuzzy
msgid "Make sure that the setting `quarkus.cassandra.local-datacenter` matches the datacenter of your Cassandra cluster."
msgstr "请确保设置 `quarkus.cassandra.local-datacenter` ，与你的Cassandra集群的数据中心相匹配。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:337
#, fuzzy
msgid "If you don't know the name of your local datacenter, this value can be found by running the following CQL query: `SELECT data_center FROM system.local`."
msgstr "如果你不知道你的本地数据中心的名称，这个值可以通过运行以下CQL查询找到： `SELECT data_center FROM system.local` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:340
#, fuzzy
msgid "If you want to use Docker to run a Cassandra database, you can use the following command to launch one in the background:"
msgstr "如果你想使用Docker来运行Cassandra数据库，你可以使用以下命令在后台启动一个数据库。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:344
#, no-wrap
msgid "docker run --name local-cassandra-instance -p 9042:9042 -d cassandra\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:348
#, fuzzy
msgid "Next you need to create the keyspace and table that will be used by your application. If you are using Docker, run the following commands:"
msgstr "接下来你需要创建将被你的应用程序使用的钥匙空间和表。如果你使用的是Docker，运行以下命令。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:353
#, no-wrap
msgid ""
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE KEYSPACE IF NOT EXISTS k1 WITH replication = {'class':'SimpleStrategy', 'replication_factor':1}\"\n"
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE TABLE IF NOT EXISTS k1.fruit(name text PRIMARY KEY, description text)\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:356
#, fuzzy
msgid "You can also use the CQLSH utility to interactively interrogate your database:"
msgstr "你也可以使用CQLSH工具来交互地询问你的数据库。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:360
#, no-wrap
msgid "docker exec -it local-cassandra-instance cqlsh\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cassandra.adoc:362
#, fuzzy, no-wrap
msgid "Testing the REST API"
msgstr "测试REST API"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:365
#, fuzzy
msgid "In the project root directory:"
msgstr "在项目根目录下。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:367
#, fuzzy
msgid "Run `mvn clean package` and then `java -jar ./target/cassandra-quarkus-quickstart-*-runner.jar` to start the application;"
msgstr "运行 `mvn clean package` ，然后 `java -jar ./target/cassandra-quarkus-quickstart-*-runner.jar` ，启动应用程序。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:368
#, fuzzy
msgid "Or better yet, run the application in dev mode: `mvn clean quarkus:dev`."
msgstr "或者更好的是，在开发模式下运行应用程序： `mvn clean quarkus:dev` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:370
#, fuzzy
msgid "Now you can use curl commands to interact with the underlying REST API."
msgstr "现在你可以使用curl命令与底层的REST API进行交互。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:372
#, fuzzy
msgid "To create a fruit:"
msgstr "要创造一种水果。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:379
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"apple\",\"description\":\"red and tasty\"}' \\\n"
"  http://localhost:8080/fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:382
#, fuzzy
msgid "To retrieve fruits:"
msgstr "捞取水果。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:386
#, no-wrap
msgid "curl -X GET http://localhost:8080/fruits\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cassandra.adoc:388
#, fuzzy, no-wrap
msgid "Creating a Frontend"
msgstr "创建一个前台"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:391
#, fuzzy
msgid "Now let's add a simple web page to interact with our `FruitResource`."
msgstr "现在让我们添加一个简单的网页来与我们的 `FruitResource` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:395
#, fuzzy
msgid "Quarkus automatically serves static resources located under the `META-INF/resources` directory. In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the contents from link:src/main/resources/META-INF/resources/fruits.html[this file] in it."
msgstr "Quarkus自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含 link:src/main/resources/META-INF/resources/fruits.html[该文件] 的内容。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:397
#, fuzzy
msgid "You can now interact with your REST service:"
msgstr "现在你可以与你的REST服务进行交互。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:399 upstream/_guides/cassandra.adoc:554
#, fuzzy
msgid "If you haven't done yet, start your application with `mvn clean quarkus:dev`;"
msgstr "如果你还没有做，请用 `mvn clean quarkus:dev` 开始你的申请。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:400
#, fuzzy
msgid "Point your browser to `http://localhost:8080/fruits.html`;"
msgstr "将您的浏览器指向 `<a href=\"http://localhost:8080/fruits.html\" class=\"bare\">http://localhost:8080/fruits.html</a>` ;"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:401 upstream/_guides/cassandra.adoc:556
#, fuzzy
msgid "Add new fruits to the list via the form."
msgstr "通过表格添加新的水果到列表中。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:403
#, fuzzy, no-wrap
msgid "Reactive Programming with the Cassandra Client"
msgstr "使用Cassandra客户端的反应式编程"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:409
#, fuzzy
msgid "The link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession` interface] gives you access to a series of reactive methods that integrate seamlessly with Quarkus and its reactive framework, Mutiny."
msgstr "link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`] 接口让你可以访问一系列的反应式方法，这些方法与Quarkus及其反应式框架Mutiny无缝集成。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:411
#, fuzzy
msgid "If you are not familiar with Mutiny, please check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的反应式编程库] 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:413
#, fuzzy
msgid "Let's rewrite our application using reactive programming with Mutiny."
msgstr "让我们用Mutiny的反应式编程来重写我们的应用程序。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:415
#, fuzzy
msgid "First, let's declare another DAO interface that works in a reactive way:"
msgstr "首先，让我们来声明另一个以反应式方式工作的DAO接口。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:420
#, no-wrap
msgid ""
"@Dao\n"
"public interface ReactiveFruitDao {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:423
#, no-wrap
msgid ""
"  @Update\n"
"  Uni<Void> updateAsync(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:427
#, no-wrap
msgid ""
"  @Select\n"
"  MutinyMappedReactiveResultSet<Fruit> findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:434
#, fuzzy
msgid "Note the usage of `MutinyMappedReactiveResultSet` - it is a specialized `Mutiny` type converted from the original `Publisher` returned by the driver, which also exposes a few extra methods, e.g. to obtain the query execution info. If you don't need anything in that interface, you can also simply declare your method to return `Multi`: `Multi<Fruit> findAll()`,"
msgstr "请注意 `MutinyMappedReactiveResultSet` 的用法--它是由驱动程序返回的原始 `Publisher` 转换而来的专门的 `Mutiny` 类型，它还暴露了一些额外的方法，例如获取查询执行信息。如果你不需要该接口中的任何东西，你也可以简单地声明你的方法返回 `Multi` ： `Multi<Fruit> findAll()` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:437
#, fuzzy
msgid "Similarly, the method `updateAsync` returns a `Uni` - it is automatically converted from the original result set returned by the driver."
msgstr "同样，方法 `updateAsync` ，返回一个 `Uni` --它是由驱动程序返回的原始结果集自动转换的。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:445
#, fuzzy
msgid "The Cassandra driver uses the Reactive Streams `Publisher` API for reactive calls. The Quarkus framework however uses Mutiny. Because of that, the `CqlQuarkusSession` interface transparently converts the `Publisher` instances returned by the driver into the reactive type `Multi`.  `CqlQuarkusSession` is also capable of converting a `Publisher` into a `Uni` – in this case, the publisher is expected to emit at most one row, then complete. This is suitable for write queries (they return no rows), or for read queries guaranteed to return one row at most (count queries, for example)."
msgstr "Cassandra驱动使用Reactive Streams `Publisher` API进行反应性调用。然而Quarkus框架使用Mutiny。因为， `CqlQuarkusSession` 接口可以透明地将驱动程序返回的 `Publisher` 实例转换为反应式类型 `Multi` 。 `CqlQuarkusSession` 也能够将 `Publisher` 转换为 `Uni` - 在这种情况下，预计发布者最多发出一条记录，然后完成。这适用于写查询（它们不返回任何行），或保证最多返回一行的读查询（例如，计数查询）。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:447
#, fuzzy
msgid "Next, we need to adapt the `FruitMapper` to construct a `ReactiveFruitDao` instance:"
msgstr "接下来，我们需要调整 `FruitMapper` ，构建一个 `ReactiveFruitDao` 的实例。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:453
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  // the existing method omitted\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:457
#, no-wrap
msgid ""
"  @DaoFactory\n"
"  ReactiveFruitDao reactiveFruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:461
#, fuzzy
msgid "Now, we can create a `ReactiveFruitService` that leverages our reactive DAO:"
msgstr "现在，我们可以创建一个 `ReactiveFruitService` ，利用我们的反应式DAO。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:466
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveFruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:468
#, no-wrap
msgid "  @Inject ReactiveFruitDao fruitDao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:472
#, no-wrap
msgid ""
"  public Uni<Void> add(Fruit fruit) {\n"
"    return fruitDao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:477
#, no-wrap
msgid ""
"  public Multi<Fruit> getAll() {\n"
"    return fruitDao.findAll();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:480
#, fuzzy
msgid "Finally, we can create a `ReactiveFruitResource`:"
msgstr "最后，我们可以创建一个 `ReactiveFruitResource` 。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:487
#, no-wrap
msgid ""
"@Path(\"/reactive-fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class ReactiveFruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:489
#, no-wrap
msgid "  @Inject ReactiveFruitService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:494
#, no-wrap
msgid ""
"  @GET\n"
"  public Multi<FruitDto> getAll() {\n"
"    return service.getAll().map(this::convertToDto);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:499
#, no-wrap
msgid ""
"  @POST\n"
"  public Uni<Void> add(FruitDto fruitDto) {\n"
"    return service.add(convertFromDto(fruitDto));\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:513
#, fuzzy
msgid "The above resource is exposing a new endpoint, `reactive-fruits`. Its capabilities are identical to the ones that we created before with `FruitResource`, but everything is handled in a reactive fashion, without any blocking operation."
msgstr "上述资源公开了一个新的端点， `reactive-fruits` 。它的功能与我们之前用 `FruitResource` 创建的功能相同，但一切都以反应式方式处理，没有任何阻塞操作。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:517
#, fuzzy
msgid "The `getAll()` method above returns `Multi`, and the `add()` method returns `Uni`. These types are the same Mutiny types that we met before; they are automatically recognized by the Quarkus reactive REST API, so we don't need to convert them into JSON ourselves."
msgstr "上面的 `getAll()` 方法返回 `Multi` ，而 `add()` 方法返回 `Uni` 。这些类型与我们之前遇到的Mutiny类型相同；它们被Quarkus反应式REST API自动识别，所以我们不需要自己把它们转换为JSON。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:519
#, fuzzy
msgid "RESTEasy Reactive natively supports the Mutiny reactive types e.g. `Uni` and `Multi`."
msgstr "RESTEasy Reactive原生支持Mutiny的反应类型，例如 `Uni` 和 `Multi` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:522
#, fuzzy
msgid "This dependency is already included in this guide's pom.xml, but if you are starting a new project from scratch, make sure to include it."
msgstr "这个依赖已经包含在本指南的pom.xml中，但如果你要从头开始一个新项目，请确保包含它。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:523
#, fuzzy, no-wrap
msgid "Testing the Reactive REST API"
msgstr "测试反应式REST API"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:527
#, fuzzy
msgid "Run the application in dev mode as explained above, then you can use curl commands to interact with the underlying REST API."
msgstr "如上所述，在开发模式下运行应用程序，然后你可以使用curl命令与底层REST API进行交互。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:529
#, fuzzy
msgid "To create a fruit using the reactive REST endpoint:"
msgstr "要使用反应式REST端点创建一个水果。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:536
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"banana\",\"description\":\"yellow and sweet\"}' \\\n"
"  http://localhost:8080/reactive-fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:539
#, fuzzy
msgid "To retrieve fruits with the reactive REST endpoint:"
msgstr "要用反应式REST端点检索水果。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:543
#, no-wrap
msgid "curl -X GET http://localhost:8080/reactive-fruits\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cassandra.adoc:545
#, fuzzy, no-wrap
msgid "Creating a Reactive Frontend"
msgstr "创建一个反应式的前端"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:550
#, fuzzy
msgid "Now let's add a simple web page to interact with our `ReactiveFruitResource`. In the `src/main/resources/META-INF/resources` directory, add a `reactive-fruits.html` file with the contents from link:src/main/resources/META-INF/resources/reactive-fruits.html[this file] in it."
msgstr "现在让我们添加一个简单的网页来与我们的 `ReactiveFruitResource` 。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `reactive-fruits.html` 文件，其中包含 link:src/main/resources/META-INF/resources/reactive-fruits.html[该文件] 的内容。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:552
#, fuzzy
msgid "You can now interact with your reactive REST service:"
msgstr "现在你可以与你的反应式REST服务进行交互。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:555
#, fuzzy
msgid "Point your browser to `http://localhost:8080/reactive-fruits.html`;"
msgstr "将您的浏览器指向 `<a href=\"http://localhost:8080/reactive-fruits.html\" class=\"bare\">http://localhost:8080/reactive-fruits.html</a>` ;"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:557
#, fuzzy, no-wrap
msgid "Health Checks"
msgstr "健康检查"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:563
#, fuzzy
msgid "If you are using the Quarkus SmallRye Health extension, then the Cassandra client will automatically add a readiness health check to validate the connection to the Cassandra cluster. This extension is already included in this guide's pom.xml, but if you need to include it manually in your application, add the following:"
msgstr "如果你使用Quarkus SmallRye Health扩展，那么Cassandra客户端将自动添加就绪健康检查以验证与Cassandra集群的连接。这个扩展已经包含在本指南的pom.xml中，但如果你需要在你的应用程序中手动包含它，请添加以下内容。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:570
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-smallrye-health</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:574
#, fuzzy
msgid "When health checks are available, you can access the `/health/ready` endpoint of your application and have information about the connection validation status."
msgstr "当健康检查可用时，你可以访问你的应用程序的 `/health/ready` 端点，并拥有关于连接验证状态的信息。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:577
#, fuzzy
msgid "Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to http://localhost:8080/health/ready you should see an output similar to the following one:"
msgstr "在开发模式下运行 `mvn clean quarkus:dev` ，如果你把你的浏览器指向 http://localhost:8080/health/ready ，你应该看到类似于以下的输出。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:596
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"UP\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"DataStax Apache Cassandra Driver health check\",\n"
"            \"status\": \"UP\",\n"
"            \"data\": {\n"
"                \"cqlVersion\": \"3.4.4\",\n"
"                \"releaseVersion\": \"3.11.7\",\n"
"                \"clusterName\": \"Test Cluster\",\n"
"                \"datacenter\": \"datacenter1\",\n"
"                \"numberOfNodes\": 1\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:601
#, fuzzy
msgid "If you need health checks globally enabled in your application, but don't want to activate Cassandra health checks, you can disable Cassandra health checks by setting the `quarkus.cassandra.health.enabled` property to `false` in your `application.properties`."
msgstr " `application.properties` 如果你需要在你的应用程序中全局启用健康检查，但不想激活Cassandra健康检查，你可以通过在你的 `quarkus.cassandra.health.enabled` 属性设置为 `false` ，来禁用Cassandra健康检查。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:602
#, fuzzy, no-wrap
msgid "Metrics"
msgstr "度量衡"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:606
#, fuzzy
msgid "The Cassandra Quarkus client can provide metrics about the Cassandra session and about individual Cassandra nodes. It supports both Micrometer and MicroProfile."
msgstr "Cassandra Quarkus客户端可以提供关于Cassandra会话和单个Cassandra节点的指标。它同时支持Micrometer和MicroProfile。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:609
#, fuzzy
msgid "The first step to enable metrics is to add a few additional dependencies depending on the metrics framework you plan to use."
msgstr "启用度量衡的第一步是根据你计划使用的度量衡框架，添加一些额外的依赖项。"

#. type: Title ===
#: upstream/_guides/cassandra.adoc:610
#, fuzzy, no-wrap
msgid "Enabling Metrics with Micrometer"
msgstr "用Micrometer实现指标化"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:613
#, fuzzy
msgid "Micrometer is the recommended metrics framework in Quarkus applications."
msgstr "Micrometer是Quarkus应用中推荐的度量框架。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:615
#, fuzzy
msgid "To enable Micrometer metrics in your application, you need to add the following to your pom.xml."
msgstr "为了在你的应用程序中启用Micrometer度量，你需要在你的pom.xml中添加以下内容。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:626
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:629
#, fuzzy
msgid "This guide uses Micrometer, so the above dependencies are already included in this guide's pom.xml."
msgstr "本指南使用Micrometer，所以上述依赖已经包含在本指南的pom.xml中。"

#. type: Title ===
#: upstream/_guides/cassandra.adoc:630
#, fuzzy, no-wrap
msgid "Enabling Metrics with MicroProfile Metrics"
msgstr "用MicroProfile度量标准启用度量标准"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:633
#, fuzzy
msgid "Remove any dependency to Micrometer from your pom.xml, then add the following ones instead:"
msgstr "从你的pom.xml中删除任何对Micrometer的依赖，然后添加以下内容。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:644
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-microprofile</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-smallrye-metrics</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:646
#, fuzzy, no-wrap
msgid "Enabling Cassandra Metrics"
msgstr "启用Cassandra度量衡"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:651
#, fuzzy
msgid "Even when metrics are enabled in your application, the Cassandra client will not report any metrics, unless you opt in for this feature. So your next step is to enable Cassandra metrics in your `application.properties` file."
msgstr "即使在你的应用程序中启用了度量，Cassandra 客户端也不会报告任何度量，除非你选择使用这个功能。所以你的下一步是在你的 `application.properties` 文件中启用 Cassandra 度量。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:655
#, no-wrap
msgid "quarkus.cassandra.metrics.enabled=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:658
#, fuzzy
msgid "That's it!"
msgstr "就这样吧!"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:662
#, fuzzy
msgid "The final (and optional) step is to customize which specific Cassandra metrics you would like the Cassandra client to track. Several metrics can be tracked; if you skip this step, a default set of useful metrics will be automatically tracked."
msgstr "最后一步（也是可选的）是自定义你希望 Cassandra 客户端跟踪哪些特定的 Cassandra 指标。可以跟踪几个指标；如果你跳过这一步，一组默认的有用指标将被自动跟踪。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:668
#, fuzzy
msgid "For the full list of available metric names, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference] page; search for the `advanced.metrics` section.  Also, Cassandra driver metrics are covered in detail in the https://docs.datastax.com/en/developer/java-driver/latest/manual/core/metrics/[driver manual]."
msgstr "关于可用度量名称的完整列表，请参考 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[驱动设置参考] 页；搜索 `advanced.metrics` 部分。另外，Cassandra驱动指标在 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/metrics/[驱动手册] 中也有详细介绍。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:670
#, fuzzy
msgid "If you do wish to customize which metrics to track, you should use the following properties:"
msgstr "如果你确实希望自定义追踪哪些指标，你应该使用以下属性。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:673
#, fuzzy
msgid "`quarkus.cassandra.metrics.session.enabled` should contain the session-level metrics to enable (metrics that are global to the session)."
msgstr " `quarkus.cassandra.metrics.session.enabled` 应该包含要启用的会话级指标（对会话来说是全局的指标）。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:675
#, fuzzy
msgid "`quarkus.cassandra.metrics.node.enabled` should contain the node-level metrics to enable (metrics for which each node contacted by the Cassandra client gets its own metric value)."
msgstr " `quarkus.cassandra.metrics.node.enabled` 应包含要启用的节点级度量（Cassandra 客户端接触的每个节点都会得到自己的度量值的度量）。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:677
#, fuzzy
msgid "Both properties accept a comma-separated list of valid metric names."
msgstr "这两个属性都接受一个以逗号分隔的有效度量衡名称列表。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:679
#, fuzzy
msgid "For example, let's assume that you wish to enable the following three Cassandra metrics:"
msgstr "例如，让我们假设你希望启用以下三个Cassandra度量。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:681
#, fuzzy
msgid "Session-level: `session.connected-nodes` and `session.bytes-sent`;"
msgstr "会议级别： `session.connected-nodes` 和 `session.bytes-sent` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:682
#, fuzzy
msgid "Node-level: `node.pool.open-connections`."
msgstr "节点级： `node.pool.open-connections` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:684
#, fuzzy
msgid "Then you should add the following settings to your `application.properties`:"
msgstr "然后，你应该将以下设置添加到你的 `application.properties` 。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:690
#, no-wrap
msgid ""
"quarkus.cassandra.metrics.enabled=true\n"
"quarkus.cassandra.metrics.session.enabled=connected-nodes,bytes-sent\n"
"quarkus.cassandra.metrics.node.enabled=pool.open-connections\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:694
#, fuzzy
msgid "This guide's `application.properties` file has already many metrics enabled; you can use its metrics list as a good starting point for exposing useful Cassandra metrics in your application."
msgstr "本指南的 `application.properties` 文件已经启用了许多指标；你可以把它的指标列表作为在你的应用程序中公开有用的 Cassandra 指标的良好起点。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:697
#, fuzzy
msgid "When metrics are properly enabled, metric reports for all enabled metrics are available at the `/metrics` REST endpoint of your application."
msgstr "当指标被正确启用时，所有被启用的指标的指标报告都可以在你的应用程序的 `/metrics` REST端点得到。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:701
#, fuzzy
msgid "Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to `http://localhost:8080/metrics` you should see a list of metrics; search for metrics whose names contain `cassandra`."
msgstr "在开发模式下运行 `mvn clean quarkus:dev` ，如果你把你的浏览器指向 `<a href=\"http://localhost:8080/metrics\" class=\"bare\">http://localhost:8080/metrics</a>` 你应该看到一个指标列表；搜索名称中包含 `cassandra` 的指标。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:705
#, fuzzy
msgid "For Cassandra metrics to show up, the Cassandra client needs to be initialized and connected; if you are using lazy initialization (see below), you won't see any Cassandra metrics until your application actually connects and hits the database for the first time."
msgstr "为了让Cassandra指标显示出来，Cassandra客户端需要被初始化和连接；如果你使用懒惰初始化（见下文），在你的应用程序实际连接并首次点击数据库之前，你不会看到任何Cassandra指标。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:706
#, fuzzy, no-wrap
msgid "Running in native mode"
msgstr "在本地模式下运行"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:710
#, fuzzy
msgid "If you installed GraalVM, you can link:https://quarkus.io/guides/building-native-image[build a native image] using:"
msgstr "如果你安装了GraalVM，你可以用以下方法 link:https://quarkus.io/guides/building-native-image[构建一个本地镜像] 。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:714
#, no-wrap
msgid "mvn clean package -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:718
#, fuzzy
msgid "Beware that native compilation can take a significant amount of time! Once the compilation is done, you can run the native executable as follows:"
msgstr "请注意，本地编译可能需要大量的时间!编译完成后，你可以按以下方式运行本地可执行文件。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:722
#, no-wrap
msgid "./target/cassandra-quarkus-quickstart-*-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:725
#, fuzzy
msgid "You can then point your browser to `http://localhost:8080/fruits.html` and use your application."
msgstr "然后你可以将你的浏览器指向 `<a href=\"http://localhost:8080/fruits.html\" class=\"bare\">http://localhost:8080/fruits.html</a>` 并使用你的应用程序。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:726
#, fuzzy, no-wrap
msgid "Eager vs Lazy Initialization"
msgstr "渴望与懒惰的初始化"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:729
#, fuzzy
msgid "This extension allows you to inject either:"
msgstr "这个扩展允许你注入任何一种。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:731
#, fuzzy
msgid "a `QuarkusCqlSession` bean;"
msgstr "a `QuarkusCqlSession` 豆子。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:732
#, fuzzy
msgid "or the asynchronous version of this bean, that is, `CompletionStage<QuarkusCqlSession>`;"
msgstr "或该bean的异步版本，即 `CompletionStage<QuarkusCqlSession>` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:733
#, fuzzy
msgid "or the reactive version of this bean, that is, `Uni<QuarkusCqlSession>`."
msgstr "或这个bean的反应式版本，即： `Uni<QuarkusCqlSession>` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:737
#, fuzzy
msgid "The most straightforward approach is obviously to inject `QuarkusCqlSession` directly. This should work just fine for most applications; however, the `QuarkusCqlSession` bean needs to be initialized before it can be used, and this process is blocking."
msgstr "最直接的方法显然是直接注入 `QuarkusCqlSession` 。这对大多数应用程序来说应该是很好的；然而，在使用 `QuarkusCqlSession` bean之前需要对其进行初始化，而这个过程是阻塞的。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:744
#, fuzzy
msgid "Fortunately, it is possible to control when the initialization should happen: the `quarkus.cassandra.init.eager-init` parameter determines if the `QuarkusCqlSession` bean should be initialized on its first access (lazy) or when the application is starting (eager). The default value of this parameter is `false`, meaning the init process is lazy: the `QuarkusCqlSession` bean will be initialized lazily on its first access – for example, when there is a first REST request that needs to interact with the Cassandra database."
msgstr "幸运的是，可以控制初始化发生的时间： `quarkus.cassandra.init.eager-init` 参数决定了 `QuarkusCqlSession` Bean是在其第一次访问时被初始化（懒惰）还是在应用程序启动时被初始化（急切）。这个参数的默认值是 `false` ，意味着初始化过程是懒惰的： `QuarkusCqlSession` Bean将在其第一次访问时被懒惰地初始化--例如，当有第一个REST请求需要与Cassandra数据库交互时。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:751
#, fuzzy
msgid "Using lazy initialization speeds up your application startup time, and avoids startup failures if the Cassandra database is not available. However, it could also prove dangerous if your code is fully asynchronous, e.g. if you are using https://quarkus.io/guides/reactive-routes[reactive routes]: indeed, the lazy initialization could accidentally happen on a thread that is not allowed to block, such as a Vert.x event loop thread. Therefore, setting `quarkus.cassandra.init.eager-init` to `false` and injecting `QuarkusCqlSession` should be avoided in these contexts."
msgstr "使用懒惰初始化可以加快应用程序的启动时间，并避免在Cassandra数据库不可用时出现启动失败。然而，如果你的代码是完全异步的，例如，如果你使用 link:https://quarkus.io/guides/reactive-routes[反应式路由] ，它也可能被证明是危险的：事实上，懒惰初始化可能意外地发生在一个不允许阻塞的线程上，例如Vert.x事件循环线程。因此，在这些情况下，应该避免将 `quarkus.cassandra.init.eager-init` 设置为 `false` ，并注入 `QuarkusCqlSession` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:757
msgid "If you want to use Vert.x (or any other reactive framework) and keep the lazy initialization behavior, you should instead inject only `CompletionStage<QuarkusCqlSession>` or `Uni<QuarkusCqlSession>`. When injecting these beans, the initialization process will be triggered lazily, but it will happen in the background, in a non-blocking way, leveraging the Vert.x event loop. This way you don't risk blocking the Vert.x thread."
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:762
msgid "Alternatively, you can set `quarkus.cassandra.init.eager-init` to true: in this case the session bean will be initialized eagerly during application startup, on the Quarkus main thread. This would eliminate any risk of blocking a Vert.x thread, at the cost of making your startup time (much)  longer."
msgstr ""

#. type: Title ==
#: upstream/_guides/cassandra.adoc:763
#, no-wrap
msgid "Conclusion"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:767
msgid "Accessing a Cassandra database from a client application is easy with Quarkus and the Cassandra extension, which provides configuration and native support for the DataStax Java driver for Apache Cassandra."
msgstr ""
