# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/amazon-lambda-http.adoc:6
#, fuzzy, no-wrap
msgid "Amazon Lambda with RESTEasy Reactive, Undertow, or Reactive Routes"
msgstr "亚马逊Lambda与RESTEasy Reactive、Undertow或Reactive Routes的关系"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:15
#, fuzzy
msgid "With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda."
msgstr "通过Quarkus，您可以使用 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] 或 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API] 将您最喜爱的Java HTTP框架部署为Amazon Lambda。这意味着你可以将用RESTEasy Reactive（JAX-RS）、Undertow（servlet）、Reactive Routes、 link:funqy-http.html[Funqy HTTP] 或任何其他Quarkus HTTP框架编写的微服务部署为AWS Lambda。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:18
#, fuzzy
msgid "You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework]."
msgstr "你可以将你的Lambda部署为一个纯Java jar，或者你可以将你的项目编译为一个本地镜像，然后部署，以减少内存占用和启动时间。我们的集成还可以生成SAM部署文件，可以被 link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[亚马逊的SAM框架] 所使用。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:22
#, fuzzy
msgid "Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision."
msgstr "Quarkus为每个网关API都有一个不同的扩展。HTTP网关API是在 `quarkus-amazon-lambda-http` 扩展中实现的。REST网关API是在 `quarkus-amazon-lambda-rest` 扩展中实现的。如果你对使用哪种网关产品感到困惑，亚马逊有一个 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[很好的指南] 来帮助你做这个决定。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:24
#, fuzzy
msgid "Like most Quarkus extensions, the Quarkus AWS Lambda HTTP/REST extensions support Live Coding."
msgstr "像大多数Quarkus扩展一样，Quarkus AWS Lambda HTTP/REST扩展支持Live Coding。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:27
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:32
#, fuzzy
msgid "https://aws.amazon.com[An Amazon AWS account]"
msgstr "link:https://aws.amazon.com[一个亚马逊AWS账户]"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:33
#, fuzzy
msgid "https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]"
msgstr "link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:34
#, fuzzy, no-wrap
msgid "Getting Started"
msgstr "入门"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:38
#, fuzzy
msgid "This guide walks you through generating an example Java project via a Maven archetype.  Later on it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda."
msgstr "本指南将引导您通过Maven原型生成一个Java项目的例子。随后，本指南将介绍项目的结构，以便您能够调整现有的项目以使用Amazon Lambda。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:39
#, fuzzy, no-wrap
msgid "Installing AWS bits"
msgstr "安装AWS位"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:43
#, fuzzy
msgid "Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI."
msgstr "安装所有的AWS位可能是本指南中最困难的事情。请确保你遵循安装AWS SAM CLI的所有步骤。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:44
#, fuzzy, no-wrap
msgid "Creating the Maven Deployment Project"
msgstr "创建Maven部署项目"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:47
#, fuzzy
msgid "Create the Quarkus AWS Lambda Maven project using our Maven Archetype."
msgstr "使用我们的Maven Archetype创建Quarkus AWS Lambda Maven项目。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:49
#, fuzzy
msgid "If you want to use the AWS Gateway HTTP API, generate your project with this script:"
msgstr "如果你想使用AWS Gateway HTTP API，用这个脚本生成你的项目。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:55
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-http-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:58
#, fuzzy
msgid "If you want to use the AWS Gateway REST API, generate your project with this script:"
msgstr "如果你想使用AWS Gateway REST API，用这个脚本生成你的项目。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:64
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-rest-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:67
#, fuzzy, no-wrap
msgid "Build and Deploy"
msgstr "构建和部署"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:70
#, fuzzy
msgid "Build the project:"
msgstr "构建该项目。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:76
#, fuzzy
msgid "This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension."
msgstr "这将编译代码并运行生成的项目中包含的单元测试。单元测试和其他的Java项目一样，不需要在Amazon上运行。Quarkus开发模式也可以通过这个扩展来实现。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:79
#, fuzzy
msgid "If you want to build a native executable, make sure you have GraalVM installed correctly and just add a `native` property to the build"
msgstr "如果你想构建一个本地可执行文件，请确保你已经正确安装了GraalVM，只需在构建时添加一个 `native` 属性即可。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:85
#, fuzzy
msgid "If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however."
msgstr "如果你在非Linux系统上构建，你还需要传入一个属性，指示quarkus使用Docker构建，因为Amazon Lambda需要Linux二进制文件。你可以通过在你的构建命令中传递 `-Dquarkus.native.container-build=true` 。不过，这需要你在本地安装Docker。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:88
#, fuzzy, no-wrap
msgid "Extra Build Generated Files"
msgstr "额外的构建生成的文件"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:92
#, fuzzy
msgid "After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the the build directory: `target/` for Maven, `build/` for Gradle."
msgstr "运行构建后，你所使用的Quarkus lambda扩展会生成一些额外的文件。这些文件在构建目录中：Maven的 `target/` ，Gradle的 `build/` 。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:94
#, fuzzy
msgid "`function.zip` - lambda deployment file"
msgstr " `function.zip` - lambda部署文件"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:95
#, fuzzy
msgid "`sam.jvm.yaml` - sam cli deployment script"
msgstr " `sam.jvm.yaml` - sam cli部署脚本"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:96
#, fuzzy
msgid "`sam.native.yaml` - sam cli deployment script for native"
msgstr " `sam.native.yaml` - 本机的sam cli部署脚本"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:97
#, fuzzy, no-wrap
msgid "Live Coding and Simulating AWS Lambda Environment Locally"
msgstr "现场编码和本地模拟AWS Lambda环境"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:103
#, fuzzy
msgid "In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI."
msgstr "在开发和测试模式下，Quarkus会启动一个模拟的AWS Lambda事件服务器，将HTTP请求转换为相应的API Gateway事件类型，并将其发布到底层的Quarkus HTTP lambda环境进行处理。这在本地尽可能地模拟了AWS Lambda环境，而不需要Docker和SAM CLI等工具。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:107
#, fuzzy
msgid "When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop."
msgstr "当使用Quarkus开发模式时，只需在 `<a href=\"http://localhost:8080\" class=\"bare\">http://localhost:8080</a>` 就像你在测试REST端点时一样。这个请求将击中Mock Event Server，并将被转换为API Gateway的json消息，被Quarkus Lambda Poll循环所消耗。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:110
#, fuzzy
msgid "For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up."
msgstr "为了测试，Quarkus在端口8081下启动了一个单独的模拟事件服务器。Rest Assured的默认端口被Quarkus自动设置为8081，所以你不必担心设置这个。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:115
#, fuzzy
msgid "If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:"
msgstr "如果你想在你的测试中模拟更复杂的API Gateway事件，那么就手动做一个HTTP POST到 `<a href=\"http://localhost:8080/_lambda_\" class=\"bare\">http://localhost:8080/_lambda_</a>` (测试模式下的8081端口)，将原始的API Gateway json事件发送到。这些事件将被直接放在Quarkus Lambda轮询循环上进行处理。下面是一个例子。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:120
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.equalTo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:122
#: upstream/_guides/amazon-lambda-http.adoc:445
#: upstream/_guides/amazon-lambda-http.adoc:486
#, no-wrap
msgid "import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:124
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:134
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class AmazonLambdaSimpleTestCase {\n"
"    @Test\n"
"    public void testJaxrsCognitoJWTSecurityContext() throws Exception {\n"
"        APIGatewayV2HTTPEvent request = request(\"/security/username\");\n"
"        request.getRequestContext().setAuthorizer(new APIGatewayV2HTTPEvent.RequestContext.Authorizer());\n"
"        request.getRequestContext().getAuthorizer().setJwt(new APIGatewayV2HTTPEvent.RequestContext.Authorizer.JWT());\n"
"        request.getRequestContext().getAuthorizer().getJwt().setClaims(new HashMap<>());\n"
"        request.getRequestContext().getAuthorizer().getJwt().getClaims().put(\"cognito:username\", \"Bill\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:145
#, no-wrap
msgid ""
"        given()\n"
"                .contentType(\"application/json\")\n"
"                .accept(\"application/json\")\n"
"                .body(request)\n"
"                .when()\n"
"                .post(\"/_lambda_\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(\"body\", equalTo(\"Bill\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:148
#, fuzzy
msgid "The above example simulates sending a Cognito principal with an HTTP request to your HTTP Lambda."
msgstr "上面的例子模拟了向你的HTTP Lambda发送一个带有HTTP请求的Cognito principal。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:153
#, fuzzy
msgid "If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API."
msgstr "如果你想为AWS HTTP API手工编码原始事件，AWS Lambda库的请求事件类型是 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` ，响应事件类型是 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse` 。这与 `quarkus-amazon-lambda-http` 扩展和AWS HTTP API相对应。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:157
#, fuzzy
msgid "If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API."
msgstr "如果你想为AWS REST API手工编码原始事件，Quarkus有自己的实现： `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` 和 `io.quarkus.amazon.lambda.http.model.AwsProxyResponse` 。这与 `quarkus-amazon-lambda-rest` 扩展和AWS REST API相对应。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:160
#, fuzzy
msgid "The mock event server is also started for `@NativeImageTest` and `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker."
msgstr "模拟事件服务器也是为 `@NativeImageTest` 和 `@QuarkusIntegrationTest` 测试而启动的，所以也能与本地二进制文件一起工作。所有这些都提供了类似于SAM CLI本地测试的功能，而没有Docker的开销。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:163
#, fuzzy
msgid "Finally, if port 8080 or port 8081 is not available on your computer, you can modify the dev and test mode ports with application.properties"
msgstr "最后，如果端口8080或端口8081在你的电脑上不可用，你可以用application.properties修改dev和test模式的端口"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:168
#, no-wrap
msgid ""
"quarkus.lambda.mock-event-server.dev-port=8082\n"
"quarkus.lambda.mock-event-server.test-port=8083\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:171
#, fuzzy
msgid "A port value of zero will result in a randomly assigned port."
msgstr "端口值为零将导致随机分配的端口。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:172
#, fuzzy, no-wrap
msgid "Simulate Amazon Lambda Deployment with SAM CLI"
msgstr "用SAM CLI模拟亚马逊Lambda的部署"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:176
#, fuzzy
msgid "The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:"
msgstr "AWS SAM CLI允许你在笔记本电脑上模拟Lambda环境，在本地运行你的lambda。这需要安装Docker。在你建立了Maven项目后，执行这个命令。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:180
#, no-wrap
msgid "sam local start-api --template target/sam.jvm.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:184
#, fuzzy
msgid "This will start a Docker container that mimics Amazon's Lambda's deployment environment. Once the environment is started you can invoke the example lambda in your browser by going to:"
msgstr "这将启动一个Docker容器，模仿亚马逊Lambda的部署环境。一旦环境启动，你就可以在你的浏览器中调用示例lambda，方法是去。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:186
#, fuzzy
msgid "http://127.0.0.1:3000/hello"
msgstr " http://127.0.0.1:3000/hello "

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:189
#, fuzzy
msgid "In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java."
msgstr "在控制台，你会看到lambda的启动信息。这个特定的部署启动了一个JVM，并将你的lambda加载为纯Java。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:191
#, fuzzy, no-wrap
msgid "Deploy to AWS"
msgstr "部署到AWS"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:196
#, no-wrap
msgid "sam deploy -t target/sam.jvm.yaml -g\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:200
#, fuzzy
msgid "Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:"
msgstr "回答所有的问题，你的lambda将被部署，必要的钩子将被设置到API网关。如果一切部署成功，你的微服务的根URL将被输出到控制台。类似这样的情况。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:205
#, no-wrap
msgid ""
"Key                 LambdaHttpApi\n"
"Description         URL for application\n"
"Value               https://234asdf234as.execute-api.us-east-1.amazonaws.com/\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:208
#, fuzzy
msgid "The `Value` attribute is the root URL for your lambda. Copy it to your browser and add `hello` at the end."
msgstr " `Value` 属性是你的lambda的根URL。把它复制到你的浏览器，并在末尾添加 `hello` 。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:214
#, fuzzy
msgid "Responses for binary types will be automatically encoded with base64.  This is different than the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding."
msgstr "二进制类型的响应将被自动编码为base64。这与使用 `quarkus:dev` 的行为不同，后者将返回原始字节。亚马逊的API有额外的限制，要求使用base64编码。一般来说，客户端代码会自动处理这种编码，但在某些自定义情况下，你应该知道你可能需要手动管理这种编码。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:215
#, fuzzy, no-wrap
msgid "Deploying a native executable"
msgstr "部署一个本地可执行文件"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:218
#, fuzzy
msgid "To deploy a native executable, you must build it with GraalVM."
msgstr "要部署一个本地可执行文件，你必须用GraalVM构建它。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:222
#, fuzzy
msgid "You can then test the executable locally with sam local"
msgstr "然后你可以在本地用sam local测试可执行文件"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:226
#, no-wrap
msgid "sam local start-api --template target/sam.native.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:229
#, fuzzy
msgid "To deploy to AWS Lambda:"
msgstr "要部署到AWS Lambda。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:232
#, no-wrap
msgid "sam deploy -t target/sam.native.yaml -g\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:234
#, fuzzy, no-wrap
msgid "Examine the POM"
msgstr "考察POM"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:239
#, fuzzy
msgid "There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploy an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment."
msgstr "除了包含 `quarkus-amazon-lambda-http` 扩展（如果你要部署AWS Gateway HTTP API）或 `quarkus-amazon-lambda-rest` 扩展（如果你要部署AWS Gateway REST API）外，POM没有什么特别之处。这些扩展会自动生成你的lambda部署可能需要的一切。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:243
#, fuzzy
msgid "Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (JAX-RS, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment."
msgstr "另外，至少在生成的Maven原型 `pom.xml` 中， `quarkus-resteasy-reactive` 、 `quarkus-reactive-routes` 和 `quarkus-undertow` 依赖都是可选的。选择你想使用的HTTP框架（JAX-RS、Reactive Routes和/或Servlet），并删除其他依赖项以缩小部署规模。"

#. type: Title ===
#: upstream/_guides/amazon-lambda-http.adoc:244
#, fuzzy, no-wrap
msgid "Examine sam.yaml"
msgstr "检查sam.yaml"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:248
#, fuzzy
msgid "The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files."
msgstr " `sam.yaml` 语法已经超出了本文档的范围。有几件事情必须强调，以防你要制作你自己的自定义 `sam.yaml` 部署文件。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:251
#, fuzzy
msgid "The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name."
msgstr "首先要注意的是，对于纯Java的lambda部署需要一个特定的处理程序类。不要改变Lambda处理程序的名称。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:257
#, no-wrap
msgid ""
"     Properties:\n"
"        Handler: io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest\n"
"        Runtime: java11\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:260
#, fuzzy
msgid "This handler is a bridge between the lambda runtime and the Quarkus HTTP framework you are using (JAX-RS, Servlet, etc.)"
msgstr "这个处理程序是lambda运行时和你正在使用的Quarkus HTTP框架（JAX-RS、Servlet等）之间的桥梁。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:263
#, fuzzy
msgid "If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:"
msgstr "如果你想使用本地程序，有一个环境变量必须为本地GraalVM部署而设置。如果你看一下 `sam.native.yaml` ，你会看到这个。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:269
#, no-wrap
msgid ""
"        Environment:\n"
"          Variables:\n"
"            DISABLE_SIGNAL_HANDLERS: true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:272
#, fuzzy
msgid "This environment variable resolves some incompatibilities between Quarkus and the Amazon Lambda Custom Runtime environment."
msgstr "这个环境变量解决了Quarkus和Amazon Lambda Custom Runtime环境之间的一些不兼容问题。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:277
#, fuzzy
msgid "Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:"
msgstr "最后，对于AWS Gateway REST API的部署，有一件特别的事情。该API假定HTTP响应体是文本，除非你通过配置明确告诉它哪些媒体类型是二进制。为了使事情更简单，Quarkus扩展强制对所有的HTTP响应信息进行二进制（base 64）编码， `sam.yaml` 文件必须配置API网关，以假设所有的媒体类型都是二进制。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:285
#, no-wrap
msgid ""
"  Globals:\n"
"    Api:\n"
"      EndpointConfiguration: REGIONAL\n"
"      BinaryMediaTypes:\n"
"        - \"*/*\"\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:287
#, fuzzy, no-wrap
msgid "Injectable AWS Context Variables"
msgstr "可注射的AWS上下文变量"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:291
#, fuzzy
msgid "If you are using RESTEasy Reactive and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes using the JAX-RS `@Context` annotation or anywhere else with the CDI `@Inject` annotation."
msgstr "如果您使用RESTEasy Reactive和JAX-RS，您可以使用JAX-RS `@Context` 注解将各种AWS Context变量注入JAX-RS资源类中，或者在其他地方使用CDI `@Inject` 注解。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:294
#, fuzzy
msgid "For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:"
msgstr "对于AWS HTTP API，你可以注入AWS变量 `com.amazonaws.services.lambda.runtime.Context` 和 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` 。下面是一个例子。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:299
#, no-wrap
msgid ""
"import javax.ws.rs.core.Context;\n"
"import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:305
#: upstream/_guides/amazon-lambda-http.adoc:330
#, no-wrap
msgid ""
"@Path(\"/myresource\")\n"
"public class MyResource {\n"
"    @GET\n"
"    public String ctx(@Context com.amazonaws.services.lambda.runtime.Context ctx) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:308
#, no-wrap
msgid ""
"    @GET\n"
"    public String event(@Context APIGatewayV2HTTPEvent event) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:311
#, no-wrap
msgid ""
"    @GET\n"
"    public String requestContext(@Context APIGatewayV2HTTPEvent.RequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:314
#: upstream/_guides/amazon-lambda-http.adoc:338
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:318
#, fuzzy
msgid "For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:"
msgstr "对于AWS REST API，你可以注入AWS变量 `com.amazonaws.services.lambda.runtime.Context` 和 `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext` 。下面是一个例子。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:324
#, no-wrap
msgid ""
"import javax.ws.rs.core.Context;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:333
#, no-wrap
msgid ""
"    @GET\n"
"    public String reqContext(@Context AwsProxyRequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:336
#, no-wrap
msgid ""
"    @GET\n"
"    public String req(@Context AwsProxyRequest req) { }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:340
#, fuzzy, no-wrap
msgid "Tracing with AWS XRay and GraalVM"
msgstr "用AWS XRay和GraalVM进行追踪"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:345
#, fuzzy
msgid "If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work."
msgstr "如果你正在构建本地图像，并希望在你的lambda中使用 link:https://aws.amazon.com/xray[AWS X-Ray Tracing] ，你将需要在你的pom中把 `quarkus-amazon-lambda-xray` 作为一个依赖项。AWS X-Ray库与GraalVM并不完全兼容，所以我们不得不做一些整合工作来使其发挥作用。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:346
#, fuzzy, no-wrap
msgid "Security Integration"
msgstr "安全集成"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:351
#, fuzzy
msgid "When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (JAX-RS, servlet, Reactive Routes)."
msgstr "当你在API网关上调用一个HTTP请求时，网关会把这个HTTP请求变成一个JSON事件文档，并转发给Quarkus Lambda。Quarkus Lambda解析这个json并将其转换为HTTP请求的内部表示，可以被Quarkus支持的任何HTTP框架（JAX-RS、servlet、Reactive Routes）所消费。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:358
#, fuzzy
msgid "API Gateway supports many different ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in JAX-RS by injecting a `javax.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information."
msgstr "API Gateway支持许多不同的方式在你的HTTP端点上安全地调用，这些端点是由Lambda和Quarkus支持的。如果你启用了它，Quarkus会自动解析 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[事件json文档] 的相关部分，寻找基于安全的元数据，并在内部注册一个 `java.security.Principal` ，通过注入 `javax.ws.rs.core.SecurityContext` ，通过Servlet中的 `HttpServletRequest.getUserPrincipal()` ，以及Reactive Routes中的 `RouteContext.user()` ，可以在JAX-RS中查询到。如果你想要更多的安全信息， `Principal` 对象可以被类型化到一个能给你更多信息的类。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:360
#, fuzzy
msgid "To enable this security feature, add this to your `application.properties` file:"
msgstr "要启用这一安全功能，请将此添加到你的 `application.properties` 文件。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:362
#, no-wrap
msgid "quarkus.lambda-http.enable-security=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:366
#, fuzzy
msgid "Here's how its mapped:"
msgstr "下面是它的映射方式。"

#. type: Block title
#: upstream/_guides/amazon-lambda-http.adoc:367
#: upstream/_guides/amazon-lambda-http.adoc:396
#, fuzzy, no-wrap
msgid "HTTP `quarkus-amazon-lambda-http`"
msgstr "HTTP `quarkus-amazon-lambda-http` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:370
#: upstream/_guides/amazon-lambda-http.adoc:380
#, fuzzy, no-wrap
msgid "Auth Type"
msgstr "授权类型"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:370
#: upstream/_guides/amazon-lambda-http.adoc:380
#, fuzzy, no-wrap
msgid "Principal Class"
msgstr "主要类别"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:371
#: upstream/_guides/amazon-lambda-http.adoc:381
#, fuzzy, no-wrap
msgid "Json path of Principal Name"
msgstr "校长姓名的Json路径"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:371
#, fuzzy, no-wrap
msgid "Cognito JWT"
msgstr "Cognito JWT"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:371
#: upstream/_guides/amazon-lambda-http.adoc:381
#, fuzzy, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CognitoPrincipal`"
msgstr " `io.quarkus.amazon.lambda.http.CognitoPrincipal` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:372
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.jwt.claims.cognito:username`"
msgstr " `requestContext.authorizer.jwt.claims.cognito:username` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:372
#: upstream/_guides/amazon-lambda-http.adoc:382
#, fuzzy, no-wrap
msgid "IAM"
msgstr "IAM"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:372
#: upstream/_guides/amazon-lambda-http.adoc:382
#, fuzzy, no-wrap
msgid "`io.quarkus.amazon.lambda.http.IAMPrincipal`"
msgstr " `io.quarkus.amazon.lambda.http.IAMPrincipal` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:373
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.iam.userId`"
msgstr " `requestContext.authorizer.iam.userId` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:373
#: upstream/_guides/amazon-lambda-http.adoc:383
#, fuzzy, no-wrap
msgid "Custom Lambda"
msgstr "自定义Lambda"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:373
#: upstream/_guides/amazon-lambda-http.adoc:383
#, fuzzy, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CustomPrincipal`"
msgstr " `io.quarkus.amazon.lambda.http.CustomPrincipal` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:375
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.lambda.principalId`"
msgstr " `requestContext.authorizer.lambda.principalId` "

#. type: Block title
#: upstream/_guides/amazon-lambda-http.adoc:377
#: upstream/_guides/amazon-lambda-http.adoc:437
#, fuzzy, no-wrap
msgid "REST `quarkus-amazon-lambda-rest`"
msgstr "REST `quarkus-amazon-lambda-rest` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:381
#, fuzzy, no-wrap
msgid "Cognito"
msgstr "识别"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:382
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.claims.cognito:username`"
msgstr " `requestContext.authorizer.claims.cognito:username` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:383
#, fuzzy, no-wrap
msgid "`requestContext.identity.user`"
msgstr " `requestContext.identity.user` "

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:385
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.principalId`"
msgstr " `requestContext.authorizer.principalId` "

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:387
#, fuzzy, no-wrap
msgid "Custom Security Integration"
msgstr "定制安全集成"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:395
#, fuzzy
msgid "The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have can full control how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration."
msgstr "对AWS安全的默认支持只是将委托人的名字映射到Quarkus安全API上，并没有对索赔、角色或权限进行映射。你可以使用 `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` 接口的实现来完全控制lambda HTTP事件中的安全元数据如何被映射到Quarkus安全API。通过实现这个接口，你可以做一些事情，比如为你的委托人定义角色映射，或者发布由IAM或Cognito或你的Custom Lambda安全集成提供的额外属性。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:400
#: upstream/_guides/amazon-lambda-http.adoc:441
#, no-wrap
msgid "package io.quarkus.amazon.lambda.http;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:410
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"    @Override\n"
"    default public Class<LambdaAuthenticationRequest> getRequestType() {\n"
"        return LambdaAuthenticationRequest.class;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:420
#, no-wrap
msgid ""
"    @Override\n"
"    default Uni<SecurityIdentity> authenticate(LambdaAuthenticationRequest request, AuthenticationRequestContext context) {\n"
"        APIGatewayV2HTTPEvent event = request.getEvent();\n"
"        SecurityIdentity identity = authenticate(event);\n"
"        if (identity == null) {\n"
"            return Uni.createFrom().optional(Optional.empty());\n"
"        }\n"
"        return Uni.createFrom().item(identity);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:432
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:436
#, fuzzy
msgid "For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`"
msgstr "对于HTTP，要覆盖的重要方法是 `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)` 。在此，你将根据你想要的方式分配一个SecurityIdentity，以映射安全数据，从 `APIGatewayV2HTTPEvent` "

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:443
#, no-wrap
msgid "import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:451
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
"import io.quarkus.security.identity.AuthenticationRequestContext;\n"
"import io.quarkus.security.identity.IdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:458
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:470
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:474
msgid "For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`."
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:476
msgid "Your implemented provider must be a CDI bean.  Here's an example:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:480
#: upstream/_guides/amazon-lambda-http.adoc:511
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:482
#: upstream/_guides/amazon-lambda-http.adoc:513
#, no-wrap
msgid "import java.security.Principal;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:484
#: upstream/_guides/amazon-lambda-http.adoc:515
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:491
#: upstream/_guides/amazon-lambda-http.adoc:522
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.LambdaIdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.quarkus.security.runtime.QuarkusPrincipal;\n"
"import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:504
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        if (event.getHeaders() == null || !event.getHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getHeaders().get(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:507
msgid "Here's the same example, but with the AWS Gateway REST API:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:517
#, no-wrap
msgid "import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:535
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        if (event.getMultiValueHeaders() == null || !event.getMultiValueHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getMultiValueHeaders().getFirst(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:539
msgid "Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier."
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:540
#, no-wrap
msgid "Simple SAM Local Principal"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:544
msgid "If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable"
msgstr ""
