# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-05-12 15:58+0000\n"
"PO-Revision-Date: 2022-05-29 23:35+0800\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:6
#, no-wrap
msgid "Quarkus - Getting started with Reactive"
msgstr "Quarkus - 响应式入门"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:12
msgid "Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:"
msgstr "了解如何使用Quarkus创建响应式应用程序，并探索Quarkus提供的不同响应式功能。 本指南涵盖："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:14
msgid "A quick glance at the Quarkus engine and how it enables reactive"
msgstr "快速浏览一下Quarkus引擎和它如何实现响应式"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:15
msgid "A brief introduction to Mutiny - the reactive programming library used by Quarkus"
msgstr "Mutiny的简要介绍 - Quarkus使用的响应式编程库"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:16
msgid "The difference between RESTEasy, RESTEasy Reactive and Reactive Routes"
msgstr "RESTEasy、RESTEasy Reactive 和 Reactive Routes 之间的区别"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:17
msgid "The bootstrap of a reactive application using RESTEasy Reactive"
msgstr "使用 RESTEasy Reactive 的响应式应用程序的引导"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:18
msgid "Creating a reactive JAX-RS endpoint (asynchronous, streams...)"
msgstr "创建响应式 JAX-RS 端点（异步、流等）"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:19
msgid "Using reactive database access"
msgstr "使用响应式数据库访问"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:20
msgid "Interacting with other reactive APIs"
msgstr "与其他响应式API交互"

#. type: Title ==
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:21
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:24
msgid "To complete this guide, you need:"
msgstr "要完成这个指南，你需要："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:26
msgid "less than 15 minutes"
msgstr "不到15分钟"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:27
msgid "an IDE"
msgstr "一个IDE"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:28
msgid "JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 8 或 11+安装并适当配置了 `JAVA_HOME`"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:29
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Title ==
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:30
#, no-wrap
msgid "Solutions"
msgstr "解决方案"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:33
msgid "We recommend that you follow the instructions from <<bootstrapping-the-project,Bootstrapping project>> and onwards to create the application step by step."
msgstr "我们建议您按照从 <<bootstrapping-the-project,Bootstrapping project>> 开始的指示，一步一步地创建应用程序。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:35
msgid "However, you can go right to the completed example."
msgstr "不过，您也可以直接进入完成的例子。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:37
msgid "Download an {quickstarts-archive-url}[archive] or clone the git repository:"
msgstr "下载一个 {quickstarts-archive-url}[存档]或克隆git仓库："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:41
#, no-wrap
msgid "git clone {quickstarts-clone-url}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:44
msgid "The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories."
msgstr "解决方案位于 `getting-started-reactive` 和 `getting-started-reactive-crud` 目录中。"

#. type: Title ==
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:45
#, no-wrap
msgid "The multiple reactive facets of Quarkus"
msgstr "Quarkus的多响应式方面特征"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:51
msgid "Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine."
msgstr "Quarkus是响应式的。如果您仔细观察，就会发现一个为Quarkus应用程序提供动力的响应式引擎。这个引擎就是Eclipse Vert.x (https://vertx.io)。所有网络I/O都通过非阻塞和响应性的 Vert.x 引擎。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:53
msgid "image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 70%]"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:61
msgid "Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread."
msgstr "让我们举两个例子来解释它是如何工作的。想象一个传入的HTTP请求。嵌入在Quarkus中的 (Vert.x) HTTP服务器接收请求，然后将其路由到应用程序。如果请求的目标是一个 _imperative_ 方法（传统的JAX-RS，代码注释为 `@Blocking`…），路由层在 _worker_ 线程中调用资源方法，并在数据可用时写入响应。到目前为止，还没有什么新的或突出的。下图描述了这种行为。在这种情况下，应用程序代码是在工作线程上调用的，而业务逻辑会阻塞该线程。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:63
msgid "image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 70%]"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:65
msgid "But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:"
msgstr "但是，如果HTTP请求的目标是一个响应式方法（JAX-RS使用RESTEasy响应式，响应式路由， `@Incoming` 方法没有注释 `@Blocking`…），路由层会在I/O线程上调用路由，这会带来很多好处，比如更高的并发性和性能："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:67
msgid "image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 70%]"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:74
msgid "Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread."
msgstr "因为Quarkus使用I/O线程来调用代码，所以我们节省了上下文切换，避免了大型线程池管理，从而提高了资源利用率。但是，代码必须 **NOT** 阻塞该线程。为什么？因为，I/O线程用于处理多个并发请求。一旦一个请求的处理因为需要执行一些I/O而无法进行，它就会调度这些I/O，并传递一个延续。它释放可以处理另一个请求的线程。当计划的I/O完成时，继续执行，返回到I/O线程。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:78
msgid "As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon."
msgstr "因此，许多Quarkus组件在设计时都考虑了响应式，比如数据库访问（PostgreSQL, MySQL, Mongo等），应用服务（邮件，模板引擎等），消息传递（Kafka, AMQP等）等等。但是，要完全受益于此模型，应用程序代码应该以非阻塞的方式编写。这就是运用一个响应式API这个终极武器的地方。"

#. type: Title ==
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:80
#, no-wrap
msgid "Mutiny - A reactive programming library"
msgstr "Mutiny - 一个响应式编程库"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:84
msgid "https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:"
msgstr "https://github.com/smallrye/smallrye-mutiny[Mutiny]是一个响应式编程库，允许表达和组合异步动作。它提供两种类型："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:86
msgid "`io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result"
msgstr "`io.smallrye.mutiny.Uni` - 用于提供0或1结果的异步操作"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:87
msgid "`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams"
msgstr "`io.smallrye.mutiny.Multi` - 用于多条目(回压)流"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:90
msgid "Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists)."
msgstr "这两种类型都是惰性的，并且遵循订阅模式。计算只在有实际需要时才开始（即订阅者登记）。"

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:97
#, no-wrap
msgid ""
"uni.subscribe().with(\n"
"    result -> System.out.println(\"result is \" + result),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:102
#, no-wrap
msgid ""
"multi.subscribe().with(\n"
"    item -> System.out.println(\"Got \" + item),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:108
msgid "Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive."
msgstr " `Uni` 和 `Multi` 都公开了事件驱动的API：你表达了在给定事件上你想做什么(成功，失败等)。这些API被分成组（操作类型），以使其更具表达性，并避免将100个方法附加到单个类上。主要的操作类型是对失败、完成、操作项、提取或收集它们作出反应。它提供了一种流畅的编码体验，具有可导航的API，并且结果不需要太多关于响应式的知识。"

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:113
#, no-wrap
msgid ""
"httpCall\n"
"    .onFailure().recoverWithItem(\"my fallback\");\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:119
msgid "You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex."
msgstr "你可能想知道响应流 (https://www.reactive-streams.org/)。  `Multi` 实现了响应流 `Publisher`，因此实现了响应流回压机制。  `Uni` 没有实现 `Publisher` ，因为' Uni '的订阅足以表明你对结果感兴趣。由于响应流的订阅/请求仪式更加复杂，所以它再次考虑了更简单、更流畅的API。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:122
msgid "Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`."
msgstr "拥抱来自Quarkus的响应和指令支柱的统一， `Uni` 和 `Multi` 都为指令式结构提供了桥梁。例如，你可以将 `Multi` 转换为 `Iterable` ，或者 _await_ `Uni` 生成元素。"

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:127
#, no-wrap
msgid ""
"// Block until the result is available\n"
"String result = uni.await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:130
#, no-wrap
msgid ""
"// Transform an asynchronous stream into a blocking iterable\n"
"stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:134
msgid "At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:"
msgstr "在这一点上，如果你是RxJava或Reactor的用户，你可能想知道如何使用你熟悉的 `Flowable`，`Single`，`Flux`，`Mono`… Mutiny允许从 `Unis` 和 `Multis` 到RX Java和Reactor类型的转换："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:139
#, no-wrap
msgid ""
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:144
msgid "But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:"
msgstr "但是，Vert.x呢？Vert.x API也可以使用Mutiny类型。下面的代码片段展示了Vert.x Web 客户端的用法："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:164
#, no-wrap
msgid ""
"// Use io.vertx.mutiny.ext.web.client.WebClient\n"
"client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"// ...\n"
"Uni<JsonObject> uni =\n"
"    client.get(\"/api/fruit/\" + name)\n"
"        .send()\n"
"        .onItem().transform(resp -> {\n"
"            if (resp.statusCode() == 200) {\n"
"                return resp.bodyAsJsonObject();\n"
"            } else {\n"
"                return new JsonObject()\n"
"                        .put(\"code\", resp.statusCode())\n"
"                        .put(\"message\", resp.bodyAsString());\n"
"            }\n"
"        });\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:167
msgid "Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline."
msgstr "最后但并非最不重要的是，Mutiny内置了与MicroProfile上下文传播的集成，因此您可以在响应管道中传播事务、跟踪数据等。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:169
msgid "But enough talking, let's get our hands dirty!"
msgstr "说得够多了，我们动手吧！"

#. type: Title ==
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:170
#, no-wrap
msgid "Bootstrapping the project"
msgstr "创建项目"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:175
msgid "There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread."
msgstr "使用Quarkus实现响应式应用程序有几种方法。在本指南中，我们将使用RESTEasy Reactive，一个受益于Quarkus Reactive引擎的RESTEasy的实现。默认情况下，它调用I/O线程上的HTTP端点。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:178
msgid "While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose."
msgstr "虽然可以使用_traditional_ RESTEasy，但需要添加 `quarkus-resteasy-mutiny` 扩展，该方法仍然会在 _worker_ 线程上调用。因此，虽然它将使用响应式编程，但仍然需要工作线程，这与目的不符。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:180
msgid "The easiest way to create a new Quarkus project is to open a terminal and run the following command:"
msgstr "创建一个新的Quarkus项目最简单的方法是打开终端并运行以下命令："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:182
msgid "For Linux and macOS users"
msgstr "对于Linux和macOS用户"

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:192
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive \\\n"
"    -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" \\\n"
"    -Dpath=\"/hello\" \\\n"
"    -Dextensions=\"resteasy-reactive\"\n"
"cd getting-started-reactive\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:195
msgid "For Windows users"
msgstr "对于Windows用户"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:197
msgid "If using cmd, (don't use forward slash `\\`)"
msgstr "如果使用cmd，（不要使用正斜杠 `\\`）"

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:201
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:204
msgid "If using Powershell, wrap `-D` parameters in double quotes"
msgstr "如果使用Powershell，请将 `-D` 参数用双引号括起来"

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:208
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.getting.started.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:211
msgid "It generates the following in `./getting-started-reactive`:"
msgstr "它会在 `./getting-started-reactive`中生成如下内容："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:213
msgid "the Maven structure"
msgstr "关于Maven结构"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:214
msgid "an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`"
msgstr "一个 `org.acme.quickstart.ReactiveGreetingResource` 资源暴露 `/hello`"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:215
msgid "an associated unit test"
msgstr "关联的单元测试"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:216
msgid "a landing page that is accessible on `http://localhost:8080` after starting the application"
msgstr "启动应用程序后，可在 `http://localhost:8080` 上访问登录页面"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:217
msgid "example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`"
msgstr "示例 `Dockerfile` 文件位于 `src/main/docker`，用于 `native` 和 `jvm` 两种模式"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:218
msgid "the application configuration file"
msgstr "应用程序配置文件"

#. type: Title ===
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:219
#, no-wrap
msgid "Reactive JAX-RS resources"
msgstr "响应式 JAX-RS 资源"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:222
msgid "During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:"
msgstr "在项目创建过程中， `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` 文件已经创建了以下内容："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:226
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:269
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:291
#, no-wrap
msgid "package org.acme.getting.started;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:231
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:234
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:304
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:241
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello RESTEasy Reactive\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:245
msgid "It's a very simple REST endpoint, returning \"Hello RESTEasy Reactive\" to requests on \"/hello\".  As it uses RESTEAsy Reactive, this method is called on the I/O thread."
msgstr "这是一个非常简单的REST端点，在 \"/hello\"上返回 \"Hello RESTEasy Reactive\" 请求。当它使用RESTEAsy响应式时，这个方法在I/O线程上被调用。"

#. type: delimited block =
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:250
msgid "To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:"
msgstr "要让Quarkus在_worker_线程上调用这个方法，请使用 `io.smallrye.common.annotation.Blocking` 注释它。你可以在一个方法、类上使用 ' @Blocking '，或者在整个应用中通过注释一个 `Application` 类来启用它："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:256
#, no-wrap
msgid ""
"import javax.ws.rs.ApplicationPath;\n"
"import javax.ws.rs.core.Application;\n"
"import io.smallrye.common.annotation.Blocking;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:261
#, no-wrap
msgid ""
"@ApplicationPath(\"/\")\n"
"@Blocking\n"
"public class RestBlockingApplication extends Application {\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:265
msgid "Let's now create a `ReactiveGreetingService` class with the following content:"
msgstr "现在让我们创建一个 `ReactiveGreetingService` 类，包含以下内容："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:272
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:275
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:278
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveGreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:284
#, no-wrap
msgid ""
"    public Uni<String> greeting(String name) {\n"
"        return Uni.createFrom().item(name)\n"
"                .onItem().transform(n -> String.format(\"hello %s\", n));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:287
msgid "Then, edit the `ReactiveGreetingResource` class to match the following content:"
msgstr "然后，编辑 `ReactiveGreetingResource` 类，以匹配以下内容："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:297
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:301
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:307
#, no-wrap
msgid ""
"    @Inject\n"
"    ReactiveGreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:314
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"/greeting/{name}\")\n"
"    public Uni<String> greeting(String name) {\n"
"        return service.greeting(name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:321
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:326
msgid "The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide."
msgstr "`ReactiveGreetingService` 类包含一个生成 `Uni` 的简单方法。虽然在这个例子中，产生的条目是立即发出的，你可以想象任何异步API产生一个 `Uni`。我们将在本指南的后面讨论这个问题。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:328
msgid "Now, start the application using:"
msgstr "现在，使用以下命令启动应用程序："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:332
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:335
msgid "Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo."
msgstr "运行后，通过打开 http://localhost:8080/hello/greeting/neo 检查您是否得到了预期的问候信息。"

#. type: Title ==
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:336
#, no-wrap
msgid "Handling streams"
msgstr "处理流"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:340
msgid "So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages."
msgstr "到目前为止，我们只返回一个异步结果。在本节中，我们使用传输多个条目的流来扩展应用程序。这些数据流可以来自Kafka或任何其他数据源，但为了简单起见，我们只生成周期性的问候消息。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:342
msgid "In the `ReactiveGreetingService`, add the following method:"
msgstr "在 `ReactiveGreetingService` 中，添加以下方法："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:350
#, no-wrap
msgid ""
"public Multi<String> greetings(int count, String name) {\n"
"  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .onItem().transform(n -> String.format(\"hello %s - %d\", name, n))\n"
"        .transform().byTakingFirstItems(count);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:353
msgid "you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements."
msgstr "你可能需要添加 `import io.smallrye.mutiny.Multi;` 和 `import java.time.Duration;` 语句。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:355
msgid "It generates a greeting message every second and stops after `count` messages."
msgstr "它每秒钟生成一条问候信息，并在 `count` 信息后停止。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:357
msgid "In the `ReactiveGreetingResource` add the following method:"
msgstr "在 `ReactiveGreetingResource` 中添加以下方法："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:366
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Path(\"/greeting/{count}/{name}\")\n"
"public Multi<String> greetings(int count, String name) {\n"
"  return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:370
msgid "This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters."
msgstr "这个端点将项目以JSON数组的形式发送给客户端。消息的名称和数量用路径参数进行参数化。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:372
msgid "So calling the endpoint produces something like:"
msgstr "所以调用端点会产生如下结果："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:377
#, no-wrap
msgid ""
"$ curl http://localhost:8080/hello/greeting/3/neo\n"
"[\"hello neo - 0\", \"hello neo - 1\", \"hello neo - 2\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:380
msgid "We can also generate Server-Sent Event responses by returning a `Multi`:"
msgstr "我们也可以通过返回一个 `Multi` 来生成服务器发送的事件响应："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:390
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@RestSseElementType(MediaType.TEXT_PLAIN)\n"
"@Path(\"/stream/{count}/{name}\")\n"
"public Multi<String> greetingsAsStream(int count, String name) {\n"
"    return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:394
msgid "The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event."
msgstr "与前面代码片段唯一的区别是生成的类型和指示每个事件类型的 `@RestSseElementType` 注解。由于 `@Produces` 注解定义了 `SERVER_SENT_EVENTS`，JAX-RS需要它知道每个（嵌套）事件的内容类型。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:396
msgid "You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement."
msgstr "你可能需要添加 `import org.jboss.resteasy.reactive.RestSseElementType;` 语句。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:398
msgid "You can see the result using:"
msgstr "你可以使用以下命令看到结果："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:403
#, no-wrap
msgid ""
"$ curl -N http://localhost:8080/hello/stream/5/neo\n"
"data: hello neo - 0\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:405
#, no-wrap
msgid "data: hello neo - 1\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:407
#, no-wrap
msgid "data: hello neo - 2\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:409
#, no-wrap
msgid "data: hello neo - 3\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:411
#, no-wrap
msgid "data: hello neo - 4\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:413
#, no-wrap
msgid "Using Reactive APIs"
msgstr "使用响应式 API"

#. type: Title ===
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:415
#, no-wrap
msgid "Using Quarkus reactive APIs"
msgstr "使用Quarkus响应式API"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:419
msgid "Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way."
msgstr "Quarkus使用Mutiny模型提供了许多响应式API。在本节中，我们将看到如何使用响应式PostgreSQL驱动程序以一种非阻塞和响应式的方式与数据库交互。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:421
msgid "Create a new project using:"
msgstr "使用以下命令创建一个新项目："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:431
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive-crud \\\n"
"    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-reactive,resteasy-reactive-jackson,reactive-pg-client\"\n"
"cd getting-started-reactive-crud\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:434
msgid "This application is interacting with a PostgreSQL database, so you need one:"
msgstr "这个应用程序与一个PostgreSQL数据库交互，所以你需要一个："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:441
#, no-wrap
msgid ""
"docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n"
"           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n"
"           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n"
"           -p 5432:5432 postgres:11.2\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:445
msgid "Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:"
msgstr "然后，让我们配置数据源。打开 `src/main/resources/application.properties` 并添加以下内容："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:453
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus_test\n"
"quarkus.datasource.password=quarkus_test\n"
"quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n"
"myapp.schema.create=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:457
msgid "The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized."
msgstr "第3行定义数据源。最后一行将在应用程序中用于指示在应用程序初始化时是否插入一些条目。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:460
msgid "Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:"
msgstr "现在，让我们创建 _entity_。创建 `org.acme.reactive.crud.Fruit` 类具有以下内容："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:464
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:538
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:581
#, no-wrap
msgid "package org.acme.reactive.crud;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:471
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import io.vertx.mutiny.sqlclient.Row;\n"
"import io.vertx.mutiny.sqlclient.RowSet;\n"
"import io.vertx.mutiny.sqlclient.Tuple;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:473
#, no-wrap
msgid "import java.util.stream.StreamSupport;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:475
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:477
#, no-wrap
msgid "    public Long id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:479
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:483
#, no-wrap
msgid ""
"    public Fruit() {\n"
"        // default constructor.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:487
#, no-wrap
msgid ""
"    public Fruit(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:492
#, no-wrap
msgid ""
"    public Fruit(Long id, String name) {\n"
"        this.id = id;\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:500
#, no-wrap
msgid ""
"    public static Multi<Fruit> findAll(PgPool client) {\n"
"        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\").execute()\n"
"                // Create a Multi from the set of rows:\n"
"                .onItem().transformToMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n"
"                // For each row create a fruit instance\n"
"                .onItem().transform(Fruit::from);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:506
#, no-wrap
msgid ""
"    public static Uni<Fruit> findById(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"                .onItem().transform(RowSet::iterator)\n"
"                .onItem().transform(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:511
#, no-wrap
msgid ""
"    public Uni<Long> save(PgPool client) {\n"
"        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\").execute(Tuple.of(name))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:516
#, no-wrap
msgid ""
"    public Uni<Boolean> update(PgPool client) {\n"
"        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\").execute(Tuple.of(name, id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:521
#, no-wrap
msgid ""
"    public static Uni<Boolean> delete(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:526
#, no-wrap
msgid ""
"    private static Fruit from(Row row) {\n"
"        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:532
msgid "This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects."
msgstr "这个 _entity_ 包含一些字段和方法，用于从数据库中查找、更新和删除行。当检索到结果时，所生成的项被异步触发，这些方法返回 `Unis` 或 `Multis` 。注意，响应式PostgreSQL客户端已经提供了 `Uni` 和 `Multi` 实例。因此，您只需将来自数据库的结果转换为 _business-friendly_ 对象。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:534
msgid "For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:"
msgstr "为了在应用程序启动时初始化数据库，我们将创建一个名为 `DBInit` 的类，其内容如下："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:542
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:545
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:548
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class DBInit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:551
#, no-wrap
msgid ""
"    private final PgPool client;\n"
"    private final boolean schemaCreate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:556
#, no-wrap
msgid ""
"    public DBInit(PgPool client, @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\") boolean schemaCreate) {\n"
"        this.client = client;\n"
"        this.schemaCreate = schemaCreate;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:562
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent ev) {\n"
"        if (schemaCreate) {\n"
"            initdb();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:573
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:577
msgid "Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:"
msgstr "然后，让我们在 `FruitResource` 中使用这个 `Fruit` 类。编辑 `FruitResource` 类，匹配以下内容："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:583
#, no-wrap
msgid "import java.net.URI;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:595
#, no-wrap
msgid ""
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.DELETE;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.PUT;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.ResponseBuilder;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:599
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:604
#, no-wrap
msgid ""
"@Path(\"fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:606
#, no-wrap
msgid "    private final PgPool client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:610
#, no-wrap
msgid ""
"    public FruitResource(PgPool client) {\n"
"        this.client = client;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:620
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:625
#, no-wrap
msgid ""
"    @GET\n"
"    public Multi<Fruit> get() {\n"
"        return Fruit.findAll(client);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:633
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> getSingle(Long id) {\n"
"        return Fruit.findById(client, id)\n"
"                .onItem().transform(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n"
"                .onItem().transform(ResponseBuilder::build);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:640
#, no-wrap
msgid ""
"    @POST\n"
"    public Uni<Response> create(Fruit fruit) {\n"
"        return fruit.save(client)\n"
"                .onItem().transform(id -> URI.create(\"/fruits/\" + id))\n"
"                .onItem().transform(uri -> Response.created(uri).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:648
#, no-wrap
msgid ""
"    @PUT\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> update(Long id, Fruit fruit) {\n"
"        return fruit.update(client)\n"
"                .onItem().transform(updated -> updated ? Status.OK : Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:657
#, no-wrap
msgid ""
"    @DELETE\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> delete(Long id) {\n"
"        return Fruit.delete(client, id)\n"
"                .onItem().transform(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status).build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:660
msgid "This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class."
msgstr "这个资源根据 `Fruit` 类产生的结果返回 `Uni` 和 `Multi` 实例。"

#. type: Title ===
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:661
#, no-wrap
msgid "Using Vert.x clients"
msgstr "使用 Vert.x 客户端"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:665
msgid "The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly."
msgstr "前面的示例使用了Quarkus提供的_service_。同样，你也可以直接使用Vert.x客户端。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:667
msgid "First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:"
msgstr "首先，确保存在 `quarkus-vertx` 扩展。如果没有激活扩展，请执行如下命令来激活："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:672
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:add-extensions \\\n"
"    -Dextensions=vertx\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:675
msgid "Or add `quarkus-vertx` into your dependencies manually."
msgstr "或者手动将 `quarkus-vertx` 添加到依赖项中。"

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:682
#, no-wrap
msgid ""
"<dependency>\n"
"\t<groupId>io.quarkus</groupId>\n"
"\t<artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:686
msgid "There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:"
msgstr "有一个Mutiny 版本的Vert.x的API。这个API被分为几个可以独立导入的工件："

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:688
#, no-wrap
msgid "groupId:artifactId"
msgstr "项目包名:工程名"

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:690
#, no-wrap
msgid "Description"
msgstr "描述"

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:691
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-core`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:693
#, no-wrap
msgid "Mutiny API for Vert.x Core"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:694
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:696
#, no-wrap
msgid "Mutiny API for the Vert.x Mail Client"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:697
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:699
#, no-wrap
msgid "Mutiny API for the Vert.x Web Client"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:700
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:702
#, no-wrap
msgid "Mutiny API for the Vert.x Mongo Client"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:703
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:705
#, no-wrap
msgid "Mutiny API for the Vert.x Redis Client"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:706
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:708
#, no-wrap
msgid "Mutiny API for the Vert.x Cassandra Client"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:709
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:711
#, no-wrap
msgid "Mutiny API for the Vert.x Consul Client"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:712
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:714
#, no-wrap
msgid "Mutiny API for the Vert.x Kafka Client"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:715
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:717
#, no-wrap
msgid "Mutiny API for the Vert.x AMQP Client"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:718
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`"
msgstr ""

#. type: Table
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:719
#, no-wrap
msgid "Mutiny API for the Vert.x RabbitMQ Client"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:722
msgid "You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/."
msgstr "您还可以在 http://smallrye.io/smallrye-reactive-utils/apidocs/ 上查看可用的API。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:725
msgid "Let's take an example.  Add the following dependency to your application:"
msgstr "我们举个例子。添加以下依赖到你的应用程序："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:732
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:736
msgid "It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:"
msgstr "它提供了Vert.x Web客户端的Mutiny API。然后，您可以使用如下web客户端："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:740
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:747
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.ext.web.client.WebClientOptions;\n"
"import io.vertx.mutiny.core.Vertx;\n"
"import io.vertx.mutiny.ext.web.client.WebClient;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:754
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:757
#, no-wrap
msgid ""
"@Path(\"/fruit-data\")\n"
"public class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:760
#, no-wrap
msgid ""
"    @Inject\n"
"    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:762
#, no-wrap
msgid "    private WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:769
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void initialize() {\n"
"        this.client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:786
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    @Path(\"/{name}\")\n"
"    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n"
"        return client.get(\"/api/fruit/\" + name)\n"
"                .send()\n"
"                .map(resp -> {\n"
"                    if (resp.statusCode() == 200) {\n"
"                        return resp.bodyAsJsonObject();\n"
"                    } else {\n"
"                        return new JsonObject()\n"
"                                .put(\"code\", resp.statusCode())\n"
"                                .put(\"message\", resp.bodyAsString());\n"
"                    }\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:788
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:791
msgid "There are 2 important points:"
msgstr "有两点很重要："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:793
msgid "The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;"
msgstr "注入的 Vert.x 实例是 `io.vertx.mutiny.core.Vertx` 类型，它是 Vert.x 的 Mutiny 变量；"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:794
msgid "The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`."
msgstr "Web客户端是从 `io.vertx.mutiny.ext.web.client.WebClient` 创建的。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:796
msgid "The Mutiny version of the Vert.x APIs also offers:"
msgstr "Mutiny 版本的 Vert.x API 还提供："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:799
msgid "`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way."
msgstr "`andAwait` 方法，例如 `sendAndAwait`。 `andAwait` 表示调用方线程被阻塞，直到结果可用。注意不要用这种方式阻塞事件循环/ IO线程。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:803
msgid "`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription."
msgstr "`andForget` 方法，如 `writeAndForget`。 `andForget` 可用于返回 `Uni` 的方法。  `andForget` 表示你不需要结果的 `Uni` 来表示操作的成功或失败。但是请记住，如果您不订阅，操作将不会被触发。  `andForget` 为您管理这个和管理订阅。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:804
msgid "`toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`"
msgstr "`toMulti` 方法允许将一个 Vert.x `ReadStream` 转换为 `Multi`"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:805
msgid "`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`"
msgstr "`toBlockingIterable` / `toBlockingStream` 方法允许转换Vert.x `ReadStream` 写入阻塞的可迭代对象或阻塞的 `java.util.Stream`"

#. type: Title ===
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:806
#, no-wrap
msgid "Using RxJava or Reactor APIs"
msgstr "使用 RxJava 或 Reactor API"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:809
msgid "Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`."
msgstr "Mutiny提供工具来将 RxJava 2 和 Project Reactor 类型转换为 `Uni` 和 `Multi`。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:811
msgid "RxJava 2 converters are available in the following dependency:"
msgstr "RxJava 2转换器有以下依赖项："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:818
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-rxjava</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:821
msgid "So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:"
msgstr "因此，如果你有一个返回RxJava 2类型 (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`) 的API，你可以创建 `Unis` 和 `Multis` ，如下所示："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:833
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniRxConverters;\n"
"// ...\n"
"Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\n"
"Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\n"
"Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\n"
"Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\n"
"Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\n"
"Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:840
#, no-wrap
msgid ""
"Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\n"
"Multi<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\n"
"Multi<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\n"
"Multi<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n"
"Multi<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\n"
"Multi<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:843
msgid "You can also transform `Unis` and `Multis` into RxJava types:"
msgstr "你也可以将 `Unis` 和 `Multis` 转换成 RxJava 类型："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:860
#, no-wrap
msgid ""
"Completable completable = uni.convert().with(UniRxConverters.toCompletable());\n"
"Single<Optional<String>> single = uni.convert().with(UniRxConverters.toSingle());\n"
"Single<String> single2 = uni.convert().with(UniRxConverters.toSingle().failOnNull());\n"
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Observable<String> observable = uni.convert().with(UniRxConverters.toObservable());\n"
"Flowable<String> flowable = uni.convert().with(UniRxConverters.toFlowable());\n"
"// ...\n"
"Completable completable = multi.convert().with(MultiRxConverters.toCompletable());\n"
"Single<Optional<String>> single = multi.convert().with(MultiRxConverters.toSingle());\n"
"Single<String> single2 = multi.convert().with(MultiRxConverters\n"
"        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\n"
"Maybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\n"
"Observable<String> observable = multi.convert().with(MultiRxConverters.toObservable());\n"
"Flowable<String> flowable = multi.convert().with(MultiRxConverters.toFlowable());\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:863
msgid "Project Reactor converters are available in the following dependency:"
msgstr "项目 Reactor 转换器在以下依赖项中可用："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:870
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-reactor</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:873
msgid "So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:"
msgstr "那么如果你有一个API返回 Reactor 类型 (`Mono`, `Flux`)，你可以创建 `Unis` 和 `Multis` 如下："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:881
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n"
"// ...\n"
"Uni<String> uniFromMono = Uni.createFrom().converter(UniReactorConverters.fromMono(), mono);\n"
"Uni<String> uniFromFlux = Uni.createFrom().converter(UniReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:884
#, no-wrap
msgid ""
"Multi<String> multiFromMono = Multi.createFrom().converter(MultiReactorConverters.fromMono(), mono);\n"
"Multi<String> multiFromFlux = Multi.createFrom().converter(MultiReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:887
msgid "You can also transform `Unis` and `Multis` into Reactor types:"
msgstr "你也可以将 `Unis` 和 `Multis` 转换为 Reactor 类型："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:892
#, no-wrap
msgid ""
"Mono<String> mono = uni.convert().with(UniReactorConverters.toMono());\n"
"Flux<String> flux = uni.convert().with(UniReactorConverters.toFlux());\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:895
#, no-wrap
msgid ""
"Mono<String> mono2 = multi.convert().with(MultiReactorConverters.toMono());\n"
"Flux<String> flux2 = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:897
#, no-wrap
msgid "Using CompletionStages or Publisher API"
msgstr "使用CompletionStages或Publisher API"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:901
msgid "If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier<CompletionStage>`. For example:"
msgstr "如果你面对的是使用 `CompletionStage`, `CompletableFuture` 或 `Publisher` 的API，你可以来回转换。首先， `Uni` 和 `Multi` 都可以从 `CompletionStage` 或 `Supplier<CompletionStage>`创建。例如："

#. type: delimited block -
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:907
#, no-wrap
msgid ""
"CompletableFuture<String> future = Uni\n"
"        // Create from a Completion Stage\n"
"        .createFrom().completionStage(CompletableFuture.supplyAsync(() -> \"hello\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:910
msgid "On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`."
msgstr "在 `Uni` 上，你也可以使用 `subscribeAsCompletionStage()` 来产生一个 `CompletionStage` 。 `CompletionStage` 会获得由 `Uni` 发出的条目或失败。"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:914
msgid "You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`."
msgstr "你也可以使用 `createFrom().publisher(Publisher)` 从 `Publisher` 的实例中创建 `Unis` 和 `Multis` 。你可以使用 `toMulti` 将 `Uni` 转换为 `Publisher` 。事实上， `Multi` 实现了 `Publisher`。"

#. type: Title ==
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:915
#, no-wrap
msgid "What's next?"
msgstr "下一步做什么？"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:920
msgid "This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:"
msgstr "本指南是关于Quarkus响应式的介绍。Quarkus 的许多特性已经具有了响应式风格。下面列出了一些例子："

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:922
msgid "link:rest-json#reactive[Using Mutiny with RestEasy]"
msgstr "link:rest-json#reactive[使用Mutiny和RestEasy]"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:923
msgid "link:mailer[Sending email]"
msgstr "link:mailer[发送电邮件]"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:924
msgid "link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]"
msgstr "link:mongodb#reactive[使用 MongoDB] 和 link:mongodb-panache#reactive[MongoDB 和Panache]"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:925
msgid "link:reactive-sql-clients[Reactive Database Clients]"
msgstr "link:reactive-sql-clients[Reactive 数据库客户端]"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:926
msgid "link:vertx[Using Vert.x]"
msgstr "link:vertx[使用 Vert.x]"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:927
msgid "link:kafka[Interacting with Kafka] and link:amqp[Interacting with AMQP]"
msgstr "link:kafka[与Kafka交互] 和 link:amqp[与AMQP交互]"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:928
msgid "link:neo4j#reactive[Using Neo4J]"
msgstr "link:neo4j#reactive[使用Neo4J]"

#. type: Plain text
#: upstream/_versions/1.11/guides/getting-started-reactive.adoc:928
msgid "link:reactive-routes[Using reactive routes]"
msgstr "link:reactive-routes[使用响应式路由]"
