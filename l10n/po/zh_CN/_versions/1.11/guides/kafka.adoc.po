# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:58+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/1.11/guides/kafka.adoc:6
#, no-wrap
msgid "Quarkus - Using Apache Kafka with Reactive Messaging"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:11
msgid "This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with Apache Kafka."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:12
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:15
msgid "To complete this guide, you need:"
msgstr "要完成这个指南，你需要："

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:17
msgid "less than 15 minutes"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:18
msgid "an IDE"
msgstr "一个编辑器"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:19
msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:20
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:21
msgid "A running Kafka cluster, or Docker Compose to start a development cluster"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:22
msgid "GraalVM installed if you want to run in native mode."
msgstr ""

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_versions/1.11/guides/kafka.adoc:23
#: upstream/_versions/1.11/guides/kafka.adoc:31
#, no-wrap
msgid "Architecture"
msgstr "应用结构"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:30
msgid "In this guide, we are going to generate (random) prices in one component.  These prices are written in a Kafka topic (`prices`).  A second component reads from the `prices` Kafka topic and apply some magic conversion to the price.  The result is sent to an in-memory stream consumed by a JAX-RS resource.  The data is sent to a browser using server-sent events."
msgstr ""

#. type: Target for macro image
#: upstream/_versions/1.11/guides/kafka.adoc:31
#, no-wrap
msgid "kafka-guide-architecture.png"
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:33
#, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:37
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:39
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库: `git clone {quickstarts-clone-url}` ，或下载一个 {quickstarts-archive-url}[存档] 。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:41
msgid "The solution is located in the `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory]."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:42
#, no-wrap
msgid "Creating the Maven Project"
msgstr "创建Maven项目"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:45
msgid "First, we need a new project. Create a new project with the following command:"
msgstr "首先，我们需要一个新的项目。使用以下命令创建一个新的项目:"

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:55
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-quickstart \\\n"
"    -DclassName=\"org.acme.kafka.PriceResource\" \\\n"
"    -Dpath=\"/prices\" \\\n"
"    -Dextensions=\"resteasy,smallrye-reactive-messaging-kafka\"\n"
"cd kafka-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:58
msgid "This command generates a Maven project, importing the Reactive Messaging and Kafka connector extensions."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:61
msgid "If you already have your Quarkus project configured, you can add the `smallrye-reactive-messaging-kafka` extension to your project by running the following command in your project base directory:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:65
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"smallrye-reactive-messaging-kafka\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:68
msgid "This will add the following to your `pom.xml`:"
msgstr "这将在你的 `pom.xml` 中添加以下内容："

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:75
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:77
#, no-wrap
msgid "Starting Kafka"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:81
msgid "Then, we need a Kafka cluster.  You can follow the instructions from the https://kafka.apache.org/quickstart[Apache Kafka web site] or create a `docker-compose.yaml` file with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:85
#, no-wrap
msgid "version: '2'\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:87
#, no-wrap
msgid "services:\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:98
#, no-wrap
msgid ""
"  zookeeper:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:114
#, no-wrap
msgid ""
"  kafka:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:117
msgid "Once created, run `docker-compose up`."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:119
msgid "This is a development cluster, do not use in production."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:120
#, no-wrap
msgid "The price generator"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:123
msgid "Create the `src/main/java/org/acme/kafka/PriceGenerator.java` file, with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:127
#: upstream/_versions/1.11/guides/kafka.adoc:168
#: upstream/_versions/1.11/guides/kafka.adoc:211
#, no-wrap
msgid "package org.acme.kafka;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:130
#, no-wrap
msgid ""
"import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:132
#: upstream/_versions/1.11/guides/kafka.adoc:175
#: upstream/_versions/1.11/guides/kafka.adoc:428
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:135
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:142
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random prices every 5 seconds.\n"
" * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:144
#, no-wrap
msgid "    private Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:151
#, no-wrap
msgid ""
"    @Outgoing(\"generated-price\")                        // <1>\n"
"    public Multi<Integer> generate() {                  // <2>\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))\n"
"                .onOverflow().drop()\n"
"                .map(tick -> random.nextInt(100));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:153
#: upstream/_versions/1.11/guides/kafka.adoc:194
#: upstream/_versions/1.11/guides/kafka.adoc:447
#: upstream/_versions/1.11/guides/kafka.adoc:617
#: upstream/_versions/1.11/guides/kafka.adoc:714
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:155
msgid "Instruct Reactive Messaging to dispatch the items from returned stream to `generated-price`."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:156
msgid "The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ every 5 seconds."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:159
msgid "The method returns a _Reactive Stream_. The generated items are sent to the stream named `generated-price`.  This stream is mapped to Kafka using the `application.properties` file that we will create soon."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:160
#, no-wrap
msgid "The price converter"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:164
msgid "The price converter reads the prices from Kafka, and transforms them.  Create the `src/main/java/org/acme/kafka/PriceConverter.java` file with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:173
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:182
#, no-wrap
msgid ""
"/**\n"
" * A bean consuming data from the \"prices\" Kafka topic and applying some conversion.\n"
" * The result is pushed to the \"my-data-stream\" stream which is an in-memory stream.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceConverter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:184
#: upstream/_versions/1.11/guides/kafka.adoc:437
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:192
#, no-wrap
msgid ""
"    @Incoming(\"prices\")                                     // <1>\n"
"    @Outgoing(\"my-data-stream\")                             // <2>\n"
"    @Broadcast                                              // <3>\n"
"    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // <4>\n"
"    public double process(int priceInUsd) {\n"
"        return priceInUsd * CONVERSION_RATE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:196
msgid "Indicates that the method consumes the items from the `prices` topic"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:197
msgid "Indicates that the objects returned by the method are sent to the `my-data-stream` stream"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:198
msgid "Indicates that the item are dispatched to all _subscribers_"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:199
msgid "Make sure to acknowledge the incoming message"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:202
msgid "The `process` method is called for every Kafka _record_ from the `prices` topic (configured in the application configuration).  Every result is sent to the `my-data-stream` in-memory stream."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:203
#, no-wrap
msgid "The price resource"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:207
msgid "Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/java/org/acme/kafka/PriceResource.java` file with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:214
#: upstream/_versions/1.11/guides/kafka.adoc:563
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:221
#: upstream/_versions/1.11/guides/kafka.adoc:570
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:227
#, no-wrap
msgid ""
"/**\n"
" * A simple resource retrieving the in-memory \"my-data-stream\" and sending the items as server-sent events.\n"
" */\n"
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:230
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"my-data-stream\") Publisher<Double> prices; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:239
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS) // <2>\n"
"    @SseElementType(\"text/plain\") // <3>\n"
"    public Publisher<Double> stream() { // <4>\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:241
msgid "Injects the `my-data-stream` channel using the `@Channel` qualifier"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:242
msgid "Indicates that the content is sent using `Server Sent Events`"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:243
msgid "Indicates that the data contained within the server sent events is of type `text/plain`"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:244
msgid "Returns the stream (_Reactive Stream_)"
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:245
#, no-wrap
msgid "Configuring the Kafka connector"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:249
msgid "We need to configure the Kafka connector. This is done in the `application.properties` file.  The keys are structured as follows:"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:251
msgid "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:253
msgid "The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:"
msgstr "`channel-name` 片段必须与 `@Incoming` 和 `@Outgoing` 注解中设定的值相匹配:"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:255
msgid "`generated-price` -> sink in which we write the prices"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:256
msgid "`prices` -> source in which we read the prices"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:261
#, no-wrap
msgid ""
"# Configure the SmallRye Kafka connector\n"
"kafka.bootstrap.servers=localhost:9092\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:266
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.generated-price.connector=smallrye-kafka\n"
"mp.messaging.outgoing.generated-price.topic=prices\n"
"mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:270
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka\n"
"mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:273
msgid "More details about this configuration is available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation. These properties are configured with the prefix `kafka`."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:275
msgid "What about `my-data-stream`? This is an in-memory stream, not connected to a message broker."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:276
#, no-wrap
msgid "The HTML page"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:279
msgid "Final touch, the HTML page reading the converted prices using SSE."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:281
msgid "Create the `src/main/resources/META-INF/resources/prices.html` file, with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:289
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"<head>\n"
"    <meta charset=\"UTF-8\">\n"
"    <title>Prices</title>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:297
#, no-wrap
msgid ""
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css\">\n"
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css\">\n"
"</head>\n"
"<body>\n"
"<div class=\"container\">\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:312
#, no-wrap
msgid ""
"    <h2>Last price</h2>\n"
"    <div class=\"row\">\n"
"    <p class=\"col-md-12\">The last price is <strong><span id=\"content\">N/A</span>&nbsp;&euro;</strong>.</p>\n"
"    </div>\n"
"</div>\n"
"</body>\n"
"<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\n"
"<script>\n"
"    var source = new EventSource(\"/prices/stream\");\n"
"    source.onmessage = function (event) {\n"
"        document.getElementById(\"content\").innerHTML = event.data;\n"
"    };\n"
"</script>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:315
msgid "Nothing spectacular here. On each received price, it updates the page."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:316
#, no-wrap
msgid "Get it running"
msgstr "让它运行起来"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:320
msgid "If you followed the instructions, you should have Kafka running.  Then, you just need to run the application using:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:324
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:327
msgid "Open `http://localhost:8080/prices.html` in your browser."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:329
msgid "If you started the Kafka broker with docker compose, stop it using `CTRL+C` followed by `docker-compose down`."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:330
#, no-wrap
msgid "Running Native"
msgstr "以本机可执行文件运行"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:333
msgid "You can build the native executable with:"
msgstr "您可以使用以下命令构建本机可执行文件:"

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:337
#, no-wrap
msgid "./mvnw package -Pnative\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:339
#, no-wrap
msgid "Imperative usage"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:342
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr "有时，您需要使用命令式的方式来发送消息。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:345
msgid "For example, if you need to send a message to a stream, from inside a REST endpoint, when receiving a POST request.  In this case, you cannot use `@Output` because your method has parameters."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:347
msgid "For this, you can use an `Emitter`."
msgstr "这种情况下您可以使用 `Emitter` 。"

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:352
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:358
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:361
#, no-wrap
msgid ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:363
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:370
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:374
msgid "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use `@OnOverflow` to configure back-pressure strategy."
msgstr ""

#. type: Block title
#: upstream/_versions/1.11/guides/kafka.adoc:376
#, no-wrap
msgid "Deprecation"
msgstr "弃用"

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:379
msgid "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr "`io.smallrye.reactive.messaging.annotations.Emitter` , `io.smallrye.reactive.messaging.annotations.Channel` 和 `io.smallrye.reactive.messaging.annotations.OnOverflow` 类现在已被废弃，并被替换为："

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:381
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:382
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:383
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:385
msgid "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr "新的 `Emitter.send` 方法会返回一个 `CompletionStage` ，并且它会在产生的消息被确认时完成。"

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:387
#, no-wrap
msgid "Kafka Health Check"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:391
msgid "If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka` can add a readiness health check to validate the connection to the broker. This is disabled by default."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:393
msgid "If enabled, when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:395
msgid "This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:396
#, no-wrap
msgid "JSON serialization"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:399
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr "Quarkus有内置的能力来处理JSON格式的Kafka消息。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:401
msgid "Imagine we have a `Fruit` pojo as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:405
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:408
#, no-wrap
msgid ""
"    public String name;\n"
"    public int price;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:411
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:417
#, no-wrap
msgid ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:420
msgid "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr "而我们想用它来接收来自Kafka的消息，从而进行一些价格转换，并将消息传回Kafka。"

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:426
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:435
#, no-wrap
msgid ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n"
"* The result is pushed to the \"fruit-out\" stream.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:445
#, no-wrap
msgid ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:450
msgid "To do this, we will need to setup JSON serialization with Jackson or JSON-B."
msgstr "要做到这一点，我们需要用Jackson或JSON-B来设置JSON序列化。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:452
msgid "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr "在正确配置了JSON序列化后，您也可以使用 `Publisher<Fruit>` 和 `Emitter<Fruit>` 。"

#. type: Title ===
#: upstream/_versions/1.11/guides/kafka.adoc:453
#, no-wrap
msgid "Serializing via Jackson"
msgstr "通过Jackson进行序列化"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:456
msgid "First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-resteasy-jackson` extension, this is not needed)."
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:463
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:467
msgid "There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson, but the corresponding deserializer is generic, so it needs to be subclassed."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:469
msgid "So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:473
#, no-wrap
msgid "package com.acme.fruit.jackson;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:475
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:482
#, no-wrap
msgid ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer(){\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:485
msgid "Finally, configure your streams to use the Jackson serializer and deserializer."
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:492
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:497
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:500
msgid "Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo."
msgstr ""

#. type: Title ===
#: upstream/_versions/1.11/guides/kafka.adoc:501
#, no-wrap
msgid "Serializing via JSON-B"
msgstr "通过JSON-B进行序列化"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:504
msgid "First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed)."
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:511
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:515
msgid "There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B, but the corresponding deserializer is generic, so it needs to be subclassed."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:517
msgid "So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:521
#, no-wrap
msgid "package com.acme.fruit.jsonb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:523
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:530
#, no-wrap
msgid ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer(){\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:534
msgid "If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:536
msgid "Finally, configure your streams to use the JSON-B serializer and deserializer."
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:543
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:548
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:551
msgid "Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo."
msgstr ""

#. type: Title ===
#: upstream/_versions/1.11/guides/kafka.adoc:552
#, no-wrap
msgid "Sending JSON Server-Sent Events (SSE)"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:556
msgid "If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events, as the method will be annotated with `@Produces(MediaType.SERVER_SENT_EVENTS)`."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:558
msgid "The following example shows how to use SSE from a Kafka topic source."
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:573
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:576
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"fruit-out\") Publisher<Fruit> fruits;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:585
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @SseElementType(MediaType.APPLICATION_JSON)\n"
"    public Publisher<Fruit> stream() {\n"
"        return fruits;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:587
#, no-wrap
msgid "Blocking processing"
msgstr "阻塞处理"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:591
msgid "You often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and cannot be run on the caller thread."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:593
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr "例如，下面的代码演示了如何使用Hibernate与Panache将接收到的payload存储到数据库："

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:597
#, no-wrap
msgid "package org.acme.panache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:600
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:603
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:606
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:615
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    @Blocking\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:620
msgid "The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr "完整的例子可以参考 `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory]."

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:624
msgid "There are 2 `@Blocking` annotations:"
msgstr "有2种 `@Blocking` 注解："

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:626
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:627
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#. type: delimited block =
#: upstream/_versions/1.11/guides/kafka.adoc:632
msgid "They have the same effect.  Thus, you can use both.  The first one provides more fine-grain tuning such as the worker pool to use and whether it preserves the order.  The second one, used in also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:634
#, no-wrap
msgid "Testing a Kafka application"
msgstr "测试一个Kafka应用程序"

#. type: Title ===
#: upstream/_versions/1.11/guides/kafka.adoc:636
#, no-wrap
msgid "Testing without a broker"
msgstr "无broker的测试"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:640
msgid "It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr "在不启动Kafka broker的情况下测试应用程序会很有用。为了实现这一点，您可以把Kafka连接器管理的 channels  _切换_ 到_内存 _中 。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:642
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "这种方法只适用于JVM测试。它不能用于原生测试(因为原生模式不支持注入)。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:644
msgid "First, add the following dependency to your application:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:652
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:655
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "然后，按以下方法创建Quarkus测试资源："

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:659
#, no-wrap
msgid "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:669
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        Map<String, String> env = new HashMap<>();\n"
"        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");  // <1>\n"
"        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"queue\");   // <2>\n"
"        env.putAll(props1);\n"
"        env.putAll(props2);\n"
"        return env;  // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:675
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:677
msgid "Switch the incoming channel \"orders\" (expecting messages from Kafka) to in-memory."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:678
msgid "Switch the outgoing channel \"queue\" (writing messages to Kafka) to in-memory."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:679
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "构建并返回一个 `Map` ，包含配置应用程序使用内存 channels 所需的所有属性。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:680
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "当测试停止时，清除 `InMemoryConnector` (丢弃所有接收和发送的信息)。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:682
msgid "Create a Quarkus Test using the test resource created above:"
msgstr "使用上面创建的测试资源创建一个Quarkus测试："

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:688
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:691
#, no-wrap
msgid ""
"    @Inject @Any\n"
"    InMemoryConnector connector; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:696
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<Order> orders = connector.source(\"orders\"); // <2>\n"
"        InMemorySink<Beverage> queue = connector.sink(\"queue\");    // <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:701
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:703
#, no-wrap
msgid "        orders.send(order);  // <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:705
#, no-wrap
msgid "        await().<List<? extends Message<Beverage>>>until(queue::received, t -> t.size() == 1); // <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:712
#, no-wrap
msgid ""
"        Beverage queuedBeverage = queue.received().get(0).getPayload();\n"
"        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
"        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
"        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
"        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:716
msgid "Inject the in-memory connector in your test class."
msgstr "在您的测试类中注入内存内连接器。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:717
msgid "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr "检索传入 channel ( `orders` ) - 该 channel 必须在测试资源中被切换到内存中。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:718
msgid "Retrieve the outgoing channel (`queue`) - the channel must have been switched to in-memory in the test resource."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:719
msgid "Use the `send` method to send a message to the `orders` channel. So, the application will process this message."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:720
msgid "Use the `received` method to check the messages produced by the application."
msgstr ""

#. type: Title ===
#: upstream/_versions/1.11/guides/kafka.adoc:721
#, no-wrap
msgid "Starting Kafka in a test resource"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:725
msgid "Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr "另外，您也可以在测试资源中启动一个Kafka broker。下面的片段展示了如何在一个测试资源使用 link:https://www.testcontainers.org/modules/kafka/[Testcontainers] 启动一个Kafka broker："

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:729
#, no-wrap
msgid "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:731
#, no-wrap
msgid "    private final KafkaContainer kafka = new KafkaContainer();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:737
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:743
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:745
msgid "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr "配置Kafka bootstrap位置，这样应用程序就会连接到这个broker。"

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:746
#, no-wrap
msgid "Authenticating with OAuth"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:750
msgid "If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:"
msgstr "如果您的Kafka broker使用OAuth作为认证机制，您需要配置Kafka消费者来启用这个认证过程。首先，在您的应用程序中添加以下依赖："

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:757
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:761
msgid "This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:"
msgstr "这个依赖提供了处理OAuth工作流所需的回调处理器。然后，在 `application.properties` ，添加："

#. type: delimited block -
#: upstream/_versions/1.11/guides/kafka.adoc:771
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:774
msgid "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr "更改 `oauth.client.id` ， `oauth.client.secret` 和 `oauth.token.endpoint.uri` 值。"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:776
msgid "OAuth authentication works for both JVM and native modes."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.11/guides/kafka.adoc:777
#, no-wrap
msgid "Going further"
msgstr "进一步探索"

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:781
msgid "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes MicroProfile Reactive Messaging to build data streaming applications."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.11/guides/kafka.adoc:782
msgid "If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "如果您想进一步了解文档 https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], 在Quarkus中使用的实现。"
