# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-29 02:24+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Contexts and Dependency Injection"
msgstr "上下文和依赖性注入"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus DI solution (also called ArC) is based on the https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html[Jakarta Contexts and Dependency Injection 4.1, window=\"_blank\"] specification.\n"
"It implements the CDI Lite specification, with selected improvements on top, and passes the CDI Lite TCK.\n"
"It does not implement CDI Full.\n"
"See also <<supported_features_and_limitations,the list of supported features and limitations>>."
msgstr "Quarkus DI 解决方案（又称 ArC）基于 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html[Jakarta Contexts 和依赖注入 4.1] 规范。它实现了 CDI Lite 规范，在此基础上进行了部分改进，并通过了 CDI Lite TCK。它没有实现 CDI Full。另请参阅 xref:supported_features_and_limitations[支持的功能和限制列表] 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] first."
msgstr "如果你是CDI的新手，那么我们建议你先阅读 link:cdi.html[CDI简介] 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Most of the existing CDI code should work just fine but there are some small differences which follow from the Quarkus architecture and goals."
msgstr "大部分现有的CDI代码应该可以正常工作，但有一些小的差异，这些差异来自Quarkus的架构和目标。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Bean Discovery"
msgstr "豆类的发现"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Bean discovery in CDI is a complex process which involves legacy deployment structures and accessibility requirements of the underlying module architecture.\n"
"However, Quarkus is using a *simplified bean discovery*.\n"
"There is only single bean archive with the https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"] and no visibility boundaries."
msgstr "CDI 中的 Bean 发现是一个复杂的过程，涉及到传统的部署结构和底层模块架构的可访问性要求。然而，Quarkus 使用的是 *简化的* Bean 发现。只有一个豆归档， link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#default_bean_discovery[豆发现模式] 为 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#default_bean_discovery[annotated ，没有可见性边界。]"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The bean archive is synthesized from:"
msgstr "豆类档案是由以下内容合成的。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "the application classes,"
msgstr "的应用类。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "dependencies that contain a `beans.xml` descriptor (content is ignored),"
msgstr "包含一个 `beans.xml` 描述符的依赖关系（内容被忽略）。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "dependencies that contain a Jandex index - `META-INF/jandex.idx`,"
msgstr "包含Jandex索引的依赖性 - `META-INF/jandex.idx` ,"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "dependencies referenced by `quarkus.index-dependency` in `application.properties`,"
msgstr " `quarkus.index-dependency` 中引用的依赖性， `application.properties` 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "and Quarkus integration code."
msgstr "和Quarkus集成代码。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Bean classes that don't have a https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are not discovered.\n"
"This behavior is defined by CDI.\n"
"But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation (this behavior is different to what is defined in CDI).\n"
"In fact, the declaring bean classes are considered annotated with `@Dependent`."
msgstr "没有 bean link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bean_defining_annotations[定义注解] 的 Bean 类不会被发现。这种行为由 CDI 定义。但是，即使声明类没有注释 Bean 定义注解，生产者方法和字段以及观察者方法也会被发现（这种行为与 CDI 中定义的不同）。事实上，声明的 Bean 类被认为注释了 `@Dependent` 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Quarkus extensions may declare additional discovery rules. For example, `@Scheduled` business methods are registered even if the declaring class is not annotated with a bean defining annotation."
msgstr "Quarkus扩展可以声明额外的发现规则。例如， `@Scheduled` 业务方法被注册，即使声明的类没有用Bean定义注解。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "How to Generate a Jandex Index"
msgstr "如何生成一个Jandex索引"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"A dependency with a Jandex index is automatically scanned for beans.\n"
"To generate the index just add the following plugin to your build file:"
msgstr "带有 Jandex 索引的依赖关系会自动扫描豆类。要生成索引，只需在构建文件中添加以下插件："

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Gradle (Groovy DSL)"
msgstr "Gradle (Groovy DSL)"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "You can find the latest plugin version in the https://plugins.gradle.org/plugin/org.kordamp.gradle.jandex[Gradle Plugin Portal]"
msgstr "您可以在 link:https://plugins.gradle.org/plugin/org.kordamp.gradle.jandex[Gradle 插件门户] 中找到最新的插件版本"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Gradle (Kotlin DSL)"
msgstr "或者，如果您使用Gradle Kotlin DSL。"

#. type: delimited block *
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "If you can't modify the dependency, you can still index it by adding `quarkus.index-dependency` entries to your `application.properties`:"
msgstr "如果你不能修改依赖关系，你仍然可以通过在你的 `application.properties` ，添加 `quarkus.index-dependency` 条目来索引它。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "If no `artifact-id` is specified then all dependencies with the specificed `group-id` are indexed."
msgstr "如果未指定 `artifact-id` ，则会对指定 `group-id` 的所有依赖关系进行索引。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:"
msgstr "例如，以下条目确保 `org.acme:acme-api` 依赖关系被编入索引。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Example application.properties"
msgstr "示例application.properties"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Value is a group id for a dependency identified by name `acme`."
msgstr "值是由名称 `acme` 确定的依赖关系的组ID。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Value is an artifact id for a dependency identified by name `acme`."
msgstr "值是由名称识别的依赖关系的工件ID `acme` 。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "How To Exclude Types and Dependencies from Discovery"
msgstr "如何从发现中排除类型和依赖关系"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It may happen that some beans from third-party libraries do not work correctly in Quarkus.\n"
"A typical example is a bean injecting a portable extension.\n"
"In such case, it's possible to exclude types and dependencies from the bean discovery.\n"
"The `quarkus.arc.exclude-types` property accepts a list of string values that are used to match classes that should be excluded."
msgstr "第三方库中的某些 Bean 可能无法在 Quarkus 中正常工作。一个典型的例子就是注入了可移植扩展的 Bean。在这种情况下，可以从 bean 发现中排除类型和依赖关系。 `quarkus.arc.exclude-types` 属性接受一个字符串值列表，用于匹配应排除的类。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Value Examples"
msgstr "价值实例"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Value"
msgstr "价值"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Description"
msgstr "描述"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`org.acme.Foo`"
msgstr " `org.acme.Foo` "

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the fully qualified name of the class"
msgstr "匹配类的完全合格名称"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`org.acme.*`"
msgstr " `org.acme.*` "

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match classes with package `org.acme`"
msgstr "匹配类与包 `org.acme` "

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`org.acme.**`"
msgstr " `org.acme.**` "

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match classes where the package starts with `org.acme`"
msgstr "匹配包的开头为 `org.acme` "

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`Bar`"
msgstr " `Bar` "

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the simple name of the class"
msgstr "匹配类的简单名称"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Exclude the type `org.acme.Foo`."
msgstr "排除类型 `org.acme.Foo` 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Exclude all types from the `org.acme` package."
msgstr "从 `org.acme` 包中排除所有类型。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Exclude all types whose simple name is `Bar`"
msgstr "排除所有类型，其简单名称为 `Bar` "

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It is also possible to exclude a dependency artifact that would be otherwise scanned for beans.\n"
"For example, because it contains a `beans.xml` descriptor."
msgstr "也可以排除在其他情况下扫描豆类的依赖工件。例如，因为它包含 `beans.xml` 描述符。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Native Executables and Private Members"
msgstr "本地可执行文件和私有成员"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus is using GraalVM to build a native executable.\n"
"One of the limitations of GraalVM is the usage of link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/Reflection/[Reflection, window=\"_blank\"].\n"
"Reflective operations are supported but all relevant members must be registered for reflection explicitly.\n"
"Those registrations result in a bigger native executable."
msgstr "Quarkus 正在使用 GraalVM 构建本地可执行文件。GraalVM 的限制之一是 link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/Reflection/[反射] 的使用。虽然支持反射操作，但所有相关成员都必须明确注册为反射。这些注册会导致本地可执行文件体积增大。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"And if Quarkus DI needs to access a private member it *has to use reflection*.\n"
"That's why Quarkus users are encouraged __not to use private members__ in their beans.\n"
"This involves injection fields, constructors and initializers, observer methods, producer methods and fields, disposers and interceptor methods."
msgstr "如果 Quarkus DI 需要访问私有成员，就 *必须使用反射* 。这就是为什么我们鼓励 Quarkus 用户 _不要_ 在他们的 Bean 中 _使用私有成员_ 。这涉及到注入字段、构造函数和初始化器、观察者方法、生产者方法和字段、处置器和拦截器方法。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"How to avoid using private members?\n"
"You can use package-private modifiers:"
msgstr "如何避免使用私有成员？您可以使用包私有修饰符："

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "A package-private injection field."
msgstr "一个包-私密的注入字段。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "A package-private observer method."
msgstr "一个包内私有的观察者方法。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Or constructor injection:"
msgstr "或构造器注入。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "A package-private constructor injection. `@Inject` is optional in this particular case."
msgstr " `@Inject` ，在这种特殊情况下是可选的。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "[[supported_features]][[limitations]] Supported Features and Limitations"
msgstr "  支持的功能和限制"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The CDI Lite specification is fully supported.\n"
"The following features from CDI Full are also supported:"
msgstr "完全支持 CDI Lite 规范。还支持 CDI 完全版的以下功能："

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Decorators"
msgstr "装饰公司"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Decoration of built-in beans, such as `Event`, is not supported"
msgstr "不支持对内置豆类的装饰，如 `Event` ，。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`BeanManager`"
msgstr " `BeanContainer` "

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In addition to the `BeanContainer` methods, the following methods are supported: `getInjectableReference()`, `resolveDecorators()`"
msgstr " `BeanManager` ：除了 `BeanContainer` 方法外，只支持以下方法： `getInjectableReference()` , `resolveDecorators()` "

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`@SessionScoped`"
msgstr "`@SessionScoped`"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Only with the Undertow extension; see xref:cdi.adoc#bean-scope-available[here] for details"
msgstr "范围和背景；详见 link:cdi.html#bean-scope-available[这里]"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The _method invokers_ implementation supports asynchronous methods.\n"
"The following methods are considered asynchronous and `@Dependent` instances are only destroyed when the asynchronous action completes:"
msgstr "_方法调用者_ 实现支持异步方法。以下方法被视为异步方法， `@Dependent` 实例只有在异步操作完成时才会被销毁："

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "methods that declare a return type of `CompletionStage`, `Uni`, or `Multi`"
msgstr "声明返回类型为 `CompletionStage` , `Uni` , 或 `Multi`"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "These additional features are not covered by the CDI Lite TCK."
msgstr "CDI Lite TCK 不包括这些附加功能。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Non-standard Features"
msgstr "非标准功能"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Eager Instantiation of Beans"
msgstr "豆类的急切实例化"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Lazy By Default"
msgstr "默认的懒惰"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"By default, CDI beans are created lazily, when needed.\n"
"What exactly \"needed\" means depends on the scope of a bean."
msgstr "默认情况下，CDI Bean 是在需要时才创建的。需要 \"的确切含义取决于 Bean 的作用域。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "A *normal scoped bean* (`@ApplicationScoped`, `@RequestScoped`, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification)."
msgstr "当一个方法在一个注入的实例上被调用时（根据规范的上下文引用），需要一个 *正常范围的Bean* （ `@ApplicationScoped` , `@RequestScoped` , 等等）。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In other words, injecting a normal scoped bean will not suffice because a _client proxy_ is injected instead of a contextual instance of the bean."
msgstr "换句话说，注入一个正常范围的Bean是不够的，因为注入的是一个 _客户端代理_ 而不是Bean的上下文实例。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "A *bean with a pseudo-scope* (`@Dependent` and `@Singleton` ) is created when injected."
msgstr "当注入时，一个 *具有伪范围的Bean* ( `@Dependent` 和 `@Singleton` ) 被创建。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Lazy Instantiation Example"
msgstr "懒惰实例化实例"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Injection triggers the instantiation of `AmazingService`."
msgstr "注入触发了 `AmazingService` 的实例化。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Injection itself does not result in the instantiation of `CoolService`. A client proxy is injected."
msgstr "注入本身并不导致 `CoolService` 。一个客户代理被注入了。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The first invocation upon the injected proxy triggers the instantiation of `CoolService`."
msgstr "对注入的代理的第一次调用触发了 `CoolService` 的实例化。"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Startup Event"
msgstr "初创企业活动"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "However, if you really need to instantiate a bean eagerly you can:"
msgstr "然而，如果你真的需要急切地实例化一个bean，你可以。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Declare an observer of the `StartupEvent` - the scope of the bean does not matter in this case:"
msgstr "声明一个 `StartupEvent` 的观察者--在这种情况下，bean的范围并不重要。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "A `CoolService` is created during startup to service the observer method invocation."
msgstr "在启动过程中会创建一个 `CoolService` ，以服务于观察者方法的调用。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Use the bean in an observer of the `StartupEvent` - normal scoped beans must be used as described in <<lazy_by_default>>:"
msgstr "在 `StartupEvent` 的观察者中使用 Bean - 必须按照 <<lazy_by_default>> 中的说明使用普通作用域 Bean："

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The `AmazingService` is created during injection."
msgstr " `AmazingService` 是在注射过程中产生的。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The `CoolService` is a normal scoped bean, so we have to invoke a method upon the injected proxy to force the instantiation."
msgstr " `CoolService` 是一个正常范围的bean，所以我们必须在注入的代理上调用一个方法来强制实例化。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Annotate the bean with `@io.quarkus.runtime.Startup` as described in xref:lifecycle.adoc#startup_annotation[Startup annotation]:"
msgstr "按照 link:lifecycle.html#startup_annotation[Startup annotation] 中的描述，用 `@io.quarkus.runtime.Startup` 来注解bean。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used."
msgstr "对于每个用 `@Startup` 注释的Bean，会生成一个 `StartupEvent` 的合成观察者。使用的是默认的优先级。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context."
msgstr "当应用程序启动时，Bean构造函数被调用，产生的上下文实例被存储在应用程序上下文中。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Quarkus users are encouraged to always prefer the `@Observes StartupEvent` to `@Initialized(ApplicationScoped.class)` as explained in the xref:lifecycle.adoc[Application Initialization and Termination] guide."
msgstr "我们鼓励Quarkus用户总是首选 `@Observes StartupEvent` ，而不是 `@Initialized(ApplicationScoped.class)` ，这在 link:lifecycle.html[应用程序初始化和终止] 指南中有所解释。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Request Context Lifecycle"
msgstr "请求语境的生命周期"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The request context is also active:"
msgstr "请求环境也是活跃的。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "during notification of a synchronous observer method."
msgstr "在同步观察者方法的通知期间。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The request context is destroyed:"
msgstr "请求上下文被销毁。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "after the observer notification completes for an event, if it was not already active when the notification started."
msgstr "在事件的观察者通知完成后，如果通知开始时它还没有被激活的话。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "An event with qualifier `@Initialized(RequestScoped.class)` is fired when the request context is initialized for an observer notification. Moreover, the events with qualifiers `@BeforeDestroyed(RequestScoped.class)` and `@Destroyed(RequestScoped.class)` are fired when the request context is destroyed."
msgstr "当请求上下文被初始化为观察者通知时，带有限定词 `@Initialized(RequestScoped.class)` 的事件被触发。此外，当请求上下文被销毁时，带有限定词 `@BeforeDestroyed(RequestScoped.class)` 和 `@Destroyed(RequestScoped.class)` 的事件被触发。"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "How to Enable Trace Logging for Request Context Activation"
msgstr "如何启用请求上下文激活的跟踪记录"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "You can set the `TRACE` level for the logger `io.quarkus.arc.requestContext` and try to analyze the log output afterwards."
msgstr "你可以为记录仪设置 `TRACE` ， `io.quarkus.arc.requestContext` ，之后再尝试分析日志输出。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`application.properties` Example"
msgstr " `application.properties` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "你还需要调整相关类别的最小日志级别。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Qualified Injected Fields"
msgstr "合格的注射场"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In CDI, if you declare a field injection point you need to use `@Inject` and optionally a set of qualifiers."
msgstr "在CDI中，如果你声明一个字段注入点，你需要使用 `@Inject` ，并且可以选择一组限定词。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In Quarkus, you can skip the `@Inject` annotation completely if the injected field declares at least one qualifier."
msgstr "在Quarkus中，如果注入的字段至少声明了一个限定词，你可以完全跳过 `@Inject` 注释。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "With the notable exception of one special case discussed below, `@Inject` is still required for constructor and method injection."
msgstr "除了下面讨论的一种特殊情况外， `@Inject` ，构造函数和方法注入仍然需要。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Simplified Constructor Injection"
msgstr "简化的构造函数注入"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).\n"
"However, this requirement complicates constructor injection - you need to provide a dummy no-args constructor to make things work in CDI."
msgstr "在 CDI 中，正常作用域的 Bean 必须始终声明一个无参数构造函数（该构造函数通常由编译器生成，除非您声明任何其他构造函数）。然而，这一要求使构造函数注入变得复杂--您需要提供一个虚假的无参数构造函数，才能在 CDI 中正常工作。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.\n"
"Also, if there's only one constructor there is no need for `@Inject`."
msgstr "在 Quarkus 中，无需为普通作用域 Bean 声明虚拟构造函数，它们会自动生成。此外，如果只有一个构造函数，就不需要 `@Inject` 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "We don't generate a no-args constructor automatically if a bean class extends a class that does not declare a no-args constructor."
msgstr "如果一个Bean类扩展了一个没有声明no-args构造函数的类，我们不会自动生成一个no-args构造函数。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Removing Unused Beans"
msgstr "移除未使用的豆子"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The container attempts to remove all unused beans, interceptors and decorators during build by default.\n"
"This optimization helps to minimize the amount of generated classes, thus conserving memory.\n"
"However, Quarkus can't detect the programmatic lookup performed via the `CDI.current()` static method.\n"
"Therefore, it is possible that a removal results in a false positive error, i.e. a bean is removed although it's actually used.\n"
"In such cases, you'll notice a big warning in the log.\n"
"Users and extension authors have several options <<eliminate_false_positives,how to eliminate false positives>>."
msgstr "默认情况下，容器会在构建过程中移除所有未使用的 Bean、拦截器和装饰器。这种优化有助于最大限度地减少生成类的数量，从而节省内存。不过，Quarkus 无法检测通过 `CDI.current()` 静态方法执行的编程查找。因此，删除可能会导致误报，即一个 bean 被删除了，但它实际上还在使用。在这种情况下，您会在日志中注意到一个很大的警告。用户和扩展作者有几种 xref:eliminate_false_positives[消除误报的方法] 。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The optimization can be disabled by setting `quarkus.arc.remove-unused-beans` to `none` or `false`.\n"
"Quarkus also provides a middle ground where application beans are never removed whether or not they are unused, while the optimization proceeds normally for non application classes.\n"
"To use this mode, set `quarkus.arc.remove-unused-beans` to `fwk` or `framework`."
msgstr "可以通过将 `quarkus.arc.remove-unused-beans` 设置为 `none` 或 `false` 来禁用优化。Quarkus 还提供了一种中间模式，即无论应用程序 Bean 是否未被使用，它都不会被移除，而对非应用程序类的优化则正常进行。要使用这种模式，可将 `quarkus.arc.remove-unused-beans` 设置为 `fwk` 或 `framework` 。"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "What's Removed?"
msgstr "移除的是什么？"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus first identifies so-called _unremovable_ beans that form the roots in the dependency tree.\n"
"A good example is a Jakarta REST resource class or a bean which declares a `@Scheduled` method."
msgstr "Quarkus 首先会识别所谓的 _不可移除_ Bean，这些 Bean 构成了依赖关系树的根。Jakarta REST 资源类或声明了 `@Scheduled` 方法的 Bean 就是一个很好的例子。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "An _unremovable_ bean:"
msgstr "一颗 _不_ 可拆卸的豆子。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "is excluded from removal by an extension, or"
msgstr "因延期而被排除在清除之外，或"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "has a name designated via `@Named`, or"
msgstr "有一个通过 `@Named` 指定的名称，或"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "declares an observer method."
msgstr "声明了一个观察者方法。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "An _unused_ bean:"
msgstr "一个 _未使用的_ 豆子。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "is not _unremovable_, and"
msgstr "并非 _不可移除_ ，而且"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "is not eligible for injection to any injection point in the dependency tree, and"
msgstr "没有资格被注入到依赖树中的任何注入点，并且"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "does not declare any producer which is eligible for injection to any injection point in the dependency tree, and"
msgstr "没有声明任何有资格被注入到依赖树中任何注入点的生产者，并且"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "is not eligible for injection into any `jakarta.enterprise.inject.Instance` or `jakarta.inject.Provider` injection point."
msgstr "没有资格注射到任何 `javax.enterprise.inject.Instance` 或 `javax.inject.Provider` 注射点。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Unused interceptors and decorators are not associated with any bean."
msgstr "未使用的拦截器和装饰器不与任何Bean关联。"

#. type: delimited block =
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "When using the dev mode (running `./mvnw clean compile quarkus:dev`), you can see more information about which beans are being removed:"
msgstr "当使用dev模式（运行 `./mvnw clean compile quarkus:dev` ）时，你可以看到更多关于哪些bean被移除的信息。"

#. type: delimited block =
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In the console - just enable the DEBUG level in your `application.properties`, i.e. `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG`"
msgstr "在控制台--只要在你的 `application.properties` ，启用DEBUG级别，即 `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` "

#. type: delimited block =
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In the relevant Dev UI page"
msgstr "在相关的开发用户界面页面中"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "How To Eliminate False Positives"
msgstr "如何消除假阳性反应"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Users can instruct the container to not remove any of their specific beans (even if they satisfy all the rules specified above) by annotating them with `@io.quarkus.arc.Unremovable`.\n"
"This annotation can be declared on a class, a producer method or field."
msgstr "用户可以用 `@io.quarkus.arc.Unremovable` 注释容器，指示容器不删除任何特定的 Bean（即使这些 Bean 符合上述规定的所有规则）。这种注解可以在类、生产者方法或字段上声明。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Since this is not always possible, there is an option to achieve the same via `application.properties`.\n"
"The `quarkus.arc.unremovable-types` property accepts a list of string values that are used to match beans based on their name or package."
msgstr "由于并非总能做到这一点，因此可以通过 `application.properties` 来实现同样的目的。 `quarkus.arc.unremovable-types` 属性接受一个字符串值列表，用于根据豆子的名称或包匹配豆子。"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the fully qualified name of the bean class"
msgstr "匹配Bean类的完全合格名称"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match beans where the package of the bean class is `org.acme`"
msgstr "匹配豆类的包是什么的豆类 `org.acme` "

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match beans where the package of the bean class starts with `org.acme`"
msgstr "匹配豆类的包以\"\"开头的豆类。 `org.acme` "

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the simple name of the bean class"
msgstr "匹配豆类的简单名称"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Furthermore, extensions can eliminate false positives by producing an `UnremovableBeanBuildItem`."
msgstr "此外，扩展可以消除假阳性，产生一个 `UnremovableBeanBuildItem` 。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Default Beans"
msgstr "默认豆类"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus adds a capability that CDI currently does not support which is to conditionally declare a bean if no other bean with equal types and qualifiers was declared by any available means (bean class, producer, synthetic bean, ...)\n"
"This is done using the `@io.quarkus.arc.DefaultBean` annotation and is best explained with an example."
msgstr "Quarkus 增加了一项 CDI 目前不支持的功能，即如果没有其他具有相同类型和限定符的 Bean 通过任何可用的方法（Bean 类、生产者、合成 Bean 等）被声明，则有条件地声明一个 Bean。该功能使用 `@io.quarkus.arc.DefaultBean` 注解实现，最好用一个示例来解释。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Say there is a Quarkus extension that among other things declares a few CDI beans like the following code does:"
msgstr "假设有一个Quarkus扩展，除此之外还声明了一些CDI Bean，就像下面的代码那样。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The idea is that the extension autoconfigures things for the user, eliminating a lot of boilerplate - we can just `@Inject` a `Tracer` wherever it is needed.\n"
"Now imagine that in our application we would like to utilize the configured `Tracer`, but we need to customize it a little, for example by providing a custom `Reporter`.\n"
"The only thing that would be needed in our application would be something like the following:"
msgstr "这样做的目的是让扩展为用户自动配置，省去大量的模板--我们只需在需要的地方 `@Inject` `Tracer` 。现在设想一下，在我们的应用程序中，我们希望使用配置好的 `Tracer` ，但我们需要对其进行一些定制，例如提供一个自定义的 `Reporter` 。在我们的应用程序中，唯一需要的就是类似下面这样的内容："

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"`@DefaultBean` allows extensions (or any other code for that matter) to provide defaults while backing off if beans of that type are supplied in any\n"
"way Quarkus supports."
msgstr "`@DefaultBean` 允许扩展程序（或任何其他代码）提供默认值，同时在以任何 Quarkus 支持的方式提供该类型的 bean 时退出。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Default beans can optionally declare `@jakarta.annotation.Priority`.\n"
"If there is no priority defined, `@Priority(0)` is assumed.\n"
"Priority value is used for bean ordering and during typesafe resolution to disambiguate multiple matching default beans."
msgstr "默认 Bean 可以选择声明 `@jakarta.annotation.Priority` 。如果没有定义优先级，则假定为 `@Priority(0)` 。优先级值用于豆排序和类型安全解析，以消除多个匹配默认豆的歧义。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Enabling Beans for Quarkus Build Profile"
msgstr "启用Quarkus Build Profile的豆类"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time profile is enabled,\n"
"via the `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc.profile.UnlessBuildProfile` annotations.\n"
"When used in conjunction with `@io.quarkus.arc.DefaultBean`, these annotations allow for the creation of different bean configurations for different build profiles."
msgstr "Quarkus 增加了一项 CDI 目前不支持的功能，即通过 `@io.quarkus.arc.profile.IfBuildProfile` 和 `@io.quarkus.arc.profile.UnlessBuildProfile` 注释，在启用 Quarkus 构建时间配置文件时有条件地启用 Bean。当与 `@io.quarkus.arc.DefaultBean` 结合使用时，这些注解允许为不同的构建配置文件创建不同的 Bean 配置。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Imagine for instance that an application contains a bean named `Tracer`, which needs to do nothing when in tests or in dev mode, but works in its normal capacity for the production artifact.\n"
"An elegant way to create such beans is the following:"
msgstr "例如，设想一个应用程序包含一个名为 `Tracer` 的 Bean，它在测试或开发模式下不需要做任何事情，但在生产模式下可以正常工作。创建此类 Bean 的一种简便方法如下："

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "If instead, it is required that the `Tracer` bean also works in dev mode and only default to doing nothing for tests, then `@UnlessBuildProfile` would be ideal. The code would look like:"
msgstr "如果相反，要求 `Tracer` bean也能在开发模式下工作，并且只在测试时默认为不做任何事情，那么 `@UnlessBuildProfile` 将是理想的。代码将看起来像。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The runtime profile has absolutely no effect on the bean resolution using `@IfBuildProfile` and `@UnlessBuildProfile`."
msgstr "运行时配置文件对使用 `@IfBuildProfile` 和 `@UnlessBuildProfile` 的bean解析完全没有影响。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "It is also possible to use `@IfBuildProfile` and `@UnlessBuildProfile` on stereotypes."
msgstr "也可以在刻板印象上使用 `@IfBuildProfile` 和 `@UnlessBuildProfile` 。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Enabling Beans for Quarkus Build Properties"
msgstr "为Quarkus构建属性启用豆类"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time property has/has not a specific value,\n"
"via the `@io.quarkus.arc.properties.IfBuildProperty` and `@io.quarkus.arc.properties.UnlessBuildProperty` annotations.\n"
"When used in conjunction with `@io.quarkus.arc.DefaultBean`, this annotation allow for the creation of different bean configurations for different build properties."
msgstr "Quarkus 增加了一项 CDI 目前不支持的功能，即通过 `@io.quarkus.arc.properties.IfBuildProperty` 和 `@io.quarkus.arc.properties.UnlessBuildProperty` 注释，在 Quarkus 构建时间属性具有/不具有特定值时，有条件地启用 Bean。当与 `@io.quarkus.arc.DefaultBean` 结合使用时，该注解允许针对不同的构建属性创建不同的 Bean 配置。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The scenario we mentioned above with `Tracer` could also be implemented in the following way:"
msgstr "我们上面提到的用 `Tracer` ，也可以用以下方式实现。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`@IfBuildProperty` and `@UnlessBuildProperty` are repeatable annotations, i.e. a bean will only be enabled if **all** the conditions defined by these annotations are satisfied."
msgstr " `@IfBuildProperty` 和 是可重复的注解，也就是说，只有当这些注解所定义的 `@UnlessBuildProperty` *所有* 条件得到满足时，Bean才会被启用。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "If instead, it is required that the `RealTracer` bean is only used if the `some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` would be ideal. The code would look like:"
msgstr "相反，如果要求 `RealTracer` Bean只在 `some.tracer.enabled` 属性不是 `false` 的情况下使用，那么 `@UnlessBuildProperty` 将是最理想的。代码将看起来像。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`."
msgstr "在运行时设置的属性对使用 `@IfBuildProperty` 的bean解析绝对没有影响。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "It is also possible to use `@IfBuildProperty` and `@UnlessBuildProperty` on stereotypes."
msgstr "也可以在刻板印象上使用 `@IfBuildProperty` 和 `@UnlessBuildProperty` 。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Declaring Selected Alternatives"
msgstr "宣布选定的替代品"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In CDI, an alternative bean may be selected either globally for an application by means of `@Priority`, or for a bean archive using a `beans.xml` descriptor.\n"
"Quarkus has a simplified bean discovery and the content of `beans.xml` is ignored."
msgstr "在 CDI 中，可通过 `@Priority` 或 `beans.xml` 描述符为应用程序全局选择替代 bean，或为 bean 档案选择替代 bean。Quarkus 有一个简化的 Bean 发现功能，而且 `beans.xml` 的内容会被忽略。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"However, it is also possible to select alternatives for an application using the unified configuration.\n"
"The `quarkus.arc.selected-alternatives` property accepts a list of string values that are used to match alternative beans.\n"
"If any value matches then the priority of `Integer#MAX_VALUE` is used for the relevant bean.\n"
"The priority declared via `@Priority` or inherited from a stereotype is overridden."
msgstr "不过，也可以使用统一配置为应用程序选择替代豆。 `quarkus.arc.selected-alternatives` 属性接受一个字符串值列表，用于匹配替代 bean。如果有任何值匹配，则 `Integer#MAX_VALUE` 的优先级将用于相关 Bean。通过 `@Priority` 声明或从定型中继承的优先级会被覆盖。"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the fully qualified name of the bean class or the bean class of the bean that declares the producer"
msgstr "匹配Bean类的完全合格名称或声明生产者的Bean类"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Match the simple name of the bean class or the bean class of the bean that declares the producer"
msgstr "匹配豆类的简单名称或声明生产者的豆类的豆类"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Simplified Producer Method Declaration"
msgstr "简化生产者方法申报"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In CDI, a producer method must be always annotated with `@Produces`."
msgstr "在CDI中，生产者方法必须总是被注解为 `@Produces` 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In Quarkus, you can skip the `@Produces` annotation completely if the producer method is annotated with a scope annotation, a stereotype or a qualifier."
msgstr "在Quarkus中，如果生产者方法被注解了范围注解、定型或限定符，你可以完全跳过 `@Produces` 注解。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Interception of Static Methods"
msgstr "静态方法的拦截"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The Interceptors specification is clear that _around-invoke_ methods must not be declared static.\n"
"However, this restriction was driven mostly by technical limitations.\n"
"And since Quarkus is a build-time oriented stack that allows for additional class transformations, those limitations don't apply anymore.\n"
"It's possible to annotate a non-private static method with an interceptor binding:"
msgstr "拦截器规范明确规定，\" _周围唤醒_ \"方法不得声明为静态方法。不过，这一限制主要是受技术限制所驱使。由于 Quarkus 是面向构建时间的堆栈，允许额外的类转换，因此这些限制不再适用。使用拦截器绑定注解非私有静态方法是可能的："

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`Logged` is an interceptor binding."
msgstr " `Logged` 是一个拦截器绑定。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Each method invocation is intercepted if there is an interceptor associated with `Logged`."
msgstr "如果有一个与 `Logged` 相关的拦截器，每个方法的调用都会被拦截。"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Limitations"
msgstr "限制条件"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Only *method-level bindings* are considered for backward compatibility reasons (otherwise static methods of bean classes that declare class-level bindings would be suddenly intercepted)"
msgstr "出于向后兼容的原因，只考虑 *方法级绑定* （否则声明类级绑定的bean类的静态方法会突然被拦截）。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Private static methods are never intercepted"
msgstr "私有静态方法从不被拦截"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`InvocationContext#getTarget()` returns `null` for obvious reasons; therefore not all existing interceptors may behave correctly when intercepting static methods"
msgstr " `InvocationContext#getTarget()` 返回 ，原因显而易见；因此，并不是所有现有的拦截器在拦截静态方法时都会表现得正确。 `null` "

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Interceptors can use `InvocationContext.getMethod()` to detect static methods and adjust the behavior accordingly."
msgstr "拦截器可以使用 `InvocationContext.getMethod()` 来检测静态方法并相应地调整行为。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Ability to handle 'final' classes and methods"
msgstr "有能力处理 \"最终 \"类和方法"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In normal CDI, classes that are marked as `final` and / or have `final` methods are not eligible for proxy creation,\n"
"which in turn means that interceptors and normal scoped beans don't work properly.\n"
"This situation is very common when trying to use CDI with alternative JVM languages like Kotlin where classes and methods are `final` by default."
msgstr "在普通 CDI 中，被标记为 `final` 和/或具有 `final` 方法的类不符合代理创建条件，这反过来又意味着拦截器和普通作用域 Bean 无法正常工作。在尝试将 CDI 与其他 JVM 语言（如 Kotlin）一起使用时，这种情况非常常见，因为 Kotlin 的类和方法默认为 `final` 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value)."
msgstr " `true` 然而，当 `quarkus.arc.transform-unproxyable-classes` （这是默认值）时，Quarkus可以克服这些限制。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Container-managed Concurrency"
msgstr "容器管理的并发性"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"There is no standard concurrency control mechanism for CDI beans.\n"
"Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.\n"
"In that case it should be thread-safe.\n"
"You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access.\n"
"Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for this interceptor binding.\n"
"Each interceptor instance associated with a contextual instance of an intercepted bean holds a separate `ReadWriteLock` with non-fair ordering policy."
msgstr "CDI Bean 没有标准的并发控制机制。不过，Bean 实例可以由多个线程共享和并发访问。在这种情况下，它应该是线程安全的。您可以使用标准的 Java 结构（ `volatile` , `synchronized` , `ReadWriteLock` 等），也可以让容器来控制并发访问。Quarkus 为这种拦截器绑定提供了 `@io.quarkus.arc.Lock` 和内置拦截器。与被拦截 Bean 的上下文实例相关联的每个拦截器实例都拥有一个单独的、采用非公平排序策略的 `ReadWriteLock` 。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`io.quarkus.arc.Lock` is a regular interceptor binding and as such can be used for any bean with any scope. However, it is especially useful for \"shared\" scopes, e.g. `@Singleton` and `@ApplicationScoped`."
msgstr " `io.quarkus.arc.Lock` 是一个常规的拦截器绑定，因此可以用于任何作用域的bean。然而，它对 \"共享 \"作用域特别有用，例如： 和 。 `@Singleton` `@ApplicationScoped` "

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Container-managed Concurrency Example"
msgstr "容器管理的并发性实例"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has \"exclusive access\" and no concurrent invocations will be allowed."
msgstr " `@Lock` (映射到 )声明的类指示容器为任何业务方法的任何调用锁定Bean实例，也就是说，客户有 \"排他性访问\"，不允许并发调用。 `@Lock(Lock.Type.WRITE)` "

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`."
msgstr " `@Lock(Lock.Type.READ)` 覆盖了在类级别指定的值。这意味着任何数量的客户端都可以并发地调用该方法，除非Bean实例被 锁定。 `@Lock(Lock.Type.WRITE)` "

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown."
msgstr "你也可以指定 \"等待时间\"。如果在给定的时间内不可能获得锁，就会抛出一个 `LockException` 。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Repeatable interceptor bindings"
msgstr "可重复的拦截器绑定"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Quarkus has limited support for `@Repeatable` interceptor binding annotations."
msgstr "Quarkus对 `@Repeatable` 拦截器绑定注释的支持有限。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"When binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.\n"
"Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.\n"
"This might be added in the future."
msgstr "将拦截器绑定到组件时，可以在方法上声明多个 `@Repeatable` 注释。由于与拦截器规范的交互还存在一些未决问题，因此不支持在类和定型上声明可重复的拦截器绑定。将来可能会添加。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"As an example, suppose we have an interceptor that clears a cache.\n"
"The corresponding interceptor binding would be called `@CacheInvalidateAll` and would be declared as `@Repeatable`.\n"
"If we wanted to clear two caches at the same time, we would add `@CacheInvalidateAll` twice:"
msgstr "举例来说，假设我们有一个拦截器可以清除缓存。相应的拦截器绑定将被称为 `@CacheInvalidateAll` ，并声明为 `@Repeatable` 。如果我们想同时清除两个缓存，就需要添加两次 `@CacheInvalidateAll` ："

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"This is how interceptors are used.\n"
"What about creating an interceptor?"
msgstr "这就是拦截器的使用方法。如何创建拦截器？"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"When declaring interceptor bindings of an interceptor, you can add multiple `@Repeatable` annotations to the interceptor class as usual.\n"
"This is useless when the annotation members are `@Nonbinding`, as would be the case for the `@Cached` annotation, but is important otherwise."
msgstr "在声明拦截器的拦截器绑定时，可以像往常一样向拦截器类添加多个 `@Repeatable` 注释。当注解成员为 `@Nonbinding` 时，这一点毫无用处，如 `@Cached` 注解的情况，但在其他情况下，这一点非常重要。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"For example, suppose we have an interceptor that can automatically log method invocations to certain targets.\n"
"The interceptor binding annotation `@Logged` would have a member called `target`, which specifies where to store the log.\n"
"Our implementation could be restricted to console logging and file logging:"
msgstr "例如，假设我们有一个拦截器，可以自动记录对某些目标的方法调用。拦截器绑定注解 `@Logged` 将有一个名为 `target` 的成员，它指定了日志的存储位置。我们的实现可能仅限于控制台日志和文件日志："

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Other interceptors could be provided to log method invocations to different targets."
msgstr "可以提供其他拦截器来记录对不同目标的方法调用。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Caching the Result of Programmatic Lookup"
msgstr "缓存程序化查询的结果"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In certain situations, it is practical to obtain a bean instance programmatically via an injected `jakarta.enterprise.inject.Instance` and `Instance.get()`.\n"
"However, according to the specification the `get()` method must identify the matching bean and obtain a contextual reference.\n"
"As a consequence, a new instance of a  `@Dependent` bean is returned from each invocation of `get()`.\n"
"Moreover, this instance is a dependent object of the injected `Instance`.\n"
"This behavior is well-defined, but it may lead to unexpected errors and memory leaks.\n"
"Therefore, Quarkus comes with the `io.quarkus.arc.WithCaching` annotation.\n"
"An injected `Instance` annotated with this annotation will cache the result of the `Instance#get()` operation.\n"
"The result is computed on the first call and the same value is returned for all subsequent calls, even for `@Dependent` beans."
msgstr "在某些情况下，通过注入的 `jakarta.enterprise.inject.Instance` 和 `Instance.get()` 以编程方式获取 Bean 实例是可行的。但是，根据规范， `get()` 方法必须识别匹配的 Bean 并获取上下文引用。因此，每次调用 `get()` 时，都会返回一个新的 `@Dependent` Bean 实例。此外，该实例是注入的 `Instance` 的从属对象。这种行为定义明确，但可能会导致意想不到的错误和内存泄漏。因此，Quarkus 附带了 `io.quarkus.arc.WithCaching` 注释。注入了该注解的 `Instance` 将缓存 `Instance#get()` 操作的结果。第一次调用会计算出结果，随后的所有调用都会返回相同的值，即使是 `@Dependent` bean 也不例外。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "It is also possible to clear the cached value via `io.quarkus.arc.InjectableInstance.clearCache()`. In this case, you'll need to inject the Quarkus-specific `io.quarkus.arc.InjectableInstance` instead of `jakarta.enterprise.inject.Instance`."
msgstr "也可以通过 `io.quarkus.arc.InjectableInstance.clearCache()` 来清除缓存的值。在这种情况下，你需要注入Quarkus专用的 `io.quarkus.arc.InjectableInstance` ，而不是 `javax.enterprise.inject.Instance` 。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Declaratively Choose Beans That Can Be Obtained by Programmatic Lookup"
msgstr "声明性地选择可通过程序化查询获得的豆类"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"It is sometimes useful to narrow down the set of beans that can be obtained by programmatic lookup via `jakarta.enterprise.inject.Instance`.\n"
"Typically, a user needs to choose the appropriate implementation of an interface based on a runtime configuration property."
msgstr "有时，通过 `jakarta.enterprise.inject.Instance` 缩小可通过编程查找获得的 Bean 集范围是非常有用的。通常情况下，用户需要根据运行时配置属性来选择合适的接口实现。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Imagine that we have two beans implementing the interface `org.acme.Service`.\n"
"You can't inject the `org.acme.Service` directly unless your implementations declare a CDI qualifier.\n"
"However, you can inject the `Instance<Service>` instead, then iterate over all implementations and choose the correct one manually.\n"
"Alternatively, you can use the `@LookupIfProperty` and `@LookupUnlessProperty` annotations.\n"
"`@LookupIfProperty` indicates that a bean should only be obtained if a runtime configuration property matches the provided value.\n"
"`@LookupUnlessProperty`, on the other hand, indicates that a bean should only be obtained if a runtime configuration property does not match the provided value."
msgstr "想象一下，我们有两个实现接口 `org.acme.Service` 的 Bean。您不能直接注入 `org.acme.Service` ，除非您的实现声明了 CDI 限定符。不过，您可以注入 `Instance<Service>` ，然后遍历所有实现并手动选择正确的实现。另外，您还可以使用 `@LookupIfProperty` 和 `@LookupUnlessProperty` 注释。 `@LookupIfProperty` 表示，只有当运行时配置属性与提供的值相匹配时，才能获取 bean。 `@LookupUnlessProperty` 而  注解则表示，只有当运行时配置属性与提供的值不匹配时，才应获取 Bean。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`@LookupIfProperty` Example"
msgstr " `@LookupIfProperty` 例子"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Injecting Multiple Bean Instances Intuitively"
msgstr "直观地注入多个Bean实例"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In CDI, it's possible to inject multiple bean instances (aka contextual references) via the `jakarta.enterprise.inject.Instance` which implements `java.lang.Iterable`.\n"
"However, it's not exactly intuitive.\n"
"Therefore, a new way was introduced in Quarkus - you can inject a `java.util.List` annotated with the `io.quarkus.arc.All` qualifier.\n"
"The type of elements in the list is used as the required type when performing the lookup."
msgstr "在 CDI 中，可以通过实现 `java.lang.Iterable` 的 `jakarta.enterprise.inject.Instance` 注入多个 Bean 实例（又称上下文引用）。不过，这并不直观。因此，Quarkus 引入了一种新方法--您可以注入一个用 `io.quarkus.arc.All` 限定符注释的 `java.util.List` 。在执行查找时，列表中元素的类型将被用作所需的类型。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The injected instance is an _immutable list_ of the contextual references of the _disambiguated_ beans."
msgstr "注入的实例是一个 _不可变的列表_ ，其中包含了 _被消除歧义的_ Bean的上下文引用。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "For this injection point the required type is `Service` and no additional qualifiers are declared."
msgstr "对于这个注入点，所需的类型是 `Service` ，没有声明额外的限定符。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "The list is sorted by priority as defined by `io.quarkus.arc.InjectableBean#getPriority()`. Higher priority goes first. In general, the `@jakarta.annotation.Priority` annotation can be used to assign the priority to a class bean, producer method or producer field."
msgstr "列表按照 `io.quarkus.arc.InjectableBean#getPriority()` 所定义的优先级进行排序。优先级越高越好。一般来说， `@javax.annotation.Priority` 和 `@io.quarkus.arc.Priority` 注解可以用来给类豆、生产者方法或生产者字段分配优先级。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "If an injection point declares no other qualifier than `@All` then `@Any` is used, i.e. the behavior is equivalent to `@Inject @Any Instance<Service>`."
msgstr "如果一个注入点除了 `@All` ，没有声明其他限定词，那么就使用 `@Any` ，即行为等同于 `@Inject @Any Instance<Service>` 。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"You can also inject a list of bean instances wrapped in `io.quarkus.arc.InstanceHandle`.\n"
"This can be useful if you need to inspect the related bean metadata."
msgstr "您还可以注入用 `io.quarkus.arc.InstanceHandle` 封装的 Bean 实例列表。如果您需要检查相关的 Bean 元数据，这将非常有用。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Neither a type variable nor a wildcard is a legal type parameter for an `@All List<>` injection point, i.e. `@Inject @All List<?> all` is not supported and results in a deployment error."
msgstr "类型变量和通配符都不是 `@All List<>` 注入点的合法类型参数，即不支持 `@Inject @All List<?> all` ，导致部署错误。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "It is also possible to obtain the list of all bean instance handles programmatically via the `Arc.container().listAll()` methods."
msgstr "也可以通过 `Arc.container().listAll()` 方法以编程方式获得所有bean实例柄的列表。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Ignoring Class-Level Interceptor Bindings for Methods and Constructors"
msgstr "忽略方法和构造器的类级拦截器绑定"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If a managed bean declares interceptor binding annotations on the class level, the corresponding `@AroundInvoke` interceptors will apply to all business methods.\n"
"Similarly, the corresponding `@AroundConstruct` interceptors will apply to the bean constructor."
msgstr "如果托管 bean 在类级别声明了拦截器绑定注解，则相应的 `@AroundInvoke` 拦截器将适用于所有业务方法。同样，相应的 `@AroundConstruct` 拦截器也将应用于 bean 构造函数。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "For example, suppose we have a logging interceptor with the `@Logged` binding annotation and a tracing interceptor with the `@Traced` binding annotation:"
msgstr "例如，假设我们有一个带有 `@Logged` 绑定注释的日志拦截器和一个带有 `@Traced` 绑定注释的追踪拦截器。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In this example, both `doSomething` and `doSomethingElse` will be intercepted by the hypothetical logging interceptor.\n"
"Additionally, the `doSomethingElse` method will be intercepted by the hypothetical tracing interceptor."
msgstr "在本例中，假定日志拦截器将拦截 `doSomething` 和 `doSomethingElse` 。此外， `doSomethingElse` 方法也将被假设的跟踪拦截器拦截。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Now, if that `@Traced` interceptor also performed all the necessary logging, we'd like to skip the `@Logged` interceptor for this method, but keep it for all other methods.\n"
"To achieve that, you can annotate the method with `@NoClassInterceptors`:"
msgstr "现在，如果 `@Traced` 拦截器也执行了所有必要的日志记录，我们希望跳过该方法的 `@Logged` 拦截器，但在所有其他方法中保留它。要做到这一点，可以用 `@NoClassInterceptors` 来注解该方法："

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `@NoClassInterceptors` annotation may be put on methods and constructors and means that all class-level interceptors are ignored for these methods and constructors.\n"
"In other words, if a method/constructor is annotated `@NoClassInterceptors`, then the only interceptors that will apply to this method/constructor are interceptors declared directly on the method/constructor."
msgstr "`@NoClassInterceptors` 注解可用于方法和构造函数，这意味着这些方法和构造函数将忽略所有类级拦截器。换句话说，如果一个方法/构造函数被注解为 `@NoClassInterceptors` ，那么适用于该方法/构造函数的拦截器只能是直接在该方法/构造函数上声明的拦截器。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "This annotation affects only business method interceptors (`@AroundInvoke`) and constructor lifecycle callback interceptors (`@AroundConstruct`)."
msgstr "这个注解只影响业务方法拦截器 ( `@AroundInvoke` ) 和构造函数生命周期回调拦截器 ( `@AroundConstruct` )。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Exceptions Thrown By An Asynchronous Observer Method"
msgstr "异步观察者方法抛出的异常情况"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"If an exception is thrown by an asynchronous observer then the `CompletionStage` returned by the `fireAsync()` method completes exceptionally so that the event producer may react appropriately.\n"
"However, if the event producer does not care then the exception is ignored silently.\n"
"Therefore, Quarkus logs an error message by default.\n"
"It is also possible to implement a custom `AsyncObserverExceptionHandler`.\n"
"A bean that implements this interface should be `@jakarta.inject.Singleton` or `@jakarta.enterprise.context.ApplicationScoped`."
msgstr "如果异步观察者抛出异常，那么 `fireAsync()` 方法返回的 `CompletionStage` 会异常完成，以便事件生产者做出适当反应。但是，如果事件生产者并不关心，那么异常就会被无声地忽略。因此，Quarkus 默认会记录一条错误信息。也可以实现自定义的 `AsyncObserverExceptionHandler` 。实现该接口的 Bean 应该是 `@jakarta.inject.Singleton` 或 `@jakarta.enterprise.context.ApplicationScoped` 。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "`NoopAsyncObserverExceptionHandler`"
msgstr " `NoopAsyncObserverExceptionHandler` "

#: _versions/main/guides/cdi-reference.adoc
msgid "Intercepted self-invocation"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus supports what is known as intercepted self-invocation or just self-interception - a scenario where CDI bean invokes its own intercepted method from within another method while triggering any associated interceptors.\n"
"This is a non-standard feature as CDI specification doesn't define whether self-interception should work or not."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Suppose we have a CDI bean with two methods, one of which has the `@Transactional` interceptor binding associated with it:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "One or more interceptor bindings; `@Transactional` is just an example."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Non-intercepted method invoking another method from the same bean that has associated binding(s); this will trigger interception."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In the above example, any code calling the `doSomething()` method triggers interception - in this case, the method becomes transactional.\n"
"This is regardless of whether the invocation originated directly from the `MyService` bean (such as `MyService#doSomethingElse`) or from some other bean."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Intercepting Producer Methods and Synthetic Beans"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"By default, interception is only supported for managed beans (also known as class-based beans).\n"
"To support interception of producer methods and synthetic beans, the CDI specification includes an `InterceptionFactory`, which is a runtime oriented concept and therefore cannot be supported in Quarkus."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Instead, Quarkus has its own API: `InterceptionProxy` and `@BindingsSource`.\n"
"The `InterceptionProxy` is very similar to `InterceptionFactory`: it creates a proxy that applies `@AroundInvoke` interceptors before forwarding the method call to the target instance.\n"
"The `@BindingsSource` annotation allows setting interceptor bindings in case the intercepted class is external and cannot be changed."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Declares an injection point of type `InterceptionProxy<MyClass>`.\n"
"This means that at build time, a subclass of `MyClass` is generated that does the interception and forwarding.\n"
"Note that the type argument must be identical to the return type of the producer method."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Creates an instance of the interception proxy for the given instance of `MyClass`.\n"
"The method calls will be forwarded to this target instance after all interceptors run."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "In this example, interceptor bindings are read from the `MyClass` class."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Note that `InterceptionProxy` only supports `@AroundInvoke` interceptors declared on interceptor classes.\n"
"Other kinds of interception, as well as `@AroundInvoke` interceptors declared on the target class and its superclasses, are not supported."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The intercepted class should be https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1#unproxyable[proxyable] and therefore should not be `final`, should not have non-private `final` methods, and should have a non-private zero-parameter constructor.\n"
"If it isn't, a bytecode transformation will attempt to fix it if <<unproxyable_classes_transformation,enabled>>, but note that adding a zero-parameter constructor is not always possible."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"It is often the case that the produced classes come from external libraries and don't contain interceptor binding annotations at all.\n"
"To support such cases, the `@BindingsSource` annotation may be declared on the `InterceptionProxy` parameter:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "A class that mirrors the `MyClass` structure and contains interceptor bindings."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "The `@BindingsSource` annotation says that interceptor bindings for `MyClass` should be read from `MyClassBindings`."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "The concept of _bindings source_ is a build-time friendly equivalent of `InterceptionFactory.configure()`."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Producer method interception and synthetic bean interception only works for instance methods.\n"
"<<interception_of_static_methods>> is not supported for producer methods and synthetic beans."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Declaring `@BindingsSource`"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The `@BindingsSource` annotation specifies a class that mirrors the structure of the intercepted class.\n"
"Interceptor bindings are then read from that class and treated as if they were declared on the intercepted class."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Specifically: class-level interceptor bindings declared on the bindings source class are treated as class-level bindings of the intercepted class.\n"
"Method-level interceptor bindings declared on the bindings source class are treated as method-level bindings of a method with the same name, return type, parameter types and `static` flag of the intercepted class."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "It is common to make the bindings source class and methods `abstract` so that you don't have to write method bodies:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Since this class is never instantiated and its method are never invoked, this is okay, but it's also possible to create a non-`abstract` class:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "The method body does not matter."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Note that for generic classes, the type variable names must also be identical.\n"
"For example, for the following class:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "the bindings source class must also use `T` as the name of the type variable:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"You don't need to declare methods that are not annotated simply because they exist on the intercepted class.\n"
"If you want to add method-level bindings to a subset of methods, you only have to declare the methods that are supposed to have an interceptor binding.\n"
"If you only want to add class-level bindings, you don't have to declare any methods at all."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "These annotations can be present on a bindings source class:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "_interceptor bindings_: on the class and on the methods"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "_stereotypes_: on the class"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "`@NoClassInterceptors`: on the methods"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Any other annotation present on a bindings source class is ignored."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Synthetic Beans"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Using `InterceptionProxy` in synthetic beans is similar."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "First, you have to declare that your synthetic bean injects the `InterceptionProxy`:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Once again, this means that at build time, a subclass of `MyClass` is generated that does the interception and forwarding."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Second, you have to obtain the `InterceptionProxy` from the `SyntheticCreationalContext` in the `BeanCreator` and use it:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Obtains the `InterceptionProxy` for `MyClass`, as declared above.\n"
"It would also be possible to use the `getInjectedReference()` method, passing a `TypeLiteral`, but `getInterceptionProxy()` is easier."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"There's also an equivalent of `@BindingsSource`.\n"
"The `injectInterceptionProxy()` method has an overload with a parameter:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "The argument is the bindings source class."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Pitfalls with Reactive Programming"
msgstr "反应式编程的陷阱"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"CDI is a purely synchronous framework.\n"
"Its notion of asynchrony is very limited and based solely on thread pools and thread offloading.\n"
"Therefore, there is a number of pitfalls when using CDI together with reactive programming."
msgstr "CDI 是一个纯粹的同步框架。它的异步概念非常有限，仅基于线程池和线程卸载。因此，在将 CDI 与反应式编程结合使用时，会存在许多隐患。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Detecting When Blocking Is Allowed"
msgstr "检测何时允许阻塞"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `io.quarkus.runtime.BlockingOperationControl#isBlockingAllowed()` method can be used to detect whether blocking is allowed on the current thread.\n"
"When it is not, and you need to perform a blocking operation, you have to offload it to another thread.\n"
"The easiest way is to use the `Vertx.executeBlocking()` method:"
msgstr "`io.quarkus.runtime.BlockingOperationControl#isBlockingAllowed()` 方法可用于检测当前线程是否允许阻塞。当不允许阻塞时，如果需要执行阻塞操作，就必须将其卸载到另一个线程。最简单的方法是使用 `Vertx.executeBlocking()` 方法："

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Build Time Extensions"
msgstr "延长建造时间"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Quarkus incorporates build-time optimizations in order to provide instant startup and low memory footprint.\n"
"The downside of this approach is that CDI Portable Extensions cannot be supported.\n"
"Nevertheless, most of the functionality can be achieved using Quarkus xref:writing-extensions.adoc[extensions].\n"
"See the xref:cdi-integration.adoc[integration guide] for more information."
msgstr "Quarkus 在构建时进行了优化，以提供即时启动和低内存占用。这种方法的缺点是无法支持 CDI 可移植扩展。不过，大部分功能都可以通过 Quarkus xref:writing-extensions.adoc[扩展] 实现。更多信息，请参阅 xref:cdi-integration.adoc[集成指南] 。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "[[development-mode]] Dev mode"
msgstr " 开发模式"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In dev mode, two special endpoints are registered automatically to provide some basic debug info in the JSON format:"
msgstr "在开发模式下，会自动注册两个特殊端点，以 JSON 格式提供一些基本调试信息："

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "HTTP GET `/q/arc` - returns the summary; number of beans, config properties, etc."
msgstr "HTTP GET `/q/arc` - 返回摘要；豆的数量、配置属性等。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "HTTP GET `/q/arc/beans` - returns the list of all beans"
msgstr "HTTP GET `/q/arc/beans` - 返回所有豆子的列表"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "You can use query params to filter the output:"
msgstr "你可以使用查询参数来过滤输出。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`scope` - include beans with scope that ends with the given value, i.e. `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`"
msgstr " `scope` - 包括具有以给定值结束的范围的豆子，即 `<a href=\"http://localhost:8080/q/arc/beans?scope=ApplicationScoped\" class=\"bare\">http://localhost:8080/q/arc/beans?scope=ApplicationScoped</a>` "

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`beanClass` - include beans with bean class that starts with the given value, i.e. `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`"
msgstr " `beanClass` - 包括具有以给定值开头的豆类的豆子，即 `<a href=\"http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo\" class=\"bare\">http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo</a>` "

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "`kind` - include beans of the specified kind (`CLASS`, `PRODUCER_FIELD`, `PRODUCER_METHOD`, `INTERCEPTOR` or `SYNTHETIC`), i.e. `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`"
msgstr " `kind` - 包括指定种类的豆子（ , , , 或 ），即 `CLASS` `PRODUCER_FIELD` `PRODUCER_METHOD` `INTERCEPTOR` `SYNTHETIC` `<a href=\"http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD\" class=\"bare\">http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD</a>` "

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "HTTP GET `/q/arc/removed-beans` - returns the list of unused beans removed during build"
msgstr "HTTP GET `/q/arc/removed-beans` - 返回在构建过程中移除的未使用的Bean列表。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "HTTP GET `/q/arc/observers` - returns the list of all observer methods"
msgstr "HTTP GET `/q/arc/observers` - 返回所有观察者方法的列表"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "These endpoints are only available in dev mode, i.e. when you run your application via `mvn quarkus:dev` (or `./gradlew quarkusDev`)."
msgstr "这些端点仅在开发模式下可用，即通过 `mvn quarkus:dev` （或 `./gradlew quarkusDev` ）运行应用程序时可用。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Monitoring Business Method Invocations and Events"
msgstr "监测业务方法调用和事件"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"In dev mode, it is also possible to enable monitoring of business method invocations and fired events.\n"
"Simply set the `quarkus.arc.dev-mode.monitoring-enabled` configuration property to `true` and explore the relevant Dev UI pages."
msgstr "在开发模式下，还可以启用对业务方法调用和触发事件的监控。只需将 `quarkus.arc.dev-mode.monitoring-enabled` 配置属性设置为 `true` ，然后访问相关的开发用户界面页面即可。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "Strict Mode"
msgstr "严格的模式"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"By default, ArC does not perform all validations required by the CDI specification.\n"
"It also improves CDI usability in many ways, some of them being directly against the specification."
msgstr "默认情况下，ArC 不会执行 CDI 规范要求的所有验证。ArC 还能以多种方式提高 CDI 的可用性，其中一些方式直接与规范相对应。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"To pass the CDI Lite TCK, ArC also has a _strict_ mode.\n"
"This mode enables additional validations and disables certain improvements that conflict with the specification."
msgstr "为了通过 CDI Lite TCK，ArC 还有一个 _严格_ 模式。该模式启用了额外的验证，并禁用了某些与规范冲突的改进。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "To enable the strict mode, use the following configuration:"
msgstr "要启用严格模式，请使用以下配置："

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Some other features affect specification compatibility as well:"
msgstr "其他一些特征也会影响规范的兼容性："

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "<<unproxyable_classes_transformation,Transformation of unproxyable classes>>"
msgstr "xref:unproxyable_classes_transformation[不可代理类的转换]"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "<<remove_unused_beans,Unused beans removal>>"
msgstr "xref:remove_unused_beans[清除未使用的豆子]"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "To get a behavior closer to the specification, these features should be disabled."
msgstr "为了获得更接近规范的行为，应该禁用这些功能。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Applications are recommended to use the default, non-strict mode, which makes CDI more convenient to use.\n"
"The \"strictness\" of the strict mode (the set of additional validations and the set of disabled improvements on top of the CDI specification) may change over time."
msgstr "建议应用程序使用默认的非严格模式，这样可以更方便地使用 CDI。严格模式的 \"严格程度\"（附加验证集和 CDI 规范基础上的禁用改进集）可能会随着时间的推移而改变。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, fuzzy, no-wrap
msgid "ArC Configuration Reference"
msgstr "ArC 配置参考"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "<span class=\"icon\"><i class=\"fa fa-lock\" title=\"Fixed at build time\"></i></span> Configuration property fixed at build time - All other configuration properties are overridable at runtime <input type=\"search\" id=\"config-search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"
msgstr "<span class=\"icicon\"><i class=\"fa fa-lock\" title=\"在构建时固定\"></i></span>在构建时固定的配置属性 - 所有其他配置属性都可在运行时重写 <input type=\"search\" id=\"config-search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"
