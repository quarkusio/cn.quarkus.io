# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-21 02:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Using the Cassandra Client"
msgstr "使用卡桑德拉客户端"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Apache Cassandra® is a free and open-source, distributed, wide column store, NoSQL database\n"
"management system designed to handle large amounts of data across many commodity servers, providing\n"
"high availability with no single point of failure."
msgstr "Apache Cassandra® 是一种免费、开源、分布式、宽列存储、NoSQL 数据库管理系统，旨在跨多个商品服务器处理大量数据，提供无单点故障的高可用性。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "In this guide, we will see how you can get your REST services to use a Cassandra database."
msgstr "在本指南中，我们将看到如何让你的REST服务使用Cassandra数据库。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"A running link:https://cassandra.apache.org[Apache Cassandra],\n"
"link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise] (DSE) or\n"
"link:https://astra.datastax.com[DataStax Astra] database; or alternatively, a fresh Docker\n"
"installation."
msgstr "运行中的 link:https://cassandra.apache.org[Apache Cassandra] 、 link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise] (DSE) 或 link:https://astra.datastax.com[DataStax Astra] 数据库；或者，全新安装的 Docker。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, no-wrap
msgid "Architecture"
msgstr "应用结构"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"This quickstart guide shows how to build a REST application using the\n"
"link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkus extension], which allows you to\n"
"connect to an Apache Cassandra, DataStax Enterprise (DSE) or DataStax Astra database, using the\n"
"link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Java driver]."
msgstr "本快速入门指南介绍如何使用 link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkus 扩展] 构建 REST 应用程序，该 link:https://github.com/datastax/cassandra-quarkus[扩展] 允许您使用 link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Java 驱动程序] 连接 Apache Cassandra、DataStax Enterprise (DSE) 或 DataStax Astra 数据库。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"This guide will also use the\n"
"link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper]\n"
"– a powerful Java-to-CQL mapping framework that greatly simplifies your application's data access\n"
"layer code by sparing you the hassle of writing your CQL queries by hand."
msgstr "本指南还将使用 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] ，这是一个功能强大的 Java 到 CQL 映射框架，可大大简化应用程序的数据访问层代码，免去手动编写 CQL 查询的麻烦。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The application built in this quickstart guide is quite simple: the user can add elements in a list\n"
"using a form, and the items list is updated. All the information between the browser and the server\n"
"is formatted as JSON, and the elements are stored in the Cassandra database."
msgstr "本快速入门指南中构建的应用程序非常简单：用户可以使用表单在列表中添加元素，然后更新项目列表。浏览器和服务器之间的所有信息都是 JSON 格式，元素存储在 Cassandra 数据库中。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, no-wrap
msgid "Solution"
msgstr "解决方案"

#: _versions/main/guides/cassandra.adoc
msgid ""
"We recommend that you follow the instructions in the next sections and create the application step\n"
"by step. However, you can go right to the completed example."
msgstr "我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The solution is located in the\n"
"link:https://github.com/datastax/cassandra-quarkus/tree/main/quickstart[quickstart directory] of\n"
"the Cassandra Quarkus extension GitHub repository."
msgstr "该解决方案位于 Cassandra Quarkus 扩展 GitHub 代码库的 link:https://github.com/datastax/cassandra-quarkus/tree/main/quickstart[quickstart 目录] 中。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Creating a Blank Maven Project"
msgstr "创建一个空白的Maven项目"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"First, create a new Maven project and copy the `pom.xml` file that is present in the `quickstart`\n"
"directory."
msgstr "首先，创建一个新的 Maven 项目，并复制 `quickstart` 目录中的 `pom.xml` 文件。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "The `pom.xml` is importing all the Quarkus extensions and dependencies you need."
msgstr " `pom.xml` 是导入所有你需要的Quarkus扩展和依赖。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Creating the Data Model and Data Access Objects"
msgstr "创建数据模型和数据访问对象"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
msgid "In this example, we will create an application to manage a list of fruits."
msgstr "在这个例子中，我们将创建一个应用程序来管理fruit列表。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "First, let's create our data model – represented by the `Fruit` class – as follows:"
msgstr "首先，让我们创建我们的数据模型--由 `Fruit` 类表示--如下。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"As stated above, we are using the DataStax Object Mapper. In other words, we are not going to write\n"
"our CQL queries manually; instead, we will annotate our data model with a few annotations, and the\n"
"mapper will generate proper CQL queries underneath."
msgstr "如上所述，我们正在使用 DataStax 对象映射器。换句话说，我们不打算手动编写 CQL 查询；相反，我们将用一些注释来注解我们的数据模型，然后映射器将在下面生成适当的 CQL 查询。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"This is why the `Fruit` class is annotated with `@Entity`: this annotation marks it as an _entity\n"
"class_ that is mapped to a Cassandra table. Its instances are meant to be automatically persisted\n"
"into, and retrieved from, the Cassandra database. Here, the table name will be inferred from the\n"
"class name: `fruit`."
msgstr "这就是 `Fruit` 类被注释为 `@Entity` 的原因：该注释将其标记为映射到 Cassandra 表的 _实体类_ 。其实例将自动持久化到 Cassandra 数据库中，并从 Cassandra 数据库中检索。这里，表名将从类名推断出： `fruit` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Also, the `name` field represents a Cassandra partition key, and so we are annotating it with\n"
"`@PartitionKey` – another annotation from the Object Mapper library."
msgstr "此外， `name` 字段代表 Cassandra 分区键，因此我们用 `@PartitionKey` 对其进行注解，这是对象映射器库的另一个注解。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Entity classes are normally required to have a default no-arg constructor, unless they\n"
"are annotated with `@PropertyStrategy(mutable = false)`, which is the case here."
msgstr "实体类通常需要有一个默认的无参数构造函数，除非它们被注释为 `@PropertyStrategy(mutable = false)` ，这里就是这种情况。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The next step is to create a DAO (Data Access Object) interface that will manage instances of\n"
"`Fruit` entities:"
msgstr "下一步是创建一个 DAO（数据访问对象）接口，用于管理 `Fruit` 实体的实例："

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"This interface exposes operations that will be used in our REST service. Again, the annotation\n"
"`@Dao` comes from the DataStax Object Mapper, which will also automatically generate an\n"
"implementation of this interface for you."
msgstr "该接口公开了将在 REST 服务中使用的操作。注释 `@Dao` 同样来自 DataStax Object Mapper，它还会自动为您生成该接口的实现。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Note also the special return type of the `findAll` method,\n"
"link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[`PagingIterable`]:\n"
"it's the base type of result sets returned by the driver."
msgstr "还要注意 `findAll` 方法的特殊返回类型、 link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[PagingIterable] ：它是驱动程序返回结果集的基本类型。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Finally, let's create a Mapper interface:"
msgstr "最后，让我们创建一个Mapper接口。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The `@Mapper` annotation is yet another annotation recognized by the DataStax Object Mapper. A\n"
"mapper is responsible for constructing DAO instances – in this case, out mapper is constructing\n"
"an instance of our only DAO, `FruitDao`."
msgstr "`@Mapper` 注解是 DataStax 对象映射器识别的另一个注解。映射器负责构建 DAO 实例--在本例中，映射器正在构建我们唯一的 DAO `FruitDao` 的实例。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Think of the mapper interface as a factory for DAO beans. If you intend to construct and inject a\n"
"specific DAO bean in your own code, then you first must add a `@DaoFactory` method for it in a\n"
"`@Mapper` interface."
msgstr "将映射器接口视为 DAO Bean 的工厂。如果您打算在自己的代码中构建和注入特定的 DAO Bean，那么首先必须在 `@Mapper` 接口中为其添加一个 `@DaoFactory` 方法。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "`@DaoFactory` method names are irrelevant."
msgstr " `@DaoFactory` 方法名称是不相关的。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "`@DaoFactory` methods should return beans of the following types:"
msgstr " `@DaoFactory` 方法应该返回以下类型的豆子。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Any `@Dao`-annotated interface, e.g. `FruitDao`;"
msgstr "你的项目中所有 `@Mapper` -注释的接口。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "A `CompletionStage` of any `@Dao`-annotated interface, e.g. `CompletionStage<FruitDao>`."
msgstr "任何 `@Dao` - 注释的接口的 `CompletationStage` ，例如 `CompletionStage<FruitDao>` 。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "A `Uni` of any `@Dao`-annotated interface, e.g. `Uni<FruitDao>`."
msgstr "任何 `@Dao` - 注释的接口的 `Uni` ，例如 `Uni<FruitDao>` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"`Uni` is a type from the Mutiny library, which is the reactive programming library used by\n"
"Quarkus. This will be explained in more detail in the \"Reactive Programming\" section below."
msgstr "`Uni` 是 Quarkus 使用的反应式编程库 Mutiny 库中的一种类型。下文的 \"反应式编程 \"部分将对此进行更详细的解释。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Generating the DAO and mapper implementations"
msgstr "生成DAO和映射器的实现"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"As you probably guessed already, we are not going to implement the interfaces above. Instead, the\n"
"Object Mapper will generate such implementations for us."
msgstr "您可能已经猜到，我们不会实现上述接口。相反，对象映射器会为我们生成这样的实现。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "The Object Mapper is composed of 2 pieces:"
msgstr "对象映射器由2个部分组成。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"A (compile-time) annotation processor that scans the classpath for classes annotated with\n"
"`@Mapper`, `@Dao` or `@Entity`, and generates code and CQL queries for them; and"
msgstr "一个（编译时）注释处理器，可扫描类路径，查找注释为 `@Mapper` 、 `@Dao` 或 `@Entity` 的类，并为其生成代码和 CQL 查询；以及"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "A runtime module that contains the logic to execute the generated queries."
msgstr "一个运行时模块，包含执行生成的查询的逻辑。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Therefore, enabling the Object Mapper requires two steps:"
msgstr "因此，启用Object Mapper需要两个步骤。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Declare the `cassandra-quarkus-mapper-processor` annotation processor. With Maven, this is done\n"
"by modifying the compiler plugin configuration in the project's `pom.xml` file as follows:"
msgstr "声明 `cassandra-quarkus-mapper-processor` 注释处理器。使用 Maven 时，可通过修改项目 `pom.xml` 文件中的编译器插件配置来实现，具体做法如下："

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "With Gradle, this is done by adding the following line to the `build.gradle` file:"
msgstr "在Gradle中，这可以通过在 `build.gradle` 文件中添加以下一行来完成。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Verify that you are enabling the right annotation processor! The Cassandra driver ships\n"
"with its Object Mapper annotation processor, called `java-driver-mapper-processor`. But the\n"
"Cassandra Quarkus extension also ships with its own annotation processor:\n"
"`cassandra-quarkus-mapper-processor`, which has more capabilities than the driver's. This annotation\n"
"processor is the only one suitable for use in a Quarkus application, so check that this is the one\n"
"in use. Also, never use both annotation processors together."
msgstr "确认是否启用了正确的注释处理器！Cassandra 驱动程序自带对象映射器注释处理器，名为 `java-driver-mapper-processor` 。但是，Cassandra Quarkus 扩展也配备了自己的注释处理器： `cassandra-quarkus-mapper-processor` 它比驱动程序的注释处理器功能更强大。该注释处理器是唯一适合在 Quarkus 应用程序中使用的注释处理器，因此请检查这是否是正在使用的注释处理器。此外，切勿同时使用两个注释处理器。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Declare the `java-driver-mapper-runtime` dependency in compile scope in the project's `pom.xml`\n"
"file as follows:"
msgstr "在项目 `pom.xml` 文件的编译作用域中声明 `java-driver-mapper-runtime` 依赖关系，如下所示："

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Although this module is called \"runtime\", it must be declared in compile scope."
msgstr "尽管这个模块被称为 \"运行时\"，但它必须在编译范围内声明。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"If your project is correctly set up, you should now be able to compile it without errors, and you\n"
"should see the generated code in the `target/generated-sources/annotations` directory (if you are\n"
"using Maven). It's not required to get familiar with the generated code though, as it is mostly\n"
"internal machinery to interact with the database."
msgstr "如果项目设置正确，现在就可以顺利编译，并在 `target/generated-sources/annotations` 目录中看到生成的代码（如果使用 Maven）。不过不需要熟悉生成的代码，因为它主要是与数据库交互的内部机制。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Creating a service & JSON REST endpoint"
msgstr "创建一个服务和JSON REST端点"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Now let's create a `FruitService` that will be the business layer of our application and store/load\n"
"the fruits from the Cassandra database."
msgstr "现在，让我们创建一个 `FruitService` ，作为应用程序的业务层，并从 Cassandra 数据库中存储/加载水果。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Note how the service is being injected a `FruitDao` instance. This DAO instance is injected\n"
"automatically, thanks to the generated implementations."
msgstr "请注意服务是如何被注入 `FruitDao` 实例的。这个 DAO 实例是自动注入的，这要归功于生成的实现。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The Cassandra Quarkus extension allows you to inject any of the following beans in your own\n"
"components:"
msgstr "Cassandra Quarkus 扩展允许您在自己的组件中注入以下任何 Bean："

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "All `@Mapper`-annotated interfaces in your project."
msgstr "你的项目中所有 `@Mapper` -注释的接口。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "You can also inject a `CompletionStage` or `Uni` of any `@Mapper`-annotated interface."
msgstr "你也可以注入一个 `CompletionStage` 或 `Uni` 的任何 `@Mapper` -注释的接口。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Any bean returned by a `@DaoFactory` method (see above for possible bean types)."
msgstr "任何由 `@DaoFactory` 方法返回的bean（可能的bean类型见上文）。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The\n"
"link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`]\n"
"bean: this application-scoped, singleton bean is your main entry point to the Cassandra client; it\n"
"is a specialized Cassandra driver session instance with a few methods tailored especially for\n"
"Quarkus. Read its javadocs carefully!"
msgstr "的 link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[QuarkusCqlSession] Bean：这个应用范围内的单例 Bean 是 Cassandra 客户端的主要入口；它是一个专门的 Cassandra 驱动程序会话实例，带有一些专门为 Quarkus 定制的方法。请仔细阅读其 javadocs！"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "You can also inject `CompletionStage<QuarkusCqlSession>` or `Uni<QuarkusCqlSession>`."
msgstr "你也可以注射 `CompletationStage<QuarkusCqlSession>` 或 `Uni<QuarkusCqlSession>` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"In our example, both `FruitMapper` and `FruitDao` could be injected anywhere. We chose to inject\n"
"`FruitDao` in `FruitService`."
msgstr "在我们的示例中， `FruitMapper` 和 `FruitDao` 都可以注入到任何地方。我们选择在 `FruitService` 中注入 `FruitDao` 。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "The last missing piece is the REST API that will expose GET and POST methods:"
msgstr "最后缺少的部分是REST API，它将暴露GET和POST方法。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Notice how `FruitResource` is being injected a `FruitService` instance automatically."
msgstr "注意到 `FruitResource` 是如何被自动注入一个 `FruitService` 实例的。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"It is generally not recommended using the same entity object between the REST API and the data\n"
"access layer. These layers should indeed be decoupled and use distinct APIs in order to allow each\n"
"API to evolve independently of the other. This is the reason why our REST API is using a different\n"
"object: the `FruitDto` class – the word DTO stands for \"Data Transfer Object\". This DTO object will\n"
"be automatically converted to and from JSON in HTTP messages:"
msgstr "一般不建议在 REST API 和数据访问层之间使用相同的实体对象。这些层确实应该解耦，并使用不同的应用程序接口，以便让每个应用程序接口都能独立发展。这就是我们的 REST API 使用不同对象的原因： `FruitDto` 类--DTO 一词代表 \"数据传输对象\"。该 DTO 对象将在 HTTP 消息中自动转换为 JSON 格式或从 JSON 格式转换为 JSON 格式："

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The translation to and from JSON is done automatically by the Quarkus REST (formerly RESTEasy Reactive) extension, which is\n"
"included in this guide's pom.xml file. If you want to add it manually to your application, add the\n"
"below snippet to your application's pom.xml file:"
msgstr "Quarkus REST（前身为 RESTEasy Reactive）扩展会自动完成 JSON 之间的转换，本指南的 pom.xml 文件中包含了该扩展。如果你想手动将其添加到应用程序中，请将以下代码段添加到应用程序的 pom.xml 文件中："

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"DTO classes used by the JSON serialization layer are required to have a default no-arg\n"
"constructor."
msgstr "JSON 序列化层使用的 DTO 类必须有一个默认的无参数构造函数。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The conversion from DTO to JSON is handled automatically for us, but we still must convert from\n"
"`Fruit` to `FruitDto` and vice versa. This must be done manually, which is why we have two\n"
"conversion methods declared in `FruitResource`: `convertToDto` and `convertFromDto`."
msgstr "从 DTO 到 JSON 的转换是自动进行的，但我们仍必须将 `Fruit` 转换为 `FruitDto` ，反之亦然。这必须手动完成，因此我们在 `FruitResource` 中声明了两种转换方法： `convertToDto` 和 `convertFromDto` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"In our example, `Fruit` and `FruitDto` are very similar, so you might wonder why not use\n"
"`Fruit` everywhere. In real life cases though, it's not uncommon to see DTOs and entities having\n"
"very different structures."
msgstr "在我们的示例中， `Fruit` 和 `FruitDto` 非常相似，所以你可能会想，为什么不在所有地方都使用 `Fruit` 呢？但在现实生活中，DTO 和实体的结构大相径庭的情况并不少见。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Connecting to the Cassandra Database"
msgstr "连接到Cassandra数据库"

#. type: Title ===
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Connecting to Apache Cassandra or DataStax Enterprise (DSE)"
msgstr "连接到Apache Cassandra或DataStax Enterprise（DSE）。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The main properties to configure are: `contact-points`, to access the Cassandra database;\n"
"`local-datacenter`, which is required by the driver; and – optionally – the keyspace to bind to."
msgstr "需要配置的主要属性有 `contact-points` ，用于访问 Cassandra 数据库； `local-datacenter` ，驱动程序需要该属性；以及（可选）要绑定的键空间。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
msgid "A sample configuration should look like this:"
msgstr "示例配置应如下所示："

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"In this example, we are using a single instance running on localhost, and the keyspace containing\n"
"our data is `k1`:"
msgstr "在本例中，我们使用在 localhost 上运行的单个实例，包含数据的密钥空间是 `k1` ："

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"If your cluster requires plain text authentication, you must also provide two more settings:\n"
"`username` and `password`."
msgstr "如果群集需要纯文本验证，还必须提供另外两个设置： `username` 和 `password` 。"

#. type: Title ===
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Connecting to a DataStax Astra Cloud Database"
msgstr "连接到DataStax Astra云数据库"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"When connecting to link:https://astra.datastax.com[DataStax Astra], instead of providing a contact\n"
"point and a datacenter, you should provide a so-called _secure connect bundle_, which should point\n"
"to a valid path to an Astra secure connect bundle file. You can download your secure connect bundle\n"
"from the Astra web console."
msgstr "连接到 link:https://astra.datastax.com[DataStax Astra] 时，您不应提供联系点和数据中心，而应提供所谓的 _安全_ 连接捆绑包，该捆绑包应指向 Astra 安全连接捆绑包文件的有效路径。您可以从 Astra 网络控制台下载安全连接捆绑包。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"You will also need to provide a username and password, since authentication is always required on\n"
"Astra clusters."
msgstr "您还需要提供用户名和密码，因为 Astra 群集始终需要进行身份验证。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "A sample configuration for DataStax Astra should look like this:"
msgstr "DataStax Astra的样本配置应该是这样的。"

#. type: Title ===
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Advanced Driver Configuration"
msgstr "高级驱动程序配置"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"You can configure other Java driver settings using `application.conf` or `application.json` files.\n"
"They need to be located in the classpath of your application. All settings will be passed\n"
"automatically to the underlying driver configuration mechanism. Settings defined in\n"
"`application.properties` with the `quarkus.cassandra` prefix will have priority over settings\n"
"defined in `application.conf` or `application.json`."
msgstr "您可以使用 `application.conf` 或 `application.json` 文件配置其他 Java 驱动程序设置。它们需要位于应用程序的类路径中。所有设置都将自动传递给底层驱动程序配置机制。在 `application.properties` 中定义的带有 `quarkus.cassandra` 前缀的设置将优先于在 `application.conf` 或 `application.json` 中定义的设置。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"To see the full list of settings, please refer to the\n"
"link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver\n"
"settings reference]."
msgstr "要查看完整的设置列表，请参阅 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[驱动程序设置参考] 。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Running a Local Cassandra Database"
msgstr "运行本地卡桑德拉数据库"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"By default, the Cassandra client is configured to access a local Cassandra database on port 9042\n"
"(the default Cassandra port)."
msgstr "默认情况下，Cassandra 客户端被配置为通过 9042 端口（默认 Cassandra 端口）访问本地 Cassandra 数据库。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Make sure that the setting `quarkus.cassandra.local-datacenter` matches the datacenter of\n"
"your Cassandra cluster."
msgstr "确保 `quarkus.cassandra.local-datacenter` 的设置与 Cassandra 集群的数据中心相匹配。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"If you don't know the name of your local datacenter, this value can be found by running the\n"
"following CQL query: `SELECT data_center FROM system.local`."
msgstr "如果不知道本地数据中心的名称，可以通过运行以下 CQL 查询找到该值： `SELECT data_center FROM system.local` ."

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"If you want to use Docker to run a Cassandra database, you can use the following command to launch\n"
"one in the background:"
msgstr "如果想使用 Docker 运行 Cassandra 数据库，可以使用以下命令在后台启动一个数据库："

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Next you need to create the keyspace and table that will be used by your application. If you are\n"
"using Docker, run the following commands:"
msgstr "接下来，您需要创建应用程序将使用的键空间和表。如果使用的是 Docker，请运行以下命令："

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "You can also use the CQLSH utility to interactively interrogate your database:"
msgstr "你也可以使用CQLSH工具来交互地询问你的数据库。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Testing the REST API"
msgstr "测试REST API"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "In the project root directory:"
msgstr "在项目根目录下。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Run `mvn clean package` and then `java -jar ./target/cassandra-quarkus-quickstart-*-runner.jar` to start the application;"
msgstr "运行 `mvn clean package` ，然后 `java -jar ./target/cassandra-quarkus-quickstart-*-runner.jar` ，启动应用程序。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Or better yet, run the application in dev mode: `mvn clean quarkus:dev`."
msgstr "或者更好的是，在开发模式下运行应用程序： `mvn clean quarkus:dev` 。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Now you can use curl commands to interact with the underlying REST API."
msgstr "现在你可以使用curl命令与底层的REST API进行交互。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "To create a fruit:"
msgstr "要创造一种水果。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "To retrieve fruits:"
msgstr "捞取水果。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Creating a Frontend"
msgstr "创建一个前台"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Now let's add a simple web page to interact with our `FruitResource`."
msgstr "现在让我们添加一个简单的网页来与我们的 `FruitResource` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Quarkus automatically serves static resources located under the `META-INF/resources` directory. In\n"
"the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the contents\n"
"from link:src/main/resources/META-INF/resources/fruits.html[this file] in it."
msgstr "Quarkus 会自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含 link:src/main/resources/META-INF/resources/fruits.html[该文件] 的内容。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
msgid "You can now interact with your REST service:"
msgstr "现在你可以与你的REST服务进行交互："

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "If you haven't done yet, start your application with `mvn clean quarkus:dev`;"
msgstr "如果你还没有做，请用 `mvn clean quarkus:dev` 开始你的申请。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Point your browser to `http://localhost:8080/fruits.html`;"
msgstr "将您的浏览器指向 `<a href=\"http://localhost:8080/fruits.html\" class=\"bare\">http://localhost:8080/fruits.html</a>` ;"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Add new fruits to the list via the form."
msgstr "通过表格添加新的水果到列表中。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Reactive Programming with the Cassandra Client"
msgstr "使用Cassandra客户端的反应式编程"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The\n"
"link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`\n"
"interface] gives you access to a series of reactive methods that integrate seamlessly with Quarkus\n"
"and its reactive framework, Mutiny."
msgstr "link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[QuarkusCqlSession 界面] 可让你访问一系列与 Quarkus 及其反应式框架 Mutiny 无缝集成的反应式方法。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "If you are not familiar with Mutiny, please check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的反应式编程库] 。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Let's rewrite our application using reactive programming with Mutiny."
msgstr "让我们用Mutiny的反应式编程来重写我们的应用程序。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "First, let's declare another DAO interface that works in a reactive way:"
msgstr "首先，让我们来声明另一个以反应式方式工作的DAO接口。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Note the usage of `MutinyMappedReactiveResultSet` - it is a specialized `Mutiny` type converted from\n"
"the original `Publisher` returned by the driver, which also exposes a few extra methods, e.g. to\n"
"obtain the query execution info. If you don't need anything in that interface, you can also simply\n"
"declare your method to return `Multi`: `Multi<Fruit> findAll()`,"
msgstr "请注意 `MutinyMappedReactiveResultSet` 的用法--它是一种专门的 `Mutiny` 类型，由驱动程序返回的原始 `Publisher` 转换而来，它还提供了一些额外的方法，例如用于获取查询执行信息的方法。如果您不需要该接口中的任何内容，也可以简单地声明您的方法返回 `Multi` : `Multi<Fruit> findAll()` 、"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Similarly, the method `updateAsync` returns a `Uni` - it is automatically converted from the\n"
"original result set returned by the driver."
msgstr "同样，方法 `updateAsync` 返回一个 `Uni` ，它是由驱动程序返回的原始结果集自动转换而来的。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The Cassandra driver uses the Reactive Streams `Publisher` API for reactive calls. The Quarkus\n"
"framework however uses Mutiny. Because of that, the `CqlQuarkusSession` interface transparently\n"
"converts the `Publisher` instances returned by the driver into the reactive type `Multi`.\n"
"`CqlQuarkusSession` is also capable of converting a `Publisher` into a `Uni` – in this case, the\n"
"publisher is expected to emit at most one row, then complete. This is suitable for write queries\n"
"(they return no rows), or for read queries guaranteed to return one row at most (count queries, for\n"
"example)."
msgstr "Cassandra 驱动程序使用 Reactive Streams `Publisher` API 进行反应式调用。不过，Quarkus 框架使用的是 Mutiny。因此， `CqlQuarkusSession` 接口会将驱动程序返回的 `Publisher` 实例透明地转换为反应式类型 `Multi` 。 `CqlQuarkusSession` 也能将 `Publisher` 转换为 `Uni` --在这种情况下，发布者最多只能发布一条记录，然后完成。这适用于写入查询（不返回记录），或保证最多返回一条记录的读取查询（例如计数查询）。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Next, we need to adapt the `FruitMapper` to construct a `ReactiveFruitDao` instance:"
msgstr "接下来，我们需要调整 `FruitMapper` ，构建一个 `ReactiveFruitDao` 的实例。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Now, we can create a `ReactiveFruitService` that leverages our reactive DAO:"
msgstr "现在，我们可以创建一个 `ReactiveFruitService` ，利用我们的反应式DAO。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Finally, we can create a `ReactiveFruitResource`:"
msgstr "最后，我们可以创建一个 `ReactiveFruitResource` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The above resource is exposing a new endpoint, `reactive-fruits`. Its capabilities are identical to\n"
"the ones that we created before with `FruitResource`, but everything is handled in a reactive\n"
"fashion, without any blocking operation."
msgstr "上述资源公开了一个新的端点 `reactive-fruits` 。它的功能与我们之前通过 `FruitResource` 创建的功能完全相同，但一切都是以反应方式处理的，没有任何阻塞操作。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The `getAll()` method above returns `Multi`, and the `add()` method returns `Uni`. These types\n"
"are the same Mutiny types that we met before; they are automatically recognized by the Quarkus\n"
"reactive REST API, so we don't need to convert them into JSON ourselves."
msgstr "上面的 `getAll()` 方法返回 `Multi` ，而 `add()` 方法返回 `Uni` 。这些类型与我们之前遇到的 Mutiny 类型相同；它们会被 Quarkus 反应式 REST API 自动识别，因此我们不需要自己将它们转换成 JSON。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Quarkus REST natively supports the Mutiny reactive types e.g. `Uni` and `Multi`."
msgstr "Quarkus REST 本机支持 Mutiny 反应类型，如 `Uni` 和 `Multi` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"This dependency is already included in this guide's pom.xml, but if you are starting a new project\n"
"from scratch, make sure to include it."
msgstr "本指南的 pom.xml 已包含此依赖项，但如果您要从头开始一个新项目，请确保包含它。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Testing the Reactive REST API"
msgstr "测试反应式REST API"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Run the application in dev mode as explained above, then you can use curl commands to interact with\n"
"the underlying REST API."
msgstr "如上所述，在开发模式下运行应用程序，然后使用 curl 命令与底层 REST API 交互。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "To create a fruit using the reactive REST endpoint:"
msgstr "要使用反应式REST端点创建一个水果。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "To retrieve fruits with the reactive REST endpoint:"
msgstr "要用反应式REST端点检索水果。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Creating a Reactive Frontend"
msgstr "创建一个反应式的前端"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Now let's add a simple web page to interact with our `ReactiveFruitResource`. In the\n"
"`src/main/resources/META-INF/resources` directory, add a `reactive-fruits.html` file with the\n"
"contents from link:src/main/resources/META-INF/resources/reactive-fruits.html[this file] in it."
msgstr "现在，让我们添加一个简单的网页，与 `ReactiveFruitResource` 进行交互。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `reactive-fruits.html` 文件，其中包含 link:src/main/resources/META-INF/resources/reactive-fruits.html[该文件] 的内容。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "You can now interact with your reactive REST service:"
msgstr "现在你可以与你的反应式REST服务进行交互。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Point your browser to `http://localhost:8080/reactive-fruits.html`;"
msgstr "将您的浏览器指向 `<a href=\"http://localhost:8080/reactive-fruits.html\" class=\"bare\">http://localhost:8080/reactive-fruits.html</a>` ;"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, no-wrap
msgid "Health Checks"
msgstr "健康检查"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"If you are using the Quarkus SmallRye Health extension, then the Cassandra client will automatically\n"
"add a readiness health check to validate the connection to the Cassandra cluster. This extension is\n"
"already included in this guide's pom.xml, but if you need to include it manually in your\n"
"application, add the following:"
msgstr "如果您使用的是 Quarkus SmallRye Health 扩展，那么 Cassandra 客户端将自动添加准备就绪健康检查，以验证与 Cassandra 集群的连接。本指南的 pom.xml 中已包含该扩展，但如果需要在应用程序中手动包含该扩展，请添加以下内容："

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"When health checks are available, you can access the `/health/ready` endpoint of your application\n"
"and have information about the connection validation status."
msgstr "当健康检查可用时，您可以访问应用程序的 `/health/ready` 端点，并获得有关连接验证状态的信息。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to\n"
"http://localhost:8080/health/ready you should see an output similar to the following one:"
msgstr "在开发模式下运行 `mvn clean quarkus:dev` ，如果将浏览器指向 http://localhost:8080/health/ready ，应该会看到类似下面的输出："

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"If you need health checks globally enabled in your application, but don't want to activate\n"
"Cassandra health checks, you can disable Cassandra health checks by setting the\n"
"`quarkus.cassandra.health.enabled` property to `false` in your `application.properties`."
msgstr "如果您需要在应用程序中全局启用健康检查，但又不想激活 Cassandra 健康检查，您可以在 `application.properties` 中将 `quarkus.cassandra.health.enabled` 属性设置为 `false` ，从而禁用 Cassandra 健康检查。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, no-wrap
msgid "Metrics"
msgstr "指标"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The Cassandra Quarkus client can provide metrics about the Cassandra session and about individual\n"
"Cassandra nodes. It supports both Micrometer and MicroProfile."
msgstr "Cassandra Quarkus 客户端可提供有关 Cassandra 会话和单个 Cassandra 节点的指标。它同时支持 Micrometer 和 MicroProfile。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The first step to enable metrics is to add a few additional dependencies depending on the metrics\n"
"framework you plan to use."
msgstr "启用度量的第一步是根据计划使用的度量框架添加一些额外的依赖项。"

#. type: Title ===
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Enabling Metrics with Micrometer"
msgstr "用Micrometer实现指标化"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Micrometer is the recommended metrics framework in Quarkus applications."
msgstr "Micrometer是Quarkus应用中推荐的度量框架。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "To enable Micrometer metrics in your application, you need to add the following to your pom.xml."
msgstr "为了在你的应用程序中启用Micrometer度量，你需要在你的pom.xml中添加以下内容。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "This guide uses Micrometer, so the above dependencies are already included in this guide's pom.xml."
msgstr "本指南使用Micrometer，所以上述依赖已经包含在本指南的pom.xml中。"

#. type: Title ===
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Enabling Metrics with MicroProfile Metrics"
msgstr "用MicroProfile度量标准启用度量标准"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Remove any dependency to Micrometer from your pom.xml, then add the following ones instead:"
msgstr "从你的pom.xml中删除任何对Micrometer的依赖，然后添加以下内容。"

#. type: Title ===
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Enabling Cassandra Metrics"
msgstr "启用Cassandra度量衡"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Even when metrics are enabled in your application, the Cassandra client will not report any metrics,\n"
"unless you opt in for this feature. So your next step is to enable Cassandra metrics in your\n"
"`application.properties` file."
msgstr "即使在应用程序中启用了指标，Cassandra 客户端也不会报告任何指标，除非您选择使用该功能。因此，下一步是在 `application.properties` 文件中启用 Cassandra 指标。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "That's it!"
msgstr "就这样吧!"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The final (and optional) step is to customize which specific Cassandra metrics you would like the\n"
"Cassandra client to track. Several metrics can be tracked; if you skip this step, a default set of\n"
"useful metrics will be automatically tracked."
msgstr "最后一步（可选）是自定义您希望 Cassandra 客户端跟踪的特定 Cassandra 指标。可以跟踪多个指标；如果跳过这一步，将自动跟踪一组有用的默认指标。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"For the full list of available metric names, please refer to the\n"
"link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver\n"
"settings reference] page; search for the `advanced.metrics` section.\n"
"Also, Cassandra driver metrics are covered in detail in the\n"
"https://docs.datastax.com/en/developer/java-driver/latest/manual/core/metrics/[driver manual]."
msgstr "有关可用度量名称的完整列表，请参阅 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[驱动程序设置参考] 页面；搜索 `advanced.metrics` 部分。此外，Cassandra 驱动程序指标在 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/metrics/[驱动程序手册] 中有详细介绍。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "If you do wish to customize which metrics to track, you should use the following properties:"
msgstr "如果你确实希望自定义追踪哪些指标，你应该使用以下属性。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"`quarkus.cassandra.metrics.session.enabled` should contain the session-level metrics to enable\n"
"(metrics that are global to the session)."
msgstr "`quarkus.cassandra.metrics.session.enabled` 应包含要启用的会话级指标（会话的全局指标）。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"`quarkus.cassandra.metrics.node.enabled` should contain the node-level metrics to enable (metrics\n"
"for which each node contacted by the Cassandra client gets its own metric value)."
msgstr "`quarkus.cassandra.metrics.node.enabled` 应包含要启用的节点级度量（Cassandra 客户端联系的每个节点都会得到自己的度量值）。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Both properties accept a comma-separated list of valid metric names."
msgstr "这两个属性都接受一个以逗号分隔的有效度量衡名称列表。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "For example, let's assume that you wish to enable the following three Cassandra metrics:"
msgstr "例如，让我们假设你希望启用以下三个Cassandra度量。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Session-level: `session.connected-nodes` and `session.bytes-sent`;"
msgstr "会议级别： `session.connected-nodes` 和 `session.bytes-sent` 。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Node-level: `node.pool.open-connections`."
msgstr "节点级： `node.pool.open-connections` 。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "Then you should add the following settings to your `application.properties`:"
msgstr "然后，你应该将以下设置添加到你的 `application.properties` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"This guide's `application.properties` file has already many metrics enabled; you can use its metrics\n"
"list as a good starting point for exposing useful Cassandra metrics in your application."
msgstr "本指南的 `application.properties` 文件已经启用了许多指标；您可以将其指标列表作为一个良好的起点，在您的应用程序中公开有用的 Cassandra 指标。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"When metrics are properly enabled, metric reports for all enabled metrics are available at the\n"
"`/metrics` REST endpoint of your application."
msgstr "在正确启用指标后，应用程序的 `/metrics` REST 端点可提供所有已启用指标的指标报告。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to\n"
"`http://localhost:8080/metrics` you should see a list of metrics; search for metrics whose names\n"
"contain `cassandra`."
msgstr "在开发模式下运行 `mvn clean quarkus:dev` ，如果将浏览器指向 `http://localhost:8080/metrics` 就会看到一个度量指标列表；搜索名称包含 `cassandra` 的度量指标。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"For Cassandra metrics to show up, the Cassandra client needs to be initialized and\n"
"connected; if you are using lazy initialization (see below), you won't see any Cassandra metrics\n"
"until your application actually connects and hits the database for the first time."
msgstr "要显示 Cassandra 指标，Cassandra 客户端需要初始化并连接；如果您使用的是懒初始化（见下文），在您的应用程序真正连接并首次访问数据库之前，您不会看到任何 Cassandra 指标。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Running in native mode"
msgstr "在本地模式下运行"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "If you installed GraalVM, you can xref:building-native-image.adoc[build a native image] using:"
msgstr "如果你安装了GraalVM，你可以用以下方法 link:https://quarkus.io/guides/building-native-image[构建一个本地镜像] 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Beware that native compilation can take a significant amount of time! Once the compilation is done,\n"
"you can run the native executable as follows:"
msgstr "请注意，本地编译可能会耗费大量时间！编译完成后，运行本地可执行文件的方法如下："

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
msgid "You can then point your browser to `http://localhost:8080/fruits.html` and use your application."
msgstr "然后你可以使用的浏览器访问 `<a href=\"http://localhost:8080/fruits.html\" class=\"bare\">http://localhost:8080/fruits.html</a>` 来使用你的应用程序。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, fuzzy, no-wrap
msgid "Choosing between eager and lazy initialization"
msgstr "渴望与懒惰的初始化"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "As explained above, this extension allows you to inject many types of beans:"
msgstr "这个扩展允许你注入任何一种。"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "A simple bean like `QuarkusCqlSession` or `FruitDao`;"
msgstr "a `QuarkusCqlSession` 豆子。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The asynchronous version of that bean, for example `CompletionStage<QuarkusCqlSession>` or\n"
"`CompletionStage<FruitDao>;"
msgstr "该 bean 的异步版本，例如 `CompletionStage<QuarkusCqlSession>` 或 `CompletionStage<FruitDao>；"

#. type: Plain text
#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid "The reactive version of that bean, for example `Uni<QuarkusCqlSession>` or `Uni<FruitDao>`."
msgstr "或这个bean的反应式版本，即： `Uni<QuarkusCqlSession>` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"The most straightforward approach is obviously to inject the bean directly. This should work just\n"
"fine for most applications. However, the `QuarkusCqlSession` bean, and all DAO beans that depend on\n"
"it, might take some time to initialize before they can be used for the first time, and this process\n"
"is blocking."
msgstr "最直接的方法显然是直接注入 Bean。这对于大多数应用程序来说都是可行的。但是， `QuarkusCqlSession` Bean 以及依赖于它的所有 DAO Bean 可能需要一些时间来初始化，然后才能首次使用，而这个过程是阻塞的。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Fortunately, it is possible to control when the initialization should happen: the\n"
"`quarkus.cassandra.init.eager-init` parameter determines if the `QuarkusCqlSession` bean should be\n"
"initialized on its first access (lazy) or when the application is starting (eager). The default\n"
"value of this parameter is `false`, meaning the init process is lazy: the `QuarkusCqlSession` bean\n"
"will be initialized lazily on its first access – for example, when there is a first REST request\n"
"that needs to interact with the Cassandra database."
msgstr "幸运的是，我们可以控制初始化的时间： `quarkus.cassandra.init.eager-init` 参数决定 `QuarkusCqlSession` Bean 是在首次访问时初始化（懒惰），还是在应用程序启动时初始化（急切）。该参数的默认值是 `false` ，这意味着初始化过程是 \"懒惰 \"的： `QuarkusCqlSession` Bean 将在首次访问时被 \"懒惰 \"地初始化，例如，当有第一个 REST 请求需要与 Cassandra 数据库交互时。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Using lazy initialization speeds up your application startup time, and avoids startup failures if\n"
"the Cassandra database is not available. However, it could also prove dangerous if your code is\n"
"fully non-blocking, for example if it uses xref:reactive-routes.adoc[reactive routes].\n"
"Indeed, the lazy initialization could accidentally happen on a thread that is not allowed\n"
"to block, such as a Vert.x event loop thread. Therefore, setting `quarkus.cassandra.init.eager-init`\n"
"to `false` and injecting `QuarkusCqlSession` should be avoided in these contexts."
msgstr "使用懒初始化可加快应用程序的启动速度，并避免在 Cassandra 数据库不可用时出现启动失败。不过，如果你的代码是完全非阻塞的，例如使用了 xref:reactive-routes.adoc[反应式路由] ，那么使用懒初始化也可能证明是危险的。事实上，懒初始化可能会意外发生在不允许阻塞的线程上，如 Vert.x 事件循环线程。因此，在这些情况下应避免将 `quarkus.cassandra.init.eager-init` 设置为 `false` 并注入 `QuarkusCqlSession` 。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"If you want to use Vert.x (or any other non-blocking framework) and keep the lazy initialization\n"
"behavior, you should instead inject only a `CompletionStage` or a `Uni` of the desired bean. When\n"
"injecting these beans, the initialization process will be triggered lazily, but it will happen in\n"
"the background, in a non-blocking way, leveraging the Vert.x event loop. This way you don't risk\n"
"blocking the Vert.x thread."
msgstr "如果您想使用 Vert.x（或任何其他非阻塞框架）并保持懒初始化行为，您应该只注入所需的 Bean 的 `CompletionStage` 或 `Uni` 。注入这些 Bean 时，初始化过程将被懒散地触发，但它将在后台以无阻塞的方式发生，并利用 Vert.x 事件循环。这样就不会有阻塞 Vert.x 线程的风险。"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Alternatively, you can set `quarkus.cassandra.init.eager-init` to true: in this case the session\n"
"bean and all DAO beans will be initialized eagerly during application startup, on the Quarkus main\n"
"thread. This would eliminate any risk of blocking a Vert.x thread, at the cost of making your\n"
"startup time (much) longer."
msgstr "或者，您也可以将 `quarkus.cassandra.init.eager-init` 设置为 true：在这种情况下，会话 bean 和所有 DAO Bean 都将在应用程序启动时，在 Quarkus 主线程上急于初始化。这将消除阻塞 Vert.x 线程的风险，但代价是启动时间（更长）。"

#. type: Title ==
#: _versions/main/guides/cassandra.adoc
#, no-wrap
msgid "Conclusion"
msgstr "解决方案"

#: _versions/main/guides/cassandra.adoc
#, fuzzy
msgid ""
"Accessing a Cassandra database from a client application is easy with Quarkus and the Cassandra\n"
"extension, which provides configuration and native support for the DataStax Java driver for Apache\n"
"Cassandra."
msgstr "通过Quarkus和Cassandra扩展，从客户端应用程序访问Cassandra数据库变得非常简单，Quarkus和Cassandra扩展为Apache Cassandra的DataStax Java驱动程序提供了配置和本地支持。"
