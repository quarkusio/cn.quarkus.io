# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-12 02:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "CDI Integration Guide"
msgstr "CDI整合指南"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"ArC, the CDI container in Quarkus, is bootstrapped at build time.\n"
"To integrate with the container, https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#spi_lite[CDI Build Compatible Extensions, window=\"_blank\"] can be used, as well as a Quarkus-specific extension API.\n"
"CDI Portable Extensions are not and cannot be supported.\n"
"This guide focuses on the Quarkus-specific extensions API."
msgstr "ArC 是 Quarkus 中的 CDI 容器，在构建时进行引导。要与容器集成，可以使用 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#spi_lite[CDI Build Compatible Extensions] 以及 Quarkus 专用的扩展 API。我们不支持 CDI 可移植扩展。本指南重点介绍 Quarkus 专用扩展 API。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The container is bootstrapped in multiple phases.\n"
"From a high level perspective these phases go as follows:"
msgstr "容器的启动分为多个阶段。从高层次的角度来看，这些阶段如下："

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Initialization"
msgstr "初始化"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Bean discovery"
msgstr "豆类的发现"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Registration of synthetic components"
msgstr "合成成分的注册"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Validation"
msgstr "审定"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n"
"_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n"
"Subsequently, the extensions can register _synthetic components_.\n"
"Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n"
"Finally, the _deployment is validated_.\n"
"For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers."
msgstr "在 _初始化_ 阶段，将进行准备工作并注册自定义上下文。然后，容器会分析所有应用程序类，识别 _Bean_ ，并根据提供的元数据将它们连接在一起。随后，扩展可以注册 _合成组件_ 。这些组件的属性完全由扩展控制，即不是从现有类派生出来的。最后，对 _部署进行验证_ 。例如，容器会验证应用程序中的每个注入点，如果没有满足给定所需类型和限定条件的 Bean，则构建失败。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In <<cdi-reference.adoc#dev_mode,dev mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format."
msgstr "通过启用附加日志，您可以看到更多有关引导程序的信息。只需使用 `-X` 或 `--debug` 运行 Maven 构建，然后在包含 `io.quarkus.arc` 的行中搜索即可。在 xref:cdi-reference.adoc#dev_mode[开发模式] 下，您可以使用 `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` ，两个特殊的端点也会自动注册，以 JSON 格式提供一些基本的调试信息。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Quarkus build steps can produce and consume various build items and hook into each phase.\n"
"In the following sections we will describe all the relevant build items and common scenarios."
msgstr "Quarkus 的构建步骤可以生成和消耗各种构建项，并与每个阶段挂钩。在下面的章节中，我们将介绍所有相关的构建项和常见情况。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Metadata Sources"
msgstr "元数据来源"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Classes and annotations are the primary source of bean-level metadata.\n"
"The initial metadata are read from the _bean archive index_, an immutable https://github.com/smallrye/jandex[Jandex index, window=\"_blank\"] which is built from various sources during <<cdi-reference.adoc#bean_discovery,bean discovery>>.\n"
"However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n"
"Moreover, extensions can also register <<synthetic_beans,synthetic components>>.\n"
"This is an important aspect to realize when integrating CDI components in Quarkus."
msgstr "类和注解是 Bean 层元数据的主要来源。初始元数据是从 Bean _档案索引_ 中读取的，这是一个不可变的 link:https://github.com/smallrye/jandex[Jandex] 索引，是在 xref:cdi-reference.adoc#bean_discovery[Bean 发现] 过程中从各种来源建立的。不过，扩展可以在引导的某些阶段添加、删除或转换元数据。此外，扩展还可以注册 xref:synthetic_beans[合成组件] 。这是在 Quarkus 中集成 CDI 组件时需要认识到的一个重要方面。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n"
"For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored."
msgstr "通过这种方式，扩展可以将原本会被忽略的类转化为 Bean，反之亦然。例如，一个声明了 `@Scheduled` 方法的类，即使没有注释 bean 定义注解，通常也会被忽略，但它总是注册为 bean。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - My Class Is Not Recognized as a Bean"
msgstr "用例 - 我的类不被识别为豆类"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n"
"Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.\n"
"There are several reasons why a class is not recognized and also several ways to fix it.\n"
"In the first step we should identify the _reason_."
msgstr "`UnsatisfiedResolutionException` 表示 xref:cdi.adoc#typesafe_resolution[类型安全解决] 过程中出现了问题。有时，即使类路径上有一个看起来符合注入条件的类，也无法满足注入点的要求。类无法被识别有几种原因，也有几种解决方法。第一步，我们应找出 _原因_ 。"

#. type: Title ===
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "_Reason 1_: Class Is Not discovered"
msgstr " _原因1_ ：上课时没有发现"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n"
"It might happen that the class is not part of the application index.\n"
"For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "Quarkus 具有 xref:cdi-reference.adoc#bean_discovery[简化的发现] 功能。有可能出现类不在应用程序索引中的情况。例如，Quarkus 扩展 _程序运行模块_ 中的类不会被自动索引。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"_Solution_: Use the `AdditionalBeanBuildItem`.\n"
"This build item can be used to specify one or more additional classes to be analyzed during the discovery.\n"
"Additional bean classes are transparently added to the application index processed by the container."
msgstr "_解决方案_ ： `AdditionalBeanBuildItem` 该构建项可用于指定一个或多个要在发现过程中分析的附加类。附加 Bean 类会透明地添加到容器处理的应用程序索引中。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "It is not possible to conditionally enable/disable additional beans via the `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` and `@UnlessBuildProperty` annotations as described in <<cdi-reference.adoc#enable_build_profile>> and <<cdi-reference.adoc#enable_build_properties>>. Extensions should inspect the configuration or the current profile and only produce an `AdditionalBeanBuildItem` if really needed."
msgstr "如 <<cdi-reference.adoc#enable_build_profile>> 和 <<cdi-reference.adoc#enable_build_properties>> 所述，无法通过 `@IfBuildProfile` 、 `@UnlessBuildProfile` 、 `@IfBuildProperty` 和 `@UnlessBuildProperty` 注释有条件地启用/禁用其他 Bean。扩展应检查配置或当前配置文件，只有在确实需要时才生成 `AdditionalBeanBuildItem` 。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`AdditionalBeanBuildItem` Example"
msgstr " `AdditionalBeanBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`AdditionalBeanBuildItem.Builder` can be used for more complex use cases."
msgstr " `AdditionalBeanBuildItem.Builder` 可用于更复杂的用例。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n"
"If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n"
"However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n"
"See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details."
msgstr "通过 `AdditionalBeanBuildItem` 添加的 Bean 类默认是 _可移除_ 的。如果容器认为它们 xref:cdi-reference.adoc#remove_unused_beans[未被使用] ，它们就会被忽略。不过，您可以使用 `AdditionalBeanBuildItem.Builder.setUnremovable()` 方法来指示容器永不删除通过此构建项注册的 Bean 类。另请参阅 xref:cdi-reference.adoc#remove_unused_beans[移除未使用的 Bean] 和 <<unremovable_builditem>> 以了解更多详情。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n"
"The default scope is only used if there is no scope declared on the bean class."
msgstr "也可以通过 `AdditionalBeanBuildItem.Builder#setDefaultScope()` 设置默认作用域。默认作用域只有在 bean 类没有声明作用域时才会使用。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "If no default scope is specified the `@Dependent` pseudo-scope is used."
msgstr "如果没有指定默认范围，则使用 `@Dependent` 伪范围。"

#. type: Title ===
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "_Reason 2_: Class Is Discovered but Has No Bean Defining Annotation"
msgstr "原因 _2_ ：类被发现了，但没有豆的定义注释"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"In Quarkus, the application is represented by a single bean archive with the https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n"
"Therefore, bean classes that don't have a https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n"
"Bean defining annotations are declared on the class-level and include scopes, stereotypes and `@Interceptor`."
msgstr "在 Quarkus 中，应用程序由单个 Bean 档案表示，其 Bean link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#default_bean_discovery[发现模式] 为 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#default_bean_discovery[annotated 。因此，没有 bean 定] link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bean_defining_annotations[义注解] 的 bean 类将被忽略。Bean 定义注解在类级别声明，包括作用域、定型和 `@Interceptor` 。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions."
msgstr " _解决方案1_ ：使用 `AutoAddScopeBuildItem` 。这个构建项可以用来为满足某些条件的类添加一个范围。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`AutoAddScopeBuildItem` Example"
msgstr " `AutoAddScopeBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Find all classes annotated with `@Scheduled`."
msgstr "找到所有用 `@Scheduled` 注释的类。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically."
msgstr "添加 `@Singleton` 作为默认作用域。已经用范围注释的类会被自动跳过。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`."
msgstr " _解决方案2_ ：如果你需要处理带有特定注解的类，那么可以通过 `BeanDefiningAnnotationBuildItem` ，扩展Bean定义的注解集。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`BeanDefiningAnnotationBuildItem` Example"
msgstr " `BeanDefiningAnnotationBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations."
msgstr "将 `org.eclipse.microprofile.graphql.GraphQLApi` 添加到bean定义注释的集合中。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n"
"However, you can change the default behavior.\n"
"See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details."
msgstr "默认情况下，通过 `BeanDefiningAnnotationBuildItem` 添加的 Bean 类是 _不可移除_ 的，也就是说，生成的 Bean 类即使被视为未使用，也不得移除。不过，您可以更改默认行为。更多详情，请参阅 xref:cdi-reference.adoc#remove_unused_beans[移除未使用的 Bean] 和 <<unremovable_builditem>> 。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is also possible to specify the default scope.\n"
"The default scope is only used if there is no scope declared on the bean class."
msgstr "还可以指定默认作用域。默认作用域只有在 bean 类没有声明作用域时才会使用。"

#. type: Title ===
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed"
msgstr " _原因3_ ：类被发现并有一个Bean定义的注释，但被删除了"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n"
"This optimization allows for _framework-level dead code elimination_.\n"
"In few special cases, it's not possible to correctly identify an unused bean.\n"
"In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n"
"Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`."
msgstr "默认情况下，容器会在构建过程中 xref:cdi-reference.adoc#remove_unused_beans[移除所有未使用的 Bean] 。这种优化可以 _消除框架级的死代码_ 。在少数特殊情况下，无法正确识别未使用的 Bean。特别是，Quarkus 还不能检测 `CDI.current()` 静态方法的使用情况。扩展程序可以通过生成 `UnremovableBeanBuildItem` .NET 方法来消除可能的误报。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`UnremovableBeanBuildItem` Example"
msgstr " `UnremovableBeanBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Make all classes annotated with `@Startup` unremovable."
msgstr "使所有用 `@Startup` 注释的类都不能被移除。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding"
msgstr "用例 - 我的注释没有被识别为限定符或拦截器绑定"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is likely that the annotation class is not part of the application index.\n"
"For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "注释类很可能不是应用程序索引的一部分。例如，Quarkus 扩展 _程序运行模块_ 中的类不会被自动索引。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>."
msgstr "_解决方案_ ：如 <<additional_bean_build_item>> 中所述，使用 `AdditionalBeanBuildItem` 。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - I Need To Transform Annotation Metadata"
msgstr "用例 - 我需要转换元数据"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"In some cases, it's useful to be able to modify the annotation metadata.\n"
"Quarkus provides a powerful alternative to https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#process_annotated_type[`jakarta.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bce_enhancement[`jakarta.enterprise.inject.build.compatible.spi.Enhancement`, window=\"_blank\"].\n"
"With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes."
msgstr "在某些情况下，修改注释元数据非常有用。Quarkus 为 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#process_annotated_type[jakarta.enterprise.inject.spi.ProcessAnnotatedType] 和 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bce_enhancement[jakarta.enterprise.inject.build.compatible.spi.Enhancement] .通过 `AnnotationsTransformerBuildItem` ，我们可以覆盖 Bean 类上存在的注解。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Keep in mind that annotation transformers must be produced _before_ the bean discovery starts."
msgstr "请记住，注释转换器必须 _在_ Bean发现开始 _之前_ 产生。"

#: _versions/main/guides/cdi-integration.adoc
msgid ""
"For example, you might want to add an interceptor binding to a specific bean class.\n"
"You can use a convenient builder API to create a transformation instance:"
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Builder Example"
msgstr " `CustomScopeBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The transformer is only applied to classes."
msgstr "转化器只适用于类。"

#: _versions/main/guides/cdi-integration.adoc
msgid "Only apply the transformation if the class is `org.acme.Bar`."
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Add the `@MyInterceptorBinding` annotation."
msgstr "添加 `@MyInterceptorBinding` 注释。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The example above can be rewritten with an anonymous class:"
msgstr "上面的例子可以用一个匿名的类来重写："

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`AnnotationsTransformerBuildItem` Example"
msgstr " `AnnotationsTransformerBuildItem` 例子"

#: _versions/main/guides/cdi-integration.adoc
msgid "If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`."
msgstr ""

#: _versions/main/guides/cdi-integration.adoc
msgid "The previous `AnnotationsTransformer` API from ArC is still supported, but the new `AnnotationTransformation` API from Jandex is preferred."
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`."
msgstr "构建步骤可以通过 `TransformedAnnotationsBuildItem` ，为一个给定的注释目标查询转换后的注释。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`TransformedAnnotationsBuildItem` Example"
msgstr " `TransformedAnnotationsBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations."
msgstr " `TransformedAnnotationsBuildItem.getAnnotations()` 将返回一个可能经过转换的注释集。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "There are other build items specialized in transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>."
msgstr "还有其他专门用于改造的构建项目： <<additional_interceptor_bindings>> 和 <<injection_point_transformation>> 。"

#. type: Title ===
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "How to Enable Trace Logging for Annotation Transformers"
msgstr "如何为注解转换器启用跟踪记录功能"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "You can set the `TRACE` level for the category `io.quarkus.arc.processor` and try to analyze the log output afterwards."
msgstr "你可以为类别 `io.quarkus.arc.processor` ，设置 `TRACE` ，并在之后尝试分析日志输出。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`application.properties` Example"
msgstr " `application.properties` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "你还需要调整相关类别的最小日志级别。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - Inspect Beans, Observers and Injection Points"
msgstr "用例 - 检查豆类、观察者和注入点"

#. type: Title ===
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "_Solution 1_: `BeanDiscoveryFinishedBuildItem`"
msgstr " _解决方案1_ 。 `BeanDiscoveryFinishedBuildItem` "

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.\n"
"However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered."
msgstr "`BeanDiscoveryFinishedBuildItem` 的用户可以轻松检查应用程序中注册的所有基于类的 Bean、观察者和注入点。但是，合成类和观察者 _不包括在内_ ，因为该构建项是 _在_ 合成组件注册 _之前_ 生成的。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Additionally, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "另外，从 `BeanDiscoveryFinishedBuildItem#getBeanResolver()` 返回的bean解析器可以用来应用类型安全的解析规则，例如，找出是否有一个bean可以满足所需类型和限定符的某些组合。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`BeanDiscoveryFinishedBuildItem` Example"
msgstr " `BeanDiscoveryFinishedBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The resulting list will not contain `@Named` synthetic beans."
msgstr "由此产生的列表将不包含 `@Named` 合成豆。"

#. type: Title ===
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "_Solution 2_: `SynthesisFinishedBuildItem`"
msgstr " _解决方案2_ 。 `SynthesisFinishedBuildItem` "

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered."
msgstr " `SynthesisFinishedBuildItem` 的消费者可以很容易地检查在应用程序中注册的所有bean、observer和注入点。合成豆和观察者被包括在内，因为这个构建项是 _在_ 合成组件被注册 _后_ 产生的。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Additionally, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "另外，从 `SynthesisFinishedBuildItem#getBeanResolver()` 返回的bean解析器可以用来应用类型安全的解析规则，例如，找出是否有一个bean可以满足所需类型和限定符的某些组合。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`SynthesisFinishedBuildItem` Example"
msgstr " `SynthesisFinishedBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The resulting list will contain `@Named` synthetic beans."
msgstr "由此产生的列表将包含 `@Named` 合成豆。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - The Need for Synthetic Beans"
msgstr "用例 - 合成豆的需求"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Sometimes it is practical to be able to register a _synthetic bean_.\n"
"Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n"
"Instead, all the attributes are defined by an extension.\n"
"In regular CDI, this could be achieved using the https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bce_synthesis[`SyntheticComponents.addBean()`] methods."
msgstr "有时，注册 _合成_ Bean 也很实用。合成 Bean 的 Bean 属性并非源自 Java 类、方法或字段。相反，所有属性都是由扩展定义的。在常规的 CDI 中，可以使用 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#after_bean_discovery[AfterBeanDiscovery.addBean()] 和 link:https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bce_synthesis[SyntheticComponents.addBean()] 方法来实现。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`."
msgstr " _解决办法_ 。如果你需要注册一个合成豆，那么请使用 `SyntheticBeanBuildItem` 。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`SyntheticBeanBuildItem` Example 1"
msgstr " `SyntheticBeanBuildItem` 例子1"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Generate the bytecode of the `jakarta.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation."
msgstr "生成 `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` 实现的字节码。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The output of a bean configurator is recorded as bytecode.\n"
"Therefore, there are some limitations in how a synthetic bean instance is created at runtime.\n"
"You can:"
msgstr "Bean 配置器的输出记录为字节码。因此，在运行时创建合成 Bean 实例的方式会受到一些限制。您可以"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`."
msgstr "通过 `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)` ，直接生成 `Contextual#create(CreationalContext<T>)` 方法的字节码。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Pass a subclass of `io.quarkus.arc.BeanCreator` via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some build-time parameters via `ExtendedBeanConfigurator#param()` and synthetic injection points via `ExtendedBeanConfigurator#addInjectionPoint()`."
msgstr "通过 `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)` 传递一个 `io.quarkus.arc.BeanCreator` 实现类，并可能通过 `ExtendedBeanConfigurator#param()` 指定一些参数。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder` method>> and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)`, `ExtendedBeanConfigurator#runtimeProxy(Object)`,  `ExtendedBeanConfigurator#supplier(Supplier<?>)` or `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)`."
msgstr "通过 xref:writing-extensions.adoc#bytecode-recording[@Recorder 方法] 返回的代理生成运行时实例，并通过 `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` , `ExtendedBeanConfigurator#runtimeProxy(Object)` , `ExtendedBeanConfigurator#supplier(Supplier<?>)` 或 `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)` 进行设置。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`SyntheticBeanBuildItem` Example 2"
msgstr " `SyntheticBeanBuildItem` 例2"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "By default, a synthetic bean is initialized during `STATIC_INIT`."
msgstr "默认情况下，合成豆是在 `STATIC_INIT` 。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The bean instance is supplied by a value returned from a recorder method."
msgstr "豆类实例是由一个记录器方法返回的值提供的。"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.\n"
"See the <<writing-extensions.adoc#bootstrap-three-phases,Three Phases of Bootstrap and Quarkus Philosophy>> for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`."
msgstr "可以在 `RUNTIME_INIT` 期间标记要初始化的合成 Bean。有关 `STATIC_INIT` 和 `RUNTIME_INIT` 之间区别的更多信息，请参阅 xref:writing-extensions.adoc#bootstrap-three-phases[Bootstrap 的三个阶段] 和 xref:writing-extensions.adoc#bootstrap-three-phases[Quarkus 理念] 。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`RUNTIME_INIT` `SyntheticBeanBuildItem` Example"
msgstr " `RUNTIME_INIT` `SyntheticBeanBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase."
msgstr "记录器必须在 `ExecutionTime.RUNTIME_INIT` 阶段执行。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The bean instance is initialized during `RUNTIME_INIT`."
msgstr "在 `RUNTIME_INIT` ，Bean实例被初始化。"

#. type: delimited block =
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:"
msgstr "在 `RUNTIME_INIT` 期间初始化的合成Bean不能在 `STATIC_INIT` 期间被访问。 `RUNTIME_INIT` 构建步骤访问运行时初始化的合成Bean应该消耗 `SyntheticBeansRuntimeInitBuildItem` 。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "This build step must be executed after `syntheticBean()` completes."
msgstr "这个构建步骤必须在 `syntheticBean()` 完成后执行。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized."
msgstr "这个记录器方法会导致对 `Foo` bean实例的调用，因此我们需要确保在所有合成bean被初始化后执行构建步骤。"

#. type: delimited block =
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus."
msgstr "也可以使用 `BeanRegistrationPhaseBuildItem` 来注册一个合成豆。然而，我们建议扩展作者坚持使用 `SyntheticBeanBuildItem` ，这对Quarkus来说是更习惯的。"

#. type: Title ===
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Synthetic Injection Points"
msgstr "合成的注射点"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"A synthetic bean may register a synthetic injection point via the `ExtendedBeanConfigurator#addInjectionPoint()` method.\n"
"This injection point is validated at build time and considered when <<cdi-reference.adoc#remove_unused_beans,detecting unused beans>>.\n"
"The injected reference is accessible through the `SyntheticCreationalContext#getInjectedReference()` methods at runtime."
msgstr "合成 Bean 可通过 `ExtendedBeanConfigurator#addInjectionPoint()` 方法注册合成注入点。该注入点会在构建时进行验证，并在 xref:cdi-reference.adoc#remove_unused_beans[检测未使用的 Bean] 时予以考虑。注入的引用可在运行时通过 `SyntheticCreationalContext#getInjectedReference()` 方法访问。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Synthetic Injection Point - Build Step Example"
msgstr " `SyntheticBeanBuildItem` 例子1"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "A synthetic injection point with required type `Bar` was added; this is an equivalent of `@Inject Bar`."
msgstr "增加了一个所需类型的合成注入点 `Bar` ；这相当于 `@Inject Bar` 。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The bean instance is created with a function returned from a recorder method."
msgstr "豆类实例是由一个记录器方法返回的值提供的。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Synthetic Injection Point - Recorder Example"
msgstr "合成注射点--记录器实例"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Pass a contextual reference of `Bar` to the constructor of `Foo`."
msgstr "将 `Bar` 的上下文引用传递给 `Foo` 的构造函数。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - Synthetic Observers"
msgstr "用例 - 合成观测器"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension."
msgstr "与 xref:synthetic_beans[合成 bean] 类似，合成观察者方法的属性并非源自 Java 方法。相反，所有属性都是由扩展定义的。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`."
msgstr " _解决方案_ 。如果你需要注册一个合成观察者，请使用 `ObserverRegistrationPhaseBuildItem` 。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "消耗 `ObserverRegistrationPhaseBuildItem` 的构建步骤应该总是产生一个 `ObserverConfiguratorBuildItem` ，或者至少为这个构建项目注入一个 `BuildProducer` ，否则它可能被忽略或者在错误的时间处理（比如在正确的CDI引导阶段之后）。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`ObserverRegistrationPhaseBuildItem` Example"
msgstr " `ObserverRegistrationPhaseBuildItem` 例子"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The output of a `ObserverConfigurator` is recorded as bytecode.\n"
"Therefore, there are some limitations in how a synthetic observer is invoked at runtime.\n"
"Currently, you must generate the bytecode of the method body directly."
msgstr "`ObserverConfigurator` 的输出记录为字节码。因此，在运行时如何调用合成观察者存在一些限制。目前，您必须直接生成方法体的字节码。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - I Have a Generated Bean Class"
msgstr "用例 - 我有一个生成的豆类"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"No problem.\n"
"You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`."
msgstr "没问题。您可以手动生成 Bean 类的字节码，然后只需生成 `GeneratedBeanBuildItem` 而不是 `GeneratedClassBuildItem` 。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`GeneratedBeanBuildItem` Example"
msgstr " `GeneratedBeanBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs."
msgstr " `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` 使得从Gizmo构造中产生 s变得容易。 `GeneratedBeanBuildItem` "

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "The resulting bean class is something like `public class @Singleton MyBean { }`."
msgstr "由此产生的豆类是类似于 `public class @Singleton MyBean { }` 。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - I Need to Validate the Deployment"
msgstr "用例 - 我需要验证部署情况"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong."
msgstr "有时，扩展需要检查Bean、观察者和注入点，然后进行额外的验证，如果有问题，就会导致构建失败。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`."
msgstr " _解决方案_ 。如果一个扩展需要验证部署，它应该使用 `ValidationPhaseBuildItem` 。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "消耗 `ValidationPhaseBuildItem` 的构建步骤应该总是产生一个 `ValidationErrorBuildItem` ，或者至少为这个构建项目注入一个 `BuildProducer` ，否则它可能被忽略或者在错误的时间处理（例如在正确的CDI引导阶段之后）。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method."
msgstr "你可以通过从 `ValidationPhaseBuildItem.getContext().beans()` 方法返回的方便的 `BeanStream` ，轻松地过滤所有注册的bean。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - Register a Custom CDI Context"
msgstr "用例 - 注册一个自定义CDI上下文"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Sometimes extensions need to extend the set of built-in CDI contexts."
msgstr "有时扩展需要扩展内置的CDI上下文集。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`."
msgstr " _解决办法_ 。如果你需要注册一个自定义上下文，请使用 `ContextRegistrationPhaseBuildItem` 。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "消耗 `ContextRegistrationPhaseBuildItem` 的构建步骤应该总是产生一个 `ContextConfiguratorBuildItem` ，或者至少为这个构建项目注入一个 `BuildProducer` ，否则它可能被忽略或者在错误的时间处理（例如在正确的CDI引导阶段之后）。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`ContextRegistrationPhaseBuildItem` Example"
msgstr " `ContextRegistrationPhaseBuildItem` 例子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations."
msgstr "此外，每个通过 `ContextRegistrationPhaseBuildItem` 注册自定义CDI上下文的扩展也应该产生 `CustomScopeBuildItem` ，以便将自定义范围注解名称贡献给Bean定义注解集。"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`CustomScopeBuildItem` Example"
msgstr " `CustomScopeBuildItem` 例子"

#. type: Title ===
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "What if I Need to Know All the Scopes Used in the Application?"
msgstr "如果我需要知道应用程序中使用的所有作用域怎么办？"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."
msgstr " _解决方案_ 。你可以在构建步骤中注入 `CustomScopeAnnotationsBuildItem` ，并使用方便的方法，如 `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()` 。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - Additional Interceptor Bindings"
msgstr "用例 - 额外的拦截器绑定"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@jakarta.interceptor.InterceptorBinding` as an interceptor binding.\n"
"This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n"
"We are going to use `InterceptorBindingRegistrarBuildItem` to get it done."
msgstr "在极少数情况下，以编程方式将未注明 `@jakarta.interceptor.InterceptorBinding` 的现有注解注册为拦截器绑定可能很方便。这与 CDI 通过 `BeforeBeanDiscovery#addInterceptorBinding()` 实现的功能类似。我们将使用 `InterceptorBindingRegistrarBuildItem` 来实现这一目标。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`InterceptorBindingRegistrarBuildItem` Example"
msgstr " `InterceptorBindingRegistrarBuildItem` 例子"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - Additional Qualifiers"
msgstr "用例 - 额外的限定词"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Sometimes it might be useful to register an existing annotation that is not annotated with `@jakarta.inject.Qualifier` as a CDI qualifier.\n"
"This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.\n"
"We are going to use `QualifierRegistrarBuildItem` to get it done."
msgstr "有时，将未注明 `@jakarta.inject.Qualifier` 的现有注释注册为 CDI 限定符可能很有用。这与 CDI 通过 `BeforeBeanDiscovery#addQualifier()` 实现的功能类似。我们将使用 `QualifierRegistrarBuildItem` 来实现这一目标。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`QualifierRegistrarBuildItem` Example"
msgstr " `QualifierRegistrarBuildItem` 例子"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - Additional Stereotypes"
msgstr "用例 - 额外的限定词"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is sometimes useful to register an existing annotation that is not annotated with `@jakarta.enterprise.inject.Stereotype` as a CDI stereotype.\n"
"This is similar to what CDI achieves through `BeforeBeanDiscovery#addStereotype()`.\n"
"We are going to use `StereotypeRegistrarBuildItem` to get it done."
msgstr "有时，将未注明 `@jakarta.enterprise.inject.Stereotype` 的现有注释注册为 CDI 定型也很有用。这与 CDI 通过 `BeforeBeanDiscovery#addStereotype()` 实现的功能类似。我们将使用 `StereotypeRegistrarBuildItem` 来实现这一目标。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`StereotypeRegistrarBuildItem` Example"
msgstr " `QualifierRegistrarBuildItem` 例子"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "If the newly registered stereotype annotation doesn't have the appropriate meta-annotations, such as scope or interceptor bindings, use an <<annotations_transformer_build_item,annotation transformation>> to add them."
msgstr "如果新注册的定型注解没有相应的元注解（如作用域或拦截器绑定），可使用 xref:annotations_transformer_build_item[注解转换] 来添加它们。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - Injection Point Transformation"
msgstr "用例 - 注射点转换"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n"
"You can do just that with `InjectionPointTransformerBuildItem`.\n"
"The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:"
msgstr "偶尔以编程方式更改注入点的限定符也很方便。您可以使用 `InjectionPointTransformerBuildItem` 来实现这一功能。下面的示例展示了如何对类型为 `Foo` 且包含限定符 `MyQualifier` 的注入点进行转换："

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`InjectionPointTransformerBuildItem` Example"
msgstr " `InjectionPointTransformerBuildItem` 例子"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.)."
msgstr "理论上，您可以使用 xref:annotations_transformer_build_item[AnnotationsTransformer 来实现同样] xref:annotations_transformer_build_item[的] 目标。然而，有一些不同之处使 `InjectionPointsTransformer` 更适合这项特殊任务：(1) 注释转换器在发现 Bean 时应用于所有类，而 `InjectionPointsTransformer` 只在发现 Bean 后应用于已发现的注入点；(2) 使用 `InjectionPointsTransformer` 时，您不需要处理各种类型的注入点（字段、初始化方法的参数等）。"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Use Case - Resource Annotations and Injection"
msgstr "用例 - 资源注释和注入"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.\n"
"An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation."
msgstr "`ResourceAnnotationBuildItem` 可用于指定资源注释，从而可以解析非 CDI 注入点，如 Jakarta EE 资源。集成商还必须提供相应的 `io.quarkus.arc.ResourceReferenceProvider` 服务提供商实现。"

#. type: Block title
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "`ResourceAnnotationBuildItem` Example"
msgstr " `ResourceAnnotationBuildItem` 例子"

#. type: Title ==
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "Available Build Time Metadata"
msgstr "可用的构建时间元数据"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.\n"
"The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:"
msgstr "任何使用 `BuildExtension.BuildContext` 的上述扩展都可以利用在构建过程中生成的某些构建时间元数据。 `io.quarkus.arc.processor.BuildExtension.Key` 中的内置键是"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "ANNOTATION_STORE"
msgstr "注解商店"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers"
msgstr "包含一个 `AnnotationStore` ，在应用注解变换器后保持所有 `AnnotationTarget` 注解的信息。"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "INJECTION_POINTS"
msgstr "注射点"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<InjectionPointInfo>` containing all injection points"
msgstr " `Collection<InjectionPointInfo>` 包含所有的注射点"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "BEANS"
msgstr "豆类"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<BeanInfo>` containing all beans"
msgstr " `Collection<BeanInfo>` 包含所有的豆子"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "REMOVED_BEANS"
msgstr "移除的豆类"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<BeanInfo>` containing all the removed beans; see <<cdi-reference.adoc#remove_unused_beans,Removing unused beans>> for more information"
msgstr "`Collection<BeanInfo>` 包含所有移除的 Bean；更多信息，请参阅 xref:cdi-reference.adoc#remove_unused_beans[移除未使用的 Bean]"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "OBSERVERS"
msgstr "观察者"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<ObserverInfo>` containing all observers"
msgstr " `Collection<ObserverInfo>` 包含所有观察员"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "SCOPES"
msgstr "证券交易所"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<ScopeInfo>` containing all scopes, including custom ones"
msgstr " `Collection<ScopeInfo>` 包含所有的作用域，包括自定义的作用域"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "QUALIFIERS"
msgstr "资格审查员"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all qualifiers"
msgstr " `Map<DotName, ClassInfo>` 包含所有限定词"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "INTERCEPTOR_BINDINGS"
msgstr "拦截器_绑定"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all interceptor bindings"
msgstr " `Map<DotName, ClassInfo>` 包含所有拦截器的绑定"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "STEREOTYPES"
msgstr "遗传因子"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "`Map<DotName, StereotypeInfo>` containing all stereotypes"
msgstr " `Map<DotName, StereotypeInfo>` 包含所有定型的"

#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"To get hold of these, simply query the extension context object for given key.\n"
"Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.\n"
"If your extension attempts to retrieve metadata that wasn't yet produced, `null` will be returned.\n"
"Here is a summary of which extensions can access which metadata:"
msgstr "要获取这些元数据，只需查询扩展上下文对象中的给定键即可。请注意，这些元数据是在构建过程中提供的，这意味着扩展只能利用在调用扩展之前构建的元数据。如果扩展试图检索尚未生成的元数据， `null` 。下面总结了哪些扩展可以访问哪些元数据："

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "AnnotationsTransformer"
msgstr "注释性转化器"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Shouldn't rely on any metadata as it could be used at any time in any phase of the bootstrap"
msgstr "不应该依赖任何元数据，因为它可以在引导的任何阶段中随时使用。"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "ContextRegistrar"
msgstr "语境注册商（ContextRegistrar"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"
msgstr "可访问 `ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` 。 `STEREOTYPES` "

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "InjectionPointsTransformer"
msgstr "注射点变换器"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "ObserverTransformer"
msgstr "观察者变换器"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "BeanRegistrar"
msgstr "豆类注册商（BeanRegistrar"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "可以访问 `ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` , `STEREOTYPES` , `BEANS` （仅基于类的豆子）， `OBSERVERS` （仅基于类的观察者）。 `INJECTION_POINTS` "

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "ObserverRegistrar"
msgstr "观察员登记员"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "可访问 `ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` , `STEREOTYPES` , `BEANS` , `OBSERVERS` （仅限基于类的观察者）、 `INJECTION_POINTS`"

#. type: Labeled list
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy, no-wrap
msgid "BeanDeploymentValidator"
msgstr "BeanDeploymentValidator"

#. type: Plain text
#: _versions/main/guides/cdi-integration.adoc
#, fuzzy
msgid "Has access to all build metadata"
msgstr "可访问所有构建元数据"
