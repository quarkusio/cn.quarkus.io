msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Quarkus Messaging Extensions"
msgstr "Quarkus 消息传递扩展"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Event-driven messaging systems have become the backbone of most modern applications,\n"
"enabling the building of message-driven microservices or complex data streaming pipelines."
msgstr "事件驱动的消息传递系统已成为大多数现代应用程序的支柱，使消息驱动的微服务或复杂的数据流管道的构建成为可能。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus offers a comprehensive suite of messaging extensions designed to synchronize with leading messaging technologies effortlessly.\n"
"This empowers developers to concentrate on crafting the core application logic, liberating them from the necessity to delve into the complexities of individual APIs and messaging infrastructures."
msgstr "Quarkus提供了一套全面的消息传递扩展，旨在毫不费力地与领先的消息传递技术同步。这样，开发人员就可以专注于设计核心应用程序逻辑，而不必深入研究个别应用程序接口和消息基础架构的复杂性。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "This page focuses on common features and the development model for all messaging extensions."
msgstr "本页主要介绍所有信息扩展的共同功能和开发模式。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Some of these extensions are maintained in the core Quarkus repository:"
msgstr "Quarkus 核心软件库中维护了其中一些扩展："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "*Messaging*: The core extension defines the basic concepts and APIs to develop messaging applications"
msgstr "*消息传递* 核心扩展定义了开发消息传递应用程序的基本概念和应用程序接口"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "xref:kafka.adoc[*Messaging - Kafka Connector*]"
msgstr "xref:kafka.adoc[消息传送 - Kafka 连接器]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "xref:pulsar.adoc[*Messaging - Pulsar Connector*]"
msgstr "xref:pulsar.adoc[消息传送 - Pulsar 连接器]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "xref:rabbitmq-reference.adoc[*Messaging - RabbitMQ Connector*]"
msgstr "xref:rabbitmq-reference.adoc[消息传送 - RabbitMQ 连接器]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "xref:amqp-reference.adoc[*Messaging - AMQP 1.0 Connector*]"
msgstr "xref:amqp-reference.adoc[消息传送 - AMQP 1.0 连接器]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "*Messaging - MQTT Connector*"
msgstr "*消息传送 - MQTT 连接器*"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Some extensions are contributed and maintained by the community:"
msgstr "一些扩展由社区贡献和维护："

#: _versions/main/guides/messaging.adoc
msgid "link:{camel-smallrye-reactive-messaging}[Camel SmallRye Reactive Messaging]"
msgstr ""

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:{nats-jetstream}[Nats Jetstream Connector]"
msgstr "link:{nats-jetstream}[Nats 捷流连接器]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:{solace-quarkus}[Solace Messaging Connector]"
msgstr "link:{solace-quarkus}[Solace 消息连接器]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:{http-websocket-connector}[Reactive HTTP and WebSocket Connector]"
msgstr "link:{http-websocket-connector}[反应式 HTTP 和 WebSocket 连接器]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "AWS SQS Connector"
msgstr "AWS SQS 连接器"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Other connectors, such as the *JMS Connector* or the *Google PubSub Connector*, do not benefit from the same level of integration and require more manual configuration to set up."
msgstr "其他连接器，如 *JMS 连接器* 或 *Google PubSub 连接器* ，则无法从相同的集成水平中获益，而且需要更多的手动配置来设置。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"On the other hand, some messaging-related extensions propose low-level provider-specific integrations.\n"
"The level of support covered on this page DOES NOT involve these low-level extensions.\n"
"A non-exhaustive list of this kind of extension are the following:"
msgstr "另一方面，一些与消息相关的扩展提出了针对特定提供商的低级集成。本页面涵盖的支持级别不涉及这些低级扩展。以下是此类扩展的不完全列表："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://quarkus.io/guides/kafka-streams[Kafka Streams Extension]"
msgstr "link:https://quarkus.io/guides/kafka-streams[卡夫卡流扩展]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://docs.quarkiverse.io/quarkus-rabbitmq-client/dev/index.html[RabbitMQ Client]"
msgstr "link:https://docs.quarkiverse.io/quarkus-rabbitmq-client/dev/index.html[RabbitMQ 客户端]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://docs.quarkiverse.io/quarkus-hivemq-client/dev/index.html[HiveMQ Client]"
msgstr "link:https://docs.quarkiverse.io/quarkus-hivemq-client/dev/index.html[HiveMQ 客户端]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://docs.quarkiverse.io/quarkus-artemis/dev/quarkus-artemis-jms.html[Artemis Core & JMS]"
msgstr "link:https://docs.quarkiverse.io/quarkus-artemis/dev/quarkus-artemis-jms.html[Artemis Core 和 JMS]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://docs.quarkiverse.io/quarkus-google-cloud-services/main/pubsub.html[Google Cloud Pubsub]"
msgstr "link:https://docs.quarkiverse.io/quarkus-google-cloud-services/main/pubsub.html[谷歌云 Pubsub]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Quarkus Messaging Development Model"
msgstr "Quarkus 消息传递开发模型"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus simplifies message-driven application development by establishing a uniform model for publishing, consuming, and processing messages, regardless of whether the underlying broker technology uses message queuing or event streaming.\n"
"Built upon the MicroProfile Reactive Messaging specification, Quarkus Messaging extensions ensure seamless integration with these technologies.\n"
"Importantly, proficiency in reactive programming is NOT a prerequisite for leveraging these capabilities."
msgstr "无论底层代理技术使用的是消息队列还是事件流，Quarkus都能为消息的发布、消费和处理建立统一的模型，从而简化消息驱动型应用程序开发。Quarkus 消息传递扩展基于 MicroProfile 反应式消息传递规范，可确保与这些技术无缝集成。重要的是，熟练掌握反应式编程并不是利用这些功能的先决条件。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The Reactive Messaging specification defines a CDI-based programming model for implementing event-driven and message-driven applications.\n"
"Using a small set of annotations, CDI beans become building blocks for implementing interactions with message brokers.\n"
"These interactions happen through _channels_ where application components read and write messages."
msgstr "Reactive Messaging 规范定义了一种基于 CDI 的编程模型，用于实现事件驱动和消息驱动的应用程序。CDI Bean 通过使用少量注释集，成为实现与消息代理交互的构件。这些交互是通过应用组件读写消息的 _通道_ 实现的。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "_Channels_ are identified by a unique name and declared using a set of annotations."
msgstr "_通道_ 由一个唯一的名称标识，并使用一组注释进行声明。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@Incoming` and `@Outgoing` annotations"
msgstr "`@Incoming` 和 注释 `@Outgoing` "

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@Incoming` and `@Outgoing` method annotations define _channels_ allowing to consume messages from and produce messages to the message broker:"
msgstr "`@Incoming` 和 方法注解定义了允许从消息代理处消费消息和向消息代理处生成消息的 `@Outgoing` _通道_ ："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@Outgoing` can be used by itself on a method to generate messages:"
msgstr "`@Outgoing` 可以在方法中单独使用，以生成信息："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@Incoming` can be used by itself to consume messages:"
msgstr "`@Incoming` 本身就可以用来消费信息："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Note that you should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code.\n"
"They are invoked by the framework.\n"
"Having user code invoking them would not have the expected outcome."
msgstr "请注意，不应在代码中直接调用注释为 `@Incoming` 和/或 `@Outgoing` 的方法。它们是由框架调用的。用户代码调用它们不会产生预期结果。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can read more on supported method signatures in the link:{rm_doc_method_signatures}[SmallRye Reactive Messaging – Supported signatures]."
msgstr "有关支持的方法签名的更多信息，请参阅 link:{rm_doc_method_signatures}[SmallRye Reactive Messaging - 支持的签名] 。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Emitters and `@Channel` annotation"
msgstr "发射器和 `@Channel` 注释"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "An application often needs to combine messaging with other parts of the application, ex. produce messages from HTTP endpoints, or stream consumed messages as a response."
msgstr "应用程序通常需要将消息传递与应用程序的其他部分结合起来，例如，从 HTTP 端点生成消息，或将消耗的消息作为响应流。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "To send messages from imperative code to a specific channel, you need to inject an `Emitter` object identified by the `@Channel` annotation:"
msgstr "要从命令式代码向特定通道发送消息，需要注入一个由 `@Channel` 注解标识的 `Emitter` 对象："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The `@Channel` annotation lets you indicate to which channel you will send your payloads or messages.\n"
"The `Emitter` allows buffering messages sent to the channel."
msgstr "`@Channel` 注释可让您指明要向哪个通道发送有效载荷或消息。 `Emitter` 允许缓冲发送到通道的信息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "For more control, using link:{mutiny}[Mutiny] APIs, you can use the `MutinyEmitter` emitter interface:"
msgstr "使用 link:{mutiny}[Mutiny] API，您可以使用 `MutinyEmitter` 发射器接口来获得更多控制权："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "The `@Channel` annotation can also be used to inject the stream of messages from an incoming channel:"
msgstr "`@Channel` 注释也可用于注入传入通道的信息流："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"When consuming messages with `@Channel`, the application code is responsible for subscribing to the stream.\n"
"In the example above, the Quarkus REST (formerly RESTEasy Reactive) endpoint handles that for you."
msgstr "当使用 `@Channel` 消费消息时，应用程序代码负责订阅流。在上面的示例中，Quarkus REST（前身为 RESTEasy Reactive）端点为你处理了这个问题。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can read more on the emitters and channels in the link:{rm_doc_emitter}[SmallRye Reactive Messaging – Emitter and Channels] documentation."
msgstr "有关发射器和信道的更多信息，请参阅 link:{rm_doc_emitter}[SmallRye Reactive Messaging - 发射器和信道] 文档。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Messages and Metadata"
msgstr "信息和元数据"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"A `Message` is an envelope around a payload.\n"
"In the examples above only payloads were used, but every payload is wrapped around a `Message` internally in Quarkus Messaging."
msgstr "`Message` 是对有效载荷的封装。在上面的示例中，只使用了有效载荷，但在 Quarkus Messaging 内部，每个有效载荷都包裹着一个 `Message` 。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The `Message<T>` interface associates a payload of type `<T>` with `Metadata`,\n"
"a set of arbitrary objects and asynchronous actions for acknowledgement (ack) and negative acknowledgement (nack)."
msgstr "`Message<T>` 接口将 `<T>` 类型的有效载荷与 `Metadata` 、一组任意对象以及用于确认 (ack) 和否定确认 (nack) 的异步操作关联起来。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"A message is acknowledged back to the broker when its processing or reception has been successful.\n"
"Acknowledgements between messages are chained, meaning that when processing a message,\n"
"the acknowledgement of an outgoing message triggers the acknowledgement of incoming message(s).\n"
"In most cases, acks and nacks are managed for you and connectors allow you to configure different strategies per channel.\n"
"So, you usually don't need to interact with the `Message` interface directly.\n"
"Only advanced use cases require dealing with the Message directly."
msgstr "报文处理或接收成功后，会向代理回执。报文之间的确认是链式的，这意味着在处理报文时，发出报文的确认会触发收到报文的确认。在大多数情况下，acks 和 nacks 会为您管理，连接器允许您为每个通道配置不同的策略。因此，您通常不需要直接与 `Message` 接口交互。只有高级用例才需要直接处理消息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Accessing the `Metadata`, on the other hand, can be practical in many cases.\n"
"Connectors add specific metadata objects to the message to give access to the message headers, properties, and other connector-specific information.\n"
"You do not need to interact with the `Message` interface to access connector-specific metadata.\n"
"You can simply inject the metadata object as a method parameter after the payload parameter:"
msgstr "另一方面，访问 `Metadata` 在很多情况下都很实用。连接器会将特定的元数据对象添加到报文中，以便访问报文头、属性和其他特定于连接器的信息。要访问特定于连接器的元数据，无需与 `Message` 接口交互。您只需将元数据对象作为方法参数注入到有效载荷参数之后即可："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Depending on the connector, payload types available to consume in processing methods differ.\n"
"You can implement a custom `MessageConverter` to transform the payload to a type that is accepted by your application."
msgstr "根据连接器的不同，处理方法中可用的有效载荷类型也不同。您可以自定义 `MessageConverter` ，将有效载荷转换为应用程序可接受的类型。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Channel configuration"
msgstr "通道配置"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Channel attributes can be configured using the `mp.messaging.incoming.<channel-name>` and `mp.messaging.outgoing.<channel-name>` configuration properties."
msgstr "通道属性可使用 `mp.messaging.incoming.<channel-name>` 和 `mp.messaging.outgoing.<channel-name>` 配置属性进行配置。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "For example, to configure the Kafka connector to consume messages from the `my-topic` topic with a custom deserializer:"
msgstr "例如，配置 Kafka 连接器，以便使用自定义反序列化器从 `my-topic` 主题消费消息："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The `connector` attribute is required for all channels and specifies the connector to use.\n"
"You can omit this configuration if you have a single connector on your classpath, as Quarkus will automatically select the connector."
msgstr "`connector` 属性对所有通道都是必需的，它指定了要使用的连接器。如果classpath上只有一个连接器，则可以省略此配置，因为Quarkus会自动选择连接器。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Global channel attributes can be configured using the connector name:"
msgstr "全局通道属性可使用连接器名称进行配置："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Connector-specific attributes are listed in connector documentation."
msgstr "连接器特定属性列于连接器文档中。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Channel wiring and Messaging patterns"
msgstr "通道布线和信息传递模式"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"At startup time, Quarkus analyzes declared channels to wire them together and verify that all channels are connected.\n"
"Concretely, each channel creates a _reactive stream_ of messages connected to another channel's _reactive stream_ of messages.\n"
"Adhering to the reactive stream protocol, the back-pressure mechanism is enforced between channels, allowing to control application resource usage and not over-commit and overloading part of the system."
msgstr "启动时，Quarkus 会分析已声明的通道，将它们连接在一起，并验证所有通道是否已连接。具体来说，每个通道都会创建一个与另一个通道的反应式 _信息流_ 相连的 _反应式信息流_ 。根据反应流协议，通道之间会执行反向压力机制，从而控制应用程序的资源使用，避免过度承诺和系统部分超载。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"On the flip side it is NOT possible to create new channels programmatically at runtime.\n"
"There are, however, many patterns that let you implement most, if not all, messaging and integration use cases:"
msgstr "反过来说，也不可能在运行时以编程方式创建新通道。不过，有许多模式可以让你实现大多数（如果不是全部）消息传递和集成用例："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Some messaging technologies allow consumers to subscribe to a set of topics or queues, and producers to send messages to a specific topic on message basis.\n"
"If you are sure you need to configure and create clients dynamically at runtime, you should consider using the low-level clients directly."
msgstr "有些消息传递技术允许消费者订阅一组主题或队列，允许生产者根据消息向特定主题发送消息。如果确定需要在运行时动态地配置和创建客户端，则应考虑直接使用底层客户端。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Internal Channels"
msgstr "内部渠道"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"In some use cases, it is convenient to use messaging patterns to transfer messages inside the same application.\n"
"When you don't connect a channel to a messaging backend, i.e. a connector, everything happens internally to the application,\n"
"and the streams are created by chaining methods together.\n"
"Each chain is still a reactive stream and enforces the back-pressure protocol."
msgstr "在某些用例中，使用消息传递模式在同一应用程序内传输消息非常方便。如果不将通道连接到消息传递后端（即连接器），一切都将在应用程序内部进行，而流则是通过方法链创建的。每个链仍然是一个反应流，并执行反压协议。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The framework verifies that the producer/consumer chain is complete,\n"
"meaning that if the application writes messages into an internal channel (using a method with only `@Outgoing`, or an `Emitter`),\n"
"it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream)."
msgstr "框架会验证生产者/消费者链是否完整，这意味着如果应用程序将消息写入内部信道（使用仅包含 `@Outgoing` 的方法或 `Emitter` ），则必须同时从应用程序内部（使用仅包含 `@Incoming` 的方法或使用非托管流）消费消息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Enable/Disable channels"
msgstr "启用/禁用通道"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "All defined channels are enabled by default, but it is possible to disable a channel with the configuration:"
msgstr "所有已定义的通道默认都已启用，但也可以通过配置禁用某个通道："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"This can be used alongside Quarkus build profiles to enable/disable channels based on some build-time condition, such as the the target environment.\n"
"You need to make sure of two things when disabling a channel:"
msgstr "它可以与 Quarkus 构建配置文件一起使用，根据某些构建时间条件（如目标环境）启用/禁用通道。在禁用通道时，你需要确保两件事："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "the disabled channel usage is located in a bean that can be filtered out at build time,"
msgstr "禁用通道使用位于一个 bean 中，可以在构建时过滤掉、"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "that without the channel, the remaining channels still work correctly."
msgstr "在没有该通道的情况下，其余通道仍能正常工作。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Multiple Outgoings and `@Broadcast`"
msgstr "多重支出和 `@Broadcast`"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"By default, messages transmitted in a channel are only dispatched to a single consumer.\n"
"Having multiple consumers is considered an error and is reported at deployment time."
msgstr "默认情况下，在信道中传输的消息只发送给一个消费者。多个消费者被视为错误，会在部署时报告。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The `@Broadcast` annotation changes this behavior and indicates that messages transiting in the channel are dispatched to all the consumers.\n"
"`@Broadcast` must be used with the `@Outgoing` annotation:"
msgstr "`@Broadcast` 注解改变了这一行为，它表示在通道中传输的信息会被发送到所有消费者。 `@Broadcast` 必须与 `@Outgoing` 注解一起使用："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Similarly to `@Broadcast`, you can use `@Outgoing` annotation multiple times on the same method to indicate that the method produces messages to multiple channels:"
msgstr "与 `@Broadcast` 类似，您可以在同一个方法上多次使用 `@Outgoing` 注释，以表示该方法向多个通道发送消息："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Using Multiple Outgoings can be useful for implementing fan-out patterns, in which a single message is processed by multiple target channels."
msgstr "使用 \"多重输出 \"可以帮助实现扇出模式，即一条信息由多个目标通道处理。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can selectively dispatch messages to multiple outgoings by returning `Targeted` from the processing method:"
msgstr "通过从处理方法返回 `Targeted` ，您可以有选择性地将信息分派到多个出口："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Multiple Incomings and `@Merge`"
msgstr "多重收入和 `@Merge`"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"By default, a single producer can transmit messages in a channel.\n"
"Having multiple producers is considered erroneous and is reported at deployment time.\n"
"The `@Merge` annotation changes this behavior and indicates that a channel can have multiple producers.\n"
"`@Merge` must be used with the `@Incoming` annotation:"
msgstr "默认情况下，单个生产者可在一个通道中传输信息。拥有多个生产者会被认为是错误的，并在部署时被报告。 `@Merge` 注解改变了这一行为，表明一个通道可以有多个生产者。 `@Merge` 必须与 `@Incoming` 注解一起使用："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Similarly to `@Merge`, you can use `@Incoming` annotation multiple times on the same method to indicate that the method consumes messages from multiple channels:"
msgstr "与 `@Merge` 类似，您可以在同一个方法上多次使用 `@Incoming` 注解，以表示该方法消耗来自多个通道的消息："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Stream Processing"
msgstr "流处理"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "In some advanced scenarios, you can manipulate directly the stream of messages instead of each individual message."
msgstr "在某些高级情况下，您可以直接操作信息流，而不是每条单独的信息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Using link:{mutiny}[Mutiny APIs] in incoming and outgoing signatures allow you to process the stream of messages:"
msgstr "在传入和传出签名中使用 link:{mutiny}[Mutiny API] ，可以处理信息流："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Execution Model"
msgstr "执行模式"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus Messaging sits on top of the xref:quarkus-reactive-architecture.adoc#engine[reactive engine] of Quarkus and leverages link:{eclipse-vertx}[Eclipse Vert.x] to dispatch messages for processing.\n"
"It supports three execution modes:"
msgstr "Quarkus Messaging 位于 Quarkus 的 xref:quarkus-reactive-architecture.adoc#engine[反应式引擎] 之上，利用 link:{eclipse-vertx}[Eclipse Vert.x] 来调度处理消息。它支持三种执行模式："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"*Event-loop*, where messages are dispatched on the Vert.x I/O thread.\n"
"Remember that you should not perform blocking operations on the event loop."
msgstr "*事件循环* ，信息在 Vert.x I/O 线程上派发。切记不要在事件循环上执行阻塞操作。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "*Worker-threads*, where messages are dispatched on a worker thread pool."
msgstr "*工作* 线程（ *Worker-threads* ），信息在工作线程池中分发。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"*Virtual-threads*, where messages are dispatched on a virtual thread (requires Java 21+).\n"
"As virtual threads are not pooled, a new virtual thread is created for each message.\n"
"Please refer to the dedicated xref:messaging-virtual-threads.adoc[Quarkus Virtual Thread support] guide for more information."
msgstr "*虚拟* 线程（ *Virtual-threads* ），信息在虚拟线程上发送（要求 Java 21+）。由于虚拟线程没有池化，因此每条消息都会创建一个新的虚拟线程。更多信息请参阅专门的 xref:messaging-virtual-threads.adoc[Quarkus 虚拟线程支持] 指南。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus chooses the default execution mode based on the method signature.\n"
"If the method signature is _synchronous_, messages are dispatched on *worker threads* otherwise it defaults to *event-loop*:"
msgstr "Quarkus 根据方法签名选择默认执行模式。如果方法签名是 _同步的_ ，消息就会在 *工作线程* 上发送，否则就会默认为 *事件循环* ："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Method signature"
msgstr "方法签名"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Default execution mode"
msgstr "默认执行模式"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"@Incoming(\"source\")\n"
"void process(String payload)"
msgstr "@Incoming(\"source\") void process(String payload)"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Worker-threads"
msgstr "工作线程"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"@Incoming(\"source\")\n"
"Uni<Void> process(String payload)"
msgstr "@Incoming(\"source\") Uni<Void> process(String payload)"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Event-loop"
msgstr "事件循环"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"@Incoming(\"source\")\n"
"CompletionStage<Void> process(Message<String> message)"
msgstr "@Incoming(\"source\") CompletionStage<Void> process(Message<String> message)"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"@Incoming(\"source\")\n"
"@Outgoing(\"sink\")\n"
"Multi<R> process(Multi<T> in)"
msgstr "@Incoming(\"source\") @Outgoing(\"sink\") Multi<R> process(Multi<T> in)"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Stream-processing methods are executed at startup, then each message is dispatched on event loop."
msgstr "流处理方法在启动时执行，然后在事件循环中分发每条信息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Fine-grained control over the execution model is possible using annotations:"
msgstr "使用注释可以对执行模型进行细粒度控制："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"link:{rm_blocking_annotation}[`@Blocking`] will force the method to be executed on a worker thread pool.\n"
"The default pool of worker threads is shared between all channels.\n"
"Using `@Blocking(\"my-custom-pool\")` you can configure channels with a custom thread pool.\n"
"The configuration property `smallrye.messaging.worker.my-custom-pool.max-concurrency` specifies the maximum number of threads in the pool.\n"
"You can read more on the blocking processing in link:{rm_blocking_docs}[SmallRye Reactive Messaging documentation]."
msgstr "link:{rm_blocking_annotation}[@Blocking] 会强制该方法在工作线程池上执行。默认的工作线程池由所有通道共享。使用 `@Blocking(\"my-custom-pool\")` ，可以用自定义线程池配置通道。配置属性 `smallrye.messaging.worker.my-custom-pool.max-concurrency` 可指定池中线程的最大数量。有关阻塞处理的更多信息，请参阅 link:{rm_blocking_docs}[SmallRye Reactive Messaging 文档] 。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@NonBlocking` will force the method to be executed on the event-loop thread."
msgstr "`@NonBlocking` 会强制该方法在事件循环线程上执行。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"`@RunOnVirtualThread` will force the method to be executed on a virtual thread.\n"
"To leverage the lightweight nature of virtual threads, the default maximum concurrency for methods annotated with `@RunOnVirtualThread` is 1024.\n"
"This can be changed by setting the `smallrye.messaging.worker.<virtual-thread>.max-concurrency` configuration property\n"
"or using together with the `@Blocking(\"my-custom-pool\")` annotation."
msgstr "`@RunOnVirtualThread` 将强制方法在虚拟线程上执行。为了充分利用虚拟线程的轻量级特性，使用 注释的方法的默认最大并发量为 1024。可以通过设置 配置属性或与 注释一起使用来更改。 `@RunOnVirtualThread` `smallrye.messaging.worker.<virtual-thread>.max-concurrency` `@Blocking(\"my-custom-pool\")` "

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "The presence of `@Transactional` annotation implies blocking execution."
msgstr "`@Transactional` 注释的存在意味着阻塞执行。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"In messaging applications, produced and consumed messages constitute an ordered stream of events,\n"
"either enforced by the broker (inside a topic or a queue)\n"
"or by the order of reception and emission in the application.\n"
"To preserve this order, Quarkus Messaging dispatches messages sequentially by default.\n"
"You can override this behavior by using `@Blocking(ordered = false)` or `@RunOnVirtualThread` annotation."
msgstr "在消息传递应用程序中，产生和消耗的消息构成了有序的事件流，这可能是由代理（主题或队列内部）强制执行的，也可能是由应用程序中的接收和发送顺序强制执行的。为了保持这种顺序，Quarkus 消息传递默认按顺序分派消息。你可以使用 `@Blocking(ordered = false)` 或 `@RunOnVirtualThread` 注释来覆盖这一行为。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Incoming Channel Concurrency"
msgstr "传入通道并发"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Some connectors support configuring the concurrency level of incoming channels."
msgstr "某些连接器支持配置传入通道的并发级别。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"This creates four copies of the incoming channel under the hood, wiring them to the same processing method.\n"
"Depending on the broker technology, this can be useful to increase the application's throughput by processing multiple messages concurrently\n"
"while still preserving the partial order of messages received in different copies.\n"
"This is the case, for example, for Kafka, where multiple consumers can consume different topic partitions."
msgstr "这将在引擎盖下创建四个传入通道副本，并将它们连接到相同的处理方法。根据代理技术的不同，这可以通过并发处理多条消息来提高应用程序的吞吐量，同时还能保留不同副本中接收到的消息的部分顺序。例如，在 Kafka 中，多个消费者可以使用不同的主题分区。"

#: _versions/main/guides/messaging.adoc
msgid "Health Checks"
msgstr "健康检查"

#: _versions/main/guides/messaging.adoc
msgid ""
"Together with the SmallRye Health extension, Quarkus Messaging extensions provide health check support per channel.\n"
"The implementation of _startup_, _readiness_ and _liveness_ checks depends on the connector.\n"
"Some connectors allow configuring the health check behavior or disabling them completely or per channel."
msgstr ""

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Channel health checks can be disabled using `quarkus.messaging.health.<channel-name>.enabled` or per health check type,\n"
"ex. `quarkus.messaging.health.<channel-name>.liveness.enabled`."
msgstr "可以使用 `quarkus.messaging.health.<channel-name>.enabled` 或按健康检查类型（例如 `quarkus.messaging.health.<channel-name>.liveness.enabled` ）禁用通道健康检查。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Setting the `quarkus.messaging.health.enabled` configuration property to `false` completely disables the messaging health checks."
msgstr "将 `quarkus.messaging.health.enabled` 配置属性设置为 `false` 可完全禁用消息传递健康检查。"

#: _versions/main/guides/messaging.adoc
msgid "Observability"
msgstr "可观察性"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Micrometer Metrics"
msgstr "千分尺度量"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus Messaging extensions provide simple but useful metrics to monitor the health of the messaging system.\n"
"The xref:telemetry-micrometer.adoc[Micrometer extension] exposes these metrics."
msgstr "Quarkus 消息传递扩展提供了简单但有用的指标，用于监控消息传递系统的健康状况。 xref:telemetry-micrometer.adoc[Micrometer 扩展] 提供了这些指标。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "The following metrics can be gathered per channel, identified with the `channel` tag:"
msgstr "通过 `channel` 标签可收集每个通道的以下指标："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`quarkus.messaging.message.count` : The number of messages produced or received"
msgstr "`quarkus.messaging.message.count` 信息：生成或接收的信息数量"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`quarkus.messaging.message.acks` : The number of messages processed successfully"
msgstr "`quarkus.messaging.message.acks` 成功处理的报文数量"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`quarkus.messaging.message.failures` : The number of messages processed with failures"
msgstr "`quarkus.messaging.message.failures` ：处理失败的报文数量"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`quarkus.messaging.message.duration` : The duration of the message processing"
msgstr "`quarkus.messaging.message.duration` 信息处理的持续时间"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "For backwards compatibility reasons, channel metrics are not enabled by default and can be enabled with: `smallrye.messaging.observation.enabled=true`."
msgstr "出于向后兼容的原因，默认情况下不启用通道度量，但可以使用 `smallrye.messaging.observation.enabled=true` ."

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "OpenTelemetry Tracing"
msgstr "OpenTelemetry 追踪"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Some Quarkus Messaging connectors integrate out-of-the-box with OpenTelemetry Tracing.\n"
"When the xref:opentelemetry.adoc[OpenTelemetry extension] is present, outgoing messages propagate the current tracing span.\n"
"On incoming channels, if a received message contains tracing information, the message processing inherits the message span as parent."
msgstr "一些 Quarkus 消息连接器与 OpenTelemetry 跟踪功能集成。当有 xref:opentelemetry.adoc[OpenTelemetry 扩展] 时，发出的消息会传播当前的跟踪跨度。在传入通道上，如果收到的消息包含跟踪信息，消息处理将继承作为父级的消息跨度。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can disable tracing for a specific channel using the following configuration:"
msgstr "您可以使用以下配置禁用特定通道的跟踪功能："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "TLS Configuration"
msgstr "TLS 配置"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Some messaging extensions integrate with the xref:./tls-registry-reference.adoc[Quarkus TLS Registry] to configure the underlying client.\n"
"To configure the TLS on a channel, you need to provide the named TLS configuration to the `tls-configuration-name` property:"
msgstr "一些消息扩展与 xref:./tls-registry-reference.adoc[Quarkus TLS 注册表] 集成，以配置底层客户端。要在通道上配置 TLS，需要向 `tls-configuration-name` 属性提供命名的 TLS 配置："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Or you can configure it globally on all channels of a connector:"
msgstr "也可以在连接器的所有通道上进行全局配置："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Currently, the following messaging extensions support configuration through the Quarkus TLS Registry:"
msgstr "目前，以下信息扩展支持通过 Quarkus TLS 注册表进行配置："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Kafka: Provides the `ssl.engine.factory.class` property for the Kafka client."
msgstr "卡夫卡：为 Kafka 客户端提供 `ssl.engine.factory.class` 属性。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Pulsar: Only mTLS authentication is supported."
msgstr "脉冲星：仅支持 mTLS 身份验证。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "RabbitMQ"
msgstr "RabbitMQ"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "AMQP 1.0"
msgstr "AMQP 1.0"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "MQTT"
msgstr "MQTT"

#: _versions/main/guides/messaging.adoc
msgid "Testing"
msgstr "测试"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Testing with Dev Services"
msgstr "使用开发服务进行测试"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Most Quarkus Messaging extensions provide a Dev Service to simplify the development and testing of applications.\n"
"The Dev Service creates a broker instance configured to work out-of-the-box with the Quarkus Messaging extension."
msgstr "大多数 Quarkus 消息传递扩展都提供了开发服务（Dev Service），以简化应用程序的开发和测试。开发服务会创建一个代理实例，并将其配置为与 Quarkus 消息传递扩展开箱即用。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "During testing Quarkus creates a separate broker instance to run the tests against it."
msgstr "在测试过程中，Quarkus 会创建一个单独的代理实例来运行测试。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can read more about Dev Services in the xref:dev-services.adoc[Dev Services] guide, including a list of Dev Services provided by platform extensions."
msgstr "您可以在 xref:dev-services.adoc[开发服务指南] 中阅读有关开发服务的更多信息，包括平台扩展提供的开发服务列表。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Testing with InMemoryConnector"
msgstr "使用 InMemoryConnector 进行测试"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"It can be useful to test the application without starting a broker.\n"
"To achieve this, you can _switch_ the channels managed by a connector to _in-memory_."
msgstr "在不启动代理的情况下测试应用程序可能很有用。为此，可以 _将_ 连接器管理的通道 _切换_ 为 _内存_ 通道。"

#: _versions/main/guides/messaging.adoc
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "这种方法只适用于JVM测试。它不能用于原生测试(因为原生模式不支持注入)。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Let's say we want to test the following sample application:"
msgstr "假设我们要测试以下示例应用程序："

#: _versions/main/guides/messaging.adoc
msgid "First, add the following test dependency to your application:"
msgstr "首先，在您的应用程序中添加以下测试依赖："

#: _versions/main/guides/messaging.adoc
msgid "pom.xml"
msgstr "pom.xml"

#: _versions/main/guides/messaging.adoc
msgid "build.gradle"
msgstr "build.gradle"

#: _versions/main/guides/messaging.adoc
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "然后，按以下方法创建Quarkus测试资源："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Switch the incoming channel `words-in` (consumed messages) to in-memory."
msgstr "将传入通道 `words-in` （消耗的信息）切换到内存中。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Switch the outgoing channel `words-out` (produced messages) to in-memory."
msgstr "将外发通道 `words-out` （产生的报文）切换到内存中。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Switch the outgoing channel `uppercase` (processed messages) to in-memory."
msgstr "将外发通道 `uppercase` （已处理报文）切换到内存中。"

#: _versions/main/guides/messaging.adoc
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "构建并返回一个 `Map` ，包含配置应用程序使用内存 channels 所需的所有属性。"

#: _versions/main/guides/messaging.adoc
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "当测试停止时，清除 `InMemoryConnector` (丢弃所有接收和发送的信息)。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Create a `@QuarkusTest` using the test resource created above:"
msgstr "使用上面创建的测试资源创建 `@QuarkusTest` ："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Inject the in-memory connector in your test class, using the `@Connector` or `@Any` qualifier."
msgstr "在测试类中注入内存连接器，使用 `@Connector` 或 `@Any` 限定符。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Retrieve the outgoing channel (`words-out`) - the channel must have been switched to in-memory in the test resource."
msgstr "读取输出通道 ( `words-out` ) - 该通道必须已切换到测试资源的内存中。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Retrieve the incoming channel (`words-in`)"
msgstr "读取输入频道 ( `words-in` )"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Retrieve the outgoing channel (`uppercase`)"
msgstr "读取发送频道 ( `uppercase` )"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Use the injected application bean to call `sendMessage` method to send a message using the emitter with the channel `words-out`."
msgstr "使用注入的应用程序 Bean 调用 `sendMessage` 方法，使用带有通道 `words-out` 的发射器发送信息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Use the `received` method on `words-out` in-memory channel to check the message produced by the application."
msgstr "在 `words-out` 内存通道上使用 `received` 方法检查应用程序生成的信息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Use the `send` mwthod on `words-in` in-memory channel to send a message.\n"
"The application will process this message and send a message to `uppercase` channel."
msgstr "在 `words-in` 内存通道上使用 `send` mwthod 发送信息。应用程序将处理该信息并向 `uppercase` 频道发送信息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Use the `received` method on `uppercase` channel to check the messages produced by the application."
msgstr "在 `uppercase` 频道上使用 `received` 方法检查应用程序生成的信息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"In-memory connector is solely intended for testing purposes.\n"
"There are some caveats to consider when using the in-memory connector:"
msgstr "内存连接器仅用于测试目的。使用内存连接器时需要注意一些事项："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The in-memory connector only transmits objects (payloads or configured messages) sent using the `InMemorySource#send` method.\n"
"Messages received by the application methods won't contain connector-specific metadata."
msgstr "内存连接器只传输使用 `InMemorySource#send` 方法发送的对象（有效载荷或配置信息）。应用方法接收的信息不包含特定于连接器的元数据。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"By default, in-memory channels dispatch messages on the caller thread of the `InMemorySource#send` method, which would be the main thread in unit tests.\n"
"However, most of the other connectors handle context propagation dispatching messages on separate duplicated Vert.x contexts."
msgstr "默认情况下，内存通道会在 `InMemorySource#send` 方法的调用线程（即单元测试中的主线程）上分派消息。不过，大多数其他连接器都会处理上下文传播，在单独的重复 Vert.x 上下文中分派消息。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "The `quarkus-test-vertx` dependency provides the `@io.quarkus.test.vertx.RunOnVertxContext` annotation, which when used on a test method, executes the test on a Vert.x context."
msgstr "`quarkus-test-vertx` 依赖项提供了 `@io.quarkus.test.vertx.RunOnVertxContext` 注解，在测试方法中使用该注解时，测试将在 Vert.x 上下文中执行。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"If your tests are dependent on context propagation, you can configure the in-memory connector channels with `run-on-vertx-context` attribute to dispatch events, including messages and acknowledgements, on a Vert.x context.\n"
"Alternatively you can switch this behaviour using the `InMemorySource#runOnVertxContext` method."
msgstr "如果您的测试依赖于上下文传播，您可以配置带有 `run-on-vertx-context` 属性的内存连接器通道，以便在 Vert.x 上下文中分派事件（包括消息和确认）。或者，您也可以使用 `InMemorySource#runOnVertxContext` 方法切换这种行为。"

#: _versions/main/guides/messaging.adoc
msgid "Going further"
msgstr "进一步探索"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "This guide shows the general principles of Quarkus Messaging extensions."
msgstr "本指南介绍了 Quarkus 消息传递扩展的一般原则。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"If you want to go further, you can check the link:{rm_doc}[SmallRye Reactive Messaging] documentation,\n"
"which has in-depth documentation for each of these concepts and more."
msgstr "如果你想进一步了解，可以查看 link:{rm_doc}[SmallRye Reactive Messaging] 文档，其中有关于上述每个概念和更多内容的深入文档。"
