# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2023-11-22 02:24+0000\n"
"PO-Revision-Date: 2022-05-31 09:24+0800\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Building a Native Executable"
msgstr "构建一个原生可执行文件"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "This guide covers:"
msgstr "本指南包括："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Compiling the application to a native executable"
msgstr "将应用程序编译为原生可执行文件"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Packaging the native executable in a container"
msgstr "将原生可执行文件打包到一个容器中"

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Debugging native executable"
msgstr "调试原生可执行文件"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "This guide takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide]."
msgstr "本指南将 xref:getting-started.adoc[入门指南]中开发的应用程序作为输入。"

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "A xref:configuring-c-development[working C development environment]"
msgstr "一个 xref:configuring-c-development[C语言工作开发环境]"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "The code of the application developed in the xref:getting-started.adoc[Getting Started Guide]."
msgstr "在 xref:getting-started.adoc[入门指南] 中开发的应用程序代码。"

#. type: Block title
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Supporting native compilation in C"
msgstr "支持C语言的原生编译"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "What does having a working C developer environment mean?"
msgstr "拥有一个C语言工作开发者环境意味着什么？"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:"
msgstr "在Linux上，你将需要GCC，以及glibc和zlib头文件。常见发行版的例子："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "XCode provides the required dependencies on macOS:"
msgstr "XCode在macOS上提供了必要的依赖性："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]"
msgstr "在Windows上，你将需要安装 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++构建工具]"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Background"
msgstr "背景介绍"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Building a native executable requires using a distribution of GraalVM.\n"
"There are three distributions:\n"
"Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.\n"
"The differences between the Oracle and Mandrel distributions are as follows:"
msgstr "构建一个原生可执行文件需要使用GraalVM的发行版。有三个发行版：Oracle GraalVM社区版（CE）、Oracle GraalVM企业版（EE）和Mandrel。Oracle和Mandrel发行版之间的区别如下："

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Mandrel is a downstream distribution of the Oracle GraalVM CE.\n"
"Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus."
msgstr "Mandrel是Oracle GraalVM CE的一个下游发行版。Mandrel的主要目标是提供一种方法来构建专门为支持Quarkus而设计的原生可执行文件。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base,\n"
"with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.\n"
"They support the same capabilities to build native executables as Oracle GraalVM CE,\n"
"with no significant changes to functionality.\n"
"Notably, they do not include support for polyglot programming.\n"
"The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.\n"
"These exclusions also mean Mandrel offers a considerable reduction in its distribution size\n"
"when compared with Oracle GraalVM CE/EE."
msgstr "Mandrel版本的代码库来自于上游的Oracle GraalVM CE代码库，只做了一些小的改动，但也有一些重要的对于Quarkus本地应用程序来说是没有必要的排除项。它们支持与Oracle GraalVM CE相同的构建原生可执行文件的能力，在功能上没有重大变化。值得注意的是，它们不包括对多语言编程的支持。之所以排除这些功能，是为了给大多数Quarkus用户提供更好的支持水平。与Oracle GraalVM CE/EE相比，这些不包括的内容也意味着Mandrel发布的软件包大小大大减小。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.\n"
"This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.\n"
"These enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.\n"
"This is particularly important when it comes to conformance and security."
msgstr "Mandrel的构建方式与Oracle GraalVM CE略有不同，它使用标准的OpenJDK项目。这意味着，Oracle往OpenJDK增加了一些小增强功能，并用于构建Oracle自己的GraalVM，但Mandrel不能从中获益。这些增强功能被省略了，因为它上游的标准OpenJDK并不管理这些特性，也无法提供保障。这一点在涉及到一致性和安全性时尤其重要。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Mandrel is recommended for building native executables that target Linux containerized environments.\n"
"This means that Mandrel users are encouraged to use containers to build their native executables.\n"
"If you are building native executables for macOS,\n"
"you should consider using Oracle GraalVM instead,\n"
"because Mandrel does not currently target this platform.\n"
"Building native executables directly on bare metal Linux or Windows is possible,\n"
"with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README]\n"
"and https://github.com/graalvm/mandrel/releases[Mandrel releases]."
msgstr "Mandrel被推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着，我们鼓励Mandrel用户使用容器来构建他们的原生可执行文件。如果你要为macOS构建本地可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前不针对这个平台。直接在裸机Linux或Windows上构建原生可执行文件是可能的，详情可参见 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel发行版] 。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Configuring GraalVM"
msgstr "配置GraalVM"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"This step is only required for generating native executables targeting non-Linux operating systems.\n"
"For generating native executables targeting Linux, you can optionally skip this section and xref:container-runtime[use a builder image] instead."
msgstr "只有在生成针对非 Linux 操作系统的本地可执行文件时才需要此步骤。如果要生成针对 Linux 的本地可执行文件，可以选择跳过这一部分，而 xref:container-runtime[使用生成器映像] 。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM.\n"
"There is an explanation of how to do this at xref:multistage-docker[the end of this guide]."
msgstr "如果无法安装 GraalVM，可以使用多阶段 Docker 构建，在嵌入 GraalVM 的 Docker 容器内运行 Maven。 xref:multistage-docker[本指南末尾将] 解释如何做到这一点。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "GraalVM {graalvm-version} is required."
msgstr "版本 {graalvm-version} 是必需的。使用社区版就可以了。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Install GraalVM if you haven't already. You have a few options for this:"
msgstr "如果你还没有安装 GraalVM。那么你有几个选择："

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Download the appropriate archive from <https://github.com/graalvm/mandrel/releases> or <https://github.com/graalvm/graalvm-ce-builds/releases>, and unpack it like you would any other JDK."
msgstr "从 <https://github.com/graalvm/mandrel/releases> 或 <https://github.com/graalvm/graalvm-ce-builds/releases> 下载相应的归档文件，然后像对待其他 JDK 一样将其解压。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"Use platform-specific installer tools like https://sdkman.io/jdks#graalce[sdkman], https://github.com/graalvm/homebrew-tap[homebrew], or https://github.com/ScoopInstaller/Java[scoop].\n"
"We recommend the _community edition_ of GraalVM. For example, install it with `sdk install java 21-graalce`."
msgstr "使用特定平台的安装工具，如 link:https://sdkman.io/jdks#graalce[sdkman] 、 link:https://github.com/graalvm/homebrew-tap[homebrew] 或 link:https://github.com/ScoopInstaller/Java[scoop] 。我们推荐使用 GraalVM 的 _社区版_ 。例如，使用 `sdk install java 21-graalce` 安装。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:"
msgstr "配置运行环境。例如将 `GRAALVM_HOME` 环境变量设置为GraalVM的安装目录，例如："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "On macOS (not supported by Mandrel), point the variable to the `Home` sub-directory:"
msgstr "在macOS上（Mandrel不支持），将该变量指向 `Home` 子目录："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "On Windows, you will have to go through the Control Panel to set your environment variables."
msgstr "在Windows上，您将不得不通过控制面板来设置你的环境变量。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Installing via scoop will do this for you."
msgstr "通过scoop安装将为你做到这一点。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "(Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory."
msgstr "(可选）将 `JAVA_HOME` 环境变量设置为GraalVM的安装目录。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "(Optional) Add the GraalVM `bin` directory to the path"
msgstr "(可选）将GraalVM `bin` 目录添加到路径中"

#. type: Block title
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Issues using GraalVM with macOS"
msgstr "在MacOS Catalina上使用GraalVM的问题"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "GraalVM binaries are not (yet) notarized for macOS as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `native-image`:"
msgstr "GraalVM的二进制文件（尚未）对macOS Catalina进行认证，正如这个 https://github.com/oracle/graal/issues/1724[GralVM问题]中所报告的那样。这意味着您在使用 `gu` 时可能会看到以下错误："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:"
msgstr "使用以下命令递归删除GraalVM安装目录上的 `com.apple.quarantine` 扩展属性，作为一种解决方法："

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example."
msgstr "我们建议您按照下面几节的说明，一步一步地打包应用。不过您还可以直接进入完成的例子。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库: `git clone {quickstarts-clone-url}` ，或下载一个 {quickstarts-archive-url}[存档] 。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "The solution is located in the `getting-started` directory."
msgstr "该解决方案位于 `getting-started` 目录中。"

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Producing a native executable"
msgstr "制作一个原生可执行文件"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint."
msgstr "我们应用程序的原生可执行文件将包含应用程序代码、所需的库、Java API和一个缩小版的虚拟机。较小的虚拟机基础提高了应用程序的启动时间和最小的磁盘占用。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "image:native-executable-process.png[Creating a native executable]"
msgstr "image:native-executable-process.png[创建原生可执行文件]"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:"
msgstr "如果你已经从前面的教程中生成了应用程序，你可以在 `pom.xml` ，找到以下 _profile_："

#: _versions/main/guides/building-native-image.adoc
msgid ""
"You can provide custom options for the `native-image` command using the `<quarkus.native.additional-build-args>` property.\n"
"Multiple options may be separated by a comma."
msgstr "你可以使用 `<quarkus.native.additional-build-args>` 属性为 `native-image` 命令提供自定义选项。多个选项可以用逗号隔开。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`."
msgstr "另一种做法是在你的 `application.properties` ，填写 `quarkus.native.additional-build-args` 配置属性。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "You can find more information about how to configure the native image building process in the xref:configuration-reference[Configuring the Native Executable] section below."
msgstr "你可以在下面的 <<configuration-reference>> 部分找到关于如何配置原生镜像构建过程的更多信息。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could\n"
"just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as\n"
"this allows native image tests to also be run."
msgstr "我们使用profile是因为，你很快就会看到，打包原生可执行文件需要 _few_ 分钟。你可以在命令行中把 -Dquarkus.package.type=native 作为一个属性，但是最好是使用一个profile，因为这可以使原生镜像测试也被运行。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Create a native executable using:"
msgstr "使用以下方法创建一个原生可执行文件："

#. type: Block title
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Issues with packaging on Windows"
msgstr "在Windows上打包的问题"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"The Microsoft Native Tools for Visual Studio must first be initialized before packaging.\n"
"You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools.\n"
"At the `x64 Native Tools Command Prompt`, you can navigate to your project folder and run `./mvnw package -Dnative`."
msgstr "打包前必须首先初始化 Visual Studio 的 Microsoft 本地工具。您可以通过启动与 Visual Studio Build Tools 一起安装的 `x64 Native Tools Command Prompt` 来实现这一点。在 `x64 Native Tools Command Prompt` ，您可以导航到项目文件夹并运行 `./mvnw package -Dnative` 。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Another solution is to write a script to do this for you:"
msgstr "另一个解决方案是写一个脚本来为您做这件事："

#: _versions/main/guides/building-native-image.adoc
msgid ""
"In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.\n"
"You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`."
msgstr "除了常规文件外，该构建还产生了 `target/getting-started-1.0.0-SNAPSHOT-runner` 。你可以用以下方式运行它： `./target/getting-started-1.0.0-SNAPSHOT-runner` 。"

#. type: Block title
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Java preview features"
msgstr "Java预览功能"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Java code that relies on preview features requires special attention.\n"
"To produce a native executable, this means that the `--enable-preview` flag needs to be passed to the underlying native image invocation.\n"
"You can do so by prepending the flag with `-J` and passing it as additional native build argument: `-Dquarkus.native.additional-build-args=-J--enable-preview`."
msgstr "依赖于预览功能的Java代码需要特别注意。为了产生一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给底层的原生镜像调用。你可以这样做，用 `-J` 作为标志的前缀，并将其作为额外的原生构建参数传递：`-Dquarkus.native.additional-build-args=-J--enable-preview`。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Build fully static native executables"
msgstr "构建纯静态原生可执行文件"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Fully static native executables support is experimental."
msgstr "纯静态原生可执行文件支持是试验性的。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"On Linux it's possible to package a native executable that doesn't depend on any system shared library.\n"
"There are link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/guides/build-static-executables/#prerequisites-and-preparation[some system requirements] to be fulfilled and additional build arguments to be used along with the `native-image` invocation, a minimum is `-Dquarkus.native.additional-build-args=\"--static\",\"--libc=musl\"`."
msgstr "在 Linux 上，可以打包一个不依赖任何系统共享库的本地可执行文件。需要满足 link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/guides/build-static-executables/#prerequisites-and-preparation[一些系统要求] ，并在调用 `native-image` 时使用额外的编译参数，最低要求是 `-Dquarkus.native.additional-build-args=\"--static\",\"--libc=musl\"` 。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Compiling fully static binaries is done by statically linking https://musl.libc.org/[musl] instead of `glibc` and should not be used in production without rigorous testing."
msgstr "编译纯静态的二进制文件是通过静态链接 link:https://musl.libc.org/[musl] 而不是 `glibc` ，如果没有严格的测试，不应该在生产中使用。"

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Testing the native executable"
msgstr "测试原生可执行文件"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file. The reasoning is explained in the link:getting-started-testing#quarkus-integration-test[Testing Guide]."
msgstr "制作一个原生可执行文件可能会导致一些问题，因此，建议针对以原生可执行文件运行的应用程序运行一些测试。具体原因在 link:getting-started-testing#quarkus-integration-test[测试指南] 中有详细解释。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "To see the `GreetingResourceIT` run against the native executable, use `./mvnw verify -Dnative`:"
msgstr "要看到 `GreetingResourceIT` 面向原生可执行文件运行，使用 `./mvnw verify -Pnative` ："

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This\n"
"duration can be changed using the `quarkus.test.wait-time` system property. For example, to increase the duration\n"
"to 300 seconds, use: `./mvnw verify -Dnative -Dquarkus.test.wait-time=300`."
msgstr "默认情况下，Quarkus 会等待原生映像启动 60 秒，然后自动使原生测试失败。可以使用 `quarkus.test.wait-time` 系统属性更改该持续时间。例如，要将持续时间增加到 300 秒，请使用： `./mvnw verify -Dnative -Dquarkus.test.wait-time=300` 。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"This procedure was formerly accomplished using the `@NativeImageTest` annotation. `@NativeImageTest` was replaced by `@QuarkusIntegrationTest` which provides a superset of the testing\n"
"capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide]."
msgstr "`@NativeImageTest` `@NativeImageTest` 被 取代，后者提供了 测试功能的超集。有关 的更多信息，请参阅《 `@QuarkusIntegrationTest` `@NativeImageTest` `@QuarkusIntegrationTest` xref:getting-started-testing.adoc#quarkus-integration-test[测试指南》] 。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Profiles"
msgstr "配置文件"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "By default, integration tests both *build* and *run* the native executable using the `prod` profile."
msgstr "默认情况下，集成测试使用 `prod` 配置文件 *build* 和 *run* 原生可执行文件。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"You can override the profile the executable *runs* with during the test using the `quarkus.test.native-image-profile` property.\n"
"Either by adding it to `application.properties` or by appending it to the command line:\n"
"`./mvnw verify -Dnative -Dquarkus.test.native-image-profile=test`.\n"
"Your `%test.` prefixed properties will be used at the test runtime."
msgstr "您可以使用 `quarkus.test.native-image-profile` 属性覆盖可执行文件在测试过程中的 *运行* 配置文件。可将其添加到 `application.properties` 或添加到命令行： `./mvnw verify -Dnative -Dquarkus.test.native-image-profile=test` 。测试运行时将使用 `%test.` 前缀的属性。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"You can override the profile the executable is *built* with and *runs* with using the `quarkus.profile=test` property, e.g.\n"
"`./mvnw clean verify -Dnative -Dquarkus.profile=test`. This might come handy if there are test specific resources to be processed,\n"
"such as importing test data into the database."
msgstr "您可以使用 `quarkus.profile=test` 属性覆盖可执行文件 *的* 配置文件，例如 `./mvnw clean verify -Dnative -Dquarkus.profile=test` 。如果需要处理特定的测试资源，如将测试数据导入数据库，这可能会派上用场。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"With the aforementioned example in your `application.properties`, your Hibernate ORM managed database will be populated with test\n"
"data both during the JVM mode test run and during the native mode test run. The production\n"
"executable will contain only the `version.txt` resource, no superfluous test data."
msgstr "在前面提到的 `application.properties` 例子中。在JVM模式测试运行期间和原生模式测试运行期间，Hibernate ORM管理的数据库将填充测试数据。生产可执行文件将只包含 `version.txt` 资源，没有多余的测试数据。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"The executable built with `-Dquarkus.profile=test` is not suitable for production deployment.\n"
"It contains your test resources files and settings. Once the testing is done, the executable would have to be built again,\n"
"using the default, `prod` profile."
msgstr "`-Dquarkus.profile=test` 生成的可执行文件不适合用于生产部署。它包含测试资源文件和设置。测试完成后，必须使用 `prod` 默认配置文件重新构建可执行文件。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"Alternatively, if you need to specify specific properties when running tests against the native executable\n"
"built using the `prod` profile, an option is to put those properties in file `src/test/resources/application-nativeit.yaml`, and refer to it from the `failsafe` plugin configuration using the `QUARKUS_CONFIG_LOCATIONS` environment variable. For instance:"
msgstr "另外，如果在针对使用 `prod` 配置文件构建的本地可执行文件运行测试时需要指定特定属性，也可以将这些属性放在文件 `src/test/resources/application-nativeit.yaml` 中，并使用 `QUARKUS_CONFIG_LOCATIONS` 环境变量从 `failsafe` 插件配置中引用该文件。例如"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Java code that relies on preview features requires special attention.\n"
"To test a native executable, this means that the `--enable-preview` flag needs to be passed to the Surefire plugin.\n"
"Adding `<argLine>--enable-preview</argLine>` to its `configuration` section is one way to do so."
msgstr "依赖于预览功能的Java代码需要特别注意。为了测试一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给Surefire插件。将 `<argLine>--enable-preview</argLine>` 添加到其 `configuration` 片段是一种可行方法。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Excluding tests when running as a native executable"
msgstr "作为原生可执行文件运行时排除测试"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"When running tests this way, the only things that actually run natively are your application endpoints, which\n"
"you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code\n"
"that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests."
msgstr "以这种方式运行测试时，唯一能真正以本地方式运行的是应用程序端点，您只能通过 HTTP 调用对其进行测试。您的测试代码实际上并不在本地运行，因此如果您测试的代码不调用 HTTP 端点，那么将其作为本地测试的一部分运行可能不是一个好主意。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"If you share your test class between JVM and native executions like we advise above, you can mark certain tests\n"
"with the `@DisabledOnIntegrationTest` annotation in order to skip them when testing against a native image."
msgstr "如果你像我们上面建议的那样，在JVM和原生执行之间共享测试类，你可以用 `@DisabledOnNativeImage` 注解标记某些测试，被标注的测试只在JVM上运行。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Using `@DisabledOnIntegrationTest` will also disable the test in all integration test instances, including\n"
"testing the application in JVM mode, in a container image, and native image."
msgstr "使用 `@DisabledOnIntegrationTest` 还将禁用所有集成测试实例中的测试，包括在JVM模式、容器镜像和原生镜像中测试应用程序。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Testing an existing native executable"
msgstr "测试一个现有的原生可执行文件"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"It is also possible to re-run the tests against a native executable that has already been built. To do this run\n"
"`./mvnw test-compile failsafe:integration-test -Dnative`. This will discover the existing native image and run the tests against it using failsafe."
msgstr "也可以针对已构建的本地可执行文件重新运行测试。为此，请运行 `./mvnw test-compile failsafe:integration-test -Dnative` 。这将发现现有的本地镜像文件，并使用故障安全机制针对该镜像文件运行测试。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the\n"
"target directory you can specify the executable with the `-Dnative.image.path=` system property."
msgstr "如果进程由于某种原因找不到原生镜像，或者你想测试一个已经不在目标目录中的原生镜像，你可以用 `-Dnative.image.path=` 系统属性指定可执行文件。"

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Creating a Linux executable without GraalVM installed"
msgstr "在没有安装GraalVM的情况下创建一个Linux可执行文件"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker\n"
"on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop."
msgstr "在进一步行动之前，请确保有一个工作的容器运行环境（Docker或podman）。如果你在Windows上使用Docker，你应该在Docker Desktop文件共享设置中共享你的项目的驱动器，并重新启动Docker Desktop。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid\n"
"the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice\n"
"to install as little software as possible)."
msgstr "很多时候，人们只需要为他们的Quarkus应用程序创建一个原生Linux可执行文件（例如，为了在容器化环境中运行），并希望避免安装适当的GraalVM版本来完成这项麻烦任务（例如，在CI环境中，通常的做法是尽可能少地安装软件）。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.\n"
"The easiest way of accomplishing this task is to execute:"
msgstr "为此，Quarkus提供了一个非常方便的方法，通过利用容器运行时（如Docker或podman）来创建一个原生Linux可执行文件。完成这项任务的最简单方法是执行："

#: _versions/main/guides/building-native-image.adoc
msgid ""
"By default, Quarkus automatically detects the container runtime.\n"
"If you want to explicitly select the container runtime, you can do it with:"
msgstr "默认情况下，Quarkus会自动检测容器的运行时。如果你想显式指定择容器的运行时，你可以通过以下方式实现："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "For Docker:"
msgstr "对于Docker："

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "CLI"
msgstr "CLI"

#: _versions/main/guides/building-native-image.adoc
msgid "Maven"
msgstr "Maven"

#: _versions/main/guides/building-native-image.adoc
msgid "Gradle"
msgstr "Gradle"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "For podman:"
msgstr "对于podman："

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"These are regular Quarkus config properties, so if you always want to build in a container\n"
"it is recommended you add these to your `application.properties` in order to avoid specifying them every time."
msgstr "这些是常规的 Quarkus 配置属性，因此如果你总是想在容器中构建，建议将它们添加到 `application.properties` ，以避免每次都指定它们。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "If you see the following invalid path error for your application JAR when trying to create a native executable using a container build, even though your JAR was built successfully, you're most likely using a remote daemon for your container runtime."
msgstr "如果你在试图使用容器构建创建原生可执行文件时，尽管你的JAR已经成功构建，仍看到应用程序JAR出现以下无效路径错误，您很可能为容器运行时使用了一个远程守护进程。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"Error: Invalid Path entry getting-started-1.0.0-SNAPSHOT-runner.jar\n"
"Caused by: java.nio.file.NoSuchFileException: /project/getting-started-1.0.0-SNAPSHOT-runner.jar"
msgstr "错误：Invalid Path entry getting-started-1.0.0-SNAPSHOT-runner.jar 原因是： java.nio.file.NoSuchFileException：/project/getting-started-1.0.0-SNAPSHOT-runner.jar"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "In this case, use the parameter `-Dquarkus.native.remote-container-build=true` instead of `-Dquarkus.native.container-build=true`."
msgstr "在这种情况下，使用参数 `-Dquarkus.native.remote-container-build=true` ，而不是 `-Dquarkus.native.container-build=true` 。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "The reason for this is that the local build driver invoked through `-Dquarkus.native.container-build=true` uses volume mounts to make the JAR available in the build container, but volume mounts do not work with remote daemons. The remote container build driver copies the necessary files instead of mounting them. Note that even though the remote driver also works with local daemons, the local driver should be preferred in the local case because mounting is usually more performant than copying."
msgstr "原因是通过 `-Dquarkus.native.container-build=true` 调用的本地构建驱动程序使用卷挂载来使 JAR 在构建容器中可用，但卷挂载对远程守护程序不起作用。远程容器构建驱动程序复制必要的文件，而不是挂载它们。请注意，即使远程驱动程序也能与本地守护进程一起工作，但在本地情况下，本地驱动程序应该是首选，因为挂载通常比复制性能更高。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "Building with GraalVM instead of Mandrel requires a custom builder image parameter to be passed additionally:"
msgstr "使用Mandrel构建需要额外传递一个自定义的构建器镜像参数："

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"Please note that the above command points to a floating tag.\n"
"It is highly recommended to use the floating tag,\n"
"so that your builder image remains up-to-date and secure.\n"
"If you absolutely must, you may hard-code to a specific tag\n"
"(see https://quay.io/repository/quarkus/ubi-quarkus-mandrel-builder-image?tab=tags[here] for available tags),\n"
"but be aware that you won't get security updates that way and it's unsupported."
msgstr "请注意，上述命令指向的是浮动标签。强烈建议使用浮动标签，这样你的生成器图像就能保持最新和安全。如果万不得已，您可以硬编码到特定标签（请参阅 link:https://quay.io/repository/quarkus/ubi-quarkus-mandrel-builder-image?tab=tags[此处] 了解可用标签），但请注意，这种方式无法获得安全更新，而且不受支持。"

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Creating a container"
msgstr "创建一个容器"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Using the container-image extensions"
msgstr "使用容器-镜像扩展"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions."
msgstr "到目前为止，从你的Quarkus应用程序中创建一个容器镜像的最简单方法是利用容器镜像扩展。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:"
msgstr "如果这些扩展之一是存在的，那么为原生可执行文件创建一个容器镜像基本上就是执行一个命令的问题："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "`quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)"
msgstr "`quarkus.native.container-build=true` 允许在不安装GralVM的情况下创建一个Linux可执行文件（只有在你没有安装GralVM或者你的本地操作系统不是Linux的情况下才需要）"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "If you're running a remote Docker daemon, you need to replace `quarkus.native.container-build=true` with `quarkus.native.remote-container-build=true`."
msgstr "在这种情况下，使用参数 `-Dquarkus.native.remote-container-build=true` ，而不是 `-Dquarkus.native.container-build=true` 。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "See xref:tip-quarkus-native-remote-container-build[Creating a Linux executable without GraalVM installed] for more details."
msgstr "在没有安装GraalVM的情况下创建一个Linux可执行文件"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "`quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)"
msgstr "`quarkus.container-image.build=true` 指示Quarkus使用最终的应用程序工件（在本例中是原生可执行文件）创建一个容器镜像"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "See the xref:container-image.adoc[Container Image guide] for more details."
msgstr "更多细节见 xref:container-image.adoc[容器镜像指南] 。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Manually using the micro base image"
msgstr "手动使用微基础镜像"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.\n"
"However, in this section we focus on creating a container image using the produced native executable."
msgstr "你可以使用Quarkus Maven插件生成的JAR在容器中运行该应用程序。然而，在本节中我们将重点讨论使用生成的原生可执行文件创建一个容器镜像。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "image:containerization-process.png[Containerization Process]"
msgstr "image:containerization-process.png[容器化过程]"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).\n"
"However, as a container may not use the same _executable_ format as the one produced by your operating system,\n"
"we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in xref:container-runtime[this section]):"
msgstr "使用本地 GraalVM 安装时，本地可执行文件将以本地操作系统（Linux、macOS、Windows 等）为目标。不过，由于容器可能不会使用与操作系统生成的 _可执行文件_ 相同的格式，我们将指示 Maven 构建利用容器运行时生成可执行文件（如 xref:container-runtime[本节] 所述）："

#: _versions/main/guides/building-native-image.adoc
msgid ""
"The produced executable will be a 64-bit Linux executable, so depending on your operating system it may no longer be runnable.\n"
"However, it's not an issue as we are going to copy it to a container.\n"
"The project generation has provided a `Dockerfile.native-micro` in the `src/main/docker` directory with the following content:"
msgstr "产生的可执行文件将是一个64位的Linux可执行文件，所以如果您的操作系统不支持，它可能不能运行。但由于我们会把它复制到容器中，所以这不是一个问题。自动生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native-micro` ，内容如下："

#. type: Block title
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Quarkus Micro Image?"
msgstr "什么是Quarkus微镜像？"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"The Quarkus Micro Image is a small container image providing the right set of dependencies to run your native application.\n"
"It is based on https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro].\n"
"This base image has been tailored to work perfectly in containers."
msgstr "Quarkus 微镜像是一个小型的容器镜像，为运行你的原生应用程序提供了正确的依赖性集合。它是基于 https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro] 的。这个基础镜像已经被定制为在容器中完美运行。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "You can read more about UBI images on:"
msgstr "你可以在这里阅读更多关于UBI镜像的内容："

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image[Introduction to Universal Base Image]"
msgstr "https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image[通用基础镜像介绍]"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "https://catalog.redhat.com/software/container-stacks/detail/5ec53f50ef29fd35586d9a56[Red Hat Universal Base Image 8]"
msgstr "https://catalog.redhat.com/software/container-stacks/detail/5ec53f50ef29fd35586d9a56[红帽通用基础镜像8]"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "UBI images can be used without any limitations."
msgstr "UBI镜像可以不受任何限制地使用。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "xref:quarkus-runtime-base-image.adoc[This page] explains how to extend the `quarkus-micro` image when your application has specific requirements."
msgstr "xref:quarkus-runtime-base-image.adoc[此页] 解释了当你的应用有特殊要求时，如何扩展 `quarkus-micro` 镜像。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Then, if you didn't delete the generated native executable, you can build the docker image with:"
msgstr "然后，如果你没有删除生成的原生可执行文件，可以用以下方法构建docker镜像："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "And finally, run it with:"
msgstr "最后，用以下方式运行："

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Manually using the minimal base image"
msgstr "手工使用最小基础镜像"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "The project generation has also provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:"
msgstr "生成的项目也在 `src/main/docker` 目录中提供了一个 `Dockerfile.native` ，内容如下："

#: _versions/main/guides/building-native-image.adoc
msgid ""
"The UBI minimal image is bigger than the micro one mentioned above.\n"
"It contains more utilities such as the `microdnf` package manager."
msgstr "UBI最小镜像比上面提到的微镜像要大。它包含更多的实用程序，如 `microdnf` 软件包管理器。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Using a multi-stage Docker build"
msgstr "使用多阶段的Docker构建"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"The previous section showed you how to build a native executable using Maven or Gradle, but it requires you to have created the native executable first.\n"
"In addition, this native executable must be a Linux 64 bits executable."
msgstr "上一节向你展示了如何使用Maven或Gradle构建原生可执行文件，但这需要你先创建原生可执行文件。此外，这个原生可执行文件必须是Linux 64位可执行文件。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"You may want to build the native executable directly in a container without having a final container containing the build tools.\n"
"That approach is possible with a multi-stage Docker build:"
msgstr "你可能想直接在一个容器中构建原生可执行文件，而不需要一个包含构建工具的最终容器。这种方法可以通过多阶段的Docker构建来实现："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "The first stage builds the native executable using Maven or Gradle"
msgstr "第一阶段使用Maven或Gradle构建原生可执行文件"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "The second stage is a minimal image copying the produced native executable"
msgstr "第二阶段是复制产生了原生可执行文件的最小镜像"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "Before building a container image from the Dockerfiles shown below, you need to update the default `.dockerignore` file, as it filters everything except the `target` directory. In order to build inside a container, you need to copy the `src` directory. Thus, edit your `.dockerignore` and remove the `*` line."
msgstr "在启动我们的Docker构建之前，我们需要更新默认的 `.dockerignore` 文件，因为它过滤了除 `target` 目录之外的所有内容。由于我们计划在容器内构建，我们需要复制 `src` 目录。因此，编辑你的 `.dockerignore` ，并更新内容。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Such a multi-stage build can be achieved as follows:"
msgstr "这样的多阶段构建可以通过以下方式实现："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Sample Dockerfile for building with Maven:"
msgstr "用Maven构建的Docker文件例子："

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"This multi-stage Docker build copies the Maven wrapper from the host machine.\n"
"The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.\n"
"It avoids having to create a base image with Maven and Gradle.\n"
"To provision the Maven Wrapper in your project, use: `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.1:wrapper`."
msgstr "这种多阶段 Docker 构建会从主机复制 Maven 封装器。Maven 封装器（或 Gradle 封装器）是提供特定版本 Maven/Gradle 的便捷方法。它避免了创建包含 Maven 和 Gradle 的基础镜像。要在项目中配置 Maven 封装器，请使用： `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.1:wrapper` ."

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart."
msgstr "将此文件保存在 `src/main/docker/Dockerfile.multistage` ，因为它不包括在开始快速入门中。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Sample Dockerfile for building with Gradle:"
msgstr "用Gradle构建的Docker文件例子："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`."
msgstr "如果在项目中使用Gradle，你可以使用这个Docker文件例子。将其保存在 `src/main/docker/Dockerfile.multistage` 。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "And, finally, run it with:"
msgstr "最后，用以下方式运行："

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image."
msgstr "如果你的原生可执行文件需要SSL支持，你可以轻松地在Docker镜像中包含必要的库。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "Please see xref:native-and-ssl.adoc#working-with-containers[our Using SSL With Native Executables guide] for more information."
msgstr "更多信息请参见 xref:native-and-ssl.adoc#working-with-containers[我们的使用SSL与原生可执行文件指南] 。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "To use GraalVM CE instead of Mandrel, update the `FROM` clause to: `FROM quay.io/quarkus/ubi-quarkus-graalvmce-builder-image:{graalvm-flavor} AS build`."
msgstr "要使用Mandrel而不是GraalVM CE，请将 `FROM` 子句更新为: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build` 。 `$TAG` 可以在 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel镜像标签页]上找到。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Using a Distroless base image"
msgstr "使用无发行版基础镜像"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Distroless image support is experimental."
msgstr "无发行版支持是试验性的。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"If you are looking for small container images, the https://github.com/GoogleContainerTools/distroless[distroless] approach reduces the size of the base layer.\n"
"The idea behind _distroless_ is the usage of a single and minimal base image containing all the requirements, and sometimes even the application itself."
msgstr "如果你正在寻找小型的容器镜像，https://github.com/GoogleContainerTools/distroless[无发行] 的方法可以减少基础层的大小。 _distroless_ 背后的想法是使用一个单一和最小的基础镜像包含所有的需求，有时甚至是应用程序本身。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Quarkus provides a distroless base image that you can use in your `Dockerfile`.\n"
"You only need to copy your application, and you are done:"
msgstr "Quarkus提供了一个无发行版的基础镜像，可以用于你的 `Dockerfile` 。你只需要复制你的应用程序，就可以了："

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"Quarkus provides the `quay.io/quarkus/quarkus-distroless-image:2.0` image.\n"
"It contains the required packages to run a native executable and is only **9Mb**.\n"
"Just add your application on top of this image, and you will get a tiny container image."
msgstr "Quarkus 提供 `quay.io/quarkus/quarkus-distroless-image:2.0` 镜像。它包含运行本地可执行文件所需的软件包，只有 *9Mb* 。只需在该镜像上添加你的应用程序，就能得到一个很小的容器镜像。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Distroless images should not be used in production without rigorous testing."
msgstr "在没有经过严格测试的情况下，不应该在生产中使用无发行版镜像。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Build a container image from scratch"
msgstr "从头开始建立一个容器镜像"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Scratch image support is experimental."
msgstr "Scratch镜像的支持是试验性的。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "Building fully statically linked binaries enables the usage of a https://hub.docker.com/_/scratch[scratch image] containing solely the resulting native executable."
msgstr "构建完全静态链接的二进制文件可以使用仅包含所产生的本地可执行文件的 link:https://hub.docker.com/_/scratch[从头图像] 。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Sample multistage Dockerfile for building an image from `scratch`:"
msgstr "以下是基于 `scratch` 镜像，使用Dockerfile多阶段构建镜像的例子："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Scratch images should not be used in production without rigorous testing."
msgstr "在没有经过严格测试的情况下，不应该在生产中使用Scratch镜像。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "The versions of musl and zlib may need to be updated to meet the native-image executable requirements (and UPX if you use native image compression)."
msgstr "musl和zlib的版本可能需要更新，以满足本地图像可执行文件的要求（如果你使用本地图像压缩，还需要更新UPX）。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Compress native images"
msgstr "压缩原始图像"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Quarkus can compress the produced native executable using UPX.\n"
"More details on xref:./upx.adoc[UPX Compression documentation]."
msgstr "Quarkus可以使用UPX压缩产生的原生可执行文件。更多细节见 xref:./upx.adoc[UPX压缩文档] 。"

#. type: Title ===
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Separating Java and native image compilation"
msgstr "Java和原生镜像分开编译"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"In certain circumstances, you may want to build the native image in a separate step.\n"
"For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.\n"
"For this use case, you can set the `quarkus.package.type=native-sources`.\n"
"This will execute the java compilation as if you had started native compilation (`-Dnative`), but stops before triggering the actual call to GraalVM's `native-image`."
msgstr "在某些情况下，你可能希望在单独的步骤中构建本地镜像。例如，在 CI/CD 流水线中，可能需要一个步骤生成用于生成本地镜像的源代码，另一个步骤使用这些源代码实际构建本地可执行文件。在这种情况下，可以设置 `quarkus.package.type=native-sources` 。这将像启动本地编译（ `-Dnative` ）一样执行 java 编译，但会在触发实际调用 GraalVM 的 `native-image` 之前停止。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "After compilation has finished, you find the build artifact in `target/native-sources`:"
msgstr "编译完成后，你可以在 `target/native-sources` 找到构建工件："

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"From the output above one can see that, in addition to the produced jar file and the associated lib directory, a text file named `native-image.args` was created.\n"
"This file holds all parameters (including the name of the JAR to compile) to pass along to GraalVM's `native-image` command.\n"
"A text file named `graalvm.version` was also created and holds the GraalVM version that should be used.\n"
"If you have GraalVM installed and it matches this version, you can start the native compilation by executing:"
msgstr "从上面的输出可以看出，除了生成的 jar 文件和相关的 lib 目录外，还创建了一个名为 `native-image.args` 的文本文件。该文件包含所有参数（包括要编译的 JAR 的名称），以便传递给 GraalVM 的 `native-image` 命令。此外，还创建了一个名为 `graalvm.version` 的文本文件，其中包含应使用的 GraalVM 版本。如果已安装 GraalVM 且版本与之匹配，就可以执行以下命令开始本地编译："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "The process for Gradle is analogous."
msgstr "Gradle的过程是类似的。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Running the build process in a container is also possible:"
msgstr "在一个容器中运行构建过程也是可能的："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "`-Dquarkus.native.container-build=true` will produce an additional text file named `native-builder.image` holding the docker image name to be used to build the native image."
msgstr " `-Dquarkus.native.container-build=true` 将产生一个额外的文本文件，名为 ，其中包含用于构建本地镜像的docker镜像名称。 `native-builder.image` "

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Mount the host's directory `target/native-image` to the container's `/work`. Thus, the generated binary will also be written to this directory."
msgstr "将主机的目录 `target/native-image` 挂载到容器的 `/work` 。因此，生成的二进制文件也将被写入这个目录。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Switch the working directory to `/work`, which we have mounted in <1>."
msgstr "将工作目录切换到 `/work` ，我们已经在<1>中挂载了这个目录。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "Use the docker image from the file `native-builder.image`."
msgstr "使用文件中的docker镜像， `native-builder.image` 。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Call `native-image` with the content of file `native-image.args` as arguments. We also supply an additional argument to limit the process's maximum memory to 4 Gigabytes (this may vary depending on the project being built and the machine building it)."
msgstr "以文件 `native-image.args` 的内容为参数调用 `native-image` 。我们还提供了一个额外的参数，将进程的最大内存限制在4G字节（这可能取决于正在构建的项目和构建它的机器）。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"If you are running on a Windows machine, please keep in mind that the binary was created within a Linux docker container.\n"
"Hence, the binary will not be executable on the host Windows machine."
msgstr "如果你是在Windows机器上运行，请记住，二进制文件是在Linux docker容器中创建的。因此，二进制文件在Windows主机上是无法执行的。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "A high level overview of what the various steps of a CI/CD pipeline would look is the following:"
msgstr "以下是对CI/CD管道的各个步骤的高度概述："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Register the output of the step executing `./mvnw ...` command (i.e. directory `target/native-image`) as a build artifact,"
msgstr "将执行 `./mvnw …​` 命令的步骤的输出（即目录 `target/native-image` ）注册为构建工件，"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Require this artifact in the step executing the `native-image ...` command, and"
msgstr "在执行 `native-image …​` 命令的步骤中需要这个工件，并且"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Register the output of the step executing the `native-image ...` command (i.e. files matching `target/*runner`) as build artifact."
msgstr "将执行 `native-image …​` 命令的步骤的输出（即匹配 `target/*runner` 的文件）注册为构建工件。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "The environment executing step `1` only needs Java and Maven (or Gradle) installed, while the environment executing step `3` only needs a GraalVM installation (including the `native-image` feature)."
msgstr "执行步骤 `1` 的环境只需要安装Java和Maven（或Gradle），而执行步骤 `3` 的环境只需要安装GralVM（包括 `native-image` 功能）。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Depending on what the final desired output of the CI/CD pipeline is, the generated binary might then be used to create a container image."
msgstr "根据CI/CD管道的最终期望输出，生成的二进制文件可能被用来创建一个容器镜像。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"Native executables can be debugged using tools such as `gdb`.\n"
"For this to be possible native executables need to be generated with debug symbols."
msgstr "本地可执行文件可以使用 `gdb` 等工具进行调试。为此，本地可执行文件必须使用调试符号生成。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"Debug symbol generation is only supported on Linux.\n"
"Windows support is still under development, while macOS is not supported."
msgstr "调试符号生成仅支持 Linux。Windows 支持仍在开发中，而 macOS 不支持。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"To generate debug symbols,\n"
"add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.\n"
"You will find the debug symbols for the native executable in a `.debug` file next to the native executable."
msgstr "要生成调试符号，在生成原生可执行文件时添加 `-Dquarkus.native.debug.enabled=true` 标志。你将在原生可执行文件旁边的 `.debug` 文件中找到原生可执行文件的调试符号。"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"The generation of the `.debug` file depends on `objcopy`.\n"
"As a result, when using a local GraalVM installation on common Linux distributions you will need to install the `binutils` package:"
msgstr "`.debug` 文件的生成依赖于 `objcopy` 。因此，在普通 Linux 发行版上使用本地 GraalVM 安装时，需要安装 `binutils` 软件包："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "When `objcopy` is not available debug symbols are embedded in the executable."
msgstr "当被嵌入到可执行文件中的 `objcopy` 调试符号不可用时。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Aside from debug symbols,\n"
"setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files\n"
"for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.\n"
"This source cache is useful for native debugging tools,\n"
"to establish the link between the symbols and matching source code.\n"
"It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable."
msgstr "除了调试符号外，设置 `-Dquarkus.native.debug.enabled=true` 标志会生成一个源文件缓存，用于生成原生可执行文件时解决的任何JDK运行时类、GraalVM类和应用程序类。这个源码缓存对原生调试工具很有用，可以在符号和匹配的源代码之间建立联系。在调试本原生执行文件时，它提供了一种方便的方法，使调试器/IDE仅能获得必要的源文件。"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"Sources for third party jar dependencies, including Quarkus source code,\n"
"are not added to the source cache by default.\n"
"To include those, make sure you invoke `mvn dependency:sources` first.\n"
"This step is required in order to pull the sources for these dependencies,\n"
"and get them included in the source cache."
msgstr "第三方jar依赖的源，包括Quarkus源代码，默认情况下不会被添加到源缓存中。要包括这些，请确保你先调用 `mvn dependency:sources` 。这一步是必须的，以便拉出这些依赖的源代码，并将其包含在源代码缓存中。"

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "The source cache is located in the `target/sources` folder."
msgstr "源缓存位于 `target/sources` 文件夹中。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "If running `gdb` from a different directory than `target`, then the sources can be loaded by running:"
msgstr "如果从与 `target` 不同的目录下运行 `gdb` ，那么可以通过运行源代码加载："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "in the `gdb` prompt."
msgstr "在 `gdb` 提示中。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "Or start `gdb` with:"
msgstr "或这样运行 `gdb` 命令："

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "e.g.,"
msgstr "比如："

#. type: delimited block =
#: _versions/main/guides/building-native-image.adoc
msgid "For a more detailed guide about debugging native images please refer to the xref:native-reference.adoc[Native Reference Guide]."
msgstr "关于调试原生镜像的更详细指南，请参考 xref:native-reference.adoc[原生参考指南] 。"

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Using Monitoring Options"
msgstr "使用容器-镜像扩展"

#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid ""
"Monitoring options such as JDK flight recorder, jvmstat, heap dumps, and remote JMX (experimental in Mandrel 23)\n"
"can be added to the native executable build. Simply supply a comma separated list of the monitoring options you wish to\n"
"include at build time."
msgstr "JDK 飞行记录器、jvmstat、堆转储和远程 JMX（在 Mandrel 23 中为试验性）等监控选项可添加到本地可执行文件构建中。只需在构建时提供一个逗号分隔的监控选项列表即可。"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Monitoring Option"
msgstr "监测选项"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Description"
msgstr "描述"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Availability As Of"
msgstr "可用性截止到"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "jfr"
msgstr "jfr"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Include JDK Flight Recorder support"
msgstr "包括JDK飞行记录器支持"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "GraalVM CE 21.3 Mandrel 21.3"
msgstr "GraalVM CE 21.3心轴 21.3"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "jvmstat"
msgstr "ǞǞǞǞ"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Adds jvmstat support"
msgstr "增加了对jvmstat的支持"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "GraalVM 22.3, GraalVM CE 17.0.7 Mandrel 22.3 Mandrel 23.0 (17.0.7)"
msgstr "GraalVM 22.3、GraalVM CE 17.0.7 心轴 22.3 心轴 23.0 (17.0.7)"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "heapdump"
msgstr "heapdump"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Adds support for generating heap dumps"
msgstr "添加对生成堆转储的支持"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "jmxclient"
msgstr "jmxclient"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Adds support for connections to JMX servers."
msgstr "增加了对 JMX 服务器连接的支持。"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "GraalVM for JDK 17/20 Mandrel 23.0"
msgstr "GraalVM for JDK 17/20 Mandrel 23.0"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "jmxserver"
msgstr "jmxserver"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Adds support for accepting connections from JMX clients."
msgstr "添加了对接受 JMX 客户端连接的支持。"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "GraalVM for JDK 17/20 Mandrel 23.0 (17.0.7)"
msgstr "GraalVM for JDK 17/20 Mandrel 23.0 (17.0.7)"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "all"
msgstr "一应俱全"

#. type: Table
#: _versions/main/guides/building-native-image.adoc
#, fuzzy, no-wrap
msgid "Adds all monitoring options."
msgstr "添加所有监控选项。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
#, fuzzy
msgid "Please see the Quarkus Native Reference Guide for more detailed information on these monitoring options."
msgstr "有关这些监控选项的详细信息，请参阅《Quarkus 本机参考指南》。"

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "Configuring the Native Executable"
msgstr "配置原生可执行文件"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"There are a lot of different configuration options that can affect how the native executable is generated.\n"
"These are provided in `application.properties` the same as any other config property."
msgstr "有很多不同的配置选项可以影响原生可执行文件的生成方式。这些都是在 `application.properties` ，与其他配置属性相同。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "The properties are shown below:"
msgstr "这些属性显示如下："

#. type: Title ==
#: _versions/main/guides/building-native-image.adoc
#, no-wrap
msgid "What's next?"
msgstr "下一步做什么？"

#: _versions/main/guides/building-native-image.adoc
msgid ""
"This guide covered the creation of a native (binary) executable for your application.\n"
"It provides an application exhibiting a swift startup time and consuming less memory.\n"
"However, there is much more."
msgstr "本指南介绍了如何为应用程序创建原生(二进制)可执行文件。它提供了一个具备快速启动时间和消耗更少内存的应用程序。然而，还有更多。"

#. type: Plain text
#: _versions/main/guides/building-native-image.adoc
msgid "We recommend continuing the journey with the xref:deploying-to-kubernetes.adoc[deployment to Kubernetes and OpenShift]."
msgstr "我们建议继续阅读 xref:deploying-to-kubernetes.adoc[部署到Kubernetes和OpenShift]。"
