# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-12 02:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Apache Pulsar Reference Guide"
msgstr "Apache Kafka参考指南"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "This reference guide demonstrates how your Quarkus application can utilize Quarkus Messaging to interact with Apache Pulsar."
msgstr "本参考指南演示了 Quarkus 应用程序如何利用 Quarkus 消息传递与 Apache Pulsar 进行交互。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Introduction"
msgstr "简介"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"https://pulsar.apache.org[Apache Pulsar] is an open-source, distributed messaging and streaming platform built for the cloud.\n"
"It provides a multi-tenant, high-performance solution to server messaging with tiered storage capabilities."
msgstr "link:https://pulsar.apache.org[Apache Pulsar] 是专为云计算打造的开源分布式消息传递和流媒体平台。它为具有分层存储功能的服务器消息传输提供了一个多租户、高性能的解决方案。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Pulsar implements the publish-subscribe pattern:"
msgstr "Pulsar 实现了发布-订阅模式："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Producers publish messages to _topics_."
msgstr "生产者向 _主题_ 发布信息。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Consumers create _subscriptions_ to those topics to receive and process incoming messages, and send _acknowledgments_ to the broker when processing is finished."
msgstr "消费者对这些主题创建 _订阅_ ，以接收和处理传入的消息，并在处理完毕后向代理发送 _确认_ 。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"When a subscription is created, Pulsar retains all messages, even if the consumer is disconnected.\n"
"The retained messages are discarded only when a consumer acknowledges that all these messages are processed successfully."
msgstr "创建订阅后，Pulsar 会保留所有信息，即使消费者已断开连接。只有当用户确认所有这些信息都已成功处理时，才会丢弃保留的信息。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "A Pulsar cluster consists of"
msgstr "脉冲星星团由以下部分组成"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "One or more _brokers_, which are stateless components."
msgstr "一个或多个 _经纪人_ ，他们是无状态组件。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "A _metadata store_ for maintaining topic metadata, schema, coordination and cluster configuration."
msgstr "_元数据存储_ ，用于维护主题元数据、模式、协调和集群配置。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "A set of _bookies_ used for persistent storage of messages."
msgstr "用于持久存储信息的一组 _书签_ 。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Quarkus Extension for Apache Pulsar"
msgstr "用于阿帕奇脉冲星的 Quarkus 扩展程序"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Quarkus provides support for Apache Pulsar through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.\n"
"Based on Eclipse MicroProfile Reactive Messaging specification 3.0, it proposes a flexible programming model bridging CDI and event-driven."
msgstr "Quarkus 通过 link:https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] 框架为 Apache Pulsar 提供支持。它基于 Eclipse MicroProfile Reactive Messaging 规范 3.0，提出了一种灵活的编程模型，将 CDI 与事件驱动连接起来。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"This guide provides an in-depth look on Apache Pulsar and SmallRye Reactive Messaging framework.\n"
"For a quick start take a look at xref:pulsar-getting-started.adoc[Getting Started to Quarkus Messaging with Apache Pulsar]."
msgstr "本指南深入介绍了 Apache Pulsar 和 SmallRye Reactive Messaging 框架。如需快速入门，请参阅《 xref:pulsar-getting-started.adoc[使用 Apache Puls] ar 快速 xref:pulsar-getting-started.adoc[入门 Quarkus 消息传递] 》。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "You can add the `messaging-pulsar` extensions to your project by running the following command in your project base directory:"
msgstr "您可以在项目基本目录下运行以下命令，将 `messaging-pulsar` 扩展添加到项目中："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "This will add the following to your build file:"
msgstr "以上命令将在你的构建配置文件中添加以下内容："

#. type: Block title
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Block title
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "The extension includes `pulsar-clients-original` version 3.0.0 as a transitive dependency and is compatible with Pulsar brokers version 2.10.x."
msgstr "该扩展包括 `pulsar-clients-original` 3.0.0 版作为传递依赖项，并与 Pulsar brokers 2.10.x 版兼容。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Configuring SmallRye Pulsar Connector"
msgstr "配置 SmallRye Pulsar 连接器"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Because SmallRye Reactive Messaging framework supports different messaging backends like Apache Kafka, Apache Pulsar, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:"
msgstr "由于 SmallRye Reactive Messaging 框架支持 Apache Kafka、Apache Pulsar、AMQP、Apache Camel、JMS、MQTT 等不同的消息传递后端，因此它采用了通用词汇表："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Applications send and receive *messages*. https://javadoc.io/doc/io.smallrye.reactive/smallrye-reactive-messaging-api/latest/org/eclipse/microprofile/reactive/messaging/Message.html[`Message`] wraps a _payload_ and can be extended with some _metadata_.\n"
"This should not be confused with a Pulsar https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/client/api/Message.html[`Message`], which consists of value, key\n"
"With the Pulsar connector, a Reactive Messaging _message_ corresponds to a Pulsar _message_."
msgstr "应用程序发送和接收 *信息* 。 link:https://javadoc.io/doc/io.smallrye.reactive/smallrye-reactive-messaging-api/latest/org/eclipse/microprofile/reactive/messaging/Message.html[Message] Pulsar 包裹着一个 _有效载荷_ ，并可通过一些 _元数据_ 进行扩展。这不应与 Pulsar link:https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/client/api/Message.html[Message] 信息，后者由值、键组成。 通过 Pulsar 连接器，一个 Reactive Messaging _消息_ 对应一个 Pulsar _消息_ 。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Pulsar connector maps _channels_ to Pulsar _topics_."
msgstr "信息在 *通道* 上传输。应用程序组件连接到通道，以发布和消费信息。Pulsar 连接器将 _通道_ 映射到 Pulsar _主题_ 。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Channels are connected to message backends using *connectors*.\n"
"Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel.\n"
"Each connector is dedicated to a specific messaging technology.\n"
"For example, the connector dealing with Pulsar is named `smallrye-pulsar`."
msgstr "通道通过 *连接器* 与消息后端连接。连接器被配置为将传入信息映射到特定通道（由应用程序消耗），并收集发送到特定通道的传出信息。每个连接器都专用于特定的消息传递技术。例如，处理 Pulsar 的连接器名为 `smallrye-pulsar` 。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "A minimal configuration for the Pulsar connector with an incoming channel looks like the following:"
msgstr "带有输入通道的 Pulsar 连接器的最低配置如下："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Configure the Pulsar broker service url for the production profile.\n"
"You can configure it globally or per channel using `mp.messaging.incoming.$channel.serviceUrl` property.\n"
"In dev mode and when running tests, <<pulsar-dev-services>> automatically starts a Pulsar broker."
msgstr "为生产配置文件配置 Pulsar 代理服务 url。您可以使用 `mp.messaging.incoming.$channel.serviceUrl` 属性对其进行全局配置或按通道配置。在开发模式和运行测试时， <<pulsar-dev-services>> 会自动启动 Pulsar 代理。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Configure the connector to manage the prices channel.\n"
"By default, the _topic_ name is same as the channel name."
msgstr "配置连接器以管理价格通道。默认情况下， _主题_ 名称与通道名称相同。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "You can configure the topic attribute to override it."
msgstr "您可以配置主题属性来覆盖它。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details."
msgstr "`%prod` 前缀表示该属性只在应用程序运行在生产模式下时生效(而不是在开发或测试模式)。更多细节请参考 xref:config-reference.adoc#profiles[Profile documentation]。"

#. type: Block title
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Connector auto-attachment"
msgstr "连接器自动连接"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"If you have a single connector on your classpath, you can omit the `connector` attribute configuration.\n"
"Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.\n"
"_Orphan_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer."
msgstr "如果类路径上只有一个连接器，则可以省略 `connector` 属性配置。Quarkus 会自动将 _孤儿_ 通道关联到 classpath 上的（唯一）连接器。 _孤儿_ 通道是指没有下游消费者的传出通道或没有上游生产者的传入通道。"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
msgid "This auto-attachment can be disabled using:"
msgstr "可以用以下方法禁用这种自动连接功能："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "For more configuration options see <<configuring-pulsar-clients>>."
msgstr "有关更多配置选项，请参阅 <<configuring-pulsar-clients>> 。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Receiving messages from Pulsar"
msgstr "接收来自 Pulsar 的信息"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The Pulsar Connector connects to a Pulsar broker using a Pulsar client and creates consumers to\n"
"receive messages from Pulsar brokers, and it maps each Pulsar `Message` into Reactive Messaging `Message`."
msgstr "Pulsar 连接器使用 Pulsar 客户端连接到 Pulsar 经纪人，并创建消费者来接收来自 Pulsar 经纪人的信息，它将每个 Pulsar `Message` 映射到 Reactive Messaging `Message` 中。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Example"
msgstr "例子"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Let’s imagine you have a Pulsar broker running, and accessible using the `pulsar:6650` address.\n"
"Configure your application to receive Pulsar messages on the `prices` channel as follows:"
msgstr "假设您有一个 Pulsar 代理正在运行，并可通过 `pulsar:6650` 地址访问。将应用程序配置为在 `prices` 频道上接收 Pulsar 消息，如下所示："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Configure the Pulsar broker service url."
msgstr "配置 Pulsar 代理服务 url。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Make sure consumer subscription starts receiving messages from the `Earliest` position."
msgstr "确保消费者订阅从 `Earliest` 位置开始接收信息。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"You don’t need to set the Pulsar topic, nor the consumer name.\n"
"By default, the connector uses the channel name (`prices`).\n"
"You can configure the `topic` and `consumerName` attributes to override them."
msgstr "您不需要设置 Pulsar 主题或消费者名称。默认情况下，连接器使用通道名称 ( `prices` )。您可以配置 `topic` 和 `consumerName` 属性来覆盖它们。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"In Pulsar, consumers need to provide a `subscriptionName` for topic subscriptions.\n"
"If not provided the connector generates a unique **subscription name**."
msgstr "在 Pulsar 中，消费者需要为主题订阅提供 `subscriptionName` 。如果不提供，连接器会生成一个唯一的 *订阅名称* 。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Then, your application can receive the `double` payload directly:"
msgstr "然后，您的应用程序就可以直接接收 `double` 有效载荷："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Or, you can retrieve the Reactive Messaging type `Message<Double>`:"
msgstr "或者，您可以检索 Reactive Messaging 类型 `Message<Double>` ："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "The Reactive Messaging `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually."
msgstr "Reactive Messaging `Message` 类型允许消费方法访问传入的消息元数据，并手动处理确认。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "If you want to access the Pulsar message objects directly, use:"
msgstr "如果要直接访问 Pulsar 消息对象，请使用"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`org.apache.pulsar.client.api.Message` is provided by the underlying Pulsar client and can be used directly with the consumer method."
msgstr "`org.apache.pulsar.client.api.Message` 由底层 Pulsar 客户端提供，可直接与消费者方法一起使用。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Alternatively, your application can inject a `Multi` in your bean, identified with the channel name and subscribe to its events as the following example:"
msgstr "或者，您的应用程序可以在 Bean 中注入一个 `Multi` ，用通道名称标识并订阅其事件，如下例所示："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"When consuming messages with `@Channel`, the application code is responsible for the subscription.\n"
"In the example above, the Quarkus REST (formerly RESTEasy Reactive) endpoint handles that for you."
msgstr "当使用 `@Channel` 消费消息时，应用程序代码负责订阅。在上面的示例中，Quarkus REST（前身为 RESTEasy Reactive）端点为你处理了这个问题。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "Following types can be injected as channels:"
msgstr "以下类型可以作为 channels 被注入："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"As with the previous `Message` example, if your injected channel receives payloads (`Multi<T>`), it acknowledges the message automatically, and support multiple subscribers.\n"
"If your injected channel receives Message (`Multi<Message<T>>`), you will be responsible for the acknowledgment and broadcasting."
msgstr "与之前的 `Message` 示例一样，如果您注入的信道接收有效载荷 ( `Multi<T>` ) ，它会自动确认消息，并支持多个订阅者。如果您的注入式频道接收信息 ( `Multi<Message<T>>` )，您将负责确认和广播。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Blocking processing"
msgstr "阻塞处理"

#: _versions/main/guides/pulsar.adoc
msgid ""
"Reactive Messaging invokes your method on an I/O thread.\n"
"See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.\n"
"But, you often need to combine Reactive Messaging with blocking processing such as database interactions.\n"
"For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread."
msgstr "Reactive Messaging会在一个I/O线程中调用您的方法。关于这个话题的更多细节，请看  xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation]  。但是您可能需要经常将Reactive Messaging 与阻塞式处理相结合使用，比如与数据库通信。为此，您需要使用 `@Blocking` 注解来表该明处理是 _阻塞的_ ，并且不在调用者线程中运行。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr "例如，下面的代码演示了如何使用Hibernate与Panache将接收到的payload存储到数据库："

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
msgid "There are 2 `@Blocking` annotations:"
msgstr "有2种 `@Blocking` 注解："

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#: _versions/main/guides/pulsar.adoc
msgid ""
"They have the same effect.\n"
"Thus, you can use both.\n"
"The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.\n"
"The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr "它们效果相同。因此，您可以随意使用。第一个提供了更精细的配置，比如worker pool以及是否保留顺序。第二种，同其他的Quarkus Reactive功能类似，使用默认的worker pool并且保留了顺序。"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Detailed information on the usage of `@Blocking` annotation can be found in https://smallrye.io/smallrye-reactive-messaging/latest/concepts/blocking/[SmallRye Reactive Messaging – Handling blocking execution]."
msgstr "关于 `@Blocking` 注解的详细信息，可以在 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging – 阻塞处理] 找到。"

#. type: Block title
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "@RunOnVirtualThread"
msgstr "@RunOnVirtualThread"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "For running the blocking processing on Java _virtual threads_, see the xref:messaging-virtual-threads.adoc[Quarkus Virtual Thread support with Reactive Messaging documentation]."
msgstr "关于在 Java 虚拟 _线程_ 上运行阻塞处理，请参阅 xref:messaging-virtual-threads.adoc[Quarkus 虚拟线程支持与反应式消息传递文档] 。"

#. type: Block title
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "@Transactional"
msgstr "@Transactional"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
msgid "If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`."
msgstr "如果你的方法被注释为 `@Transactional` ，它将被自动视为 _blocking_ ，即使该方法没有被注释为 `@Blocking` 。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Pulsar Subscription Types"
msgstr "Pulsar 订阅类型"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Pulsar *subscriptionType* consumer configuration can be used flexibly to achieve different messaging scenarios, such as publish-subscribe or queuing."
msgstr "Pulsar *subscriptionType* 消费者配置可灵活用于实现不同的消息传递场景，如发布-订阅或队列。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "*Exclusive* subscription type allows specifying a _unique subscription name_ for \"fan-out pub-sub messaging\". This is the default subscription type."
msgstr "*专属* 订阅类型允许为 \"扇出发布子消息 \"指定一个 _唯一的订阅名称_ 。这是默认订阅类型。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "*Shared*, *Key_Shared* or *Failover* subscription types allow multiple consumers to share the _same subscription name_, to achieve \"message queuing\" among consumers."
msgstr "*共享* 、 *密钥共享* 或 *故障转移* 订阅类型允许多个消费者共享 _相同的订阅名称_ ，以实现消费者之间的 \"消息队列\"。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "If a subscription name is not provided Quarkus generates a unique id."
msgstr "如果没有提供订阅名称，Quarkus 会生成一个唯一 ID。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Deserialization and Pulsar Schema"
msgstr "反序列化和 Pulsar 模式"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The Pulsar Connector allows configuring Schema configuration for the underlying Pulsar consumer.\n"
"See the <<pulsar-schema-configuration>> for more information."
msgstr "Pulsar 连接器允许为底层 Pulsar 消费者配置模式配置。更多信息请参见 <<pulsar-schema-configuration>> 。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Acknowledgement Strategies"
msgstr "鸣谢策略"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"When a message produced from a Pulsar Message is *acknowledged*, the connector sends an https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#acknowledgment[acknowledgement request] to the Pulsar broker.\n"
"All Reactive Messaging messages need to be *acknowledged*, which is handled automatically in most cases.\n"
"Acknowledgement requests can be sent to the Pulsar broker using the following two strategies:"
msgstr "当从 Pulsar 消息生成的消息被 *确认* 时，连接器会向 Pulsar 代理发送 link:https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#acknowledgment[确认请求] 。所有 Reactive Messaging 消息都需要 *确认* ，这在大多数情况下都是自动处理的。可以使用以下两种策略向 Pulsar 代理发送确认请求："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "**Individual acknowledgement** is the default strategy, an acknowledgement request is to the broker for each message."
msgstr "*单个确认* 是默认策略，每个报文都会向代理发出确认请求。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"**Cumulative acknowledgement**, configured using `ack-strategy=cumulative`, the consumer only acknowledges the last message it received.\n"
"All messages in the stream up to (and including) the provided message are not redelivered to that consumer."
msgstr "*累积确认* ，使用 `ack-strategy=cumulative` 配置，消费者只确认它收到的最后一条信息。信息流中直到（包括）所提供信息的所有信息都不会重新发送给该消费者。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"By default, the Pulsar consumer does not wait for the acknowledgement confirmation from the broker to validate an acknowledgement.\n"
"You can enable this using `ackReceiptEnabled=true`."
msgstr "默认情况下，Pulsar 消费者不会等待来自代理的确认确认来验证确认。您可以使用 `ackReceiptEnabled=true` 启用此功能。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Failure Handling Strategies"
msgstr "故障处理策略"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"If a message produced from a Pulsar message is *nacked*, a failure strategy is applied.\n"
"The Quarkus Pulsar extension supports 4 strategies:"
msgstr "如果从脉冲星报文生成的报文被 *拦截* ，则会应用失败策略。Quarkus Pulsar 扩展支持 4 种策略："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"`nack` *(default)* sends https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#negative-acknowledgment[negative acknowledgment] to the broker, triggering the broker to redeliver this message to the consumer.\n"
"The negative acknowledgment can be further configured using `negativeAckRedeliveryDelayMicros` and `negativeAck.redeliveryBackoff` properties."
msgstr "`nack` *(默认）* 向代理发送 link:https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#negative-acknowledgment[负确认] ，触发代理将此消息重新发送给消费者。负确认可通过 和 属性进一步配置。 `negativeAckRedeliveryDelayMicros` `negativeAck.redeliveryBackoff`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`fail` fail the application, no more messages will be processed."
msgstr "`fail` 则不会再处理任何信息。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`ignore` the failure is logged, but the acknowledgement strategy will be applied and the processing will continue."
msgstr "`ignore` 则会记录失败，但会应用确认策略并继续处理。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`continue` the failure is logged, but processing continues without applying acknowledgement or negative acknowledgement. This strategy can be used with <<ack-timeout>> configuration."
msgstr "`continue` 故障会被记录，但处理仍在继续，不会应用确认或否定确认。这种策略可与 配置一起使用。 <<ack-timeout>> "

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"`reconsume-later` sends the message to the https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#retry-letter-topic[retry letter topic] using the `reconsumeLater` API to be reconsumed with a delay.\n"
"The delay can be configured using the `reconsumeLater.delay` property and defaults to 3 seconds.\n"
"Custom delay or properties per message can be configured by adding an instance of `io.smallrye.reactive.messaging.pulsar.PulsarReconsumeLaterMetadata` to the failure metadata."
msgstr "`reconsume-later` 会使用 API 将消息发送到 `reconsumeLater` link:https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#retry-letter-topic[重试信件主题] ，并延迟重新接收。延迟可使用 属性进行配置，默认值为 3 秒。可通过在故障元数据中添加 实例来配置每条消息的自定义延迟或属性。 `reconsumeLater.delay` `io.smallrye.reactive.messaging.pulsar.PulsarReconsumeLaterMetadata`"

#. type: Title ====
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Acknowledgement timeout"
msgstr "确认超时"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Similar to the negative acknowledgement, with the https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#acknowledgment-timeout[acknowledgement timeout] mechanism, the Pulsar client tracks the unacknowledged messages,\n"
"for the given *ackTimeout* period and sends *redeliver unacknowledged messages request* to the broker, thus the broker resends the unacknowledged messages to the consumer."
msgstr "与负确认类似，在 link:https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#acknowledgment-timeout[确认超时] 机制下，Pulsar 客户端会在给定的 *ackTimeout* 时间段内跟踪未确认的报文，并向代理发送 *重新发送未确认报文的请求* ，从而由代理将未确认的报文重新发送给消费者。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"To configure the timeout and redelivery backoff mechanism you can set `ackTimeoutMillis` and `ackTimeout.redeliveryBackoff` properties.\n"
"The `ackTimeout.redeliveryBackoff` value accepts comma separated values of min delay in milliseconds, max delay in milliseconds and multiplier respectively:"
msgstr "要配置超时和重发回退机制，可以设置 `ackTimeoutMillis` 和 `ackTimeout.redeliveryBackoff` 属性。 `ackTimeout.redeliveryBackoff` 值接受以逗号分隔的最小延迟（毫秒）、最大延迟（毫秒）和乘数："

#. type: Title ====
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Reconsume later and retry letter topic"
msgstr "稍后恢复并重试信件主题"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#retry-letter-topic[retry letter topic] pushes messages that are not consumed successfully to a dead letter topic and continue message consumption.\n"
"Note that dead letter topic can be used in different message redelivery methods, such as acknowledgment timeout, negative acknowledgment or retry letter topic."
msgstr "link:https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#retry-letter-topic[重试信件主题] 会将未成功发送的信息推送到死信主题，并继续发送信息。请注意，死信主题可用于不同的信息再发送方法，如确认超时、负确认或重试信件主题。"

#. type: Title ====
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Dead-letter topic"
msgstr "死板的话题"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#dead-letter-topic[dead letter topic] pushes messages that are not consumed successfully to a dead letter topic an continue message consumption.\n"
"Note that dead letter topic can be used in different message redelivery methods, such as acknowledgment timeout, negative acknowledgment or retry letter topic."
msgstr "link:https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#dead-letter-topic[死信主题] 会将未成功接收的信息推送到死信主题，以继续接收信息。请注意，死信主题可用于不同的信息再发送方法，如确认超时、负确认或重试信件主题。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"*Negative acknowledgment* or *acknowledgment timeout* methods for redelivery will redeliver the whole batch of messages containing at least an unprocessed message.\n"
"See <<producer-batching>> for more information."
msgstr "*负确认* 或 *确认超时* 重发方法将重发至少包含一条未处理报文的整批报文。更多信息请参阅 <<producer-batching>> 。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Receiving Pulsar Messages in Batches"
msgstr "批量接收脉冲星信息"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"By default, incoming methods receive each Pulsar message individually.\n"
"You can enable batch mode using `batchReceive=true` property, or setting a `batchReceivePolicy` in consumer configuration."
msgstr "默认情况下，传入方法会单独接收每条 Pulsar 消息。您可以使用 `batchReceive=true` 属性或在消费者配置中设置 `batchReceivePolicy` 来启用批处理模式。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Or you can directly receive the list of payloads to the consume method:"
msgstr "或者，您也可以直接向消耗方法接收有效载荷列表："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Quarkus auto-detects batch types for incoming channels and sets batch configuration automatically.\n"
"You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batchReceive` property."
msgstr "Quarkus 会自动检测传入通道的批处理类型，并自动设置批处理配置。您可以使用 `mp.messaging.incoming.$channel.batchReceive` 属性显式配置批处理模式。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Sending messages to Pulsar"
msgstr "向 Pulsar 发送信息"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "The Pulsar Connector can write Reactive Messaging `Message`s as Pulsar Message."
msgstr "Pulsar 连接器可将反应式消息 \"信息 \"写成 Pulsar 消息。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Let’s imagine you have a Pulsar broker running, and accessible using the `pulsar:6650` address.\n"
"Configure your application to write the messages from the `prices` channel into a Pulsar Messages as follows:"
msgstr "假设你有一个正在运行的 Pulsar 代理，可以使用 `pulsar:6650` 地址访问。配置应用程序，将 `prices` 频道的消息写入 Pulsar 消息，如下所示："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"You don’t need to set the Pulsar topic, nor the producer name.\n"
"By default, the connector uses the channel name (`prices`).\n"
"You can configure the `topic` and `producerName` attributes to override them."
msgstr "您不需要设置 Pulsar 主题或制作者名称。默认情况下，连接器使用通道名称 ( `prices` )。您可以配置 `topic` 和 `producerName` 属性来覆盖它们。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Then, your application must send `Message<Double>` to the `prices`\n"
"channel. It can use `double` payloads as in the following snippet:"
msgstr "然后，您的应用程序必须向 `prices` 频道发送 `Message<Double>` 。它可以使用 `double` 有效载荷，如下所示："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Note that the generate method returns a `Multi<Double>`, which implements the `Flow.Publisher` interface.\n"
"This publisher will be used by the framework to generate messages and send them to the configured Pulsar topic."
msgstr "请注意，generate 方法会返回一个 `Multi<Double>` ，它实现了 `Flow.Publisher` 接口。框架将使用该发布者来生成消息并将其发送到已配置的 Pulsar 主题。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.pulsar.OutgoingMessage` to send Pulsar messages:"
msgstr "发送 Pulsar 消息时，可以不返回有效载荷，而是返回 `io.smallrye.reactive.messaging.pulsar.OutgoingMessage` ："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:"
msgstr "Payload可以被封装在 `org.eclipse.microprofile.reactive.messaging.Message`，以便对写入的记录有更多的控制："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"When sending `Messages`, you can add an instance of\n"
"`io.smallrye.reactive.messaging.pulsar.PulsarOutgoingMessageMetadata` to influence how the message is going to be written to Pulsar."
msgstr "发送 `Messages` 时，可以添加 `io.smallrye.reactive.messaging.pulsar.PulsarOutgoingMessageMetadata` 的实例，以影响信息写入 Pulsar 的方式。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Other than method signatures returning a `Flow.Publisher`, outgoing method can also return single message.\n"
"In this case the producer will use this method as generator to create an infinite stream."
msgstr "除了返回 `Flow.Publisher` 的方法签名外，传出方法也可以返回单条消息。在这种情况下，生产者将使用该方法作为生成器，创建一个无限流。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Serialization and Pulsar Schema"
msgstr "序列化和 Pulsar 模式"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The Pulsar Connector allows configuring Schema configuration for the underlying Pulsar producer.\n"
"See the <<pulsar-schema-configuration>> for more information."
msgstr "Pulsar Connector 允许为底层 Pulsar 生产者配置模式配置。更多信息请参阅 <<pulsar-schema-configuration>> 。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Sending key/value pairs"
msgstr "发送键/值对"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"In order to send Kev/Value pairs to Pulsar, you can configure the Pulsar producer Schema with a\n"
"https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/common/schema/KeyValue.html[KeyValue] schema."
msgstr "为了向 Pulsar 发送 Kev/Value 对，可以用 link:https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/common/schema/KeyValue.html[KeyValue] 模式配置 Pulsar 生产者模式。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "If you need more control on the written records, use `PulsarOutgoingMessageMetadata`."
msgstr "如果需要对书面记录进行更多控制，请使用 `PulsarOutgoingMessageMetadata` 。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Acknowledgement"
msgstr "消息确认"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Upon receiving a message from a Producer, a Pulsar broker assigns a `MessageId` to the message and sends it back to the producer,\n"
"confirming that the message is published."
msgstr "Pulsar 代理在收到来自生产者的信息后，会为信息分配一个 `MessageId` ，并将其发送回生产者，确认信息已发布。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"By default, the connector does wait for Pulsar to acknowledge the record\n"
"to continue the processing (acknowledging the received `Message`).\n"
"You can disable this by setting the `waitForWriteCompletion` attribute to `false`."
msgstr "默认情况下，连接器会等待 Pulsar 确认记录后再继续处理（确认收到的 `Message` ）。您可以通过将 `waitForWriteCompletion` 属性设置为 `false` 来禁用此功能。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "If a record cannot be written, the message is `nacked`."
msgstr "如果记录无法写入，则信息为 `nacked` 。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The Pulsar client automatically retries sending messages in case of failure, until the *send timeout* is reached.\n"
"The *send timeout* is configurable with `sendTimeoutMs` attribute and by default is 30 seconds."
msgstr "如果发送失败，Pulsar 客户端会自动重试发送信息，直到达到 *发送超时* 为止。 *发送超时* 可通过 `sendTimeoutMs` 属性配置，默认为 30 秒。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Back-pressure and inflight records"
msgstr "背压和飞行记录"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The Pulsar outbound connector handles back-pressure, monitoring the number of pending messages waiting to be written to the Pulsar broker.\n"
"The number of pending messages is configured using the `maxPendingMessages` attribute and defaults to 1000."
msgstr "Pulsar 出站连接器处理反向压力，监控等待写入 Pulsar 代理的待处理报文数量。待处理信息的数量通过 `maxPendingMessages` 属性进行配置，默认值为 1000。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The connector only sends that amount of messages concurrently.\n"
"No other messages will be sent until at least one pending message gets acknowledged by the broker.\n"
"Then, the connector writes a new message to Pulsar when one of the broker’s pending messages get acknowledged."
msgstr "连接器只能同时发送该数量的报文。在至少有一条待处理信息得到代理确认之前，不会发送其他信息。然后，当代理的一条待处理信息得到确认时，连接器就会向 Pulsar 写入一条新信息。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"You can also remove the limit of pending messages by setting `maxPendingMessages` to `0`.\n"
"Note that Pulsar also enables to configure the number of pending messages per partition using `maxPendingMessagesAcrossPartitions`."
msgstr "您也可以通过将 `maxPendingMessages` 设置为 `0` 来取消待处理邮件的限制。请注意，Pulsar 还可以使用 `maxPendingMessagesAcrossPartitions` 来配置每个分区的待处理邮件数量。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Producer Batching"
msgstr "生产商分批"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"By default, the Pulsar producer batches individual messages together to be published to the broker.\n"
"You can configure batching parameters using `batchingMaxPublishDelayMicros`, `batchingPartitionSwitchFrequencyByPublishDelay`,\n"
"`batchingMaxMessages`, `batchingMaxBytes` configuration properties, or disable it completely with `batchingEnabled=false`."
msgstr "默认情况下，Pulsar 生产者会将单个消息分批发布到代理。你可以使用 `batchingMaxPublishDelayMicros` , `batchingPartitionSwitchFrequencyByPublishDelay` , `batchingMaxMessages` , `batchingMaxBytes` 配置属性来配置批处理参数，或使用 `batchingEnabled=false` 完全禁用它。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "When using `Key_Shared` consumer subscriptions, the `batcherBuilder` can be configured to `BatcherBuilder.KEY_BASED`."
msgstr "使用 `Key_Shared` 消费者订阅时，可将 `batcherBuilder` 配置为 `BatcherBuilder.KEY_BASED` 。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Pulsar Transactions and Exactly-Once Processing"
msgstr "脉冲星交易和精确一次处理"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "https://pulsar.apache.org/docs/3.0.x/txn-why/[Pulsar transactions] enable event streaming applications to consume, process, and produce messages in one atomic operation."
msgstr "link:https://pulsar.apache.org/docs/3.0.x/txn-why/[Pulsar 事务] 可让事件流应用程序在一次原子操作中消费、处理和生成消息。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Transactions allow one or multiple producers to send batch of messages to multiple topics where all messages in the batch are eventually visible to any consumer, or none is ever visible to consumers."
msgstr "事务允许一个或多个生产者向多个主题发送批量信息，批量信息中的所有信息最终都会被任何消费者看到，或者消费者永远看不到任何信息。"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "In order to be used, transaction support needs to be activated on the broker configuration, using `transactionCoordinatorEnabled=true` and `systemTopicEnabled=true` broker configuration."
msgstr "要使用该功能，需要在代理配置上激活事务支持，使用 `transactionCoordinatorEnabled=true` 和 `systemTopicEnabled=true` 代理配置。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "On the client side, the transaction support also needs to be enabled on `PulsarClient` configuration:"
msgstr "在客户端，还需要在 `PulsarClient` 配置中启用事务支持："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Pulsar connector provides `PulsarTransactions` custom emitter for writing records inside a transaction."
msgstr "Pulsar 连接器提供 `PulsarTransactions` 自定义发射器，用于在事务中写入记录。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "It can be used as a regular emitter `@Channel`:"
msgstr "它可用作普通发射器 `@Channel` ："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The function given to the `withTransaction` method receives a `TransactionalEmitter` for producing records, and returns a `Uni` that provides the result of the transaction.\n"
"If the processing completes successfully, the producer is flushed and the transaction is committed.\n"
"If the processing throws an exception, returns a failing `Uni`, or marks the `TransactionalEmitter` for abort, the transaction is aborted."
msgstr "`withTransaction` 方法的函数接收用于生成记录的 `TransactionalEmitter` ，并返回提供事务结果的 `Uni` 。如果处理成功完成，生产者被刷新，事务被提交。如果处理抛出异常，返回失败的 `Uni` ，或标记 `TransactionalEmitter` 中止，则事务被中止。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Multiple transactional producers can participate in a single transaction.\n"
"This ensures all messages are sent using the started transaction and before the transaction is committed, all participating producers are flushed."
msgstr "多个事务生产者可以参与一个事务。这样可以确保所有信息都使用启动的事务发送，并且在事务提交之前，所有参与的生产者都会被刷新。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"If this method is called on a Vert.x context, the processing function is also called on that context.\n"
"Otherwise, it is called on the sending thread of the producer."
msgstr "如果该方法在 Vert.x 上下文中调用，则处理函数也会在该上下文中调用。否则，将在生产者的发送线程上调用。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Exactly-Once Processing"
msgstr "（Exactly-Once Processing）精确一次处理"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Pulsar Transactions API also allows managing consumer offsets inside a transaction, together with produced messages.\n"
"This in turn enables coupling a consumer with a transactional producer in a consume-transform-produce pattern,\n"
"also known as exactly-once processing.\n"
"It means that an application consumes messages, processes them, publishes the results to a topic, and commits offsets of the consumed messages in a transaction."
msgstr "Pulsar 事务应用程序接口还允许在事务中管理消费者偏移量以及生成的消息。这反过来又可以将消费者与事务生产者以消费-转换-生产模式（也称为一次处理）结合起来。这意味着应用程序消耗消息、处理消息、将结果发布到主题，并在事务中提交消耗消息的偏移量。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "The `PulsarTransactions` emitter also provides a way to apply exactly-once processing to an incoming Pulsar message inside a transaction."
msgstr "`PulsarTransactions` 发射器还提供了一种在事务中对传入的 Pulsar 消息进行精确一次性处理的方法。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "The following example includes a batch of Pulsar messages inside a transaction."
msgstr "下面的示例在事务中包含了一批 Pulsar 报文。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "If the processing completes successfully, the message is acknowledged inside the transaction and the transaction is committed."
msgstr "如果处理成功完成，消息就会在事务中得到确认，事务也会提交。"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "When using exactly-once processing, messages can only be acked individually rather than cumulatively."
msgstr "在使用精确一次处理时，报文只能被单独接收，而不能被累计接收。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"If the processing needs to abort, the message is nack'ed. One of the failure strategies can be employed in order to retry the processing or simply fail-stop.\n"
"Note that the `Uni` returned from the `withTransaction` will yield a failure if the transaction fails and is aborted."
msgstr "如果处理过程需要中止，则消息会被删除。可以使用其中一种失败策略来重试处理或直接停止。请注意，如果事务失败并中止，从 `withTransaction` 返回的 `Uni` 将产生一个失败结果。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The application can choose to handle the error case, but for the message consumption to continue, `Uni` returned from the `@Incoming` method must not result in failure.\n"
"`PulsarTransactions#withTransactionAndAck` method will ack and nack the message but will not stop the reactive stream.\n"
"Ignoring the failure simply resets the consumer to the last committed offsets and resumes the processing from there."
msgstr "应用程序可以选择处理错误情况，但要继续消耗信息， `@Incoming` 方法返回的 `Uni` 必须不会导致失败。 `PulsarTransactions#withTransactionAndAck` 方法将接受和拦截信息，但不会停止反应流。忽略故障只会将消费者重置为上次提交的偏移量，并从那里开始恢复处理。"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "In order to avoid duplicates in case of failure, it is recommended to enable message deduplication and batch index level acknowledgment on the broker side:"
msgstr "为了避免在故障情况下出现重复，建议在代理侧启用报文重复数据删除和批索引级确认："

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Pulsar Schema Configuration & Auto Schema Discovery"
msgstr "Pulsar 模式配置和自动模式发现"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Pulsar messages are stored with payloads as unstructured byte array.\n"
"A Pulsar **schema** defines how to serialize structured data to the raw message bytes.\n"
"The **schema** is applied in producers and consumers to write and read with an enforced data structure.\n"
"It serializes data into raw bytes before they are published to a topic and deserializes the raw bytes before they are delivered to consumers."
msgstr "Pulsar 报文与有效载荷一起以非结构化字节数组的形式存储。Pulsar *模式定义* 了如何将结构化数据序列化为原始信息字节。该 *模式* 适用于生产者和消费者，以强制数据结构进行写入和读取。在将数据发布到主题之前，它将数据序列化为原始字节，并在将原始字节交付给消费者之前将其反序列化。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Pulsar uses a schema registry as a central repository to store the registered schema information,\n"
"which enables producers/consumers to coordinate the schema of a topic's messages through brokers.\n"
"By default the Apache BookKeeper is used to store schemas."
msgstr "Pulsar 使用模式注册中心作为中央存储库，以存储已注册的模式信息，从而使生产者/消费者能够通过经纪人协调主题消息的模式。默认情况下，使用 Apache BookKeeper 来存储模式。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Pulsar API provides built-in schema information for a number of\n"
"https://pulsar.apache.org/docs/3.0.x/schema-understand#primitive-type[primitive types]\n"
"and https://pulsar.apache.org/docs/3.0.x/schema-understand#complex-type[complex types] such as Key/Value, Avro and Protobuf."
msgstr "Pulsar API 为许多 link:https://pulsar.apache.org/docs/3.0.x/schema-understand#primitive-type[原始类型] 和 link:https://pulsar.apache.org/docs/3.0.x/schema-understand#complex-type[复杂类型] （如 Key/Value、Avro 和 Protobuf）提供内置模式信息。"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "The Pulsar Connector allows specifying the schema as a primitive type using the `schema` property:"
msgstr "Pulsar Connector 允许使用 `schema` 属性将模式指定为原始类型："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"If the value for the `schema` property matches a https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/common/schema/SchemaType.html[Schema Type]\n"
"a simple schema will be created with that type and will be used for that channel."
msgstr "如果 `schema` 属性的值与 link:https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/common/schema/SchemaType.html[模式类型] 相匹配，则将创建该类型的简单模式，并用于该频道。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "The Pulsar Connector allows configuring complex schema types by providing `Schema` beans through CDI, identified with the `@Identifier` qualifier."
msgstr "Pulsar 连接器可通过 CDI 提供 `Schema` beans（用 `@Identifier` 限定符标识），从而配置复杂的模式类型。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "For example the following bean provides an JSON schema and a Key/Value schema:"
msgstr "例如，下面的 Bean 提供了一个 JSON 模式和一个键/值模式："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "To configure the incoming channel `users` with defined schema, you need to set the `schema` property to the identifier of the schema `user-schema`:"
msgstr "要使用已定义的模式配置传入通道 `users` ，需要将 `schema` 属性设置为 `user-schema` 模式的标识符："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"If no `schema` property is found, the connector looks for `Schema` beans identified with the channel name.\n"
"For example, the outgoing channel `a-channel` will use the key/value schema."
msgstr "如果找不到 `schema` 属性，连接器就会查找与通道名称一致的 `Schema` 豆。例如，传出通道 `a-channel` 将使用键/值模式。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "If no schema information is provided incoming channels will use `Schema.AUTO_CONSUME()`, whereas outgoing channels will use `Schema.AUTO_PRODUCE_BYTES()` schemas."
msgstr "如果没有提供模式信息，传入通道将使用 `Schema.AUTO_CONSUME()` ，而传出通道将使用 `Schema.AUTO_PRODUCE_BYTES()` 模式。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Auto Schema Discovery"
msgstr "自动模式发现"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"When using Quarkus Messaging Pulsar (`io.quarkus:quarkus-messaging-pulsar`), Quarkus can often automatically detect the correct Pulsar Schema to configure.\n"
"This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s."
msgstr "在使用 Quarkus Messaging Pulsar ( `io.quarkus:quarkus-messaging-pulsar` ) 时，Quarkus 通常可以自动检测要配置的正确 Pulsar 模式。这种自动检测基于 `@Incoming` 和 `@Outgoing` 方法的声明以及注入的 `@Channel` s。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "For example, if you declare"
msgstr "例如，如果您声明"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "and your configuration indicates that the `generated-price` channel uses the `smallrye-pulsar` connector, then Quarkus will automatically set the `schema` attribute of the  `generated-price` channel to Pulsar Schema `INT32`."
msgstr "如果您的配置显示 `generated-price` 通道使用 `smallrye-pulsar` 连接器，那么 Quarkus 将自动把 `generated-price` 通道的 `schema` 属性设置为 Pulsar Schema `INT32` 。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "Similarly, if you declare"
msgstr "同样地，如果您声明"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "and your configuration indicates that the `my-pulsar-consumer` channel uses the `smallrye-pulsar` connector, then Quarkus will automatically set the `schema` attribute to Pulsar `BYTES` Schema."
msgstr "如果您的配置显示 `my-pulsar-consumer` 通道使用 `smallrye-pulsar` 连接器，那么 Quarkus 将自动把 `schema` 属性设置为 Pulsar `BYTES` 模式。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "Finally, if you declare"
msgstr "最后，如果您声明"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "and your configuration indicates that the `price-create` channel uses the `smallrye-pulsar` connector, then Quarkus will automatically set the `schema` to Pulsar `INT64` Schema."
msgstr "如果您的配置显示 `price-create` 通道使用 `smallrye-pulsar` 连接器，则 Quarkus 会自动将 `schema` 设置为 Pulsar `INT64` 模式。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "The full set of types supported by the Pulsar Schema autodetection is:"
msgstr "Pulsar 模式自动检测支持的全部类型包括"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "`short` and `java.lang.Short`"
msgstr "`short` 和 `java.lang.Short`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "`int` and `java.lang.Integer`"
msgstr "`int` 和 `java.lang.Integer`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "`long` and `java.lang.Long`"
msgstr "`long` 和 `java.lang.Long`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "`float` and `java.lang.Float`"
msgstr "`float` 和 `java.lang.Float`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "`double` and `java.lang.Double`"
msgstr "`double` 和 `java.lang.Double`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "`byte[]`"
msgstr "`byte[]` "

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`java.time.Instant`"
msgstr "`java.time.Instant`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`java.sql.Timestamp`"
msgstr "`java.sql.Timestamp`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`java.time.LocalDate`"
msgstr "`java.time.LocalDate`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`java.time.LocalTime`"
msgstr "`java.time.LocalTime`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`java.time.LocalDateTime`"
msgstr "`java.time.LocalDateTime`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "`java.nio.ByteBuffer`"
msgstr "`java.nio.ByteBuffer`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "classes generated from Avro schemas, as well as Avro `GenericRecord`, will be configured with `AVRO` schema type"
msgstr "从 Avro 模式生成的类以及 Avro `GenericRecord` ，将配置为 `AVRO` 模式类型"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "classes generated from Protobuf schemas, will be configured with `PROTOBUF` schema type"
msgstr "从 Protobuf 模式生成的类将配置为 `PROTOBUF` 模式类型"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "other classes will automatically be configured with `JSON` schema type"
msgstr "其他类将自动配置为 `JSON` 模式类型"

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Note that `JSON` schema type enforces schema validation."
msgstr "请注意， `JSON` 模式类型可执行模式验证。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "In addition to those Pulsar-provided schemas, Quarkus provides following schema implementations _without enforcing validation_ :"
msgstr "除 Pulsar 提供的模式外，Quarkus 还提供以下模式实现，但 _不强制执行验证_ ："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`io.vertx.core.buffer.Buffer` will be configured with `io.quarkus.pulsar.schema.BufferSchema` schema"
msgstr "`io.vertx.core.buffer.Buffer` 将配置 模式 `io.quarkus.pulsar.schema.BufferSchema` "

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`io.vertx.core.json.JsonObject` will be configured with `io.quarkus.pulsar.schema.JsonObjectSchema` schema"
msgstr "`io.vertx.core.json.JsonObject` 将配置 模式 `io.quarkus.pulsar.schema.JsonObjectSchema` "

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`io.vertx.core.json.JsonArray` will be configured with `io.quarkus.pulsar.schema.JsonArraySchema` schema"
msgstr "`io.vertx.core.json.JsonArray` 将配置 模式 `io.quarkus.pulsar.schema.JsonArraySchema` "

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"For schema-less Json serialization, if the `schema` configuration is set to `ObjectMapper<fully_qualified_name_of_the_bean>`,\n"
"a Schema will be generated using the Jackson `ObjectMapper`, without enforcing a Pulsar Schema validation.\n"
"`io.quarkus.pulsar.schema.ObjectMapperSchema` can be used to explicitly configure JSON schema without validation."
msgstr "对于无模式的 Json 序列化，如果 `schema` 配置设置为 `ObjectMapper<fully_qualified_name_of_the_bean>` ，则将使用 Jackson `ObjectMapper` 生成模式，而不会强制执行 Pulsar 模式验证。 `io.quarkus.pulsar.schema.ObjectMapperSchema` 可用于显式配置无验证的 JSON 模式。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "If a `schema` is set by configuration, it won't be replaced by the auto-detection."
msgstr "如果 `schema` 是通过配置设置的，则不会被自动检测所取代。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"In case you have any issues with serializer auto-detection, you can switch it off completely by setting `quarkus.messaging.pulsar.serializer-autodetection.enabled=false`.\n"
"If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have."
msgstr "如果你在序列化器自动检测方面遇到任何问题，可以通过设置 `quarkus.messaging.pulsar.serializer-autodetection.enabled=false` 将其完全关闭。如果你发现需要这样做，请在 link:https://github.com/quarkusio/quarkus/issues[Quarkus 问题跟踪器] 中提交一个 bug，这样我们就能解决你遇到的任何问题。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Configuring Pulsar clients"
msgstr "配置 Pulsar 客户端"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Pulsar clients, consumers and producers are very customizable to configure how a Pulsar client application behaves."
msgstr "Pulsar 客户端、消费者和生产者均可进行自定义，以配置 Pulsar 客户端应用程序的行为方式。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The Pulsar connector creates a Pulsar client and, a consumer or a producer per channel, each with sensible defaults to ease their configuration.\n"
"Although the creation is handled, all available configuration options remain configurable through Pulsar channels."
msgstr "Pulsar 连接器为每个通道创建一个 Pulsar 客户端、一个消费者或一个生产者，每个通道都有合理的默认值，以方便配置。虽然创建工作已经完成，但所有可用的配置选项仍可通过 Pulsar 通道进行配置。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"While idiomatic way of creating `PulsarClient`, `PulsarConsumer` or `PulsarProducer` are through builder APIs, in its essence\n"
"those APIs build each time a configuration object, to pass onto the implementation.\n"
"Those are https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ClientConfigurationData.html[ClientConfigurationData],\n"
"https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ConsumerConfigurationData.html[ConsumerConfigurationData]\n"
"and https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ProducerConfigurationData.html[ProducerConfigurationData]."
msgstr "虽然创建 `PulsarClient` 、 `PulsarConsumer` 或 `PulsarProducer` 的惯用方式是通过构建程序接口（Builder API），但从本质上讲，这些 API 每次都会构建一个配置对象，并将其传递给实现。它们是 link:https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ClientConfigurationData.html[ClientConfigurationData] 、 link:https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ConsumerConfigurationData.html[ConsumerConfigurationData] 和 link:https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ProducerConfigurationData.html[ProducerConfigurationData] 。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Pulsar Connector allows receiving properties for those configuration objects directly.\n"
"For example, the broker authentication information for `PulsarClient` is received using `authPluginClassName` and `authParams` properties.\n"
"In order to configure the authentication for the incoming channel `data` :"
msgstr "Pulsar Connector 允许直接接收这些配置对象的属性。例如，可通过 `authPluginClassName` 和 `authParams` 属性接收 `PulsarClient` 的代理身份验证信息。为了配置传入通道的身份验证， `data` ："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Note that the Pulsar consumer property `subscriptionInitialPosition` is also configured with the `Earliest` value which represents with enum value `SubscriptionInitialPosition.Earliest`."
msgstr "请注意，Pulsar 消费者属性 `subscriptionInitialPosition` 也配置了 `Earliest` 值，该值用枚举值 `SubscriptionInitialPosition.Earliest` 表示。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"This approach covers most of the configuration cases.\n"
"However, non-serializable objects such as `CryptoKeyReader`, `ServiceUrlProvider` etc. cannot be configured this way.\n"
"The Pulsar Connector allows taking into account instances of Pulsar configuration data objects –\n"
"`ClientConfigurationData`, `ConsumerConfigurationData`, `ProducerConfigurationData`:"
msgstr "这种方法涵盖了大多数配置情况。但是，不可序列化的对象，如 `CryptoKeyReader` , `ServiceUrlProvider` 等，则不能用这种方法配置。Pulsar 连接器允许考虑 Pulsar 配置数据对象的实例 - `ClientConfigurationData` , `ConsumerConfigurationData` , `ProducerConfigurationData` ："

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"This instance is retrieved and used to configure the client used by the connector.\n"
"You need to indicate the name of the client using the `client-configuration`, `consumer-configuration` or `producer-configuration` attributes:"
msgstr "该实例将被检索并用于配置连接器使用的客户端。您需要使用 `client-configuration` 、 `consumer-configuration` 或 `producer-configuration` 属性指明客户端的名称："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "If no `[client|consumer|producer]-configuration` is configured, the connector will look for instances identified with the channel name:"
msgstr "如果未配置 `[client|consumer|producer]-configuration` ，连接器将查找以通道名称标识的实例："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "You also can provide a `Map<String, Object>` containing configuration values by key:"
msgstr "您还可以提供一个 `Map<String, Object>` ，其中按键包含配置值："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Different configuration sources are loaded in the following order of precedence, from the least important to the highest:"
msgstr "不同配置源的加载顺序如下，从最不重要到最重要："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`Map<String, Object>` config map produced with default config identifier, `default-pulsar-client`, `default-pulsar-consumer`, `default-pulsar-producer`."
msgstr "`Map<String, Object>` 使用默认配置标识符生成的配置映射， , , 。 `default-pulsar-client` `default-pulsar-consumer` `default-pulsar-producer`"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`Map<String, Object>` config map produced with identifier in the configuration or channel name"
msgstr "`Map<String, Object>` 使用配置或通道名称中的标识符生成的配置映射"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "`[Client|Producer|Consuemr]ConfigurationData` object produced with identifier in the channel configuration or the channel name"
msgstr "`[Client|Producer|Consuemr]ConfigurationData` 对象，该对象是根据频道配置中的标识符或频道名称生成的"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Channel configuration properties named with `[Client|Producer|Consuemr]ConfigurationData` field names."
msgstr "以 `[Client|Producer|Consuemr]ConfigurationData` 字段名命名的通道配置属性。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "See <<configuration-reference>> for the exhaustive list of configuration options."
msgstr "有关配置选项的详尽列表，请参见 <<configuration-reference>> 。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Configuring Pulsar Authentication"
msgstr "配置 Pulsar 验证"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Pulsar provides a pluggable authentication framework, and Pulsar brokers/proxies use this mechanism to authenticate clients."
msgstr "Pulsar 提供了一个可插拔的身份验证框架，Pulsar 中间商/代理使用该机制对客户端进行身份验证。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Clients can be configured in `application.properties` file using `authPluginClassName` and `authParams` attributes:"
msgstr "客户端可在 `application.properties` 文件中使用 `authPluginClassName` 和 `authParams` 属性进行配置："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Or programmatically:"
msgstr "或编程："

#: _versions/main/guides/pulsar.adoc
msgid "Configuring authentication to Pulsar using mTLS"
msgstr ""

#: _versions/main/guides/pulsar.adoc
msgid "Pulsar Messaging extension integrates with the xref:./tls-registry-reference.adoc[Quarkus TLS registry] to authenticate clients using mTLS."
msgstr ""

#: _versions/main/guides/pulsar.adoc
msgid "To configure the mTLS for a Pulsar channel, you need to provide a named TLS configuration in the `application.properties`:"
msgstr ""

#. type: Title ====
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Configuring access to Datastax Luna Streaming"
msgstr "配置对 Datastax Luna Streaming 的访问"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Luna Streaming is a production-ready distribution of Apache Pulsar, with tools and support from DataStax.\n"
"After creating your DataStax Luna Pulsar tenant, note the auto generated token, and configure the token authentication:"
msgstr "Luna Streaming 是 Apache Pulsar 的生产就绪发行版，由 DataStax 提供工具和支持。创建 DataStax Luna Pulsar 租户后，请注意自动生成的令牌，并配置令牌身份验证："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Make sure to create topics beforehand, or enable the _Auto Topic Creation_ in the namespace configuration."
msgstr "确保事先创建主题，或在命名空间配置中启用 _自动创建主题_ 功能。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Note that the topic configuration needs to reference full name of topics:"
msgstr "请注意，主题配置需要引用主题的全名："

#. type: Title ====
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Configuring access to StreamNative Cloud"
msgstr "配置对 StreamNative 云的访问"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"StreamNative Cloud is a fully managed Pulsar-as-a-Service available in different deployment options,\n"
"whether it is fully-hosted, on a public cloud but managed by StreamNative or self-managed on Kubernetes."
msgstr "StreamNative Cloud 是一种完全托管的 Pulsar 即服务，有不同的部署选项，可以是完全托管的，也可以是由 StreamNative 管理的公共云上的，还可以是 Kubernetes 上的自我管理。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The StreamNative Pulsar clusters use Oauth2 authentication,\n"
"so you need to make sure that a https://docs.streamnative.io/docs/service-account[service account] exists with\n"
"required https://docs.streamnative.io/docs/access-control#authorize-namespaces[permissions to the Pulsar namespace/topic] your application is using."
msgstr "StreamNative Pulsar 集群使用 Oauth2 身份验证，因此需要确保存在一个 link:https://docs.streamnative.io/docs/service-account[服务账户，且该账户] link:https://docs.streamnative.io/docs/access-control#authorize-namespaces[对] 应用程序正在使用的 link:https://docs.streamnative.io/docs/access-control#authorize-namespaces[Pulsar 命名空间/主题] 具有所需的 link:https://docs.streamnative.io/docs/access-control#authorize-namespaces[权限] 。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Next, you need to download the **Key file** (which serves as **private key**) of the service account and note the **issuer URL** (typically `https://auth.streamnative.cloud/`)\n"
"and the **audience** (for example `urn:sn:pulsar:o-rf3ol:redhat`) for your cluster.\n"
"The **Pulsar Clients** page in the **Admin** section in the StreamNative Cloud console helps you with this process."
msgstr "接下来，您需要下载服务账户的 *密钥文件* （作为 *私钥* ），并记下 *发行者 URL* （通常为 `https://auth.streamnative.cloud/` ）和群集的 *受众* （例如 `urn:sn:pulsar:o-rf3ol:redhat` ）。StreamNative云控制台 *管理* 部分的 *Pulsar客户端* 页面可以帮助你完成这一过程。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "To configure your application with Pulsar Oauth2 authentication:"
msgstr "使用 Pulsar Oauth2 身份验证配置应用程序："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Note that the `pulsar.client.authParams` configuration contains a Json string with `issuerUrl`, `audience` and the `privateKey` in the `data:application/json;base64,<base64-encoded-key-file>` format."
msgstr "请注意， `pulsar.client.authParams` 配置包含一个 Json 字符串，其中有 `issuerUrl` 、 `audience` 和 `data:application/json;base64,<base64-encoded-key-file>` 格式的 `privateKey` 。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Alternatively you can configure the authentication programmatically:"
msgstr "您也可以通过编程配置身份验证："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "This assumes that the key file is included to the application classpath as a resource, then the configuration would like the following:"
msgstr "假设密钥文件作为资源包含在应用程序的 classpath 中，那么配置如下："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Note that channels using the client configuration identified with `pulsar-auth` need to set the `client-configuration` attribute."
msgstr "请注意，使用 `pulsar-auth` 标识的客户端配置的通道需要设置 `client-configuration` 属性。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Health Checks"
msgstr "健康检查"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The Quarkus extension reports startup, readiness and liveness of each channel managed by the Pulsar connector.\n"
"Health checks rely on the Pulsar client to verify that a connection is established with the broker."
msgstr "Quarkus 扩展报告 Pulsar 连接器管理的每个通道的启动、就绪和有效性。健康检查依靠 Pulsar 客户端来验证是否与代理建立了连接。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"**Startup** and **Readiness** probes for both inbound and outbound channels report *OK* when the\n"
"connection with the broker is established."
msgstr "当与代理建立连接时，入站和出站通道的 *启动* 和 *就绪* 探测器都会报告 \" *OK* \"。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"The **Liveness** probe for both inbound and outbound channels reports *OK*  when the\n"
"connection is established with the broker **AND** that no failures have been caught."
msgstr "当与代理建立连接时，入站和出站通道的 \" *有效性* \"探针都会报告 \" *OK* \"， *并且* 没有捕捉到故障。"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Note that a message processing failures *nacks* the message which is\n"
"then handled by the failure-strategy. It is the responsibility of the\n"
"failure-strategy to report the failure and influence the outcome of the\n"
"liveness checks. The `fail` failure strategy reports the failure and so\n"
"the liveness check will report the failure."
msgstr "请注意，报文处理失败后，报文会 *被* \"失败策略\"（failure-strategy）处理。故障策略有责任报告故障并影响有效性检查的结果。 `fail` 故障策略会报告故障，因此有效性检查也会报告故障。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Configuration Reference"
msgstr "配置参考"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Following are the list of configuration attributes for the Pulsar connector channels, consumers, producers and clients.\n"
"See the <<pulsar-client-configuration>> for more information on how the Pulsar clients are configured."
msgstr "以下是 Pulsar 连接器通道、消费者、生产者和客户端的配置属性列表。有关如何配置 Pulsar 客户端的更多信息，请参阅 <<pulsar-client-configuration>> 。"

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Incoming channel configuration (receiving from Pulsar)"
msgstr "接收通道配置（从 Pulsar 接收）"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "The following attributes are configured using:"
msgstr "以下属性通过该方式进行配置："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "You can also configure properties supported by the underlying Pulsar consumer."
msgstr "您还可以配置底层 Pulsar 消费者支持的属性。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "These properties can also be globally configured using `pulsar.consumer` prefix:"
msgstr "这些属性也可以使用 `pulsar.consumer` 前缀进行全局配置："

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Outgoing channel configuration (publishing to Pulsar)"
msgstr "传出通道配置（发布到 Pulsar）"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "You can also configure properties supported by the underlying Pulsar producer."
msgstr "您还可以配置底层 Pulsar 生产者支持的属性。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "These properties can also be globally configured using `pulsar.producer` prefix:"
msgstr "这些属性也可以使用 `pulsar.producer` 前缀进行全局配置："

#. type: Title ===
#: _versions/main/guides/pulsar.adoc
#, fuzzy, no-wrap
msgid "Pulsar Client Configuration"
msgstr "Pulsar 客户端配置"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"Following is the configuration reference for the underlying `PulsarClient`.\n"
"These options can be configured using the channel attribute:"
msgstr "以下是底层 `PulsarClient` 的配置参考。这些选项可使用通道属性进行配置："

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Or configured globally using `pulsar.client` prefix:"
msgstr "或使用 `pulsar.client` 前缀进行全局配置："

#. type: delimited block =
#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid "Configuration properties not configurable in configuration files (non-serializable) is noted in the column `Config file`."
msgstr "配置文件中不可配置的配置属性（不可序列化）在 `Config file` 一栏中注明。"

#. type: Title ==
#: _versions/main/guides/pulsar.adoc
#, no-wrap
msgid "Going further"
msgstr "进一步探索"

#: _versions/main/guides/pulsar.adoc
#, fuzzy
msgid ""
"This guide has shown how you can interact with Pulsar using Quarkus.\n"
"It utilizes Quarkus Messaging to build data streaming applications."
msgstr "本指南介绍了如何使用 Quarkus 与 Pulsar 进行交互。它利用 Quarkus 消息传递来构建数据流应用程序。"

#. type: Plain text
#: _versions/main/guides/pulsar.adoc
msgid "If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "如果您想更进一步，请参看link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging]，在Quarkus中使用的实现。"
