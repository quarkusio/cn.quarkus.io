# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-08-28 16:20+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "RESTEasy Classic"
msgstr "RESTEasy Classic"

#. type: delimited block =
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"This guide is about https://resteasy.dev[RESTEasy Classic] which used to be "
"the default Jakarta REST (formerly known as JAX-RS) implementation until "
"Quarkus 2.8."
msgstr ""
"在 Quarkus 2.8 之前， link:https://resteasy.dev[RESTEasy Classic] 一直是 Jakarta "
"REST（以前称为 JAX-RS）的默认实现。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"It is now recommended to use RESTEasy Reactive, which supports both "
"traditional blocking workloads and reactive workloads equally well.\n"
"For more information about RESTEasy Reactive,\n"
"please see the xref:rest-json.adoc[introductory REST JSON guide] or the xref:"
"resteasy-reactive.adoc[RESTEasy Reactive reference documentation]."
msgstr ""
"现在建议使用 RESTEasy Reactive，它同样支持传统的阻塞工作负载和反应工作负载。有关 RESTEasy Reactive "
"的更多信息，请参阅 xref:rest-json.adoc[REST JSON 入门指南] 或 xref:resteasy-reactive."
"adoc[RESTEasy Reactive 参考文档] 。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"there is another guide if you need a xref:rest-client.adoc[REST client based "
"on RESTEasy Classic] (including support for JSON)."
msgstr ""
"如果您需要 xref:rest-client.adoc[基于 RESTEasy Classic 的 REST 客户端] （包括对 JSON "
"的支持），还有另一份指南。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Architecture"
msgstr "架构"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"The application built in this guide is quite simple: the user can add "
"elements in a list using a form and the list is updated."
msgstr "本指南中构建的应用程序非常简单：用户可以使用一个表单在列表中添加元素并更新列表。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"All the information between the browser and the server are formatted as JSON."
""
msgstr "浏览器和服务器之间的所有信息都被格式化为JSON。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Creating the Maven project"
msgstr "创建Maven项目"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"First, we need a new project. Create a new project with the following "
"command:"
msgstr "首先，我们需要一个新的项目。使用以下命令创建一个新的项目:"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"This command generates a new project importing the RESTEasy/Jakarta REST and "
"https://github.com/FasterXML/jackson[Jackson] extensions,\n"
"and in particular adds the following dependency:"
msgstr ""
"该命令将生成一个导入 RESTEasy/Jakarta REST 和 link:https://github.com/FasterXML/"
"jackson[Jackson] 扩展的新项目，并特别添加以下依赖关系："

#. type: Block title
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Block title
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block =
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"To improve user experience, Quarkus registers the three Jackson https://"
"github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you don't need "
"to do it manually."
msgstr ""
"为了提高用户体验，Quarkus注册了三个Jackson link:https://github.com/FasterXML/jackson-"
"modules-java8[Java 8模块] ，所以你不需要手动操作。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Quarkus also supports https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] so, "
"if you prefer JSON-B over Jackson, you can create a project relying on the "
"RESTEasy JSON-B extension instead:"
msgstr ""
"Quarkus 还支持 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] "
"，因此，如果你更喜欢 JSON-B，而不是 Jackson，你可以创建一个依赖于 RESTEasy JSON-B 扩展的项目："

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"This command generates a new project importing the RESTEasy/Jakarta REST and "
"https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] extensions,\n"
"and in particular adds the following dependency:"
msgstr ""
"该命令将生成一个导入 RESTEasy/Jakarta REST 和 link:https://eclipse-ee4j.github.io/jsonb-"
"api/[JSON-B] 扩展的新项目，并特别添加以下依赖关系："

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Creating your first JSON REST service"
msgstr "创建你的第一个JSON REST服务"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"In this example, we will create an application to manage a list of fruits."
msgstr "在这个例子中，我们将创建一个应用程序来管理fruit列表。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "First, let's create the `Fruit` bean as follows:"
msgstr "首先，让我们创建 `Fruit` 实体类，如下所示："

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Nothing fancy. One important thing to note is that having a default "
"constructor is required by the JSON serialization layer."
msgstr "这非常的简单。需要注意的一件事是， JSON 序列化层需要具有默认构造函数。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "Now, create the `org.acme.rest.json.FruitResource` class as follows:"
msgstr "现在，创建 `org.acme.rest.json.FruitResource` 类，如下所示。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"The implementation is pretty straightforward, and you just need to define "
"your endpoints using the Jakarta REST annotations."
msgstr "实现起来相当简单，你只需要使用JAX-RS注解来定义你的节点。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"The `Fruit` objects will be automatically serialized/deserialized by https://"
"eclipse-ee4j.github.io/jsonb-api/[JSON-B] or https://github.com/FasterXML/"
"jackson[Jackson],\n"
"depending on the extension you chose when initializing the project."
msgstr ""
"`Fruit` 对象将被 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] 或 link:"
"https://github.com/FasterXML/jackson[Jackson] 自动序列化/反序列化，这取决于你在初始化项目时选择的扩展。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"When a JSON extension is installed such as `quarkus-resteasy-jackson` or "
"`quarkus-resteasy-jsonb`, Quarkus will use the `application/json` media type\n"
"by default for most return values, unless the media type is explicitly set "
"via\n"
"`@Produces` or `@Consumes` annotations (there are some exceptions for well "
"known types, such as `String` and `File`, which default to `text/plain` and "
"`application/octet-stream`\n"
"respectively)."
msgstr ""
"当安装了 JSON 扩展（如 `quarkus-resteasy-jackson` 或 `quarkus-resteasy-jsonb` "
"）时，Quarkus 将对大多数返回值默认使用 `application/json` 媒体类型，除非通过 `@Produces` 或 "
"`@Consumes` 注释明确设置了媒体类型（众所周知的类型有一些例外，如 `String` 和 `File` ，它们分别默认使用 `text/"
"plain` 和 `application/octet-stream` ）。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"If you don't want JSON by default you can set `quarkus.resteasy-json.default-"
"json=false` and the default will change back to being auto-negotiated. If "
"you set this\n"
"you will need to add `@Produces(MediaType.APPLICATION_JSON)` and "
"`@Consumes(MediaType.APPLICATION_JSON)` to your endpoints in order to use "
"JSON."
msgstr ""
"如果默认情况下不需要 JSON，可以设置 `quarkus.resteasy-json.default-json=false` "
"，默认情况下将变回自动协商。如果设置了该选项，则需要在端点中添加 `@Produces(MediaType.APPLICATION_JSON)` 和 "
"`@Consumes(MediaType.APPLICATION_JSON)` ，以便使用 JSON。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"If you don't rely on the JSON default, it is heavily recommended to annotate "
"your endpoints with the `@Produces` and `@Consumes` annotations to define "
"precisely the expected content-types.\n"
"It will allow to narrow down the number of Jakarta REST providers (which can "
"be seen as converters) included in the native executable."
msgstr ""
"如果不依赖 JSON 默认值，强烈建议使用 `@Produces` 和 `@Consumes` "
"注释来注解端点，以精确定义预期的内容类型。这样可以减少本地可执行文件中包含的 Jakarta REST 提供程序（可视为转换器）的数量。"

#. type: Title ===
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Configuring JSON support"
msgstr "配置JSON支持"

#. type: Title ====
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Jackson"
msgstr "杰克逊"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"In Quarkus, the default Jackson `ObjectMapper` obtained via CDI (and "
"consumed by the Quarkus extensions) is configured to ignore unknown "
"properties\n"
"(by disabling the `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` "
"feature)."
msgstr ""
"在Quarkus中，通过CDI获得的默认Jackson `ObjectMapper` （并由Quarkus扩展使用）被配置为忽略未知属性（通过禁用 "
"`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` 功能）。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"You can restore the default behavior of Jackson by setting `quarkus.jackson."
"fail-on-unknown-properties=true` in your `application.properties`\n"
"or on a per-class basis via `@JsonIgnoreProperties(ignoreUnknown = false)`."
msgstr ""
"您可以在 `application.properties` 中设置 `quarkus.jackson.fail-on-unknown-"
"properties=true` ，或通过 `@JsonIgnoreProperties(ignoreUnknown = false)` 按类设置，恢复 "
"Jackson 的默认行为。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Furthermore, the `ObjectMapper` is configured to format dates and time in "
"ISO-8601\n"
"(by disabling the `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` feature)."
msgstr ""
"此外， `ObjectMapper` 被配置为ISO-8601的日期和时间格式（通过禁用 `SerializationFeature."
"WRITE_DATES_AS_TIMESTAMPS` 功能）。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"The default behaviour of Jackson can be restored by setting `quarkus.jackson."
"write-dates-as-timestamps=true`\n"
"in your `application.properties`. If you want to change the format for a "
"single field, you can use the\n"
"`@JsonFormat` annotation."
msgstr ""
"Jackson的默认行为可以通过在你的 `application.properties` 中设置 `quarkus.jackson.write-"
"dates-as-timestamps=true` 来设置。如果你想改变单个字段的默认行为，你可以使用 `@JsonFormat` 注解。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Also, Quarkus makes it very easy to configure various Jackson settings via "
"CDI beans.\n"
"The simplest (and suggested) approach is to define a CDI bean of type `io."
"quarkus.jackson.ObjectMapperCustomizer`\n"
"inside of which any Jackson configuration can be applied."
msgstr ""
"另外，Quarkus使得通过CDI beans来配置各种Jackson设置变得非常容易。最简单的（也是建议的）方法是定义一个类型为 `io."
"quarkus.jackson.ObjectMapperCustomizer` 的CDI Bean，在其中可以使用任何Jackson配置。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"An example where a custom module needs to be registered would look like so:"
msgstr "需要注册自定义模块的示例如下所示："

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Users can even provide their own `ObjectMapper` bean if they so choose.\n"
"If this is done, it is very important to manually inject and apply all `io."
"quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that "
"produces `ObjectMapper`.\n"
"Failure to do so will prevent Jackson specific customizations provided by "
"various extensions from being applied."
msgstr ""
"如果用户选择的话，他们甚至可以提供自己的 `ObjectMapper` bean。如果这样做，在产生 `ObjectMapper` "
"的CDI生产者中，手动注入和应用所有 `io.quarkus.jackson.ObjectMapperCustomizer` "
"Bean是非常重要的。如果不这样做，就会阻止各种扩展所提供的Jackson特定的自定义功能被应用。"

#. type: Title ====
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "JSON-B"
msgstr "JSON-B"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"As stated above, Quarkus provides the option of using JSON-B instead of "
"Jackson via the use of the `quarkus-resteasy-jsonb` extension."
msgstr "如上所述，Quarkus通过使用 `quarkus-resteasy-jsonb` 扩展提供了使用JSON-B而不是Jackson的选项。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Following the same approach as described in the previous section, JSON-B can "
"be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean."
msgstr ""
"按照上一节所述的相同方法，JSON-B可以使用 `io.quarkus.jsonb.JsonbConfigCustomizer` bean进行配置。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"If for example a custom serializer named `FooSerializer` for type `com."
"example.Foo` needs to be registered with JSON-B, the addition of a bean like "
"the following would suffice:"
msgstr ""
"例如，如果需要使用 JSON-B 注册类型为 `com.example.Foo` 的名为 `FooSerializer` "
"的自定义序列化程序，则添加如下所示的 bean 就足够了："

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"A more advanced option would be to directly provide a bean of `jakarta.json."
"bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to "
"provide a bean of type `jakarta.json.bind.Jsonb` (with a `Singleton` scope).\n"
"If the latter approach is leveraged it is very important to manually inject "
"and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI "
"producer that produces `jakarta.json.bind.Jsonb`.\n"
"Failure to do so will prevent JSON-B specific customizations provided by "
"various extensions from being applied."
msgstr ""
"更高级的选择是直接提供 `jakarta.json.bind.JsonbConfig` 的 Bean（具有 `Dependent` "
"作用域），或者在极端情况下提供 `jakarta.json.bind.Jsonb` 类型的 Bean（具有 `Singleton` "
"作用域）。如果使用后一种方法，那么在生成 `jakarta.json.bind.Jsonb` 的 CDI 生产者中手动注入和应用所有 `io."
"quarkus.jsonb.JsonbConfigCustomizer` Bean 就非常重要。否则将无法应用各种扩展提供的 JSON-B 特定定制。"

#. type: Title ===
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "JSON Hypertext Application Language (HAL) support"
msgstr "支持JSON超文本应用语言（HAL）。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"The https://tools.ietf.org/id/draft-kelly-json-hal-01.html[HAL] standard is "
"a simple format to represent web links."
msgstr ""
"link:https://tools.ietf.org/id/draft-kelly-json-hal-01.html[HAL] "
"标准是一种表示网络链接的简单格式。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"To enable the HAL support, add the `quarkus-hal` extension to your project. "
"Also, as HAL needs JSON support, you need to add either the `quarkus-"
"resteasy-jsonb` or the `quarkus-resteasy-jackson` extension."
msgstr ""
"要启用HAL支持，请在你的项目中添加 `quarkus-hal` 扩展。另外，由于HAL需要JSON支持，你需要添加 `quarkus-resteasy-"
"jsonb` 或 `quarkus-resteasy-jackson` 扩展。"

#. type: Block title
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Table Context object"
msgstr "表情境对象"

#. type: Table
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "GAV"
msgstr "GAV"

#. type: Table
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Usage"
msgstr "使用方法"

#. type: Table
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "`io.quarkus:quarkus-hal`"
msgstr " `io.quarkus:quarkus-resteasy-reactive-jaxb` "

#. type: Table
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "https://tools.ietf.org/id/draft-kelly-json-hal-01.html[HAL]"
msgstr "link:https://tools.ietf.org/id/draft-kelly-json-hal-01.html[哈尔]"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"After adding the extensions, we can now annotate the REST resources to "
"produce the media type `application/hal+json` (or use RestMediaType."
"APPLICATION_HAL_JSON). For example:"
msgstr ""
"添加扩展后，我们现在可以对REST资源进行注释，以产生媒体类型 `application/hal+json` （或使用RestMediaType."
"APPLICATION_HAL_JSON）。比如说。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Now, the endpoints `/records` and `/records/first` will accept the media "
"type both `json` and `hal+json` to print the records in Hal format."
msgstr ""
"现在，端点 `/records` 和 `/records/first` 将接受媒体类型 `json` 和 `hal+json` ，以 Hal "
"格式打印记录。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"For example, if we invoke the `/records` endpoint using curl to return a "
"list of records, the HAL format will look like as follows:"
msgstr "例如，如果我们使用curl调用 `/records` 端点来返回一个记录列表，HAL格式将如下所示。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"When we call a resource `/records/first` that returns only one instance, "
"then the output is:"
msgstr "当我们调用只返回一个实例的资源 `/records/first` 时，输出结果为"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Creating a frontend"
msgstr "创建一个网页"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Now let's add a simple web page to interact with our `FruitResource`.\n"
"Quarkus automatically serves static resources located under the `META-INF/"
"resources` directory.\n"
"In the `src/main/resources/META-INF/resources` directory, add a `fruits."
"html` file with the content from this link:{quickstarts-blob-url}/rest-json-"
"quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] "
"file in it."
msgstr ""
"现在，让我们添加一个简单的网页，与我们的 `FruitResource` 进行交互。Quarkus 会自动提供位于 `META-INF/"
"resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 "
"`fruits.html` 文件，其中包含 link:{quickstarts-blob-url}/rest-json-quickstart/src/"
"main/resources/META-INF/resources/fruits.html[fruits.html] 文件的内容。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "You can now interact with your REST service:"
msgstr "现在你可以与你的REST服务进行交互："

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "start Quarkus with:"
msgstr "启动Quarkus："

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid "CLI"
msgstr "CLI"

#: _versions/3.2/guides/resteasy.adoc
msgid "Maven"
msgstr "Maven"

#: _versions/3.2/guides/resteasy.adoc
msgid "Gradle"
msgstr "Gradle"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "open a browser to `http://localhost:8080/fruits.html`"
msgstr ""
"打开浏览器访问 `<a href=\"http://localhost:8080/fruits.html\" class=\"bare\">http://"
"localhost:8080/fruits.html</a>` "

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "add new fruits to the list via the form"
msgstr "通过表格添加新的fruits到列表中"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Building a native executable"
msgstr "构建一个本地可执行文件"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "You can build a native executable with the usual command:"
msgstr "你可以使用常用命令构建本机可执行文件："

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Running it is as simple as executing `./target/rest-json-quickstart-1.0.0-"
"SNAPSHOT-runner`."
msgstr "运行它就像执行 `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner` 一样简单。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"You can then point your browser to `http://localhost:8080/fruits.html` and "
"use your application."
msgstr ""
"然后你可以使用的浏览器访问 `<a href=\"http://localhost:8080/fruits.html\" class="
"\"bare\">http://localhost:8080/fruits.html</a>` 来使用你的应用程序。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "About serialization"
msgstr "关于序列化"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"JSON serialization libraries use Java reflection to get the properties of an "
"object and serialize them."
msgstr "JSON序列化库使用Java反射来获取一个对象的属性并将其序列化。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"When using native executables with GraalVM, all classes that will be used "
"with reflection need to be registered.\n"
"The good news is that Quarkus does that work for you most of the time.\n"
"So far, we haven't registered any class, not even `Fruit`, for reflection "
"usage and everything is working fine."
msgstr ""
"当使用GraalVM的本地可执行文件时，需要注册所有将与反射一起使用的类。好消息是，Quarkus在大多数时候都会为你做这项工作。到目前为止，我们还没有注册任何类，甚至没有注册 "
"`Fruit` ，并且一切正常。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Quarkus performs some magic when it is capable of inferring the serialized "
"types from the REST methods.\n"
"When you have the following REST method, Quarkus determines that `Fruit` "
"will be serialized:"
msgstr ""
"当Quarkus能够从REST方法中推断出序列化的类型时，它会发挥一些作用。当你有以下的REST方法时，Quarkus确定 `Fruit` 将被序列化："

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Quarkus does that for you automatically by analyzing the REST methods at "
"build time\n"
"and that's why we didn't need any reflection registration in the first part "
"of this guide."
msgstr "Quarkus通过在构建时分析REST方法自动为你执行此操，这就是为什么我们在本指南的第一部分不需要任何反射注册。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Another common pattern in the Jakarta REST world is to use the `Response` "
"object.\n"
"`Response` comes with some nice perks:"
msgstr "在 Jakarta REST 世界中，另一种常见的模式是使用 `Response` 对象。 `Response` 有一些不错的好处："

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"you can return different entity types depending on what happens in your "
"method (a `Legume` or an `Error` for instance);"
msgstr "你可以根据你的方法中发生的情况，返回不同的实体类型（例如， `Legume` 或 `Error` ）。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"you can set the attributes of the `Response` (the status comes to mind in "
"the case of an error)."
msgstr "你可以设置 `Response` 的属性（在出现错误的情况下，会想到状态）。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "Your REST method then looks like this:"
msgstr "你的 REST 方法如下所示："

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"It is not possible for Quarkus to determine at build time the type included "
"in the `Response` as the information is not available.\n"
"In this case, Quarkus won't be able to automatically register for reflection "
"the required classes."
msgstr ""
"Quarkus不可能在构建时确定 `Response` 中包含的类型，因为该信息不可用。在这种情况下，Quarkus将无法自动注册反映所需的类。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "This leads us to our next section."
msgstr "这将我们引向下一节。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Using Response"
msgstr "使用Response"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Let's create the `Legume` class which will be serialized as JSON, following "
"the same model as for our `Fruit` class:"
msgstr "让我们创建一个将被序列化为 JSON 的 `Legume` 类，遵循与我们的 `Fruit` 类相同的模型："

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Now let's create a `LegumeResource` REST service with only one method which "
"returns the list of legumes."
msgstr "现在让我们创建一个 `LegumeResource` REST服务，它只有一个返回legumes类列表的方法。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "This method returns a `Response` and not a list of `Legume`."
msgstr "该方法返回一个 `Response` ，而不是一个 `Legume` 列表。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Now let's add a simple web page to display our list of legumes.\n"
"In the `src/main/resources/META-INF/resources` directory, add a `legumes."
"html` file with the content from this\n"
"{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/"
"resources/legumes.html[legumes.html] file in it."
msgstr ""
"现在让我们添加一个简单的网页来显示我们的legumes列表。在 `src/main/resources/META-INF/resources` "
"目录中，添加一个 `legumes.html` 文件，其中包含这个{quickstarts-blob-url}/rest-json-quickstart/"
"src/main/resources/META-INF/resources/legumes.html[legumes.html] 文件的内容。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Open a browser to http://localhost:8080/legumes.html, and you will see our "
"list of legumes."
msgstr ""
"然后你可以使用的浏览器访问 `<a href=\"http://localhost:8080/fruits.html\" class="
"\"bare\">http://localhost:8080/fruits.html</a>` 来使用你的应用程序。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"The interesting part starts when running the application as a native "
"executable:"
msgstr "有趣的部分是在将应用程序作为本机可执行文件运行时开始的："

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "create the native executable with:"
msgstr "创建本地可执行文件。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "execute it with `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`"
msgstr "用以下方式执行它 `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner` "

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "open a browser and go to http://localhost:8080/legumes.html"
msgstr "打开浏览器，访问 http://localhost:8080/legumes.html "

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "No legumes there."
msgstr "那里没有legumes。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"As mentioned above, the issue is that Quarkus was not able to determine the "
"`Legume` class will require some reflection by analyzing the REST endpoints.\n"
"The JSON serialization library tries to get the list of fields of `Legume` "
"and gets an empty list, so it does not serialize the fields' data."
msgstr ""
"如上所述，问题在于 Quarkus 无法通过分析 REST 端点来确定 `Legume` 类是否需要一些反射。JSON 序列化库尝试获取 "
"`Legume` 的字段列表，但得到的是一个空列表，因此它不会序列化字段数据。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"At the moment, when JSON-B or Jackson tries to get the list of fields of a "
"class, if the class is not registered for reflection, no exception will be "
"thrown.\n"
"GraalVM will simply return an empty list of fields."
msgstr ""
"目前，当JSON-B或Jackson尝试获取一个类的字段列表时，如果该类没有注册反射，则不会抛出异常。GraalVM将简单地返回一个空的字段列表。"

#. type: delimited block =
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Hopefully, this will change in the future and make the error more obvious."
msgstr "希望这在将来会有所改变，使错误更加明显。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"We can register `Legume` for reflection manually by adding the "
"`@RegisterForReflection` annotation on our `Legume` class:"
msgstr ""
"我们可以通过在我们的 `Legume` 类上添加 `@RegisterForReflection` 注解来手动注册 `Legume` 进行反射："

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"The `@RegisterForReflection` annotation instructs Quarkus to keep the class "
"and its members during the native compilation. More details about the "
"`@RegisterForReflection` annotation can be found on the xref:writing-native-"
"applications-tips.adoc#registerForReflection[native application tips] page."
msgstr ""
"`@RegisterForReflection` 注解用于指导Quarkus在native编译过程中保留该类和其成员。关于 "
"`@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips."
"html#registerForReflection[native应用程序提示] 页面找到。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "Let's do that and follow the same steps as before:"
msgstr "让我们这样做，并遵循与之前相同的步骤："

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "hit `Ctrl+C` to stop the application"
msgstr "点击 `Ctrl+C` ，停止应用程序。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid "This time, you can see our list of legumes."
msgstr "这一次，你可以看到我们的legumes列表。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Being reactive"
msgstr "响应式"

#. type: delimited block =
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"For reactive workloads, please always use xref:resteasy-reactive."
"adoc[RESTEasy Reactive]."
msgstr "对于反应式工作负载，请始终使用 link:resteasy-reactive.html[RESTEasy Reactive] 。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"You can return _reactive types_ to handle asynchronous processing.\n"
"Quarkus recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] "
"to write reactive and asynchronous code."
msgstr ""
"你可以返回 _响应式类型_ 来处理异步处理。Quarkus推荐使用 link:https://smallrye.io/smallrye-"
"mutiny[Mutiny] 来编写响应式和异步代码。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"To integrate Mutiny and RESTEasy, you need to add the `quarkus-resteasy-"
"mutiny` dependency to your project:"
msgstr "要集成Mutiny和RESTEasy，你需要在你的项目中添加 `quarkus-resteasy-mutiny` 的依赖性。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid "Then, your endpoint can return `Uni` or `Multi` instances:"
msgstr "然后，你的端点可以返回 `Uni` 或 `Multi` 实例。"

#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Use `Uni` when you have a single result.\n"
"Use `Multi` when you have multiple items that may be emitted asynchronously."
msgstr "当你有一个单一的结果时，使用 `Uni` 。当你有多个可能被异步发射的项目时，使用 `Multi` 。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"You can use `Uni` and `Response` to return asynchronous HTTP responses: "
"`Uni<Response>`."
msgstr "您可以使用 `Uni` 和 `Response` 返回异步 HTTP 响应：`Uni<Response>`。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"More details about Mutiny can be found in xref:mutiny-primer.adoc[Mutiny - "
"an intuitive reactive programming library]."
msgstr ""
"有关 Mutiny 的更多详细信息，请参见外部参考：xref:mutiny-primer.adoc[Mutiny - 一个直观的响应式编程库]。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "HTTP filters and interceptors"
msgstr "HTTP过滤器和拦截器"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Both HTTP request and response can be intercepted by providing "
"`ContainerRequestFilter` or `ContainerResponseFilter`\n"
"implementations respectively. These filters are suitable for processing the "
"metadata associated with a message: HTTP\n"
"headers, query parameters, media type, and other metadata. They also have "
"the capability to abort the request\n"
"processing, for instance when the user does not have the permissions to "
"access the endpoint."
msgstr ""
"通过分别提供 `ContainerRequestFilter` 或 `ContainerResponseFilter` 实现，可以拦截 HTTP "
"请求和响应。这些过滤器适用于处理与信息相关的元数据：HTTP "
"头信息、查询参数、媒体类型和其他元数据。它们还具有中止请求处理的功能，例如当用户没有访问端点的权限时。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Let's use `ContainerRequestFilter` to add logging capability to our service. "
"We can do that by implementing\n"
"`ContainerRequestFilter` and annotating it with the `@Provider` annotation:"
msgstr ""
"让我们使用 `ContainerRequestFilter` ，为我们的服务添加日志功能。我们可以通过实现 "
"`ContainerRequestFilter` ，并使用 `@Provider` 注释来实现这一功能。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Now, whenever a REST method is invoked, the request will be logged into the "
"console:"
msgstr "现在，每当REST方法被调用时，该请求将被记录到控制台。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "CORS filter"
msgstr "CORS过滤器"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-"
"origin resource sharing] (CORS) is a mechanism that\n"
"allows restricted resources on a web page to be requested from another "
"domain outside the domain from which the first resource\n"
"was served."
msgstr ""
"link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[跨源资源共享] "
"（CORS）是一种机制，允许从提供第一个资源的域之外的另一个域请求网页上的受限资源。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Quarkus comes with a CORS filter. Read the xref:http-reference.adoc#cors-"
"filter[HTTP Reference Documentation] to learn\n"
"how to use it."
msgstr ""
"Quarkus 自带 CORS 过滤器。阅读 xref:http-reference.adoc#cors-filter[HTTP 参考文档] "
"，了解如何使用它。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "GZip Support"
msgstr "支持GZip"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Quarkus comes with GZip support (even though it is not enabled by default). "
"The following configuration knobs allow to configure GZip support."
msgstr "Quarkus自带GZip支持（尽管它在默认情况下是不启用的）。下面的配置旋钮可以配置GZip支持。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid "Enable Gzip support."
msgstr "启用Gzip支持。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Configure the upper limit on deflated request body. This is useful to "
"mitigate potential attacks by limiting their reach. The default value is "
"`10M`.\n"
"This configuration option would recognize strings in this format (shown as a "
"regular expression): `[0-9]+[KkMmGgTtPpEeZzYy]?`. If no suffix is given, "
"assume bytes."
msgstr ""
"配置放宽请求正文的上限。这有助于通过限制潜在攻击的影响范围来减轻攻击。默认值为 `10M` 。该配置选项可识别以下格式的字符串（以正则表达式显示）： "
"`[0-9]+[KkMmGgTtPpEeZzYy]?` .如果没有给出后缀，则假定为字节。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Once GZip support has been enabled you can use it on an endpoint by adding "
"the `@org.jboss.resteasy.annotations.GZIP` annotation to your endpoint "
"method."
msgstr ""
"启用 GZip 支持后，只要在端点方法中添加 `@org.jboss.resteasy.annotations.GZIP` 注解，就可以在端点上使用 "
"GZip 支持。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"There is also the `quarkus.http.enable-compression` configuration property "
"which enables HTTP response compression globally. If enabled then a response "
"body is compressed if the `Content-Type` HTTP header is set and the value is "
"a compressed media type as configured via the `quarkus.http.compress-media-"
"types` configuration property."
msgstr ""
"`quarkus.http.enable-compression` 配置属性可全局启用 HTTP 响应压缩。启用后，如果设置了 `Content-"
"Type` HTTP 标头，且值是通过 `quarkus.http.compress-media-types` "
"配置属性配置的压缩媒体类型，则响应体将被压缩。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Multipart Support"
msgstr "多部分支持"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"RESTEasy supports multipart via the https://docs.jboss.org/resteasy/docs/4.5."
"6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider]."
msgstr ""
"RESTEasy通过 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/"
"html/Multipart.html[RESTEasy Multipart Provider] 支持多部件。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Quarkus provides an extension called `quarkus-resteasy-multipart` to make "
"things easier for you."
msgstr "Quarkus提供了一个名为 `quarkus-resteasy-multipart` 的扩展，使你的工作更容易。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"This extension slightly differs from the RESTEasy default behavior as the "
"default charset (if none is specified in your request) is UTF-8 rather than "
"US-ASCII."
msgstr "该扩展与RESTEasy的默认行为略有不同，因为默认字符集（如果你的请求中没有指定）是UTF-8，而不是US-ASCII。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"You can configure this behavior with the following configuration properties:"
msgstr "你可以通过以下配置属性来配置这种行为。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"<span class=\"icon\"><i class=\"fa fa-lock\" title=\"Fixed at build time\"></"
"i></span> Configuration property fixed at build time - All other "
"configuration properties are overridable at runtime <input type=\"search\" "
"id=\"config-search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"
msgstr ""
"<span class=\"icicon\"><i class=\"fa fa-lock\" title=\"在构建时固定\"></i></"
"span>在构建时固定的配置属性 - 所有其他配置属性都可在运行时重写 <input type=\"search\" id=\"config-"
"search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Servlet compatibility"
msgstr "小程序兼容性"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"In Quarkus, RESTEasy can either run directly on top of the Vert.x HTTP "
"server, or on top of Undertow if you have any servlet dependency."
msgstr ""
"在Quarkus中，RESTEasy可以直接运行在Vert.x HTTP服务器之上，如果你有任何Servlet依赖，也可以运行在Undertow之上。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"As a result, certain classes, such as `HttpServletRequest` are not always "
"available for injection. Most use-cases for this particular\n"
"class are covered by Jakarta REST equivalents, except for getting the remote "
"client's IP. RESTEasy comes with a replacement API which you can inject:\n"
"https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/"
"spi/HttpRequest.html[`HttpRequest`], which has the methods\n"
"https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/"
"spi/HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`]\n"
"and https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/"
"resteasy/spi/HttpRequest.html#getRemoteHost--[`getRemoteHost()`]\n"
"to solve this problem."
msgstr ""
"因此，某些类（如 `HttpServletRequest` ）并不总是可以注入。除了获取远程客户端的 IP 外，Jakarta REST "
"对应类涵盖了该特定类的大多数用例。RESTEasy 提供了可以注入的替代 API： link:https://docs.jboss.org/"
"resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest."
"html[HttpRequest] ，它有 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/"
"javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteAddress--"
"[getRemoteAddress()] 和 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/"
"javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteHost--"
"[getRemoteHost()] 方法来解决这个问题。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "RESTEasy and REST Client interactions"
msgstr "RESTEasy和REST客户端的互动"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"In Quarkus, the RESTEasy extension and xref:rest-client.adoc[the REST Client "
"extension] share the same infrastructure.\n"
"One important consequence of this consideration is that they share the same "
"list of providers (in the Jakarta REST meaning of the word)."
msgstr ""
"在 Quarkus 中，RESTEasy 扩展和 xref:rest-client.adoc[REST 客户端扩展] "
"共享相同的基础设施。这种考虑的一个重要结果是，它们共享相同的提供程序列表（按照 Jakarta REST 的含义）。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"For instance, if you declare a `WriterInterceptor`, it will by default "
"intercept both the servers calls and the client calls,\n"
"which might not be the desired behavior."
msgstr "例如，如果您声明一个 `WriterInterceptor` ，它将默认拦截服务器调用和客户端调用，这可能不是您想要的行为。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"However, you can change this default behavior and constrain a provider to:"
msgstr "然而，你可以改变这种默认行为，并将一个提供者约束为。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"only consider *server* calls by adding the `@ConstrainedTo(RuntimeType."
"SERVER)` annotation to your provider;"
msgstr "通过向你的提供者添加 `@ConstrainedTo(RuntimeType.SERVER)` 注释，只考虑 *服务器* 调用。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"only consider *client* calls by adding the `@ConstrainedTo(RuntimeType."
"CLIENT)` annotation to your provider."
msgstr "通过向你的提供者添加 `@ConstrainedTo(RuntimeType.CLIENT)` 注释，只考虑 *客户端* 调用。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "What's Different from Jakarta EE Development"
msgstr "与雅加达EE开发有什么不同"

#. type: Title ===
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "No Need for `Application` Class"
msgstr "不需要 `Application` 类"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Configuration via an application-supplied subclass of `Application` is "
"supported, but not required."
msgstr "支持但不要求通过应用程序提供的 `Application` 子类进行配置。"

#. type: Title ===
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Only a single Jakarta REST application"
msgstr "只有一个JAX-RS应用程序"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"In contrast to Jakarta REST (and RESTeasy) running in a standard servlet-"
"container, Quarkus only supports the deployment of a single Jakarta REST "
"application.\n"
"If multiple Jakarta REST `Application` classes are defined, the build will "
"fail with the message `Multiple classes have been annotated with "
"@ApplicationPath which is currently not supported`."
msgstr ""
"与在标准 servlet 容器中运行的 Jakarta REST（和 RESTeasy）不同，Quarkus 只支持部署一个 Jakarta REST "
"应用程序。如果定义了多个 Jakarta REST `Application` 类，构建将失败，提示信息为 `Multiple classes have "
"been annotated with @ApplicationPath which is currently not supported` 。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"If multiple Jakarta REST applications are defined, the property `quarkus."
"resteasy.ignore-application-classes=true` can be used to ignore all explicit "
"`Application` classes. This makes all resource-classes available via the "
"application-path as defined by `quarkus.resteasy.path` (default: `/`)."
msgstr ""
"如果定义了多个 Jakarta REST 应用程序，可使用 `quarkus.resteasy.ignore-application-classes="
"true` 属性忽略所有显式 `Application` 类。这样，所有资源类都可以通过 `quarkus.resteasy.path` （默认值： `/"
"` ）定义的应用程序路径访问。"

#. type: Title ===
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Support limitations of Jakarta REST application"
msgstr "支持JAX-RS应用程序的限制"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"The RESTEasy extension doesn't support the method `getProperties()` of the "
"class `jakarta.ws.rs.core.Application`. Moreover, it only relies on the "
"methods `getClasses()` and `getSingletons()` to filter out the annotated "
"resource, provider and feature classes.\n"
"It doesn't filter out the built-in resource, provider and feature classes "
"and also the resource, provider and feature classes registered by the other "
"extensions.\n"
"Finally, the objects returned by the method `getSingletons()` are ignored, "
"only the classes are taken into account to filter out the resource, provider "
"and feature classes, in other words the method `getSingletons()` is actually "
"managed the same way as `getClasses()`."
msgstr ""
"RESTEasy 扩展不支持类 `jakarta.ws.rs.core.Application` 的方法 `getProperties()` "
"。此外，它只依赖 `getClasses()` 和 `getSingletons()` "
"方法来过滤已注释的资源、提供程序和特征类。它不过滤内置的资源、提供程序和特征类，也不过滤其他扩展注册的资源、提供程序和特征类。最后，方法 "
"`getSingletons()` 返回的对象会被忽略，只有类会被考虑在内，以筛选出资源、提供程序和特征类，换句话说，方法 "
"`getSingletons()` 的管理方式实际上与 `getClasses()` 相同。"

#. type: Title ===
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Lifecycle of Resources"
msgstr "资源的生命周期"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"In Quarkus all Jakarta REST resources are treated as CDI beans.\n"
"It's possible to inject other beans via `@Inject`, bind interceptors using "
"bindings such as `@Transactional`, define `@PostConstruct` callbacks, etc."
msgstr ""
"在 Quarkus 中，所有 Jakarta REST 资源都被视为 CDI Bean。可以通过 `@Inject` 注入其他 Bean，使用绑定（如 "
"`@Transactional` ）绑定拦截器，定义 `@PostConstruct` 回调等。"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"If there is no scope annotation declared on the resource class then the "
"scope is defaulted.\n"
"The default scope can be controlled through the `quarkus.resteasy.singleton-"
"resources` property.\n"
"If set to `true` (default) then a *single instance* of a resource class is "
"created to service all requests (as defined by `@jakarta.inject.Singleton`).\n"
"If set to `false` then a *new instance* of the resource class is created per "
"each request.\n"
"An explicit CDI scope annotation (`@RequestScoped`, `@ApplicationScoped`, "
"etc.) always overrides the default behavior and specifies the lifecycle of "
"resource instances."
msgstr ""
"如果资源类上没有声明作用域注解，则使用默认作用域。默认作用域可通过 `quarkus.resteasy.singleton-resources` "
"属性控制。如果设置为 `true` （默认），则会创建一个资源类 *实例* 来服务所有请求（如 `@jakarta.inject.Singleton` "
"所定义）。如果设置为 `false` ，则每个请求都会创建一个 *新的* 资源类实例。明确的 CDI 作用域注解（ `@RequestScoped` , "
"`@ApplicationScoped` 等）总是会覆盖默认行为，并指定资源实例的生命周期。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy, no-wrap
msgid "Include/Exclude Jakarta REST classes with build time conditions"
msgstr "包括/排除具有构建时间条件的JAX-RS类"

#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Quarkus enables the inclusion or exclusion of Jakarta REST Resources, "
"Providers and Features directly thanks to build time conditions in the same "
"that it does for CDI beans.\n"
"Thus, the various Jakarta REST classes can be annotated with profile "
"conditions (`@io.quarkus.arc.profile.IfBuildProfile` or `@io.quarkus.arc."
"profile.UnlessBuildProfile`) and/or with property conditions (`io.quarkus."
"arc.properties.IfBuildProperty` or `io.quarkus.arc.properties."
"UnlessBuildProperty`) to indicate to Quarkus at build time under which "
"conditions these Jakarta REST classes should be included."
msgstr ""
"Quarkus 与 CDI Bean 一样，通过构建时的条件，可以直接包含或排除 Jakarta REST 资源、提供者和功能。因此，各种 "
"Jakarta REST 类都可以用配置文件条件（ `@io.quarkus.arc.profile.IfBuildProfile` 或 `@io."
"quarkus.arc.profile.UnlessBuildProfile` ）和/或属性条件（ `io.quarkus.arc.properties."
"IfBuildProperty` 或 `io.quarkus.arc.properties.UnlessBuildProperty` "
"）进行注释，以便在构建时向 Quarkus 表明在哪些条件下应包含这些 Jakarta REST 类。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"In the following example, Quarkus includes the endpoint `sayHello` if and "
"only if the build profile `app1` has been enabled."
msgstr "在下面的例子中，Quarkus包括端点 `sayHello` ，当且仅当构建配置文件 `app1` 已经被启用。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
#, fuzzy
msgid ""
"Please note that if a Jakarta REST Application has been detected and the "
"method `getClasses()` and/or `getSingletons()` has/have been overridden, "
"Quarkus will ignore the build time conditions and consider only what has "
"been defined in the Jakarta REST Application."
msgstr ""
"请注意，如果检测到一个 JAX-RS 应用程序，并且方法 `getClasses()` 和/或 `getSingletons()` "
"已经被重写，Quarkus 将忽略构建时间条件，只考虑 JAX-RS 应用程序中定义的内容。"

#. type: Title ==
#: _versions/3.2/guides/resteasy.adoc
#, no-wrap
msgid "Conclusion"
msgstr "解决方案"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"Creating JSON REST services with Quarkus is easy as it relies on proven and "
"well known technologies."
msgstr "使用 Quarkus 创建 JSON REST 服务很容易，因为它依赖于经过验证且众所周知的技术。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"As usual, Quarkus further simplifies things under the hood when running your "
"application as a native executable."
msgstr "像往常一样，当您将应用程序作为本机可执行文件运行时，Quarkus 进一步简化了内部工作。"

#. type: Plain text
#: _versions/3.2/guides/resteasy.adoc
msgid ""
"There is only one thing to remember: if you use `Response` and Quarkus can't "
"determine the beans that are serialized, you need to annotate them with "
"`@RegisterForReflection`."
msgstr ""
"只有一件事要记住：如果您使用 `Response` 并且 Quarkus 无法确定被序列化的 bean，则需要使用 "
"`@RegisterForReflection` 注解它们。"
