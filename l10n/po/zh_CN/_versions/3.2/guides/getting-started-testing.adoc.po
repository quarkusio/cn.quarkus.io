# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-08-28 16:20+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Testing Your Application"
msgstr "测试您的应用程序"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Learn how to test your Quarkus Application.\n"
"This guide covers:"
msgstr "学习如何测试您的Quarkus应用程序。本指南包括："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Testing in JVM mode"
msgstr "在JVM模式下测试"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Testing in native mode"
msgstr "在本地模式下测试"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Injection of resources into tests"
msgstr "将资源注入测试中"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "The completed greeter application from the xref:getting-started.adoc[Getting Started Guide]"
msgstr "来自 link:getting-started.html[《入门指南》]  的完整的greeter应用程序"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Architecture"
msgstr "架构"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"In this guide, we expand on the initial test that was created as part of the Getting Started Guide.\n"
"We cover injection into tests and also how to test native executables."
msgstr "在本指南中，我们对作为入门指南的一部分而创建的初始测试进行扩展。我们涵盖了注入测试以及如何测试本地可执行文件。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Quarkus supports Continuous testing, but this is covered by the xref:continuous-testing.adoc[Continuous Testing Guide]."
msgstr "Quarkus支持持续测试，但这是 link:continuous-testing.html[持续测试指南] 所讨论的。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Solution"
msgstr "解决方案"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"We recommend that you follow the instructions in the next sections and create the application step by step.\n"
"However, you can go right to the completed example."
msgstr "我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库： `git clone {quickstarts-clone-url}` ，或者下载 {quickstarts-archive-url}[存档] 。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "The solution is located in the `getting-started-testing` link:{quickstarts-tree-url}/getting-started-testing[directory]."
msgstr "该解决方案位于 `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[目录]中。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "This guide assumes you already have the completed application from the `getting-started` directory."
msgstr "本指南假设您已经准备好了 `getting-started` 目录中的应用。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Recap of HTTP based Testing in JVM mode"
msgstr "对JVM模式中基于HTTP的测试的回顾"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"If you have started from the Getting Started example you should already have a completed test, including the correct\n"
"tooling setup."
msgstr "如果您已从入门的例子开始，那您应该已经有了一个完成的测试例子，包括正确的安装了工具。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "In your build file you should see 2 test dependencies:"
msgstr "在您的构建文件中应该有2个测试依赖："

#. type: Block title
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: Block title
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Gradle"
msgstr "Gradle"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.\n"
"`rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically\n"
"sets the correct URL so no configuration is required."
msgstr "`quarkus-junit5` 是测试所必需的，因为它提供 `@QuarkusTest` 注解来控制测试框架。而 `rest-assured` 不是必需的，但它是测试HTTP节点的一种便捷方式，我们还集成对自动设置正确URL的支持，因此不需要配置。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin]\n"
"must be set, as the default version does not support Junit 5:"
msgstr "因为我们使用的是JUnit 5，所以必须设置 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven插件] 的版本，因为默认版本不支持Junit 5："

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration\n"
"from `${maven.home}/conf/settings.xml` is applied (if any)."
msgstr "我们还设置了 `java.util.logging.manager` 系统属性，以确保测试使用正确的日志管理器。同时设置 `maven.home` 属性，以确保 `${maven.home}/conf/settings.xml` 的自定义配置被设置（如果有的话）。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "The project should also contain a simple test:"
msgstr "该项目还应该包含一个简单的测试："

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before\n"
"the test is run."
msgstr "该测试使用HTTP来直接测试我们的REST节点。当运行测试时，应用程序将在测试运行前被启动。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Controlling the test port"
msgstr "控制测试端口"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run\n"
"tests while having the application running in parallel."
msgstr "虽然Quarkus默认会监听端口 `8080` ，但当运行测试时，它会默认设为 `8081` 。这允许您在运行测试的同时让应用程序并行运行。"

#. type: Block title
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Changing the test port"
msgstr "改变测试端口"

#. type: delimited block =
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:"
msgstr "您可以通过 `quarkus.http.test-port` 和 `quarkus.http.test-ssl-port` 来配置用于HTTP和HTTPS测试的端口："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`0` will result in the use of a random port (assigned by the operating system)."
msgstr "设置为 `0` 则会使用随机端口（由操作系统分配）。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run,\n"
"so no additional configuration should be required."
msgstr "Quarkus还提供了RestAssured集成用以在测试运行前更新RestAssured使用的默认端口，因而不需要额外的配置。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Controlling HTTP interaction timeout"
msgstr "控制HTTP交互超时时间"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.\n"
"You can override this setting with the `quarkus.http.test-timeout` property:"
msgstr "当在您的测试中使用REST Assured时，连接和响应超时默认设置为30秒。可以通过 `quarkus.http.test-timeout` 属性覆盖该设置："

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Injecting a URI"
msgstr "注入URI"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is\n"
"done via the `@TestHTTPResource` annotation."
msgstr "也可以直接将URL注入测试中，从而可以更容易的使用不同的客户端。可通过 `@TestHTTPResource` 注解完成。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in\n"
"`src/main/resources/META-INF/resources/index.html` :"
msgstr "让我们写一个简单的测试来演示如何加载一些静态资源。首先创建一个简单的HTML文件 `src/main/resources/META-INF/resources/index.html` ："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "We will create a simple test to ensure that this is being served correctly:"
msgstr "我们将创建一个简单的测试以确保这个文件被正确的加载："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL"
msgstr "该注解允许您将URL直接注入为Quarkus实例，注解的值将是URL的路径"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL."
msgstr "目前为止 `@TestHTTPResource` 允许您注入 `URI` 、 `URL` 以及 `String` 的URL表示。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Testing a specific endpoint"
msgstr "测试特定的节点"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding\n"
"a path. This currently supports both Jakarta REST endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints\n"
"a given test is testing."
msgstr "RESTassured 和 `@TestHTTPResource` 都允许您指定要测试的端点类，而不是硬编码路径。目前，它支持 Jakarta REST 端点、Servlets 和 Reactive Routes。这样就能更轻松地查看特定测试正在测试的端点。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "For the purposes of these examples I am going to assume we have an endpoint that looks like the following:"
msgstr "为了演示这些例子的目的，这里将假设我们有一个类似于下面的节点："

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"This currently does not support the `@ApplicationPath()` annotation to set the Jakarta REST context path. Use the\n"
"`quarkus.resteasy.path` config value instead if you want a custom context path."
msgstr "目前不支持使用 `@ApplicationPath()` 注释来设置 Jakarta REST 上下文路径。如果需要自定义上下文路径，请使用 `quarkus.resteasy.path` 配置值。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "TestHTTPResource"
msgstr "TestHTTPResource"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path\n"
"will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will\n"
"be appended to the end of the endpoint path."
msgstr "您可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注释来指定节点路径，该路径会从提供的节点中提取。如果您还为 `TestHTTPResource` 节点指定了另外的值，它将被附加到节点路径后。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Because `GreetingResource` is annotated with `@Path(\"/hello\")` the injected URL\n"
"will end with `/hello`."
msgstr "因为 `GreetingResource` 用到了注解 `@Path(\"/hello\")` ，注入的URL会以 `/hello` 结束。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "RESTassured"
msgstr "RESTassured"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"To control the RESTassured base path (i.e. the default path that serves as the root for every\n"
"request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can\n"
"be applied at the class or method level. To test out greeting resource we would do:"
msgstr "为了控制RESTassured基础路径（即作为每个请求根路径的默认路径），您可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注解。可以在类或方法层面上使用。为了测试greeting资源类，我们可以这样做："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "This tells RESTAssured to prefix all requests with `/hello`."
msgstr "这将使RESTAssured在所有请求之前加上 `/hello` 。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Note we don't need to specify a path here, as `/hello` is the default for this test"
msgstr "注意我们不需要在此指定路径，因为 `/hello` 是这个测试的默认路径"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Injection into tests"
msgstr "注入测试"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit\n"
"testing and test our beans directly?"
msgstr "到目前为止，我们只涉及了通过HTTP节点测试应用程序的集成式测试，但如果我们想做单元测试并直接测试我们的Bean又该怎么办？"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in\n"
"Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting\n"
"service directly without using HTTP:"
msgstr "Quarkus支持这种方式。它允许使用 `@Inject` 注解来将CDI Bean注入您的测试中（事实上，Quarkus中的测试是完整的CDI Bean，所以您可以使用所有的CDI功能）。让我们创建一个简单的测试，直接测试greeting服务，而非使用HTTP："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "The `GreetingService` bean will be injected into the test"
msgstr "`GreetingService` bean将被注入到测试类中"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Applying Interceptors to Tests"
msgstr "在测试中使用拦截器"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would\n"
"normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the\n"
"`@Transactional` annotation to the method and the transaction interceptor will handle it."
msgstr "如上所述，Quarkus测试实际上是完整的CDI Bean，因此您可以自由的使用CDI拦截器。举个例子，如果您想让测试方法在事务上下文中运行，您可以将 `@Transactional` 注解加到该方法上，之后事务拦截器将会处理。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"In addition to this you can also create your own test stereotypes. For example, we could create a `@TransactionalQuarkusTest`\n"
"as follows:"
msgstr "除此以外，您还可以创建您自己的测试 stereotypes。例如，我们可以创建一个 `@TransactionalQuarkusTest` ，如下所示："

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and\n"
"`@Transactional` annotations, e.g.:"
msgstr "如果我们将这个注解应用于测试类，那它就类似于我们同时应用了 `@QuarkusTest` 和 `@Transactional` 注解一样，例如："

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Tests and Transactions"
msgstr "测试与事务"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your\n"
"test makes to the database will be persistent. If you want any changes made to be rolled back at the end of\n"
"the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a\n"
"transaction, but roll it back once the test method is complete to revert any database changes."
msgstr "您可以在测试中使用标准的Quarkus `@Transactional` 注解，但这意味着您的测试对数据库的改变将是持久的。如果您想在测试结束时回滚所做的任何改变，您可以使用 `io.quarkus.test.TestTransaction` 注释。这将在一个事务中运行测试方法，但一旦测试方法完成，事务就会回滚从而以恢复所有数据库变化。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Enrichment via QuarkusTest*Callback"
msgstr "通过QuarkusTest*Callback来增强"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:"
msgstr "作为拦截器的替代或补充，您可以通过实现以下回调接口来增强 *所有* 的 `@QuarkusTest` 类："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeTestExecutionCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterTestExecutionCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "Optionally, you can enable these callbacks also for the `@QuarkusIntegrationTest` tests if the property `quarkus.test.enable-callbacks-for-integration-tests` is `true`."
msgstr "可选的是，如果属性 `quarkus.test.enable-callbacks-for-integration-tests` 是 `true` ，你也可以为 `@QuarkusIntegrationTest` 测试启用这些回调。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Such a callback implementation has to be registered as a \"service provider\" as defined by `java.util.ServiceLoader`."
msgstr "这种回调实现必须作为java \"服务提供者(service provider) \"注册，从而被 `java.util.ServiceLoader` 来加载。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "E.g. the following sample callback:"
msgstr "例如下面的回调例子："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "has to be registered via `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` as follows:"
msgstr "该回调类必须通过 `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` 注册，具体如下："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "It is possible to read annotations from the test class or method to control what the callback shall be doing."
msgstr "可以从测试类或方法中读取注解，从而控制回调应做什么。"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has\n"
"         to run tests in a custom classloader which JUnit is not aware of."
msgstr "虽然可以使用 JUnit Jupiter 回调接口（如 `BeforeEachCallback` ），但可能会遇到类加载问题，因为 Quarkus 必须在 JUnit 不知道的自定义类加载器中运行测试。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Testing Different Profiles"
msgstr "测试不同的Profiles"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot,\n"
"then all tests will run, then Quarkus will shut down at the end. This makes for a very fast testing experience however\n"
"it is a bit limited as you can't test different configurations."
msgstr "到目前为止，在我们所有的例子中，我们只为所有的测试启动Quarkus一次。在第一个测试运行之前，Quarkus会启动，然后所有测试都会在这次启动中运行，最后Quarkus会关闭。这使得测试体验非常快，但是它有一点局限性，因为您无法测试不同的配置。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously\n"
"run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously\n"
"a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility."
msgstr "为了解决这个问题，Quarkus支持测试profile。如果一个测试有一个与之前运行的测试不同的profile，那么Quarkus将被停止，并在运行对应的测试之前使用新的profile启动。这显然会有些许变慢，因为它在测试时间上增加了一个停止/启动周期，但同时也提供了很大的灵活性。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"To reduce the amount of times Quarkus needs to restart, `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer`\n"
"is registered as a global `ClassOrderer` as described in the\n"
"link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5 User Guide].\n"
"The behavior of this `ClassOrderer` is configurable via `junit-platform.properties` (see the source code or javadoc for more details).\n"
"It can also be disabled entirely by setting another `ClassOrderer` that is provided by JUnit 5 or even your own custom one. +\n"
"Please note that as of JUnit 5.8.2 link:https://github.com/junit-team/junit5/issues/2794[only a single `junit-platform.properties` is picked up and a warning is logged if more than one is found].\n"
"If you encounter such warnings, you can get rid of them by removing the Quarkus-supplied `junit-platform.properties` from the classpath via an exclusion:"
msgstr "为了减少Quarkus需要重启的次数， `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` 被注册为全局 `ClassOrderer` ，如 link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5用户指南] 中所述。这个orderer的行为可以通过 `junit-platform.properties` （更多细节见源代码或javadoc）来配置。它也可以通过配置另一个由JUnit 5所提供的ClassOrderer，甚至是您自己的自定义Orderer来完全禁用。+ 请注意，从JUnit 5.8.2开始 link:https://github.com/junit-team/junit5/issues/2794[只能有一个 `junit-platform.properties` 被使用，如果超过一个就会有警告记录] 。如果您遇到这样的警告，您可以通过从classpath中移除Quarkus提供的 `junit-platform.properties` 来删除它们："

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Writing a Profile"
msgstr "编写Profile"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:"
msgstr "为了实现一个测试profile，我们需要实现 `io.quarkus.test.junit.QuarkusTestProfile` ："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "All these methods have default implementations so just override the ones you need to override."
msgstr "所有这些方法都有默认的实现，所以只要覆盖您需要覆盖的方法就可以。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Now we have defined our profile we need to include it on our test class.\n"
"We do this by annotating the test class with `@TestProfile(MockGreetingProfile.class)`."
msgstr "现在我们已经定义了我们自己的profile，我们需要在我们的测试类中引入它。我们通过在测试类中注解 `@TestProfile(MockGreetingProfile.class)` 来做到这一点。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"All the test profile configuration is stored in a single class, which makes it easy to tell if the previous test ran with the\n"
"same configuration."
msgstr "所有的测试profile配置都存储在一个单一的类中，这使得我们很容易知道之前的测试是否以相同的配置运行。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Running specific tests"
msgstr "运行特定的测试"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Quarkus provides the ability to limit test execution to tests with specific  `@TestProfile` annotations.\n"
"This works by leveraging the `tags` method of `QuarkusTestProfile` in conjunction with the `quarkus.test.profile.tags` system property."
msgstr "Quarkus提供了将测试限制在具有特定 `@TestProfile` 注释的测试中执行的能力。这是通过联合利用 `QuarkusTestProfile` 的 `tags` 方法和 `quarkus.test.profile.tags` 系统属性来实现的。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Essentially, any `QuarkusTestProfile` with at least one matching tag matching the value of `quarkus.test.profile.tags` will be considered active\n"
"and all the tests annotated with `@TestProfile` of active profiles, will be run while the rest will be skipped.\n"
"This is best shown in the following example."
msgstr "本质上，任何至少有一个标签与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 将被认为是激活的，并且所有被激活的profiles中注解了 `@TestProfile` 的测试将被运行，而其余的将被跳过。这在下面的例子中得到了最好的体现。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "First let's define a few `QuarkusTestProfile` implementations like so:"
msgstr "首先让我们定义这么几个 `QuarkusTestProfile` 实现："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Now let's assume that we have the following tests:"
msgstr "现在让我们假设有以下测试："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Let's consider the following scenarios:"
msgstr "让我们考虑以下场景："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`quarkus.test.profile.tags` is not set: All tests will be executed."
msgstr "`quarkus.test.profile.tags` 未被设置。所有的测试都将被执行。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"`quarkus.test.profile.tags=foo`: In this case none of tests will be executed because none of the tags defined on the `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`.\n"
"Note that `NoQuarkusProfileTest` is not executed either because it is not annotated with `@TestProfile`."
msgstr "`quarkus.test.profile.tags=foo` :在这种情况下，所欧测试都不会被执行，因为在 `QuarkusTestProfile` 实现上定义的标签中没有一个与 `quarkus.test.profile.tags` 的值相匹配。注意， `NoQuarkusProfileTest` 也不会被执行，因为它没有 `@TestProfile` 注解。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"`quarkus.test.profile.tags=test1`: In this case `SingleTagTest` and `MultipleTagsTest` will be run because the tags on their respective `QuarkusTestProfile` implementations\n"
"match the value of `quarkus.test.profile.tags`."
msgstr "`quarkus.test.profile.tags=test1` :在这种情况下， `SingleTagTest` 和 `MultipleTagsTest` 将被运行，因为它们各自的 `QuarkusTestProfile` 实现的标签与 `quarkus.test.profile.tags` 的值一致。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`quarkus.test.profile.tags=test1,test3`: This case results in the same tests being executed as the previous case."
msgstr "`quarkus.test.profile.tags=test1,test3` :这种情况下，执行的测试与前一种情况相同。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"`quarkus.test.profile.tags=test2,test3`: In this case only `MultipleTagsTest` will be run because `MultipleTagsTest` is the only `QuarkusTestProfile` implementation whose `tags` method\n"
"matches the value of `quarkus.test.profile.tags`."
msgstr "`quarkus.test.profile.tags=test2,test3` :在这种情况下，只有 `MultipleTagsTest` 会被运行，因为 `MultipleTagsTest` 是唯一一个 `tags` 方法与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 实现。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Mock Support"
msgstr "Mock支持"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to\n"
"mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis."
msgstr "Quarkus支持使用两种不同的方法来mock对象。您可以使用CDI alternatives来mock出所有测试类的Bean，也可以使用 `QuarkusMock` 来mock出每个测试类的Bean。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "CDI `@Alternative` mechanism."
msgstr "CDI `@Alternative` 机制。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.\n"
"Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.\n"
"This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.\n"
"For example if I have the following service:"
msgstr "要使用这个方法，只需用 `src/test/java` 目录中的一个类来覆盖您想mock的Bean，并在Bean上加上 `@Alternative` 和 `@Priority(1)` 注解。另外，也可以使用 `io.quarkus.test.Mock` stereotype注释。这个内置的stereotype声明了 `@Alternative` 、 `@Priority(1)` 和 `@Dependent` 。例如，如果我有以下的服务："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "I could mock it with the following class in `src/test/java`:"
msgstr "我可以在 `src/test/java` 中用以下类来mock它："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Overrides the `@Dependent` scope declared on the `@Mock` stereotype."
msgstr "对 `@Mock` stereotype上声明的 `@Dependent` 范围的覆盖。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise\n"
"it will take effect all the time, not just when testing."
msgstr "注意，alternative要放置于 `src/test/java` 目录中而不是 `src/main/java` ，否则它将不仅仅只是在测试时生效。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Note that at present this approach does not work with native image testing, as this would require the test alternatives\n"
"to be baked into the native image."
msgstr "另外需要注意的是，目前这种方法不能用于本地镜像测试，因为这需要将测试用的alternatives加入本地镜像中。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Mocking using QuarkusMock"
msgstr "使用QuarkusMock进行mock"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped\n"
"bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class,\n"
"while if you use this in a test method the mock will only take effect for the duration of the current test."
msgstr "`io.quarkus.test.junit.QuarkusMock` 类可以被用来临时mock任何正常scope的bean。如果您在 `@BeforeAll` 方法中使用这个方法，mock将对当前类的所有测试生效，而如果您在测试方法中使用这个方法，mock将只在当前测试方法范围内生效。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically\n"
"every scope except `@Singleton` and `@Dependent`)."
msgstr "该方法可以用于任何正常scope的CDI Bean（例如： `@ApplicationScoped` , `@RequestScoped` 等，基本上是除了 `@Singleton` 和 `@Dependent` 以外的scope ）。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "An example usage could look like:"
msgstr "示例用法如下所示："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods"
msgstr "由于注入的实例在这里不可用，我们使用了 `installMockForType` ，这个mock用在于所有两个测试方法中"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method."
msgstr "我们使用 `installMockForInstance` 以取代注入的bean，它在整个测试方法的持续时间内生效。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the\n"
"objects to provide the behaviour you require."
msgstr "请注意，这里并不依赖Mockito，您可以使用任何您喜欢的mocking库，甚至可以手动覆盖对象以提供您需要的行为。"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"Using `@Inject` will get you a CDI proxy to the mock instance you install, which is not suitable for passing to methods such as `Mockito.verify`\n"
"which want the mock instance itself.\n"
"So if you need to call methods such as `verify` you should hang on to the mock instance in your test, or use `@io.quarkus.test.InjectMock`."
msgstr "使用 `@Inject` 将获得一个指向所安装的模拟实例的 CDI 代理，这不适合传递给 `Mockito.verify` 等需要模拟实例本身的方法。因此，如果需要调用 `verify` 等方法，应在测试中挂起模拟实例，或使用 `@io.quarkus.test.InjectMock` 。"

#. type: Title ====
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Further simplification with `@InjectMock`"
msgstr "使用 `@InjectMock` 进行进一步简化"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.\n"
"This functionality is available with the `@io.quarkus.test.InjectMock` annotation if the `quarkus-junit5-mockito` dependency is present."
msgstr "在 `QuarkusMock` 所提供功能的基础上，Quarkus 还允许用户毫不费力地利用 link:https://site.mockito.org/[Mockito] 来模拟 `QuarkusMock` 所支持的 Bean。如果存在 `quarkus-junit5-mockito` 依赖关系，则可通过 `@io.quarkus.test.InjectMock` 注解使用该功能。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Using `@InjectMock`, the previous example could be written as follows:"
msgstr "使用 `@InjectMock` ，前面的例子可以写成下面形式："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "`@InjectMock` results in a Mockito mock being created, which is then available in test methods of the test class (other test classes are *not* affected by this)"
msgstr "`@InjectMock` 可以生成一个mock并使其在测试类的所有测试方法中可用（其他测试 类*不受* 此影响）"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "The `mockableBean1` is configured here for every test method of the class"
msgstr "`mockableBean1` 被mockito配置并可以为类的每个测试方法所用"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Since the `mockableBean2` mock has not been configured, it will return the default Mockito response."
msgstr "由于 `mockableBean2` mock还没有被配置，它将返回默认的Mockito响应。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "In this test the `mockableBean2` is configured, so it returns the configured response."
msgstr "在这个测试中， `mockableBean2` 进行了配置，所以它返回配置好的响应。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test\n"
"we would most likely configure a mock, but then test a bean that uses the mocked bean.\n"
"Here is an example:"
msgstr "尽管上面的测试很好地展示了 `@InjectMock` 的能力，但它并不能很好地表示一个真实的测试案例。在一个真实的测试案例中，我们很可能会配置一个mock，然后测试一个使用了mocked Bean的Bean。下面是一个例子："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean"
msgstr "由于我们将 `greetingService` 配置为一个mock，那么在使用了 `GreetingService` Bean的 `GreetingResource` 中，我们得到的是mock的响应，而不是正常的 `GreetingService` Bean的响应"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"By default, the `@InjectMock` annotation can be used for any normal CDI scoped bean (e.g. `@ApplicationScoped`, `@RequestScoped`).\n"
"Mocking `@Singleton` beans can be performed by adding the `@MockitoConfig(convertScopes = true)` annotation.\n"
"This will convert the `@Singleton` bean to an `@ApplicationScoped` bean for the test."
msgstr "默认情况下， `@InjectMock` 注解可用于任何普通的 CDI 作用域 Bean（如 `@ApplicationScoped` , `@RequestScoped` ）。可以通过添加 `@MockitoConfig(convertScopes = true)` 注解来模拟 `@Singleton` Bean。这将把 `@Singleton` Bean 转换为用于测试的 `@ApplicationScoped` Bean。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "This is considered an advanced option and should only be performed if you fully understand the consequences of changing the scope of the bean."
msgstr "这是一个高级选项，只有在您完全了解改变Bean scope的后果时才可以执行。"

#. type: Title ====
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Using Spies instead of Mocks with `@InjectSpy`"
msgstr "通过 `@InjectSpy` 用Spies来代替Mocks"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.\n"
"This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency."
msgstr "基于 `InjectMock` 所提供的功能，Quarkus还允许用户很容易利用 link:https://site.mockito.org/[Mockito] 来对 `QuarkusMock` 所支持的bean进行spy操作。这个功能可以通过 `@io.quarkus.test.junit.mockito.InjectSpy` 注解来实现，该注解通过 `quarkus-junit5-mockito` 依赖导入。"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#13[Mockito documentation - Spying on real objects] for more details on Spy partial mocks.\n"
"In either of those situations a Spy of the object is preferable.\n"
"Using `@InjectSpy`, the previous example could be written as follows:"
msgstr "有时在测试时，你只需要验证某个逻辑路径是否被采用，或者你只需要将某个方法的响应存根出来，同时仍然执行 Spied 克隆上的其他方法。有关 Spy 部分模拟的更多详情，请参阅 link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#13[Mockito 文档--监视真实对象] 。在这两种情况下，最好都使用 Spy 对象。使用 `@InjectSpy` ，前面的示例可以编写如下："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test."
msgstr "我们没有覆盖这个值，而只是想确保我们的 `GreetingService` 上的greet方法被这个测试所调用。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "Here we are telling the Spy to return \"hi\" instead of \"hello\". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean. Sometimes it's impossible or impractical to use `when(Object)` for stubbing spies. Therefore when using spies please consider `doReturn|Answer|Throw()` family of methods for stubbing."
msgstr "这里我们令Spy返回 \"hi \"而不是 \"hello\"。当 `GreetingResource` 向 `GreetingService` 请求greeting时，我们得到的是mock的响应，而不是正常的 `GreetingService` Bean的响应"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "We are verifying that we get the mocked response from the Spy."
msgstr "这里我们正在验证从Spy那里得到了mock响应。"

#. type: Title ====
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Using `@InjectMock` with `@RestClient`"
msgstr "使用 `@InjectMock` 与 `@RestClient`"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`."
msgstr "`@RegisterRestClient` 在运行时注册了rest-client的实现，并且由于bean需要保证使用了一个正常的scope，您必须使用 `@ApplicationScoped` 来注释您的接口。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "For the test class here is an example:"
msgstr "对于测试类，这里有一个例子："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Indicate that this injection point is meant to use an instance of `RestClient`."
msgstr "这里表示这个注入点使用了 `RestClient` 的实例。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Mocking with Panache"
msgstr "使用Panache mock"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the xref:hibernate-orm-panache.adoc#mocking[Hibernate ORM with Panache Mocking] and xref:mongodb-panache.adoc#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access."
msgstr "如果您使用 `quarkus-hibernate-orm-panache` 或 `quarkus-mongodb-panache` 扩展，请查看 link:hibernate-orm-panache.html#mocking[Hibernate ORM with Panache Mocking] 和 link:mongodb-panache.html#mocking[MongoDB with Panache Mocking] 文档，以了解mock数据访问的最简单方式。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Testing Security"
msgstr "测试安全性"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "If you are using Quarkus Security, check out the xref:security-testing.adoc[Testing Security] section for information on how to easily test security features of the application."
msgstr "如果您正在使用Quarkus Security，请查看 link:security-testing.html[测试安全] 部分，了解如何轻松测试应用程序的安全功能。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Starting services before the Quarkus application starts"
msgstr "在Quarkus应用程序启动之前启动服务"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."
msgstr "一个很常见的需求是在Quarkus应用程序启动测试之前，启动一些您的Quarkus应用程序所依赖的服务。为了解决这个需求，Quarkus提供了 `@io.quarkus.test.common.QuarkusTestResource` 和 `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` 。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"By simply annotating any test in the test suite with `@QuarkusTestResource`, Quarkus will run the corresponding `QuarkusTestResourceLifecycleManager` before any tests are run.\n"
"A test suite is also free to utilize multiple `@QuarkusTestResource` annotations, in which case all the corresponding `QuarkusTestResourceLifecycleManager` objects will be run before the tests. When using multiple test resources they can be started concurrently. For that you need to set `@QuarkusTestResource(parallel = true)`."
msgstr "通过简单地在测试套件中用 `@QuarkusTestResource` 注释测试，Quarkus将在测试运行之前运行相应的 `QuarkusTestResourceLifecycleManager` 。测试套件也可以自由地利用多个 `@QuarkusTestResource` 注释，从而使所有对应的 `QuarkusTestResourceLifecycleManager` 对象在测试前运行。当使用多个测试资源时，它们可以并行启动。为此，您需要设置 `@QuarkusTestResource(parallel = true)` 。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Test resources are global, even if they are defined on a test class or custom profile, which means they will all be activated for all tests, even though we do\n"
"remove duplicates. If you want to only enable a test resource on a single test class or test profile, you can use `@QuarkusTestResource(restrictToAnnotatedClass = true)`."
msgstr "测试资源是全局性的，即使它们被定义在一个测试类或自定义profile上，这意味着它们将全部被激活从而用于所有的测试，尽管我们删除了重复的测试。如果您只想针对一个测试类或测试profile启用某一个测试资源，您可以使用 `@QuarkusTestResource(restrictToAnnotatedClass = true)` 。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` which starts a mock Kubernetes API server),\n"
"but it is common to create custom implementations to address specific application needs.\n"
"Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[here]),\n"
"or starting a mock HTTP server using https://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here])."
msgstr "Quarkus提供了一些开箱即用的 `QuarkusTestResourceLifecycleManager` （见 `io.quarkus.test.h2.H2DatabaseTestResource` ，它启动了一个H2数据库；或 `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` ，它启动了一个模拟的Kubernetes API服务器），但创建自定义的实现来满足特定的应用需求也是很常见的。常见的情况包括使用 link:https://www.testcontainers.org/[Testcontainers] 启动docker容器（例子 link:https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[见这里] ），或使用 link:http://wiremock.org/[Wiremock] 启动一个模拟的HTTP服务器（例子 link:https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[见这里] ）。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Altering the test class"
msgstr "改动测试类"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"When creating a custom `QuarkusTestResourceLifecycleManager` that needs to inject the something into the test class, the `inject` methods can be used.\n"
"If for example you have a test like the following:"
msgstr "当创建一个自定义的 `QuarkusTestResourceLifecycleManager` 来将某些资源注入到测试类时，可以使用 `inject` 方法。例如，如果您有一个像下面这样的测试："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Making `MyWireMockResource` inject the `wireMockServer` field can be done as shown in the `inject` method of the following code snippet:"
msgstr "为了使 `MyWireMockResource` 注入 `wireMockServer` 字段，可按以下代码片断中的 `inject` 方法进行："

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"It is worth mentioning that this injection into the test class is not under the control of CDI and happens after CDI has performed\n"
"any necessary injections into the test class."
msgstr "值得一提的是，这种对测试类的注入并不在CDI的控制之下，而是发生在CDI对测试类进行了所有必要的注入之后。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Annotation-based test resources"
msgstr "基于注解的测试资源"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"It is possible to write test resources that are enabled and configured using annotations. This is enabled by placing the `@QuarkusTestResource`\n"
"on an annotation which will be used to enable and configure the test resource."
msgstr "我们也可以编写使用注解来启用和配置的测试资源。这可以通过在一个注解上使用 `@QuarkusTestResource` 来启用，该注解将被用来启用和配置测试资源。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"For example, this defines the `@WithKubernetesTestServer` annotation, which you can use on your tests to activate the `KubernetesServerTestResource`,\n"
"but only for the annotated test class. You can also place them on your `QuarkusTestProfile` test profiles."
msgstr "例如，下面代码定义了 `@WithKubernetesTestServer` 注释，您可以在您的测试上使用它来激活 `KubernetesServerTestResource` ，但只针对被注释的测试类。您也可以把它们加入到您的 `QuarkusTestProfile` 测试profile中。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"The `KubernetesServerTestResource` class has to implement the\n"
"`QuarkusTestResourceConfigurableLifecycleManager` interface in order to be configured using the previous annotation:"
msgstr "`KubernetesServerTestResource` 类必须实现 `QuarkusTestResourceConfigurableLifecycleManager` 接口，以便使用前面的注解进行配置："

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"If you want to make the annotation repeatable, the containing annotation type must be annotated with `@QuarkusTestResourceRepeatable`.\n"
"For example, this would define a repeatable `@WithRepeatableTestResource` annotation."
msgstr "如果要使注释可重复，则必须用 `@QuarkusTestResourceRepeatable` 对包含的注释类型进行注释。例如，这将定义一个可重复的 `@WithRepeatableTestResource` 注释。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Hang Detection"
msgstr "挂起侦测"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"`@QuarkusTest` has support for hang detection to help diagnose any unexpected hangs. If no progress is made for a specified\n"
"time (i.e. no JUnit callbacks are invoked) then Quarkus will print a stack trace to the console to help diagnose the hang.\n"
"The default value for this timeout is 10 minutes."
msgstr "`@QuarkusTest` 支持挂起侦测，以帮助诊断任何意外的挂起。如果在指定的时间内没有进展（即没有调用JUnit回调），那么Quarkus将打印一个堆栈跟踪到控制台以帮助诊断挂起。这个超时的默认值是10分钟。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"No further action will be taken, and the tests will continue as normal (generally until CI times out), however the printed\n"
"stack traces should help diagnose why the build has failed. You can control this timeout with the\n"
"`quarkus.test.hang-detection-timeout` system property (you can also set this in application.properties, but this won't\n"
"be read until Quarkus has started, so the timeout for Quarkus start will be the default of 10 minutes)."
msgstr "不会有进一步的动作执行，测试将继续正常进行（通常直到CI超时），但是打印出来的堆栈信息应该有助于诊断为什么构建失败了。您可以用 `quarkus.test.hang-detection-timeout` 系统属性来控制这个超时值（您也可以在application.properties中设置这个值，但是在Quarkus启动之前它不会被读取，所以Quarkus启动的默认超时时间将是10分钟）。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Native Executable Testing"
msgstr "本地可执行程序测试"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"It is also possible to test native executables using `@QuarkusIntegrationTest`. This supports all the features mentioned in this\n"
"guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible)."
msgstr "您也可以使用 `@QuarkusIntegrationTest` 来测试本地可执行文件。除了注入测试（本地可执行文件在一个单独的非JVM进程中运行，所以它实际上是不可能做到的）以外，该特性支持本指南中提到的所有功能。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "This is covered in the xref:building-native-image.adoc[Native Executable Guide]."
msgstr "这在《 link:building-native-image.html[本地可执行文件指南》] 中有所涉及。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Using `@QuarkusIntegrationTest`"
msgstr "使用@QuarkusIntegrationTest"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"`@QuarkusIntegrationTest` should be used to launch and test the artifact produced by the Quarkus build, and supports testing a jar (of whichever type), a native image or container image.\n"
"Put simply, this means that if the result of a Quarkus build (`mvn package` or `gradle build`) is a jar, that jar will be launched as `java -jar ...` and tests run against it.\n"
"If instead a native image was built, then the application is launched as `./application ...` and again the tests run against the running application.\n"
"Finally, if a container image was created during the build (by including the `quarkus-container-image-jib` or `quarkus-container-image-docker` extensions and having the\n"
"`quarkus.container-image.build=true` property configured), then a container is created and run (this requires the `docker` executable being present)."
msgstr "`@QuarkusIntegrationTest` 应该被用来启动和测试由Quarkus构建产生的物件，而且支持测试一个jar（无论哪种类型），一个本地镜像或容器镜像。简单地说，这意味着如果Quarkus构建（ `mvn package` 或者 `gradle build`）的结果是一个jar，这个jar将以 `java -jar ...` 方式启动 ，并针对它运行测试。如果构建的是一个本地镜像，那么应用程序将以 `./application ...` 方式启动，并再次针对运行中的应用程序进行测试。最后，如果在构建过程中创建了一个容器镜像（通过引入 `quarkus-container-image-jib` 或 `quarkus-container-image-docker` 扩展并使用了 `quarkus.container-image.build=true` 属性），那么将创建并运行一个容器（这需要 `docker` 可执行文件的存在）。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "This is a black box test that supports the same set features and has the same limitations."
msgstr "如同 `@NativeImageTest` ，这是一个黑盒测试，支持相同的功能集且具有相同的限制。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"As a test annotated with `@QuarkusIntegrationTest` tests the result of the build, it should be run as part of the integration test suite - i.e. by setting `-DskipITs=false` if using Maven or the `quarkusIntTest` task if using Gradle.\n"
"These tests will **not** work if run in the same phase as `@QuarkusTest` as Quarkus has not yet created the final artifact."
msgstr "由于用 `@QuarkusIntegrationTest` 注释的测试是对构建结果的测试，它应该作为集成测试套件的一部分来运行--即如果使用Maven，则设置 `-DskipITs=false`，而如果使用Gradle，则通过 `quarkusIntTest` 任务。如果与 `@QuarkusTest` 在同一阶段运行，这些测试将 *无法* 工作，因为Quarkus还没有产生出最终的artifact。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "The `pom.xml` file contains:"
msgstr "`pom.xml` 文件包括："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "This instructs the failsafe-maven-plugin to run integration-test."
msgstr "这将通知failsafe-maven-plugin去运行继承测试。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Then, open the `src/test/java/org/acme/quickstart/GreetingResourceIT.java`. It contains:"
msgstr "然后，打开 `src/test/java/org/acme/quickstart/GreetingResourceIT.java` 。它包含了："

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Use another test runner that starts the application from the native file before the tests.\n"
"The executable is retrieved by the _Failsafe Maven Plugin_."
msgstr "这里使用另一个测试runner来通过本地文件在测试之前启动应用。该执行文件通过  _Failsafe Maven Plugin_ 来获取。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "We extend our previous tests as a convenience, but you can also implement your tests."
msgstr "为了方便起见，我们扩展了之前的测试，但您也可以实现您自己的测试。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "More information can be found in the link:building-native-image#testing-the-native-executable[Testing the native executable Guide]."
msgstr "更多的信息可以在 link:building-native-image#testing-the-native-executable[Testing the native executable Guide] 里找到。"

#. type: delimited block =
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "When the application is tested using `@QuarkusIntegrationTest` it is launched using the `prod` configuration profile, but this can be changed using the `quarkus.test.integration-test-profile` property."
msgstr "当使用 `@QuarkusIntegrationTest` 测试应用程序时，它是使用 `prod` 配置文件启动的，但这可以使用 `quarkus.test.integration-test-profile` 属性来改变。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Launching containers"
msgstr "启动容器"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"When `@QuarkusIntegrationTest` results in launching a container (because the application was built with `quarkus.container-image.build` set to `true`), the container is launched on a predictable container network. This facilitates writing integration tests that need to launch services to support the application.\n"
"This means that `@QuarkusIntegrationTest` works out of the box with containers launched via xref:dev-services.adoc[Dev Services], but it also means that it enables using xref:quarkus-test-resource[QuarkusTestLifecycleManager] resources that launch additional containers.\n"
"This can be achieved by having your `QuarkusTestLifecycleManager` implement `io.quarkus.test.common.DevServicesContext.ContextAware`. A simple example could be the following:"
msgstr "当 `@QuarkusIntegrationTest` 导致启动容器时（因为应用程序是在 `quarkus.container-image.build` 设置为 `true` 的情况下构建的），容器会在可预测的容器网络上启动。这有助于编写需要启动服务以支持应用程序的集成测试。这意味着 `@QuarkusIntegrationTest` 开箱即可使用通过 xref:dev-services.adoc[Dev Services] 启动的容器，但这也意味着可以使用 xref:quarkus-test-resource[QuarkusTestLifecycleManager] 资源来启动其他容器。这可以通过让 `QuarkusTestLifecycleManager` 实现 `io.quarkus.test.common.DevServicesContext.ContextAware` 来实现。下面是一个简单的示例："

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"The container running the resource to test against, for example PostgreSQL via Testcontainers, is assigned an IP address from the container's network.\n"
"Use the container's \"public\" IP from its network and the \"unmapped\" port number to connect to the service.\n"
"The Testcontainers library usually return connection strings without respecting the container network, so additional code is needed to provide Quarkus the \"correct\" connection string using the container's IP on the container network and the _unmapped_ port number."
msgstr "运行要测试资源的容器，例如通过Testcontainers启用的PostgreSQL，会从容器的网络中分配到一个IP地址。使用容器网络中的 \"公共 \"IP和 \"未映射 \"的端口号来连接到服务。Testcontainers库通常在不遵从容器网络规则的情况下返回连接字符串，所以需要额外的代码来为Quarkus提供 \"正确的 \"连接字符串，以使用容器网络中的IP和 _未映射_ 的端口号。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "The following example illustrates the use with PostgreSQL, but the approach is applicable to all containers."
msgstr "下面的例子展示了在PostgreSQL上的使用，但这个方法也适用于所有的容器。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`CustomResource` would be activated on a `@QuarkusIntegrationTest` using `@QuarkusTestResource` as is described in the corresponding section of this doc."
msgstr "`CustomResource` 将在 `@QuarkusIntegrationTest` 上通过使用 `@QuarkusTestResource` 激活，就如本文档对应部分所述。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Executing against a running application"
msgstr "对正在运行的应用程序执行测试"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"`@QuarkusIntegrationTest` supports executing tests against an already running instance of the application. This can be achieved by setting the\n"
"`quarkus.http.test-host` system property when running the tests."
msgstr "`@QuarkusIntegrationTest` 支持对已经在运行的应用程序实例执行测试。这可以通过在运行测试时设置 `quarkus.http.test-host` 属性来实现。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "An example use of this could be the following Maven command, that forces `@QuarkusIntegrationTest` to execute against that is accessible at `http://1.2.3.4:4321`:"
msgstr "这方面的一个例子是下面的Maven命令，该命令强制 `@QuarkusIntegrationTest` 对位于 `link:http://1.2.3.4:4321[http://1.2.3.4:4321]` 节点执行测试 :"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "To test against a running instance that only accepts SSL/TLS connection (example: `https://1.2.3.4:4321`) set the system property `quarkus.http.test-ssl-enabled` to `true`."
msgstr "若要针对仅接受 SSL/TLS 连接的运行实例进行测试（例如，将系统属性  设为 ： `https://1.2.3.4:4321` ) 将系统属性 `quarkus.http.test-ssl-enabled` 设置为 `true` 。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Mixing `@QuarkusTest` with other type of tests"
msgstr "混合使用 `@QuarkusTest` 与其他类型的测试"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Mixing tests annotated with `@QuarkusTest` with tests annotated with either `@QuarkusDevModeTest`, `@QuarkusProdModeTest` or `@QuarkusUnitTest`\n"
"is not allowed in a single execution run (in a single Maven Surefire Plugin execution, for instance),\n"
"while the latter three can coexist."
msgstr "在一次执行中（例如在一次Maven Surefire Plugin执行中），将注释为 `@QuarkusTest` 的测试与注释为 `@QuarkusDevModeTest` 、 `@QuarkusProdModeTest` 或 `@QuarkusUnitTest` 的测试混合执行是不被允许的，但是后三者可以共存。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"The reason of this restriction is that `@QuarkusTest` starts a Quarkus server for the whole lifetime of the tests execution run,\n"
"thus preventing the other tests to start their own Quarkus server."
msgstr "这个限制的原因是 `@QuarkusTest` 会在测试执行的整个生命周期内启动一个Quarkus服务器，从而防止其他测试启动自己的Quarkus服务器。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"To alleviate this restriction, the `@QuarkusTest` annotation defines a JUnit 5 `@Tag`: `io.quarkus.test.junit.QuarkusTest`.\n"
"You can use this tag to isolate the `@QuarkusTest` test in a specific execution run, for example with the Maven Surefire Plugin:"
msgstr "为缓解这一限制， `@QuarkusTest` 注解定义了一个 JUnit 5 的 `@Tag` : `io.quarkus.test.junit.QuarkusTest` 。您可以使用该标记在特定的执行中隔离 `@QuarkusTest` 测试，例如使用Maven Surefire插件："

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Running `@QuarkusTest` from an IDE"
msgstr "从IDE中运行 `@QuarkusTest`"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Most IDEs offer the possibility to run a selected class as a JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:"
msgstr "大多数IDE都提供了将选定的类直接作为JUnit测试运行的可能性。为了做到这点，您需要在您选择的IDE的设置中设置一些属性："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`java.util.logging.manager` (see xref:logging.adoc[Logging Guide])"
msgstr "`java.util.logging.manager` (见 link:logging.html[日志指南] )"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`maven.home` (only if there are any custom settings in `${maven.home}/conf/settings.xml`, see xref:maven-tooling.adoc[Maven Guide])"
msgstr "`maven.home` (仅当 `${maven.home}/conf/settings.xml` 中有自定义设置时，见link:maven-tooling.html[Maven指南] )"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)"
msgstr "`maven.settings` (以备在测试中使用自定义的 `settings.xml` 文件)"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Eclipse separate JRE definition"
msgstr "Eclipse中独立的JRE定义"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Copy your current \"Installed JRE\" definition into a new one, where you will add the properties as a new VM arguments:"
msgstr "将您当前的 \"已安装的JRE \"定义复制为一个新的定义，在这里您会将其作为新的虚拟机参数配置来添加属性："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`"
msgstr " `-Djava.util.logging.manager=org.jboss.logmanager.LogManager` "

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "`-Dmaven.home=<path-to-your-maven-installation>`"
msgstr " `-Dmaven.home=<path-to-your-maven-installation>` "

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any \"Run as JUnit\" configuration."
msgstr "使用这个JRE定义作为您的Quarkus项目的目标运行时，该运行时将被用于所有 \"作为JUnit运行(Run as JUnit) \"的配置。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "VSCode \"run with\" configuration"
msgstr "VSCode \"run with \"配置"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "The `settings.json` placed in the root of your project directory or in the workspace will need the following workaround in your test configuration:"
msgstr "在您的项目根目录或工作区的 `settings.json` 文件中，针对测试配置添加以下配置项目："

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "IntelliJ IDEA JUnit template"
msgstr "IntelliJ IDEA JUnit模板"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
msgid "Nothing needed in IntelliJ IDEA because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`."
msgstr "在IntelliJ中不需要任何改动，因为IDE会从 `pom.xml` 中的surefire插件配置中选择 `systemPropertyVariables` 。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, no-wrap
msgid "Testing Dev Services"
msgstr "测试开发服务"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"By default, tests should just work with xref:dev-services.adoc[Dev Services], however from some use cases you may need access to\n"
"the automatically configured properties in your tests."
msgstr "默认情况下，测试应该只与 link:dev-services.html[开发服务] 一起工作，然而在一些用例中，您可能需要访问测试中自动配置的属性。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"You can do this with `io.quarkus.test.common.DevServicesContext`, which can be injected directly into any `@QuarkusTest`\n"
"or `@QuarkusIntegrationTest`. All you need to do is define a field of type `DevServicesContext` and it will be automatically\n"
"injected. Using this you can retrieve any properties that have been set. Generally this is used to directly connect to a\n"
"resource from the test itself, e.g. to connect to kafka to send messages to the application under test."
msgstr "您可以使用 `io.quarkus.test.common.DevServicesContext` 来达到目的，它可以直接注入到任何 `@QuarkusTest` 或 `@QuarkusIntegrationTest` 中。您所需要做的就是定义一个类型为 `DevServicesContext` 的字段，然后它就会自动被注入。使用该方法，您可以检索到任何已经设置的属性。一般来说，这被用来直接连接到测试本身的资源，例如，连接到kafka来发送消息到被测试的应用程序。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"Injection is also supported into objects that implement `io.quarkus.test.common.DevServicesContext.ContextAware`. If you\n"
"have a field that implements `io.quarkus.test.common.DevServicesContext.ContextAware` Quarkus will call the\n"
"`setIntegrationTestContext` method to pass the context into this object. This allows client logic to be encapsulated in\n"
"a utility class."
msgstr "该注入也支持在实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的对象中。如果您有一个实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的字段，Quarkus将调用 `setIntegrationTestContext` 方法来将上下文传入这个对象中。这将允许客户端逻辑被允许封装在一个实用类中。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"`QuarkusTestResourceLifecycleManager` implementations can also implement `ContextAware` to get access to these properties,\n"
"which allows you to set up the resource before Quarkus starts (e.g. configure a KeyCloak instance, add data to a database etc)."
msgstr "`QuarkusTestResourceLifecycleManager` 实现也可以实现 `ContextAware` 接口，以获得对这些属性的访问，这允许您在Quarkus启动之前来配置资源（例如，配置一个KeyCloak实例，向数据库添加数据等）。"

#: _versions/3.2/guides/getting-started-testing.adoc
msgid ""
"For `@QuarkusIntegrationTest` tests that result in launcher the application as a container, `io.quarkus.test.common.DevServicesContext` also provides access to the id of the container network on which the application container was launched (via the `containerNetworkId` method).\n"
"This can be used by `QuarkusTestResourceLifecycleManager` that need to launch additional containers that the application will communicate with."
msgstr "对于将应用程序作为容器启动的 `@QuarkusIntegrationTest` 测试，`io.quarkus.test.common.DevServicesContext` 也提供了对应用容器所启动的容器网络id的访问(通过 `containerNetworkId` 方法)。这可以被 `QuarkusTestResourceLifecycleManager` 使用来启动一些应用程序需要通信的其他容器。"

#. type: Title ==
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy, no-wrap
msgid "Testing Components"
msgstr "测试组件"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "This feature is experimental and the API may change in the future."
msgstr "这个功能是实验性的，在未来的Quarkus版本中可能会有变化。"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"In Quarkus, the component model is built on top CDI.\n"
"Therefore, Quarkus provides the `QuarkusComponentTestExtension`, a JUnit extension to ease the testing of components and mocking of their dependencies.\n"
"This extension is available in the `quarkus-junit5-component` dependency."
msgstr "在Quarkus中，组件模型建立在CDI之上。因此，Quarkus 提供了 `QuarkusComponentTestExtension` ，这是一个 JUnit 扩展，用于简化组件测试及其依赖关系的模拟。该扩展可从 `quarkus-junit5-component` 依赖项中获取。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "Let's have a component `Foo`:"
msgstr "让我们有一个组件 `Foo` ："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "`Foo` is an `@ApplicationScoped` CDI bean."
msgstr " `Foo` 是一个 CDI豆。 `@ApplicationScoped` "

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "`Foo` depends on `Charlie` which declares a method `ping()`."
msgstr " `Foo` 依赖于 ，它声明了一个方法 。 `Charlie` `ping()` "

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "`Foo` depends on the config property `bar`."
msgstr " `Foo` 取决于配置属性 。 `bar` "

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "Then a component test could look like:"
msgstr "示例用法如下所示："

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "The `QuarkusComponentTest` annotation registers the JUnit extension."
msgstr " `QuarkusComponentTest` 注解注册了JUnit扩展。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "Set a configuration property for the test."
msgstr "为测试设置配置属性。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "The test injects the component under the test. The types of all fields annotated with `@Inject` are considered the component types under test. You can also specify additional component classes via `@QuarkusComponentTest#value()`."
msgstr "测试注入被测组件。所有注释为 `@Inject` 的字段类型都被视为测试中的组件类型。您还可以通过 `@QuarkusComponentTest#value()` 指定其他组件类。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "The test also injects `Charlie`, a dependency for which a synthetic `@Singleton` bean is registered automatically. The injected reference is an \"unconfigured\" Mockito mock."
msgstr "该测试还注入了 `Charlie` ，这个依赖关系自动注册了一个合成的 `@Singleton` bean。注入的引用是一个 \"未配置的 \"Mockito模拟。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "We can leverage the Mockito API in a test method to configure the behavior."
msgstr "我们可以在一个测试方法中利用Mockito API来配置行为。"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"If you need the full control over the `QuarkusComponentTestExtension` configuration then you can use the `@RegisterExtension` annotation and configure the extension programatically.\n"
"The test above could be rewritten like:"
msgstr "如果需要完全控制 `QuarkusComponentTestExtension` 配置，则可以使用 `@RegisterExtension` 注释，以编程方式配置扩展。上述测试可改写如下"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "The `QuarkusComponentTestExtension` is configured in a static field."
msgstr "`QuarkusComponentTestExtension` 在静态字段中配置。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy, no-wrap
msgid "Lifecycle"
msgstr "生命周期"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"So what exactly does the `QuarkusComponentTest` do?\n"
"It starts the CDI container and registers a dedicated xref:config-reference.adoc[configuration object] during the `before all` test phase.\n"
"The container is stopped and the config is released during the `after all` test phase.\n"
"The fields annotated with `@Inject` and `@InjectMock` are injected after a test instance is created and unset before a test instance is destroyed.\n"
"Finally, the CDI request context is activated and terminated per each test method."
msgstr "那么， `QuarkusComponentTest` 到底要做什么呢？在 `before all` 测试阶段，它会启动 CDI 容器并注册一个专用 xref:config-reference.adoc[配置对象] 。在 `after all` 测试阶段，容器被停止，配置被释放。注释为 `@Inject` 和 `@InjectMock` 的字段会在创建测试实例后注入，并在销毁测试实例前取消设置。最后，根据每个测试方法激活和终止 CDI 请求上下文。"

#. type: Plain text
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid "By default, a new test instance is created for each test method. Therefore, a new CDI container is started for each test method. However, if the test class is annotated with `@org.junit.jupiter.api.TestInstance` and the test instance lifecycle is set to `org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS` then the CDI container will be shared across all test method executions of a given test class."
msgstr "默认情况下，每个测试方法都会创建一个新的测试实例。因此，每个测试方法都要启动一个新的 CDI 容器。但是，如果测试类注释为 `@org.junit.jupiter.api.TestInstance` ，且测试实例生命周期设置为 `org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS` ，那么 CDI 容器将在给定测试类的所有测试方法执行中共享。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy, no-wrap
msgid "Auto Mocking Unsatisfied Dependencies"
msgstr "自动嘲弄不满足的依赖关系"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"Unlike in regular CDI environments the test does not fail if a component injects an unsatisfied dependency.\n"
"Instead, a synthetic bean is registered automatically for each combination of required type and qualifiers of an injection point that resolves to an unsatisfied dependency.\n"
"The bean has the `@Singleton` scope so it's shared across all injection points with the same required type and qualifiers.\n"
"The injected reference is an _unconfigured_ Mockito mock.\n"
"You can inject the mock in your test and leverage the Mockito API to configure the behavior."
msgstr "与常规 CDI 环境不同，如果组件注入了未满足的依赖关系，测试不会失败。相反，如果注入点的要求类型和限定条件的组合解析为未满足的依赖关系，则会自动注册一个合成 Bean。该 Bean 的作用域为 `@Singleton` ，因此它在具有相同所需类型和限定符的所有注入点中共享。注入的引用是一个 _未配置_ 的 Mockito mock。您可以在测试中注入该 mock，并利用 Mockito API 配置行为。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy, no-wrap
msgid "Custom Mocks For Unsatisfied Dependencies"
msgstr "为不满足的依赖关系定制Mocks"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"Sometimes you need the full control over the bean attributes and maybe even configure the default mock behavior.\n"
"You can use the mock configurator API via the `QuarkusComponentTestExtension#mock()` method."
msgstr "有时，您需要完全控制 bean 的属性，甚至需要配置默认的 mock 行为。您可以通过 `QuarkusComponentTestExtension#mock()` 方法使用 mock 配置器 API。"

#. type: Title ===
#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy, no-wrap
msgid "Configuration"
msgstr "配置"

#: _versions/3.2/guides/getting-started-testing.adoc
#, fuzzy
msgid ""
"A dedicated `SmallRyeConfig` is registered during the `before all` test phase.\n"
"Moreover, it's possible to set the configuration properties via the `QuarkusComponentTestExtension#configProperty(String, String)` method or the `@TestConfigProperty` annotation.\n"
"If you only need to use the default values for missing config properties, then the `QuarkusComponentTestExtension#useDefaultConfigProperties()` or `@QuarkusComponentTest#useDefaultConfigProperties()` might come in useful."
msgstr "在 `before all` 测试阶段会注册一个专用的 `SmallRyeConfig` 。此外，还可以通过 `QuarkusComponentTestExtension#configProperty(String, String)` 方法或 `@TestConfigProperty` 注解设置配置属性。如果您只需要使用缺失配置属性的默认值，那么 `QuarkusComponentTestExtension#useDefaultConfigProperties()` 或 `@QuarkusComponentTest#useDefaultConfigProperties()` 可能会派上用场。"
