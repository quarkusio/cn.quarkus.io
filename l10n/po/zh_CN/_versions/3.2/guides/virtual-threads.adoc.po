# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-08-28 16:20+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "Writing simpler reactive REST services with Quarkus Virtual Thread support"
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "This guide explains how to benefit from Java 19 virtual threads when writing REST services in Quarkus."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"This is the reference guide for using virtual threads to write reactive REST services.\n"
"Please refer to the xref:rest-json.adoc[Writing JSON REST services guides] for a lightweight introduction to reactive REST\n"
"services and to the xref:resteasy-reactive.adoc[Writing REST Services with RESTEasy Reactive] guide for a detailed presentation."
msgstr ""

#. type: Title ==
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "What are virtual threads ?"
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Terminology"
msgstr "术语"

#. type: Labeled list
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "OS thread"
msgstr "操作系统线程"

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "A \"thread-like\" data-structure managed by the Operating System."
msgstr ""

#. type: Labeled list
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Platform thread"
msgstr "平台螺纹"

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Up until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, that is, a wrapper around an OS thread.\n"
"Creating a platform threads creates an OS thread, blocking a platform thread blocks an OS thread."
msgstr ""

#. type: Labeled list
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Virtual thread"
msgstr "虚拟线程"

#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy
msgid ""
"Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.\n"
"Thus, scheduling virtual threads is the responsibility of the JVM."
msgstr "由 JVM 管理的轻量级线程。它们扩展了 link:{thread}[线程] 类，但不与特定的操作系统线程绑定。因此，调度虚拟线程是 JVM 的职责。"

#. type: Labeled list
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Carrier thread"
msgstr "承载线"

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"A platform thread used to execute a virtual thread is called a carrier.\n"
"This isn't a class distinct from link:{Thread}[Thread] or VirtualThread but rather a functional denomination."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Differences between virtual threads and platform threads"
msgstr "虚拟线程和平台线程之间的区别"

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "We will give a brief overview of the topic here, please refer to the link:{vthreadjep}[JEP 425] for more information."
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "Virtual threads are a feature available since Java 19 aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Until now, platform threads were the concurrency unit of the JVM.\n"
"They are a wrapper over OS structures.\n"
"This means that creating a Java platform thread actually results in creating a \"thread-like\" structure in your operating system."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Virtual threads on the other hand are managed by the JVM. In order to be executed, they need to be mounted on a platform thread\n"
"(which acts as a carrier to that virtual thread).\n"
"As such, they have been designed to offer the following characteristics:"
msgstr ""

#. type: Labeled list
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Lightweight "
msgstr "轻量级"

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Virtual threads occupy less space than platform threads in memory.\n"
"Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the heap.\n"
"By default, platform threads are created with a stack of about 1 MB where virtual threads stack is \"pay-as-you-go\".\n"
"You can find these numbers along with other motivations for virtual threads in this presentation given by the lead developer of project Loom: https://youtu.be/lIq-x_iI-kc?t=543."
msgstr ""

#. type: Labeled list
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Cheap to create"
msgstr "创建成本低"

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Creating a platform thread in Java takes time.\n"
"Currently, techniques such as pooling where threads are created once then reused are strongly encouraged to minimize the\n"
"time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).\n"
"Virtual threads are supposed to be disposable entities that we create when we need them,\n"
"it is discouraged to pool them or to reuse them for different tasks."
msgstr ""

#. type: Labeled list
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Cheap to block"
msgstr "便于封锁"

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a\n"
"wait queue and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.\n"
"Since virtual threads are managed by the JVM, no underlying OS thread is blocked when they perform a blocking operation.\n"
"Their state is simply stored in the heap and another Virtual thread is executed on the same Java platform thread."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Virtual threads are useful for I/O-bound workloads only"
msgstr "虚拟线程只对I/O绑定的工作负载有用"

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"We now know that we can create way more virtual threads than platform threads. One could be tempted to use virtual threads\n"
"to perform long computations (CPU-bound workload).\n"
"This is useless if not counterproductive.\n"
"CPU-bound doesn't consist in quickly swapping threads while they need to wait for the completion of an I/O but in leaving\n"
"them attached to a CPU-core to actually compute something.\n"
"In this scenario, it is useless to have thousands of threads if we have tens of CPU-cores, virtual threads won't enhance\n"
"the performance of CPU-bound workloads."
msgstr ""

#. type: Title ==
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "Bringing virtual threads to reactive REST services"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Since virtual threads are disposable entities, the fundamental idea of quarkus-loom is to offload the execution of an\n"
"endpoint handler on a new virtual thread instead of running it on an event-loop (in the case of RESTeasy-reactive) or a\n"
"platform worker thread."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.\n"
"If the JDK is compatible (Java 19 or later versions) then the endpoint will be offloaded to a virtual thread.\n"
"It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual\n"
"thread is mounted."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"This annotation can only be used in conjunction with endpoints annotated with link:{blockingannotation}[@Blocking] or\n"
"considered blocking because of their signature.\n"
"You can visit xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking]\n"
"for more information."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Getting started"
msgstr "开始工作"

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy
msgid "Add the following import to your build file:"
msgstr "在你的构建文件中添加以下导入。"

#. type: Block title
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Block title
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "You also need to make sure that you are using the version 19 of Java, this can be enforced in your pom.xml file with the following:"
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "Virtual threads are still an experimental feature, you need to start your application with the `--enable-preview` flag:"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"The example below shows the differences between three endpoints, all of them querying a fortune in the database then\n"
"returning it to the client."
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy
msgid "the first one uses the traditional blocking style, it is considered blocking due to its signature."
msgstr "第一个是使用传统的阻断方式，由于其特征，它被认为是阻断。"

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "the second one uses Mutiny reactive streams in a declarative style, it is considered non-blocking due to its signature."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"the third one uses Mutiny reactive streams in a synchronous way, since it doesn't return a \"reactive type\" it is\n"
"considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"When using Mutiny, alternative \"xAndAwait\" methods are provided to be used with virtual threads.\n"
"They ensure that waiting for the completion of the I/O will not \"pin\" the carrier thread and deteriorate performance.\n"
"Pinning is a phenomenon that we describe in xref:Pinning cases[this section]."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"In other words, the mutiny environment is a safe environment for virtual threads.\n"
"The guarantees offered by Mutiny are detailed later."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "Simplifying complex logic"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"The previous example is trivial and doesn't capture how imperative style can simplify complex reactive operations.\n"
"Below is a more complex example.\n"
"The endpoints must now fetch all the fortunes in the database, then append a quote to each fortune before finally returning\n"
"the result to the client."
msgstr ""

#. type: Title ==
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy, no-wrap
msgid "Pinning cases"
msgstr "钉子案"

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"The notion of \"cheap blocking\" might not always be true: in certain occasions a virtual thread might \"pin\" its carrier\n"
"(the platform thread it is mounted upon).\n"
"In this situation, the platform thread is blocked exactly as it would have been in a typical blocking scenario."
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy
msgid "According to link:{vthreadjep}[JEP 425] this can happen in two situations:"
msgstr "根据 link:{vthreadjep}[JEP425] ，这可能发生在两种情况下。"

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy
msgid "when a virtual thread performs a blocking operation inside a `synchronized` block or method"
msgstr "当一个虚拟线程在一个 `synchronized` 块或方法内执行一个阻塞操作时"

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
#, fuzzy
msgid "when it executes a blocking operation inside a native method or a foreign function"
msgstr "当它在一个本地方法或外国函数中执行一个阻塞操作时"

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"It can be fairly easy to avoid these situations in our own code, but it is hard to verify every dependency we use.\n"
"Typically, while experimenting with virtual-threads, we realized that using the link:{pgsql-driver}[postgresql-JDBC driver]\n"
"results in frequent pinning."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "The JDBC problem"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Our experiments so far show that when a virtual thread queries a database using the JDBC driver, it will pin its carrier\n"
"thread during the entire operation."
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "Let's show the code of the `findAllBlocking()` method we used in the first example"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"The actual query happens at `ResultSet rs = preparedStatement.executeQuery();`, here is how it is implemented in the\n"
"postgresql-jdbc driver 42.5.0:"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"This `synchronized` block is the culprit.\n"
"Replacing it with a lock is a good solution, but it won't be enough: `synchronized` blocks are also used in `executeWithFlags(int flag)`.\n"
"A systematic review of the postgresql-jdbc driver is necessary to make sure that it is compliant with virtual threads."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "Reactive drivers at the rescue"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"The vertx-sql-client is a reactive client, hence it is not supposed to block while waiting for the completion of a\n"
"transaction with the database.\n"
"However, when using the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] it is possible to use a variant method\n"
"that will await for the completion of the transaction, mimicking a blocking behaviour."
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "Below is the `FortuneRepository` except the blocking we've seen earlier has been replaced by reactive methods."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Contrary to the link:{pgsql-driver}[postgresql-jdbc driver], no `synchronized` block is used where it shouldn't be, and\n"
"the `await` behaviour is implemented using locks and latches that won't cause pinning."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Using the synchronous methods of the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] along with virtual threads\n"
"will allow you to use the synchronous blocking style, avoid pinning the carrier thread, and get performance close to a pure\n"
"reactive implementation."
msgstr ""

#. type: Title ==
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "A point about performance"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"Our experiments seem to indicate that Quarkus with virtual threads will scale better than Quarkus blocking (offloading\n"
"the computation on a pool of platform worker threads) but not as well as Quarkus reactive.\n"
"The memory consumption especially might be an issue: if your system needs to keep its memory footprint low we would\n"
"advise you stick to using reactive constructs."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"This degradation of performance doesn't seem to come from virtual threads themselves but from the interactions between\n"
"Vert.x/Netty (Quarkus underlying reactive engine) and the virtual threads.\n"
"This was illustrated in the issue that we will now describe."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "The Netty problem"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"For JSON serialization, Netty uses their custom implementation of thread locals, `FastThreadLocal` to store buffers.\n"
"When using virtual threads in quarkus, the number of virtual threads simultaneously living in the service is directly\n"
"related to the incoming traffic.\n"
"It is possible to get hundreds of thousands, if not millions, of them."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"If they need to serialize some data to JSON they will end up creating as many instances of `FastThreadLocal`, resulting\n"
"on a massive memory consumption as well as exacerbated pressure on the garbage collector.\n"
"This will eventually affect the performance of the application and inhibit its scalability."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"This is a perfect example of the mismatch between the reactive stack and the virtual threads.\n"
"The fundamental hypothesis are completely different and result in different optimizations.\n"
"Netty expects a system using few event-loops (as many event-loops as CPU cores by default in Quarkus), but it gets hundreds\n"
"of thousands of threads.\n"
"You can refer to link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[this mail] to get more information\n"
"on how we envision our future with virtual threads."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "Our solution to the Netty problem"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"In order to avoid this wasting of resource without modifying Netty upstream, we wrote an extension that modifies the\n"
"bytecode of the class responsible for creating the thread locals at build time.\n"
"Using this extension, performance of virtual threads in Quarkus for the Json Serialization test of the Techempower suite\n"
"increased by nearly 80%, making it almost as good as reactive endpoints."
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "To use it, it needs to be added as a dependency:"
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "Furthermore, some operations undertaken by this extension need special access, it is necessary to"
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "compile the application with the flag `-Dnet.bytebuddy.experimental`"
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "open the `java.base.lang` module at runtime with the flag `--add-opens java.base/java.lang=ALL-UNNAMED`"
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "This extension is only intended to improve performance, it is perfectly fine not to use it."
msgstr ""

#. type: Title ===
#: _versions/3.2/guides/virtual-threads.adoc
#, no-wrap
msgid "Concerning dev mode"
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"If you want to use quarkus with the dev mode, it won't be possible to manually specify the flags we mentioned along this guide.\n"
"Instead, you want to specify them all in the configuration of the `quarkus-maven-plugin` as presented below."
msgstr ""

#: _versions/3.2/guides/virtual-threads.adoc
msgid ""
"If you don't want to specify the opening of the `java.lang` module in your pom.xml file, you can also specify it as an argument\n"
"when you start the dev mode."
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "The configuration of the quarkus-maven-plugin will be simpler:"
msgstr ""

#. type: Plain text
#: _versions/3.2/guides/virtual-threads.adoc
msgid "And the command will become:"
msgstr ""
