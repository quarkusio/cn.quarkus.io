msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "CDI Integration Guide"
msgstr "CDI 集成指南"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"ArC, the CDI container in Quarkus, is bootstrapped at build time.\n"
"To integrate with the container, https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#spi_lite[CDI Build Compatible Extensions, window=\"_blank\"] can be used, as well as a Quarkus-specific extension API.\n"
"CDI Portable Extensions are not and cannot be supported.\n"
"This guide focuses on the Quarkus-specific extensions API."
msgstr "ArC 是 Quarkus 中的 CDI 容器，在构建时进行引导。要与容器集成，可以使用 link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#spi_lite[CDI Build Compatible Extensions] 以及 Quarkus 专用的扩展 API。我们不支持 CDI 可移植扩展。本指南重点介绍 Quarkus 专用扩展 API。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The container is bootstrapped in multiple phases.\n"
"From a high level perspective these phases go as follows:"
msgstr "容器的启动分为多个阶段。从高层次的角度来看，这些阶段如下："

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Initialization"
msgstr "初始化"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Bean discovery"
msgstr "发现豆子"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Registration of synthetic components"
msgstr "合成成分的注册"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Validation"
msgstr "验证"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n"
"_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n"
"Subsequently, the extensions can register _synthetic components_.\n"
"Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n"
"Finally, the _deployment is validated_.\n"
"For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers."
msgstr "在 _初始化_ 阶段，将进行准备工作并注册自定义上下文。然后，容器会分析所有应用程序类，识别 _Bean_ ，并根据提供的元数据将它们连接在一起。随后，扩展可以注册 _合成组件_ 。这些组件的属性完全由扩展控制，即不是从现有类派生出来的。最后，对 _部署进行验证_ 。例如，容器会验证应用程序中的每个注入点，如果没有满足给定所需类型和限定条件的 Bean，则构建失败。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In <<cdi-reference.adoc#dev_mode,dev mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format."
msgstr "通过启用附加日志，您可以看到更多有关引导程序的信息。只需使用 `-X` 或 `--debug` 运行 Maven 构建，然后在包含 `io.quarkus.arc` 的行中搜索即可。在 xref:cdi-reference.adoc#dev_mode[开发模式] 下，您可以使用 `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` ，两个特殊的端点也会自动注册，以 JSON 格式提供一些基本的调试信息。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Quarkus build steps can produce and consume various build items and hook into each phase.\n"
"In the following sections we will describe all the relevant build items and common scenarios."
msgstr "Quarkus 的构建步骤可以生成和消耗各种构建项，并与每个阶段挂钩。在下面的章节中，我们将介绍所有相关的构建项和常见情况。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Metadata Sources"
msgstr "元数据源"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Classes and annotations are the primary source of bean-level metadata.\n"
"The initial metadata are read from the _bean archive index_, an immutable https://github.com/wildfly/jandex[Jandex index, window=\"_blank\"] which is built from various sources during <<cdi-reference.adoc#bean_discovery,bean discovery>>.\n"
"However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n"
"Moreover, extensions can also register <<synthetic_beans,synthetic components>>.\n"
"This is an important aspect to realize when integrating CDI components in Quarkus."
msgstr "类和注解是 Bean 层元数据的主要来源。初始元数据是从 Bean _档案索引_ 中读取的，这是一个不可变的 link:https://github.com/wildfly/jandex[Jandex] 索引，是在 xref:cdi-reference.adoc#bean_discovery[Bean 发现] 过程中从各种来源建立的。不过，扩展可以在引导的某些阶段添加、删除或转换元数据。此外，扩展还可以注册 xref:synthetic_beans[合成组件] 。这是在 Quarkus 中集成 CDI 组件时需要认识到的一个重要方面。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n"
"For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored."
msgstr "通过这种方式，扩展可以将原本会被忽略的类转化为 Bean，反之亦然。例如，一个声明了 `@Scheduled` 方法的类，即使没有注释 bean 定义注解，通常也会被忽略，但它总是注册为 bean。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - My Class Is Not Recognized as a Bean"
msgstr "使用案例 - 我的类未被识别为 Bean"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n"
"Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.\n"
"There are several reasons why a class is not recognized and also several ways to fix it.\n"
"In the first step we should identify the _reason_."
msgstr "`UnsatisfiedResolutionException` 表示 xref:cdi.adoc#typesafe_resolution[类型安全解决] 过程中出现了问题。有时，即使类路径上有一个看起来符合注入条件的类，也无法满足注入点的要求。类无法被识别有几种原因，也有几种解决方法。第一步，我们应找出 _原因_ 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Reason 1_: Class Is Not discovered"
msgstr "_原因 1_ ：没有发现班级"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n"
"It might happen that the class is not part of the application index.\n"
"For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "Quarkus 具有 xref:cdi-reference.adoc#bean_discovery[简化的发现] 功能。有可能出现类不在应用程序索引中的情况。例如，Quarkus 扩展 _程序运行模块_ 中的类不会被自动索引。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"_Solution_: Use the `AdditionalBeanBuildItem`.\n"
"This build item can be used to specify one or more additional classes to be analyzed during the discovery.\n"
"Additional bean classes are transparently added to the application index processed by the container."
msgstr "_解决方案_ ：使用 `AdditionalBeanBuildItem` 。此构建项可用于指定一个或多个要在发现过程中分析的附加类。附加 Bean 类会透明地添加到容器处理的应用程序索引中。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "It is not possible to conditionally enable/disable additional beans via the `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` and `@UnlessBuildProperty` annotations as described in <<cdi-reference.adoc#enable_build_profile>> and <<cdi-reference.adoc#enable_build_properties>>. Extensions should inspect the configuration or the current profile and only produce an `AdditionalBeanBuildItem` if really needed."
msgstr "如 <<cdi-reference.adoc#enable_build_profile>> 和 <<cdi-reference.adoc#enable_build_properties>> 所述，无法通过 `@IfBuildProfile` 、 `@UnlessBuildProfile` 、 `@IfBuildProperty` 和 `@UnlessBuildProperty` 注释有条件地启用/禁用其他 Bean。扩展应检查配置或当前配置文件，只有在确实需要时才生成 `AdditionalBeanBuildItem` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`AdditionalBeanBuildItem` Example"
msgstr "`AdditionalBeanBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`AdditionalBeanBuildItem.Builder` can be used for more complex use cases."
msgstr "`AdditionalBeanBuildItem.Builder` 可用于更复杂的用例。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n"
"If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n"
"However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n"
"See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details."
msgstr "通过 `AdditionalBeanBuildItem` 添加的 Bean 类默认是 _可移除_ 的。如果容器认为它们 xref:cdi-reference.adoc#remove_unused_beans[未被使用] ，它们就会被忽略。不过，您可以使用 `AdditionalBeanBuildItem.Builder.setUnremovable()` 方法来指示容器永不删除通过此构建项注册的 Bean 类。另请参阅 xref:cdi-reference.adoc#remove_unused_beans[移除未使用的 Bean] 和 <<unremovable_builditem>> 以了解更多详情。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n"
"The default scope is only used if there is no scope declared on the bean class."
msgstr "也可以通过 `AdditionalBeanBuildItem.Builder#setDefaultScope()` 设置默认作用域。默认作用域只有在 bean 类没有声明作用域时才会使用。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "If no default scope is specified the `@Dependent` pseudo-scope is used."
msgstr "如果没有指定默认范围，则使用 `@Dependent` 伪范围。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Reason 2_: Class Is Discovered but Has No Bean Defining Annotation"
msgstr "_原因 2_ ：发现了类，但没有 Bean 定义注释"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"In Quarkus, the application is represented by a single bean archive with the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n"
"Therefore, bean classes that don't have a https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n"
"Bean defining annotations are declared on the class-level and include scopes, stereotypes and `@Interceptor`."
msgstr "在 Quarkus 中，应用程序由单个 Bean 档案表示，其 Bean link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#default_bean_discovery[发现模式] 为 link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#default_bean_discovery[annotated 。因此，没有 bean 定] link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bean_defining_annotations[义注解] 的 bean 类将被忽略。Bean 定义注解在类级别声明，包括作用域、定型和 `@Interceptor` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions."
msgstr "_解决方法 1_ ：使用 `AutoAddScopeBuildItem` .此构建项目可用于为满足特定条件的类添加作用域。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`AutoAddScopeBuildItem` Example"
msgstr "`AutoAddScopeBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Find all classes annotated with `@Scheduled`."
msgstr "查找注释为 `@Scheduled` 的所有类。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically."
msgstr "将 `@Singleton` 添加为默认作用域。已经注释了作用域的类将自动跳过。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`."
msgstr "_解决方案 2_ ：如果需要处理使用特定注解注释的类，那么可以通过 `BeanDefiningAnnotationBuildItem` 扩展 Bean 定义注解集。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`BeanDefiningAnnotationBuildItem` Example"
msgstr "`BeanDefiningAnnotationBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations."
msgstr "将 `org.eclipse.microprofile.graphql.GraphQLApi` 添加到 bean 定义注解集。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n"
"However, you can change the default behavior.\n"
"See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details."
msgstr "默认情况下，通过 `BeanDefiningAnnotationBuildItem` 添加的 Bean 类是 _不可移除_ 的，也就是说，生成的 Bean 类即使被视为未使用，也不得移除。不过，您可以更改默认行为。更多详情，请参阅 xref:cdi-reference.adoc#remove_unused_beans[移除未使用的 Bean] 和 <<unremovable_builditem>> 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is also possible to specify the default scope.\n"
"The default scope is only used if there is no scope declared on the bean class."
msgstr "还可以指定默认作用域。默认作用域只有在 bean 类没有声明作用域时才会使用。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed"
msgstr "_原因 3_ ：类已被发现并有豆子定义注释，但已被删除"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n"
"This optimization allows for _framework-level dead code elimination_.\n"
"In few special cases, it's not possible to correctly identify an unused bean.\n"
"In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n"
"Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`."
msgstr "默认情况下，容器会在构建过程中 xref:cdi-reference.adoc#remove_unused_beans[移除所有未使用的 Bean] 。这种优化可以 _消除框架级的死代码_ 。在少数特殊情况下，无法正确识别未使用的 Bean。特别是，Quarkus 还不能检测 `CDI.current()` 静态方法的使用情况。扩展程序可以通过生成 `UnremovableBeanBuildItem` .NET 方法来消除可能的误报。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`UnremovableBeanBuildItem` Example"
msgstr "`UnremovableBeanBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Make all classes annotated with `@Startup` unremovable."
msgstr "使所有注释为 `@Startup` 的类都不可移动。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding"
msgstr "使用案例 - 我的注释未被识别为限定符或拦截器绑定"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is likely that the annotation class is not part of the application index.\n"
"For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "注释类很可能不是应用程序索引的一部分。例如，Quarkus 扩展 _程序运行模块_ 中的类不会被自动索引。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>."
msgstr "_解决方案_ ：如 <<additional_bean_build_item>> 中所述，使用 `AdditionalBeanBuildItem` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - I Need To Transform Annotation Metadata"
msgstr "使用案例 - 我需要转换注释元数据"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"In some cases, it's useful to be able to modify the annotation metadata.\n"
"Quarkus provides a powerful alternative to https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#process_annotated_type[`jakarta.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_enhancement[`jakarta.enterprise.inject.build.compatible.spi.Enhancement`, window=\"_blank\"].\n"
"With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes."
msgstr "在某些情况下，修改注释元数据非常有用。Quarkus 为 link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#process_annotated_type[jakarta.enterprise.inject.spi.ProcessAnnotatedType] 和 link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_enhancement[jakarta.enterprise.inject.build.compatible.spi.Enhancement] .通过 `AnnotationsTransformerBuildItem` ，我们可以覆盖 Bean 类上存在的注解。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Keep in mind that annotation transformers must be produced _before_ the bean discovery starts."
msgstr "请记住，注释转换器必须 _在_ 豆发现开始 _之前_ 生成。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"For example, you might want to add an interceptor binding to a specific bean class.\n"
"You can use a convenient builder-like API to create a transformer instance:"
msgstr "例如，您可能想添加一个拦截器绑定到特定的 Bean 类。您可以使用类似于构建器的便捷 API 来创建转换器实例："

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Builder Example"
msgstr "施工实例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The transformer is only applied to classes."
msgstr "变压器只适用于类。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Only apply the transformation if the class name equals to `org.acme.Bar`."
msgstr "只有当类名等于 `org.acme.Bar` 时，才会应用转换。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Add the `@MyInterceptorBinding` annotation."
msgstr "添加 `@MyInterceptorBinding` 注释。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The example above can be rewritten with an anonymous class:"
msgstr "上面的例子可以用匿名类重写："

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`AnnotationsTransformerBuildItem` Example"
msgstr "`AnnotationsTransformerBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`."
msgstr "如果类名等于 `org.acme.Bar` ，则添加 `@MyInterceptorBinding` 。不要忘记调用 `Transformation#done()` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`."
msgstr "构建步骤可通过 `TransformedAnnotationsBuildItem` 查询指定注释目标的转换注释。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`TransformedAnnotationsBuildItem` Example"
msgstr "`TransformedAnnotationsBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations."
msgstr "`TransformedAnnotationsBuildItem.getAnnotations()` 将返回一组可能经过转换的注释。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "There are other build items specialized in transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>."
msgstr "还有其他专门用于改造的构建项目： <<additional_interceptor_bindings>> 和 <<injection_point_transformation>> 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "How to Enable Trace Logging for Annotation Transformers"
msgstr "如何为注释转换器启用跟踪日志功能"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "You can set the `TRACE` level for the category `io.quarkus.arc.processor` and try to analyze the log output afterwards."
msgstr "您可以为类别 `io.quarkus.arc.processor` 设置 `TRACE` 级别，然后尝试分析日志输出。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`application.properties` Example"
msgstr "`application.properties` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "您还需要调整相关类别的最低日志级别。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - Inspect Beans, Observers and Injection Points"
msgstr "用例 - 检查豆、观察者和注入点"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution 1_: `BeanDiscoveryFinishedBuildItem`"
msgstr "_解决方案 1_ ： `BeanDiscoveryFinishedBuildItem`"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.\n"
"However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered."
msgstr "`BeanDiscoveryFinishedBuildItem` 的用户可以轻松检查应用程序中注册的所有基于类的 Bean、观察者和注入点。但是，合成类和观察者 _不包括在内_ ，因为该构建项是 _在_ 合成组件注册 _之前_ 生成的。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Additionally, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "此外，从 `BeanDiscoveryFinishedBuildItem#getBeanResolver()` 返回的 Bean 解析器可用于应用类型安全解析规则，例如，查找是否存在满足所需类型和限定条件特定组合的 Bean。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`BeanDiscoveryFinishedBuildItem` Example"
msgstr "`BeanDiscoveryFinishedBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The resulting list will not contain `@Named` synthetic beans."
msgstr "生成的列表将不包含 `@Named` 合成豆。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution 2_: `SynthesisFinishedBuildItem`"
msgstr "_解决方案 2_ ： `SynthesisFinishedBuildItem`"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered."
msgstr "`SynthesisFinishedBuildItem` 的用户可以轻松检查应用程序中注册的所有 Bean、观察者和注入点。合成豆和观察者也包括在内，因为该构建项是 _在_ 合成组件注册 _后_ 生成的。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Additionally, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "此外，从 `SynthesisFinishedBuildItem#getBeanResolver()` 返回的 Bean 解析器可用于应用类型安全解析规则，例如，查找是否存在满足所需类型和限定条件特定组合的 Bean。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`SynthesisFinishedBuildItem` Example"
msgstr "`SynthesisFinishedBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The resulting list will contain `@Named` synthetic beans."
msgstr "生成的列表将包含 `@Named` 个合成豆。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - The Need for Synthetic Beans"
msgstr "使用案例 - 合成豆的需求"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Sometimes it is practical to be able to register a _synthetic bean_.\n"
"Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n"
"Instead, all the attributes are defined by an extension.\n"
"In regular CDI, this could be achieved using the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_synthesis[`SyntheticComponents.addBean()`] methods."
msgstr "有时，注册 _合成_ Bean 也很实用。合成 Bean 的 Bean 属性并非源自 Java 类、方法或字段。相反，所有属性都是由扩展定义的。在常规的 CDI 中，可以使用 link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#after_bean_discovery[AfterBeanDiscovery.addBean()] 和 link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_synthesis[SyntheticComponents.addBean()] 方法来实现。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`."
msgstr "_解决方案_ ：如果需要注册合成豆，请使用 `SyntheticBeanBuildItem` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`SyntheticBeanBuildItem` Example 1"
msgstr "`SyntheticBeanBuildItem` 示例 1"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Generate the bytecode of the `jakarta.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation."
msgstr "生成 `jakarta.enterprise.context.spi.Contextual#create(CreationalContext<T>)` 实现的字节码。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The output of a bean configurator is recorded as bytecode.\n"
"Therefore, there are some limitations in how a synthetic bean instance is created at runtime.\n"
"You can:"
msgstr "Bean 配置器的输出记录为字节码。因此，在运行时创建合成 Bean 实例的方式会受到一些限制。您可以"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`."
msgstr "通过 `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)` 直接生成 `Contextual#create(CreationalContext<T>)` 方法的字节码。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Pass a subclass of `io.quarkus.arc.BeanCreator` via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some build-time parameters via `ExtendedBeanConfigurator#param()` and synthetic injection points via `ExtendedBeanConfigurator#addInjectionPoint()`."
msgstr "通过 `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)` 传递 `io.quarkus.arc.BeanCreator` 的子类，并可能通过 `ExtendedBeanConfigurator#param()` 指定一些构建时参数，以及通过 `ExtendedBeanConfigurator#addInjectionPoint()` 指定合成注入点。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder` method>> and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)`, `ExtendedBeanConfigurator#runtimeProxy(Object)`,  `ExtendedBeanConfigurator#supplier(Supplier<?>)` or `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)`."
msgstr "通过 xref:writing-extensions.adoc#bytecode-recording[@Recorder 方法] 返回的代理生成运行时实例，并通过 `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` , `ExtendedBeanConfigurator#runtimeProxy(Object)` , `ExtendedBeanConfigurator#supplier(Supplier<?>)` 或 `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)` 进行设置。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`SyntheticBeanBuildItem` Example 2"
msgstr "`SyntheticBeanBuildItem` 示例 2"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "By default, a synthetic bean is initialized during `STATIC_INIT`."
msgstr "默认情况下，合成 Bean 是在 `STATIC_INIT` 期间初始化的。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The bean instance is supplied by a value returned from a recorder method."
msgstr "bean 实例由记录器方法返回的值提供。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.\n"
"See the <<writing-extensions.adoc#bootstrap-three-phases,Three Phases of Bootstrap and Quarkus Philosophy>> for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`."
msgstr "可以在 `RUNTIME_INIT` 期间标记要初始化的合成 Bean。有关 `STATIC_INIT` 和 `RUNTIME_INIT` 之间区别的更多信息，请参阅 xref:writing-extensions.adoc#bootstrap-three-phases[Bootstrap 的三个阶段] 和 xref:writing-extensions.adoc#bootstrap-three-phases[Quarkus 理念] 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`RUNTIME_INIT` `SyntheticBeanBuildItem` Example"
msgstr "`RUNTIME_INIT` `SyntheticBeanBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase."
msgstr "记录器必须在 `ExecutionTime.RUNTIME_INIT` 阶段执行。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The bean instance is initialized during `RUNTIME_INIT`."
msgstr "bean 实例在 `RUNTIME_INIT` 期间初始化。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:"
msgstr "在 `RUNTIME_INIT` 期间初始化的合成 Bean 不得在 `STATIC_INIT` 期间被访问。访问运行时初始化合成 Bean 的 `RUNTIME_INIT` 构建步骤应消耗 `SyntheticBeansRuntimeInitBuildItem` ："

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "This build step must be executed after `syntheticBean()` completes."
msgstr "该构建步骤必须在 `syntheticBean()` 完成后执行。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized."
msgstr "该记录器方法会调用 `Foo` Bean 实例，因此我们需要确保构建步骤在所有合成 Bean 初始化后执行。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus."
msgstr "也可以使用 `BeanRegistrationPhaseBuildItem` 注册合成 bean。不过，我们建议扩展作者坚持使用 `SyntheticBeanBuildItem` ，因为它对 Quarkus 来说更习惯。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Synthetic Injection Points"
msgstr "合成注射点"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"A synthetic bean may register a synthetic injection point via the `ExtendedBeanConfigurator#addInjectionPoint()` method.\n"
"This injection point is validated at build time and considered when <<cdi-reference.adoc#remove_unused_beans,detecting unused beans>>.\n"
"The injected reference is accessible through the `SyntheticCreationalContext#getInjectedReference()` methods at runtime."
msgstr "合成 Bean 可通过 `ExtendedBeanConfigurator#addInjectionPoint()` 方法注册合成注入点。该注入点会在构建时进行验证，并在 xref:cdi-reference.adoc#remove_unused_beans[检测未使用的 Bean] 时予以考虑。注入的引用可在运行时通过 `SyntheticCreationalContext#getInjectedReference()` 方法访问。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Synthetic Injection Point - Build Step Example"
msgstr "合成材料注射点 - 建造步骤示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "A synthetic injection point with required type `Bar` was added; this is an equivalent of `@Inject Bar`."
msgstr "添加了一个所需类型为 `Bar` 的合成注入点；这相当于 `@Inject Bar` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The bean instance is created with a function returned from a recorder method."
msgstr "bean 实例是通过记录器方法返回的函数创建的。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Synthetic Injection Point - Recorder Example"
msgstr "合成注射点 - 记录器示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Pass a contextual reference of `Bar` to the constructor of `Foo`."
msgstr "将 `Bar` 的上下文引用传递给 `Foo` 的构造函数。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - Synthetic Observers"
msgstr "使用案例 - 合成观测器"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension."
msgstr "与 xref:synthetic_beans[合成 bean] 类似，合成观察者方法的属性并非源自 Java 方法。相反，所有属性都是由扩展定义的。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`."
msgstr "_解决方案_ ：如果需要注册合成观测器，请使用 `ObserverRegistrationPhaseBuildItem` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "消耗 `ObserverRegistrationPhaseBuildItem` 的构建步骤应始终为该构建项生成 `ObserverConfiguratorBuildItem` 或至少注入 `BuildProducer` ，否则它可能会被忽略或在错误的时间（如在正确的 CDI 引导阶段之后）被处理。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`ObserverRegistrationPhaseBuildItem` Example"
msgstr "`ObserverRegistrationPhaseBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The output of a `ObserverConfigurator` is recorded as bytecode.\n"
"Therefore, there are some limitations in how a synthetic observer is invoked at runtime.\n"
"Currently, you must generate the bytecode of the method body directly."
msgstr "`ObserverConfigurator` 的输出记录为字节码。因此，在运行时如何调用合成观察者存在一些限制。目前，您必须直接生成方法体的字节码。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - I Have a Generated Bean Class"
msgstr "使用案例 - 我有一个生成的 Bean 类"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"No problem.\n"
"You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`."
msgstr "没问题。您可以手动生成 Bean 类的字节码，然后只需生成 `GeneratedBeanBuildItem` 而不是 `GeneratedClassBuildItem` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`GeneratedBeanBuildItem` Example"
msgstr "`GeneratedBeanBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs."
msgstr "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` 可以轻松地从 Gizmo 结构中生成 s。 `GeneratedBeanBuildItem`"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "The resulting bean class is something like `public class @Singleton MyBean { }`."
msgstr "生成的 Bean 类类似于 `public class @Singleton MyBean { }` 。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - I Need to Validate the Deployment"
msgstr "用例 - 我需要验证部署"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong."
msgstr "有时，扩展需要检查 Bean、观察者和注入点，然后执行额外的验证，并在出现问题时使构建失败。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`."
msgstr "_解决方案_ 如果扩展需要验证部署，则应使用 `ValidationPhaseBuildItem` .NET Framework。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "消耗 `ValidationPhaseBuildItem` 的构建步骤应始终生成 `ValidationErrorBuildItem` 或至少为该构建项注入 `BuildProducer` ，否则它可能会被忽略或在错误的时间（如在正确的 CDI 引导阶段之后）被处理。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method."
msgstr "您可以通过 `ValidationPhaseBuildItem.getContext().beans()` 方法返回的 `BeanStream` 方便地过滤所有已注册的豆子。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - Register a Custom CDI Context"
msgstr "用例 - 注册自定义 CDI 上下文"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Sometimes extensions need to extend the set of built-in CDI contexts."
msgstr "有时，扩展需要扩展内置的 CDI 上下文集。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`."
msgstr "_解决方案_ 如果需要注册自定义上下文，请使用 `ContextRegistrationPhaseBuildItem` ."

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "消耗 `ContextRegistrationPhaseBuildItem` 的构建步骤应始终生成 `ContextConfiguratorBuildItem` 或至少为该构建项注入 `BuildProducer` ，否则它可能会被忽略或在错误的时间（如在正确的 CDI 引导阶段之后）被处理。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`ContextRegistrationPhaseBuildItem` Example"
msgstr "`ContextRegistrationPhaseBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations."
msgstr "此外，通过 `ContextRegistrationPhaseBuildItem` 注册自定义 CDI 上下文的每个扩展还应该生成 `CustomScopeBuildItem` ，以便将自定义作用域注解名称贡献给 bean 定义注解集。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`CustomScopeBuildItem` Example"
msgstr "`CustomScopeBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "What if I Need to Know All the Scopes Used in the Application?"
msgstr "如果我需要了解应用程序中使用的所有作用域，该怎么办？"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."
msgstr "_解决方案_ ：可以在构建步骤中注入 `CustomScopeAnnotationsBuildItem` ，并使用 `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()` 等便捷方法。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - Additional Interceptor Bindings"
msgstr "使用案例 - 附加拦截器绑定"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@jakarta.interceptor.InterceptorBinding` as an interceptor binding.\n"
"This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n"
"We are going to use `InterceptorBindingRegistrarBuildItem` to get it done."
msgstr "在极少数情况下，以编程方式将未注明 `@jakarta.interceptor.InterceptorBinding` 的现有注解注册为拦截器绑定可能很方便。这与 CDI 通过 `BeforeBeanDiscovery#addInterceptorBinding()` 实现的功能类似。我们将使用 `InterceptorBindingRegistrarBuildItem` 来实现这一目标。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`InterceptorBindingRegistrarBuildItem` Example"
msgstr "`InterceptorBindingRegistrarBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - Additional Qualifiers"
msgstr "使用案例 - 附加限定符"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Sometimes it might be useful to register an existing annotation that is not annotated with `@jakarta.inject.Qualifier` as a CDI qualifier.\n"
"This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.\n"
"We are going to use `QualifierRegistrarBuildItem` to get it done."
msgstr "有时，将未注明 `@jakarta.inject.Qualifier` 的现有注释注册为 CDI 限定符可能很有用。这与 CDI 通过 `BeforeBeanDiscovery#addQualifier()` 实现的功能类似。我们将使用 `QualifierRegistrarBuildItem` 来实现这一目标。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`QualifierRegistrarBuildItem` Example"
msgstr "`QualifierRegistrarBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - Additional Stereotypes"
msgstr "用例 - 附加定型"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"It is sometimes useful to register an existing annotation that is not annotated with `@jakarta.enterprise.inject.Stereotype` as a CDI stereotype.\n"
"This is similar to what CDI achieves through `BeforeBeanDiscovery#addStereotype()`.\n"
"We are going to use `StereotypeRegistrarBuildItem` to get it done."
msgstr "有时，将未注明 `@jakarta.enterprise.inject.Stereotype` 的现有注释注册为 CDI 定型也很有用。这与 CDI 通过 `BeforeBeanDiscovery#addStereotype()` 实现的功能类似。我们将使用 `StereotypeRegistrarBuildItem` 来实现这一目标。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`StereotypeRegistrarBuildItem` Example"
msgstr "`StereotypeRegistrarBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "If the newly registered stereotype annotation doesn't have the appropriate meta-annotations, such as scope or interceptor bindings, use an <<annotations_transformer_build_item,annotation transformation>> to add them."
msgstr "如果新注册的定型注解没有相应的元注解（如作用域或拦截器绑定），可使用 xref:annotations_transformer_build_item[注解转换] 来添加它们。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - Injection Point Transformation"
msgstr "使用案例 - 注射点转换"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n"
"You can do just that with `InjectionPointTransformerBuildItem`.\n"
"The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:"
msgstr "偶尔以编程方式更改注入点的限定符也很方便。您可以使用 `InjectionPointTransformerBuildItem` 来实现这一功能。下面的示例展示了如何对类型为 `Foo` 且包含限定符 `MyQualifier` 的注入点进行转换："

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`InjectionPointTransformerBuildItem` Example"
msgstr "`InjectionPointTransformerBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.)."
msgstr "理论上，您可以使用 xref:annotations_transformer_build_item[AnnotationsTransformer 来实现同样] xref:annotations_transformer_build_item[的] 目标。然而，有一些不同之处使 `InjectionPointsTransformer` 更适合这项特殊任务：(1) 注释转换器在发现 Bean 时应用于所有类，而 `InjectionPointsTransformer` 只在发现 Bean 后应用于已发现的注入点；(2) 使用 `InjectionPointsTransformer` 时，您不需要处理各种类型的注入点（字段、初始化方法的参数等）。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Use Case - Resource Annotations and Injection"
msgstr "使用案例 - 资源注解和注入"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.\n"
"An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation."
msgstr "`ResourceAnnotationBuildItem` 可用于指定资源注释，从而可以解析非 CDI 注入点，如 Jakarta EE 资源。集成商还必须提供相应的 `io.quarkus.arc.ResourceReferenceProvider` 服务提供商实现。"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`ResourceAnnotationBuildItem` Example"
msgstr "`ResourceAnnotationBuildItem` 示例"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Available Build Time Metadata"
msgstr "可用的构建时间元数据"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.\n"
"The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:"
msgstr "任何使用 `BuildExtension.BuildContext` 的上述扩展都可以利用在构建过程中生成的某些构建时间元数据。 `io.quarkus.arc.processor.BuildExtension.Key` 中的内置键是"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "ANNOTATION_STORE"
msgstr "注释存储"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers"
msgstr "包含一个 `AnnotationStore` ，用于保存应用注释转换器后所有 `AnnotationTarget` 注释的信息"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "INJECTION_POINTS"
msgstr "注入点"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<InjectionPointInfo>` containing all injection points"
msgstr "`Collection<InjectionPointInfo>` 包含所有注射点"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "BEANS"
msgstr "豆类"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<BeanInfo>` containing all beans"
msgstr "`Collection<BeanInfo>` 菽"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "REMOVED_BEANS"
msgstr "REMOVED_BEANS"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<BeanInfo>` containing all the removed beans; see <<cdi-reference.adoc#remove_unused_beans,Removing unused beans>> for more information"
msgstr "`Collection<BeanInfo>` 包含所有移除的 Bean；更多信息，请参阅 xref:cdi-reference.adoc#remove_unused_beans[移除未使用的 Bean]"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "OBSERVERS"
msgstr "观察员"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<ObserverInfo>` containing all observers"
msgstr "`Collection<ObserverInfo>` 包含所有观察员"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "SCOPES"
msgstr "标准"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`Collection<ScopeInfo>` containing all scopes, including custom ones"
msgstr "`Collection<ScopeInfo>` 包含所有作用域，包括自定义作用域"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "QUALIFIERS"
msgstr "合格者"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all qualifiers"
msgstr "`Map<DotName, ClassInfo>` 包含所有限定词"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "INTERCEPTOR_BINDINGS"
msgstr "拦截器绑定"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all interceptor bindings"
msgstr "`Map<DotName, ClassInfo>` 包含所有拦截器绑定"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "STEREOTYPES"
msgstr "STEREOTYPES"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "`Map<DotName, StereotypeInfo>` containing all stereotypes"
msgstr "`Map<DotName, StereotypeInfo>` 包含所有陈规定型"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid ""
"To get hold of these, simply query the extension context object for given key.\n"
"Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.\n"
"If your extension attempts to retrieve metadata that wasn't yet produced, `null` will be returned.\n"
"Here is a summary of which extensions can access which metadata:"
msgstr "要获取这些元数据，只需查询扩展上下文对象中的给定键即可。请注意，这些元数据是在构建过程中提供的，这意味着扩展只能利用在调用扩展之前构建的元数据。如果扩展试图检索尚未生成的元数据， `null` 。下面总结了哪些扩展可以访问哪些元数据："

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "AnnotationsTransformer"
msgstr "注释转换器"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Shouldn't rely on any metadata as it could be used at any time in any phase of the bootstrap"
msgstr "不应依赖任何元数据，因为它可以在引导过程的任何阶段随时使用"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "ContextRegistrar"
msgstr "上下文注册器"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"
msgstr "可访问 `ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` 、 `STEREOTYPES`"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "InjectionPointsTransformer"
msgstr "注入点变换器"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "ObserverTransformer"
msgstr "观察者变换器"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "BeanRegistrar"
msgstr "BeanRegistrar"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "可访问 `ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` , `STEREOTYPES` , `BEANS` （仅限基于类的 bean）， `OBSERVERS` （仅限基于类的观察者）、 `INJECTION_POINTS`"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "ObserverRegistrar"
msgstr "观察员登记员"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "可访问 `ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` , `STEREOTYPES` , `BEANS` , `OBSERVERS` （仅限基于类的观察者）、 `INJECTION_POINTS`"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "BeanDeploymentValidator"
msgstr "BeanDeploymentValidator"

#: _versions/3.8/guides/cdi-integration.adoc
#, fuzzy
msgid "Has access to all build metadata"
msgstr "可访问所有构建元数据"
