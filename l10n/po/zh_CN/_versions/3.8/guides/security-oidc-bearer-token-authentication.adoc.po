msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "OpenID Connect (OIDC) Bearer token authentication"
msgstr "OpenID Connect (OIDC) 承载令牌验证"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Secure HTTP access to Jakarta REST (formerly known as JAX-RS) endpoints in your application with Bearer token authentication by using the Quarkus OpenID Connect (OIDC) extension."
msgstr "通过使用 Quarkus OpenID Connect (OIDC) 扩展，利用 Bearer 令牌身份验证功能确保对应用程序中 Jakarta REST（以前称为 JAX-RS）端点的 HTTP 访问安全。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Overview of the Bearer token authentication mechanism in Quarkus"
msgstr "Quarkus 不记名令牌身份验证机制概述"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Quarkus supports the Bearer token authentication mechanism through the Quarkus OpenID Connect (OIDC) extension."
msgstr "Quarkus 通过 Quarkus OpenID Connect（OIDC）扩展支持 Bearer 令牌验证机制。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The bearer tokens are issued by OIDC and OAuth 2.0 compliant authorization servers, such as link:https://www.keycloak.org[Keycloak]."
msgstr "不记名令牌由 OIDC 和 OAuth 2.0 兼容授权服务器（如 link:https://www.keycloak.org[Keycloak] ）发行。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Bearer token authentication is the process of authorizing HTTP requests based on the existence and validity of a bearer token.\n"
"The bearer token provides information about the subject of the call, which is used to determine whether or not an HTTP resource can be accessed."
msgstr "承载令牌验证是根据承载令牌的存在和有效性对 HTTP 请求进行授权的过程。承载令牌提供有关调用主体的信息，用于确定是否可以访问 HTTP 资源。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The following diagrams outline the Bearer token authentication mechanism in Quarkus:"
msgstr "下图概述了 Quarkus 的承载令牌身份验证机制："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Bearer token authentication mechanism in Quarkus with single-page application"
msgstr "Quarkus 中的单页面应用程序承载令牌认证机制"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"The Quarkus service retrieves verification keys from the OIDC provider.\n"
"The verification keys are used to verify the bearer access token signatures."
msgstr "Quarkus 服务从 OIDC 提供商处检索验证密钥。验证密钥用于验证不记名访问令牌签名。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The Quarkus user accesses the single-page application (SPA)."
msgstr "Quarkus 用户访问单页应用程序（SPA）。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The single-page application uses Authorization Code Flow to authenticate the user and retrieve tokens from the OIDC provider."
msgstr "单页面应用程序使用授权代码流对用户进行身份验证，并从 OIDC 提供商处检索令牌。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The single-page application uses the access token to retrieve the service data from the Quarkus service."
msgstr "单页面应用程序使用访问令牌从 Quarkus 服务中检索服务数据。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The Quarkus service verifies the bearer access token signature by using the verification keys, checks the token expiry date and other claims, allows the request to proceed if the token is valid, and returns the service response to the single-page application."
msgstr "Quarkus 服务使用验证密钥验证不记名访问令牌签名，检查令牌有效期和其他要求，如果令牌有效，则允许继续请求，并向单页应用程序返回服务响应。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The single-page application returns the same data to the Quarkus user."
msgstr "单页应用程序会向 Quarkus 用户返回相同的数据。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Bearer token authentication mechanism in Quarkus with Java or command line client"
msgstr "在 Quarkus 中使用 Java 或命令行客户端的承载令牌验证机制"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The client uses `client_credentials` that requires client id and secret or password grant, which requires client id, secret, username, and password to retrieve the access token from the OIDC provider."
msgstr "客户使用 `client_credentials` （需要客户 ID 和密码）或密码授予（需要客户 ID、密码、用户名和密码）从 OIDC 提供商处获取访问令牌。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The client uses the access token to retrieve the service data from the Quarkus service."
msgstr "客户端使用访问令牌从 Quarkus 服务中检索服务数据。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The Quarkus service verifies the bearer access token signature by using the verification keys, checks the token expiry date and other claims, allows the request to proceed if the token is valid, and returns the service response to the client."
msgstr "Quarkus 服务使用验证密钥验证不记名访问令牌签名，检查令牌有效期和其他要求，如果令牌有效，则允许继续请求，并向客户端返回服务响应。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"If you need to authenticate and authorize users by using OIDC authorization code flow, see the Quarkus xref:security-oidc-code-flow-authentication.adoc[OpenID Connect authorization code flow mechanism for protecting web applications] guide.\n"
"Also, if you use Keycloak and bearer tokens, see the Quarkus xref:security-keycloak-authorization.adoc[Using Keycloak to centralize authorization] guide."
msgstr "如果你需要通过使用 OIDC 授权代码流来验证和授权用户，请参阅《Quarkus xref:security-oidc-code-flow-authentication.adoc[OpenID Connect 授权代码流机制保护网络应用程序] 》指南。此外，如果使用 Keycloak 和承载令牌，请参阅《Quarkus xref:security-keycloak-authorization.adoc[使用 Keycloak 集中授权] 》指南。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"To learn about how you can protect service applications by using OIDC Bearer token authentication, see the following tutorial:\n"
"* xref:security-oidc-bearer-token-authentication-tutorial.adoc[Protect a web application by using OpenID Connect (OIDC) authorization code flow]."
msgstr "要了解如何通过使用 OIDC Bearer 令牌验证来保护服务应用程序，请参阅以下教程： xref:security-oidc-bearer-token-authentication-tutorial.adoc[* 使用 OpenID Connect (OIDC) 授权代码流保护网络应用程序] 。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For information about how to support multiple tenants, see the Quarkus xref:security-openid-connect-multitenancy.adoc[Using OpenID Connect Multi-Tenancy] guide."
msgstr "有关如何支持多租户的信息，请参阅《Quarkus xref:security-openid-connect-multitenancy.adoc[使用 OpenID Connect 多租户] 指南》。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "Accessing JWT claims"
msgstr "访问JWT声明"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If you need to access JWT token claims, you can inject `JsonWebToken`:"
msgstr "如果需要访问 JWT 令牌声明，可以注入 `JsonWebToken` .NET Framework："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Injection of `JsonWebToken` is supported in `@ApplicationScoped`, `@Singleton`, and `@RequestScoped` scopes.\n"
"However, the use of `@RequestScoped` is required if the individual claims are injected as simple types.\n"
"For more information, see the xref:security-jwt.adoc#supported-injection-scopes[Supported injection scopes] section of the Quarkus \"Using JWT RBAC\" guide."
msgstr "`@ApplicationScoped` 、 `@Singleton` 和 `@RequestScoped` 范围支持注入 `JsonWebToken` 。但是，如果以简单类型注入单个声明，则需要使用 `@RequestScoped` 。有关详细信息，请参阅 Quarkus \"使用 JWT RBAC \"指南中的 \" xref:security-jwt.adoc#supported-injection-scopes[支持的注入范围] \"部分。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "`UserInfo`"
msgstr "`UserInfo`"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"If you must request a UserInfo JSON object from the OIDC `UserInfo` endpoint, set `quarkus.oidc.authentication.user-info-required=true`.\n"
"A request is sent to the OIDC provider `UserInfo` endpoint, and an `io.quarkus.oidc.UserInfo` (a simple `javax.json.JsonObject` wrapper) object is created.\n"
"`io.quarkus.oidc.UserInfo` can be injected or accessed as a `SecurityIdentity` `userinfo` attribute."
msgstr "如果必须从 OIDC `UserInfo` 端点请求 UserInfo JSON 对象，请设置 `quarkus.oidc.authentication.user-info-required=true` 。请求会发送到 OIDC 提供商 `UserInfo` 端点，并创建一个 `io.quarkus.oidc.UserInfo` （简单的 `javax.json.JsonObject` 封装器）对象。 `io.quarkus.oidc.UserInfo` 可作为 `SecurityIdentity` `userinfo` 属性注入或访问。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Configuration metadata"
msgstr "配置元数据"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The current tenant's discovered link:https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata[OpenID Connect Configuration Metadata] is represented by `io.quarkus.oidc.OidcConfigurationMetadata` and can be injected or accessed as a `SecurityIdentity` `configuration-metadata` attribute."
msgstr "当前租户已发现的 link:https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata[OpenID Connect 配置元数据] 由 `io.quarkus.oidc.OidcConfigurationMetadata` 表示，可作为 `SecurityIdentity` `configuration-metadata` 属性注入或访问。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "The default tenant's `OidcConfigurationMetadata` is injected if the endpoint is public."
msgstr "如果端点是公开的，则默认租户的 `OidcConfigurationMetadata` 会被注入。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Token claims and SecurityIdentity roles"
msgstr "令牌申请和安全身份角色"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You can map `SecurityIdentity` roles from the verified JWT access tokens as follows:"
msgstr "您可以从已验证的 JWT 访问令牌中映射 `SecurityIdentity` 角色，具体如下："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"If the `quarkus.oidc.roles.role-claim-path` property is set, and matching array or string claims are found, then the roles are extracted from these claims.\n"
"For example, `customroles`, `customroles/array`, `scope`, `\"http://namespace-qualified-custom-claim\"/roles`, `\"http://namespace-qualified-roles\"`."
msgstr "如果设置了 `quarkus.oidc.roles.role-claim-path` 属性，并且找到了匹配的数组或字符串声明，那么就会从这些声明中提取角色。例如， `customroles` , `customroles/array` , `scope` , `\"http://namespace-qualified-custom-claim\"/roles` , `\"http://namespace-qualified-roles\"` 。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If a `groups` claim is available, then its value is used."
msgstr "如果有 `groups` 索赔，则使用其价值。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"If a `realm_access/roles` or `resource_access/client_id/roles` (where `client_id` is the value of the `quarkus.oidc.client-id` property) claim is available, then its value is used.\n"
"This check supports the tokens issued by Keycloak."
msgstr "如果有 `realm_access/roles` 或 `resource_access/client_id/roles` （其中 `client_id` 是 `quarkus.oidc.client-id` 属性的值）主张，则使用其值。该检查支持 Keycloak 发布的令牌。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For example, the following JWT token has a complex `groups` claim that contains a `roles` array that includes roles:"
msgstr "例如，下面的 JWT 令牌有一个复杂的 `groups` 声明，其中包含一个包含角色的 `roles` 数组："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You must map the `microprofile_jwt_user` role to `SecurityIdentity` roles, and you can do so with this configuration: `quarkus.oidc.roles.role-claim-path=groups/roles`."
msgstr "您必须将 `microprofile_jwt_user` 角色映射到 `SecurityIdentity` 角色，可以通过以下配置实现： `quarkus.oidc.roles.role-claim-path=groups/roles` 。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If the token is opaque (binary), then a `scope` property from the remote token introspection response is used."
msgstr "如果令牌不透明（二进制），则使用远程令牌反省响应中的 `scope` 属性。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If `UserInfo` is the source of the roles, then set `quarkus.oidc.authentication.user-info-required=true` and `quarkus.oidc.roles.source=userinfo`, and if needed, set `quarkus.oidc.roles.role-claim-path`."
msgstr "如果 `UserInfo` 是角色来源，则设置 `quarkus.oidc.authentication.user-info-required=true` 和 `quarkus.oidc.roles.source=userinfo` ，如果需要，则设置 `quarkus.oidc.roles.role-claim-path` 。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Additionally, a custom `SecurityIdentityAugmentor` can also be used to add the roles.\n"
"For more information, see the xref:security-customization.adoc#security-identity-customization[Security identity customization] section of the Quarkus \"Security tips and tricks\" guide."
msgstr "此外，还可以使用自定义 `SecurityIdentityAugmentor` 添加角色。更多信息，请参阅 Quarkus \"安全技巧和窍门 \"指南中的 xref:security-customization.adoc#security-identity-customization[安全身份定制] 部分。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You can also map `SecurityIdentity` roles created from token claims to deployment-specific roles by using the xref:security-authorize-web-endpoints-reference.adoc#map-security-identity-roles[HTTP Security policy]."
msgstr "您还可以使用 xref:security-authorize-web-endpoints-reference.adoc#map-security-identity-roles[HTTP 安全策略] ，将从令牌声明创建的 `SecurityIdentity` 角色映射到特定于部署的角色。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Token scopes and SecurityIdentity permissions"
msgstr "令牌作用域和 SecurityIdentity 权限"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "`SecurityIdentity` permissions are mapped in the form of `io.quarkus.security.StringPermission` from the scope parameter of the <<token-claims-and-security-identity-roles,source of the roles>> and using the same claim separator."
msgstr "`SecurityIdentity` 权限以 的形式从 `io.quarkus.security.StringPermission` xref:token-claims-and-security-identity-roles[角色源] 的作用域参数中映射，并使用相同的权利要求分隔符。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Only requests with OpenID Connect scope `email` will be granted access."
msgstr "只有 OpenID Connect 范围为 `email` 的请求才会获准访问。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The read access is limited to the client requests with the `orders_read` scope."
msgstr "读取访问仅限于 `orders_read` 范围内的客户请求。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For more information about the `io.quarkus.security.PermissionsAllowed` annotation, see the xref:security-authorize-web-endpoints-reference.adoc#permission-annotation[Permission annotation] section of the \"Authorization of web endpoints\" guide."
msgstr "有关 `io.quarkus.security.PermissionsAllowed` 注释的更多信息，请参阅 \"网络端点的授权 \"指南中的 xref:security-authorize-web-endpoints-reference.adoc#permission-annotation[权限注] 释部分。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Token verification and introspection"
msgstr "令牌验证和反省"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"If the token is a JWT token, then, by default, it is verified with a `JsonWebKey` (JWK) key from a local `JsonWebKeySet`, retrieved from the OIDC provider's JWK endpoint.\n"
"The token's key identifier (`kid`) header value is used to find the matching JWK key.\n"
"If no matching `JWK` is available locally, then `JsonWebKeySet` is refreshed by fetching the current key set from the JWK endpoint.\n"
"The `JsonWebKeySet` refresh can be repeated only after the `quarkus.oidc.token.forced-jwk-refresh-interval` expires.\n"
"The default expiry time is 10 minutes.\n"
"If no matching `JWK` is available after the refresh, the JWT token is sent to the OIDC provider's token introspection endpoint."
msgstr "如果令牌是 JWT 令牌，那么默认情况下会使用从本地 `JsonWebKeySet` 获取的 `JsonWebKey` (JWK) 密钥进行验证，该密钥是从 OIDC 提供商的 JWK 端点获取的。令牌的密钥标识符（ `kid` ）标头值用于查找匹配的 JWK 密钥。如果本地没有匹配的 `JWK` ，则通过从 JWK 端点获取当前密钥集来刷新 `JsonWebKeySet` 。只有在 `quarkus.oidc.token.forced-jwk-refresh-interval` 过期后，才能重复刷新 `JsonWebKeySet` 。默认过期时间为 10 分钟。如果刷新后没有匹配的 `JWK` ，JWT 令牌就会被发送到 OIDC 提供商的令牌自省端点。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If the token is opaque, which means it can be a binary token or an encrypted JWT token, then it is always sent to the OIDC provider's token introspection endpoint."
msgstr "如果令牌是不透明的，即可以是二进制令牌或加密的 JWT 令牌，那么它总是被发送到 OIDC 提供商的令牌反省端点。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If you work only with JWT tokens and expect a matching `JsonWebKey` to always be available, for example, after refreshing a key set, you must disable token introspection, as shown in the following example:"
msgstr "如果只使用 JWT 标记，并希望匹配的 `JsonWebKey` 始终可用（例如，刷新密钥集后），则必须禁用标记反省，如下例所示："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"There might be cases where JWT tokens must be verified through introspection only, which can be forced by configuring an introspection endpoint address only.\n"
"The following properties configuration shows you an example of how you can achieve this with Keycloak:"
msgstr "在某些情况下，JWT 标记必须只通过自省来验证，这可以通过配置一个自省端点地址来强制实现。下面的属性配置举例说明了如何使用 Keycloak 实现这一目的："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"There are advantages and disadvantages to indirectly enforcing the introspection of JWT tokens remotely.\n"
"An advantage is that you eliminate the need for two remote calls: a remote OIDC metadata discovery call followed by another remote call to fetch the verification keys that will not be used.\n"
"A disadvantage is that you need to know the introspection endpoint address and configure it manually."
msgstr "远程间接执行对 JWT 标记的反省有利有弊。优点是不需要两次远程调用：一次远程 OIDC 元数据发现调用，然后再调用一次远程调用来获取不会使用的验证密钥。缺点是需要知道反省端点地址并手动配置。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The alternative approach is to allow the default option of OIDC metadata discovery but also require that only the remote JWT introspection is performed, as shown in the following example:"
msgstr "另一种方法是允许使用 OIDC 元数据发现的默认选项，但也要求只执行远程 JWT 自省，如下例所示："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"An advantage of this approach is that the configuration is simpler and easier to understand.\n"
"A disadvantage is that a remote OIDC metadata discovery call is required to discover an introspection endpoint address, even though the verification keys will not be fetched."
msgstr "这种方法的优点是配置更简单，更容易理解。缺点是需要调用远程 OIDC 元数据发现功能来发现自省端点地址，尽管不会获取验证密钥。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"The `io.quarkus.oidc.TokenIntrospection`, a simple `jakarta.json.JsonObject` wrapper object, will be created.\n"
"It can be injected or accessed as a `SecurityIdentity` `introspection` attribute, providing either the JWT or opaque token has been successfully introspected."
msgstr "`io.quarkus.oidc.TokenIntrospection` ，一个简单的 `jakarta.json.JsonObject` 封装对象将被创建。它可以作为 `SecurityIdentity` `introspection` 属性注入或访问，前提是 JWT 或不透明令牌已被成功反省。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Token introspection and `UserInfo` cache"
msgstr "令牌反省和 `UserInfo` 缓存"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"All opaque access tokens must be remotely introspected.\n"
"Sometimes, JWT access tokens might also have to be introspected.\n"
"If `UserInfo` is also required, the same access token is used in a subsequent remote call to the OIDC provider.\n"
"So, if `UserInfo` is required, and the current access token is opaque, two remote calls are made for every such token; one remote call to introspect the token and another to get `UserInfo`.\n"
"If the token is JWT, only a single remote call to get `UserInfo` is needed, unless it also has to be introspected."
msgstr "所有不透明访问令牌都必须进行远程反省。有时，JWT 访问令牌也必须接受检查。如果 `UserInfo` 也是必需的，则在随后对 OIDC 提供商的远程调用中会使用相同的访问令牌。因此，如果 `UserInfo` 是必需的，而当前的访问令牌是不透明的，那么每一个这样的令牌都要进行两次远程调用；一次远程调用用于反省令牌，另一次远程调用用于获取 `UserInfo` 。如果令牌是 JWT，则只需一次远程调用即可获取 `UserInfo` ，除非还需要对其进行自省。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The cost of making up to two remote calls for every incoming bearer or code flow access token can sometimes be problematic."
msgstr "每个传入的承载或代码流访问令牌都要进行两次远程呼叫，其成本有时会很高。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If this is the case in production, consider caching the token introspection and `UserInfo` data for a short period, for example, 3 or 5 minutes."
msgstr "如果生产中出现这种情况，可考虑将令牌反省和 `UserInfo` 数据缓存一段短时间，例如 3 或 5 分钟。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"`quarkus-oidc` provides `quarkus.oidc.TokenIntrospectionCache` and `quarkus.oidc.UserInfoCache` interfaces, usable for `@ApplicationScoped` cache implementation.\n"
"Use `@ApplicationScoped` cache implementation to store and retrieve `quarkus.oidc.TokenIntrospection` and/or `quarkus.oidc.UserInfo` objects, as outlined in the following example:"
msgstr "`quarkus-oidc` 提供了 和 接口，可用于 缓存实现。如下例所示，使用 缓存实现来存储和检索 和/或 对象： `quarkus.oidc.TokenIntrospectionCache` `quarkus.oidc.UserInfoCache` `@ApplicationScoped` `@ApplicationScoped` `quarkus.oidc.TokenIntrospection` `quarkus.oidc.UserInfo` "

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Each OIDC tenant can either permit or deny the storing of its `quarkus.oidc.TokenIntrospection` data, `quarkus.oidc.UserInfo` data, or both with boolean `quarkus.oidc.\"tenant\".allow-token-introspection-cache` and `quarkus.oidc.\"tenant\".allow-user-info-cache` properties."
msgstr "每个 OIDC 租户可通过布尔 `quarkus.oidc.\"tenant\".allow-token-introspection-cache` 和 `quarkus.oidc.\"tenant\".allow-user-info-cache` 属性允许或拒绝存储其 `quarkus.oidc.TokenIntrospection` 数据、 `quarkus.oidc.UserInfo` 数据或两者。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Additionally, `quarkus-oidc` provides a simple default memory-based token cache, which implements both `quarkus.oidc.TokenIntrospectionCache` and `quarkus.oidc.UserInfoCache` interfaces."
msgstr "此外， `quarkus-oidc` 还提供了一个简单的基于内存的默认令牌缓存，它同时实现了 `quarkus.oidc.TokenIntrospectionCache` 和 `quarkus.oidc.UserInfoCache` 接口。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You can configure and activate the default OIDC token cache as follows:"
msgstr "配置和激活默认 OIDC 令牌缓存的方法如下："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"The default cache uses a token as a key, and each entry can have `TokenIntrospection`, `UserInfo`, or both.\n"
"It will only keep up to a `max-size` number of entries.\n"
"If the cache is already full when a new entry is to be added, an attempt is made to find a space by removing a single expired entry.\n"
"Additionally, the cleanup timer, if activated, periodically checks for expired entries and removes them."
msgstr "默认缓存使用令牌作为密钥，每个条目可以有 `TokenIntrospection` 、 `UserInfo` 或两者都有。它最多只能保留 `max-size` 的条目数。如果要添加新条目时缓存已满，则会尝试通过删除单个过期条目来寻找空间。此外，如果激活了清理定时器，它会定期检查过期条目并将其删除。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You can experiment with the default cache implementation or register a custom one."
msgstr "您可以尝试使用默认的缓存实现，或者注册一个自定义缓存。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "JSON Web Token claim verification"
msgstr "JSON 网络令牌索赔验证"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "After the bearer JWT token's signature has been verified and its `expires at` (`exp`) claim has been checked, the `iss` (`issuer`) claim value is verified next."
msgstr "在验证了承载 JWT 令牌的签名并检查了其 `expires at` ( `exp` ) 索赔后，接下来要验证 `iss` ( `issuer` ) 索赔值。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"By default, the `iss` claim value is compared to the `issuer` property, which might have been discovered in the well-known provider configuration.\n"
"However, if the `quarkus.oidc.token.issuer` property is set, then the `iss` claim value is compared to it instead."
msgstr "默认情况下， `iss` 索赔值与 `issuer` 属性进行比较，该属性可能已在知名提供程序配置中被发现。但是，如果设置了 `quarkus.oidc.token.issuer` 属性，则会与 `iss` 索赔值进行比较。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"In some cases, this `iss` claim verification might not work.\n"
"For example, if the discovered `issuer` property contains an internal HTTP/IP address while the token `iss` claim value contains an external HTTP/IP address.\n"
"Or when a discovered `issuer` property contains the template tenant variable, but the token `iss` claim value has the complete tenant-specific issuer value."
msgstr "在某些情况下， `iss` 索赔验证可能不起作用。例如，如果发现的 `issuer` 属性包含内部 HTTP/IP 地址，而令牌 `iss` 索赔值包含外部 HTTP/IP 地址。或者当发现的 `issuer` 属性包含模板租户变量，但令牌 `iss` 索赔值包含完整的租户特定签发人值时。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"In such cases, consider skipping the issuer verification by setting `quarkus.oidc.token.issuer=any`.\n"
"Only skip the issuer verification if no other options are available:"
msgstr "在这种情况下，可考虑通过设置 `quarkus.oidc.token.issuer=any` 跳过发行方验证。只有在没有其他选项的情况下，才跳过签发人验证："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If you are using Keycloak and observe the issuer verification errors caused by the different host addresses, configure Keycloak with a `KEYCLOAK_FRONTEND_URL` property to ensure the same host address is used."
msgstr "如果您使用 Keycloak 并观察到不同主机地址导致的签发人验证错误，请使用 `KEYCLOAK_FRONTEND_URL` 属性配置 Keycloak，以确保使用相同的主机地址。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"If the `iss` property is tenant-specific in a multitenant deployment, use the `SecurityIdentity` `tenant-id` attribute to check that the issuer is correct in the endpoint or the custom Jakarta filter.\n"
"For example:"
msgstr "如果在多租户部署中 `iss` 属性是特定于租户的，则可使用 `SecurityIdentity` `tenant-id` 属性来检查端点或自定义 Jakarta 过滤器中的签发者是否正确。例如"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Consider using the `quarkus.oidc.token.audience` property to verify the token `aud` (`audience`) claim value."
msgstr "考虑使用 `quarkus.oidc.token.audience` 属性来验证令牌 `aud` ( `audience` ) 索赔值。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Single-page applications"
msgstr "单页应用程序"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "A single-page application (SPA) typically uses `XMLHttpRequest`(XHR) and the JavaScript utility code provided by the OIDC provider to acquire a bearer token to access Quarkus `service` applications."
msgstr "单页应用程序（SPA）通常使用 `XMLHttpRequest` (XHR) 和 OIDC 提供商提供的 JavaScript 实用程序代码来获取承载令牌，以访问 Quarkus `service` 应用程序。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For example, if you work with Keycloak, you can use `keycloak.js` to authenticate users and refresh the expired tokens from the SPA:"
msgstr "例如，如果使用 Keycloak，则可以使用 `keycloak.js` 对用户进行身份验证，并从 SPA 中刷新过期的令牌："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "Cross-origin resource sharing"
msgstr "Cross-Origin 资源共享"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"If you plan to use your OIDC `service` application from a single-page application running on a different domain, you must configure cross-origin resource sharing (CORS).\n"
"For more information, see the xref:security-cors.adoc#cors-filter[CORS filter] section of the \"Cross-origin resource sharing\" guide."
msgstr "如果计划从运行在不同域上的单页应用程序中使用 OIDC `service` 应用程序，则必须配置跨源资源共享 (CORS)。更多信息，请参阅 \"跨源资源共享 \"指南中的 xref:security-cors.adoc#cors-filter[CORS 过滤器] 部分。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Provider endpoint configuration"
msgstr "提供商端点配置"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "An OIDC `service` application needs to know the OIDC provider's token, `JsonWebKey` (JWK) set, and possibly `UserInfo` and introspection endpoint addresses."
msgstr "OIDC `service` 应用程序需要知道 OIDC 提供商的令牌、 `JsonWebKey` (JWK) 集，可能还需要知道 `UserInfo` 和反省端点地址。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "By default, they are discovered by adding a `/.well-known/openid-configuration` path to the configured `quarkus.oidc.auth-server-url`."
msgstr "默认情况下，它们是通过在配置的 `quarkus.oidc.auth-server-url` 中，添加一个 `/.well-known/openid-configuration` 路径来发现的。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Alternatively, if the discovery endpoint is not available, or if you want to save on the discovery endpoint round-trip, you can disable the discovery and configure them with relative path values.\n"
"For example:"
msgstr "另外，如果发现端点不可用，或者想节省发现端点的往返次数，也可以禁用发现端点，并使用相对路径值进行配置。例如"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Token propagation"
msgstr "令牌传播"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For information about bearer access token propagation to the downstream services, see the xref:security-openid-connect-client-reference.adoc#token-propagation[Token propagation] section of the Quarkus \"OpenID Connect (OIDC) and OAuth2 client and filters reference\" guide."
msgstr "有关向下游服务传播承载访问令牌的信息，请参阅 Quarkus \"OpenID Connect (OIDC) 和 OAuth2 客户端和过滤器参考 \"指南中的 xref:security-openid-connect-client-reference.adoc#token-propagation[令牌传播] 部分。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "OIDC provider client authentication"
msgstr "OIDC 提供商客户端验证"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"`quarkus.oidc.runtime.OidcProviderClient` is used when a remote request to an OIDC provider is required.\n"
"If introspection of the Bearer token is necessary, then `OidcProviderClient` must authenticate to the OIDC provider.\n"
"For more information about supported authentication options, see the  xref:security-oidc-code-flow-authentication.adoc#oidc-provider-client-authentication[OIDC provider client authentication] section in the Quarkus \"OpenID Connect authorization code flow mechanism for protecting web applications\" guide."
msgstr "`quarkus.oidc.runtime.OidcProviderClient` 用于向 OIDC 提供商发出远程请求。如果需要反省 Bearer 令牌，则 必须对 OIDC 提供商进行身份验证。有关支持的身份验证选项的更多信息，请参阅 Quarkus \"用于保护网络应用程序的 OpenID Connect 授权代码流机制 \"指南中的 `OidcProviderClient` xref:security-oidc-code-flow-authentication.adoc#oidc-provider-client-authentication[OIDC 提供商客户端身份验证] 部分。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "Testing"
msgstr "测试"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If you have to test Quarkus OIDC service endpoints that require xref:security-keycloak-authorization.adoc[Keycloak authorization], follow the xref:security-keycloak-authorization.adoc#testing[Test Keycloak authorization] section."
msgstr "如果要测试需要 xref:security-keycloak-authorization.adoc[Keycloak 授权的] Quarkus OIDC 服务端点，请按照 xref:security-keycloak-authorization.adoc#testing[测试 Keycloak 授权] 部分进行操作。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You can begin testing by adding the following dependencies to your test project:"
msgstr "在测试项目中添加以下依赖项后，就可以开始测试了："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "pom.xml"
msgstr "pom.xml"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "build.gradle"
msgstr "build.gradle"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "WireMock"
msgstr "线模拟"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "Add the following dependencies to your test project:"
msgstr "在你的测试项目中添加以下依赖项："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Prepare the REST test endpoint and set `application.properties`.\n"
"For example:"
msgstr "准备 REST 测试端点并设置 `application.properties` 。例如"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Finally, write the test code.\n"
"For example:"
msgstr "最后，编写测试代码。例如"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"The `quarkus-test-oidc-server` extension includes a signing RSA private key file in a `JSON Web Key` (`JWK`) format and points to it with a `smallrye.jwt.sign.key.location` configuration property.\n"
"It allows you to sign the token by using a no-argument `sign()` operation."
msgstr "`quarkus-test-oidc-server` 扩展包含一个 `JSON Web Key` ( `JWK` ) 格式的签名 RSA 私钥文件，并通过 `smallrye.jwt.sign.key.location` 配置属性指向该文件。它允许你使用无参数 `sign()` 操作来签署令牌。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Testing your `quarkus-oidc` `service` application with `OidcWiremockTestResource` provides the best coverage because even the communication channel is tested against the WireMock HTTP stubs.\n"
"If you need to run a test with WireMock stubs that are not yet supported by `OidcWiremockTestResource`, you can inject a `WireMockServer` instance into the test class, as shown in the following example:"
msgstr "使用 `OidcWiremockTestResource` 测试 `quarkus-oidc` `service` 应用程序可提供最佳覆盖率，因为甚至通信通道也是通过 WireMock HTTP 存根测试的。如果需要使用 `OidcWiremockTestResource` 尚不支持的 WireMock 存根进行测试，可以在测试类中注入一个 `WireMockServer` 实例，如下例所示："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "`OidcWiremockTestResource` does not work with `@QuarkusIntegrationTest` against Docker containers because the WireMock server runs in the JVM that runs the test, which is inaccessible from the Docker container that runs the Quarkus application."
msgstr "`OidcWiremockTestResource` 无法在 中针对 Docker 容器运行，因为 WireMock 服务器运行在运行测试的 JVM 中，而运行 Quarkus 应用程序的 Docker 容器无法访问 JVM。 `@QuarkusIntegrationTest` "

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "`OidcTestClient`"
msgstr "`OidcTestClient`"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If you use SaaS OIDC providers, such as `Auth0`, and want to run tests against the test (development) domain or to run tests against a remote Keycloak test realm, if you already have `quarkus.oidc.auth-server-url` configured, you can use `OidcTestClient`."
msgstr "如果使用 SaaS OIDC 提供商，如 `Auth0` ，并希望针对测试（开发）域运行测试，或针对远程 Keycloak 测试域运行测试，如果已经配置了 `quarkus.oidc.auth-server-url` ，则可以使用 `OidcTestClient` 。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For example, you have the following configuration:"
msgstr "例如，您有以下配置："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "To start, add the same dependency, `quarkus-test-oidc-server`, as described in the <<bearer-token-integration-testing-wiremock>> section."
msgstr ""

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Next, write the test code as follows:"
msgstr "接下来，编写测试代码如下："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"This test code acquires a token by using a `password` grant from the test `Auth0` domain, which has registered an application with the client id `test-auth0-client`, and created the user `alice` with password `alice`.\n"
"For a test like this to work, the test `Auth0` application must have the `password` grant enabled.\n"
"This example code also shows how to pass additional parameters.\n"
"For `Auth0`, these are the `audience` and `scope` parameters."
msgstr "该测试代码通过使用 `password` grant 从测试 `Auth0` 域获取令牌，该域已用客户 ID `test-auth0-client` 注册了一个应用程序，并创建了用户 `alice` 和密码 `alice` 。要进行这样的测试，测试 `Auth0` 应用程序必须启用 `password` 授权。此示例代码还展示了如何传递附加参数。对于 `Auth0` ，这些参数是 `audience` 和 `scope` 。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "Dev Services for Keycloak"
msgstr "为Keycloak提供的开发服务"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"The preferred approach for integration testing against Keycloak is xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak].\n"
"`Dev Services for Keycloak` will start and initialize a test container.\n"
"Then, it will create a `quarkus` realm and a `quarkus-app` client (`secret` secret) and add `alice` (`admin` and `user` roles) and `bob` (`user` role) users, where all of these properties can be customized."
msgstr "对 Keycloak 进行集成测试的首选方法是 xref:security-openid-connect-dev-services.adoc[Keycloak 的 Dev Services] 。 `Dev Services for Keycloak` 将启动并初始化一个测试容器。然后，它会创建 `quarkus` realm 和 `quarkus-app` client ( `secret` secret) 并添加 `alice` ( `admin` 和 `user` roles) 和 `bob` ( `user` role) 用户，所有这些属性都可以自定义。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "First, add the following dependency, which provides a utility class `io.quarkus.test.keycloak.client.KeycloakTestClient` that you can use in tests for acquiring the access tokens:"
msgstr "首先，添加以下依赖项，该依赖项提供了一个实用程序类 `io.quarkus.test.keycloak.client.KeycloakTestClient` ，可在测试中用于获取访问令牌："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Next, prepare your `application.properties` configuration file.\n"
"You can start with an empty `application.properties` file because `Dev Services for Keycloak` registers `quarkus.oidc.auth-server-url` and points it to the running test container, `quarkus.oidc.client-id=quarkus-app`, and `quarkus.oidc.credentials.secret=secret`."
msgstr "接下来，准备好 `application.properties` 配置文件。您可以从空的 `application.properties` 文件开始，因为 `Dev Services for Keycloak` 会注册 `quarkus.oidc.auth-server-url` 并将其指向正在运行的测试容器 `quarkus.oidc.client-id=quarkus-app` 和 `quarkus.oidc.credentials.secret=secret` 。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "However, if you have already configured the required `quarkus-oidc` properties, then you only need to associate `quarkus.oidc.auth-server-url` with the `prod` profile for `Dev Services for Keycloak`to start a container, as shown in the following example:"
msgstr "但是，如果已经配置了所需的 `quarkus-oidc` 属性，则只需将 `quarkus.oidc.auth-server-url` 与 `prod` 配置文件中的 \"Dev Services for Keycloak \"关联，即可启动容器，如下例所示："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If a custom realm file has to be imported into Keycloak before running the tests, configure `Dev Services for Keycloak` as follows:"
msgstr "如果必须在运行测试前将自定义 realm 文件导入 Keycloak，请按以下步骤配置 `Dev Services for Keycloak` ："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Finally, write your test, which will be executed in JVM mode, as shown in the following examples:"
msgstr "最后，编写测试，如以下示例所示，测试将在 JVM 模式下执行："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Example of a test executed in JVM mode:"
msgstr "在 JVM 模式下执行测试的示例："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Example of a test executed in native mode:"
msgstr "在本地模式下执行测试的示例："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For more information about initializing and configuring Dev Services for Keycloak, see the xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] guide."
msgstr "有关初始化和配置 Keycloak Dev Services 的更多信息，请参阅 xref:security-openid-connect-dev-services.adoc[Keycloak Dev Services] 指南。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "`KeycloakTestResourceLifecycleManager`"
msgstr "`KeycloakTestResourceLifecycleManager`"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You can also use `KeycloakTestResourceLifecycleManager` for integration testing with Keycloak."
msgstr "您还可以使用 `KeycloakTestResourceLifecycleManager` 与 Keycloak 进行集成测试。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "Use <<bearer-token-integration-testing-keycloak-devservices,Dev Services for Keycloak>> instead of `KeycloakTestResourceLifecycleManager` for integration testing with Keycloak, unless you have specific requirements for using `KeycloakTestResourceLifecycleManager`."
msgstr ""

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "First, add the following dependency:"
msgstr "首先，添加以下依赖项："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "It provides `io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager`, which is an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` that starts a Keycloak container."
msgstr "它提供 `io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager` ，这是 `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` 的一个实现，可以启动 Keycloak 容器。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Configure the Maven Surefire plugin as follows, or similarly with `maven.failsafe.plugin` for native image testing:"
msgstr "按如下方式配置 Maven Surefire 插件，或使用 `maven.failsafe.plugin` 进行类似的本地图像测试："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Prepare the REST test endpoint and set `application.properties` as outlined in the following example:"
msgstr "准备 REST 测试端点，并按以下示例所述设置 `application.properties` ："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Summary"
msgstr "摘要"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"In the provided example, `KeycloakTestResourceLifecycleManager` registers two users: `alice` and `admin`.\n"
"By default:\n"
"* The user `alice` has the `user` role, which you can customize by using a `keycloak.token.user-roles` system property.\n"
"* The user `admin` has both the `user` and `admin` roles, which you can customize by using the `keycloak.token.admin-roles` system property."
msgstr "在所提供的示例中， `KeycloakTestResourceLifecycleManager` 注册了两个用户： `alice` 和 `admin` 。默认情况下：* 用户 `alice` 拥有 `user` 角色，可通过 `keycloak.token.user-roles` 系统属性进行自定义。* 用户 `admin` 具有 `user` 和 `admin` 两个角色，可通过 `keycloak.token.admin-roles` 系统属性进行自定义。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"By default, `KeycloakTestResourceLifecycleManager` uses HTTPS to initialize a Keycloak instance, and this can be disabled by using `keycloak.use.https=false`.\n"
"The default realm name is `quarkus`, and the client id is `quarkus-service-app`.\n"
"If you want to customize these values, set the `keycloak.realm` and `keycloak.service.client` system properties."
msgstr "默认情况下， `KeycloakTestResourceLifecycleManager` 使用 HTTPS 初始化 Keycloak 实例，可以通过 `keycloak.use.https=false` 禁用。默认的领域名称是 `quarkus` ，客户端 id 是 `quarkus-service-app` 。如果要自定义这些值，请设置 `keycloak.realm` 和 `keycloak.service.client` 系统属性。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Local public key"
msgstr "本地公用密钥"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You can use a local inlined public key for testing your `quarkus-oidc` `service` applications, as shown in the following example:"
msgstr "您可以使用本地内嵌公钥测试 `quarkus-oidc` `service` 应用程序，如下例所示："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid ""
"To generate JWT tokens, copy `privateKey.pem` from the `integration-tests/oidc-tenancy` in the `main` Quarkus repository and use a test code similar to the one in the preceding <<bearer-token-integration-testing-wiremock>> section.\n"
"You can use your own test keys, if preferred."
msgstr ""

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"This approach provides limited coverage compared to the WireMock approach.\n"
"For example, the remote communication code is not covered."
msgstr "与 WireMock 方法相比，这种方法的覆盖范围有限。例如，远程通信代码不在覆盖范围内。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "TestSecurity annotation"
msgstr "TestSecurity 注解"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "You can use `@TestSecurity` and `@OidcSecurity` annotations to test the `service` application endpoint code, which depends on either one, or all three, of the following injections:"
msgstr "您可以使用 `@TestSecurity` 和 `@OidcSecurity` 注释来测试 `service` 应用程序端点代码，该代码依赖于以下一个或全部三个注入："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "`JsonWebToken`"
msgstr "`JsonWebToken`"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "`OidcConfigurationMetadata`"
msgstr "`OidcConfigurationMetadata`"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Write a test code as outlined in the following example:"
msgstr "按照下面的示例编写测试代码："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The `ProtectedResource` class, which is used in this code example, might look like this:"
msgstr "本代码示例中使用的 `ProtectedResource` 类可能如下所示："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"You must always use the `@TestSecurity` annotation.\n"
"Its `user` property is returned as `JsonWebToken.getName()` and its `roles` property is returned as `JsonWebToken.getGroups()`.\n"
"The `@OidcSecurity` annotation is optional and you can use it to set the additional token claims and the `UserInfo` and `OidcConfigurationMetadata` properties.\n"
"Additionally, if the `quarkus.oidc.token.issuer` property is configured, it is used as an `OidcConfigurationMetadata` `issuer` property value."
msgstr "您必须始终使用 `@TestSecurity` 注释。其 `user` 属性的返回值为 `JsonWebToken.getName()` ，其 `roles` 属性的返回值为 `JsonWebToken.getGroups()` 。 `@OidcSecurity` 注解是可选的，可用于设置附加标记声明以及 `UserInfo` 和 `OidcConfigurationMetadata` 属性。此外，如果配置了 `quarkus.oidc.token.issuer` 属性，它将用作 `OidcConfigurationMetadata` `issuer` 属性值。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If you work with opaque tokens, you can test them as shown in the following code example:"
msgstr "如果使用不透明令牌，可以按照下面的代码示例对其进行测试："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "The  `ProtectedResource` class, which is used in this code example, might look like this:"
msgstr "本代码示例中使用的 `ProtectedResource` 类可能如下所示："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"The `@TestSecurity`, `user`, and `roles` attributes are available as `TokenIntrospection`, `username`, and `scope` properties.\n"
"Use `io.quarkus.test.security.oidc.TokenIntrospection` to add the additional introspection response properties, such as an `email`, and so on."
msgstr "`@TestSecurity` 、 `user` 和 `roles` 属性可作为 `TokenIntrospection` 、 `username` 和 `scope` 属性使用。使用 `io.quarkus.test.security.oidc.TokenIntrospection` 添加额外的自省响应属性，如 `email` 等。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "`@TestSecurity` and `@OidcSecurity` can be combined in a meta-annotation, as outlined in the following example:"
msgstr "`@TestSecurity` 和 可以在元注释中结合使用，如下例所示： `@OidcSecurity` "

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "This is particularly useful if multiple test methods must use the same set of security settings."
msgstr "如果多个测试方法必须使用同一套安全设置，这一点尤其有用。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Check errors in the logs"
msgstr "检查日志中的错误"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "To see more details about token verification errors, enable `io.quarkus.oidc.runtime.OidcProvider` and `TRACE` level logging:"
msgstr "要查看有关令牌验证错误的更多详细信息，请启用 `io.quarkus.oidc.runtime.OidcProvider` 和 `TRACE` 级别日志："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "To see more details about `OidcProvider` client initialization errors, enable `io.quarkus.oidc.runtime.OidcRecorder` and `TRACE` level logging as follows:"
msgstr "要查看有关 `OidcProvider` 客户端初始化错误的更多详细信息，请按以下步骤启用 `io.quarkus.oidc.runtime.OidcRecorder` 和 `TRACE` 级别的日志记录："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "External and internal access to OIDC providers"
msgstr "从外部和内部访问 OIDC 提供商"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"The externally-accessible token of the OIDC provider and other endpoints might have different HTTP(S) URLs compared to the URLs that are auto-discovered or configured relative to the `quarkus.oidc.auth-server-url` internal URL.\n"
"For example, suppose your SPA acquires a token from an external token endpoint address and sends it to Quarkus as a bearer token.\n"
"In that case, the endpoint might report an issuer verification failure."
msgstr "与相对于 `quarkus.oidc.auth-server-url` 内部 URL 自动发现或配置的 URL 相比，OIDC 提供商和其他端点的外部可访问令牌可能具有不同的 HTTP(S) URL。例如，假设你的 SPA 从外部令牌端点地址获取令牌，并将其作为承载令牌发送到 Quarkus。在这种情况下，端点可能会报告发行者验证失败。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"In such cases, if you work with Keycloak, start it with the `KEYCLOAK_FRONTEND_URL` system property set to the externally accessible base URL.\n"
"If you work with other OIDC providers, refer to your provider's documentation."
msgstr "在这种情况下，如果您使用 Keycloak，请在启动时将 `KEYCLOAK_FRONTEND_URL` 系统属性设置为外部可访问的基本 URL。如果使用其他 OIDC 提供商，请参阅提供商的文档。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Using the `client-id` property"
msgstr "使用 `client-id` 属性"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"The `quarkus.oidc.client-id` property identifies the OIDC client that requested the current bearer token.\n"
"The OIDC client can be an SPA application running in a browser or a Quarkus `web-app` confidential client application propagating the access token to the Quarkus `service` application."
msgstr "`quarkus.oidc.client-id` 属性标识了请求当前承载令牌的 OIDC 客户端。OIDC 客户端可以是在浏览器中运行的 SPA 应用程序，也可以是将访问令牌传播到 Quarkus `service` 应用程序的 Quarkus `web-app` 保密客户端应用程序。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"This property is required if the `service` application is expected to introspect the tokens remotely, which is always the case for the opaque tokens.\n"
"This property is optional for local JSON Web Token (JWT) verification only."
msgstr "如果 `service` 应用程序要远程反省令牌（不透明令牌总是如此），则需要此属性。本地 JSON 网络令牌 (JWT) 验证时，此属性为可选属性。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Setting the `quarkus.oidc.client-id` property is encouraged even if the endpoint does not require access to the remote introspection endpoint.\n"
"This is because when `client-id` is set, it can be used to verify the token audience.\n"
"It will also be included in logs when the token verification fails, enabling better traceability of tokens issued to specific clients and analysis over a longer period."
msgstr "即使端点不需要访问远程自省端点，也鼓励设置 `quarkus.oidc.client-id` 属性。这是因为设置 `client-id` 后，可用于验证令牌受众。当令牌验证失败时，它还会被包含在日志中，这样就能更好地跟踪向特定客户端签发的令牌，并进行更长时间的分析。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For example, if your OIDC provider sets a token audience, consider the following configuration pattern:"
msgstr "例如，如果您的 OIDC 提供商设置了令牌受众，请考虑以下配置模式："

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "If you set `quarkus.oidc.client-id`, but your endpoint does not require remote access to one of the OIDC provider endpoints (introspection, token acquisition, and so on), do not set a client secret with `quarkus.oidc.credentials` or similar properties because it will not be used."
msgstr "如果您设置了 `quarkus.oidc.client-id` ，但您的端点不需要远程访问 OIDC 提供者端点之一（自省、令牌获取等），则不要设置带有 `quarkus.oidc.credentials` 或类似属性的客户机密文，因为它不会被使用。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Quarkus `web-app` applications always require the `quarkus.oidc.client-id` property."
msgstr "Quarkus `web-app` 应用程序始终需要 `quarkus.oidc.client-id` 属性。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Authentication after an HTTP request has completed"
msgstr "HTTP 请求完成后的身份验证"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"Sometimes, `SecurityIdentity` for a given token must be created when there is no active HTTP request context.\n"
"The `quarkus-oidc` extension provides `io.quarkus.oidc.TenantIdentityProvider` to convert a token to a `SecurityIdentity` instance.\n"
"For example, one situation when you must verify the token after the HTTP request has completed is when you are processing messages with xref:vertx.adoc#event-bus[Vert.x event bus].\n"
"The example below uses the 'product-order' message within different CDI request contexts.\n"
"Therefore, an injected `SecurityIdentity` would not correctly represent the verified identity and be anonymous."
msgstr "有时，在没有活动 HTTP 请求上下文时，必须为给定令牌创建 `SecurityIdentity` 。 `quarkus-oidc` 扩展提供了 `io.quarkus.oidc.TenantIdentityProvider` ，可将令牌转换为 `SecurityIdentity` 实例。例如，在使用 xref:vertx.adoc#event-bus[Vert.x 事件总线] 处理消息时，就必须在 HTTP 请求完成后验证令牌。下面的示例在不同的 CDI 请求上下文中使用了 \"产品订单 \"消息。因此，注入的 `SecurityIdentity` 将无法正确表示已验证的身份，并且是匿名的。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "At this point, the token is not verified when proactive authentication is disabled."
msgstr "此时，如果禁用主动身份验证，则不会验证令牌。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "For the default tenant, the `TenantFeature` qualifier is optional."
msgstr "对于默认租户， `TenantFeature` 限定符是可选的。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "Executes token verification and converts the token to a `SecurityIdentity`."
msgstr "执行令牌验证并将令牌转换为 `SecurityIdentity` 。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"When the provider is used during an HTTP request, the tenant configuration can be resolved as described in\n"
"the xref:security-openid-connect-multitenancy.adoc[Using OpenID Connect Multi-Tenancy] guide.\n"
"However, when there is no active HTTP request, you must select the tenant explicitly with the `io.quarkus.oidc.TenantFeature` qualifier."
msgstr "在 HTTP 请求期间使用提供程序时，可以按照《 xref:security-openid-connect-multitenancy.adoc[使用 OpenID Connect 多租户] 》指南中的说明解决租户配置问题。但是，当没有活动 HTTP 请求时，必须使用 `io.quarkus.oidc.TenantFeature` 限定符明确选择租户。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid ""
"xref:security-openid-connect-multitenancy.adoc#tenant-config-resolver[Dynamic tenant configuration resolution] is currently not supported.\n"
"Authentication that requires a dynamic tenant will fail."
msgstr "目前不支持 xref:security-openid-connect-multitenancy.adoc#tenant-config-resolver[动态租户配置解析] 。需要动态租户的身份验证将失败。"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "OIDC request filters"
msgstr "OIDC 申请过滤器"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid ""
"You can filter OIDC requests made by Quarkus to the OIDC provider by registering one or more `OidcRequestFilter` implementations, which can update or add new request headers, and log requests.\n"
"For more information, see xref:security-oidc-code-flow-authentication#code-flow-oidc-request-filters[OIDC request filters]."
msgstr ""

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "References"
msgstr "参考文献"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-oidc-configuration-properties-reference.adoc[OIDC configuration properties]"
msgstr "xref:security-oidc-configuration-properties-reference.adoc[OIDC 配置属性]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-oidc-bearer-token-authentication-tutorial.adoc[Protect a service application by using OIDC Bearer token authentication]"
msgstr "xref:security-oidc-bearer-token-authentication-tutorial.adoc[使用 OIDC Bearer 令牌身份验证保护服务应用程序]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "link:https://www.keycloak.org/documentation.html[Keycloak documentation]"
msgstr "link:https://www.keycloak.org/documentation.html[Keycloak 文档]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "link:https://openid.net/connect/[OpenID Connect]"
msgstr "link:https://openid.net/connect/[OpenID Connect]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "link:https://tools.ietf.org/html/rfc7519[JSON Web Token]"
msgstr "link:https://tools.ietf.org/html/rfc7519[JSON网络令牌]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-openid-connect-client-reference.adoc[OpenID Connect and OAuth2 client and filters reference guide]"
msgstr "xref:security-openid-connect-client-reference.adoc[OpenID Connect 和 OAuth2 客户端及过滤器参考指南]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak]"
msgstr "xref:security-openid-connect-dev-services.adoc[Keycloak 的开发服务]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
msgid "xref:security-jwt-build.adoc[Sign and encrypt JWT tokens with SmallRye JWT Build]"
msgstr "xref:security-jwt-build.adoc[使用 SmallRye JWT Build 对 JWT 令牌进行签名和加密]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-authentication-mechanisms.adoc#oidc-jwt-oauth2-comparison[Choosing between OpenID Connect, SmallRye JWT, and OAuth2 authentication mechanisms]"
msgstr "xref:security-authentication-mechanisms.adoc#oidc-jwt-oauth2-comparison[在 OpenID Connect、SmallRye JWT 和 OAuth2 身份验证机制之间做出选择]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-authentication-mechanisms.adoc#combining-authentication-mechanisms[Combining authentication mechanisms]"
msgstr "xref:security-authentication-mechanisms.adoc#combining-authentication-mechanisms[组合认证机制]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-overview.adoc[Quarkus Security overview]"
msgstr "xref:security-overview.adoc[Quarkus 安全概述]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-keycloak-admin-client.adoc[Quarkus Keycloak Admin Client]"
msgstr "xref:security-keycloak-admin-client.adoc[Quarkus Keycloak 管理客户端]"

#: _versions/3.8/guides/security-oidc-bearer-token-authentication.adoc
#, fuzzy
msgid "xref:security-openid-connect-multitenancy.adoc[Using OpenID Connect Multi-Tenancy]"
msgstr "xref:security-openid-connect-multitenancy.adoc[使用 OpenID Connect 多租户功能]"
