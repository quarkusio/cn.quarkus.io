msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "OpenID Connect (OIDC) and OAuth2 Client and Filters Reference Guide"
msgstr "OpenID Connect (OIDC) 和 OAuth2 客户端及过滤器参考指南"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "This reference guide explains how to use:"
msgstr "本参考指南介绍了如何使用："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`quarkus-oidc-client`, `quarkus-oidc-client-reactive-filter` and `quarkus-oidc-client-filter` extensions to acquire and refresh access tokens from OpenID Connect and OAuth 2.0 compliant Authorization Servers such as link:https://www.keycloak.org[Keycloak]"
msgstr "`quarkus-oidc-client` `quarkus-oidc-client-reactive-filter` 和 扩展，从 OpenID Connect 和 OAuth 2.0 兼容授权服务器（如 `quarkus-oidc-client-filter` link:https://www.keycloak.org[Keycloak] ）获取和刷新访问令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`quarkus-oidc-token-propagation-reactive` and `quarkus-oidc-token-propagation` extensions to propagate the current `Bearer` or `Authorization Code Flow` access tokens"
msgstr "`quarkus-oidc-token-propagation-reactive` 和 扩展，以传播当前的 或 访问令牌 `quarkus-oidc-token-propagation` `Bearer` `Authorization Code Flow` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "The access tokens managed by these extensions can be used as HTTP Authorization Bearer tokens to access the remote services."
msgstr "这些扩展管理的访问令牌可用作 HTTP 授权承载令牌，以访问远程服务。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Also see xref:security-openid-connect-client.adoc[OpenID Connect Client and Token Propagation Quickstart]."
msgstr "另请参阅 xref:security-openid-connect-client.adoc[OpenID Connect 客户端和令牌传播快速入门] 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "OidcClient"
msgstr "OidcClient"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "Add the following dependency:"
msgstr "添加以下依赖关系："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using SmallRye Mutiny `Uni` and `Vert.x WebClient`."
msgstr "`quarkus-oidc-client` 扩展提供了一个反应式 ，可用于使用 SmallRye Mutiny 和 获取和刷新代币。 `io.quarkus.oidc.client.OidcClient` `Uni` `Vert.x WebClient`"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using the token grants such as `client_credentials` or `password` and refresh the tokens using a `refresh_token` grant."
msgstr "`OidcClient` 在构建时使用 IDP 令牌端点 URL（可自动发现或手动配置）进行初始化，并使用该端点通过令牌授权（如 或 ）获取访问令牌，以及通过 授权刷新令牌。 `client_credentials` `password` `refresh_token` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Token Endpoint Configuration"
msgstr "令牌端点配置"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "By default, the token endpoint address is discovered by adding a `/.well-known/openid-configuration` path to the configured `quarkus.oidc-client.auth-server-url`."
msgstr "默认情况下，令牌端点地址是通过向配置的 `quarkus.oidc-client.auth-server-url` 添加 `/.well-known/openid-configuration` 路径来发现的。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "For example, given this Keycloak URL:"
msgstr "例如，给定这个 Keycloak URL："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`OidcClient` will discover that the token endpoint URL is `http://localhost:8180/auth/realms/quarkus/protocol/openid-connect/tokens`."
msgstr "`OidcClient` 会发现令牌端点 URL 是 `http://localhost:8180/auth/realms/quarkus/protocol/openid-connect/tokens` ."

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Alternatively, if the discovery endpoint is not available or you want to save on the discovery endpoint round-trip, you can disable the discovery and configure the token endpoint address with a relative path value, for example:"
msgstr "另外，如果发现端点不可用或想节省发现端点的往返次数，可以禁用发现功能，并使用相对路径值等配置标记端点地址："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "A more compact way to configure the token endpoint URL without the discovery is to set `quarkus.oidc-client.token-path` to an absolute URL:"
msgstr "配置令牌端点 URL 而不进行发现的更简洁方法是将 `quarkus.oidc-client.token-path` 设置为绝对 URL："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Setting `quarkus.oidc-client.auth-server-url` and `quarkus.oidc-client.discovery-enabled` is not required in this case."
msgstr "在这种情况下，不需要设置 `quarkus.oidc-client.auth-server-url` 和 `quarkus.oidc-client.discovery-enabled` 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Supported Token Grants"
msgstr "支持代币赠款"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "The main token grants which `OidcClient` can use to acquire the tokens are the `client_credentials` (default) and `password` grants."
msgstr "`OidcClient` 可用于获取令牌的主要令牌授权是 `client_credentials` （默认）和 `password` 授权。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Client Credentials Grant"
msgstr "客户证书授予"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Here is how `OidcClient` can be configured to use the `client_credentials` grant:"
msgstr "以下是 `OidcClient` 配置为使用 `client_credentials` grant 的方法："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "The `client_credentials` grant allows to set extra parameters to the token request via `quarkus.oidc-client.grant-options.client.<param-name>=<value>`. Here is how to set the intended token recipient via the `audience` parameter:"
msgstr "`client_credentials` 授权允许通过 `quarkus.oidc-client.grant-options.client.<param-name>=<value>` 为令牌请求设置额外参数。以下是通过 `audience` 参数设置令牌接收者的方法："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Password Grant"
msgstr "密码授予"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Here is how `OidcClient` can be configured to use the `password` grant:"
msgstr "以下是 `OidcClient` 配置为使用 `password` grant 的方法："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "It can be further customized using a `quarkus.oidc-client.grant-options.password` configuration prefix, similarly to how the client credentials grant can be customized."
msgstr "可以使用 `quarkus.oidc-client.grant-options.password` 配置前缀对其进行进一步定制，这与客户凭据授予的定制方式类似。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Other Grants"
msgstr "其他补助金"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`OidcClient` can also help with acquiring the tokens using the grants which require some extra input parameters which cannot be captured in the configuration. These grants are `refresh_token` (with the external refresh token), `authorization_code`, as well as two grants which can be used to exchange the current access token, `urn:ietf:params:oauth:grant-type:token-exchange` and `urn:ietf:params:oauth:grant-type:jwt-bearer`."
msgstr "`OidcClient` 还可以帮助使用需要一些额外输入参数的授权来获取令牌，这些参数无法在配置中获取。这些授权包括 （外部刷新令牌）、 以及两个可用于交换当前访问令牌的授权 和 。 `refresh_token` `authorization_code` `urn:ietf:params:oauth:grant-type:token-exchange` `urn:ietf:params:oauth:grant-type:jwt-bearer`"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Using the `refresh_token` grant which uses an out-of-band refresh token to acquire a new set of tokens will be required if the existing refresh token has been posted to the current Quarkus endpoint for it to acquire the access token. In this case `OidcClient` needs to be configured as follows:"
msgstr "如果现有的刷新令牌已张贴到当前的 Quarkus 端点，则需要使用 `refresh_token` grant（使用带外刷新令牌获取一组新的令牌）来获取访问令牌。在这种情况下，需要对 `OidcClient` 进行如下配置："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "and then you can use `OidcClient.refreshTokens` method with a provided refresh token to get the access token."
msgstr "然后可以使用 `OidcClient.refreshTokens` 方法和提供的刷新令牌来获取访问令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Using the `urn:ietf:params:oauth:grant-type:token-exchange` or `urn:ietf:params:oauth:grant-type:jwt-bearer` grants might be required if you are building a complex microservices application and want to avoid the same `Bearer` token be propagated to and used by more than one service. See xref:token-propagation-reactive[Token Propagation in MicroProfile RestClient Reactive filter] and xref:token-propagation[Token Propagation in MicroProfile RestClient filter] for more details."
msgstr "如果您正在构建一个复杂的微服务应用程序，并希望避免同一个 `Bearer` 令牌被多个服务传播和使用，则可能需要使用 `urn:ietf:params:oauth:grant-type:token-exchange` 或 `urn:ietf:params:oauth:grant-type:jwt-bearer` 授权。有关详情，请参阅 xref:token-propagation-reactive[MicroProfile RestClient Reactive 过滤器中的令牌传播] 和 xref:token-propagation[MicroProfile RestClient 过滤器中的令牌传播] 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Using `OidcClient` to support the `authorization code` grant might be required if for some reason you cannot use the xref:security-oidc-code-flow-authentication.adoc[Quarkus OIDC extension] to support Authorization Code Flow. If there is a very good reason for you to implement Authorization Code Flow then you can configure `OidcClient` as follows:"
msgstr "如果由于某些原因无法使用 xref:security-oidc-code-flow-authentication.adoc[Quarkus OIDC 扩展] 来支持授权码流，则可能需要使用 `OidcClient` 来支持 `authorization code` grant。如果您有充分的理由实施授权代码流，那么您可以如下配置 `OidcClient` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "and then you can use `OidcClient.accessTokens` method accepting a Map of extra properties and pass the current `code` and `redirect_uri` parameters to exchange the authorization code for the tokens."
msgstr "然后可以使用 `OidcClient.accessTokens` 方法，该方法接受一个额外属性的映射表，并传递当前的 `code` 和 `redirect_uri` 参数，以便用授权代码交换令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`OidcClient` also supports the `urn:openid:params:grant-type:ciba` grant:"
msgstr "`OidcClient` 还支持 拨款： `urn:openid:params:grant-type:ciba` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "and then you can use `OidcClient.accessTokens` method accepting a Map of extra properties and pass `auth_req_id` parameter to exchange the authorization code for the tokens."
msgstr "然后就可以使用 `OidcClient.accessTokens` 方法，该方法接受一个额外属性的映射表，并通过 `auth_req_id` 参数将授权代码换成令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Grant scopes"
msgstr "赠款范围"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"You might need to request that a specific set of scopes is associated with an issued access token.\n"
"Use a dedicated `quarkus.oidc-client.scopes` list property, for example: `quarkus.oidc-client.scopes=email,phone`"
msgstr "您可能需要请求将一组特定的作用域与已签发的访问令牌关联起来。例如，使用专用的 `quarkus.oidc-client.scopes` 列表属性： `quarkus.oidc-client.scopes=email,phone`"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Use OidcClient directly"
msgstr "直接使用 OidcClient"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "One can use `OidcClient` directly as follows:"
msgstr "可以直接使用 `OidcClient` ，如下所示："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Inject Tokens"
msgstr "注入令牌"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You can inject `Tokens` which uses `OidcClient` internally. `Tokens` can be used to acquire the access tokens and refresh them if necessary:"
msgstr "您可以注入 `Tokens` ，它在内部使用 `OidcClient` 。 `Tokens` 可用于获取访问令牌，并在必要时刷新它们："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Use OidcClients"
msgstr "使用 OidcClients"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`io.quarkus.oidc.client.OidcClients` is a container of ``OidcClient``s - it includes a default `OidcClient` and named clients which can be configured like this:"
msgstr "`io.quarkus.oidc.client.OidcClients` 是 s 的容器--它包括一个默认的 和命名的客户端，可以这样配置： `OidcClient` `OidcClient` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Note in this case the default client is disabled with a `client-enabled=false` property. The `jwt-secret` client can be accessed like this:"
msgstr "请注意，在这种情况下，默认客户端是通过 `client-enabled=false` 属性禁用的。可以像这样访问 `jwt-secret` 客户端："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If you also use xref:security-openid-connect-multitenancy.adoc[OIDC multitenancy] and each OIDC tenant has its own associated `OidcClient` then you can use a Vert.x `RoutingContext` `tenantId` attribute, for example:"
msgstr "如果您也使用 xref:security-openid-connect-multitenancy.adoc[OIDC 多租] 户，并且每个 OIDC 租户都有自己的相关 `OidcClient` ，那么您可以使用 Vert.x `RoutingContext` `tenantId` 属性等："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If you need you can also create new `OidcClient` programmatically like this:"
msgstr "如果需要，也可以像这样通过编程创建新的 `OidcClient` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Inject named OidcClient and Tokens"
msgstr "注入命名的 OidcClient 和令牌"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "In case of multiple configured ``OidcClient``s you can specify the `OidcClient` injection target by the extra qualifier `@NamedOidcClient` instead of working with `OidcClients`:"
msgstr "如果有多个已配置的 `OidcClient` s，您可以通过额外的限定符 `@NamedOidcClient` 来指定 `OidcClient` 注入目标，而不是使用 `OidcClients` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "The same qualifier can be used to specify the `OidcClient` used for a `Tokens` injection:"
msgstr "同样的限定符也可用于指定 `OidcClient` 用于 `Tokens` 注入："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Use OidcClient in RestClient Reactive ClientFilter"
msgstr "在 RestClient 反应式客户端过滤器中使用 OidcClient"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Add the following Maven Dependency:"
msgstr "添加以下 Maven 依赖项"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Note it will also bring `io.quarkus:quarkus-oidc-client`."
msgstr "请注意，它还将带来 `io.quarkus:quarkus-oidc-client` 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`quarkus-oidc-client-reactive-filter` extension provides `io.quarkus.oidc.client.filter.OidcClientRequestReactiveFilter`."
msgstr "`quarkus-oidc-client-reactive-filter` 扩展名提供 。 `io.quarkus.oidc.client.filter.OidcClientRequestReactiveFilter`"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "It works similarly to the way `OidcClientRequestFilter` does (see xref:oidc-client-filter[Use OidcClient in MicroProfile RestClient client filter]) - it uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value. The difference is that it works with xref:rest-client-reactive.adoc[Reactive RestClient] and implements a non-blocking client filter which does not block the current IO thread when acquiring or refreshing the tokens."
msgstr "它的工作方式与 `OidcClientRequestFilter` 类似（请参阅 xref:oidc-client-filter[在 MicroProfile RestClient 客户端过滤器中使用 OidcClient] ）--它使用 `OidcClient` 获取访问令牌，必要时刷新令牌，并将其设置为 HTTP `Authorization` `Bearer` 方案值。所不同的是，它使用 xref:rest-client-reactive.adoc[Reactive RestClient] 并实现了一个非阻塞客户端过滤器，在获取或刷新令牌时不会阻塞当前 IO 线程。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`OidcClientRequestReactiveFilter` delays an initial token acquisition until it is executed to avoid blocking an IO thread."
msgstr "`OidcClientRequestReactiveFilter` 将初始令牌获取延迟至执行，以避免阻塞 IO 线程。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You can selectively register `OidcClientRequestReactiveFilter` by using either `io.quarkus.oidc.client.reactive.filter.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:"
msgstr "您可以使用 `io.quarkus.oidc.client.reactive.filter.OidcClientFilter` 或 `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` 注释有选择地注册 `OidcClientRequestReactiveFilter` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "or"
msgstr "或"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"`OidcClientRequestReactiveFilter` uses a default `OidcClient` by default. A named `OidcClient` can be selected with a `quarkus.oidc-client-reactive-filter.client-name` configuration property.\n"
"You can also select `OidcClient` by setting `value` attribute of the `@OidcClientFilter` annotation. The client name set through annotation has higher priority than the `quarkus.oidc-client-reactive-filter.client-name` configuration property.\n"
"For example, given xref:use-oidc-clients[this] `jwt-secret` named OIDC client declaration, you can refer to this client like this:"
msgstr "`OidcClientRequestReactiveFilter` 默认情况下使用默认的 。可以通过 配置属性选择一个已命名的 。也可以通过设置 注释的 属性来选择 。通过注解设置的客户端名称比 配置属性具有更高的优先级。例如，在 命名的 OIDC 客户端声明中，可以这样引用 `OidcClient` `quarkus.oidc-client-reactive-filter.client-name` `OidcClient` `@OidcClientFilter` `value` `OidcClient` `quarkus.oidc-client-reactive-filter.client-name` `jwt-secret` xref:use-oidc-clients[该] 客户端："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Use OidcClient in RestClient ClientFilter"
msgstr "在 RestClient 客户端过滤器中使用 OidcClient"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`quarkus-oidc-client-filter` extension provides `io.quarkus.oidc.client.filter.OidcClientRequestFilter` Jakarta REST ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value."
msgstr "`quarkus-oidc-client-filter` 扩展提供了 Jakarta REST ClientRequestFilter，它使用 获取访问令牌，必要时刷新访问令牌，并将访问令牌设置为 HTTP  方案值。 `io.quarkus.oidc.client.filter.OidcClientRequestFilter` `OidcClient` `Authorization` `Bearer` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "By default, this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short-lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`."
msgstr "默认情况下，该过滤器将在初始化时获取 `OidcClient` ，以获取第一对访问令牌和刷新令牌。如果访问令牌使用时间较短，而刷新令牌又不可用，则应通过 `quarkus.oidc-client.early-tokens-acquisition=false` 延迟获取令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.client.filter.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:"
msgstr "您可以使用 `io.quarkus.oidc.client.filter.OidcClientFilter` 或 `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` 注释有选择地注册 `OidcClientRequestFilter` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or Jakarta REST clients if `quarkus.oidc-client-filter.register-filter=true` property is set."
msgstr "另外，如果设置了 `quarkus.oidc-client-filter.register-filter=true` 属性， `OidcClientRequestFilter` 可以自动在所有 MP Rest 或 Jakarta REST 客户端注册。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"`OidcClientRequestFilter` uses a default `OidcClient` by default. A named `OidcClient` can be selected with a `quarkus.oidc-client-filter.client-name` configuration property.\n"
"You can also select `OidcClient` by setting `value` attribute of the `@OidcClientFilter` annotation. The client name set through annotation has higher priority than the `quarkus.oidc-client-filter.client-name` configuration property.\n"
"For example, given xref:use-oidc-clients[this] `jwt-secret` named OIDC client declaration, you can refer to this client like this:"
msgstr "`OidcClientRequestFilter` 默认情况下使用默认的 。可以通过 配置属性选择一个已命名的 。也可以通过设置 注释的 属性来选择 。通过注解设置的客户端名称比 配置属性具有更高的优先级。例如，在 命名的 OIDC 客户端声明中，可以这样引用 `OidcClient` `quarkus.oidc-client-filter.client-name` `OidcClient` `@OidcClientFilter` `value` `OidcClient` `quarkus.oidc-client-filter.client-name` `jwt-secret` xref:use-oidc-clients[该] 客户端："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Use Custom RestClient ClientFilter"
msgstr "使用自定义 RestClient 客户端过滤器"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If you prefer you can use your own custom filter and inject `Tokens`:"
msgstr "如果您愿意，可以使用自己的自定义过滤器并注入 `Tokens` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "The `Tokens` producer will acquire and refresh the tokens, and the custom filter will decide how and when to use the token."
msgstr "`Tokens` 生成器将获取和刷新令牌，自定义过滤器将决定如何以及何时使用令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You can also inject named `Tokens`, see xref:named-oidc-clients[Inject named OidcClient and Tokens]"
msgstr "您还可以注入命名的 `Tokens` ，请参阅 xref:named-oidc-clients[注入命名的 OidcClient 和令牌] 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Refreshing Access Tokens"
msgstr "刷新访问令牌"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"`OidcClientRequestReactiveFilter`, `OidcClientRequestFilter` and `Tokens` producers will refresh the current expired access token if the refresh token is available.\n"
"Additionally, `quarkus.oidc-client.refresh-token-time-skew` property can be used for a preemptive access token refreshment to avoid sending nearly expired access tokens that might cause HTTP 401 errors. For example if this property is set to `3S` and the access token will expire in less than 3 seconds then this token will be auto-refreshed."
msgstr "`OidcClientRequestReactiveFilter` 如果有刷新令牌， `OidcClientRequestFilter` 和 `Tokens` 生产者将刷新当前已过期的访问令牌。此外， `quarkus.oidc-client.refresh-token-time-skew` 属性可用于抢先刷新访问令牌，以避免发送可能导致 HTTP 401 错误的快过期访问令牌。例如，如果该属性设置为 `3S` ，且访问令牌将在 3 秒内过期，那么该令牌将被自动刷新。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If the access token needs to be refreshed but no refresh token is available then an attempt will be made to acquire a new token using the configured grant such as `client_credentials`."
msgstr "如果需要刷新访问令牌，但没有可用的刷新令牌，则会尝试使用配置的授权（如 `client_credentials` ）获取新令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Note that some OpenID Connect Providers will not return a refresh token in a `client_credentials` grant response. For example, starting from Keycloak 12 a refresh token will not be returned by default for `client_credentials`. The providers might also restrict the number of times a refresh token can be used."
msgstr "请注意，某些 OpenID Connect 提供商不会在 `client_credentials` grant 响应中返回刷新令牌。例如，从 Keycloak 12 开始， `client_credentials` 默认不返回刷新令牌。提供程序还可能限制刷新令牌的使用次数。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Revoking Access Tokens"
msgstr "撤销访问令牌"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If your OpenId Connect provider such as Keycloak supports a token revocation endpoint then `OidcClient#revokeAccessToken` can be used to revoke the current access token. The revocation endpoint URL will be discovered alongside the token request URI or can be configured with `quarkus.oidc-client.revoke-path`."
msgstr "如果您的 OpenId Connect 提供商（如 Keycloak）支持令牌撤销端点，那么 `OidcClient#revokeAccessToken` 可用于撤销当前访问令牌。撤销端点 URL 将与令牌请求 URI 一起被发现，也可以通过 `quarkus.oidc-client.revoke-path` 进行配置。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You might want to have the access token revoked if using this token with a REST client fails with HTTP `401` or the access token has already been used for a long time and you'd like to refresh it."
msgstr "如果在 REST 客户端使用该令牌时出现 HTTP `401` 失败，或者访问令牌已经使用了很长时间，需要重新刷新，则可能需要撤销访问令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "This can be achieved by requesting a token refresh using a refresh token. However, if the refresh token is not available then you can refresh it by revoking it first and then request a new access token."
msgstr "这可以通过使用刷新令牌请求刷新令牌来实现。不过，如果刷新令牌不可用，那么可以先撤销它，然后再申请一个新的访问令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "OidcClient Authentication"
msgstr "OidcClient 验证"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"`OidcClient` has to authenticate to the OpenID Connect Provider for the `client_credentials` and other grant requests to succeed.\n"
"All the https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication[OIDC Client Authentication] options are supported, for example:"
msgstr "`OidcClient` 必须向 OpenID Connect Provider 进行身份验证，这样 和其他授予请求才能成功。支持所有 `client_credentials` link:https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication[OIDC 客户端身份验证] 选项，例如"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`client_secret_basic`:"
msgstr "`client_secret_basic` :"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "or with the secret retrieved from a xref:credentials-provider.adoc[CredentialsProvider]:"
msgstr "或从 xref:credentials-provider.adoc[证书提供者] 获取的秘密："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`client_secret_post`:"
msgstr "`client_secret_post` :"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`client_secret_jwt`, signature algorithm is `HS256`:"
msgstr "`client_secret_jwt` ，签名算法为 `HS256` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "or with the secret retrieved from a xref:credentials-provider.adoc[CredentialsProvider], signature algorithm is `HS256`:"
msgstr "或使用从 xref:credentials-provider.adoc[证书提供者] 获取的秘密，签名算法为 `HS256` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`private_key_jwt` with the PEM key file, signature algorithm is `RS256`:"
msgstr "`private_key_jwt` PEM 密钥文件，签名算法为 ： `RS256`"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`private_key_jwt` with the keystore file, signature algorithm is `RS256`:"
msgstr "`private_key_jwt` 与密钥存储文件一起，签名算法为 ： `RS256`"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Using `client_secret_jwt` or `private_key_jwt` authentication methods ensures that no client secret goes over the wire."
msgstr "使用 `client_secret_jwt` 或 `private_key_jwt` 身份验证方法可确保客户端秘密不会通过网络传输。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Additional JWT Authentication options"
msgstr "其他 JWT 验证选项"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If either `client_secret_jwt` or `private_key_jwt` authentication methods are used then the JWT signature algorithm, key identifier, audience, subject and issuer can be customized, for example:"
msgstr "如果使用 `client_secret_jwt` 或 `private_key_jwt` 身份验证方法，则可以定制 JWT 签名算法、密钥标识符、受众、主题和签发人等："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Apple POST JWT"
msgstr "苹果 POST JWT"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Apple OpenID Connect Provider uses a `client_secret_post` method where a secret is a JWT produced with a `private_key_jwt` authentication method but with Apple account specific issuer and subject properties."
msgstr "Apple OpenID Connect Provider 使用 `client_secret_post` 方法，其中的密文是使用 `private_key_jwt` 身份验证方法生成的 JWT，但带有特定于 Apple 帐户的签发人和主体属性。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`quarkus-oidc-client` supports a non-standard `client_secret_post_jwt` authentication method which can be configured as follows:"
msgstr "`quarkus-oidc-client` 支持非标准的 身份验证方法，可按如下方式配置： `client_secret_post_jwt` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Mutual TLS"
msgstr "相互 TLS"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Some OpenID Connect Providers require that a client is authenticated as part of the mutual TLS (`mTLS`) authentication process."
msgstr "某些 OpenID Connect 提供商要求在相互 TLS ( `mTLS` ) 验证过程中对客户端进行验证。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`quarkus-oidc-client` can be configured as follows to support `mTLS`:"
msgstr "`quarkus-oidc-client` 配置如下，以支持 ： `mTLS`"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "Testing"
msgstr "测试"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "Start by adding the following dependencies to your test project:"
msgstr "首先在你的测试项目中添加以下依赖项："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "Wiremock"
msgstr "Wiremock"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "Add the following dependencies to your test project:"
msgstr "在你的测试项目中添加以下依赖项："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Write a Wiremock-based `QuarkusTestResourceLifecycleManager`, for example:"
msgstr "例如，编写基于 Wiremock 的 `QuarkusTestResourceLifecycleManager` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Prepare the REST test endpoints. You can have the test front-end endpoint, which uses the injected MP REST client with a registered OidcClient filter, call the downstream endpoint. This endpoint echoes the token back. For example, see the `integration-tests/oidc-client-wiremock` in the `main` Quarkus repository."
msgstr "准备 REST 测试端点。可以让测试前端端点（使用注入的 MP REST 客户端和注册的 OidcClient 过滤器）调用下游端点。该端点会回传令牌。例如，请参阅 `main` Quarkus 存储库中的 `integration-tests/oidc-client-wiremock` 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Set `application.properties`, for example:"
msgstr "例如，设置 `application.properties` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "and finally write the test code. Given the Wiremock-based resource above, the first test invocation should return `access_token_1` access token which will expire in 4 seconds. Use `awaitility` to wait for about 5 seconds, and now the next test invocation should return `access_token_2` access token which confirms the expired `access_token_1` access token has been refreshed."
msgstr "最后编写测试代码。鉴于上述基于 Wiremock 的资源，第一次测试调用应返回 `access_token_1` 访问令牌，该令牌将在 4 秒后过期。使用 `awaitility` 等待约 5 秒钟，现在下一次测试调用应返回 `access_token_2` 访问令牌，确认过期的 `access_token_1` 访问令牌已被刷新。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "Keycloak"
msgstr "Keycloak"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If you work with Keycloak then you can use the same approach as described in the xref:security-oidc-bearer-token-authentication.adoc#integration-testing-keycloak[OpenID Connect Bearer Token Integration testing] Keycloak section."
msgstr "如果使用 Keycloak，则可以使用 xref:security-oidc-bearer-token-authentication.adoc#integration-testing-keycloak[OpenID Connect 承载令牌集成测试] Keycloak 部分所述的相同方法。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "How to check the errors in the logs"
msgstr "如何检查日志中的错误"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Enable `io.quarkus.oidc.client.runtime.OidcClientImpl` `TRACE` level logging to see more details about the token acquisition and refresh errors:"
msgstr "启用 `io.quarkus.oidc.client.runtime.OidcClientImpl` `TRACE` 级日志记录，可查看有关令牌获取和刷新错误的更多详细信息："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Enable `io.quarkus.oidc.client.runtime.OidcClientRecorder` `TRACE` level logging to see more details about the OidcClient initialization errors:"
msgstr "启用 `io.quarkus.oidc.client.runtime.OidcClientRecorder` `TRACE` 级日志记录，以查看有关 OidcClient 初始化错误的更多详细信息："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "OIDC request customization"
msgstr "OIDC 申请定制"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You can customize OIDC requests made by Quarkus to the OIDC provider by registering one or more `OidcRequestFiler` implementations which can update or add new request headers, for example, a filter can analyze the request body and add its digest as a new header value:"
msgstr "您可以通过注册一个或多个 `OidcRequestFiler` 实现来定制 Quarkus 向 OIDC 提供商发出的 OIDC 请求，这些实现可以更新或添加新的请求标头，例如，过滤器可以分析请求正文并将其摘要添加为新的标头值："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Token Propagation Reactive"
msgstr "令牌传播"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "The `quarkus-oidc-token-propagation-reactive` extension provides RestEasy Reactive Client `io.quarkus.oidc.token.propagation.reactive.AccessTokenRequestReactiveFilter` that simplifies the propagation of authentication information by propagating the xref:security-oidc-bearer-token-authentication.adoc[Bearer token] present in the current active request or the token acquired from the xref:security-oidc-code-flow-authentication.adoc[Authorization code flow mechanism], as the HTTP `Authorization` header's `Bearer` scheme value."
msgstr "`quarkus-oidc-token-propagation-reactive` 扩展提供了 RestEasy Reactive Client `io.quarkus.oidc.token.propagation.reactive.AccessTokenRequestReactiveFilter` ，通过传播当前活动请求中的 xref:security-oidc-bearer-token-authentication.adoc[承载器令牌] 或从 xref:security-oidc-code-flow-authentication.adoc[授权代码流机制] 中获取的令牌作为 HTTP `Authorization` 头的 `Bearer` 方案值，简化了身份验证信息的传播。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You can selectively register `AccessTokenRequestReactiveFilter` by using either `io.quarkus.oidc.token.propagation.AccessToken` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotation, for example:"
msgstr "例如，您可以使用 `io.quarkus.oidc.token.propagation.AccessToken` 或 `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` 注释有选择地注册 `AccessTokenRequestReactiveFilter` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Additionally, `AccessTokenRequestReactiveFilter` can support a complex application that needs to exchange the tokens before propagating them."
msgstr "此外， `AccessTokenRequestReactiveFilter` 还能支持需要在传播代币前交换代币的复杂应用。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If you work with link:https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange[Keycloak] or other OpenID Connect Providers which support a link:https://tools.ietf.org/html/rfc8693[Token Exchange] token grant then you can configure `AccessTokenRequestReactiveFilter` to exchange the token like this:"
msgstr "如果你使用的是 link:https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange[Keycloak] 或其他支持 link:https://tools.ietf.org/html/rfc8693[令牌交换] 令牌授权的 OpenID Connect 提供商，那么你可以配置 `AccessTokenRequestReactiveFilter` 像这样交换令牌："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Note `AccessTokenRequestReactiveFilter` will use `OidcClient` to exchange the current token, and you can use `quarkus.oidc-client.grant-options.exchange` to set the additional exchange properties expected by your OpenID Connect Provider."
msgstr "注意 `AccessTokenRequestReactiveFilter` 将使用 `OidcClient` 来交换当前令牌，您可以使用 `quarkus.oidc-client.grant-options.exchange` 来设置 OpenID Connect 提供商期望的其他交换属性。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If you work with providers such as `Azure` that link:https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#example[require using] link:https://www.rfc-editor.org/rfc/rfc7523#section-2.1[JWT bearer token grant] to exchange the current token then you can configure `AccessTokenRequestReactiveFilter` to exchange the token like this:"
msgstr "如果您与 `Azure` 等提供商合作， link:https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#example[需要使用] link:https://www.rfc-editor.org/rfc/rfc7523#section-2.1[JWT 不记名令牌授权] 来交换当前令牌，那么您可以配置 `AccessTokenRequestReactiveFilter` ，像这样交换令牌："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`AccessTokenRequestReactiveFilter` uses a default `OidcClient` by default. A named `OidcClient` can be selected with a `quarkus.oidc-token-propagation-reactive.client-name` configuration property."
msgstr "`AccessTokenRequestReactiveFilter` 默认情况下使用默认的 。可通过 配置属性选择一个名为 的文件。 `OidcClient` `quarkus.oidc-token-propagation-reactive.client-name` `OidcClient` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "Token Propagation"
msgstr "令牌传播"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"The `quarkus-oidc-token-propagation` extension provides two Jakarta REST `jakarta.ws.rs.client.ClientRequestFilter` class implementations that simplify the propagation of authentication information.\n"
"`io.quarkus.oidc.token.propagation.AccessTokenRequestFilter` propagates the xref:security-oidc-bearer-token-authentication.adoc[Bearer token] present in the current active request or the token acquired from the xref:security-oidc-code-flow-authentication.adoc[Authorization code flow mechanism], as the HTTP `Authorization` header's `Bearer` scheme value.\n"
"The `io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter` provides the same functionality, but in addition provides support for JWT tokens."
msgstr "`quarkus-oidc-token-propagation` 扩展提供了两个简化身份验证信息传播的 Jakarta REST `jakarta.ws.rs.client.ClientRequestFilter` 类实现。 `io.quarkus.oidc.token.propagation.AccessTokenRequestFilter` 传播当前活动请求中的 xref:security-oidc-bearer-token-authentication.adoc[承载器令牌] 或从 xref:security-oidc-code-flow-authentication.adoc[授权代码流机制] 中获取的令牌，作为 HTTP `Authorization` 标头的 `Bearer` 方案值。 `io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter` 提供了相同的功能，但此外还支持 JWT 令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "When you need to propagate the current Authorization Code Flow access token then the immediate token propagation will work well - as the code flow access tokens (as opposed to ID tokens) are meant to be propagated for the current Quarkus endpoint to access the remote services on behalf of the currently authenticated user."
msgstr "当您需要传播当前的授权代码流访问令牌时，即时令牌传播就能很好地发挥作用--因为代码流访问令牌（与 ID 令牌不同）是为当前的 Quarkus 端点传播的，以便代表当前通过身份验证的用户访问远程服务。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "However, the direct end to end Bearer token propagation should be avoided if possible. For example, `Client -> Service A -> Service B` where `Service B` receives a token sent by `Client` to `Service A`. In such cases `Service B` will not be able to distinguish if the token came from `Service A` or from `Client` directly. For `Service B` to verify the token came from `Service A` it should be able to assert a new issuer and audience claims."
msgstr "不过，应尽可能避免直接进行端到端承载符令牌传播。例如， `Client → Service A → Service B` ， `Service B` 接收 `Client` 发送到 `Service A` 的令牌。在这种情况下， `Service B` 将无法区分令牌是来自 `Service A` 还是直接来自 `Client` 。 `Service B` 要验证令牌是否来自 `Service A` ，就必须声称有新的签发人和受众。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Additionally, a complex application might need to exchange or update the tokens before propagating them. For example, the access context might be different when `Service A` is accessing `Service B`. In this case, `Service A` might be granted a narrow or a completely different set of scopes to access `Service B`."
msgstr "此外，复杂的应用程序在传播令牌前可能需要交换或更新令牌。例如，当 `Service A` 访问 `Service B` 时，访问上下文可能不同。在这种情况下， `Service A` 可能会被授予一组范围较窄或完全不同的范围来访问 `Service B` 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "The following sections show how `AccessTokenRequestFilter` and `JsonWebTokenRequestFilter` can help."
msgstr "下文将介绍 `AccessTokenRequestFilter` 和 `JsonWebTokenRequestFilter` 如何提供帮助。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "RestClient AccessTokenRequestFilter"
msgstr "访问令牌请求过滤器"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`AccessTokenRequestFilter` treats all tokens as Strings and as such it can work with both JWT and opaque tokens."
msgstr "`AccessTokenRequestFilter` 将所有令牌都视为字符串，因此它既能处理 JWT 令牌，也能处理不透明令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You can selectively register `AccessTokenRequestFilter` by using either `io.quarkus.oidc.token.propagation.AccessToken` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`, for example:"
msgstr "例如，您可以使用 `io.quarkus.oidc.token.propagation.AccessToken` 或 `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` 有选择地注册 `AccessTokenRequestFilter` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Alternatively, `AccessTokenRequestFilter` can be registered automatically with all MP Rest or Jakarta REST clients if `quarkus.oidc-token-propagation.register-filter` property is set to `true` and `quarkus.oidc-token-propagation.json-web-token` property is set to `false` (which is a default value)."
msgstr "另外，如果将 `quarkus.oidc-token-propagation.register-filter` 属性设置为 `true` ，将 `quarkus.oidc-token-propagation.json-web-token` 属性设置为 `false` （这是默认值），则 `AccessTokenRequestFilter` 可以在所有 MP Rest 或 Jakarta REST 客户端自动注册。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Exchange Token Before Propagation"
msgstr "传播前交换令牌"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If the current access token needs to be exchanged before propagation and you work with link:https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange[Keycloak] or other OpenID Connect Provider which supports a link:https://tools.ietf.org/html/rfc8693[Token Exchange] token grant then you can configure `AccessTokenRequestFilter` like this:"
msgstr "如果在传播之前需要交换当前访问令牌，并且使用 link:https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange[Keycloak] 或其他支持令牌 link:https://tools.ietf.org/html/rfc8693[交换] 令牌授权的 OpenID Connect 提供商，则可以像这样配置 `AccessTokenRequestFilter` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If you work with providers such as `Azure` that link:https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#example[require using] link:https://www.rfc-editor.org/rfc/rfc7523#section-2.1[JWT bearer token grant] to exchange the current token then you can configure `AccessTokenRequestFilter` to exchange the token like this:"
msgstr "如果您与 `Azure` 等提供商合作， link:https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#example[需要使用] link:https://www.rfc-editor.org/rfc/rfc7523#section-2.1[JWT 不记名令牌授权] 来交换当前令牌，那么您可以配置 `AccessTokenRequestFilter` ，像这样交换令牌："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Note `AccessTokenRequestFilter` will use `OidcClient` to exchange the current token, and you can use `quarkus.oidc-client.grant-options.exchange` to set the additional exchange properties expected by your OpenID Connect Provider."
msgstr "注意 `AccessTokenRequestFilter` 将使用 `OidcClient` 来交换当前令牌，您可以使用 `quarkus.oidc-client.grant-options.exchange` 来设置 OpenID Connect 提供商期望的其他交换属性。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`AccessTokenRequestFilter` uses a default `OidcClient` by default. A named `OidcClient` can be selected with a `quarkus.oidc-token-propagation.client-name` configuration property."
msgstr "`AccessTokenRequestFilter` 默认情况下使用默认的 。可通过 配置属性选择一个名为 的配置。 `OidcClient` `quarkus.oidc-token-propagation.client-name` `OidcClient` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "RestClient JsonWebTokenRequestFilter"
msgstr "RestClient JsonWebTokenRequestFilter"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Using `JsonWebTokenRequestFilter` is recommended if you work with Bearer JWT tokens where these tokens can have their claims such as `issuer` and `audience` modified and the updated tokens secured (for example, re-signed) again. It expects an injected `org.eclipse.microprofile.jwt.JsonWebToken` and therefore will not work with the opaque tokens. Also, if your OpenID Connect Provider supports a Token Exchange protocol then it is recommended to use `AccessTokenRequestFilter` instead - as both JWT and opaque bearer tokens can be securely exchanged with `AccessTokenRequestFilter`."
msgstr "如果使用不记名 JWT 标记，建议使用 `JsonWebTokenRequestFilter` ，因为这些标记可以修改其声明（如 `issuer` 和 `audience` ），并再次确保更新后标记的安全（如重新签名）。它需要注入 `org.eclipse.microprofile.jwt.JsonWebToken` ，因此无法使用不透明令牌。此外，如果 OpenID Connect 提供商支持令牌交换协议，建议使用 `AccessTokenRequestFilter` 代替，因为 JWT 和不透明承载令牌都可以通过 `AccessTokenRequestFilter` 安全交换。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "`JsonWebTokenRequestFilter` makes it easy for `Service A` implementations to update the injected `org.eclipse.microprofile.jwt.JsonWebToken` with the new `issuer` and `audience` claim values and secure the updated token again with a new signature. The only difficult step is to ensure `Service A` has a signing key - it should be provisioned from a secure file system or from the remote secure storage such as Vault."
msgstr "`JsonWebTokenRequestFilter` 这样， 实现就可以很容易地用新的 和 索值更新注入的 ，并用新的签名再次保护更新后的令牌。唯一困难的步骤是确保 拥有签名密钥--应从安全文件系统或远程安全存储（如 Vault）中提供。 `Service A` `issuer` `audience` `org.eclipse.microprofile.jwt.JsonWebToken` `Service A` "

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "You can selectively register `JsonWebTokenRequestFilter` by using either `io.quarkus.oidc.token.propagation.JsonWebToken` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`, for example:"
msgstr "例如，您可以使用 `io.quarkus.oidc.token.propagation.JsonWebToken` 或 `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` 有选择地注册 `JsonWebTokenRequestFilter` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Alternatively, `JsonWebTokenRequestFilter` can be registered automatically with all MicroProfile REST or Jakarta REST clients if both `quarkus.oidc-token-propagation.register-filter` and `quarkus.oidc-token-propagation.json-web-token` properties are set to `true`."
msgstr "另外，如果 `quarkus.oidc-token-propagation.register-filter` 和 `quarkus.oidc-token-propagation.json-web-token` 属性都设置为 `true` ， `JsonWebTokenRequestFilter` 可以自动注册到所有 MicroProfile REST 或 Jakarta REST 客户端。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "Update Token Before Propagation"
msgstr "传播前更新令牌"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "If the injected token needs to have its `iss` (issuer) and/or `aud` (audience) claims updated and secured again with a new signature then you can configure `JsonWebTokenRequestFilter` like this:"
msgstr "如果注入的令牌需要更新其 `iss` （发行方）和/或 `aud` （受众）声明，并用新签名再次保护，则可以这样配置 `JsonWebTokenRequestFilter` ："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "As already noted above, use `AccessTokenRequestFilter` if you work with Keycloak or OpenID Connect Provider which supports a Token Exchange protocol."
msgstr "如上所述，如果使用支持令牌交换协议的 Keycloak 或 OpenID Connect Provider，请使用 `AccessTokenRequestFilter` 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"You can generate the tokens as described in xref:security-oidc-bearer-token-authentication.adoc#integration-testing[OpenID Connect Bearer Token Integration testing] section.\n"
"Prepare the REST test endpoints. You can have the test front-end endpoint, which uses the injected MP REST client with a registered token propagation filter, call the downstream endpoint. For example, see the `integration-tests/oidc-token-propagation` in the `main` Quarkus repository."
msgstr "您可以按照 xref:security-oidc-bearer-token-authentication.adoc#integration-testing[OpenID Connect 承载令牌集成测试] 部分的描述生成令牌。准备 REST 测试端点。可以让测试前端端点调用下游端点，测试前端端点使用注入的 MP REST 客户端和已注册的令牌传播过滤器。例如，请参阅 `main` Quarkus 存储库中的 `integration-tests/oidc-token-propagation` 。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "The `quarkus-oidc-token-propagation-reactive` extension provides `io.quarkus.oidc.token.propagation.reactive.AccessTokenRequestReactiveFilter` which can be used to propagate the current `Bearer` or `Authorization Code Flow` access tokens."
msgstr "`quarkus-oidc-token-propagation-reactive` 扩展提供 `io.quarkus.oidc.token.propagation.reactive.AccessTokenRequestReactiveFilter` ，可用于传播当前 `Bearer` 或 `Authorization Code Flow` 访问令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"The `quarkus-oidc-token-propagation-reactive` extension (as opposed to the non-reactive `quarkus-oidc-token-propagation` extension) does not currently support the exchanging or resigning the tokens before the propagation.\n"
"However, these features might be added in the future."
msgstr "`quarkus-oidc-token-propagation-reactive` 扩展（与非反应式 `quarkus-oidc-token-propagation` 扩展相反）目前不支持在传播前交换或放弃令牌。不过，将来可能会添加这些功能。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "GraphQL client integration"
msgstr "GraphQL 客户端集成"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"The `quarkus-oidc-client-graphql` extension provides a way to integrate an\n"
"OIDC client into xref:smallrye-graphql-client.adoc[GraphQL clients]. This\n"
"works similarly as with REST clients. When this extension is present, any\n"
"configured (that means NOT created programmatically via the builder, but via\n"
"configuration properties) GraphQL client will attempt to use the OIDC client\n"
"to obtain an access token and set it as an `Authorization` header value.\n"
"OIDC client will also refresh expired access tokens."
msgstr "`quarkus-oidc-client-graphql` 扩展提供了一种将 OIDC 客户端集成到 xref:smallrye-graphql-client.adoc[GraphQL 客户端] 的方法。其工作原理与 REST 客户端类似。如果存在该扩展，任何已配置（这意味着不是通过生成器编程创建，而是通过配置属性创建）的 GraphQL 客户端都会尝试使用 OIDC 客户端获取访问令牌，并将其设置为 `Authorization` 标头值。OIDC 客户端还会刷新已过期的访问令牌。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "To configure which OIDC client should be used by GraphQL client, select one of the configured OIDC clients with the `quarkus.oidc-client-graphql.client-name` property, for example:"
msgstr "要配置 GraphQL 客户端应使用哪个 OIDC 客户端，请使用 `quarkus.oidc-client-graphql.client-name` 属性从已配置的 OIDC 客户端中选择一个，例如："

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"quarkus.oidc-client-graphql.client-name=oidc-client-for-graphql\n"
"\n"
"# example declaration of the OIDC client itself\n"
"quarkus.oidc-client.oidc-client-for-graphql.auth-server-url=${keycloak.url}\n"
"quarkus.oidc-client.oidc-client-for-graphql.grant.type=password\n"
"quarkus.oidc-client.oidc-client-for-graphql.grant-options.password.username=${username}\n"
"quarkus.oidc-client.oidc-client-for-graphql.grant-options.password.password=${password}\n"
"quarkus.oidc-client.oidc-client-for-graphql.client-id=${quarkus.oidc.client-id}\n"
"quarkus.oidc-client.oidc-client-for-graphql.credentials.client-secret.value=${keycloak.credentials.secret}\n"
"quarkus.oidc-client.oidc-client-for-graphql.credentials.client-secret.method=POST"
msgstr "quarkus.oidc-client-graphql.client-name=oidc-client-for-graphql"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"If you don't specify the `quarkus.oidc-client-graphql.client-name` property,\n"
"GraphQL clients will use the default OIDC client (without an explicit name)."
msgstr "如果不指定 `quarkus.oidc-client-graphql.client-name` 属性，GraphQL 客户端将使用默认的 OIDC 客户端（没有明确的名称）。"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"Specifically for type-safe GraphQL clients, you can override this on a\n"
"per-client basis by annotating the `GraphQLClientApi` interface with\n"
"`@io.quarkus.oidc.client.filter.OidcClientFilter`. For example:"
msgstr "对于类型安全的 GraphQL 客户端，您可以通过使用 `@io.quarkus.oidc.client.filter.OidcClientFilter` 对 `GraphQLClientApi` 接口进行注解，从而在每个客户端的基础上覆盖这一点。例如"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid ""
"To be able to use this with a programmatically created GraphQL client, both\n"
"builders (`VertxDynamicGraphQLClientBuilder` and\n"
"`VertxTypesafeGraphQLClientBuilder`) contain a method `dynamicHeader(String,\n"
"Uni<String>`) that allows you to plug in a header that might change for\n"
"every request. To plug an OIDC client into it, use"
msgstr "为了能与以编程方式创建的 GraphQL 客户端一起使用，两个构建器（ `VertxDynamicGraphQLClientBuilder` 和 `VertxTypesafeGraphQLClientBuilder` ）都包含一个方法 `dynamicHeader(String, Uni<String>` ），允许您插入一个可能在每个请求中都会改变的标头。要将 OIDC 客户端插入其中，请使用"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
msgid "References"
msgstr "参考文献"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "xref:security-openid-connect-client.adoc[OpenID Connect Client and Token Propagation Quickstart]"
msgstr "xref:security-openid-connect-client.adoc[OpenID Connect 客户端和令牌传播快速入门]"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "xref:security-oidc-bearer-token-authentication.adoc[OIDC Bearer token authentication]"
msgstr "xref:security-oidc-bearer-token-authentication.adoc[OIDC 承载令牌验证]"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "xref:security-oidc-code-flow-authentication.adoc[OIDC code flow mechanism for protecting web applications]"
msgstr "xref:security-oidc-code-flow-authentication.adoc[保护网络应用程序的 OIDC 代码流机制]"

#: _versions/3.6/guides/security-openid-connect-client-reference.adoc
#, fuzzy
msgid "xref:security-overview.adoc[Quarkus Security overview]"
msgstr "xref:security-overview.adoc[Quarkus 安全概述]"
