msgid ""
msgstr ""
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _versions/3.6/guides/writing-extensions.adoc
msgid "Writing Your Own Extension"
msgstr "编写您自己的扩展"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Quarkus extensions add a new developer focused behavior to the core offering, and consist of two distinct parts, buildtime augmentation and runtime container. The augmentation part is responsible for all metadata processing, such as reading annotations, XML descriptors etc. The output of this augmentation phase is recorded bytecode which is responsible for directly instantiating the relevant runtime services."
msgstr "Quarkus 扩展为核心产品添加了以开发人员为中心的新行为，由两个不同的部分组成：构建时增强和运行时容器。增强部分负责所有元数据处理，如读取注释、XML 描述符等。增强阶段的输出是记录字节码，字节码负责直接实例化相关的运行时服务。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"This means that metadata is only processed once at build time, which both saves on startup time, and also on memory\n"
"usage as the classes etc that are used for processing are not loaded (or even present) in the runtime JVM."
msgstr "这意味着元数据只在构建时处理一次，既节省了启动时间，也节省了内存使用量，因为用于处理的类等不会加载（甚至不会出现在运行时的 JVM 中）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This is an in-depth documentation, see the xref:building-my-first-extension.adoc[building my first extension] if you need an introduction."
msgstr "这是一份深入的文档，如果需要了解更多信息，请参阅 \" xref:building-my-first-extension.adoc[构建我的第一个扩展] \"。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extension philosophy"
msgstr "推广理念"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This section is a work in progress and gathers the philosophy under which extensions should be designed and written."
msgstr "本节正在编写中，收集了设计和编写扩展的理念。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Why an extension framework"
msgstr "为什么需要扩展框架"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Quarkus’s mission is to transform your entire application including the libraries it uses, into an artifact that uses significantly less resources than traditional approaches. These can then be used to build native applications using GraalVM.\n"
"To do this you need to analyze and understand the full \"closed world\" of the application.\n"
"Without the full and complete context, the best that can be achieved is partial and limited generic support.\n"
"By using the Quarkus extension approach, we can bring Java applications in line with memory footprint constrained environments like Kubernetes or cloud platforms."
msgstr "Quarkus 的使命是将您的整个应用程序（包括其使用的库）转化为一个使用资源比传统方法少得多的工件。然后，这些资源可用于使用 GraalVM 构建本地应用程序。要做到这一点，您需要分析和理解应用程序的完整 \"封闭世界\"。如果没有完整的上下文，最好的结果也只能是部分和有限的通用支持。通过使用 Quarkus 扩展方法，我们可以使 Java 应用与 Kubernetes 或云平台等内存占用受限的环境保持一致。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The Quarkus extension framework results in significantly improved resource utilization even when GraalVM is not used (e.g. in HotSpot).\n"
"Let’s list the actions an extension performs:"
msgstr "即使不使用 GraalVM（例如在 HotSpot 中），Quarkus 扩展框架也能显著提高资源利用率。让我们列出扩展执行的操作："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Gather build time metadata and generate code"
msgstr "收集构建时间元数据并生成代码"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This part has nothing to do with GraalVM, it is how Quarkus starts frameworks “at build time”"
msgstr "这部分内容与 GraalVM 无关，而是 Quarkus 如何 \"在构建时 \"启动框架。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The extension framework facilitates reading metadata, scanning classes as well as generating classes as needed"
msgstr "扩展框架便于读取元数据、扫描类以及根据需要生成类"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A small part of the extension work is executed at runtime via the generated classes, while the bulk of the work is done at build time (called deployment time)"
msgstr "一小部分扩展工作在运行时通过生成的类执行，而大部分工作在构建时（称为部署时）完成"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Enforce opinionated and sensible defaults based on the close world view of the application (e.g. an application with no `@Entity` does not need to start Hibernate ORM)"
msgstr "根据应用程序的实际情况，执行合理的默认设置（例如，没有 `@Entity` 的应用程序不需要启动 Hibernate ORM）"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An extension hosts Substrate VM code substitution so that libraries can run on GraalVM"
msgstr "扩展主机 Substrate VM 代码替换，使库可在 GraalVM 上运行"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Most changes are pushed upstream to help the underlying library run on GraalVM"
msgstr "大多数更改都会推送到上游，以帮助底层库在 GraalVM 上运行"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Not all changes can be pushed upstream, extensions host Substrate VM substitutions - which is a form of code patching - so that libraries can run"
msgstr "并不是所有的更改都能被推送到上游，扩展主机 Substrate VM 的替换（这也是一种代码修补形式）可以使库能够运行"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Host Substrate VM code substitution to help dead code elimination based on the application needs"
msgstr "主机底层虚拟机代码替换，帮助根据应用需求消除死代码"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This is application dependent and cannot really be shared in the library itself"
msgstr "这取决于应用程序，无法在程序库中共享"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "For example, Quarkus optimizes the Hibernate code because it knows it only needs a specific connection pool and cache provider"
msgstr "例如，Quarkus 会优化 Hibernate 代码，因为它知道自己只需要特定的连接池和缓存提供者"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Send metadata to GraalVM for example classes in need of reflection"
msgstr "为需要反思的示例类向 GraalVM 发送元数据"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This information is not static per library (e.g. Hibernate) but the framework has the semantic knowledge and knows which classes need to have reflection (for example @Entity classes)"
msgstr "这些信息不是每个库（如 Hibernate）的静态信息，但框架拥有语义知识，知道哪些类需要反射（如 @Entity 类）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Favor build time work over runtime work"
msgstr "优先考虑构建时的工作，而不是运行时的工作"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"As much as possible favor doing work at build time (deployment part of the extension) as opposed to let the framework do work at startup time (runtime).\n"
"The more is done there, the smaller Quarkus applications using that extension will be and the faster they will load."
msgstr "尽可能在构建时（扩展的部署部分）完成工作，而不是让框架在启动时（运行时）完成工作。在启动时完成的工作越多，使用该扩展的 Quarkus 应用程序就越小，加载速度也就越快。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "How to expose configuration"
msgstr "如何公开配置"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Quarkus simplifies the most common usages.\n"
"This means that its defaults might be different from the library it integrates."
msgstr "Quarkus 简化了最常用的用法。这意味着它的默认设置可能与其集成的库不同。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"To make the simple experience easiest, unify the configuration in `application.properties` via SmallRye Config.\n"
"Avoid library specific configuration files, or at least make them optional: e.g. `persistence.xml` for Hibernate ORM is optional."
msgstr "为了让用户体验更简单，可通过 SmallRye Config 在 `application.properties` 中统一配置。避免使用特定库的配置文件，或至少使其成为可选配置文件：例如，Hibernate ORM 的 `persistence.xml` 就是可选配置文件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Extensions should see the configuration holistically as a Quarkus application instead of focusing on the library experience.\n"
"For example `quarkus.database.url` and friends are shared between extensions as defining a database access is a shared task (instead of a `hibernate.` property for example).\n"
"The most useful configuration options should be exposed as `quarkus.[extension].` instead of the natural namespace of the library.\n"
"Less common properties can live in the library namespace."
msgstr "扩展程序应将配置视为 Quarkus 应用程序的整体，而不是只关注库体验。例如， `quarkus.database.url` 和好友在扩展之间共享，因为定义数据库访问是一项共享任务（而不是 `hibernate.` 属性）。最有用的配置选项应作为 `quarkus.[extension].` 而不是库的自然命名空间公开。不常用的属性可以放在库名称空间中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"To fully enable the close world assumptions that Quarkus can optimize best, it is better to consider configuration options as build time settled vs overridable at runtime.\n"
"Of course properties like host, port, password should be overridable at runtime.\n"
"But many properties like enable caching or setting the JDBC driver can safely require a rebuild of the application."
msgstr "为了充分实现 Quarkus 能够优化的近似世界假设，最好将配置选项视为构建时解决的问题，而不是运行时可覆盖的问题。当然，主机、端口、密码等属性应该可以在运行时重写。但许多属性，如启用缓存或设置 JDBC 驱动程序，则需要重新构建应用程序才能安全使用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Static Init Config"
msgstr "静态初始化配置"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If the extension provides additional Config Sources and if these are required during Static Init, these must be registered with `StaticInitConfigBuilderBuildItem`. Configuration in Static Init does not scan for additional sources to avoid double initialization at application startup time."
msgstr "如果扩展提供了额外的配置源，并且在静态初始化过程中需要这些配置源，则这些配置源必须在 `StaticInitConfigBuilderBuildItem` 注册。静态初始化中的配置不会扫描附加源，以避免在应用程序启动时重复初始化。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Expose your components via CDI"
msgstr "通过 CDI 公开组件"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Since CDI is the central programming model when it comes to component composition, frameworks and extensions should expose their components as beans that are easily consumable by user applications.\n"
"For example, Hibernate ORM exposes `EntityManagerFactory` and `EntityManager` beans, the connection pool exposes `DataSource` beans etc.\n"
"Extensions must register these bean definitions at build time."
msgstr "由于 CDI 是组件组合的核心编程模型，框架和扩展应将其组件公开为 bean，以便于用户应用程序使用。例如，Hibernate ORM 公开了 `EntityManagerFactory` 和 `EntityManager` Bean，连接池公开了 `DataSource` Bean 等。扩展必须在构建时注册这些 Bean 定义。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Beans backed by classes"
msgstr "由类支持的豆"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An extension can produce an xref:cdi-integration.adoc#additional_bean_build_item[`AdditionalBeanBuildItem`] to instruct the container to read a bean definition from a class as if it was part of the original application:"
msgstr "扩展可以生成一个 xref:cdi-integration.adoc#additional_bean_build_item[AdditionalBeanBuildItem] 来指示容器从类中读取 bean 定义，就好像它是原始应用程序的一部分："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Bean Class Registered by `AdditionalBeanBuildItem`"
msgstr "豆类 注册人 `AdditionalBeanBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If a bean registered by an `AdditionalBeanBuildItem` does not specify a scope then `@Dependent` is assumed."
msgstr "如果 `AdditionalBeanBuildItem` 注册的 bean 没有指定作用域，则假定 `@Dependent` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "All other beans can inject such a bean:"
msgstr "所有其他豆子都可以注入这样的豆子："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Bean Injecting a Bean Produced by an `AdditionalBeanBuildItem`"
msgstr "豆注入一个由 `AdditionalBeanBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "And vice versa - the extension bean can inject application beans and beans provided by other extensions:"
msgstr "反之亦然，扩展 bean 可以注入应用程序 bean 和其他扩展提供的 bean："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extension Bean Injection Example"
msgstr "扩展 Bean 注入示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Inject a bean provided by other extension."
msgstr "注入其他扩展提供的 Bean。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Inject all beans matching the type `List<String>`."
msgstr "注入与类型 `List<String>` 匹配的所有豆子。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Bean initialization"
msgstr "Bean 初始化"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Some components may require additional initialization based on information collected during augmentation.\n"
"The most straightforward solution is to obtain a bean instance and call a method directly from a build step.\n"
"However, it is _illegal_ to obtain a bean instance during the augmentation phase.\n"
"The reason is that the CDI container is not started yet.\n"
"It's started during the xref:bootstrap-three-phases[Static init bootstrap phase]."
msgstr "某些组件可能需要根据增强过程中收集的信息进行额外的初始化。最直接的解决方案是直接从构建步骤中获取一个 Bean 实例并调用一个方法。但是，在增强阶段获取 Bean 实例是 _非法的_ 。原因是 CDI 容器尚未启动。它是在 xref:bootstrap-three-phases[静态初始引导阶段] 启动的。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`BUILD_AND_RUN_TIME_FIXED` and `RUN_TIME` config roots can be injected in any bean. `RUN_TIME` config roots should only be injected after the bootstrap though."
msgstr "`BUILD_AND_RUN_TIME_FIXED` 和 配置根可以注入到任何 bean 中。但 配置根只能在引导后注入。 `RUN_TIME` `RUN_TIME` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"It is possible to invoke a bean method from a xref:bytecode-recording[recorder method] though.\n"
"If you need to access a bean in a `@Record(STATIC_INIT)` build step then is must either depend on the `BeanContainerBuildItem` or wrap the logic in a `BeanContainerListenerBuildItem`.\n"
"The reason is simple - we need to make sure the CDI container is fully initialized and started.\n"
"However, it is safe to expect that the CDI container is fully initialized and running in a `@Record(RUNTIME_INIT)` build step.\n"
"You can obtain a reference to the container via `CDI.current()` or Quarkus-specific `Arc.container()`."
msgstr "不过，可以从 xref:bytecode-recording[记录器方法] 中调用 bean 方法。如果您需要在 `@Record(STATIC_INIT)` 构建步骤中访问 bean，那么必须依赖于 `BeanContainerBuildItem` 或将逻辑封装在 `BeanContainerListenerBuildItem` 中。原因很简单--我们需要确保 CDI 容器已完全初始化并启动。不过，在 `@Record(RUNTIME_INIT)` 构建步骤中完全初始化和运行 CDI 容器是安全的。您可以通过 `CDI.current()` 或 Quarkus 特有的 `Arc.container()` 获取容器的引用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Don't forget to make sure the bean state guarantees the visibility, e.g. via the `volatile` keyword."
msgstr "不要忘记确保 bean 状态能保证可见性，例如通过 `volatile` 关键字。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"There is one significant drawback of this \"late initialization\" approach.\n"
"An _uninitialized_ bean may be accessed by other extensions or application components that are instantiated during bootstrap.\n"
"We'll cover a more robust solution in the xref:synthetic_beans[Synthetic beans]."
msgstr "这种 \"延迟初始化 \"方法有一个很大的缺点。在引导过程中实例化的其他扩展或应用程序组件可能会访问 _未初始_ 化的 Bean。我们将在 xref:synthetic_beans[合成豆中] 介绍一种更稳健的解决方案。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Default beans"
msgstr "默认豆子"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A very useful pattern of creating such beans but also giving application code the ability to easily override some beans with custom implementations, is to use\n"
"the `@DefaultBean` that Quarkus provides.\n"
"This is best explained with an example."
msgstr "创建此类 Bean 的一种非常有用的模式是使用 Quarkus 提供的 `@DefaultBean` ，这种模式不仅能创建此类 Bean，还能让应用程序代码轻松地覆盖某些 Bean，并采用自定义的实现方式。最好用一个例子来说明这一点。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Let us assume that the Quarkus extension needs to provide a `Tracer` bean which application code is meant to inject into its own beans."
msgstr "假设 Quarkus 扩展需要提供一个 `Tracer` Bean，应用程序代码可以将其注入到自己的 Bean 中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If for example application code wants to use `Tracer`, but also needs to use a custom `Reporter` bean, such a requirement could easily be done using something like:"
msgstr "例如，如果应用程序代码希望使用 `Tracer` ，但同时又需要使用自定义的 `Reporter` Bean，那么可以使用类似的方法轻松实现这一要求："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "How to Override a Bean Defined by a Library/Quarkus Extension that doesn't use @DefaultBean"
msgstr "如何重写由库/Quarkus 扩展定义的、未使用 @DefaultBean 的 Bean"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Although `@DefaultBean` is the recommended approach, it is also possible for application code to override beans provided by an extension by marking beans as a CDI `@Alternative` and including `@Priority` annotation.\n"
"Let's show a simple example.\n"
"Suppose we work on an imaginary \"quarkus-parser\" extension and we have a default bean implementation:"
msgstr "虽然 `@DefaultBean` 是推荐的方法，但应用代码也可以通过将 Bean 标记为 CDI `@Alternative` 并包含 `@Priority` 注释来覆盖扩展提供的 Bean。让我们举一个简单的例子。假设我们在一个假想的 \"quarkus-parser \"扩展上工作，我们有一个默认的 Bean 实现："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "And our extension also consumes this parser:"
msgstr "我们的扩展也会消耗这个解析器："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Now, if a user or even some other extension needs to override the default implementation of the `Parser` the simplest solution is to use CDI `@Alternative` + `@Priority`:"
msgstr "现在，如果用户甚至其他扩展需要覆盖 `Parser` 的默认实现，最简单的解决方案就是使用 CDI `@Alternative` + `@Priority` ："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`MyParser` is an alternative bean."
msgstr "`MyParser` 是一种替代豆。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Enables the alternative. The priority could be any number to override the default bean but if there are multiple alternatives the highest priority wins."
msgstr "启用替代方案。优先级可以是任何数字，以覆盖默认 bean，但如果有多个备选方案，则优先级最高者胜出。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "CDI alternatives are only considered during injection and type-safe resolution. For example the default implementation would still receive observer notifications."
msgstr "CDI 替代方案只在注入和类型安全解析时才会被考虑。例如，默认实现仍会接收观察者通知。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Synthetic beans"
msgstr "合成豆"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Sometimes it is very useful to be able to register a synthetic bean.\n"
"Bean attributes of a synthetic bean are not derived from a java class, method or field.\n"
"Instead, the attributes are specified by an extension."
msgstr "有时，注册合成 Bean 非常有用。合成 Bean 的 Bean 属性并非源自 Java 类、方法或字段。相反，这些属性是由扩展指定的。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Since the CDI container does not control the instantiation of a synthetic bean the dependency injection and other services (such as interceptors) are not supported.\n"
"In other words, it's up to the extension to provide all required services to a synthetic bean instance."
msgstr "由于 CDI 容器不控制合成 bean 的实例化，因此不支持依赖注入和其他服务（如拦截器）。换句话说，需要由扩展为合成 bean 实例提供所有必需的服务。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"There are several ways to register a xref:cdi-reference.adoc#synthetic_beans[synthetic bean] in Quarkus.\n"
"In this chapter, we will cover a use case that can be used to initialize extension beans in a safe manner (compared to xref:bean_init[Bean initialization])."
msgstr "在 Quarkus 中注册 xref:cdi-reference.adoc#synthetic_beans[合成 Bean] 有几种方法。在本章中，我们将介绍一种可用于以安全方式（与 xref:bean_init[Bean 初始化] 相比）初始化扩展 Bean 的用例。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The `SyntheticBeanBuildItem` can be used to register a synthetic bean:"
msgstr "`SyntheticBeanBuildItem` 可用来注册合成豆："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "whose instance can be easily produced through a xref:bytecode-recording[recorder],"
msgstr "其实例可通过 xref:bytecode-recording[录音机] 轻松制作、"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "to provide a \"context\" bean that holds all the information collected during augmentation so that the real components do not need any \"late initialization\" because they can inject the context bean directly."
msgstr "提供一个 \"上下文 \"Bean，保存在增强过程中收集到的所有信息，这样真正的组件就不需要任何 \"后期初始化\"，因为它们可以直接注入上下文 Bean。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Instance Produced Through Recorder"
msgstr "通过记录器生成的实例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The string value is recorded in the bytecode and used to initialize the instance of `Foo`."
msgstr "字符串值会记录在字节码中，并用于初始化 `Foo` 的实例。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "\"Context\" Holder"
msgstr "\"背景 \"持有人"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The \"real\" components can inject the `TestContext` directly."
msgstr "真实 \"组件可以直接注入 `TestContext` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Some types of extensions"
msgstr "某些类型的扩展"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "There exist multiple stereotypes of extension, let's list a few."
msgstr "外延存在多种定型观念，让我们列举几种。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Bare library running"
msgstr "运行裸图书馆"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"This is the less sophisticated extension.\n"
"It consists of a set of patches to make sure a library runs on GraalVM.\n"
"If possible, contribute these patches upstream, not in extensions.\n"
"Second best is to write Substrate VM substitutions, which are patches applied during native image compilation."
msgstr "这是一种不太复杂的扩展。它由一组补丁组成，以确保库在 GraalVM 上运行。如果可能，请将这些补丁贡献到上游，而不是在扩展中。其次是编写 Substrate VM 替换，这是在本地镜像编译过程中应用的补丁。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Get a framework running"
msgstr "运行框架"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A framework at runtime typically reads configuration, scan the classpath and classes for metadata (annotations, getters etc.), build a metamodel on top of which it runs, find options via the service loader pattern, prepare invocation calls (reflection), proxy interfaces, etc. +\n"
"These operations should be done at build time and the metamodel be passed to the recorder DSL that will generate classes that will be executed at runtime and boot the framework."
msgstr ""
"运行时的框架通常会读取配置、扫描 classpath 和类以获取元数据（注释、getters 等）、在其基础上构建元模型并运行、通过服务加载器模式查找选项、准备调用调用（反射）、代理接口等。\n"
"\n"
" 这些操作应在构建时完成，元模型应传递给记录器 DSL，后者将生成在运行时执行的类并启动框架。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Get a CDI portable extension running"
msgstr "运行 CDI 便携式扩展"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The CDI portable extension model is very flexible.\n"
"Too flexible to benefit from the build time boot promoted by Quarkus.\n"
"Most extension we have seen do not make use of these extreme flexibility capabilities.\n"
"The way to port a CDI extension to Quarkus is to rewrite it as a Quarkus extension which will define the various beans at build time (deployment time in extension parlance)."
msgstr "CDI 便携式扩展模型非常灵活。由于过于灵活，Quarkus 倡导的构建时间引导功能无法从中受益。我们看到的大多数扩展都没有利用这些极高的灵活性。将 CDI 扩展移植到 Quarkus 的方法是将其重写为 Quarkus 扩展，在构建时（扩展术语为部署时）定义各种 Bean。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Technical aspect"
msgstr "技术方面"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Three Phases of Bootstrap and Quarkus Philosophy"
msgstr "Bootstrap 和 Quarkus 理念的三个阶段"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "There are three distinct bootstrap phases of a Quarkus app:"
msgstr "Quarkus 应用程序有三个不同的引导阶段："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Augmentation"
msgstr "扩建"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"This is the first phase, and is done by the xref:build-step-processors[Build Step Processors]. These processors have access to Jandex annotation\n"
"information and can parse any descriptors and read annotations, but should not attempt to load any application classes. The output of these\n"
"build steps is some recorded bytecode, using an extension of the ObjectWeb ASM project called Gizmo(ext/gizmo), that is used to actually bootstrap the application at runtime.\n"
"Depending on the `io.quarkus.deployment.annotations.ExecutionTime` value of the `@io.quarkus.deployment.annotations.Record` annotation associated with the build step,\n"
"the step may be run in a different JVM based on the following two modes."
msgstr "这是第一阶段，由 xref:build-step-processors[构建步骤处理器] 完成。这些处理器可以访问 Jandex 注释信息，可以解析任何描述符并读取注释，但不应尝试加载任何应用程序类。这些构建步骤的输出是使用 ObjectWeb ASM 项目扩展 Gizmo(ext/gizmo) 录制的字节码，用于在运行时实际引导应用程序。根据与构建步骤相关的 `@io.quarkus.deployment.annotations.Record` 注释的 `io.quarkus.deployment.annotations.ExecutionTime` 值，该步骤可在以下两种模式的不同 JVM 中运行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Static Init"
msgstr "静态启动"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If bytecode is recorded with `@Record(STATIC_INIT)` then it will be executed from a static init method on the main\n"
"class. For a native executable build, this code is executed in a normal JVM as part of the native build\n"
"process, and any retained objects that are produced in this stage will be directly serialized into the native executable via an image mapped file.\n"
"This means that if a framework can boot in this phase then it will have its booted state directly written to the\n"
"image, and so the boot code does not need to be executed when the image is started."
msgstr "如果使用 `@Record(STATIC_INIT)` 记录字节码，那么它将通过主类上的静态 init 方法执行。对于本地可执行文件的构建，这些代码将作为本地构建过程的一部分在普通 JVM 中执行，在此阶段生成的任何保留对象都将通过映像映射文件直接序列化到本地可执行文件中。这意味着，如果框架能在此阶段启动，那么它的启动状态将直接写入映像，因此启动映像时无需执行启动代码。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "There are some restrictions on what can be done in this stage as the Substrate VM disallows some objects in the native executable. For example you should not attempt to listen on a port or start threads in this phase. In addition, it is disallowed to read run time configuration during static initialization."
msgstr "由于 Substrate VM 不允许本地可执行文件中的某些对象，因此在这一阶段的操作会受到一些限制。例如，在此阶段不应尝试监听端口或启动线程。此外，在静态初始化期间不允许读取运行时配置。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"In non-native pure JVM mode, there is no real difference between Static and Runtime Init, except that Static Init is always executed first. This mode benefits from the same build phase augmentation as native mode as the descriptor parsing and annotation scanning are done\n"
"at build time and any associated class/framework dependencies can be removed from the build output jar. In servers like\n"
"WildFly, deployment related classes such as XML parsers hang around for the life of the application, using up valuable\n"
"memory. Quarkus aims to eliminate this, so that the only classes loaded at runtime are actually used at runtime."
msgstr "在非本地纯 JVM 模式中，静态初始化和运行时初始化并无实质区别，只是静态初始化总是先执行。由于描述符解析和注释扫描是在构建时完成的，而且任何相关的类/框架依赖关系都可以从构建输出 jar 中移除，因此这种模式与本地模式一样受益于构建阶段的增强功能。在 WildFly 等服务器中，XML 解析器等与部署相关的类会在应用程序的整个生命周期中一直存在，从而占用宝贵的内存。Quarkus 的目标是消除这种情况，使运行时加载的类仅在运行时实际使用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"As an example, the only reason that a Quarkus application should load an XML parser is if the user is using XML in their\n"
"application. Any XML parsing of configuration should be done in the Augmentation phase."
msgstr "举例来说，Quarkus 应用程序加载 XML 解析器的唯一原因是用户在其应用程序中使用了 XML。任何 XML 配置解析都应在增强阶段完成。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Runtime Init"
msgstr "运行时启动"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If bytecode is recorded with `@Record(RUNTIME_INIT)` then it is executed from the application's main method. This code\n"
"will be run on native executable boot. In general as little code as possible should be executed in this phase, and should\n"
"be restricted to code that needs to open ports etc."
msgstr "如果使用 `@Record(RUNTIME_INIT)` 记录了字节码，则会在应用程序的主方法中执行。这些代码将在本地可执行文件启动时运行。一般来说，在这一阶段应尽可能少执行代码，并应仅限于需要打开端口等的代码。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Pushing as much as possible into the `@Record(STATIC_INIT)` phase allows for two different optimizations:"
msgstr "将尽可能多的信息推送到 `@Record(STATIC_INIT)` 阶段，可以实现两种不同的优化："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "In both native executable and pure JVM mode this allows the app to start as fast as possible since processing was done during build time. This also minimizes the classes/native code needed in the application to pure runtime related behaviors."
msgstr "在本地可执行文件和纯 JVM 模式下，由于处理过程在构建时就已完成，因此应用程序可以尽可能快地启动。这样还能将应用程序中需要的类/本地代码减少到纯运行时相关行为。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Another benefit with native executable mode is that Substrate can more easily eliminate features that are not used. If features are directly initialized via bytecode, Substrate can detect that a method is never called and eliminate\n"
"that method. If config is read at runtime, Substrate cannot reason about the contents of the config and so needs to keep all features in case they are required."
msgstr "本地可执行模式的另一个好处是，Substrate 可以更轻松地消除不使用的功能。如果特性是通过字节码直接初始化的，Substrate 可以检测到某个方法从未被调用，从而消除该方法。如果配置是在运行时读取的，Substrate 无法推理配置的内容，因此需要保留所有功能，以备不时之需。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Project setup"
msgstr "项目设置"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Your extension project should be setup as a multi-module project with two submodules:"
msgstr "您的扩展项目应设置为包含两个子模块的多模块项目："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A deployment time submodule that handles the build time processing and bytecode recording."
msgstr "部署时间子模块，用于处理构建时间处理和字节码记录。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A runtime submodule that contains the runtime behavior that will provide the extension behavior in the native executable or runtime JVM."
msgstr "运行时子模块，包含运行时行为，将在本地可执行文件或运行时 JVM 中提供扩展行为。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Your runtime artifact should depend on `io.quarkus:quarkus-core`, and possibly the runtime artifacts of other Quarkus\n"
"modules if you want to use functionality provided by them.\n"
"Your deployment time module should depend on `io.quarkus:quarkus-core-deployment`, your runtime artifact,\n"
"and possibly the deployment artifacts of other Quarkus modules if you want to use functionality provided by them."
msgstr "您的运行时工件应依赖于 `io.quarkus:quarkus-core` ，如果您想使用其他 Quarkus 模块提供的功能，还可能依赖于它们的运行时工件。您的部署时间模块应依赖于 `io.quarkus:quarkus-core-deployment` 、您的运行时构件以及其他 Quarkus 模块的部署构件（如果您想使用它们提供的功能）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Under no circumstances can the runtime module depend on a deployment artifact. This would result\n"
"in pulling all the deployment time code into runtime scope, which defeats the purpose of having the split."
msgstr "在任何情况下，运行时模块都不能依赖于部署工件。这将导致所有部署时代码被拉入运行时范围，从而违背了拆分的初衷。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Using Maven"
msgstr "使用 Maven"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You will need to include the `io.quarkus:quarkus-extension-maven-plugin` and configure the `maven-compiler-plugin` to detect the `quarkus-extension-processor` annotation processor to collect and generate the necessary xref:extension-metadata.adoc[Quarkus extension metadata] for the extension artifacts, if you are using the Quarkus parent pom it will automatically inherit the correct configuration."
msgstr "你需要包含 `io.quarkus:quarkus-extension-maven-plugin` ，并配置 `maven-compiler-plugin` 以检测 `quarkus-extension-processor` 注释处理器，从而为扩展工件收集并生成必要的 xref:extension-metadata.adoc[Quarkus 扩展元数据] ，如果你使用的是 Quarkus 父 pom，它会自动继承正确的配置。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You may want to use the `create-extension` mojo of `{quarkus-platform-groupid}:quarkus-maven-plugin` to create these Maven modules - see the next section."
msgstr "您可能需要使用 `create-extension` mojo of `{quarkus-platform-groupid}:quarkus-maven-plugin` 来创建这些 Maven 模块--请参阅下一节。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"By convention the deployment time artifact has the `-deployment` suffix, and the runtime artifact\n"
"has no suffix (and is what the end user adds to their project)."
msgstr "按照惯例，部署时工件的后缀是 `-deployment` ，而运行时工件没有后缀（是最终用户添加到其项目中的内容）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The above `maven-compiler-plugin` configuration requires version 3.5+."
msgstr "上述 `maven-compiler-plugin` 配置需要 3.5 以上版本。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You will also need to configure the `maven-compiler-plugin` of the deployment module to detect the `quarkus-extension-processor` annotation processor."
msgstr "您还需要配置部署模块的 `maven-compiler-plugin` ，以检测 `quarkus-extension-processor` 注释处理器。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Create new Quarkus Core extension modules using Maven"
msgstr "使用 Maven 创建新的 Quarkus Core 扩展模块"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Quarkus provides `create-extension` Maven Mojo to initialize your extension project."
msgstr "Quarkus 提供 `create-extension` Maven Mojo 来初始化扩展项目。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "It will try to auto-detect its options:"
msgstr "它会尝试自动检测其选项："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "from `quarkus` (Quarkus Core) or `quarkus/extensions` directory, it will use the 'Quarkus Core' extension layout and defaults."
msgstr "`quarkus` (Quarkus Core) 或 `quarkus/extensions` 目录中，它将使用 \"Quarkus Core \"扩展布局和默认设置。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "with `-DgroupId=io.quarkiverse.[extensionId]`, it will use the 'Quarkiverse' extension layout and defaults."
msgstr "`-DgroupId=io.quarkiverse.[extensionId]` ，它将使用 \"Quarkiverse \"扩展布局和默认设置。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "in other cases it will use the 'Standalone' extension layout and defaults."
msgstr "在其他情况下，它将使用 \"独立 \"扩展布局和默认设置。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "we may introduce other layout types in the future."
msgstr "我们将来可能会引入其他布局类型。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You may not specify any parameter to use the interactive mode: `mvn {quarkus-platform-groupid}:quarkus-maven-plugin:{quarkus-version}:create-extension -N`"
msgstr "使用交互模式时，您可以不指定任何参数： `mvn {quarkus-platform-groupid}:quarkus-maven-plugin:{quarkus-version}:create-extension -N`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "As and example, let's add a new extension called `my-ext` to the Quarkus source tree:"
msgstr "例如，让我们在 Quarkus 源代码树中添加一个名为 `my-ext` 的新扩展："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "By default, the `groupId`, `version`, `quarkusVersion`, `namespaceId`, and `namespaceName` will be consistent with other Quarkus core extensions."
msgstr "默认情况下， `groupId` , `version` , `quarkusVersion` , `namespaceId` 和 `namespaceName` 将与其他 Quarkus 核心扩展保持一致。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The extension description is important as it is displayed on https://code.quarkus.io/, when listing extensions with the Quarkus CLI, etc."
msgstr "扩展描述非常重要，因为它会显示在 link:https://code.quarkus.io/[https://code.quarkus.io/ 上，] 在使用 Quarkus CLI 列出扩展时也是如此。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The above sequence of commands does the following:"
msgstr "上述命令序列执行以下操作："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Creates four new Maven modules:"
msgstr "创建四个新的 Maven 模块："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus-my-ext-parent` in the `extensions/my-ext` directory"
msgstr "`quarkus-my-ext-parent` `extensions/my-ext` 目录中"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus-my-ext` in the `extensions/my-ext/runtime` directory"
msgstr "`quarkus-my-ext` `extensions/my-ext/runtime` 目录中"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus-my-ext-deployment` in the `extensions/my-ext/deployment` directory; a basic `MyExtProcessor` class is generated in this module."
msgstr "`quarkus-my-ext-deployment` `extensions/my-ext/deployment` 目录中；该模块生成了一个基本的 类。 `MyExtProcessor` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus-my-ext-integration-test` in the `integration-tests/my-ext/deployment` directory; an empty Jakarta REST Resource class and two test classes (for JVM mode and native mode) are generated in this module."
msgstr "`quarkus-my-ext-integration-test` `integration-tests/my-ext/deployment` 目录中；该模块会生成一个空的 Jakarta REST 资源类和两个测试类（JVM 模式和本地模式）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Links these three modules where necessary:"
msgstr "必要时将这三个模块连接起来："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus-my-ext-parent` is added to the `<modules>` of `quarkus-extensions-parent`"
msgstr "`quarkus-my-ext-parent` 被添加到 的 `<modules>` `quarkus-extensions-parent`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus-my-ext` is added to the `<dependencyManagement>` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr "`quarkus-my-ext` 被添加到 Quarkus BOM（物料清单）的 中。 `<dependencyManagement>` `bom/application/pom.xml`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus-my-ext-deployment` is added to the `<dependencyManagement>` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr "`quarkus-my-ext-deployment` 被添加到 Quarkus BOM（物料清单）的 中。 `<dependencyManagement>` `bom/application/pom.xml`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus-my-ext-integration-test` is added to the `<modules>` of `quarkus-integration-tests-parent`"
msgstr "`quarkus-my-ext-integration-test` 被添加到 的 `<modules>` `quarkus-integration-tests-parent`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You also have to fill the xref:extension-metadata.adoc#quarkus-extension-yaml[quarkus-extension.yaml] template file that describe your extension inside the runtime module `src/main/resources/META-INF` folder."
msgstr "你还必须在运行模块 `src/main/resources/META-INF` 文件夹中填写描述你的扩展的 xref:extension-metadata.adoc#quarkus-extension-yaml[quarkus-extension.yaml] 模板文件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This is the `quarkus-extension.yaml` template of the `quarkus-agroal` extension, you can use it as an example:"
msgstr "这是 `quarkus-agroal` 扩展的 `quarkus-extension.yaml` 模板，您可以将其作为范例："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "the name of the extension that will be displayed to users"
msgstr "将显示给用户的分机名称"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "keywords that can be used to find the extension in the extension catalog"
msgstr "可用于在扩展目录中查找扩展的关键字"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "link to the extension's guide or documentation"
msgstr "扩展指南或文档的链接"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "categories under which the extension should appear on https://code.quarkus.io[code.quarkus.io], could be omitted, in which case the extension will still be listed but not under any specific category"
msgstr "扩展应该出现在 link:https://code.quarkus.io[code.quarkus.io] 上的类别，可以省略，在这种情况下，扩展仍然会被列出，但不在任何特定类别下"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "maturity status, which could be `stable`, `preview` or `experimental`, evaluated by extension maintainers"
msgstr "成熟度状态可能是 `stable` 、 `preview` 或 `experimental` ，由扩展维护者评估"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The `name` parameter of the mojo is optional.\n"
"If you do not specify it on the command line, the plugin will derive it from `extensionId` by replacing dashes with spaces and uppercasing each token.\n"
"So you may consider omitting explicit `name` in some cases."
msgstr "Mojo 的 `name` 参数为可选参数。如果不在命令行中指定，插件将从 `extensionId` 派生，用空格替换破折号，并将每个标记大写。因此，在某些情况下，您可以考虑省略明确的 `name` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Please refer to https://github.com/quarkusio/quarkus/blob/{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java[CreateExtensionMojo JavaDoc] for all the available options of the mojo."
msgstr "有关 mojo 的所有可用选项，请参阅 link:https://github.com/quarkusio/quarkus/blob/{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java[CreateExtensionMojo JavaDoc] 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Using Gradle"
msgstr "使用 Gradle"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"You will need to apply the `io.quarkus.extension` plugin in the `runtime` module of your extension project.\n"
"The plugin includes the `extensionDescriptor` task that will generate `META-INF/quarkus-extension.properties` and `META-INF/quarkus-extension.yml` files.\n"
"The plugin also enables the `io.quarkus:quarkus-extension-processor` annotation processor in both `deployment` and `runtime` modules to collect and generate the rest of the xref:extension-metadata.adoc[Quarkus extension metadata].\n"
"The name of the deployment module can be configured in the plugin by setting the `deploymentModule` property. The property is set to `deployment` by default:"
msgstr "您需要在扩展项目的 `runtime` 模块中应用 `io.quarkus.extension` 插件。该插件包含 `extensionDescriptor` 任务，可生成 `META-INF/quarkus-extension.properties` 和 `META-INF/quarkus-extension.yml` 文件。该插件还能在 `deployment` 和 `runtime` 模块中启用 `io.quarkus:quarkus-extension-processor` 注释处理器，以收集和生成其余的 xref:extension-metadata.adoc[Quarkus 扩展元数据] 。部署模块的名称可通过设置 `deploymentModule` 属性在插件中进行配置。该属性默认设置为 `deployment` ："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This plugin is still experimental, it does not validate the extension dependencies as the equivalent Maven plugin does."
msgstr "该插件仍处于试验阶段，不会像 Maven 插件那样验证扩展依赖关系。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Build Step Processors"
msgstr "构建步进处理器"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Work is done at augmentation time by _build steps_ which produce and consume _build items_.  The build steps found in\n"
"the deployment modules that correspond to the extensions in the project build are automatically wired together and executed\n"
"to produce the final build artifact(s)."
msgstr "扩充时的工作由生成和消耗构建 _项_ 的 _构建步骤_ 完成。与项目构建中的扩展相对应的部署模块中的构建步骤会自动连接在一起并执行，以生成最终的构建工件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Build steps"
msgstr "建设步骤"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A _build step_ is a non-static method which is annotated with the `@io.quarkus.deployment.annotations.BuildStep` annotation.\n"
"Each build step may xref:consuming-values[consume] items that are produced by earlier stages, and xref:producing-values[produce] items that can be consumed by later stages. Build steps are normally only run when they produce a build item that is\n"
"ultimately consumed by another step."
msgstr "_构建步骤_ 是一种非静态方法，使用 `@io.quarkus.deployment.annotations.BuildStep` 注释。每个构建步骤都可能 xref:consuming-values[消耗] 早期阶段产生的项目，并 xref:producing-values[产生] 可被后期阶段消耗的项目。通常，只有当构建步骤产生的构建项最终被其他步骤消耗时，才会运行构建步骤。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Build steps are normally placed on plain classes within an extension's deployment module.  The classes are automatically\n"
"instantiated during the augment process and utilize xref:injection[injection]."
msgstr "构建步骤通常置于扩展部署模块中的普通类上。这些类会在增强过程中自动实例化，并利用 xref:injection[注入] 功能。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Build items"
msgstr "建设项目"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Build items are concrete, final subclasses of the abstract `io.quarkus.builder.item.BuildItem` class.  Each build item represents\n"
"some unit of information that must be passed from one stage to another.  The base `BuildItem` class may not itself be directly\n"
"subclassed; rather, there are abstract subclasses for each of the kinds of build item subclasses that _may_ be created:\n"
"xref:simple-build-items[simple], xref:multi-build-items[multi], and xref:empty-build-items[empty]."
msgstr "构建项是抽象 `io.quarkus.builder.item.BuildItem` 类的具体、最终子类。每个构建项都代表了必须从一个阶段传递到另一个阶段的某个信息单元。 `BuildItem` 基类本身不能直接被子类化；相反，每种 _可_ 创建的构建项子类都有一个抽象子类： xref:simple-build-items[简单] 、 xref:multi-build-items[多] 和 xref:empty-build-items[空] 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Think of build items as a way for different extensions to communicate with one another.  For example, a build item can:"
msgstr "将构建项视为不同扩展之间相互通信的一种方式。例如，构建项可以"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "expose the fact that a database configuration exists"
msgstr "暴露数据库配置存在的事实"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "consume that database configuration (e.g. a connection pool extension or an ORM extension)"
msgstr "消耗该数据库配置（例如连接池扩展或 ORM 扩展）"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"ask an extension to do work for another extension: e.g. an extension wanting to define a new CDI bean and asking the ArC extension\n"
"to do so"
msgstr "要求一个扩展为另一个扩展完成工作：例如，一个扩展希望定义一个新的 CDI Bean，并要求 ArC 扩展完成这项工作"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This is a very flexible mechanism."
msgstr "这是一个非常灵活的机制。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"`BuildItem` instances should be immutable, as the producer/consumer model does not allow for mutation to be correctly\n"
"ordered. This is not enforced but failure to adhere to this rule can result in race conditions."
msgstr "`BuildItem` 实例应该是不可变的，因为生产者/消费者模型不允许对突变进行正确排序。这一点并未强制执行，但不遵守这一规则可能会导致竞赛条件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Build steps are executed if and only if they produce build items that are (transitively) needed by other build steps. Make sure your build step produces a build item, otherwise you should probably produce either `ValidationErrorBuildItem` for build validations, or `ArtifactResultBuildItem` for generated artifacts."
msgstr "只有当联编步骤产生其他联编步骤需要的联编项时，联编步骤才会被执行。请确保您的联编步骤会产生联编项，否则您可能应该为联编验证生成 `ValidationErrorBuildItem` ，或为生成的工件生成 `ArtifactResultBuildItem` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Simple build items"
msgstr "简单建造项目"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Simple build items are final classes which extend `io.quarkus.builder.item.SimpleBuildItem`.  Simple build items may only\n"
"be produced by one step in a given build; if multiple steps in a build declare that they produce the same simple build item,\n"
"an error is raised.  Any number of build steps may consume a simple build item.  A build step which consumes a simple\n"
"build item will always run _after_ the build step which produced that item."
msgstr "简单联编项是扩展 `io.quarkus.builder.item.SimpleBuildItem` 的最终类。在给定的联编过程中，简单联编项只能由一个步骤生成；如果一个联编过程中的多个步骤声明它们生成了相同的简单联编项，则会出现错误。任何数量的联编步骤都可能消耗一个简单联编项。消耗简单构建项的构建步骤总是在产生该构建项的构建步骤 _之后_ 运行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of a single build item"
msgstr "单一建造项目示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Multi build items"
msgstr "多种构建项目"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Multiple or \"multi\" build items are final classes which extend `io.quarkus.builder.item.MultiBuildItem`.  Any number of\n"
"multi build items of a given class may be produced by any number of steps, but any steps which consume multi build items\n"
"will only run _after_ every step which can produce them has run."
msgstr "多重或 \"多重 \"构建项是扩展 `io.quarkus.builder.item.MultiBuildItem` 的最终类。一个给定类的任意数量的多重构建项可以由任意数量的步骤生成，但任何消耗多重构建项的步骤只有 _在_ 每个能生成它们的步骤运行 _后_ 才会运行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of a multiple build item"
msgstr "多重构建项目示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of multiple build item usage"
msgstr "多个构建项目的使用示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Empty build items"
msgstr "空构建项目"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Empty build items are final (usually empty) classes which extend `io.quarkus.builder.item.EmptyBuildItem`.\n"
"They represent build items that don't actually carry any data, and allow such items to be produced and consumed\n"
"without having to instantiate empty classes.  They cannot themselves be instantiated."
msgstr "空构建项是扩展 `io.quarkus.builder.item.EmptyBuildItem` 的最终（通常为空）类。它们代表实际上不携带任何数据的构建项，并允许在无需实例化空类的情况下生成和消耗此类构建项。它们本身不能被实例化。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"As they cannot be instantiated, they cannot be injected by any means, nor be returned by a build step (or via a `BuildProducer`).\n"
"To produce an empty build item you must annotate the build step with `@Produce(MyEmptyBuildItem.class)` and to consume it by `@Consume(MyEmptyBuildItem.class)`."
msgstr "由于它们不能被实例化，因此不能以任何方式注入，也不能由联编步骤返回（或通过 `BuildProducer` ）。要生成空联编项，必须在联编步骤中注释 `@Produce(MyEmptyBuildItem.class)` ，并通过 `@Consume(MyEmptyBuildItem.class)` 来消耗它。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of an empty build item"
msgstr "空构建项目示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Empty build items can represent \"barriers\" which can impose ordering between steps.  They can also be used in\n"
"the same way that popular build systems use \"pseudo-targets\", which is to say that the build item can represent a\n"
"conceptual goal that does not have a concrete representation."
msgstr "空的构建项可以代表 \"障碍\"，在步骤之间施加排序。空构建项也可以像流行的构建系统使用 \"伪目标 \"那样使用，也就是说，构建项可以代表一个没有具体表述的概念目标。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of usage of an empty build item in a \"pseudo-target\" style"
msgstr "在 \"伪目标 \"样式中使用空构建项的示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of usage of an empty build item in a \"barrier\" style"
msgstr "使用 \"障碍 \"风格的空构建项目示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Validation Error build items"
msgstr "验证错误构建项目"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "They represent build items with validation errors that make the build fail. These build items are consumed during the initialization of the CDI container."
msgstr "它们代表带有会导致构建失败的验证错误的构建项。这些构建项会在 CDI 容器初始化过程中消耗掉。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of usage of an validation error build item in a \"pseudo-target\" style"
msgstr "在 \"伪目标 \"样式中使用验证错误构建项的示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Artifact Result build items"
msgstr "人工制品结果构建项目"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"They represent build items containing the runnable artifact generated by the build, such as an uberjar or thin jar.\n"
"These build items can also be used to always execute a build step without needing to produce anything."
msgstr "它们代表包含联编生成的可运行工件（如 uberjar 或 thin jar）的联编项。这些构建项也可用于始终执行构建步骤，而无需生成任何东西。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of build step that is always executed in a \"pseudo-target\" style"
msgstr "始终以 \"伪目标 \"方式执行的构建步骤示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Injection"
msgstr "注射"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Classes which contain build steps support the following types of injection:"
msgstr "包含构建步骤的类支持以下类型的注入："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Constructor parameter injection"
msgstr "构造函数参数注入"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Field injection"
msgstr "现场喷射"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Method parameter injection (for build step methods only)"
msgstr "方法参数注入（仅适用于构建步骤方法）"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Build step classes are instantiated and injected for each build step invocation, and are discarded afterwards.  State\n"
"should only be communicated between build steps by way of build items, even if the steps are on the same class."
msgstr "每次调用构建步骤时，构建步骤类都会被实例化和注入，之后就会被丢弃。即使是同一类中的步骤，也只能通过构建项在构建步骤之间传递状态。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Final fields are not considered for injection, but can be populated by way of constructor parameter injection\n"
"if desired.  Static fields are never considered for injection."
msgstr "最终字段不考虑注入，但如果需要，可以通过构造函数参数注入的方式填充。静态字段从不考虑注入。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The types of values that can be injected include:"
msgstr "可注入的值类型包括"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "xref:build-items[Build items] produced by previous build steps"
msgstr "先前构建步骤产生的 xref:build-items[构建项目]"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "xref:producing-values[Build producers] to produce items for subsequent build steps"
msgstr "xref:producing-values[建造生产者] 为后续建造步骤生产物品"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "xref:configuration[Configuration Mapping] types"
msgstr "xref:configuration[配置映射] 类型"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Template objects for xref:bytecode-recording[bytecode recording]"
msgstr "用于 xref:bytecode-recording[记录字节码] 的模板对象"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Objects which are injected into a build step method or its class _must not_ be used outside that method's\n"
"execution."
msgstr "注入到构建步骤方法或其类中的对象 _不得_ 在该方法执行之外使用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Injection is resolved at compile time via an annotation processor,\n"
"and the resulting code does not have permission to inject private fields or invoke private methods."
msgstr "注入是在编译时通过注解处理器解决的，由此产生的代码不允许注入私有字段或调用私有方法。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Producing values"
msgstr "创造价值"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A build step may produce values for subsequent steps in several possible ways:"
msgstr "一个构建步骤可以通过几种可能的方式为后续步骤生成数值："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "By returning a xref:simple-build-items[simple build item] or xref:multi-build-items[multi build item] instance"
msgstr "通过返回 xref:simple-build-items[简单构建项目] 或 xref:multi-build-items[多重构建项目] 实例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "By returning a `List` of a multi build item class"
msgstr "通过返回一个多构建物品类别的 `List` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "By injecting a `BuildProducer` of a simple or multi build item class"
msgstr "通过注入简单或多重构建项目类的 `BuildProducer` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"By annotating the method with `@io.quarkus.deployment.annotations.Produce`, giving the class name of an\n"
"xref:empty-build-items[empty build item]"
msgstr "通过使用 `@io.quarkus.deployment.annotations.Produce` 对方法进行注解，给出一个 xref:empty-build-items[空构建项] 的类名"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If a simple build item is declared on a build step, it _must_ be produced during that build step, otherwise an error\n"
"will result.  Build producers, which are injected into steps, _must not_ be used outside that step."
msgstr "如果在构建步骤中声明了简单构建项，则 _必须_ 在该构建步骤中生成该构建项，否则将导致错误。注入到步骤中的联编生产器 _不得_ 在该步骤之外使用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Note that a `@BuildStep` method will only be called if it produces something that another consumer or the final output\n"
"requires. If there is no consumer for a particular item then it will not be produced. What is required will depend on\n"
"the final target that is being produced.  For example, when running in developer mode the final output will not ask\n"
"for GraalVM-specific build items such as `ReflectiveClassBuildItem`, so methods that only produce these\n"
"items will not be invoked."
msgstr "请注意， `@BuildStep` 方法只有在产生另一个消费者或最终输出所需的内容时才会被调用。如果某个项目没有消费者，那么它就不会被生产出来。所需的内容取决于正在生成的最终目标。例如，在开发者模式下运行时，最终输出将不会要求 GraalVM 特定的构建项（如 `ReflectiveClassBuildItem` ），因此不会调用只生成这些项的方法。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Consuming values"
msgstr "消费价值观"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A build step may consume values from previous steps in the following ways:"
msgstr "构建步骤可以通过以下方式消耗先前步骤的值："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "By injecting a xref:simple-build-items[simple build item]"
msgstr "通过注入一个 xref:simple-build-items[简单的构建项目]"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "By injecting an `Optional` of a simple build item class"
msgstr "通过注入一个简单构建项目类的 `Optional` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "By injecting a `List` of a xref:multi-build-items[multi build item] class"
msgstr "通过注入 xref:multi-build-items[一个多构建项目] 类的 `List` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"By annotating the method with `@io.quarkus.deployment.annotations.Consume`, giving the class name of an\n"
"xref:empty-build-items[empty build item]"
msgstr "通过使用 `@io.quarkus.deployment.annotations.Consume` 对方法进行注解，给出一个 xref:empty-build-items[空构建项] 的类名"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Normally it is an error for a step which is included to consume a simple build item that is not produced by any other\n"
"step.  In this way, it is guaranteed that all the declared values will be present and non-`null` when a step is run."
msgstr "通常情况下，如果一个步骤包含了一个简单的构建项，而该构建项又不是由其他步骤生成的，那么这个步骤就会出错。通过这种方式，可以保证在运行一个步骤时，所有已声明的值都会存在，并且不会被 `null` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Sometimes a value isn't necessary for the build to complete, but might inform some behavior of the build step if it is\n"
"present.  In this case, the value can be optionally injected."
msgstr "有时，某个值并不是完成构建所必需的，但如果该值存在，则可能为构建步骤的某些行为提供信息。在这种情况下，可以选择注入该值。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Multi build values are always considered _optional_.  If not present, an empty list will be injected."
msgstr "多重构建值始终被视为 _可选值_ 。如果不存在，将注入一个空列表。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Weak value production"
msgstr "价值生产薄弱"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Normally a build step is included whenever it produces any build item which is in turn consumed by any other build step.  In this way,\n"
"only the steps necessary to produce the final artifact(s) are included, and steps which pertain to extensions which are\n"
"not installed or which only produce build items which are not relevant for the given artifact type are excluded."
msgstr "通常情况下，只要某个构建步骤产生的构建项被其他构建步骤消耗，该步骤就会被包括在内。In this way, only the steps necessary to produce the final artifact(s) are included, and steps which pertain to extensions which are not installed or which only produce build items which are not relevant for the given artifact type are excluded."

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"For cases where this is not desired behavior, the `@io.quarkus.deployment.annotations.Weak` annotation may be used.  This\n"
"annotation indicates that the build step should not automatically be included solely on the basis of producing the annotated value."
msgstr "如果不希望出现这种情况，可使用 `@io.quarkus.deployment.annotations.Weak` 注释。该注释表明，构建步骤不应仅因产生注释值而自动包含。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of producing a build item weakly"
msgstr "弱化制造项目的示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This method (not provided in this example) would generate the class using the ASM API."
msgstr "该方法（本例中未提供）将使用 ASM API 生成类。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Certain types of build items are generally always consumed, such as generated classes or resources.\n"
"An extension might produce a build item along with a generated class to facilitate the usage\n"
"of that build item.  Such a build step would use the `@Weak` annotation on the generated class build item, while normally\n"
"producing the other build item.  If the other build item is ultimately consumed by something, then the step would run\n"
"and the class would be generated.  If nothing consumes the other build item, the step would not be included in the build\n"
"process."
msgstr "某些类型的构建项通常总是被消耗的，例如生成的类或资源。扩展可能会在生成类的同时生成一个构建项，以方便使用该构建项。这样的构建步骤会在生成类构建项上使用 `@Weak` 注释，同时正常生成另一个构建项。如果其他联编项最终被某些东西消耗，那么该步骤就会运行并生成类。如果没有任何东西消耗另一个构建项，那么构建过程中就不会包含该步骤。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"In the example above, `GeneratedClassBuildItem` would only be produced if `ExecutorClassBuildItem` is consumed by\n"
"some other build step."
msgstr "在上面的例子中，只有当 `ExecutorClassBuildItem` 被其他构建步骤消耗时，才会生成 `GeneratedClassBuildItem` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Note that when using xref:bytecode-recording[bytecode recording], the implicitly generated class can be declared to be weak by\n"
"using the `optional` attribute of the `@io.quarkus.deployment.annotations.Record` annotation."
msgstr "请注意，在使用 xref:bytecode-recording[字节码记录] 时，可以通过 `@io.quarkus.deployment.annotations.Record` 注解的 `optional` 属性来声明隐式生成的类是弱类。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of using a bytecode recorder where the generated class is weakly produced"
msgstr "使用字节码记录器生成弱类的示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Note the `optional` attribute."
msgstr "请注意 `optional` 属性。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This example is using recorder proxies; see the section on xref:bytecode-recording[bytecode recording] for more information."
msgstr "本示例使用记录器代理；更多信息请参阅 xref:bytecode-recording[字节码记录] 部分。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Application Archives"
msgstr "应用档案"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The `@BuildStep` annotation can also register marker files that determine which archives on the class path are considered\n"
"to be 'Application Archives', and will therefore get indexed. This is done via the `applicationArchiveMarkers`. For\n"
"example the ArC extension registers `META-INF/beans.xml`, which means that all archives on the class path with a `beans.xml`\n"
"file will be indexed."
msgstr "`@BuildStep` 注释还可以注册标记文件，以确定类路径上的哪些归档文件被视为 \"应用程序归档文件\"，并因此被编入索引。这是通过 `applicationArchiveMarkers` 实现的。例如，ArC 扩展注册了 `META-INF/beans.xml` ，这意味着类路径上所有带有 `beans.xml` 文件的归档文件都将被索引。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Using Thread's Context Class Loader"
msgstr "使用线程的上下文类加载器"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The build step will be run with a TCCL that can load user classes from the deployment in a transformer-safe way.\n"
"This class loader only lasts for the life of the augmentation, and is discarded afterwards.\n"
"The classes will be loaded again in a different class loader at runtime.\n"
"This means that loading a class during augmentation does not stop it from being transformed when running in the development/test mode."
msgstr "构建步骤将使用 TCCL 运行，该 TCCL 可以安全地从部署中加载用户类。该类加载器只在扩增过程中有效，之后就会被丢弃。类将在运行时由不同的类加载器再次加载。这意味着，在增强过程中加载类并不会阻止类在开发/测试模式下运行时被转换。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Adding external JARs to the indexer with IndexDependencyBuildItem"
msgstr "使用 IndexDependencyBuildItem 向索引器添加外部 JAR"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The index of scanned classes will not automatically include your external class dependencies.\n"
"To add dependencies, create a `@BuildStep` that produces `IndexDependencyBuildItem` objects, for a `groupId` and `artifactId`."
msgstr "扫描类的索引不会自动包含外部类的依赖关系。要添加依赖关系，请为 `groupId` 和 `artifactId` 创建一个能生成 `IndexDependencyBuildItem` 对象的 `@BuildStep` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "It is important to specify all the required artifacts to be added to the indexer. No artifacts are implicitly added transitively."
msgstr "必须指定要添加到索引器的所有必要工件。不会隐式地临时添加任何工件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The `Amazon Alexa` extension adds dependent libraries from the Alexa SDK that are used in Jackson JSON transformations, in order for the reflective classes to identified and included at `BUILD_TIME`."
msgstr "The `Amazon Alexa` extension adds dependent libraries from the Alexa SDK that are used in Jackson JSON transformations, in order for the reflective classes to identified and included at `BUILD_TIME` ."

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "With the artifacts added to the `Jandex` indexer, you can now search the index to identify classes implementing an interface, subclasses of a specific class, or classes with a target annotation."
msgstr "将人工制品添加到 `Jandex` 索引器后，您现在可以搜索索引，以识别实现接口的类、特定类的子类或带有目标注解的类。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"For example, the `Jackson` extension uses code like below to search for annotations used in JSON deserialization,\n"
"and add them to the reflective hierarchy for `BUILD_TIME` analysis."
msgstr "例如， `Jackson` 扩展使用如下代码搜索 JSON 反序列化中使用的注解，并将其添加到反射层次结构中，以便 `BUILD_TIME` 分析。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Visualizing build step dependencies"
msgstr "可视化构建步骤依赖关系"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"It can occasionally be useful to see a visual representation of the interactions between the various build steps. For such cases, adding `-Dquarkus.builder.graph-output=build.dot` when building an application\n"
"will result in the creation of the `build.dot` file in the project's root directory. See link:https://graphviz.org/resources/[this] for a list of software that can open the file and show the actual visual representation."
msgstr "有时，查看各构建步骤之间交互的可视化表示会很有用。在这种情况下，如果在构建应用程序时添加 `-Dquarkus.builder.graph-output=build.dot` ，就会在项目根目录下创建 `build.dot` 文件。有关可以打开该文件并显示实际可视化表示的软件列表，请参见 link:https://graphviz.org/resources/[此处] 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Configuration"
msgstr "配置"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Configuration in Quarkus is based on https://smallrye.io/smallrye-config/Main/[SmallRye Config]. All features provided\n"
"by https://smallrye.io/smallrye-config/Main/[SmallRye Config] are also available in Quarkus."
msgstr "Quarkus 中的配置基于 link:https://smallrye.io/smallrye-config/Main/[SmallRye Config] 。 link:https://smallrye.io/smallrye-config/Main/[SmallRye Config] 提供的所有功能在 Quarkus 中同样可用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Extensions must use https://smallrye.io/smallrye-config/Main/config/mappings/[SmallRye Config @ConfigMapping] to map\n"
"the configuration required by the Extension. This will allow Quarkus to automatically expose an instance of the mapping\n"
"to each configuration phase and generate the configuration documentation."
msgstr "扩展必须使用 link:https://smallrye.io/smallrye-config/Main/config/mappings/[SmallRye Config @ConfigMapping] 来映射扩展所需的配置。这样，Quarkus 就能自动向每个配置阶段公开映射实例，并生成配置文档。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Config Phases"
msgstr "配置阶段"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Configuration mappings are strictly bound by configuration phase, and attempting to access a configuration mapping from\n"
"outside its corresponding phase will result in an error. They dictate when its contained keys are read from the\n"
"configuration, and when they are available to applications. The phases defined by\n"
"`io.quarkus.runtime.annotations.ConfigPhase` are as follows:"
msgstr "配置映射受配置阶段的严格限制，试图从相应阶段之外访问配置映射将导致错误。它们决定了何时从配置中读取所包含的键，以及何时可向应用程序提供这些键。 `io.quarkus.runtime.annotations.ConfigPhase` 定义的阶段如下："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Phase name"
msgstr "阶段名称"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Read & avail. at build time"
msgstr "读取并在构建时使用"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Avail. at run time"
msgstr "运行时可用"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Read during static init"
msgstr "在静态启动过程中读取"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Re-read during startup (native executable)"
msgstr "启动时重新读取（本地可执行文件）"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Notes"
msgstr "说明"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "BUILD_TIME"
msgstr "构建时间"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "✓"
msgstr "✓"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "✗"
msgstr "✗"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Appropriate for things which affect build."
msgstr "适用于影响建设的事物。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "BUILD_AND_RUN_TIME_FIXED"
msgstr "固定构建和运行时间"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Appropriate for things which affect build and must be visible for run time code.  Not read from config at run time."
msgstr "适用于影响构建且必须在运行时可见的代码。运行时不从配置中读取。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "BOOTSTRAP"
msgstr "靴带"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Used when runtime configuration needs to be obtained from an external system (like `Consul`), but details of that system need to be configurable (for example Consul's URL). The high level way this works is by using the standard Quarkus config sources (such as properties files, system properties, etc.) and producing `ConfigSourceProvider` objects which are subsequently taken into account by Quarkus when creating the final runtime `Config` object."
msgstr "当需要从外部系统（如 `Consul` ）获取运行时配置，但该系统的细节（如 Consul 的 URL）需要可配置时使用。其高级工作方式是使用标准的 Quarkus 配置源（如属性文件、系统属性等），并生成 `ConfigSourceProvider` 对象，随后 Quarkus 在创建最终运行时 `Config` 对象时将其考虑在内。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "RUN_TIME"
msgstr "运行时间"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Not available at build, read at start in all modes."
msgstr "构建时不可用，在所有模式下启动时读取。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "For all cases other than the `BUILD_TIME` case, the configuration mapping interface and all the configuration groups and types contained therein must be located in, or reachable from, the extension's run time artifact. Configuration mappings of phase `BUILD_TIME` may be located in or reachable from either of the extension's run time or deployment artifacts."
msgstr "对于 `BUILD_TIME` 情况以外的所有情况，配置映射接口及其中包含的所有配置组和类型必须位于扩展的运行时构件中，或可从扩展的运行时构件中到达。 `BUILD_TIME` 阶段的配置映射可位于扩展的运行时构件或部署构件中，或可从扩展的运行时构件中到达。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "_Bootstrap_ configuration steps are executed during runtime-init *before* any of other runtime steps. This means that code executed as part of this step cannot access anything that gets initialized in runtime init steps (runtime synthetic CDI beans being one such example)."
msgstr "_引导_ 配置步骤在运行时初始化过程中执行， *然后再* 执行其他运行时步骤。这意味着作为该步骤一部分执行的代码不能访问在运行时初始化步骤中初始化的任何内容（运行时合成 CDI Bean 就是一个例子）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Configuration Example"
msgstr "配置示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A configuration property name can be split into segments. For example, a property name like\n"
"`quarkus.log.file.enable` can be split into the following segments:"
msgstr "配置属性名可以分割成若干段。例如，像 `quarkus.log.file.enable` 这样的属性名可以分割成以下几个部分："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus` - a namespace claimed by Quarkus which is a prefix for `@ConfigMapping` interfaces,"
msgstr "`quarkus` - 的命名空间，它是 接口的前缀、 `@ConfigMapping` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`log` - a name segment which corresponds to the prefix set in the interface annotated with `@ConfigMapping`,"
msgstr "`log` - 一个名称段，该名称段与注释为 的接口中设置的前缀相对应、 `@ConfigMapping`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`file` - a name segment which corresponds to the `file` field in this class,"
msgstr "`file` - 与该类中 字段相对应的名称段、 `file` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`enable` - a name segment which corresponds to `enable` field in `FileConfig`."
msgstr "`enable` - 名称段，该名称段与 中的 字段相对应。 `FileConfig` `enable` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The `@ConfigMapping` annotation indicates that the interface is a configuration mapping, in this case one which\n"
"corresponds to a `quarkus.log` segment."
msgstr "`@ConfigMapping` 注释表示该接口是一个配置映射，在本例中是一个与 `quarkus.log` 段相对应的接口。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The `@ConfigRoot` annotation indicated to which Config phase, the configuration applies to."
msgstr "`@ConfigRoot` 注释表示该配置适用于哪个配置阶段。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Here the `LoggingProcessor` injects a `LogConfiguration` instance automatically by detecting the `@ConfigRoot`\n"
"annotation."
msgstr "在这里， `LoggingProcessor` 通过检测 `@ConfigRoot` 注释自动注入 `LogConfiguration` 实例。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A corresponding `application.properties` for the above example could be:"
msgstr "与上述例子相对应的 `application.properties` 可以是"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Since `format` is not defined in these properties, the default value from `@WithDefault` will be used instead."
msgstr "由于 `format` 未在这些属性中定义，因此将使用 `@WithDefault` 中的默认值。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A configuration mapping name can contain an extra suffix segment for the case where there are configuration\n"
"mappings for multiple xref:config-phases[Config Phases]. Classes which correspond to the `BUILD_TIME` and `BUILD_AND_RUN_TIME_FIXED`\n"
"may end with `BuildTimeConfig` or `BuildTimeConfiguration`, classes which correspond to the `RUN_TIME` phase\n"
"may end with `RuntimeConfig`, `RunTimeConfig`, `RuntimeConfiguration` or `RunTimeConfiguration` while classes which\n"
"correspond to the `BOOTSTRAP` configuration may end with `BootstrapConfig` or `BootstrapConfiguration`."
msgstr "配置映射名称可以包含一个额外的后缀段，用于多个配置 xref:config-phases[阶段] 的配置映射。与 `BUILD_TIME` 和 `BUILD_AND_RUN_TIME_FIXED` 对应的类可以以 `BuildTimeConfig` 或 `BuildTimeConfiguration` 结尾，与 `RUN_TIME` 阶段对应的类可以以 `RuntimeConfig` 、 `RunTimeConfig` 、 `RuntimeConfiguration` 或 `RunTimeConfiguration` 结尾，而与 `BOOTSTRAP` 配置对应的类可以以 `BootstrapConfig` 或 `BootstrapConfiguration` 结尾。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Configuration Reference Documentation"
msgstr "配置参考文档"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The configuration is an important part of each extension and therefore needs to be properly documented. Each\n"
"configuration property should have a proper Javadoc comment."
msgstr "配置是每个扩展的重要组成部分，因此需要妥善记录。每个配置属性都应有适当的 Javadoc 注释。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"While it is handy to have the documentation available when coding, the configuration documentation must also be\n"
"available in the extension guides. The Quarkus build automatically generates the configuration documentation based on\n"
"the Javadoc comments, but it needs to be explicitly included in each guide."
msgstr "虽然在编码时提供文档很方便，但在扩展指南中也必须提供配置文档。Quarkus 会根据 Javadoc 注释自动生成配置文档，但需要明确地将其包含在每个指南中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Writing the documentation"
msgstr "编写文件"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Each configuration property, requires a Javadoc explaining its purpose."
msgstr "每个配置属性都需要 Javadoc 来解释其用途。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The first sentence should be meaningful and self-contained as it is included in the summary table."
msgstr "第一句话应该是有意义的，自成一体，因为它包含在摘要表中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"While standard Javadoc comments are perfectly fine for simple documentation (recommended even), AsciiDoc is more\n"
"suitable for tips, source code extracts, lists and more:"
msgstr "标准的 Javadoc 注释完全可以用于简单的文档（甚至推荐使用），而 AsciiDoc 则更适合用于提示、源代码摘录、列表等："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"To use AsciiDoc, the Javadoc comment must be annotated with `@asciidoclet` tag. This tag serves two purposes: it is\n"
"used as a marker for Quarkus generation tool, but it is also used by the `javadoc` process for the Javadoc generation."
msgstr "要使用 AsciiDoc，Javadoc 注释必须使用 `@asciidoclet` 标记。该标签有两个用途：它被用作 Quarkus 生成工具的标记，同时也被 `javadoc` 程序用于生成 Javadoc。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A more detailed example:"
msgstr "一个更详细的例子："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"For indentation to be respected in the Javadoc comment (list items spread on multiple lines or indented\n"
"source code), the automatic Eclipse formatter must be disabled (the formatter is automatically included in the build),\n"
"with the markers `// @formatter:off`/`// @formatter:on`. These require separate comments and a mandatory space after the\n"
"`//` marker."
msgstr "要在 Javadoc 注释中遵守缩进规则（列表项分布在多行或缩进源代码中），必须禁用 Eclipse 自动格式化器（格式化器已自动包含在构建中），标记为 `// @formatter:off` / `// @formatter:on` 。这些都需要单独的注释，并且 `//` 标记后必须有一个空格。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Open blocks (`--`) are not supported in the AsciiDoc documentation. All the other types of blocks\n"
"(source, admonitions...) are supported."
msgstr "AsciiDoc 文档不支持开放式块 ( `--` )。支持所有其他类型的区块（源代码、告诫......）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"By default, the documentation generator will use the hyphenated field name as the key of a `java.util.Map`. Use the\n"
"`io.quarkus.runtime.annotations.ConfigDocMapKey` annotation to override the behaviour."
msgstr "默认情况下，文档生成器将使用连字符字段名作为 `java.util.Map` 的键值。使用 `io.quarkus.runtime.annotations.ConfigDocMapKey` 注解可覆盖该行为。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This will generate a configuration map key named `quarkus.some.\"cache-name\"` instead of `quarkus.some.\"namespace\"`."
msgstr "这将生成一个名为 `quarkus.some.\"cache-name\"` 的配置映射键，而不是 `quarkus.some.\"namespace\"` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "It is possible to write a textual explanation for the documentation default value, this is useful when it is generated: `@ConfigDocDefault(\"explain how this is generated\")`."
msgstr "可以为文档默认值编写文字说明，这在生成文档时非常有用： `@ConfigDocDefault(\"explain how this is generated\")` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`@ConfigDocEnumValue` gives a way to explicitly customize the string displayed in the documentation when listing accepted values for an enum."
msgstr "`@ConfigDocEnumValue` 提供了一种方法，可以在列出枚举的可接受值时显式自定义文档中显示的字符串。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Writing section documentation"
msgstr "编写章节文件"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "To generate a configuration section of a given group, use the `@ConfigDocSection` annotation:"
msgstr "要生成给定组的配置部分，请使用 `@ConfigDocSection` 注释："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"This will add a section documentation for the `configGroup` config item in the generated documentation. The section\n"
"title and introduction will be derived from the javadoc of the configuration item. The first sentence from the javadoc\n"
"is considered as the section title and the remaining sentences used as section introduction."
msgstr "这将在生成的文档中为 `configGroup` 配置项添加一个章节文档。章节的标题和简介将来自配置项的 javadoc。javadoc 中的第一句话被视为章节标题，其余句子用作章节介绍。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Generating the documentation"
msgstr "生成文件"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "To generate the documentation:"
msgstr "生成文件："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Execute `./mvnw -DquicklyDocs`"
msgstr "执行 `./mvnw -DquicklyDocs`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Can be executed globally or in a specific extension directory (e.g. `extensions/mailer`)."
msgstr "可在全局或特定扩展目录（如 `extensions/mailer` ）中执行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The documentation is generated in the global `target/asciidoc/generated/config/` located at the root of the project."
msgstr "文档在位于项目根目录的全局 `target/asciidoc/generated/config/` 中生成。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Including the documentation in the extension guide"
msgstr "将文件纳入扩展指南"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "To include the generated configuration reference documentation in a guide, use:"
msgstr "要在指南中包含生成的配置参考文档，请使用"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "To include only a specific config group:"
msgstr "仅包含特定配置组："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"For example, the `io.quarkus.vertx.http.runtime.FormAuthConfig` configuration group will be generated in a file named\n"
"`quarkus-vertx-http-config-group-form-auth-config.adoc`."
msgstr "例如， `io.quarkus.vertx.http.runtime.FormAuthConfig` 配置组将在名为 `quarkus-vertx-http-config-group-form-auth-config.adoc` 的文件中生成。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A few recommendations:"
msgstr "几点建议"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`opts=optional` is mandatory to not fail the build if only part of the configuration documentation has been generated."
msgstr "`opts=optional` 是强制性的，这样在只生成了部分配置文件的情况下就不会导致构建失败。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The documentation is generated with a title level of 2 (i.e. `==`). It may need an adjustment with `leveloffset=+N`."
msgstr "文件生成时的标题级别为 2（即 `==` ）。可能需要通过 `leveloffset=+N` 进行调整。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The whole configuration documentation should not be included in the middle of the guide."
msgstr "整个配置文档不应放在指南中间。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If the guide includes an `application.properties` example, a tip must be included just below the code snippet:"
msgstr "如果指南中包含 `application.properties` 示例，则必须在代码片段下方附上提示："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "And at the end of the guide, the extensive configuration documentation:"
msgstr "在指南的最后，还有大量的配置文档："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "All documentation should be generated and validated before being committed."
msgstr "所有文件都应在提交前生成和验证。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Conditional Step Inclusion"
msgstr "有条件地纳入步骤"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"It is possible to only include a given `@BuildStep` under certain conditions.  The `@BuildStep` annotation\n"
"has two optional parameters: `onlyIf` and `onlyIfNot`.  These parameters can be set to one or more classes\n"
"which implement `BooleanSupplier`.  The build step will only be included when the method returns\n"
"`true` (for `onlyIf`) or `false` (for `onlyIfNot`)."
msgstr "在某些条件下，可以只包含给定的 `@BuildStep` 。 `@BuildStep` 注解有两个可选参数： `onlyIf` 和 `onlyIfNot` 。这些参数可设置为实现 `BooleanSupplier` 的一个或多个类。只有当该方法返回 `true` （适用于 `onlyIf` ）或 `false` （适用于 `onlyIfNot` ）时，才会包含构建步骤。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The condition class can inject xref:configuration[configuration mappings] as long as they belong to\n"
"a build-time phase.  Run time configuration is not available for condition classes."
msgstr "只要属于构建时阶段，条件类就可以注入 xref:configuration[配置映射] 。运行时配置不适用于条件类。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The condition class may also inject a value of type `io.quarkus.runtime.LaunchMode`.\n"
"Constructor parameter and field injection is supported."
msgstr "条件类也可以注入 `io.quarkus.runtime.LaunchMode` 类型的值。支持构造函数参数和字段注入。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An example of a conditional build step"
msgstr "条件构建步骤示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If you need to make your build step conditional on the presence or absence of another extension, you can\n"
"use xref:capabilities[Capabilities] for that."
msgstr "如果需要将是否存在其他扩展作为构建步骤的条件，可以使用 \" xref:capabilities[能力] \"来实现。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You can also apply a set of conditions to all build steps in a given class with `@BuildSteps`:"
msgstr "您还可以通过 `@BuildSteps` 将一组条件应用于给定类中的所有构建步骤："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Class-wide condition for build step with @BuildSteps"
msgstr "使用 @BuildSteps 为构建步骤设置全类条件"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This condition will apply to all methods defined in `MyDevModeProcessor`"
msgstr "该条件将适用于 `MyDevModeProcessor`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The main build step will only be executed in dev mode."
msgstr "主构建步骤只会在开发模式下执行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The other build step will only be executed in dev mode."
msgstr "其他构建步骤只能在开发模式下执行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Bytecode Recording"
msgstr "字节码记录"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"One of the main outputs of the build process is recorded bytecode. This bytecode actually sets up the runtime environment. For example, in order to start Undertow, the resulting application will have some bytecode that directly registers all\n"
"Servlet instances and then starts Undertow."
msgstr "编译过程的主要输出之一是记录字节码。这些字节码实际上设置了运行时环境。例如，为了启动 Undertow，生成的应用程序将包含一些字节码，直接注册所有 Servlet 实例，然后启动 Undertow。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"As writing bytecode directly is complex, this is instead done via bytecode recorders. At deployment time,\n"
"invocations are made on recorder objects that contain the actual runtime logic, but instead of these invocations\n"
"proceeding as normal they are intercepted and recorded (hence the name). This recording is then used to generate bytecode\n"
"that performs the same sequence of invocations at runtime. This is essentially a form of deferred execution where invocations\n"
"made at deployment time get deferred until runtime."
msgstr "由于直接编写字节码非常复杂，因此需要通过字节码记录器来完成。在部署时，对包含实际运行时逻辑的记录器对象进行调用，但这些调用不会正常进行，而是被拦截并记录下来（因此得名）。然后，这种记录会被用来生成字节码，在运行时执行相同的调用序列。这本质上是一种延迟执行，即在部署时进行的调用会延迟到运行时。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Let's look at the classic 'Hello World' type example. To do this the Quarkus way we would create a recorder as follows:"
msgstr "让我们来看看经典的 \"Hello World \"类型示例。要按照 Quarkus 的方法来做，我们需要创建一个记录器，如下所示："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "And then create a build step that uses this recorder:"
msgstr "然后创建一个使用该记录器的构建步骤："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"When this build step is run nothing is printed to the console. This is because the `HelloRecorder` that is injected is\n"
"actually a proxy that records all invocations. Instead, if we run the resulting Quarkus program we will see 'Hello World'\n"
"printed to the console."
msgstr "运行此构建步骤时，控制台不会打印任何内容。这是因为注入的 `HelloRecorder` 实际上是一个记录所有调用的代理。相反，如果我们运行生成的 Quarkus 程序，就会看到 \"Hello World \"打印到控制台。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Methods on a recorder can return a value, which must be proxiable (if you want to return a non-proxiable item wrap it\n"
"in `io.quarkus.runtime.RuntimeValue`). These proxies may not be invoked directly, however they can be passed\n"
"into other recorder methods. This can be any recorder method, including from other `@BuildStep` methods, so a common pattern\n"
"is to produce `BuildItem` instances that wrap the results of these recorder invocations."
msgstr "记录器上的方法可以返回一个值，该值必须是可代理的（如果要返回一个不可代理的项目，请用 `io.quarkus.runtime.RuntimeValue` 封装）。这些代理不能直接调用，但可以传递给其他记录器方法。这可以是任何记录器方法，包括来自其他 `@BuildStep` 方法的记录器方法，因此常见的模式是生成 `BuildItem` 实例来封装这些记录器调用的结果。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"For instance, in order to make arbitrary changes to a Servlet deployment Undertow has a `ServletExtensionBuildItem`,\n"
"which is a `MultiBuildItem` that wraps a `ServletExtension` instance. I can return a `ServletExtension` from a recorder\n"
"in another module, and Undertow will consume it and pass it into the recorder method that starts Undertow."
msgstr "For instance, in order to make arbitrary changes to a Servlet deployment Undertow has a `ServletExtensionBuildItem` , which is a `MultiBuildItem` that wraps a `ServletExtension` instance.我可以从另一个模块中的记录器返回 `ServletExtension` ，Undertow 将使用它并将其传递到启动 Undertow 的记录器方法中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"At runtime the bytecode will be invoked in the order it is generated. This means that build step dependencies implicitly\n"
"control the order that generated bytecode is run. In the example above we know that the bytecode that produces a\n"
"`ServletExtensionBuildItem` will be run before the bytecode that consumes it."
msgstr "运行时，字节码将按照生成的顺序被调用。This means that build step dependencies implicitly control the order that generated bytecode is run.在上面的示例中，我们知道生成 `ServletExtensionBuildItem` 的字节码将在消耗它的字节码之前运行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The following objects can be passed to recorders:"
msgstr "以下对象可以传递给记录器："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Primitives"
msgstr "原型"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "String"
msgstr "字符串"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Class<?> objects"
msgstr "类<?>对象"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Objects returned from a previous recorder invocation"
msgstr "上一次调用记录器返回的对象"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Objects with a no-arg constructor and getter/setters for all properties (or public fields)"
msgstr "为所有属性（或公共字段）提供无参数构造函数和getter/setters的对象"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Objects with a constructor annotated with `@RecordableConstructor` with parameter names that match field names"
msgstr "构造函数注释为 `@RecordableConstructor` 且参数名与字段名匹配的对象"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Any arbitrary object via the `io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)` mechanism"
msgstr "可通过 `io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)` 机制访问任意对象"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Arrays, Lists and Maps of the above"
msgstr "上述内容的数组、列表和地图"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "In cases where some fields of an object to be recorded should be ignored (i.e. the value that being at build time should not be reflected at runtime), the `@IgnoreProperty` can be placed on the field."
msgstr "如果要记录的对象的某些字段应被忽略（即构建时的值不应在运行时反映）， `@IgnoreProperty` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If the class cannot depend on Quarkus, then Quarkus can use any custom annotation, as long as the extension implements the `io.quarkus.deployment.recording.RecordingAnnotationsProvider` SPI."
msgstr "如果类不能依赖于 Quarkus，那么只要扩展实现了 `io.quarkus.deployment.recording.RecordingAnnotationsProvider` SPI，Quarkus 就可以使用任何自定义注解。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This same SPI can also be used to provide a custom annotation that will substitute for `@RecordableConstructor`."
msgstr "同样的 SPI 也可用于提供自定义注释，以替代 `@RecordableConstructor` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Injecting Configuration into Recorders"
msgstr "将配置注入记录仪"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Configuration objects with phase `RUNTIME` or `BUILD_AND_RUNTIME_FIXED` can be injected into recorders via constructor\n"
"injection. Just create a constructor that takes the configuration objects the recorder needs. If the recorder has multiple\n"
"constructors you can annotate the one you want Quarkus to use with `@Inject`. If the recorder wants to inject runtime config\n"
"but is also used at static init time then it needs to inject a `RuntimeValue<ConfigObject>`, this value will only be set\n"
"when the runtime methods are being invoked."
msgstr "带有相位 `RUNTIME` 或 `BUILD_AND_RUNTIME_FIXED` 的配置对象可通过构造函数注入的方式注入记录器。只需创建一个构造函数，接收记录仪所需的配置对象即可。如果记录器有多个构造函数，你可以用 `@Inject` 来注解你希望 Quarkus 使用的那个。如果记录器想要注入运行时配置，但也在静态初始化时使用，那么它就需要注入一个 `RuntimeValue<ConfigObject>` ，这个值只有在运行时方法被调用时才会被设置。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "RecorderContext"
msgstr "录音机上下文"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"`io.quarkus.deployment.recording.RecorderContext` provides some convenience methods to enhance bytecode recording,\n"
"this includes the ability to register creation functions for classes without no-arg constructors, to register an object\n"
"substitution (basically a transformer from a non-serializable object to a serializable one and vice versa), and to create\n"
"a class proxy. This interface can be directly injected as a method parameter into any `@Record` method."
msgstr "`io.quarkus.deployment.recording.RecorderContext` 提供了一些方便的方法来增强字节码记录功能，其中包括为没有无参数构造函数的类注册创建函数、注册对象替换（基本上是从不可序列化对象到可序列化对象的转换器，反之亦然）以及创建类代理。该接口可作为方法参数直接注入任何 方法。 `@Record` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Calling `classProxy` with a given fully-qualified class name will create a `Class` instance that can be passed into a recorder\n"
"method, and at runtime will be substituted with the class whose name was passed in to `classProxy()`.\n"
"However, this method should not be needed in most use cases because directly loading deployment/application classes at processing time in build steps is safe.\n"
"Therefore, this method is deprecated.\n"
"Nonetheless, there are some use cases where this method comes in handy, such as referring to classes that were generated in previous build steps using `GeneratedClassBuildItem`."
msgstr "使用给定的全称类名调用 `classProxy` 将创建一个 `Class` 实例，该实例可传入记录器方法，并在运行时用传入 `classProxy()` 的类名替换。不过，在大多数使用情况下都不需要此方法，因为在构建步骤的处理过程中直接加载部署/应用类是安全的。因此，该方法已被弃用。不过，在某些使用情况下，这种方法还是很有用的，例如使用 `GeneratedClassBuildItem` 引用在以前的构建步骤中生成的类。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Runtime Classpath check"
msgstr "运行时路径检查"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Extensions often need a way to determine whether a given class is part of the application's runtime classpath.\n"
"The proper way for an extension to perform this check is to use `io.quarkus.bootstrap.classloading.QuarkusClassLoader.isClassPresentAtRuntime`."
msgstr "扩展通常需要一种方法来确定给定类是否属于应用程序运行时类路径的一部分。扩展执行这种检查的正确方法是使用 `io.quarkus.bootstrap.classloading.QuarkusClassLoader.isClassPresentAtRuntime` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Printing step execution time"
msgstr "打印步骤执行时间"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"At times, it can be useful to know how the exact time each startup task (which is the result of each bytecode recording) takes when the application is run.\n"
"The simplest way to determine this information is to launch the Quarkus application with the `-Dquarkus.debug.print-startup-times=true` system property.\n"
"The output will look something like:"
msgstr "有时，了解应用程序运行时每个启动任务（即每个字节码记录的结果）所需的确切时间会很有用。确定这一信息的最简单方法是使用 `-Dquarkus.debug.print-startup-times=true` 系统属性启动 Quarkus 应用程序。输出结果如下"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Contexts and Dependency Injection"
msgstr "上下文和依赖注入"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extension Points"
msgstr "扩展点"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"As a CDI based runtime, Quarkus extensions often make CDI beans available as part of the extension behavior.\n"
"However, Quarkus DI solution does not support CDI Portable Extensions.\n"
"Instead, Quarkus extensions can make use of various xref:cdi-reference.adoc[Build Time Extension Points]."
msgstr "作为基于 CDI 的运行时，Quarkus 扩展通常将 CDI Bean 作为扩展行为的一部分。但是，Quarkus DI 解决方案不支持 CDI 可移植扩展。相反，Quarkus 扩展可以使用各种 xref:cdi-reference.adoc[构建时间扩展点] 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Quarkus Dev UI"
msgstr "夸克开发用户界面"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You can make your extension support the xref:dev-ui-v2.adoc[Quarkus Dev UI] for a greater developer experience."
msgstr "你可以让你的扩展支持 xref:dev-ui-v2.adoc[Quarkus Dev UI] ，以获得更好的开发体验。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extension-defined endpoints"
msgstr "扩展定义的端点"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Your extension can add additional, non-application endpoints to be served alongside endpoints\n"
"for Health, Metrics, OpenAPI, Swagger UI, etc."
msgstr "您的扩展可以添加额外的非应用程序端点，与健康、指标、OpenAPI、Swagger UI 等端点一起提供服务。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Use a `NonApplicationRootPathBuildItem` to define an endpoint:"
msgstr "使用 `NonApplicationRootPathBuildItem` 定义端点："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Note that the path above does not start with a '/', indicating it is a relative path. The above\n"
"endpoint will be served relative to the configured non-application endpoint root. The non-application\n"
"endpoint root is `/q` by default, which means the resulting endpoint will be found at `/q/custom-endpoint`."
msgstr "请注意，上面的路径不是以\"/\"开头，这表明它是一个相对路径。上述端点将相对于配置的非应用端点根目录提供服务。默认情况下，非应用端点根目录是 `/q` ，这意味着生成的端点将在 `/q/custom-endpoint` 找到。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Absolute paths are handled differently. If the above called `route(\"/custom-endpoint\")`, the resulting\n"
"endpoint will be found at `/custom-endpoint`."
msgstr "绝对路径的处理方式不同。如果上面调用的是 `route(\"/custom-endpoint\")` ，那么结果端点将在 `/custom-endpoint` 找到。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If an extension needs nested non-application endpoints:"
msgstr "如果扩展需要嵌套的非应用端点："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Given a default non-application endpoint root of `/q`, this will create an endpoint at `/q/custom-endpoint/deep`."
msgstr "如果默认的非应用程序端点根目录为 `/q` ，则会在 `/q/custom-endpoint/deep` 上创建一个端点。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Absolute paths also have an impact on nested endpoints. If the above called `nestedRoute(\"custom-endpoint\", \"/deep\")`,\n"
"the resulting endpoint will be found at `/deep`."
msgstr "绝对路径对嵌套端点也有影响。如果上面调用了 `nestedRoute(\"custom-endpoint\", \"/deep\")` ，那么结果端点将在 `/deep` 找到。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Refer to the xref:all-config.adoc#quarkus-vertx-http_quarkus.http.non-application-root-path[Quarkus Vertx HTTP configuration reference]\n"
"for details on how the non-application root path is configured."
msgstr "有关如何配置非应用程序根路径的详细信息，请参阅 xref:all-config.adoc#quarkus-vertx-http_quarkus.http.non-application-root-path[Quarkus Vertx HTTP 配置参考] 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extension Health Check"
msgstr "扩展健康检查"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Health checks are provided via the `quarkus-smallrye-health` extension. It provides both liveness and readiness checks capabilities."
msgstr "健康检查通过 `quarkus-smallrye-health` 扩展提供。它同时提供有效性和就绪性检查功能。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "When writing an extension, it's beneficial to provide health checks for the extension, that can be automatically included without the developer needing to write their own."
msgstr "在编写扩展时，为扩展提供自动包含的健康检查是有益的，开发人员无需编写自己的健康检查。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "In order to provide a health check, you should do the following:"
msgstr "为了提供健康检查，您应该做到以下几点："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Import the `quarkus-smallrye-health` extension as an **optional** dependency in your runtime module so it will not impact the size of the application if\n"
"health check is not included."
msgstr "在运行模块中将 `quarkus-smallrye-health` 扩展作为 *可选* 依赖项导入，这样，如果不包含健康检查，也不会影响应用程序的大小。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Create your health check following the xref:smallrye-health.adoc[SmallRye Health] guide. We advise providing only\n"
"readiness check for an extension (liveness check is designed to express the fact that an application is up and needs to be lightweight)."
msgstr "按照 xref:smallrye-health.adoc[SmallRye Health] 指南创建健康检查。我们建议只为扩展提供就绪性检查（有效性检查旨在表达应用程序已启动并需要轻量级的事实）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Import the `quarkus-smallrye-health-spi` library in your deployment module."
msgstr "在部署模块中导入 `quarkus-smallrye-health-spi` 库。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Add a build step in your deployment module that produces a `HealthBuildItem`."
msgstr "在部署模块中添加一个构建步骤，生成 `HealthBuildItem` .NET 文件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Add a way to disable the extension health check via a config item `quarkus.<extension>.health.enabled` that should be enabled by default."
msgstr "通过配置项 `quarkus.<extension>.health.enabled` 添加禁用扩展健康检查的方法，默认情况下应启用扩展健康检查。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Following is an example from the Agroal extension that provides a `DataSourceHealthCheck` to validate the readiness of a datasource."
msgstr "以下是 Agroal 扩展中的一个示例，它提供了一个 `DataSourceHealthCheck` 来验证数据源的就绪性。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extension Metrics"
msgstr "扩展指标"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The `quarkus-micrometer` extension and the `quarkus-smallrye-metrics` extension provide support for collecting metrics.\n"
"As a compatibility note, the `quarkus-micrometer` extension adapts the MP Metrics API to Micrometer library primitives, so the `quarkus-micrometer` extension can be enabled without breaking code that relies on the MP Metrics API.\n"
"Note that the metrics emitted by Micrometer are different, see the `quarkus-micrometer` extension documentation for more information."
msgstr "`quarkus-micrometer` 扩展和 `quarkus-smallrye-metrics` 扩展支持收集度量指标。作为兼容性说明， `quarkus-micrometer` 扩展将 MP Metrics API 调整为 Micrometer 库基元，因此启用 `quarkus-micrometer` 扩展不会破坏依赖 MP Metrics API 的代码。请注意，Micrometer 输出的度量标准是不同的，更多信息请参阅 `quarkus-micrometer` 扩展文档。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The compatibility layer for MP Metrics APIs will move to a different extension in the future."
msgstr "未来，MP Metrics API 的兼容层将转移到不同的扩展中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "There are two broad patterns that extensions can use to interact with an optional metrics extension to add their own metrics:"
msgstr "扩展可以使用两种广泛的模式与可选度量扩展进行交互，以添加自己的度量："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Consumer pattern: An extension declares a `MetricsFactoryConsumerBuildItem` and uses that to provide a bytecode recorder to the metrics extension. When the metrics extension has initialized, it will iterate over registered consumers to initialize them with a `MetricsFactory`. This factory can be used to declare API-agnostic metrics, which can be a good fit for extensions that provide an instrumentable object for gathering statistics (e.g. Hibernate's `Statistics` class)."
msgstr "消费者模式：扩展会声明一个 `MetricsFactoryConsumerBuildItem` ，并利用它为度量扩展提供字节码记录器。当度量扩展完成初始化后，它会遍历已注册的消费者，用 `MetricsFactory` 对其进行初始化。该工厂可用于声明与 API 无关的度量，非常适合那些提供用于收集统计数据的可检测对象的扩展（如 Hibernate 的 `Statistics` 类）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Binder pattern: An extension can opt to use completely different gathering implementations depending on the metrics system. An `Optional<MetricsCapabilityBuildItem> metricsCapability` build step parameter can be used to declare or otherwise initialize API-specific metrics based on the active metrics extension (e.g. \"smallrye-metrics\" or \"micrometer\"). This pattern can be combined with the consumer pattern by using `MetricsFactory::metricsSystemSupported()` to test the active metrics extension within the recorder."
msgstr "粘合剂模式：扩展可根据度量系统选择使用完全不同的收集实现。 `Optional<MetricsCapabilityBuildItem> metricsCapability` 构建步骤参数可用于根据活动度量扩展（如 \"smallrye-metrics \"或 \"micrometer\"）声明或初始化特定于 API 的度量。该模式可与消费者模式相结合，使用 `MetricsFactory::metricsSystemSupported()` 在记录器中测试活动度量扩展。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Remember that support for metrics is optional. Extensions can use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter in their build step to test for the presence of an enabled metrics extension. Consider using additional configuration to control behavior of metrics. Datasource metrics can be expensive, for example, so additional configuration flags are used enable metrics collection on individual datasources."
msgstr "请记住，对度量标准的支持是可选的。扩展可以在构建步骤中使用 `Optional<MetricsCapabilityBuildItem> metricsCapability` 参数来测试是否存在已启用的度量扩展。考虑使用附加配置来控制度量的行为。例如，数据源度量可能会很昂贵，因此可以使用附加配置标志在单个数据源上启用度量收集。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "When adding metrics for your extension, you may find yourself in one of the following situations:"
msgstr "在为分机添加度量指标时，您可能会遇到以下情况之一："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An underlying library used by the extension is using a specific Metrics API directly (either MP Metrics, Micrometer, or some other)."
msgstr "扩展使用的底层库直接使用特定的度量 API（MP Metrics、Micrometer 或其他）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An underlying library uses its own mechanism for collecting metrics and makes them available at runtime using its own API, e.g. Hibernate's `Statistics` class, or Vert.x `MetricsOptions`."
msgstr "底层库使用自己的机制收集指标，并在运行时使用自己的应用程序接口提供这些指标，例如 Hibernate 的 `Statistics` 类或 Vert.x `MetricsOptions` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An underlying library does not provide metrics (or there is no library at all) and you want to add instrumentation."
msgstr "底层库不提供度量指标（或根本就没有库），您想添加仪器。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Case 1: The library uses a metrics library directly"
msgstr "情况 1：图书馆直接使用度量库"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If the library directly uses a metrics API, there are two options:"
msgstr "如果程序库直接使用度量 API，则有两种选择："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter to test which metrics API is supported (e.g. \"smallrye-metrics\" or \"micrometer\") in your build step, and use that to selectively declare or initialize API-specific beans or build items."
msgstr "在构建步骤中，使用 `Optional<MetricsCapabilityBuildItem> metricsCapability` 参数测试支持哪种度量 API（例如 \"smallrye-metrics \"或 \"micrometer\"），并以此有选择地声明或初始化特定于 API 的 Bean 或构建项。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Create a separate build step that consumes a `MetricsFactory`, and use the `MetricsFactory::metricsSystemSupported()` method within the bytecode recorder to initialize required resources if the desired metrics API is supported (e.g. \"smallrye-metrics\" or \"micrometer\")."
msgstr "创建一个消耗 `MetricsFactory` 的单独构建步骤，如果支持所需的度量 API（如 \"smallrye-metrics \"或 \"micrometer\"），则使用字节码记录器中的 `MetricsFactory::metricsSystemSupported()` 方法初始化所需的资源。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extensions may need to provide a fallback if there is no active metrics extension or the extension doesn't support the API required by the library."
msgstr "如果没有活动的度量扩展，或者扩展不支持库所需的 API，扩展可能需要提供后备功能。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Case 2: The library provides its own metric API"
msgstr "案例 2：图书馆提供自己的度量 API"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "There are two examples of a library providing its own metrics API:"
msgstr "有两个库提供自己的度量 API 的例子："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The extension defines an instrumentable object as Agroal does with `io.agroal.api.AgroalDataSourceMetrics`, or"
msgstr "扩展定义了一个可工具化的对象，如 Agroal 的 `io.agroal.api.AgroalDataSourceMetrics` ，或"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The extension provides its own abstraction of metrics, as Jaeger does with `io.jaegertracing.spi.MetricsFactory`."
msgstr "扩展提供了自己的度量抽象，就像 Jaeger 的 `io.jaegertracing.spi.MetricsFactory` 一样。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Observing instrumentable objects"
msgstr "观测可利用仪器的物体"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Let's take the instrumentable object (`io.agroal.api.AgroalDataSourceMetrics`) case first. In this case, you can do the following:"
msgstr "我们先来看看可检测对象 ( `io.agroal.api.AgroalDataSourceMetrics` ) 的情况。在这种情况下，您可以执行以下操作："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` consumer. For example, the following creates a `MetricsFactoryConsumerBuildItem` if and only if metrics are enabled both for Agroal generally, and for a datasource specifically:"
msgstr "定义 `BuildStep` ，生成 `MetricsFactoryConsumerBuildItem` ，使用 `RUNTIME_INIT` 或 `STATIC_INIT` 记录器定义 `MetricsFactory` 消费者。例如，如果且仅当 Agroal 和数据源都启用了度量指标时，以下内容才会创建 `MetricsFactoryConsumerBuildItem` ："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The associated recorder should use the provided `MetricsFactory` to register metrics. For Agroal, this means using the `MetricFactory` API to observe `io.agroal.api.AgroalDataSourceMetrics` methods. For example:"
msgstr "相关记录器应使用所提供的 `MetricsFactory` 注册度量指标。对于 Agroal 来说，这意味着使用 `MetricFactory` API 来观察 `io.agroal.api.AgroalDataSourceMetrics` 方法。例如"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The `MetricsFactory` provides a fluid builder for registration of metrics, with the final step constructing gauges or counters based on a `Supplier` or `ToDoubleFunction`. Timers can either wrap `Callable`, `Runnable`, or `Supplier` implementations, or can use a `TimeRecorder` to accumulate chunks of time. The underlying metrics extension will create appropriate artifacts to observe or measure the defined functions."
msgstr "`MetricsFactory` 为度量注册提供了一个流畅的构建器，最后一步是根据 `Supplier` 或 `ToDoubleFunction` 构建仪表或计数器。定时器可以封装 `Callable` 、 `Runnable` 或 `Supplier` 实现，也可以使用 `TimeRecorder` 来累积时间块。底层度量扩展将创建适当的工件来观察或测量所定义的功能。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Using a Metrics API-specific implementation"
msgstr "使用针对度量 API 的实现"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Using metrics-API specific implementations may be preferred in some cases. Jaeger, for example, defines its own metrics interface, `io.jaegertracing.spi.MetricsFactory`, that it uses to define counters and gauges. A direct mapping from that interface to the metrics system will be the most efficient. In this case, it is important to isolate these specialized implementations and to avoid eager classloading to ensure the metrics API remains an optional, compile-time dependency."
msgstr "在某些情况下，使用度量--API 特定的实现可能更可取。例如，Jaeger 定义了自己的度量接口 `io.jaegertracing.spi.MetricsFactory` ，用于定义计数器和仪表。从该接口直接映射到度量系统是最有效的。在这种情况下，重要的是要隔离这些专门的实现，避免急于加载类，以确保度量 API 始终是可选的编译时依赖。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`Optional<MetricsCapabilityBuildItem> metricsCapability` can be used in the build step to selectively control initialization of beans or the production of other build items. The Jaeger extension, for example, can use the following to control initialization of specialized Metrics API adapters:"
msgstr "`Optional<MetricsCapabilityBuildItem> metricsCapability` 可用于构建步骤，有选择性地控制 Bean 的初始化或其他构建项的生成。例如，Jaeger 扩展可以使用以下方法来控制专用 Metrics API 适配器的初始化："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "+"
msgstr "+"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A recorder consuming a `MetricsFactory` can use `MetricsFactory::metricsSystemSupported()` can be used to control initialization of metrics objects during bytecode recording in a similar way."
msgstr "消耗 `MetricsFactory` 的记录器可以使用 `MetricsFactory::metricsSystemSupported()` ，在字节码记录过程中以类似方式控制度量对象的初始化。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Case 3: It is necessary to collect metrics within the extension code"
msgstr "案例 3：有必要在扩展代码中收集度量指标"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "To define your own metrics from scratch, you have two basic options: Use the generic `MetricFactory` builders, or follow the binder pattern, and create instrumentation specific to the enabled metrics extension."
msgstr "要从头开始定义自己的指标，有两个基本选项：使用通用的 `MetricFactory` 构建器，或遵循粘合剂模式，创建专用于启用的度量扩展的仪器。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "To use the extension-agnostic `MetricFactory` API, your processor can define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` consumer."
msgstr "要使用与扩展无关的 `MetricFactory` API，处理器可以定义一个 `BuildStep` ，生成 `MetricsFactoryConsumerBuildItem` ，使用 `RUNTIME_INIT` 或 `STATIC_INIT` 记录器定义 `MetricsFactory` 消费者。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"+\n"
"- The associated recorder should use the provided `MetricsFactory` to register metrics, for example"
msgstr "+ - 相关记录器应使用所提供的 `MetricsFactory` 注册度量指标，例如"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Remember that metrics extensions are optional. Keep metrics-related initialization isolated from other setup for your extension, and structure your code to avoid eager imports of metrics APIs. Gathering metrics can also be expensive. Consider using additional extension-specific configuration to control behavior of metrics if the presence/absence of metrics support isn't sufficient."
msgstr "请记住，度量扩展是可选的。将与度量相关的初始化与扩展的其他设置隔离开来，并调整代码结构，避免急于导入度量 API。收集度量指标的成本也很高。如果指标支持的存在/不存在不足以控制指标行为，请考虑使用额外的特定于扩展的配置来控制指标行为。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Customizing JSON handling from an extension"
msgstr "从扩展自定义 JSON 处理"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extensions often need to register serializers and/or deserializers for types the extension provides."
msgstr "扩展通常需要为扩展提供的类型注册序列化器和/或反序列化器。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"For this, both Jackson and JSON-B extensions provide a way to register serializer/deserializer from within an\n"
"extension deployment module."
msgstr "为此，Jackson 和 JSON-B 扩展都提供了在扩展部署模块中注册序列化器/反序列化器的方法。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Keep in mind that not everybody will need JSON, so you need to make it optional."
msgstr "请记住，并不是每个人都需要 JSON，因此需要将其作为可选项。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If an extension intends to provide JSON related customization,\n"
"it is strongly advised to provide customization for both Jackson and JSON-B."
msgstr "如果扩展打算提供与 JSON 相关的自定义功能，强烈建议同时为 Jackson 和 JSON-B 提供自定义功能。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Customizing Jackson"
msgstr "定制杰克逊"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "First, add an *optional* dependency to `quarkus-jackson` on your extension's runtime module."
msgstr "首先，在扩展的运行模块上添加一个 *可选的* 依赖关系 `quarkus-jackson` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Then create a serializer or a deserializer (or both) for Jackson, an example of which can be seen in the `mongodb-panache` extension."
msgstr "然后为 Jackson 创建一个序列化器或一个反序列化器（或两者兼而有之），其示例可参见 `mongodb-panache` 扩展。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Add a dependency to `quarkus-jackson-spi` on your extension's deployment module."
msgstr "将 `quarkus-jackson-spi` 添加为扩展部署模块的依赖项。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Add a build step to your processor to register a Jackson module via the `JacksonModuleBuildItem`.\n"
"You need to name your module in a unique way across all Jackson modules."
msgstr "在处理器中添加一个构建步骤，通过 `JacksonModuleBuildItem` 注册一个 Jackson 模块。您需要在所有 Jackson 模块中以唯一的方式命名您的模块。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The Jackson extension will then use the produced build item to register a module within Jackson automatically."
msgstr "然后，Jackson 扩展将使用生成的构建项在 Jackson 中自动注册一个模块。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If you need more customization capabilities than registering a module,\n"
"you can produce a CDI bean that implements `io.quarkus.jackson.ObjectMapperCustomizer` via an `AdditionalBeanBuildItem`.\n"
"More info about customizing Jackson can be found on the JSON guide xref:rest-json.adoc#json[Configuring JSON support]"
msgstr "如果您需要比注册模块更多的自定义功能，可以制作一个 CDI Bean，通过 `AdditionalBeanBuildItem` 实现 `io.quarkus.jackson.ObjectMapperCustomizer` 。有关自定义 Jackson 的更多信息，请参阅 JSON 指南 xref:rest-json.adoc#json[配置 JSON 支持]"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Customizing JSON-B"
msgstr "定制 JSON-B"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "First, add an *optional* dependency to `quarkus-jsonb` on your extension's runtime module."
msgstr "首先，在扩展的运行模块上添加一个 *可选的* 依赖关系 `quarkus-jsonb` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Then create a serializer and/or a deserializer for JSON-B, an example of which can be seen in the `mongodb-panache` extension."
msgstr "然后为 JSON-B 创建一个序列化器和/或反序列化器，其示例可参见 `mongodb-panache` 扩展。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Add a dependency to `quarkus-jsonb-spi` on your extension's deployment module."
msgstr "将 `quarkus-jsonb-spi` 添加为扩展部署模块的依赖项。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Add a build step to your processor to register the serializer via the `JsonbSerializerBuildItem`."
msgstr "在处理器中添加一个构建步骤，通过 `JsonbSerializerBuildItem` 注册序列化器。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The JSON-B extension will then use the produced build item to register your serializer/deserializer automatically."
msgstr "然后，JSON-B 扩展将使用生成的构建项自动注册您的序列化器/解序列化器。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If you need more customization capabilities than registering a serializer or a deserializer,\n"
"you can produce a CDI bean that implements `io.quarkus.jsonb.JsonbConfigCustomizer` via an `AdditionalBeanBuildItem`.\n"
"More info about customizing JSON-B can be found on the JSON guide xref:rest-json.adoc#configuring-json-support[Configuring JSON support]"
msgstr "如果您需要比注册序列化器或反序列化器更多的自定义功能，您可以制作一个 CDI Bean，通过 `AdditionalBeanBuildItem` 实现 `io.quarkus.jsonb.JsonbConfigCustomizer` 。有关自定义 JSON-B 的更多信息，请参阅 JSON 指南 xref:rest-json.adoc#configuring-json-support[配置 JSON 支持]"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Integrating with Development Mode"
msgstr "与开发模式整合"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "There are various APIS that you can use to integrate with development mode, and to get information about the current state."
msgstr "您可以使用各种 APIS 与开发模式集成，并获取有关当前状态的信息。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Handling restarts"
msgstr "处理重新启动"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"When Quarkus is starting the `io.quarkus.deployment.builditem.LiveReloadBuildItem` is guaranteed to be present that gives\n"
"information about this start, in particular:"
msgstr "当 Quarkus 启动时， `io.quarkus.deployment.builditem.LiveReloadBuildItem` 保证会出现，并特别提供有关此次启动的信息："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Is this a clean start or a live reload"
msgstr "这是清零启动还是实弹重装？"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If this is a live reload which changed files / classes triggered the reload"
msgstr "如果这是一次实时重载，其中更改的文件/类触发了重载"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"It also provides a global context map you can use to store information between restarts, without needing to resort to\n"
"static fields."
msgstr "它还提供了一个全局上下文映射，可用于在重启之间存储信息，而无需使用静态字段。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Triggering Live Reload"
msgstr "触发实时重载"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Live reload is generally triggered by an HTTP request, however not all applications are HTTP applications and some extensions\n"
"may want to trigger live reload based on other events. To do this you need to implement `io.quarkus.dev.spi.HotReplacementSetup`\n"
"in your runtime module, and add a `META-INF/services/io.quarkus.dev.spi.HotReplacementSetup` that lists your implementation."
msgstr "实时重载一般由 HTTP 请求触发，但并非所有应用程序都是 HTTP 应用程序，有些扩展可能希望根据其他事件触发实时重载。为此，你需要在运行时模块中实现 `io.quarkus.dev.spi.HotReplacementSetup` ，并添加一个 `META-INF/services/io.quarkus.dev.spi.HotReplacementSetup` ，列出你的实现。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"On startup the `setupHotDeployment` method will be called, and you can use the provided `io.quarkus.dev.spi.HotReplacementContext`\n"
"to initiate a scan for changed files."
msgstr "启动时， `setupHotDeployment` 方法将被调用，你可以使用提供的 `io.quarkus.dev.spi.HotReplacementContext` 启动对已更改文件的扫描。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Testing Extensions"
msgstr "测试扩展"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Testing of Quarkus extensions should be done with the `io.quarkus.test.QuarkusUnitTest` JUnit 5 extension.\n"
"This extension allows for Arquillian-style tests that test specific functionalities.\n"
"It is not intended for testing user applications, as this should be done via `io.quarkus.test.junit.QuarkusTest`.\n"
"The main difference is that `QuarkusTest` simply boots the application once at the start of the run, while `QuarkusUnitTest` deploys a custom\n"
"Quarkus application for each test class."
msgstr "Quarkus 扩展测试应使用 `io.quarkus.test.QuarkusUnitTest` JUnit 5 扩展。该扩展允许进行 Arquillian 风格的测试，以测试特定功能。它不用于测试用户应用程序，因为这应通过 `io.quarkus.test.junit.QuarkusTest` 进行。主要区别在于， `QuarkusTest` 只需在运行开始时启动一次应用程序，而 `QuarkusUnitTest` 则会为每个测试类部署一个自定义的 Quarkus 应用程序。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"These tests should be placed in the deployment module, if additional Quarkus modules are required for testing\n"
"their deployment modules should also be added as test scoped dependencies."
msgstr "这些测试应放在部署模块中，如果测试需要其他 Quarkus 模块，也应将其部署模块添加为测试范围依赖项。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Note that `QuarkusUnitTest` is in the `quarkus-junit5-internal` module."
msgstr "注意 `QuarkusUnitTest` 位于 `quarkus-junit5-internal` 模块中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An example test class may look like:"
msgstr "测试类的示例如下"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The `QuarkusUnitTest` extension must be used with a static field. If used with a non-static field, the test application is not started."
msgstr "`QuarkusUnitTest` 扩展名必须与静态字段一起使用。如果与非静态字段一起使用，则不会启动测试程序。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This producer is used to build the application to be tested. It uses Shrinkwrap to create a JavaArchive to test"
msgstr "该生成器用于构建要测试的应用程序。它使用 Shrinkwrap 创建一个 JavaArchive 来测试"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "It is possible to inject beans from our test deployment directly into the test case"
msgstr "可以将测试部署中的 bean 直接注入测试用例中"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This method directly invokes the health check Servlet and verifies the response"
msgstr "该方法直接调用健康检查 Servlet 并验证响应"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This method uses the injected health check bean to verify it is returning the expected result"
msgstr "该方法使用注入的健康检查 bean 来验证它是否返回预期结果"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If you want to test that an extension properly fails at build time, use the `setExpectedException` method:"
msgstr "如果要测试扩展在构建时是否正确失败，请使用 `setExpectedException` 方法："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This tells JUnit that the Quarkus deployment should fail with a specific exception"
msgstr "这会告诉 JUnit，Quarkus 部署失败时会出现特定异常"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Testing hot reload"
msgstr "测试热重装"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"It is also possible to write tests that verify an extension works correctly in development mode and can correctly\n"
"handle updates."
msgstr "还可以编写测试，以验证扩展在开发模式下能否正常运行，以及能否正确处理更新。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"For most extensions this will just work 'out of the box', however it is still a good idea to have a smoke test to\n"
"verify that this functionality is working as expected. To test this we use `QuarkusDevModeTest`:"
msgstr "对于大多数扩展来说，这只是 \"开箱即用\"，但最好还是进行 \"烟雾测试\"，以验证该功能是否按预期运行。为了测试这一点，我们使用 `QuarkusDevModeTest` ："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"This starts the deployment, your test can modify it as part of the test suite. Quarkus will be restarted between\n"
"each test method so every method starts with a clean deployment."
msgstr "这将启动部署，你的测试可以将其作为测试套件的一部分进行修改。Quarkus 将在每个测试方法之间重新启动，因此每个方法都将以干净的部署开始。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"This method allows you to modify the source of a class file. The old source is passed into the function, and the updated\n"
"source is returned."
msgstr "使用该方法可以修改类文件的源代码。旧的源文件会传入函数，更新后的源文件会返回。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"This method adds a new class file to the deployment. The source that is used will be the original source that is part\n"
"of the current project."
msgstr "此方法可在部署中添加一个新的类文件。使用的源文件将是当前项目中的原始源文件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This method modifies a static resource"
msgstr "该方法修改静态资源"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This method adds a new static resource"
msgstr "该方法会添加一个新的静态资源"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Native Executable Support"
msgstr "本地可执行文件支持"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"There Quarkus provides a lot of build items that control aspects of the native executable build. This allows for extensions\n"
"to programmatically perform tasks such as registering classes for reflection or adding static resources to the native\n"
"executable. Some of these build items are listed below:"
msgstr "Quarkus 提供了大量的构建项，用于控制本地可执行文件构建的各个方面。这允许扩展程序以编程方式执行任务，例如为反射注册类或向本地可执行文件添加静态资源。下面列出了其中一些构建项："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Includes static resources into the native executable."
msgstr "将静态资源纳入本地可执行文件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Includes directory's static resources into the native executable."
msgstr "将目录的静态资源纳入本地可执行文件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A class that will be reinitialized at runtime by Substrate. This will result in the static initializer running twice."
msgstr "将在运行时被 Substrate 重新初始化的类。这将导致静态初始化程序运行两次。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A system property that will be set at native executable build time."
msgstr "系统属性，将在本地可执行文件构建时设置。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Includes a resource bundle in the native executable."
msgstr "在本地可执行文件中包含资源包。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Registers a class for reflection in Substrate. Constructors are always registered, while methods and fields are optional."
msgstr "为 Substrate 中的反射注册一个类。构造函数总是要注册的，而方法和字段则是可选的。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A class that will be initialized at runtime rather than build time. This will cause the build to fail if the class is initialized as part of the native executable build process, so care must be taken."
msgstr "将在运行时初始化而不是在编译时初始化的类。如果该类在本地可执行构建过程中被初始化，则会导致构建失败，因此必须小心谨慎。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A convenience feature that allows you to control most of the above features from a single build item."
msgstr "这是一项方便的功能，可让您通过单个构建项控制上述大部分功能。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"
msgstr "`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Indicates that all charsets should be enabled in native image."
msgstr "表示应在本地图像中启用所有字符集。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"
msgstr "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A convenient way to tell Quarkus that the extension requires SSL, and it should be enabled during native image build.\n"
"When using this feature, remember to add your extension to the list of extensions that offer SSL support automatically on the https://github.com/quarkusio/quarkus/blob/main/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide]."
msgstr "这是一种告诉 Quarkus 扩展需要 SSL 并应在本地镜像创建时启用的便捷方法。使用该功能时，请记得将扩展添加到 link:https://github.com/quarkusio/quarkus/blob/main/docs/src/main/asciidoc/native-and-ssl.adoc[本地和 SSL 指南] 中自动提供 SSL 支持的扩展列表中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "IDE support tips"
msgstr "IDE 支持提示"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Writing Quarkus extensions in Eclipse"
msgstr "在 Eclipse 中编写 Quarkus 扩展"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The only particular aspect of writing Quarkus extensions in Eclipse is that APT (Annotation Processing Tool) is required as part of extension builds, which means you need to:"
msgstr "在 Eclipse 中编写 Quarkus 扩展的唯一特殊之处在于，扩展构建需要使用 APT（注释处理工具），这意味着你需要这样做："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Install `m2e-apt` from https://marketplace.eclipse.org/content/m2e-apt"
msgstr "从 https://marketplace.eclipse.org/content/m2e-apt 安装 `m2e-apt` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Define this property in your `pom.xml`: `<m2e.apt.activation>jdt_apt</m2e.apt.activation>`, although if you rely on `io.quarkus:quarkus-build-parent` you will get it for free."
msgstr "在 `pom.xml` : `<m2e.apt.activation>jdt_apt</m2e.apt.activation>` 中定义此属性，不过如果使用 `io.quarkus:quarkus-build-parent` ，则可免费获得此属性。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If you have the `io.quarkus:quarkus-extension-processor` project open at the same time in your IDE (for example, if you have the Quarkus sources checked out and open in your IDE) you will need to close that project. Otherwise, Eclipse will not invoke the APT plugin that it contains."
msgstr "如果在集成开发环境中同时打开了 `io.quarkus:quarkus-extension-processor` 项目（例如，在集成开发环境中签出并打开了 Quarkus 源代码），则需要关闭该项目。否则，Eclipse 将不会调用其中包含的 APT 插件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If you just closed the extension processor project, be sure to do `Maven > Update Project` on the other projects in order for Eclipse to pick up the extension processor from the Maven repository."
msgstr "如果刚刚关闭了扩展处理器项目，请确保在其他项目上执行 `Maven > Update Project` ，以便 Eclipse 从 Maven 资源库中获取扩展处理器。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Troubleshooting / Debugging Tips"
msgstr "故障排除/调试技巧"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Inspecting the Generated/Transformed Classes"
msgstr "检查生成/转换的类"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Quarkus generates a lot of classes during the build phase and in many cases also transforms existing classes.\n"
"It is often extremely useful to see the generated bytecode and transformed classes during the development of an extension."
msgstr "在构建阶段，Quarkus 会生成大量的类，在许多情况下还会转换现有的类。在开发扩展时，查看生成的字节码和转换后的类通常非常有用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If you set the `quarkus.package.vineflower.enabled` property to `true` then Quarkus will download and invoke the https://github.com/Vineflower/vineflower[Vineflower decompiler] and dump the result in the `decompiled` directory of the build tool output (`target/decompiled` for Maven for example)."
msgstr "如果将 `quarkus.package.vineflower.enabled` 属性设置为 `true` ，Quarkus 将下载并调用 link:https://github.com/Vineflower/vineflower[Vineflower 反编译器] ，并将结果转储到构建工具输出的 `decompiled` 目录（例如 Maven 的 `target/decompiled` ）。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "This property only works during a normal production build (i.e. not for dev mode/tests) and when `fast-jar` packaging type is used (the default behavior)."
msgstr "该属性仅在正常生产构建（即不用于开发模式/测试）和使用 `fast-jar` 包装类型（默认行为）时有效。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "There are also three system properties that allow you to dump the generated/transformed classes to the filesystem and inspect them later, for example via a decompiler in your IDE."
msgstr "此外，还有三个系统属性可让您将生成/转换的类转储到文件系统中，并在稍后对其进行检查，例如通过集成开发环境中的反编译器进行检查。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus.debug.generated-classes-dir` - to dump the generated classes, such as bean metadata"
msgstr "`quarkus.debug.generated-classes-dir` - 转储生成的类，如 bean 元数据"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus.debug.transformed-classes-dir` - to dump the transformed classes, e.g. Panache entities"
msgstr "`quarkus.debug.transformed-classes-dir` - 转储转换后的类，例如 Panache 实体"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`quarkus.debug.generated-sources-dir` - to dump the ZIG files; ZIG file is a textual representation of the generated code that is referenced in the stack traces"
msgstr "`quarkus.debug.generated-sources-dir` - 转储 ZIG 文件；ZIG 文件是生成的代码的文本表示，堆栈跟踪中引用了这些代码"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "These properties are especially useful in the development mode or when running the tests where the generated/transformed classes are only held in memory in a class loader."
msgstr "在开发模式下或运行测试时，生成/转换的类只能保存在类加载器的内存中，这些属性尤其有用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "For example, you can specify the `quarkus.debug.generated-classes-dir` system property to have these classes written out to disk for inspection in the development mode:"
msgstr "例如，您可以指定 `quarkus.debug.generated-classes-dir` 系统属性，将这些类写入磁盘，以便在开发模式下进行检查："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The property value could be either an absolute path, such as `/home/foo/dump` on a Linux machine, or a path relative to the user working directory, i.e. `dump` corresponds to the `{user.dir}/target/dump` in the dev mode and `{user.dir}/dump` when running the tests."
msgstr "属性值可以是绝对路径，如 Linux 机器上的 `/home/foo/dump` ，也可以是相对于用户工作目录的路径，如 `dump` 对应开发模式下的 `{user.dir}/target/dump` ，运行测试时对应 `{user.dir}/dump` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You should see a line in the log for each class written to the directory:"
msgstr "你应该能在日志中看到写入目录的每个类的一行："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The property is also honored when running tests:"
msgstr "在运行测试时，该属性也会生效："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Analogously, you can use the `quarkus.debug.transformed-classes-dir` and `quarkus.debug.generated-sources-dir` properties to dump the relevant output."
msgstr "同样，您可以使用 `quarkus.debug.transformed-classes-dir` 和 `quarkus.debug.generated-sources-dir` 属性来转储相关输出。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Multi-module Maven Projects and the Development Mode"
msgstr "多模块 Maven 项目和开发模式"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"It's not uncommon to develop an extension in a multi-module Maven project that also contains an \"example\" module.\n"
"However, if you want to run the example in the development mode then the `-DnoDeps` system property must be used in order to exclude the local project dependencies.\n"
"Otherwise, Quarkus attempts to monitor the extension classes and this may result in weird class loading issues."
msgstr "在一个多模块的 Maven 项目中开发扩展，同时包含一个 \"示例 \"模块，这种情况并不少见。但是，如果你想在开发模式下运行示例，就必须使用 `-DnoDeps` 系统属性来排除本地项目的依赖关系。否则，Quarkus 会尝试监控扩展类，这可能会导致奇怪的类加载问题。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Indexer does not include your external dependency"
msgstr "索引器未包含您的外部依赖项"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Remember to add `IndexDependencyBuildItem` artifacts to your `@BuildStep`."
msgstr "记得将 `IndexDependencyBuildItem` 手工艺品添加到您的 `@BuildStep` 中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Sample Test Extension"
msgstr "样品测试扩展"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"We have an extension that is used to test for regressions in the extension processing. It is located in {quarkus-tree-url}/integration-tests/test-extension/extension directory. In this section we touch on some tasks an extension\n"
"author will typically need to perform using the test-extension code to illustrate how the task could be done."
msgstr "我们有一个扩展，用于测试扩展处理过程中的回归。它位于 {quarkus-tree-url}/integration-tests/test-extension/extension 目录中。在本节中，我们将使用测试扩展代码来说明扩展作者通常需要执行的一些任务。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Features and Capabilities"
msgstr "特点和功能"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Features"
msgstr "特点"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A _feature_ represents a functionality provided by an extension.\n"
"The name of the feature gets displayed in the log during application bootstrap."
msgstr "_功能_ 代表扩展提供的功能。功能名称会在应用程序启动时显示在日志中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example Startup Lines"
msgstr "启动行示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A list of features installed in the runtime image"
msgstr "运行时映像中安装的功能列表"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "A feature can be registered in a xref:build-step-processors[Build Step Processors] method that produces a `FeatureBuildItem`:"
msgstr "可在生成 `FeatureBuildItem` 的 \" xref:build-step-processors[构建步骤处理器] \"方法中注册功能："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "TestProcessor#feature()"
msgstr "测试处理器#feature()"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The name of the feature should only contain lowercase characters, words are separated by dash; e.g. `security-jpa`.\n"
"An extension should provide at most one feature and the name must be unique.\n"
"If multiple extensions register a feature of the same name the build fails."
msgstr "特征名称只能包含小写字母，单词之间用破折号隔开；例如 `security-jpa` 。一个扩展最多只能提供一个功能，且名称必须唯一。如果多个扩展注册了相同名称的功能，则构建失败。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The feature name should also map to a label in the extension's `devtools/common/src/main/filtered/extensions.json` entry so that\n"
"the feature name displayed by the startup line matches a label that one can use to select the extension when creating a project\n"
"using the Quarkus maven plugin as shown in this example taken from the xref:rest-json.adoc[Writing JSON REST Services] guide where the `resteasy-reactive-jackson` feature is referenced:"
msgstr "功能名称还应映射到扩展 `devtools/common/src/main/filtered/extensions.json` 条目中的标签，这样启动行显示的功能名称才能与标签相匹配，以便在使用 Quarkus maven 插件创建项目时选择扩展，如本示例所示，该示例摘自《 xref:rest-json.adoc[编写 JSON REST 服务》（Writing JSON REST Services] ）指南，其中引用了 `resteasy-reactive-jackson` 功能："

#: _versions/3.6/guides/writing-extensions.adoc
msgid "Capabilities"
msgstr "功能"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A _capability_ represents a technical capability that can be queried by other extensions.\n"
"An extension may provide multiple capabilities and multiple extensions can provide the same capability.\n"
"By default, capabilities are not displayed to users.\n"
"Capabilities should be used when checking for the presence of an extension rather than class path based checks."
msgstr "一种 _能力_ 代表一种技术能力，可由其他分机查询。一个分机可以提供多种能力，多个分机也可以提供相同的能力。默认情况下，能力不会显示给用户。在检查扩展是否存在时，应使用能力而不是基于类路径的检查。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Capabilities can be registered in a xref:build-step-processors[Build Step Processors] method that produces a `CapabilityBuildItem`:"
msgstr "功能可在生成 `CapabilityBuildItem` 的 \" xref:build-step-processors[构建步骤处理器] \"方法中注册："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "TestProcessor#capability()"
msgstr "测试处理器#能力()"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Extensions can consume registered capabilities using the `Capabilities` build item:"
msgstr "扩展可以使用 `Capabilities` 构建项来消耗已注册的功能："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "TestProcessor#doSomeCoolStuff()"
msgstr "测试处理器#doSomeCoolStuff()"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Capabilities should follow the naming conventions of Java packages; e.g. `io.quarkus.security.jpa`.\n"
"Capabilities provided by core extensions should be listed in the `io.quarkus.deployment.Capability` enum and their name should always start with the `io.quarkus` prefix."
msgstr "功能应遵循 Java 包的命名约定，如 `io.quarkus.security.jpa` 。核心扩展提供的功能应列在 `io.quarkus.deployment.Capability` 枚举中，其名称应始终以 `io.quarkus` 前缀开头。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Bean Defining Annotations"
msgstr "定义注解的 Bean"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The CDI layer processes CDI beans that are either explicitly registered or that it discovers based on bean defining annotations as defined in https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[2.5.1. Bean defining annotations]. You can expand this set of annotations to include annotations your extension processes using a `BeanDefiningAnnotationBuildItem` as shown in this `TestProcessor#registerBeanDefinningAnnotations` example:"
msgstr "CDI 层处理显式注册的 CDI Bean 或根据 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[2.5.1] 中定义的 Bean 定义注释发现的 CDI Bean link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[。豆定义] 注解。如 `TestProcessor#registerBeanDefinningAnnotations` 示例所示，您可以扩展注解集，使其包括您使用 `BeanDefiningAnnotationBuildItem` 进行扩展处理的注解："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Register a Bean Defining Annotation"
msgstr "注册 Bean 定义注释"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Register the annotation class and CDI default scope using the Jandex `DotName` class."
msgstr "使用 Jandex `DotName` 类注册注解类和 CDI 默认作用域。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`ConfiguredBean` will be processed by the CDI layer the same as a bean annotated with the CDI standard @ApplicationScoped."
msgstr "`ConfiguredBean` 将与使用 CDI 标准 @ApplicationScoped 注释的 Bean 一样被 CDI 层处理。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Parsing Config to Objects"
msgstr "将配置解析为对象"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"One of the main things an extension is likely to do is completely separate the configuration phase of behavior from the runtime phase.\n"
"Frameworks often do parsing/load of configuration on startup that can be done during build time to both reduce the runtime dependencies on frameworks like xml parsers as well as reducing the startup time the parsing incurs."
msgstr "扩展可能要做的主要事情之一就是将行为的配置阶段与运行阶段完全分离。框架通常会在启动时进行配置解析/加载，而这些工作可以在构建时完成，这样既可以减少对 xml 解析器等框架的运行时依赖，也可以减少解析工作所产生的启动时间。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An example of parsing an XML config file using JAXB is shown in the `TestProcessor#parseServiceXmlConfig` method:"
msgstr "使用 JAXB 解析 XML 配置文件的示例显示在 `TestProcessor#parseServiceXmlConfig` 方法中："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Parsing an XML Configuration into Runtime XmlConfig Instance"
msgstr "将 XML 配置解析为运行时 XmlConfig 实例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Look for a config.xml classpath resource"
msgstr "查找 config.xml classpath 资源"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If found, parse using JAXB context for `XmlConfig.class`"
msgstr "如果找到，则使用 JAXB 上下文为 `XmlConfig.class`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If there was no /config.xml resource available in the build environment, then a null `RuntimeServiceBuildItem` would be returned and no subsequent logic based on a `RuntimeServiceBuildItem` being produced would execute."
msgstr "如果构建环境中没有可用的 /config.xml 资源，则将返回空 `RuntimeServiceBuildItem` ，并且不会执行基于 `RuntimeServiceBuildItem` 生成的后续逻辑。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Typically, one is loading a configuration to create some runtime component/service as `parseServiceXmlConfig` is doing. We will come back to the rest of the behavior in `parseServiceXmlConfig` in the following xref:manage-non-cdi-service[Manage Non-CDI Service] section."
msgstr "通常情况下，人们会加载配置以创建某些运行时组件/服务，正如 `parseServiceXmlConfig` 所做的那样。在接下来的 \" xref:manage-non-cdi-service[管理非 CDI 服务] \"部分，我们将再次讨论 `parseServiceXmlConfig` 中的其他行为。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If for some reason you need to parse the config and use it in other build steps in an extension processor, you would need to create an `XmlConfigBuildItem` to pass the parsed XmlConfig instance around."
msgstr "如果出于某种原因需要解析配置并将其用于扩展处理器中的其他构建步骤，则需要创建一个 `XmlConfigBuildItem` 来传递解析后的 XmlConfig 实例。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If you look at the XmlConfig code you will see that it does carry around the JAXB annotations. If you don't want these in the runtime image, you could clone the XmlConfig instance into some POJO object graph and then replace XmlConfig with the POJO class.\n"
"We will do this in xref:replacing-classes-in-native-image[Replacing Classes in the Native Image]."
msgstr "如果您查看 XmlConfig 代码，就会发现它确实带有 JAXB 注释。如果不想在运行时映像中使用这些注解，可以将 XmlConfig 实例克隆到某个 POJO 对象图中，然后用 POJO 类替换 XmlConfig。我们将在 \"在 xref:replacing-classes-in-native-image[本地映像中替换类] \"一文中这样做。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Scanning Deployments Using Jandex"
msgstr "使用 Jandex 扫描部署"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "If your extension defines annotations or interfaces that mark beans needing to be processed, you can locate these beans using the Jandex API, a Java annotation indexer and offline reflection library. The following `TestProcessor#scanForBeans` method shows how to find the beans annotated with our `@TestAnnotation` that also implement the `IConfigConsumer` interface:"
msgstr "如果您的扩展定义了注解或接口来标记需要处理的 Bean，您可以使用 Java 注释索引器和离线反射库 Jandex API 查找这些 Bean。下面的 `TestProcessor#scanForBeans` 方法展示了如何查找使用我们的 `@TestAnnotation` 进行注解且同时实现 `IConfigConsumer` 接口的 Bean："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example Jandex Usage"
msgstr "Jandex 使用示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Depend on a `BeanArchiveIndexBuildItem` to have the build step be run after the deployment has been indexed."
msgstr "依赖 `BeanArchiveIndexBuildItem` ，以便在部署索引后运行构建步骤。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Retrieve the index."
msgstr "检索索引。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Find all beans annotated with `@TestAnnotation`."
msgstr "查找所有带注释的豆子 `@TestAnnotation` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Determine which of these beans also has the `IConfigConsumer` interface."
msgstr "确定其中哪个豆也有 `IConfigConsumer` 接口。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Save the bean class in a `TestBeanBuildItem` for use in a latter RUNTIME_INIT build step that will interact with the bean instances."
msgstr "将 bean 类保存在 `TestBeanBuildItem` 中，以便在后一个 RUNTIME_INIT 构建步骤中使用，该步骤将与 bean 实例交互。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Interacting With Extension Beans"
msgstr "与扩展豆交互"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "You can use the `io.quarkus.arc.runtime.BeanContainer` interface to interact with your extension beans. The following `configureBeans` methods illustrate interacting with the beans scanned for in the previous section:"
msgstr "您可以使用 `io.quarkus.arc.runtime.BeanContainer` 接口与扩展 Bean 交互。以下 `configureBeans` 方法说明了如何与上一节中扫描到的 Bean 进行交互："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Using CDI BeanContainer Interface"
msgstr "使用 CDI BeanContainer 接口"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Consume the `TestBeanBuildItem`s produced from the scanning build step."
msgstr "使用从扫描构建步骤中生成的 `TestBeanBuildItem `。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Consume the `BeanContainerBuildItem` to order this build step to run after the CDI bean container has been created."
msgstr "使用 `BeanContainerBuildItem` 命令此构建步骤在创建 CDI Bean 容器后运行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Call the runtime recorder to record the bean interactions."
msgstr "调用运行时记录器来记录 bean 的交互。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Runtime recorder retrieves the bean using its type."
msgstr "运行时记录器使用 bean 的类型检索 bean。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Runtime recorder invokes the `IConfigConsumer#loadConfig(...)` method passing in the configuration objects with runtime information."
msgstr "运行时记录器会调用 `IConfigConsumer#loadConfig(…​)` 方法，并传递包含运行时信息的配置对象。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Manage Non-CDI Service"
msgstr "管理非 CDI 服务"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A common purpose for an extension is to integrate a non-CDI aware service into the CDI based Quarkus runtime.\n"
"Step 1 of this task is to load any configuration needed in a STATIC_INIT build step as we did in xref:parsing-config-to-objects[Parsing Config to Objects].\n"
"Now we need to create an instance of the service using the configuration.\n"
"Let's return to the `TestProcessor#parseServiceXmlConfig` method to see how this can be done."
msgstr "扩展的一个常见目的是将非 CDI 感知服务集成到基于 CDI 的 Quarkus 运行时中。这项任务的第一步是在 STATIC_INIT 构建步骤中加载任何所需的配置，就像我们在 xref:parsing-config-to-objects[将配置解析为对象（Parsing Config to Objects] ）中所做的那样。现在，我们需要使用配置创建一个服务实例。让我们回到 `TestProcessor#parseServiceXmlConfig` 方法，看看如何做到这一点。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Creating a Non-CDI Service"
msgstr "创建非 CDI 服务"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Call into the runtime recorder to record the creation of the service."
msgstr "调用运行时记录器，记录服务的创建过程。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Using the parsed `XmlConfig` instance, create an instance of `RuntimeXmlConfigService` and wrap it in a `RuntimeValue`. Use a `RuntimeValue` wrapper for non-interface objects that are non-proxiable."
msgstr "使用解析后的 `XmlConfig` 实例，创建 `RuntimeXmlConfigService` 实例，并用 `RuntimeValue` 对其进行封装。对于不可代理的非接口对象，使用 `RuntimeValue` 封装器。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Wrap the return service value in a `RuntimeServiceBuildItem` for use in a RUNTIME_INIT build step that will start the service."
msgstr "将返回的服务值封装在 `RuntimeServiceBuildItem` 中，以便用于启动服务的 RUNTIME_INIT 构建步骤。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Starting a Service"
msgstr "启动服务"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Now that you have recorded the creation of a service during the build phase, you need to record how to start the service at runtime during booting.\n"
"You do this with a RUNTIME_INIT build step as shown in the `TestProcessor#startRuntimeService` method."
msgstr "既然已经记录了在构建阶段创建服务的过程，那么就需要记录如何在启动过程中的运行时启动服务。如 `TestProcessor#startRuntimeService` 方法所示，您可以使用 RUNTIME_INIT 构建步骤来完成这一工作。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Starting/Stopping a Non-CDI Service"
msgstr "启动/停止非 CDI 服务"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "We consume a ShutdownContextBuildItem to register the service shutdown."
msgstr "我们使用 ShutdownContextBuildItem 来注册服务关闭。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "We consume the previously initialized service captured in `RuntimeServiceBuildItem`."
msgstr "我们使用 `RuntimeServiceBuildItem` 中捕获的先前已初始化的服务。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Call the runtime recorder to record the service start invocation."
msgstr "调用运行时记录器记录服务启动调用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Produce a `ServiceStartBuildItem` to indicate the startup of a service. See xref:startup-shutdown-events[Startup and Shutdown Events] for details."
msgstr "生成 `ServiceStartBuildItem` 以指示服务的启动。有关详情，请参阅 xref:startup-shutdown-events[启动和关闭事件] 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Runtime recorder retrieves the service instance reference and calls its `startService` method."
msgstr "运行时记录器会检索服务实例引用，并调用其 `startService` 方法。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Runtime recorder registers an invocation of the service instance `stopService` method with the Quarkus `ShutdownContext`."
msgstr "运行时记录器向 Quarkus `ShutdownContext` 注册服务实例 `stopService` 方法的调用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The code for the `RuntimeXmlConfigService` can be viewed here:\n"
"{quarkus-blob-url}/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"
msgstr "`RuntimeXmlConfigService` 的代码可在此处查看：{quarkus-blob-url}/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]."

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The testcase for validating that the `RuntimeXmlConfigService` has started can be found in the `testRuntimeXmlConfigService` test of `ConfiguredBeanTest` and `NativeImageIT`."
msgstr "验证 `RuntimeXmlConfigService` 是否已启动的测试用例可在 `ConfiguredBeanTest` 和 `NativeImageIT` 的 `testRuntimeXmlConfigService` 测试中找到。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Startup and Shutdown Events"
msgstr "启动和关闭事件"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The Quarkus container supports startup and shutdown lifecycle events to notify components of the container startup\n"
"and shutdown. There are CDI events fired that components can observe are illustrated in this example:"
msgstr "Quarkus 容器支持启动和关闭生命周期事件，以便通知组件容器的启动和关闭。组件可以观察到已触发的 CDI 事件，本示例对此进行了说明："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Observing Container Startup"
msgstr "观察容器启动"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Observe a `StartupEvent` to be notified the runtime has started."
msgstr "观察 `StartupEvent` ，通知运行时间已开始。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Observe a `ShutdownEvent` to be notified when the runtime is going to shut down."
msgstr "观察 `ShutdownEvent` ，以便在运行时关闭时收到通知。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"What is the relevance of startup and shutdown events for extension authors? We have already seen the use of a `ShutdownContext`\n"
"to register a callback to perform shutdown tasks in the xref:starting-service[Starting a Service] section.\n"
"These shutdown tasks would be called\n"
"after a `ShutdownEvent` had been sent."
msgstr "启动和关闭事件与扩展作者有什么关系？在 \" xref:starting-service[启动服务] \"一节中，我们已经看到使用 `ShutdownContext` 注册回调以执行关闭任务。这些关闭任务将在 `ShutdownEvent` 发送后调用。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"A `StartupEvent` is fired after all `io.quarkus.deployment.builditem.ServiceStartBuildItem` producers have been consumed.\n"
"The implication of this is that if an extension has services that application components would expect to have been\n"
"started when they observe a `StartupEvent`, the build steps that invoke the runtime code to start those services needs\n"
"to produce a `ServiceStartBuildItem` to ensure that the runtime code is run before the `StartupEvent` is sent. Recall that\n"
"we saw the production of a `ServiceStartBuildItem` in the previous section, and it is repeated here for clarity:"
msgstr "`StartupEvent` 会在所有 `io.quarkus.deployment.builditem.ServiceStartBuildItem` 生产者都被消耗后触发。这意味着，如果扩展有一些服务，而应用组件在观察到 `StartupEvent` 时希望这些服务已经启动，那么调用运行时代码来启动这些服务的构建步骤就需要产生一个 `ServiceStartBuildItem` ，以确保运行时代码在 `StartupEvent` 发送之前已经运行。回想一下，我们在上一节中看到了 `ServiceStartBuildItem` 的生成过程，为了清楚起见，这里再重复一遍："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Example of Producing a ServiceStartBuildItem"
msgstr "生成 ServiceStartBuildItem 的示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Produce a `ServiceStartBuildItem` to indicate that this is a service starting step that needs to run before the `StartupEvent` is sent."
msgstr "生成 `ServiceStartBuildItem` ，表示这是一个服务启动步骤，需要在发送 `StartupEvent` 之前运行。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Register Resources for Use in Native Image"
msgstr "注册用于本地图像的资源"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Not all configuration or resources can be consumed at build time. If you have classpath resources that the runtime needs to access, you need to inform the build phase that these resources need to be copied into the native image. This is done by producing one or more `NativeImageResourceBuildItem` or `NativeImageResourceBundleBuildItem` in the case of resource bundles. Examples of this are shown in this sample `registerNativeImageResources` build step:"
msgstr "并非所有配置或资源都能在构建时消耗。如果运行时需要访问 classpath 资源，则需要通知构建阶段需要将这些资源复制到本地映像中。这可以通过生成一个或多个 `NativeImageResourceBuildItem` 或 `NativeImageResourceBundleBuildItem` （如果是资源包）来实现。 `registerNativeImageResources` 构建步骤示例中展示了这方面的例子："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Registering Resources and ResourceBundles"
msgstr "注册资源和资源包"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Indicate that the /security/runtime.keys classpath resource should be copied into native image."
msgstr "表示应将 /security/runtime.keys classpath 资源复制到本地映像中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Indicate that the `META-INF/my-descriptor.xml` resource should be copied into native image"
msgstr "表示应将 `META-INF/my-descriptor.xml` 资源复制到本地图像中"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Indicate that the \"jakarta.xml.bind.Messages\" resource bundle should be copied into native image."
msgstr "指出应将 \"jakarta.xml.bind.Messages \"资源包复制到本地镜像中。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Service files"
msgstr "服务文件"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"If you are using `META-INF/services` files you need to register the files as resources so that your native image can find them,\n"
"but you also need to register each listed class for reflection so they can be instantiated or inspected at run-time:"
msgstr "如果使用 `META-INF/services` 文件，则需要将文件注册为资源，以便本地图像可以找到它们，同时还需要将每个列出的类注册为反射，以便在运行时对它们进行实例化或检查："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"`ServiceProviderBuildItem` takes a list of service implementation classes as parameters: if\n"
"you are not reading them from the service file, make sure that they correspond to the service file contents\n"
"because the service file will still be read and used at run-time. This is not a substitute for writing a service\n"
"file."
msgstr "`ServiceProviderBuildItem` 将服务实现类的列表作为参数：如果不是从服务文件中读取这些类，请确保它们与服务文件的内容相对应，因为运行时仍会读取并使用服务文件。这不能代替编写服务文件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"This only registers the implementation classes for instantiation via reflection (you will not be able\n"
"to inspect its fields and methods). If you need to do that, you can do it this way:"
msgstr "这只能通过反射注册实例化的实现类（无法检查其字段和方法）。如果您需要这样做，也可以这样做："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"While this is the easiest way to get your services running natively, it's less efficient than scanning the implementation\n"
"classes at build time and generating code that registers them at static-init time instead of relying on reflection."
msgstr "虽然这是让你的服务原生运行的最简单方法，但它的效率比不上在构建时扫描实现类，并在静态启动时生成注册它们的代码，而不是依赖反射。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"You can achieve that by adapting the previous build step to use a static-init recorder instead of registering\n"
"classes for reflection:"
msgstr "要做到这一点，你可以调整前面的构建步骤，使用静态启动记录器，而不是为反射注册类："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Object Substitution"
msgstr "对象替换"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Objects created during the build phase that are passed into the runtime need to have a default constructor in order for them to be created and configured at startup of the runtime from the build time state. If an object does not have a default constructor you will see an error similar to the following during generation of the augmented artifacts:"
msgstr "在构建阶段创建并传递到运行时的对象需要有一个默认构造函数，以便在运行时从构建时状态启动时创建和配置它们。如果对象没有默认构造函数，在生成增强工件时就会出现类似下面的错误："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "DSAPublicKey Serialization Error"
msgstr "DSAPublicKey 序列化错误"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "There is a `io.quarkus.runtime.ObjectSubstitution` interface that can be implemented to tell Quarkus how to handle such classes. An example implementation for the `DSAPublicKey` is shown here:"
msgstr "有一个 `io.quarkus.runtime.ObjectSubstitution` 接口，可以通过实现该接口来告诉 Quarkus 如何处理这些类。 `DSAPublicKey` 的实现示例如下："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "DSAPublicKeyObjectSubstitution Example"
msgstr "DSAP 公钥对象替换示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The serialize method takes the object without a default constructor and creates a `KeyProxy` that contains the information necessary to recreate the `DSAPublicKey`."
msgstr "序列化方法使用不带默认构造函数的对象，并创建一个 `KeyProxy` ，其中包含重新创建 `DSAPublicKey` 所需的信息。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The deserialize method uses the `KeyProxy` to recreate the `DSAPublicKey` from its encoded form using the key factory."
msgstr "反序列化方法使用 `KeyProxy` ，利用密钥工厂从编码形式重新创建 `DSAPublicKey` 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "An extension registers this substitution by producing an `ObjectSubstitutionBuildItem` as shown in this `TestProcessor#loadDSAPublicKey` fragment:"
msgstr "如 `TestProcessor#loadDSAPublicKey` 片段所示，扩展程序通过生成 `ObjectSubstitutionBuildItem` 来记录这种替换："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Registering an Object Substitution"
msgstr "注册对象替代"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Replacing Classes in the Native Image"
msgstr "替换原生图像中的类"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"The Graal SDK supports substitutions of classes in the native image.\n"
"An example of how one could replace the `XmlConfig/XmlData` classes with versions that have no JAXB annotation dependencies is shown in these example classes:"
msgstr "Graal SDK 支持替换本地映像中的类。这些示例类展示了如何用不依赖 JAXB 注释的版本替换 `XmlConfig/XmlData` 类："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Substitution of XmlConfig/XmlData Classes Example"
msgstr "XmlConfig/XmlData 类的替换示例"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Ecosystem integration"
msgstr "生态系统整合"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"Some extensions may be private, and some may wish to be part of the\n"
"broader Quarkus ecosystem, and available for community re-use.\n"
"Inclusion in the Quarkiverse Hub is a convenient mechanism for handling\n"
"continuous testing and publication.\n"
"The link:https://github.com/quarkiverse/quarkiverse/wiki#getting-an-extension-onboarded[Quarkiverse Hub wiki] has instructions\n"
"for on-boarding your extension."
msgstr "有些扩展可能是私有的，有些可能希望成为更广泛的 Quarkus 生态系统的一部分，供社区重用。加入 Quarkiverse Hub 是处理持续测试和发布的便捷机制。在 link:https://github.com/quarkiverse/quarkiverse/wiki#getting-an-extension-onboarded[Quarkiverse Hub 维基] 中，有关于加入扩展的说明。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Alternatively, continuous testing and publication can be handled manually."
msgstr "此外，还可以手动处理连续测试和发布。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Continuous testing of your extension"
msgstr "对扩展进行持续测试"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid ""
"In order to make it easy for extension authors to test their extensions daily against the latest snapshot of Quarkus, Quarkus has introduced\n"
"the notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/main/README.adoc[README]\n"
"has all the details on how to set up a GitHub Actions job to take advantage of this capability, while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides an overview\n"
"of what the process looks like."
msgstr "为了方便扩展作者每天根据 Quarkus 的最新快照测试自己的扩展，Quarkus 引入了 Ecosystem CI 概念。Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/main/README.adoc[README] 提供了如何设置 GitHub Actions 作业以利用这一功能的所有详细信息，而这段 link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[视频] 则概述了整个过程。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Publish your extension in registry.quarkus.io"
msgstr "在 registry.quarkus.io 中发布您的扩展"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Before publishing your extension to the xref:tooling.adoc[Quarkus tooling], make sure that the following requirements are met:"
msgstr "在将扩展发布到 xref:tooling.adoc[Quarkus 工具] 之前，请确保满足以下要求："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "The xref:extension-metadata.adoc#quarkus-extension-yaml[quarkus-extension.yaml] file (in the extension's `runtime/` module) has the minimum metadata set:"
msgstr "xref:extension-metadata.adoc#quarkus-extension-yaml[quarkus-extension.yaml] 文件（在扩展的 `runtime/` 模块中）已设置了最小元数据："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`name`"
msgstr "`name`"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "`description` (unless you have it already set in the ``runtime/pom.xml``'s `<description>` element, which is the recommended approach)"
msgstr "`description` (除非您已经在 的 元素中进行了设置，建议采用这种方法）。 `runtime/pom.xml` `<description>` "

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Your extension is published in Maven Central"
msgstr "您的扩展已发布在 Maven Central"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Your extension repository is configured to use the xref:ecosystem-ci[Ecosystem CI]."
msgstr "您的扩展库已配置为使用 xref:ecosystem-ci[Ecosystem CI] 。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "Then you must create a pull request adding a `your-extension.yaml` file in the `extensions/` directory in the link:https://github.com/quarkusio/quarkus-extension-catalog[Quarkus Extension Catalog]. The YAML must have the following structure:"
msgstr "然后，你必须创建一个拉取请求，在 link:https://github.com/quarkusio/quarkus-extension-catalog[Quarkus 扩展目录] 的 `extensions/` 目录中添加一个 `your-extension.yaml` 文件。YAML 必须具有以下结构："

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "When your repository contains multiple extensions, you need to create a separate file for each individual extension, not just one file for the entire repository."
msgstr "当版本库包含多个扩展时，需要为每个扩展创建一个单独的文件，而不是为整个版本库创建一个文件。"

#: _versions/3.6/guides/writing-extensions.adoc
#, fuzzy
msgid "That's all. Once the pull request is merged, a scheduled job will check Maven Central for new versions and update the xref:extension-registry-user.adoc[Quarkus Extension Registry]."
msgstr "就这样。一旦拉取请求被合并，计划任务就会检查 Maven Central 是否有新版本，并更新 xref:extension-registry-user.adoc[Quarkus 扩展注册表] 。"
