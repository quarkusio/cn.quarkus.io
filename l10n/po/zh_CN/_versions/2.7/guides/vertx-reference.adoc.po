# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:58+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/2.7/guides/vertx-reference.adoc:6
#, no-wrap
msgid "Vert.x Reference Guide"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:12
msgid "https://vertx.io[Vert.x] is a toolkit for building reactive applications.  As described in the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture], Quarkus uses Vert.x underneath."
msgstr "link:https://vertx.io[Vert.x] 是一个用于构建响应式应用程序的工具集。正如 link:quarkus-reactive-architecture.html[Quarkus响应式架构] 中所描述的，下面，Quarkus将使用Vert.x。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:15
msgid "This guide is the companion to the xref:vertx.adoc[Using Eclipse Vert.x API from a Quarkus Application] guide.  It provides more advanced details about the usage and the configuration of the Vert.x instance used by Quarkus."
msgstr "本指南是《 link:vertx.html[从Quarkus应用程序中使用Eclipse Vert.x API] 》指南的补充。它提供了关于Quarkus使用的Vert.x实例的使用和配置的更多高级细节。"

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:18
#, no-wrap
msgid "Accessing the Vert.x instance"
msgstr "访问Vert.x实例"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:22
msgid "To access the managed Vert.x instance, add the `quarkus-vertx` extension to your project.  Note that this dependency may already be installed (as a transitive dependency)."
msgstr "要访问管理的Vert.x实例，请在你的项目中添加 `quarkus-vertx` 扩展。注意，这个依赖可能已经安装了（作为一个过渡性依赖）。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:24
msgid "With this extension, you can retrieve the managed instance of Vert.x using either field or constructor injection:"
msgstr "通过这个扩展，你可以使用字段或构造函数注入检索Vert.x的托管实例："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:31
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyBean {\n"
"// Field injection\n"
"@Inject Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:36
#, no-wrap
msgid ""
"// Constructor injection\n"
"MyBean(Vertx vertx) {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:38
#: upstream/_versions/2.7/guides/vertx-reference.adoc:212
#: upstream/_versions/2.7/guides/vertx-reference.adoc:815
#: upstream/_versions/2.7/guides/vertx-reference.adoc:876
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:41
msgid "You can inject either the:"
msgstr "你也可以这样注入："

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:43
msgid "`io.vertx.core.Vertx` instance exposing the _bare_ Vert.x API"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:44
msgid "`io.vertx.mutiny.core.Vertx` instance exposing the _Mutiny_ API"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:46
msgid "We recommend using the Mutiny variant as it integrates with the other reactive APIs provided by Quarkus."
msgstr "我们推荐使用Mutiny变体，因为它可以与Quarkus提供的其他响应式API集成。"

#. type: Block title
#: upstream/_versions/2.7/guides/vertx-reference.adoc:48
#: upstream/_versions/2.7/guides/vertx-reference.adoc:554
#, no-wrap
msgid "Mutiny"
msgstr ""

#. type: delimited block =
#: upstream/_versions/2.7/guides/vertx-reference.adoc:51
msgid "If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:54
msgid "Documentation about the Vert.x Mutiny variant is available on https://smallrye.io/smallrye-mutiny-vertx-bindings."
msgstr "关于Vert.x Mutiny变体的文档可在 https://smallrye.io/smallrye-mutiny-vertx-bindings "

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:56
#, no-wrap
msgid "Configuring the Vert.x instance"
msgstr "配置Vert.x实例"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:60
msgid "You can configure the Vert.x instance from the `application.properties` file.  The following table lists the supported properties:"
msgstr "你可以从 `application.properties` 文件中配置Vert.x实例。下表列出了支持的属性："

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:65
#, no-wrap
msgid "Using Vert.x clients"
msgstr "使用 Vert.x 客户端"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:69
msgid "In addition to Vert.x core, you can use most Vert.x ecosystem libraries.  Some Quarkus extension already wraps Vert.x libraries."
msgstr "除了Vert.x核心，你可以使用大多数Vert.x生态系统库。一些Quarkus扩展已经包装了Vert.x库。"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:70
#, no-wrap
msgid "Available APIs"
msgstr "可用的API"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:75
msgid "The following table lists the most used libraries from the Vert.x ecosystem.  To access these APIs, add the indicated extension or dependency to your project.  Refer to the associated documentation to learn how to use them."
msgstr "下表列出了Vert.x生态系统中最常用的库。要访问这些API，请在你的项目中添加指定的扩展或依赖性。请参考相关文档，了解如何使用它们。"

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:79
#, no-wrap
msgid "API"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:80
#, no-wrap
msgid "Extension or Dependency"
msgstr "扩展或依赖性"

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:82
#, no-wrap
msgid "Documentation"
msgstr "文档"

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:83
#, no-wrap
msgid "AMQP Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:84
#, no-wrap
msgid "`io.quarkus:quarkus-smallrye-reactive-messaging-amqp` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:86
#, no-wrap
msgid "https://quarkus.io/guides/amqp"
msgstr " https://cn.quarkus.io/guides/amqp "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:87
#, no-wrap
msgid "Circuit Breaker"
msgstr "熔断器"

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:88
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-circuit-breaker` (external dependency)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:90
#, no-wrap
msgid "https://vertx.io/docs/vertx-circuit-breaker/java/"
msgstr " https://vertx.io/docs/vertx-circuit-breaker/java/ "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:91
#, no-wrap
msgid "Consul Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:92
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client` (external dependency)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:94
#, no-wrap
msgid "https://vertx.io/docs/vertx-consul-client/java/"
msgstr " https://vertx.io/docs/vertx-consul-client/java/ "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:95
#, no-wrap
msgid "DB2 Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:96
#, no-wrap
msgid "`io.quarkus:quarkus-reactive-db2-client` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:98
#: upstream/_versions/2.7/guides/vertx-reference.adoc:114
#: upstream/_versions/2.7/guides/vertx-reference.adoc:118
#: upstream/_versions/2.7/guides/vertx-reference.adoc:122
#: upstream/_versions/2.7/guides/vertx-reference.adoc:126
#, no-wrap
msgid "https://quarkus.io/guides/reactive-sql-clients"
msgstr " https://cn.quarkus.io/guides/reactive-sql-clients "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:99
#, no-wrap
msgid "Kafka Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:100
#, no-wrap
msgid "`io.quarkus:quarkus-smallrye-reactive-messaging-kafka` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:102
#, no-wrap
msgid "https://quarkus.io/guides/kafka"
msgstr " https://cn.quarkus.io/guides/kafka "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:103
#, no-wrap
msgid "Mail Client"
msgstr "邮件客户端"

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:104
#, no-wrap
msgid "`io.quarkus:quarkus-mailer` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:106
#, no-wrap
msgid "https://quarkus.io/guides/mailer"
msgstr " https://cn.quarkus.io/guides/mailer "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:107
#, no-wrap
msgid "MQTT Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:108
#, no-wrap
msgid "`io.quarkus:quarkus-smallrye-reactive-messaging-mqtt` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:110
#, no-wrap
msgid "https://quarkus.io/guides/mqtt"
msgstr " https://cn.quarkus.io/guides/mqtt "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:111
#, no-wrap
msgid "MS SQL Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:112
#, no-wrap
msgid "`io.quarkus:quarkus-reactive-mssql-client` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:115
#, no-wrap
msgid "MySQL Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:116
#, no-wrap
msgid "`io.quarkus:quarkus-reactive-mysql-client` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:119
#, no-wrap
msgid "Oracle Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:120
#, no-wrap
msgid "`io.quarkus:quarkus-reactive-oracle-client` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:123
#, no-wrap
msgid "PostgreSQL Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:124
#, no-wrap
msgid "`io.quarkus:quarkus-reactive-pg-client` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:127
#, no-wrap
msgid "RabbitMQ Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:128
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client` (external dependency)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:130
#, no-wrap
msgid "https://vertx.io/docs/vertx-rabbitmq-client/java"
msgstr " https://vertx.io/docs/vertx-rabbitmq-client/java "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:131
#, no-wrap
msgid "Redis Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:132
#, no-wrap
msgid "`io.quarkus:quarkus-redis-client` (extension)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:134
#, no-wrap
msgid "https://quarkus.io/guides/redis"
msgstr " https://cn.quarkus.io/guides/redis "

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:135
#, no-wrap
msgid "Web Client"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:136
#, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-web-client` (external dependency)"
msgstr ""

#. type: Table
#: upstream/_versions/2.7/guides/vertx-reference.adoc:138
#, no-wrap
msgid "https://vertx.io/docs/vertx-web-client/java/"
msgstr " https://vertx.io/docs/vertx-web-client/java/ "

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:141
msgid "To learn more about the usage of the Vert.x Mutiny API, refer to https://smallrye.io/smallrye-mutiny-vertx-bindings."
msgstr "要了解更多关于Vert.x Mutiny API的用法，请参考 https://smallrye.io/smallrye-mutiny-vertx-bindings"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:142
#, no-wrap
msgid "Example of usage"
msgstr "使用示例"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:146
msgid "This section gives an example using the Vert.x `WebClient`.  As indicated in the table above, add the following dependency to your project:"
msgstr ""

#. type: Block title
#: upstream/_versions/2.7/guides/vertx-reference.adoc:148
#: upstream/_versions/2.7/guides/vertx-reference.adoc:927
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:154
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_versions/2.7/guides/vertx-reference.adoc:157
#: upstream/_versions/2.7/guides/vertx-reference.adoc:943
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:160
#, no-wrap
msgid "implementation(\"io.smallrye.reactive:smallrye-mutiny-vertx-web-client\")\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:163
msgid "Now, in your code, you can create an instance of `WebClient`:"
msgstr "现在，在你的代码中，你可以创建一个 `WebClient` 的实例："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:167
#: upstream/_versions/2.7/guides/vertx-reference.adoc:262
#: upstream/_versions/2.7/guides/vertx-reference.adoc:490
#: upstream/_versions/2.7/guides/vertx-reference.adoc:528
#: upstream/_versions/2.7/guides/vertx-reference.adoc:659
#: upstream/_versions/2.7/guides/vertx-reference.adoc:761
#: upstream/_versions/2.7/guides/vertx-reference.adoc:801
#: upstream/_versions/2.7/guides/vertx-reference.adoc:850
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:175
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:178
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:183
#, no-wrap
msgid ""
"import io.vertx.mutiny.core.Vertx;\n"
"import io.vertx.mutiny.ext.web.client.WebClient;\n"
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.ext.web.client.WebClientOptions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:186
#, no-wrap
msgid ""
"@Path(\"/fruit-data\")\n"
"public class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:188
#, no-wrap
msgid "    private final WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:193
#, no-wrap
msgid ""
"    @Inject\n"
"    VertxResource(Vertx vertx) {\n"
"        this.client = WebClient.create(vertx);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:210
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    @Path(\"/{name}\")\n"
"    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n"
"        return client.getAbs(\"https://.../api/fruit/\" + name)\n"
"                .send()\n"
"                .onItem().transform(resp -> {\n"
"                    if (resp.statusCode() == 200) {\n"
"                        return resp.bodyAsJsonObject();\n"
"                    } else {\n"
"                        return new JsonObject()\n"
"                                .put(\"code\", resp.statusCode())\n"
"                                .put(\"message\", resp.bodyAsString());\n"
"                    }\n"
"                });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:218
msgid "This resource creates a `WebClient` and, upon request, uses this client to invoke a remote HTTP API.  Depending on the result, the response is forwarded as received, or it creates a JSON object wrapping the error.  The `WebClient` is asynchronous (and non-blocking), to the endpoint returns a `Uni`."
msgstr "该资源创建了一个 `WebClient` ，并在请求时使用该客户端来调用远程HTTP API。根据结果，响应被转发，或者创建一个包含错误的 JSON 对象。 `WebClient` 是异步的（和非阻塞的），端点返回一个 `Uni` 。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:222
msgid "The application can also run as a native executable.  But, first, we need to instruct Quarkus to enable _ssl_ (if the remote API uses HTTPS).  Open the `src/main/resources/application.properties` and add:"
msgstr "该应用程序也可以作为一个本地可执行文件运行。但是，首先，我们需要指示Quarkus启用 _ssl_ （如果远程API使用HTTPS）。打开 `src/main/resources/application.properties` ，并添加："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:226
#, no-wrap
msgid "quarkus.ssl.native=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:229
msgid "Then, create the native executable with:"
msgstr "然后，用以下方法创建本地可执行文件："

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:233
#, no-wrap
msgid "Using Vert.x JSON"
msgstr "使用Vert.x JSON"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:237
msgid "Vert.x APIs often rely on JSON.  Vert.x provides two convenient classes to manipulate JSON document: `io.vertx.core.json.JsonObject` and `io.vertx.core.json.JsonArray`."
msgstr "Vert.x的API经常依赖JSON。Vert.x提供了两个方便的类来操作JSON文档： `io.vertx.core.json.JsonObject` 和 `io.vertx.core.json.JsonArray` 。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:239
msgid "`JsonObject` can be used to map an object into its JSON representation and build an object from a JSON document:"
msgstr "`JsonObject` 可用于将一个对象映射到其JSON表示中，并从JSON文档中建立一个对象。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:245
#, no-wrap
msgid ""
"// Map an object into JSON\n"
"Person person = ...;\n"
"JsonObject json = JsonObject.mapFrom(person);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:249
#, no-wrap
msgid ""
"// Build an object from JSON\n"
"json = new JsonObject();\n"
"person = json.mapTo(Person.class);\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:253
msgid "Note that these features use the mapper managed by the `quarkus-jackson` extension.  Refer to xref:rest-json.adoc#json[Jackson configuration] to customize the mapping."
msgstr "注意，这些功能使用由 `quarkus-jackson` 扩展管理的映射器。请参考 link:rest-json.html#json[Jackson的配置] 来自定义映射。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:257
msgid "JSON Object and JSON Array are both supported as Quarkus HTTP endpoint requests and response bodies (using classic RESTEasy and RESTEasy Reactive).  Consider these endpoints:"
msgstr "JSON Object和JSON Array都支持作为Quarkus HTTP端点的请求和响应体（使用经典的RESTEasy和RESTEasy Reactive）。考虑一下这些端点："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:265
#, no-wrap
msgid ""
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.core.json.JsonArray;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:270
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:272
#, no-wrap
msgid "import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:276
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"public class VertxJsonResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:282
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}/object\")\n"
"    public JsonObject jsonObject(@PathParam String name) {\n"
"        return new JsonObject().put(\"Hello\", name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:289
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}/array\")\n"
"    public JsonArray jsonArray(@PathParam String name) {\n"
"        return new JsonArray().add(\"Hello\").add(name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:292
msgid "http://localhost:8080/hello/Quarkus/object returns:"
msgstr " http://localhost:8080/hello/Quarkus/object 返回："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:296
#, no-wrap
msgid "{\"Hello\":\"Quarkus\"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:299
msgid "http://localhost:8080/hello/Quarkus/array returns:"
msgstr " http://localhost:8080/hello/Quarkus/array 返回："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:303
#, no-wrap
msgid "[\"Hello\",\"Quarkus\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:306
msgid "This works equally well when the JSON content is a request body or is wrapped in a `Uni`, `Multi`, `CompletionStage` or `Publisher`."
msgstr "当JSON内容是一个请求体或被包裹在一个 `Uni` , `Multi` , `CompletionStage` 或 `Publisher` 中时，这同样适用。"

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:307
#, no-wrap
msgid "Using verticles"
msgstr "使用verticles"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:312
msgid "link:https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is \"a simple, scalable, actor-like deployment and concurrency model\" provided by _Vert.x_.  This model does not claim to be a strict actor-model implementation, but it shares similarities, especially concerning concurrency, scaling, and deployment.  To use this model, you write and _deploy_ verticles, communicating by sending messages on the event bus."
msgstr "link:https://vertx.io/docs/vertx-core/java/#<em>verticles[Verticles] 是_Vert.x提供的 \"一个简单的、可扩展的、类似于演员的部署和并发模型\"。这个模型并不声称是一个严格的actor-model实现，但它有相似之处，特别是关于并发、扩展和部署。为了使用这个模型，你编写和 _部署_ 顶点，通过在事件总线上发送消息进行通信。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:315
msgid "You can deploy _verticles_ in Quarkus.  It supports:"
msgstr "你可以在Quarkus中部署 _verticles_ 。它支持："

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:317
msgid "_bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`"
msgstr "_bare_ verticle - 延伸的Java类 `io.vertx.core.AbstractVerticle` "

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:318
msgid "_Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`"
msgstr " _Mutiny_ verticle - 扩展的Java类 `io.smallrye.mutiny.vertx.core.AbstractVerticle` "

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:319
#, no-wrap
msgid "Deploying verticles"
msgstr "部署verticles"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:322
msgid "To deploy verticles, use the `deployVerticle` method:"
msgstr "要部署verticles，使用 `deployVerticle` 方法。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:326
#, no-wrap
msgid "@Inject Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:330
#, no-wrap
msgid ""
"// ...\n"
"vertx.deployVerticle(MyVerticle.class.getName(), ar -> { });\n"
"vertx.deployVerticle(new MyVerticle(), ar -> { });\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:333
msgid "If you use the Mutiny-variant of Vert.x, be aware that the `deployVerticle` method returns a `Uni`, and you would need to trigger a subscription to make the actual deployment."
msgstr "如果你使用Vert.x的Mutiny-variant，请注意 `deployVerticle` 方法返回一个 `Uni` ，你需要触发一个订阅来进行实际部署。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:335
msgid "An example explaining how to deploy verticles during the initialization of the application will follow."
msgstr "接下来会有一个例子解释如何在应用程序的初始化过程中部署verticles："

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:336
#, no-wrap
msgid "Using @ApplicationScoped Beans as Verticle"
msgstr "使用@ApplicationScoped Beans作为Verticle"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:342
msgid "In general, Vert.x verticles are not CDI beans.  And so cannot use injection.  However, in Quarkus, you can deploy verticles as beans.  Note that in this case, CDI (Arc in Quarkus) is responsible for creating the instance."
msgstr "一般来说，Vert.x的verticles不是CDI beans。所以不能使用注入。然而，在Quarkus中，你可以把verticle部署为Bean。注意，在这种情况下，CDI（Quarkus中的Arc）负责创建实例。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:344
msgid "The following snippet provides an example:"
msgstr "以下代码段提供了一个示例："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:348
#: upstream/_versions/2.7/guides/vertx-reference.adoc:376
#, no-wrap
msgid "package io.quarkus.vertx.verticles;\n"
msgstr "package io.quarkus.vertx.verticles;\n"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:352
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:354
#: upstream/_versions/2.7/guides/vertx-reference.adoc:494
#: upstream/_versions/2.7/guides/vertx-reference.adoc:805
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:357
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyBeanVerticle extends AbstractVerticle {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:359
#, no-wrap
msgid "    @ConfigProperty(name = \"address\") String address;\n"
msgstr "    @ConfigProperty(name = \"address\") String address;\n"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:367
#, no-wrap
msgid ""
"    @Override\n"
"    public Uni<Void> asyncStart() {\n"
"        return vertx.eventBus().consumer(address)\n"
"                .handler(m -> m.replyAndForget(\"hello\"))\n"
"                .completionHandler();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:370
msgid "You don't have to inject the `vertx` instance; instead, leverage the protected field from `AbstractVerticle`."
msgstr "你不需要注入 `vertx` 实例；相反，你可以利用 `AbstractVerticle` 的受保护字段。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:372
msgid "Then, deploy the verticle instances with:"
msgstr "然后，用以下方法部署verticle实例。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:379
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:382
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:385
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class VerticleDeployer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:390
#, no-wrap
msgid ""
"    public void init(@Observes StartupEvent e, Vertx vertx, MyBeanVerticle verticle) {\n"
"         vertx.deployVerticle(verticle).await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:393
msgid "If you want to deploy every exposed `AbstractVerticle`, you can use:"
msgstr "如果你想部署每个暴露的 `AbstractVerticle` ，你可以使用："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:401
#, no-wrap
msgid ""
"public void init(@Observes StartupEvent e, Vertx vertx, Instance<AbstractVerticle> verticles) {\n"
"    for (AbstractVerticle verticle : verticles) {\n"
"        vertx.deployVerticle(verticle).await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:403
#, no-wrap
msgid "Using multiple verticles instances"
msgstr "使用多个verticles的实例"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:408
msgid "When using `@ApplicationScoped`, you will get a single instance for your verticle.  Having multiple instances of verticles can be helpful to share the load among them.  Each of them will be associated with a different I/O thread (Vert.x event loop)."
msgstr "当使用 `@ApplicationScoped` ，你将为你的verticle获得一个实例。拥有多个verticles的实例可以帮助他们分担负载。它们中的每一个都将与不同的I/O线程相关联（Vert.x事件循环）。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:410
msgid "To deploy multiple instances of your verticle, use the `@Dependent` scope instead of `@ApplicationScoped`:"
msgstr "要部署 Verticle 的多个实例，请使用 `@Dependent` 范围而不是 `@ApplicationScoped` ："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:414
#: upstream/_versions/2.7/guides/vertx-reference.adoc:438
#, no-wrap
msgid "package org.acme.verticle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:417
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:420
#, no-wrap
msgid ""
"import javax.enterprise.context.Dependent;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:423
#, no-wrap
msgid ""
"@Dependent\n"
"public class MyVerticle extends AbstractVerticle {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:431
#, no-wrap
msgid ""
"    @Override\n"
"    public Uni<Void> asyncStart() {\n"
"        return vertx.eventBus().consumer(\"address\")\n"
"                .handler(m -> m.reply(\"Hello from \" + this))\n"
"                .completionHandler();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:434
msgid "Then, deploy your verticle as follows:"
msgstr "然后，按以下方式部署你的verticle："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:442
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.vertx.core.DeploymentOptions;\n"
"import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:447
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
"import javax.enterprise.inject.Instance;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:450
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyApp {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:457
#, no-wrap
msgid ""
"    void init(@Observes StartupEvent ev, Vertx vertx, Instance<MyVerticle> verticles) {\n"
"        vertx\n"
"                .deployVerticle(verticles::get, new DeploymentOptions().setInstances(2))\n"
"                .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:466
msgid "The `init` method receives an `Instance<MyVerticle>`.  Then, you pass a supplier to the `deployVerticle` method.  The supplier is just calling the `get()` method.  Thanks to the `@Dependent` scope, it returns a new instance on every call.  Finally, you pass the desired number of instances to the `DeploymentOptions`, such as two in the previous example.  It will call the supplier twice, which will create two instances of your verticle."
msgstr "`init` 方法接收一个 `Instance<MyVerticle>` 。然后，你将提供者传递给 `deployVerticle` 方法。该提供者只是在调用 `get()` 方法。由于 `@Dependent` 范围，它每次调用都会返回一个新的实例。最后，你向 `DeploymentOptions` 传递所需的实例数量，比如在前面的例子中是两个。它将调用提供者两次，这将为你的verticle创建两个实例。"

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:468
#, no-wrap
msgid "Using the event bus"
msgstr "使用事件总线"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:472
msgid "Vert.x comes with a built-in https://vertx.io/docs/vertx-core/java/#event_bus[event bus] that you can use from your Quarkus application.  So, your application components (CDI beans, resources...) can interact using asynchronous events, thus promoting loose-coupling."
msgstr "Vert.x有一个内置的 link:https://vertx.io/docs/vertx-core/java/#event_bus[事件总线] ，你可以从你的Quarkus应用程序中使用。因此，你的应用程序组件（CDI Bean、resources......）可以使用异步事件进行交互，从而促进松散耦合。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:475
msgid "With the event bus, you send _messages_ to _virtual addresses_.  The event bus offers three types of delivery mechanisms:"
msgstr "通过事件总线，你可以向 _virtual addresses_ 发送 _messages_。事件总线提供三种类型的传递机制："

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:477
msgid "point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round-robin is applied;"
msgstr "point-to-point - 发送消息，一个消费者接收。如果有几个消费者监听该地址，则采用轮流的方式；"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:478
msgid "publish/subscribe - publish a message; all the consumers listening to the address are receiving the message;"
msgstr "publish/subscribe - 发布一个消息；所有监听该地址的消费者都在接收该消息。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:479
msgid "request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous fashion."
msgstr "request/reply - 发送消息并期望得到响应。接收者可以以异步的方式对消息作出回应。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:481
msgid "All these delivery mechanisms are non-blocking and are providing one of the fundamental bricks to build reactive applications."
msgstr "所有这些交付机制都是无阻塞的，并提供了构建响应式应用的基本砖块之一。"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:482
#, no-wrap
msgid "Consuming events"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:486
msgid "While you can use the Vert.x API to register consumers, Quarkus comes with declarative support.  To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:"
msgstr "虽然你可以使用Vert.x的API来注册消费者，但Quarkus带有声明性支持。要消费事件，请使用 `io.quarkus.vertx.ConsumeEvent` 注解。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:492
#: upstream/_versions/2.7/guides/vertx-reference.adoc:530
#: upstream/_versions/2.7/guides/vertx-reference.adoc:803
#, no-wrap
msgid "import io.quarkus.vertx.ConsumeEvent;\n"
msgstr "import io.quarkus.vertx.ConsumeEvent;\n"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:497
#: upstream/_versions/2.7/guides/vertx-reference.adoc:538
#: upstream/_versions/2.7/guides/vertx-reference.adoc:808
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class GreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:503
#, no-wrap
msgid ""
"    @ConsumeEvent                           // <1>\n"
"    public String consume(String name) {    // <2>\n"
"        return name.toUpperCase();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:505
msgid "If not set, the address is the fully qualified name of the bean; for instance, in this snippet, it's `org.acme.vertx.GreetingService`."
msgstr "如果没有设置，地址是Bean的完全限定名称；例如，在这个片段中，它是 `org.acme.vertx.GreetingService` 。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:506
msgid "The method parameter is the message body. If the method returns _something_, it's the message response."
msgstr "方法参数是消息主体。如果该方法返回 _something_ ，那就是消息的响应。"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:507
#, no-wrap
msgid "Configuring the address"
msgstr "配置地址"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:510
msgid "The `@ConsumeEvent` annotation can be configured to set the address:"
msgstr "可以配置 `@ConsumeEvent` 注解设置地址："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:517
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")               // <1>\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:519
msgid "Receive the messages sent to the `greeting` address"
msgstr "接收发送到 `greeting` 地址的信息"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:520
#, no-wrap
msgid "Asynchronous processing"
msgstr "异步处理"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:524
msgid "The previous examples use synchronous processing.  Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:"
msgstr "前面的例子使用了同步处理。异步处理也可以通过返回一个 `io.smallrye.mutiny.Uni` 或一个 `java.util.concurrent.CompletionStage` 。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:535
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:544
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public CompletionStage<String> consume(String name) {\n"
"        // return a CompletionStage completed when the processing is finished.\n"
"        // You can also fail the CompletionStage explicitly\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:551
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public Uni<String> process(String name) {\n"
"        // return an Uni completed when the processing is finished.\n"
"        // You can also fail the Uni explicitly\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/2.7/guides/vertx-reference.adoc:558
msgid "The previous example uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "前面的例子使用了Mutiny响应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:560
#, no-wrap
msgid "Blocking processing"
msgstr "阻塞处理"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:564
msgid "By default, the code consuming the event must be _non-blocking_, as it's called on an I/O thread.  If your processing is blocking, use the `@io.smallrye.common.annotation.Blocking` annotation:"
msgstr "默认情况下，消费该事件的代码必须是 _非阻塞的_ ，因为它是在一个I/O线程上调用的。如果你的处理是阻塞的，请使用 `@io.smallrye.common.annotation.Blocking` 注解。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:572
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\")\n"
"@Blocking\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:575
msgid "Alternatively, you can use the `blocking` attribute from the `@ConsumeEvent` annotation:"
msgstr "或者，你可以使用 `@ConsumeEvent` 注解中的 `blocking` 属性。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:582
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\", blocking = true)\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:585
msgid "When using `@Blocking`, it ignores the value of the `blocking` attribute of `@ConsumeEvent`."
msgstr "当使用 `@Blocking` ，它忽略了 `blocking` 属性的值 `@ConsumeEvent` 。"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:586
#, no-wrap
msgid "Replying to messages"
msgstr "回复信息"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:590
msgid "The _return_ value of a method annotated with `@ConsumeEvent` is used to respond to the incoming message.  For instance, in the following snippet, the returned `String` is the response."
msgstr "用 `@ConsumeEvent` 注解的方法的 _返回值_ 被用来响应传入的消息。例如，在下面的代码片段中，返回的 是 `String` 类型。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:597
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:600
msgid "You can also return a `Uni<T>` or a `CompletionStage<T>` to handle asynchronous reply:"
msgstr "你也可以返回一个 `Uni<T>` 或一个 `CompletionStage<T>` 来处理异步回复："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:607
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public Uni<String> consume2(String name) {\n"
"    return Uni.createFrom().item(() -> name.toUpperCase()).emitOn(executor);\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/2.7/guides/vertx-reference.adoc:612
msgid "You can inject an `executor` if you use the Context Propagation extension:"
msgstr "如果你使用Context Propagation扩展，你可以注入一个 `executor` ："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:615
#, no-wrap
msgid "@Inject Executor executor;\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:618
#, no-wrap
msgid "Implementing fire and forget interactions"
msgstr "实现即发即弃（fire and forget）交互"

#. type: delimited block =
#: upstream/_versions/2.7/guides/vertx-reference.adoc:623
msgid "You don't have to reply to received messages.  Typically, for a _fire and forget_ interaction, the messages are consumed, and the sender does not need to know about it.  To implement this pattern, your consumer method returns `void`."
msgstr "你不需要回复收到的消息。通常情况下，对于 _fire 和 forget_ 交互来说，消息被消耗掉了，发送者不需要知道这件事。为了实现这种模式，你的消费者方法返回 `void` 类型 。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:630
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(String event) {\n"
"    // Do something with the event\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:632
#, no-wrap
msgid "Dealing with messages"
msgstr "处理信息"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:635
msgid "Unlike the previous example using the _payloads_ directly, you can also use `Message` directly:"
msgstr "与之前直接使用 _有效载荷_ 的例子不同，你也可以直接使用 `Message` 。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:643
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(Message<String> msg) {\n"
"    System.out.println(msg.address());\n"
"    System.out.println(msg.body());\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:645
#, no-wrap
msgid "Handling Failures"
msgstr "处理故障"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:648
msgid "If a method annotated with `@ConsumeEvent` throws an exception, then:"
msgstr "如果一个用 `@ConsumeEvent` 注解的方法抛出一个异常，那么："

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:650
msgid "if a reply handler is set, then the failure is propagated back to the sender via an `io.vertx.core.eventbus.ReplyException` with code `ConsumeEvent#FAILURE_CODE` and the exception message,"
msgstr "如果设置了一个回复处理程序，那么失败就会通过一个带有代码 `ConsumeEvent#FAILURE_CODE` 和异常消息的 `io.vertx.core.eventbus.ReplyException` 传播回发送者，"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:651
msgid "if no reply handler is set, then the exception is rethrown (and wrapped in a `RuntimeException` if necessary) and can be handled by the default exception handler, i.e. `io.vertx.core.Vertx#exceptionHandler()`."
msgstr "如果没有设置回复处理程序，那么异常会被重新抛出（如果需要的话，会被包裹在一个 `RuntimeException` ），并且可以由默认的异常处理程序来处理，即 `io.vertx.core.Vertx#exceptionHandler()` 。"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:652
#, no-wrap
msgid "Sending messages"
msgstr "发送信息"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:655
msgid "Sending and publishing messages use the Vert.x event bus:"
msgstr "发送和发布消息使用Vert.x事件总线。"

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:664
#: upstream/_versions/2.7/guides/vertx-reference.adoc:766
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.core.eventbus.EventBus;\n"
"import io.vertx.mutiny.core.eventbus.Message;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:670
#: upstream/_versions/2.7/guides/vertx-reference.adoc:772
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:673
#, no-wrap
msgid ""
"@Path(\"/async\")\n"
"public class EventResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:676
#, no-wrap
msgid ""
"    @Inject\n"
"    EventBus bus;                                            // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:685
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(@PathParam String name) {\n"
"        return bus.<String>request(\"greeting\", name)        // <2>\n"
"                .onItem().transform(Message::body);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:687
msgid "Inject the Event bus"
msgstr "注入事件总线"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:688
msgid "Send a message to the address `greeting`. Message payload is `name`"
msgstr "发送消息到地址 `greeting` 。消息的有效载荷是 `name` "

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:690
msgid "The `EventBus` object provides methods to:"
msgstr "`EventBus` 对象提供了以下方法："

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:692
msgid "`send` a message to a specific address - one single consumer receives the message."
msgstr "`send` 一个消息到一个特定的地址 - 单个消费者收到该消息。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:693
msgid "`publish` a message to a specific address - all consumers receive the messages."
msgstr "`publish` 向一个特定的地址发送消息--所有的消费者都会收到这些消息。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:694
msgid "`request` a message and expect a reply"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:704
#, no-wrap
msgid ""
"// Case 1\n"
"bus.sendAndForget(\"greeting\", name)\n"
"// Case 2\n"
"bus.publish(\"greeting\", name)\n"
"// Case 3\n"
"Uni<String> response = bus.<String>request(\"address\", \"hello, how are you?\")\n"
"        .onItem().transform(Message::body);\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:706
#, no-wrap
msgid "Using codecs"
msgstr "使用编解码器"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:711
msgid "The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default codec for local delivery.  So you can exchange objects as follows:"
msgstr "link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x事件总线] 使用编解码器来 _序列化_ 和 _反序列化_ 对象。Quarkus为本地交付提供了一个默认的编解码器。所以你可以按以下方式交换对象："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:721
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(@PathParam String name) {\n"
"    return bus.<String>request(\"greeting\", new MyName(name))\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:726
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\")\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \" + name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:729
msgid "If you want to use a specific codec, you need to set it on both ends explicitly:"
msgstr "如果你想使用一个特定的编解码器，你需要在两端明确地设置它："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:740
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(@PathParam String name) {\n"
"    return bus.<String>request(\"greeting\", name,\n"
"        new DeliveryOptions().setCodecName(MyNameCodec.class.getName())) // <1>\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:745
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\", codec = MyNameCodec.class)            // <2>\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \"+name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:747
msgid "Set the name of the codec to use to send the message"
msgstr "设置用于发送消息的编解码器的名称"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:748
msgid "Set the codec to use to receive the message"
msgstr "设置用于接收信息的编解码器"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:749
#, no-wrap
msgid "Combining HTTP and the event bus"
msgstr "结合HTTP和事件总线"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:755
msgid "Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.  It uses the request/reply dispatching mechanism.  Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.  Another bean consumes this message, and the response is sent using the _reply_ mechanism."
msgstr "让我们重新访问一个响应的HTTP端点，并使用异步消息传递将调用委托给一个单独的bean。它使用了request/reply的调度机制。我们不是在JAX-RS端点内实现业务逻辑，而是发送一个消息。另一个Bean使用这个消息，并使用 _回复_ 机制发送响应。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:757
msgid "In your HTTP endpoint class, inject the event bus and uses the `request` method to send a message to the event bus and expect a response:"
msgstr "在你的HTTP端点类中，注入事件总线，并使用 `request` 方法向事件总线发送一个消息，并期待一个响应："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:775
#, no-wrap
msgid ""
"@Path(\"/bus\")\n"
"public class EventResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:778
#, no-wrap
msgid ""
"    @Inject\n"
"    EventBus bus;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:787
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(@PathParam String name) {\n"
"        return bus.<String>request(\"greeting\", name)            // <1>\n"
"                .onItem().transform(Message::body);            // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:789
msgid "send the `name` to the `greeting` address and request a response"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:790
msgid "when we get the response, extract the body and send it to the user"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:794
msgid "the HTTP method returns a `Uni`.  If you are using RESTEasy Reactive, `Uni` support is built-in.  If you are using _classic_ RESTEasy, you need to add the `quarkus resteasy-mutiny` extension to your project."
msgstr "HTTP方法返回一个 `Uni` 。如果你使用的是RESTEasy Reactive， `Uni` 支持是内置的。如果你使用的是 _经典的_ RESTEasy，你需要在你的项目中添加 `quarkus resteasy-mutiny` 扩展。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:797
msgid "We need a consumer listening on the `greeting` address.  This consumer can be in the same class or another bean such as:"
msgstr "我们需要一个消费者监听 `greeting` 地址。这个消费者可以在同一个类中，也可以是另一个Bean，比如："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:813
#, no-wrap
msgid ""
"    @ConsumeEvent(\"greeting\")\n"
"    public String greeting(String name) {\n"
"        return \"Hello \" + name;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:818
msgid "This bean receives the name and returns the greeting message."
msgstr "这个Bean接收名字并返回响应信息。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:820
msgid "With this in place, every HTTP request on `/bus/quarkus` sends a message to the event bus, waits for a reply, and when this one arrives, writes the HTTP response:"
msgstr "有了这个， `/bus/quarkus` 上的每个HTTP请求都会向事件总线发送一个消息，等待回复，当这个回复到来时，就会写入HTTP响应："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:824
#, no-wrap
msgid "Hello Quarkus\n"
msgstr "Hello Quarkus\n"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:827
msgid "To better understand, let's detail how the HTTP request/response has been handled:"
msgstr "为了更好地理解，让我们详细介绍一下HTTP request/response 是如何被处理的："

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:829
msgid "The request is received by the `greeting` method"
msgstr "该请求由 `greeting` 方法接收"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:830
msgid "a message containing the _name_ is sent to the event bus"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:831
msgid "Another bean receives this message and computes the response"
msgstr "另一个Bean收到这个消息，并计算出响应"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:832
msgid "This response is sent back using the reply mechanism"
msgstr "使用回复机制发回此响应"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:833
msgid "Once the reply is received by the sender, the content is written to the HTTP response"
msgstr "一旦发送方收到回复，会将内容写入 HTTP 响应"

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:835
#, no-wrap
msgid "Bi-directional communication with browsers using SockJS"
msgstr "使用SockJS与浏览器进行双向通信"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:841
msgid "The SockJS bridge provided by Vert.x allows browser applications and Quarkus applications to communicate using the event bus.  It connects both sides.  So, both sides can send messages received on the other side.  It supports the three delivery mechanisms."
msgstr "Vert.x提供的SockJS桥允许浏览器应用程序和Quarkus应用程序使用事件总线进行通信。它连接了双方。所以，双方都可以发送在另一方收到的消息。它支持三种传递机制。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:844
msgid "SockJS negotiates the communication channel between the Quarkus application and the browser.  If WebSockets are supported, it uses them; otherwise, it degrades to SSE, long polling, etc."
msgstr "SockJS负责协商Quarkus应用程序和浏览器之间的通信渠道。如果支持WebSockets，它就使用它们；否则，它就退化为SSE、long polling等。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:846
msgid "So use SockJS, you need to configure the bridge, especially the addresses that will be used to communicate:"
msgstr "因此，使用SockJS，你需要配置桥梁，特别是将用于通信的地址："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:856
#, no-wrap
msgid ""
"import io.vertx.core.Vertx;\n"
"import io.vertx.ext.bridge.PermittedOptions;\n"
"import io.vertx.ext.web.Router;\n"
"import io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions;\n"
"import io.vertx.ext.web.handler.sockjs.SockJSHandler;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:861
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
"import javax.inject.Inject;\n"
"import java.util.concurrent.atomic.AtomicInteger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:864
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class SockJsExample {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:867
#, no-wrap
msgid ""
"    @Inject\n"
"    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:874
#, no-wrap
msgid ""
"    public void init(@Observes Router router) {\n"
"        SockJSHandler sockJSHandler = SockJSHandler.create(vertx);\n"
"        sockJSHandler.bridge(new SockJSBridgeOptions()\n"
"                .addOutboundPermitted(new PermittedOptions().setAddress(\"ticks\")));\n"
"        router.route(\"/eventbus/*\").handler(sockJSHandler);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:880
msgid "This code configures the SockJS bridge to send all the messages targeting the `ticks` address to the connected browsers.  More detailled explanations about the configuration can be found on https://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge[the Vert.x SockJS Bridge documentation]."
msgstr "这段代码配置了SockJS桥接器，以将所有针对 `ticks` 地址的信息发送到所连接的浏览器。更详细的配置说明可以在 https://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge[Vert.x SockJS Bridge文档] 中找到。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:882
msgid "The browser must use the `vertx-eventbus` JavaScript library to consume the message:"
msgstr "浏览器必须使用 `vertx-eventbus` JavaScript库来消费该信："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:896
#, no-wrap
msgid ""
"<!doctype html>\n"
"<html>\n"
"<head>\n"
"    <meta charset=\"utf-8\"/>\n"
"    <title>SockJS example - Quarkus</title>\n"
"    <script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"\n"
"            integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"></script>\n"
"    <script type=\"application/javascript\" src=\"https://cdn.jsdelivr.net/sockjs/0.3.4/sockjs.min.js\"></script>\n"
"    <script src=\"https://cdn.jsdelivr.net/npm/vertx3-eventbus-client@3.8.5/vertx-eventbus.min.js\"></script>\n"
"</head>\n"
"<body>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:898
#, no-wrap
msgid "<h1>SockJS Examples</h1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:900
#, no-wrap
msgid "<p><strong>Last Tick:</strong> <span id=\"tick\"></span></p>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:904
#, no-wrap
msgid ""
"</body>\n"
"<script>\n"
"    var eb = new EventBus('/eventbus');\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:906
#, no-wrap
msgid "    eb.onopen = function () {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:911
#, no-wrap
msgid ""
"        eb.registerHandler('ticks', function (error, message) {\n"
"            $(\"#tick\").html(message.body);\n"
"        });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:914
#, no-wrap
msgid ""
"</script>\n"
"</html>\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:917
#, no-wrap
msgid "Native Transport"
msgstr "本地运输"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:920
msgid "Native transports are not supported in GraalVM produced binaries."
msgstr "GraalVM生产的二进制文件中不支持本地传输。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:925
msgid "Vert.x is capable of using https://netty.io/wiki/native-transports.html[Netty's native transports], which offers performance improvements on specific platforms.To enable them, you must include the appropriate dependency for your platform. It's usually a good idea to have both to keep your application platform agnostic. Netty is smart enough to use the correct one, that includes none at all on unsupported platforms:"
msgstr "Vert.x能够使用 https://netty.io/wiki/native-transports.html[Netty的本地传输] ，在特定的平台上提供性能改进。要启用它们，你必须为你的平台包含适当的依赖。通常，为了保持你的应用程序与平台无关，这是个好主意。Netty很聪明，会使用正确的依赖，包括在不支持的平台上根本不使用："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:934
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.netty</groupId>\n"
"  <artifactId>netty-transport-native-epoll</artifactId>\n"
"  <classifier>linux-x86_64</classifier>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:940
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.netty</groupId>\n"
"  <artifactId>netty-transport-native-kqueue</artifactId>\n"
"  <classifier>osx-x86_64</classifier>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:946
#, no-wrap
msgid "implementation(\"io.netty:netty-transport-native-epoll::linux-x86_64\")\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:948
#, no-wrap
msgid "implementation(\"io.netty:netty-transport-native-kqueue::osx-x86_64\")\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:952
msgid "You will also have to explicitly configure Vert.x to use the native transport.  In `application.properties` add:"
msgstr "你还必须明确地配置Vert.x来使用本地传输。在 `application.properties` 中添加："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:956
#, no-wrap
msgid "quarkus.vertx.prefer-native-transport=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:959
msgid "Or in `application.yml`:"
msgstr "或者在 `application.yml` ："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:965
#, no-wrap
msgid ""
"quarkus:\n"
"  vertx:\n"
"    prefer-native-transport: true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:968
msgid "If all is well quarkus will log:"
msgstr "如果一切顺利的话，quarkus 会输出以下日志："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:971
#, no-wrap
msgid "[io.qua.ver.cor.run.VertxCoreRecorder] (main) Vertx has Native Transport Enabled: true\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:973
#, no-wrap
msgid "Native Linux Transport"
msgstr "本地Linux传输"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:976
msgid "On Linux you can enable the following socket options:"
msgstr "在Linux上，你可以启用以下socket选项："

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:978
#: upstream/_versions/2.7/guides/vertx-reference.adoc:999
msgid "SO_REUSEPORT"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:980
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1001
#, no-wrap
msgid "quarkus.http.so-reuse-port=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:982
msgid "TCP_QUICKACK"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:984
#, no-wrap
msgid "quarkus.http.tcp-quick-ack=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:986
msgid "TCP_CORK"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:988
#, no-wrap
msgid "quarkus.http.tcp-cork=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:990
msgid "TCP_FASTOPEN"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:992
#, no-wrap
msgid "quarkus.http.tcp-fast-open=true\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.7/guides/vertx-reference.adoc:994
#, no-wrap
msgid "Native MacOS Transport"
msgstr "本地MacOS传输"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:997
msgid "On MacOS Sierra and above you can enable the following socket options:"
msgstr "在MacOS Sierra及以上版本，你可以启用以下socket选项："

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1004
#, no-wrap
msgid "Listening to a Unix Domain Socket"
msgstr "监听Unix Domain Socket"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1010
msgid "Listening on a Unix domain socket allows us to dispense with the overhead of TCP if the connection to the quarkus service is established from the same host. This can happen if access to the service goes through a proxy which is often the case if you're setting up a service mesh with a proxy like Envoy."
msgstr "如果与 quarkus 服务的连接是从同一主机建立的，那么侦听 Unix 域套接字允许我们免除 TCP 的开销。如果通过代理访问服务可能会发生这种情况，如果您使用 Envoy 等代理设置服务网格，通常会出现这种情况。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1012
msgid "This will only work on platforms that support <<native-transport>>."
msgstr "这仅适用于支持 link:#native-transport[[native-transport]] 的平台。"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1015
msgid "Enable the appropriate <<native-transport>> and set the following environment property:"
msgstr "启用适当的 link:#native-transport[[native-transport]] 并设置以下环境属性："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1019
#, no-wrap
msgid ""
"quarkus.http.domain-socket=/var/run/io.quarkus.app.socket\n"
"quarkus.http.domain-socket-enabled=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1023
msgid "By itself this will not disable the tcp socket which by default will open on `0.0.0.0:8080`. It can be explicitly disabled:"
msgstr "就其本身而言，这不会禁用默认情况下将在 0.0.0.0:8080 上打开的 tcp socket（套接字）。可以明确禁用它："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1026
#, no-wrap
msgid "quarkus.http.host-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1030
msgid "These properties can be set through Java's `-D` command line parameter or on `application.properties`."
msgstr "这些属性可以通过 Java 的 `-D` 命令行参数或在 `application.properties` 上设置。"

#. type: Title ==
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1031
#, no-wrap
msgid "Read only deployment environments"
msgstr "只读部署环境"

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1034
msgid "In environments with read only file systems you may receive errors of the form:"
msgstr "在具有只读文件系统的环境中，您可能会收到以下形式的错误："

#. type: delimited block -
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1038
#, no-wrap
msgid "java.lang.IllegalStateException: Failed to create cache dir\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.7/guides/vertx-reference.adoc:1040
msgid "Assuming `/tmp/` is writable this can be fixed by setting the `vertx.cacheDirBase` property to point to a directory in `/tmp/` for instance in OpenShift by creating an environment variable `JAVA_OPTS` with the value `-Dvertx.cacheDirBase=/tmp/vertx`."
msgstr "假设 `/tmp/` 是可写的，可以通过将 `vertx.cacheDirBase` 属性设置为指向 `/tmp/` 中的目录来修复此问题，例如在OpenShift中，通过创建一个值为 `-Dvertx.cacheDirBase=/tmp/vertx` ,名为 `JAVA_OPTS` 的环境变量。"
