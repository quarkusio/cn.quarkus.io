# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-12 15:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:6
#, no-wrap
msgid "Amazon Lambda with RESTEasy, Undertow, or Vert.x Web"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:14
msgid "With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy (JAX-RS), Undertow (servlet), Vert.x Web, link:funqy-http[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:17
msgid "You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework]."
msgstr "你可以将你的Lambda部署为一个纯Java jar，或者你可以将你的项目编译为一个原生镜像，并以较少的内存占用和启动时间来部署。我们的集成还可以生成SAM部署文件，这些文件可以被 link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[亚马逊的SAM框架] 来使用。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:21
msgid "Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision."
msgstr "Quarkus对每个网关API都有一个不同的扩展。HTTP网关API是在 `quarkus-amazon-lambda-http` 扩展中实现的。REST网关API是在 `quarkus-amazon-lambda-rest` 扩展中实现的。如果你对使用哪种网关产品感到困惑，亚马逊有一个 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[很好的指南] 来帮助你做这个决定。"

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:25
#, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:28
msgid "To complete this guide, you need:"
msgstr "要完成这个指南，你需要："

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:30
msgid "less than 30 minutes"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:31
msgid "JDK 11 (AWS requires JDK 8 or 11)"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:32
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:33
msgid "https://aws.amazon.com[An Amazon AWS account]"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:34
msgid "https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:35
#, no-wrap
msgid "Getting Started"
msgstr "入门指南"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:39
msgid "This guide walks you through generating an example Java project via a Maven archetype.  Later on it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda."
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:40
#, no-wrap
msgid "Installing AWS bits"
msgstr "安装AWS位"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:44
msgid "Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI."
msgstr "安装所有的AWS位可能是本指南中最困难的事情。请确保你遵循安装AWS SAM CLI的所有步骤。"

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:45
#, no-wrap
msgid "Creating the Maven Deployment Project"
msgstr "创建Maven部署项目"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:48
msgid "Create the Quarkus AWS Lambda Maven project using our Maven Archetype."
msgstr "使用我们的Maven 原型创建Quarkus AWS Lambda Maven项目。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:50
msgid "If you want to use the AWS Gateway HTTP API, generate your project with this script:"
msgstr "如果你想使用AWS Gateway HTTP API，请用这个脚本生成你的项目："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:56
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-http-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:59
msgid "If you want to use the AWS Gateway REST API, generate your project with this script:"
msgstr "如果你想使用AWS Gateway REST API，请用这个脚本生成你的项目："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:65
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-rest-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:68
#, no-wrap
msgid "Build and Deploy"
msgstr "构建和部署"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:71
msgid "Build the project using Maven."
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:75
#, no-wrap
msgid "./mvnw clean install\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:80
msgid "This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension."
msgstr "这将编译代码并运行生成的项目中包含的单元测试。单元测试和其他的Java项目一样，不需要运行在Amazon上。Quarkus开发模式也可以通过这个扩展来提供。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:83
msgid "If you want to build a native executable, make sure you have GraalVM installed correctly and just add a `native` property to the build"
msgstr "如果你想构建一个本地可执行文件，请确保你已经正确安装了GraalVM，并且只需向构建添加一个 `native` 属性"

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:87
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:158
#, no-wrap
msgid "./mvnw clean install -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:93
msgid "If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your Maven build (or link:gradle-tooling#building-a-native-executable[for Gradle]).  This requires you to have Docker installed locally, however."
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:97
#, no-wrap
msgid "./mvnw clean install -Dnative -Dquarkus.native.container-build=true\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:99
#, no-wrap
msgid "Extra Build Generated Files"
msgstr "构建额外生成的文件"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:103
msgid "After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the the build directory: `target/` for Maven, `build/` for Gradle."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:105
msgid "`function.zip` - lambda deployment file"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:106
msgid "`sam.jvm.yaml` - sam cli deployment script"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:107
msgid "`sam.native.yaml` - sam cli deployment script for native"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:108
#, no-wrap
msgid "Simulate Amazon Lambda Deployment"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:112
msgid "The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:"
msgstr "AWS SAM CLI允许你在模拟的Lambda环境中的笔记本电脑上，本地运行你的lambda。这需要安装Docker。在构建了Maven项目后，执行这个命令："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:116
#, no-wrap
msgid "sam local start-api --template target/sam.jvm.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:120
msgid "This will start a Docker container that mimics Amazon's Lambda's deployment environment. Once the environment is started you can invoke the example lambda in your browser by going to:"
msgstr "这将启动一个模仿亚马逊的Lambda部署环境的Docker容器。一旦环境启动了，你就可以在你的浏览器中调用lambda示例，方法是去："

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:122
msgid "http://127.0.0.1:3000/hello"
msgstr "http://127.0.0.1:3000/hello"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:125
msgid "In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java."
msgstr "在控制台，你会看到lambda的启动信息。这个特定的部署启动了一个JVM，并将你的lambda作为纯Java加载。"

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:127
#, no-wrap
msgid "Deploy to AWS"
msgstr "部署到AWS"

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:132
#, no-wrap
msgid "sam deploy -t target/sam.jvm.yaml -g\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:136
msgid "Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:"
msgstr "回答所有的问题，你的lambda将被部署，必要的钩子将被设置到API网关。如果一切部署成功，你的微服务的根URL将被输出到控制台。类似这样："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:141
#, no-wrap
msgid ""
"Key                 LambdaHttpApi\n"
"Description         URL for application\n"
"Value               https://234asdf234as.execute-api.us-east-1.amazonaws.com/\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:144
msgid "The `Value` attribute is the root URL for your lambda. Copy it to your browser and add `hello` at the end."
msgstr "`Value` 属性是你的lambda的根URL。把它复制到你的浏览器，并在末尾添加 `hello` 。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:150
msgid "Responses for binary types will be automatically encoded with base64.  This is different than the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding."
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:151
#, no-wrap
msgid "Deploying a native executable"
msgstr "部署一个本地可执行文件"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:154
msgid "To deploy a native executable, you must build it with GraalVM."
msgstr "要部署一个本地可执行文件，你必须用GraalVM构建它。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:161
msgid "You can then test the executable locally with sam local"
msgstr "然后你可以使用sam local在本地测试可执行文件"

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:165
#, no-wrap
msgid "sam local start-api --template target/sam.native.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:168
msgid "To deploy to AWS Lambda:"
msgstr "要部署到AWS Lambda："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:171
#, no-wrap
msgid "sam deploy -t target/sam.native.yaml -g\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:173
#, no-wrap
msgid "Examine the POM"
msgstr "检查POM"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:178
msgid "There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploy an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:182
msgid "Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy`, `quarkus-vertx-web`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (JAX-RS, Vertx Web, and/or Servlet) and remove the other dependencies to shrink your deployment."
msgstr ""

#. type: Title ===
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:183
#, no-wrap
msgid "Examine sam.yaml"
msgstr "检查sam.yaml"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:187
msgid "The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files."
msgstr "`sam.yaml` 语法已经超出了本文档的范围。有几件事情必须强调，以防你要制作你自己的自定义 `sam.yaml` 部署文件。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:190
msgid "The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name."
msgstr "首先需要注意的是，对于纯Java lambda部署，需要一个特定的处理程序类。不要改变Lambda处理程序的名称。"

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:196
#, no-wrap
msgid ""
"     Properties:\n"
"        Handler: io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest\n"
"        Runtime: java11\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:199
msgid "This handler is a bridge between the lambda runtime and the Quarkus HTTP framework you are using (JAX-RS, Servlet, etc.)"
msgstr "这个处理程序是lambda运行时和你正在使用的Quarkus HTTP框架（JAX-RS、Servlet等）之间的桥梁。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:202
msgid "If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:"
msgstr "如果你想使用原生，那么必须为本地GraalVM部署设置一个环境变量。如果你看一下 `sam.native.yaml` ，你会看到这个变量："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:208
#, no-wrap
msgid ""
"        Environment:\n"
"          Variables:\n"
"            DISABLE_SIGNAL_HANDLERS: true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:211
msgid "This environment variable resolves some incompatibilities between Quarkus and the Amazon Lambda Custom Runtime environment."
msgstr "这个环境变量解决了Quarkus和Amazon Lambda Custom Runtime环境之间的一些不兼容问题。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:216
msgid "Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:"
msgstr "最后，对于AWS Gateway REST API的部署，有一件特别的事情。该API假定HTTP响应体是文本，除非你通过配置明确告诉它哪些媒体类型是二进制。为了使事情更简单，Quarkus扩展强制对所有的HTTP响应信息进行二进制（base 64）编码， `sam.yaml` 文件必须配置API网关，以假设所有的媒体类型都是二进制："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:224
#, no-wrap
msgid ""
"  Globals:\n"
"    Api:\n"
"      EndpointConfiguration: REGIONAL\n"
"      BinaryMediaTypes:\n"
"        - \"*/*\"\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:226
#, no-wrap
msgid "Injectable AWS Context Variables"
msgstr "可注入的AWS上下文变量"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:230
msgid "If you are using RESTEasy and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes using the JAX-RS `@Context` annotation."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:233
msgid "For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:"
msgstr "对于AWS HTTP API，你可以注入AWS变量 `com.amazonaws.services.lambda.runtime.Context` 和 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` 。下面是一个例子："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:238
#, no-wrap
msgid ""
"import javax.ws.rs.core.Context;\n"
"import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:244
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:269
#, no-wrap
msgid ""
"@Path(\"/myresource\")\n"
"public class MyResource {\n"
"    @GET\n"
"    public String ctx(@Context com.amazonaws.services.lambda.runtime.Context ctx) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:247
#, no-wrap
msgid ""
"    @GET\n"
"    public String event(@Context APIGatewayV2HTTPEvent event) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:250
#, no-wrap
msgid ""
"    @GET\n"
"    public String requestContext(@Context APIGatewayV2HTTPEvent.RequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:253
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:277
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:257
msgid "For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:"
msgstr "对于AWS REST API，你可以注入AWS变量 `com.amazonaws.services.lambda.runtime.Context` 和 `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext` 。下面是一个例子："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:263
#, no-wrap
msgid ""
"import javax.ws.rs.core.Context;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:272
#, no-wrap
msgid ""
"    @GET\n"
"    public String reqContext(@Context AwsProxyRequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:275
#, no-wrap
msgid ""
"    @GET\n"
"    public String req(@Context AwsProxyRequest req) { }\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:279
#, no-wrap
msgid "Tracing with AWS XRay and GraalVM"
msgstr "使用AWS XRay和GraalVM进行追踪"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:284
msgid "If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work."
msgstr "如果你正在构建原生镜像，并希望在你的lambda中使用 link:https://aws.amazon.com/xray[AWS X-Ray Tracing] ，那么你将需要在你的pom中包含 `quarkus-amazon-lambda-xray` 来作为一个依赖项。AWS X-Ray库与GraalVM并不完全兼容，因此我们不得不做一些整合工作来使其正常运行。"

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:285
#, no-wrap
msgid "Security Integration"
msgstr "安全集成"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:290
msgid "When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (JAX-RS, servlet, Vert.x Web)."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:297
msgid "API Gateway supports many different ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in JAX-RS by injecting a `javax.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Vert.x Web.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:299
msgid "To enable this security feature, add this to your `application.properties` file:"
msgstr "要启用这一安全特性，请将此添加到你的 `application.properties` 文件中："

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:301
#, no-wrap
msgid "quarkus.lambda-http.enable-security=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:305
msgid "Here's how its mapped:"
msgstr "下面是它的映射方式："

#. type: Block title
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:306
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:335
#, no-wrap
msgid "HTTP `quarkus-amazon-lambda-http`"
msgstr "HTTP `quarkus-amazon-lambda-http` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:309
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:319
#, no-wrap
msgid "Auth Type"
msgstr "认证类型"

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:309
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:319
#, no-wrap
msgid "Principal Class"
msgstr "主体类"

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:310
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:320
#, no-wrap
msgid "Json path of Principal Name"
msgstr "主体名的Json路径"

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:310
#, no-wrap
msgid "Cognito JWT"
msgstr "Cognito JWT"

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:310
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:320
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CognitoPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.CognitoPrincipal` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:311
#, no-wrap
msgid "`requestContext.authorizer.jwt.claims.cognito:username`"
msgstr "`requestContext.authorizer.jwt.claims.cognito:username` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:311
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:321
#, no-wrap
msgid "IAM"
msgstr ""

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:311
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:321
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.IAMPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.IAMPrincipal` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:312
#, no-wrap
msgid "`requestContext.authorizer.iam.userId`"
msgstr "`requestContext.authorizer.iam.userId` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:312
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:322
#, no-wrap
msgid "Custom Lambda"
msgstr "自定义Lambda"

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:312
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:322
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CustomPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.CustomPrincipal` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:314
#, no-wrap
msgid "`requestContext.authorizer.lambda.principalId`"
msgstr "`requestContext.authorizer.lambda.principalId` "

#. type: Block title
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:316
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:376
#, no-wrap
msgid "REST `quarkus-amazon-lambda-rest`"
msgstr "REST `quarkus-amazon-lambda-rest` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:320
#, no-wrap
msgid "Cognito"
msgstr "Cognito"

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:321
#, no-wrap
msgid "`requestContext.authorizer.claims.cognito:username`"
msgstr "`requestContext.authorizer.claims.cognito:username` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:322
#, no-wrap
msgid "`requestContext.identity.user`"
msgstr "`requestContext.identity.user` "

#. type: Table
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:324
#, no-wrap
msgid "`requestContext.authorizer.principalId`"
msgstr "`requestContext.authorizer.principalId` "

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:326
#, no-wrap
msgid "Custom Security Integration"
msgstr "自定义安全集成"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:334
msgid "The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have can full control how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration."
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:339
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:380
#, no-wrap
msgid "package io.quarkus.amazon.lambda.http;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:349
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"    @Override\n"
"    default public Class<LambdaAuthenticationRequest> getRequestType() {\n"
"        return LambdaAuthenticationRequest.class;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:359
#, no-wrap
msgid ""
"    @Override\n"
"    default Uni<SecurityIdentity> authenticate(LambdaAuthenticationRequest request, AuthenticationRequestContext context) {\n"
"        APIGatewayV2HTTPEvent event = request.getEvent();\n"
"        SecurityIdentity identity = authenticate(event);\n"
"        if (identity == null) {\n"
"            return Uni.createFrom().optional(Optional.empty());\n"
"        }\n"
"        return Uni.createFrom().item(identity);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:371
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:375
msgid "For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`"
msgstr "对于HTTP，要覆盖的重要方法是 `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)` 。为此，你将根据你从 `APIGatewayV2HTTPEvent` 映射安全数据的方式来分配一个SecurityIdentity"

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:382
#, no-wrap
msgid "import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:384
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:425
#, no-wrap
msgid "import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:390
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
"import io.quarkus.security.identity.AuthenticationRequestContext;\n"
"import io.quarkus.security.identity.IdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:397
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:409
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:413
msgid "For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`."
msgstr "对于REST，要覆盖的重要方法是 `LambdaIdentityProvider.authenticate(AwsProxyRequest event)` 。为此，你将根据你从 `AwsProxyRequest` 映射安全数据的方式来分配一个SecurityIdentity。"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:415
msgid "Your implemented provider must be a CDI bean.  Here's an example:"
msgstr "您实现的提供者必须是一个CDI bean。这里是一个例子:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:419
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:450
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:421
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:452
#, no-wrap
msgid "import java.security.Principal;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:423
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:454
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:430
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:461
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.LambdaIdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.quarkus.security.runtime.QuarkusPrincipal;\n"
"import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:443
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        if (event.getHeaders() == null || !event.getHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getHeaders().get(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:446
msgid "Here's the same example, but with the AWS Gateway REST API:"
msgstr "下面是同样的例子，但是使用了AWS Gateway REST API:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:456
#, no-wrap
msgid "import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:474
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        if (event.getMultiValueHeaders() == null || !event.getMultiValueHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getMultiValueHeaders().getFirst(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:478
msgid "Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier."
msgstr "Quarkus应该自动发现这个实现并使用它，而不是前面讨论的默认实现。"

#. type: Title ==
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:479
#, no-wrap
msgid "Simple SAM Local Principal"
msgstr "简单的SAM本地主体"

#. type: Plain text
#: upstream/_versions/2.2/guides/amazon-lambda-http.adoc:483
msgid "If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable"
msgstr "如果你使用 `sam local` 测试你的应用程序，你可以通过设置 `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` 环境变量来硬编码一个主体名，以便在应用程序运行时使用"
