<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.6.2" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>Our monthly newsletters bring together articles, videos and perspectives from across the Quarkus community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的每月通讯汇集了来自整个Quarkus社区的文章、视频和观点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>克隆 Git 仓库: `git clone {quickstarts-clone-url}` ，或下载一个 {quickstarts-archive-url}[存档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先决条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pom.xml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>build.gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>build.gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Periodic Tasks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安排周期性任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project. Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要一个新的项目。使用以下命令创建一个新的项目:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这会将以下内容添加到你的构建文件中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package and run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包并运行该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>像往常一样，该应用程序能够使用以下方式进行打包:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also generate the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以通过以下命令生成本地可执行文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide, you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要完成这个指南，你需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GreetingController</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GreetingController</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open your browser to http://localhost:8080/greeting.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的浏览器中打开 http://localhost:8080/greeting 网页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>备注</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Spring guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多 Spring 指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has more Spring compatibility features. See the following guides for more details:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus拥有更多的Spring兼容特性。获取更多细节请参阅以下指南:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下一步做什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using WebSockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebSockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And executed using `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并使用 `java -jar target/quarkus-app/quarkus-run.jar` 命令运行该应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also build the native executable using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以用以下方法构建原生(native)可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在另外一个终端中，运行:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going further</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>进一步探索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置你的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Maven structure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven的结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>描述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发用户界面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `--gradle` or `--gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Grade项目，请添加 `--gradle` 或者 `--gradle-kotlin-dsl` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_For more information about how to install the Quarkus CLI and use it, please refer to xref:cli-tooling.adoc[the Quarkus CLI guide]._</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_关于如何安装并使用Quarkkus CLI并的更多信息，请参考xref:cli-tooling.adoc[Quarkus CLI指南]。_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `-DbuildTool=gradle` or `-DbuildTool=gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Grade项目，请添加 `-DbuildTool=gradle` 或者 `-DbuildTool=gradle-kotlin-dsl` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roughly {prerequisites-time}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大概{prerequisites-time}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roughly 15 minutes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大概15分钟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编辑器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装JDK 11以上版本并正确配置了 `JAVA_HOME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker or Podman)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以工作的容器 (Docker或者Podman)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally the xref:cli-tooling.adoc[Quarkus CLI] if you want to use it</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你愿意的话，还可以选择使用xref:cli-tooling.adoc[Quarkus CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally Mandrel or GraalVM installed and xref:building-native-image.adoc#configuring-graalvm[configured appropriately] if you want to build a native executable (or Docker if you use a native container build)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想构建原生可执行程序，可以选择安装Mandrel或者GraalVM，并xref:building-native-image.adoc#configuring-graalvm[正确配置](或者使用Docker在容器中进行构建)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel or GraalVM installed and xref:building-native-image.adoc#configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以安装Mandrel或者GraalVM，并xref:building-native-image.adoc#configuring-graalvm[正确配置]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Initialization and Termination</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序的初始化和终止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kotlinlang.org/[Kotlin] is a very popular programming language that targets the JVM (amongst other environments). Kotlin has experienced a surge in popularity the last few years making it the most popular JVM language, except for Java of course.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://kotlinlang.org/[Kotlin] 是一种非常流行的基于JVM的编程语言（在其他环境中）。在过去的几年里，Kotlin的受欢迎程度激增，使其成为最受欢迎的JVM语言，当然，除了Java之外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Kotlin as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为使用Kotlin提供了一流的支持，本指南将对此进行讲解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NB: For Gradle project setup please see below, and for further reference consult the guide in the xref:gradle-tooling.adoc[Gradle setup page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意：关于Gradle项目的设置，请见下文，如需进一步参考，请查阅 link:gradle-tooling.html[Gradle设置页面] 的指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new Kotlin project. This can be done using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要一个新的Kotlin项目。这可以通过以下命令来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When adding `kotlin` to the extensions list, the Maven plugin will generate a project that is properly configured to work with Kotlin. Furthermore the `org.acme.ReactiveGreetingResource` class is implemented as Kotlin source code (as is the case with the generated tests).  The addition of `resteasy-reactive-jackson` in the extension list results in importing the RESTEasy Reactive and Jackson extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `kotlin` 添加到扩展列表后，Maven插件将生成一个经过正确配置的项目，以便与Kotlin一起工作。此外， `org.acme.ReactiveGreetingResource` 类会通过kotlin代码来进行实现（与生成的测试一样）。在扩展列表中添加 `resteasy-reactive-jackson` ，就会导入RESTEasy Reactive和Jackson扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ReactiveGreetingResource.kt` looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingResource.kt` 看起来像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to show a more practical example of Kotlin usage we will add a simple link:https://kotlinlang.org/docs/reference/data-classes.html[data class] called `Greeting.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了展示一个更实际的Kotlin使用例子，我们将像这样添加一个简单的 link:https://kotlinlang.org/docs/reference/data-classes.html[数据类] ，叫做 `Greeting.kt` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also update the `ReactiveGreetingResource.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还要这样更新 `ReactiveGreetingResource.kt` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With these changes in place the `/hello` endpoint will reply with a JSON object instead of a simple String.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>经过这些更改， `/hello` 端点将用一个JSON对象而不是一个简单的字符串来响应请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the test pass, we also need to update `ReactiveGreetingResourceTest.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了使测试通过，我们还需要像这样更新 `ReactiveGreetingResourceTest.kt` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated `pom.xml` contains the following modifications compared to its counterpart when Kotlin is not selected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与不选择Kotlin时的对应内容相比，这次生成的 `pom.xml` 包含以下修改：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-kotlin` artifact is added to the dependencies. This artifact provides support for Kotlin in the live reload mode (more about this later on)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-kotlin` 会被添加到依赖项中。这个依赖提供了对实时重载模式下的Kotlin的支持（后面会有更多关于这个的介绍）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `kotlin-stdlib-jdk8` is also added as a dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin-stdlib-jdk8` 也作为依赖被添加进来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `kotlin-maven-plugin` is configured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin-maven-plugin` ，其配置如下。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The important thing to note is the use of the https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] Kotlin compiler plugin.  In order to understand why this plugin is needed, first we need to note that by default all the classes generated from the Kotlin compiler are marked as `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注意的是，这里使用了 link:https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] 的Kotlin编译器插件。为了理解为什么需要这个插件，首先我们需要注意：在默认情况下，所有从Kotlin编译器生成的类都被标记为 `final` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having `final` classes however does not work well with various frameworks that need to create https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[Dynamic Proxies].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，拥有 `final` 类并不能很好地与需要创建 link:https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[动态代理] 的各种框架配合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the `all-open` Kotlin compiler plugin allows us to configure the compiler to *not* mark as `final` classes that have certain annotations. In the snippet above, we have specified that classes annotated with `javax.ws.rs.Path` should not be `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此， `all-open` Kotlin编译器插件允许我们对编译器进行配置，使其 *不* 将有某些注解的类标记为 `final` 。在上面的片段中，我们已经指定了带有 `javax.ws.rs.Path` 注解的类不应该是 `final` 的 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application contains classes annotated with `javax.enterprise.context.ApplicationScoped` for example, then `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` needs to be added as well. Same goes for any class that needs to have a dynamic proxy created at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您的应用程序包含了带有 `javax.enterprise.context.ApplicationScoped` 注解的类，那么也需要添加 `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` 。任何需要在运行时创建动态代理的类也是如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Future versions of Quarkus will configure the Kotlin compiler plugin in a way that will make it unnecessary to alter this configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的未来版本将以无需更改此配置文件的方式来配置Kotlin编译器插件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to the Maven configuration, when using Gradle, the following modifications are required when Kotlin is selected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Maven的配置类似，在使用Gradle时，如果选择了Kotlin，则需要做以下修改：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The all-open Kotlin plugin tells the compiler not to mark as final, those classes with the annotations highlighted (customize as required)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>all-open Kotlin插件告诉编译器不要把那些有注解的类标记为final类（可以按需自定义） </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native-image, the use of http (or https) protocol(s) must be declared</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用native-image时，必须声明使用http（或https）协议</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example configuration follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是一个配置实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kotlin plugin version needs to be specified.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要指定Kotlin插件的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The all-open configuration required, as per Maven guide above</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>按照上面的Maven指南，需要配置all-open插件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live reload</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实时重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for live reloading changes made to source code. This support is also available to Kotlin, meaning that developers can update their Kotlin source code and immediately see their changes reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了对源代码的实时重载修改的支持。这种支持也适用于Kotlin，这意味着开发者可以更新他们的Kotlin源代码，并立即看到代码更改带来的反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see this feature in action, first execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要体验到这个功能的作用，首先要执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When executing an HTTP GET request against `http://localhost:8080/hello`, you see a JSON message with the value `hello` as its `message` field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当执行一个对 `http://localhost:8080/hello`  的HTTP GET请求时，您会看到一个JSON消息，其 `message` 字段的值是 `hello` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now using your favorite editor or IDE, update `ReactiveGreetingResource.kt` and change the `hello` method to the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在使用您喜欢的编辑器或IDE，更新 `ReactiveGreetingResource.kt` ，并将 `hello` 方法改为如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now execute an HTTP GET request against `http://localhost:8080/hello`, you should see a JSON message with the value `hi` as its `message` field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当您现在执行一个对 `http://localhost:8080/hello` 的HTTP GET请求时，您应该会看到一个JSON消息，其 `message` 字段的值是 `hi` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing to note is that the live reload feature is not available when making changes to both Java and Kotlin source that have dependencies on each other. We hope to alleviate this limitation in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一点需要注意的是，当对相互有依赖关系的Java和Kotlin源代码进行修改时，实时重载功能是不可用的。我们希望在未来能缓解这一限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and executed with `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并可以使用 `java -jar target/quarkus-app/quarkus-run.jar`  来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `com.fasterxml.jackson.module:jackson-module-kotlin` dependency and the `quarkus-jackson` extension (or one of the `quarkus-resteasy-jackson` or `quarkus-resteasy-reactive-jackson` extensions) have been added to the project, then Quarkus automatically registers the `KotlinModule` to the `ObjectMapper` bean (see xref:rest-json.adoc#jackson[this] guide for more details).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `com.fasterxml.jackson.module:jackson-module-kotlin` 依赖和 `quarkus-jackson` 扩展（或 `quarkus-resteasy-jackson` 或 `quarkus-resteasy-reactive-jackson` 其中之一）已经被添加到项目中，那么 Quarkus 会自动将 `KotlinModule` 注册到 `ObjectMapper` Bean 中（更多细节请参见 link:rest-json.html#jackson[这篇指南] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Kotlin data classes with `native-image` you may experience serialization errors that do not occur with the `JVM` version, despite the Kotlin Jackson Module being registered. This is especially so if you have a more complex JSON hierarchy, where an issue on a lower node causes a serialization failure. The error message displayed is a catch-all and typically displays an issue with the root object, which may not necessarily be the case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用Kotlin数据类与 `native-image`  时，尽管Kotlin Jackson模块已被注册，但您可能会遇到JVM版本中不会出现的序列化错误。特别是如果您有一个更复杂的JSON层次结构，低层节点上的问题导致序列化失败。显示的错误消息是一条全面的错误消息，其通常会显示根对象引发了这个问题，但情况可能并非如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ensure full-compability with `native-image`, it is recommended to apply the Jackson `@field:JsonProperty("fieldName")` annotation, and set a nullable default, as illustrated below. You can automate the generation of Kotlin data classes for your sample JSON using Intellij plugins (such as JSON to Kotlin Class), and easily enable the Jackson annotation and select nullable parameters as part of the auto-code generation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了确保与 `native-image` 的完全兼容性，建议使用Jackson `@field:JsonProperty("fieldName")` 注解，并设置一个空默认值，如下图所示。您可以使用Intellij插件（如JSON to Kotlin Class）为您的样例JSON自动生成Kotlin数据类，并轻松启用Jackson注解和选择并选择可为空的参数，作为自动代码生成的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When working with the `quarkus-kubernetes` extension and have Kotlin classes bound to CustomResource definitions (like you do for building operators), you need to be aware that the underlying Fabric8 Kubernetes Client uses its own static Jackson `ObjectMapper` s, which can be configured as follows with the `KotlinModule`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `quarkus-kubernetes` 扩展并让Kotlin类绑定到CustomResource定义时（就像您在构建operator时一样），您需要注意底层的Fabric8 Kubernetes客户端使用它自己的静态Jackson `ObjectMapper` 对象，您可以这样为其配置 `KotlinModule` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Please test this carefully on compilation to native images and fallback to Java-compatible Jackson bindings if you experience problems._</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_请在编译到native-image时仔细测试，如果遇到问题，请退回到与Java兼容的Jackson binding。_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI @Inject with Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kotlin的CDI @Inject</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin reflection annotation processing differs from Java.  You may experience an error when using CDI @Inject such as: "kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin的反射注解处理与Java不同。在使用CDI @Inject时，您可能会遇到错误，比如。"kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the example below, this can be easily solved by adapting the annotation, adding @field: Default, to handle the lack of a @Target on the Kotlin reflection annotation definition.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在下面的示例中，通过调整注解，添加@field:Default来处理Kotlin反射注解定义中缺少@Target，就可以很容易地解决这一问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin requires a @field: xxx qualifier as it has no @Target on the annotation definition. Add @field: xxx in this example. @Default is used as the qualifier, explicitly specifying the use of the default bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin需要一个@field:xxx 限定符，因为它在注解定义上没有@Target。在此示例中添加@field: xxx 。@Default作为限定符，显式指定使用默认bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, prefer the use of constructor injection which works without modification of the Java examples, increases testability and complies best to a Kotlin programming style.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，更喜欢使用构造函数注入，它可以在不修改Java示例的情况下工作，提高可测试性，并且最符合Kotlin编程风格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Microsoft Azure Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到微软Azure云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Glossary</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>词汇表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是文件和网站中首选术语的集合。为了保持一致性，请保持在这些术语范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Live coding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>preferred term for the VM creating native executable. No space.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虚拟机创建原生可执行文件的首选术语。没有空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>non-preferred. Exclude.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非优先考虑的。不包括。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 容器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>imperative and reactive. 'Nuff said.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式和响应式。这就是最有名的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Best of breed frameworks and standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 最好的类库和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用结构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get it running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让它运行起来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling the application to a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将应用程序编译为原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the native executable in a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将原生可执行文件打包到一个容器中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>调试原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将 xref:getting-started.adoc[入门指南]中开发的应用程序作为输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.  There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.  The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个原生可执行文件需要使用GraalVM的发行版。有三个发行版：Oracle GraalVM社区版（CE）、Oracle GraalVM企业版（EE）和Mandrel。Oracle和Mandrel发行版之间的区别如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.  Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel是Oracle GraalVM CE的一个下游发行版。Mandrel的主要目标是提供一种方法来构建专门为支持Quarkus而设计的原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base, with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.  They support the same capabilities to build native executables as Oracle GraalVM CE, with no significant changes to functionality.  Notably, they do not include support for polyglot programming.  The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.  These exclusions also mean Mandrel offers a considerable reduction in its distribution size when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel版本的代码库来自于上游的Oracle GraalVM CE代码库，只做了一些小的改动，但也有一些重要的对于Quarkus本地应用程序来说是没有必要的排除项。它们支持与Oracle GraalVM CE相同的构建原生可执行文件的能力，在功能上没有重大变化。值得注意的是，它们不包括对多语言编程的支持。之所以排除这些功能，是为了给大多数Quarkus用户提供更好的支持水平。与Oracle GraalVM CE/EE相比，这些不包括的内容也意味着Mandrel发布的软件包大小大大减小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel的构建方式与Oracle GraalVM CE略有不同，它使用的是标准的OpenJDK项目。这意味着它不能从Oracle对用于构建他们自己的GraalVM下载的OpenJDK版本添加的一些小的增强功能中获益。这些增强功能被省略了，因为上游的OpenJDK并不管理它们，也无法担保。在涉及到一致性和安全性时，这一点尤其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is recommended for building native executables that target Linux containerized environments.  This means that Mandrel users are encouraged to use containers to build their native executables.  If you are building native executables for macOS, you should consider using Oracle GraalVM instead, because Mandrel does not currently target this platform.  Building native executables directly on bare metal Linux or Windows is possible, with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel被推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着，我们鼓励Mandrel用户使用容器来构建他们的原生可执行文件。如果你要为macOS构建本地可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前不针对这个平台。直接在裸机Linux或Windows上构建原生可执行文件是可能的，详情可参见 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel发行版] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the xref:getting-started.adoc[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 xref:getting-started.adoc[入门指南] 中开发的应用程序代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native compilation in C</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持C语言的原生编译</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does having a working C developer environment mean?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拥有一个C语言工作开发者环境意味着什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Linux上，你将需要GCC，以及glibc和zlib头文件。常见发行版的例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XCode provides the required dependencies on macOS:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>XCode在macOS上提供了必要的依赖性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上，你将需要安装 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++构建工具]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. There is an explanation of how to do this at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你无法安装GraalVM，你可以使用多阶段Docker构建在嵌入GraalVM的Docker容器内运行Maven。本指南最后有关于如何操作的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version {graalvm-version} is required. Using the community edition is enough.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>版本 {graalvm-version} 是必需的。使用社区版就可以了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你还没有安装 GraalVM。那么你有几个选择：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate archive from &lt;https://github.com/graalvm/mandrel/releases&gt; or &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 &lt;https://github.com/graalvm/mandrel/releases&gt; 或 &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt; 下载相应的归档文件，然后像对待其他 JDK 一样将其解压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://sdkman.io/jdks#Oracle[sdkman], https://github.com/graalvm/homebrew-tap[homebrew], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用特定平台的安装工具，如 https://sdkman.io/jdks#Oracle[sdkman] 、https://github.com/graalvm/homebrew-tap[homebrew] 或 https://github.com/ScoopInstaller/Java[scoop] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置运行环境。例如将 `GRAALVM_HOME` 环境变量设置为GraalVM的安装目录，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS (not supported by Mandrel), point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在macOS上（Mandrel不支持），将该变量指向 `Home` 子目录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will have to go through the Control Panel to set your environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上，您将不得不通过控制面板来设置你的环境变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing via scoop will do this for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过scoop安装将为你做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Only for Oracle GraalVM CE/EE) Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(仅适用于Oracle GraalVM CE/EE）使用 `gu install` 安装 `native-image` 工具：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some previous releases of GraalVM included the `native-image` tool by default.  This is no longer the case; it must be installed as a second step after GraalVM itself is installed. Note: there is an outstanding issue xref:graal-and-catalina[using GraalVM with macOS Catalina].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM以前的一些版本默认包括 `native-image` 工具。现在已经不是这样了，它必须在安装完GraalVM本身后作为第二步来安装。注意：一个已知的问题 xref:graal-and-catalina[在MacOS Catalina上使用GraalVM]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(可选）将 `JAVA_HOME` 环境变量设置为GraalVM的安装目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Add the GraalVM `bin` directory to the path</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(可选）将GraalVM `bin` 目录添加到路径中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues using GraalVM with macOS Catalina</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在MacOS Catalina上使用GraalVM的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM binaries are not (yet) notarized for macOS Catalina as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `gu`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM的二进制文件（尚未）对macOS Catalina进行认证，正如这个 https://github.com/oracle/graal/issues/1724[GralVM问题]中所报告的那样。这意味着您在使用 `gu` 时可能会看到以下错误：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令递归删除GraalVM安装目录上的 `com.apple.quarantine` 扩展属性，作为一种解决方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地打包应用。不过您还可以直接进入完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `getting-started` 目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制作一个原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们应用程序的原生可执行文件将包含应用程序代码、所需的库、Java API和一个缩小版的虚拟机。较小的虚拟机基础提高了应用程序的启动时间和最小的磁盘占用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:native-executable-process.png[Creating a native executable]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:native-executable-process.png[创建原生可执行文件]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经从前面的教程中生成了应用程序，你可以在 `pom.xml` ，找到以下 _profile_：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.  Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `&lt;quarkus.native.additional-build-args&gt;` 属性为 `native-image` 命令提供自定义选项。多个选项可以用逗号隔开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一种做法是在你的 `application.properties` ，填写 `quarkus.native.additional-build-args` 配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about how to configure the native image building process in the &lt;&lt;configuration-reference&gt;&gt; section below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在下面的 &lt;&lt;configuration-reference&gt;&gt; 部分找到关于如何配置原生镜像构建过程的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as this allows native image tests to also be run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用profile是因为，你很快就会看到，打包原生可执行文件需要 _few_ 分钟。你可以在命令行中把 -Dquarkus.package.type=native 作为一个属性，但是最好是使用一个profile，因为这可以使原生镜像测试也被运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下方法创建一个原生可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues with packaging on Windows</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上打包的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At `x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在打包之前，必须首先初始化 Microsoft Native Tools for Visual Studio。你可以通过启动与Visual Studio Build Tools 一起安装的 `x64 Native Tools Command Prompt` 来做到这一点。在 `x64 Native Tools Command Prompt` ，你可以导航到你的项目文件夹并运行 `mvnw package -Pnative` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another solution is to write a script to do this for you:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一个解决方案是写一个脚本来为您做这件事：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.  You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了常规文件外，该构建还产生了 `target/getting-started-1.0.0-SNAPSHOT-runner` 。你可以用以下方式运行它： `./target/getting-started-1.0.0-SNAPSHOT-runner` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.  To produce a native executable, this means that the `--enable-preview` flag needs to be passed to the underlying native image invocation.  You can do so by prepending the flag with `-J` and passing it as additional native build argument: `-Dquarkus.native.additional-build-args=-J--enable-preview`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依赖于预览功能的Java代码需要特别注意。为了产生一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给底层的原生镜像调用。你可以这样做，用 `-J` 作为标志的前缀，并将其作为额外的原生构建参数传递：`-Dquarkus.native.additional-build-args=-J--enable-preview`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制作一个原生可执行文件可能会导致一些问题，因此，针对在原生文件中运行的应用程序运行一些测试也是一个好主意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file, the `native` profile contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `pom.xml` 文件中， `native` 配置文件包含：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这指示 failsafe-maven-plugin 运行集成测试，并指出生成的原生可执行文件的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，打开 `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java` 。它包含了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.  The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用另一个测试运行器，在测试前从原生文件启动应用程序。使用 _Failsafe Maven Plugin_ 中配置的 `native.image.path` 系统属性检索该可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We extend our previous tests, but you can also implement your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们扩展了之前的测试，但您也可以实现自己的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `NativeGreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要查看针对原生可执行文件运行 `NativeGreetingResourceIT` ，请用 `./mvnw verify -Pnative`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会等待60秒的时间来启动原生镜像，然后本地测试自动失败。这个持续时间可以使用 `quarkus.test.wait-time` 系统属性来改变。例如，要增加持续时间到300秒，使用： `./mvnw verify -Pnative -Dquarkus.test.wait-time=300` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the future, `@NativeImageTest` will be deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在未来， `@NativeImageTest` 将被弃用，取而代之的是`@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 xref:getting-started-testing.adoc#quarkus-integration-test[测试指南]中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, native tests runs using the `prod` profile.  This can be overridden using the `quarkus.test.native-image-profile` property.  For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.  Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  However, don't forget that when the native executable is built the `prod` profile is enabled.  So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，原生测试使用 `prod` 配置文件运行。这可以用 `quarkus.test.native-image-profile` 属性来覆盖。例如，在你的 `application.properties` 文件中，添加： `quarkus.test.native-image-profile=test` 。或者，你可以用以下方式运行你的测试。 `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` 。然而，不要忘记当原生可执行文件被构建时， `prod` 配置文件被启用。因此，你通过这种方式启用的配置文件必须与生成的可执行文件兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.  To test a native executable, this means that the `--enable-preview` flag needs to be passed to the Surefire plugin.  Adding `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` to its `configuration` section is one way to do so.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依赖于预览功能的Java代码需要特别注意。为了测试一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给Surefire插件。将 `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` 添加到其 `configuration` 片段是一种可行方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excluding tests when running as a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为原生可执行文件运行时排除测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running tests this way, the only things that actually run natively are you application endpoints, which you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当以这种方式运行测试时，唯一真正在本地运行的是你的应用程序端点，你只能通过HTTP调用来测试。你的测试代码实际上并不在本地运行，所以如果你测试的代码不调用你的HTTP端点，把它们作为本地测试的一部分运行可能不是一个好主意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你像我们上面建议的那样，在JVM和原生执行之间共享你的测试类，你可以用 `@DisabledOnNativeImage` 注解标记某些测试，以便只在JVM上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing an existing native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试一个现有的原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以针对已经建立的原生可执行文件重新运行测试。要做到这一点，运行 `./mvnw test-compile failsafe:integration-test` 。这将发现现有的原生镜像，并使用故障安全系统对其运行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果进程由于某种原因找不到原生镜像，或者你想测试一个已经不在目标目录中的原生镜像，你可以用 `-Dnative.image.path=` 系统属性指定可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a Linux executable without GraalVM installed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在没有安装GraalVM的情况下创建一个Linux可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在进一步行动之前，请确保有一个工作的容器运行环境（Docker或podman）。如果你在Windows上使用Docker，你应该在Docker Desktop文件共享设置中共享你的项目的驱动器，并重新启动Docker Desktop。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice to install as little software as possible).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很多时候，人们只需要为他们的Quarkus应用程序创建一个原生Linux可执行文件（例如，为了在容器化环境中运行），并希望避免安装适当的GraalVM版本来完成这项麻烦任务（例如，在CI环境中，通常的做法是尽可能少地安装软件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.  The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为此，Quarkus提供了一个非常方便的方法，通过利用容器运行时（如Docker或podman）来创建一个原生Linux可执行文件。完成这项任务的最简单方法是执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus automatically detects the container runtime.  If you want to explicitely select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在默认情况下，Quarkus会自动检测容器的运行时。如果你想明确地选择容器的运行时，你可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Docker:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Docker：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For podman:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于podman：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are normal Quarkus config properties, so if you always want to build in a container it is recommended you add these to your `application.properties` in order to avoid specifying them every time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些是标准的Quarkus配置属性，所以如果你总是想在容器中构建，建议你把这些添加到你的 `application.properties` ，以避免每次都指定它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you see the following invalid path error for your application JAR when trying to create a native executable using a container build, even though your JAR was built successfully, you're most likely using a remote daemon for your container runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在试图使用容器构建创建原生可执行文件时，尽管你的JAR已经成功构建，仍看到应用程序JAR出现以下无效路径错误，您很可能为容器运行时使用了一个远程守护进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, use the parameter `-Dquarkus.native.remote-container-build=true` instead of `-Dquarkus.native.container-build=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，使用参数 `-Dquarkus.native.remote-container-build=true` ，而不是 `-Dquarkus.native.container-build=true` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason for this is that the local build driver invoked through `-Dquarkus.native.container-build=true` uses volume mounts to make the JAR available in the build container, but volume mounts do not work with remote daemons. The remote container build driver copies the necessary files instead of mounting them. Note that even though the remote driver also works with local daemons, the local driver should be preferred in the local case because mounting is usually more performant than copying.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原因是通过 `-Dquarkus.native.container-build=true` 调用的本地构建驱动程序使用卷挂载来使 JAR 在构建容器中可用，但卷挂载对远程守护程序不起作用。远程容器构建驱动程序复制必要的文件，而不是挂载它们。请注意，即使远程驱动程序也能与本地守护进程一起工作，但在本地情况下，本地驱动程序应该是首选，因为挂载通常比复制性能更高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building with Mandrel requires a custom builder image parameter to be passed additionally:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Mandrel构建需要额外传递一个自定义的构建器镜像参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.  It is highly recommended to use the floating tag, so that your builder image remains up-to-date and secure.  If you absolutely must, you may hard-code to a specific tag (see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags), but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，上述命令指向的是一个浮动标签。我们强烈建议你使用浮动标签，这样你的构建器镜像就能保持最新和安全。如果你一定要硬编码到一个特定的标签（参见 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[这里] 的可用标签），但要注意，你不会得到安全更新，而且这不被支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个容器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the container-image extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用容器-镜像扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，从你的Quarkus应用程序中创建一个容器镜像的最简单方法是利用容器镜像扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果这些扩展之一是存在的，那么为原生可执行文件创建一个容器镜像基本上就是执行一个命令的问题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.native.container-build=true` 允许在不安装GralVM的情况下创建一个Linux可执行文件（只有在你没有安装GralVM或者你的本地操作系统不是Linux的情况下才需要）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.container-image.build=true` 指示Quarkus使用最终的应用程序工件（在本例中是原生可执行文件）创建一个容器镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the xref:container-image.adoc[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节见 xref:container-image.adoc[容器镜像指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually using the micro base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手动使用微基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.  However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用Quarkus Maven插件生成的JAR在容器中运行该应用程序。然而，在本节中我们将重点讨论使用生成的原生可执行文件创建一个容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).  However, as a container may not use the same _executable_ format as the one produced by your operating system, we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in &lt;&lt;#container-runtime,this section&gt;&gt;):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用本地GraalVM安装时，原生可执行文件的目标是您的本地操作系统（Linux、macOS、Windows等）。然而，由于容器可能不使用与操作系统相同的 _executable_ 格式，我们将指示Maven构建通过利用容器运行时（ 如 &lt;&lt;#container-runtime,this section&gt;&gt; 所述）来生成可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native-micro` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>产生的可执行文件将是一个64位的Linux可执行文件，所以取决于您的操作系统，它可能不再能够运行。然而，这不是一个问题，因为我们要把它复制到一个容器中。生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native-micro` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Micro Image?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么是Quarkus微镜像？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Micro Image is a small container image providing the right set of dependencies to run your native application.  It is based on https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro].  This base image has been tailored to work perfectly in containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 微镜像是一个小型的容器镜像，为运行你的原生应用程序提供了正确的依赖性集合。它是基于 https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro] 的。这个基础镜像已经被定制为在容器中完美运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI images on:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在这里阅读更多关于UBI镜像的内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UBI images can be used without any limitations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UBI镜像可以不受任何限制地使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:quarkus-runtime-base-image.adoc[This page] explains how to extend the `quarkus-micro` image when your application has specific requirements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:quarkus-runtime-base-image.adoc[此页] 解释了当你的应用有特殊要求时，如何扩展 `quarkus-micro` 镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, if you didn't delete the generated native executable, you can build the docker image with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，如果你没有删除生成的原生可执行文件，可以用以下方法构建docker镜像：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，用以下方式运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually using the minimal base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手工使用最小基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project generation has also provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目也在 `src/main/docker` 目录中提供了一个 `Dockerfile.native` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The UBI minimal image is bigger than the micro one mentioned above.  It contains more utilities such as the `microdnf` package manager.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UBI最小镜像比上面提到的微镜像要大。它包含更多的实用程序，如 `microdnf` 软件包管理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a multi-stage Docker build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用多阶段的Docker构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven or Gradle, but it requires you to have created the native executable first.  In addition, this native executable must be a Linux 64 bits executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上一节向你展示了如何使用Maven或Gradle构建原生可执行文件，但这需要你先创建原生可执行文件。此外，这个原生可执行文件必须是Linux 64位可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may want to build the native executable directly in a container without having a final container containing the build tools.  That approach is possible with a multi-stage Docker build:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能想直接在一个容器中构建原生可执行文件，而不需要一个包含构建工具的最终容器。这种方法可以通过多阶段的Docker构建来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first stage builds the native executable using Maven or Gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一阶段使用Maven或Gradle构建原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second stage is a minimal image copying the produced native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第二阶段是复制产生了原生可执行文件的最小镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a multi-stage build can be achieved as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样的多阶段构建可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Maven:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Maven构建的Docker文件例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This multi-stage Docker build copies the Maven wrapper from the host machine.  The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.  It avoids having to create a base image with Maven and Gradle.  To provision the Maven Wrapper in your project, use: `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.0:wrapper`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种多阶段Docker构建从主机上复制Maven包装器。Maven包装器（或Gradle包装器）是提供特定版本Maven/Gradle的一种便捷方式。它避免了用Maven和Gradle创建一个基础镜像。要在项目中配置Maven包装器，请使用： `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.0:wrapper` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将此文件保存在 `src/main/docker/Dockerfile.multistage` ，因为它不包括在开始快速入门中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Gradle:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Gradle构建的Docker文件例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在项目中使用Gradle，你可以使用这个Docker文件例子。将其保存在 `src/main/docker/Dockerfile.multistage` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory. As we plan to build inside a container, we need to copy the `src` directory. Thus, edit your `.dockerignore` and update the content.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在启动我们的Docker构建之前，我们需要更新默认的 `.dockerignore` 文件，因为它过滤了除 `target` 目录之外的所有内容。由于我们计划在容器内构建，我们需要复制 `src` 目录。因此，编辑你的 `.dockerignore` ，并更新内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And, finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，用以下方式运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的原生可执行文件需要SSL支持，你可以轻松地在Docker镜像中包含必要的库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see xref:native-and-ssl.adoc#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息请参见 xref:native-and-ssl.adoc#working-with-containers[我们的使用SSL与原生可执行文件指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Mandrel instead of GraalVM CE, update the `FROM` clause to: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build`.  `$TAG` can be found on the https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel Images Tags page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用Mandrel而不是GraalVM CE，请将 `FROM` 子句更新为: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build` 。 `$TAG` 可以在 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel镜像标签页]上找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a Distroless base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用无发行版基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distroless image support is experimental.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>无发行版支持是试验性的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are looking for small container images, the https://github.com/GoogleContainerTools/distroless[distroless] approach reduces the size of the base layer.  The idea behind _distroless_ is the usage of a single and minimal base image containing all the requirements, and sometimes even the application itself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在寻找小型的容器镜像，https://github.com/GoogleContainerTools/distroless[无发行] 的方法可以减少基础层的大小。 _distroless_ 背后的想法是使用一个单一和最小的基础镜像包含所有的需求，有时甚至是应用程序本身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a distroless base image that you can use in your `Dockerfile`.  You only need to copy your application, and you are done:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个无发行版的基础镜像，可以用于你的 `Dockerfile` 。你只需要复制你的应用程序，就可以了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides the `quay.io/quarkus/quarkus-distroless-image:1.0` image.  It contains the required packages to run a native executable and is only **9Mb**.  Just add your application on top of this image, and you will get a tiny container image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了 `quay.io/quarkus/quarkus-distroless-image:1.0` 镜像。它包含了运行原生可执行文件所需的软件包，并且只有 *9Mb* 。只要在这个镜像上添加你的应用程序，你就会得到一个很小的容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distroless images should not be used in production without rigorous testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在没有经过严格测试的情况下，不应该在生产中使用无发行版镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable compression</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生可执行文件压缩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus can compress the produced native executable using UPX.  More details on xref:./upx.adoc[UPX Compression documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus可以使用UPX压缩产生的原生可执行文件。更多细节见 xref:./upx.adoc[UPX压缩文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In certain circumstances, you may want to build the native image in a separate step.  For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.  For this use case, you can set the `quarkus.package.type=native-sources`.  This will execute the java compilation as if you would have started native compilation (`-Pnative`), but stops before triggering the actual call to GraalVM's `native-image`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，你可能想在一个单独的步骤中构建本地镜像。例如，在CI/CD管道中，你可能希望有一个步骤来生成用于原生镜像的源，另一个步骤是使用这些源来实际构建原生可执行文件。对于这种用例，你可以设置 `quarkus.package.type=native-sources` 。这将执行java编译，就像你已经开始原生编译一样（ `-Pnative` ），但在触发对GraalVM的 `native-image` 的实际调用之前停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After compilation has finished, you find the build artifact in `target/native-sources`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译完成后，你可以在 `target/native-sources` 找到构建工件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the output above one can see that, in addition to the produced jar file and the associated lib directory, a text file named `native-image.args` was created.  This file holds all parameters (including the name of the JAR to compile) to pass along to GraalVM's `native-image` command.  If you have GraalVM installed, you can start the native compilation by executing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从上面的输出可以看出，除了生成的jar文件和相关的lib目录外，还创建了一个名为 `native-image.args` 的文本文件。这个文件包含了所有的参数（包括要编译的JAR的名字），以及传递给GraalVM的 `native-image` 命令。如果你已经安装了GraalVM，你可以通过执行以下命令开始本地编译：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The process for Gradle is analogous.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle的过程是类似的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the build process in a container is also possible:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个容器中运行构建过程也是可能的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mount the host's directory `target/native-image` to the container's `/work`. Thus, the generated binary will also be written to this directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将主机的目录 `target/native-image` 挂载到容器的 `/work` 。因此，生成的二进制文件也将被写入这个目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the working directory to `/work`, which we have mounted in &lt;1&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将工作目录切换到 `/work` ，我们已经在&lt;1&gt;中挂载了这个目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` docker image introduced in &lt;&lt;#multistage-docker,Using a multi-stage Docker build&gt;&gt; to build the native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 &lt;&lt;#multistage-docker,Using a multi-stage Docker build&gt;&gt; 中介绍的 `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` docker镜像来构建原生镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Call `native-image` with the content of file `native-image.args` as arguments. We also supply an additional argument to limit the process's maximum memory to 4 Gigabytes (this may vary depending on the project being built and the machine building it).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以文件 `native-image.args` 的内容为参数调用 `native-image` 。我们还提供了一个额外的参数，将进程的最大内存限制在4G字节（这可能取决于正在构建的项目和构建它的机器）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are running on a Windows machine, please keep in mind that the binary was created within a Linux docker container.  Hence, the binary will not be executable on the host Windows machine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是在Windows机器上运行，请记住，二进制文件是在Linux docker容器中创建的。因此，二进制文件在Windows主机上是无法执行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A high level overview of what the various steps of a CI/CD pipeline would look is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下是对CI/CD管道的各个步骤的高度概述：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register the output of the step executing `./mvnw ...` command (i.e. directory `target/native-image`) as a build artifact,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将执行 `./mvnw …​` 命令的步骤的输出（即目录 `target/native-image` ）注册为构建工件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Require this artifact in the step executing the `native-image ...` command, and</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在执行 `native-image …​` 命令的步骤中需要这个工件，并且</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register the output of the step executing the `native-image ...` command (i.e. files matching `target/*runner`) as build artifact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将执行 `native-image …​` 命令的步骤的输出（即匹配 `target/*runner` 的文件）注册为构建工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The environment executing step `1` only needs Java and Maven (or Gradle) installed, while the environment executing step `3` only needs a GraalVM installation (including the `native-image` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>执行步骤 `1` 的环境只需要安装Java和Maven（或Gradle），而执行步骤 `3` 的环境只需要安装GralVM（包括 `native-image` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on what the final desired output of the CI/CD pipeline is, the generated binary might then be used to create a container image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>根据CI/CD管道的最终期望输出，生成的二进制文件可能被用来创建一个容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development, macOS is not supported).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Oracle GraalVM 20.2或Mandrel 20.1开始，可以为Linux环境生成原生可执行文件的调试符号（Windows支持仍在开发中，不支持macOS）。这些符号可用于用工具调试原生可执行文件，如 `gdb` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols, add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.  You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要生成调试符号，在生成原生可执行文件时添加 `-Dquarkus.native.debug.enabled=true` 标志。你将在原生可执行文件旁边的 `.debug` 文件中找到原生可执行文件的调试符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.debug` 文件的生成取决于 `objcopy` 。在常见的Linux发行版上，你将需要安装 `binutils` 包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `objcopy` is not available debug symbols are embedded in the executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当被嵌入到可执行文件中的 `objcopy` 调试符号不可用时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols, setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.  This source cache is useful for native debugging tools, to establish the link between the symbols and matching source code.  It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了调试符号外，设置 `-Dquarkus.native.debug.enabled=true` 标志会生成一个源文件缓存，用于生成原生可执行文件时解决的任何JDK运行时类、GraalVM类和应用程序类。这个源码缓存对原生调试工具很有用，可以在符号和匹配的源代码之间建立联系。在调试本原生执行文件时，它提供了一种方便的方法，使调试器/IDE仅能获得必要的源文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code, are not added to the source cache by default.  To include those, make sure you invoke `mvn dependency:sources` first.  This step is required in order to pull the sources for these dependencies, and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第三方jar依赖的源，包括Quarkus源代码，默认情况下不会被添加到源缓存中。要包括这些，请确保你先调用 `mvn dependency:sources` 。这一步是必须的，以便拉出这些依赖的源代码，并将其包含在源代码缓存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source cache is located in the `target/sources` folder.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>源缓存位于 `target/sources` 文件夹中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If running `gdb` from a different directory than `target`, then the sources can be loaded by running:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果从与 `target` 不同的目录下运行 `gdb` ，那么可以通过运行源代码加载：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the `gdb` prompt.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `gdb` 提示中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or start `gdb` with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或这样运行 `gdb` 命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a more detailed guide about debugging native images please refer to the xref:native-reference.adoc[Native Reference Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于调试原生镜像的更详细指南，请参考 xref:native-reference.adoc[原生参考指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有很多不同的配置选项可以影响原生可执行文件的生成方式。这些都是在 `application.properties` ，与其他配置属性相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties are shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些属性显示如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.  It provides an application exhibiting a swift startup time and consuming less memory.  However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何为应用程序创建原生(二进制)可执行文件。它提供了一个具备快速启动时间和消耗更少内存的应用程序。然而，还有更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the xref:deploying-to-kubernetes.adoc[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议继续阅读 xref:deploying-to-kubernetes.adoc[部署到Kubernetes和OpenShift]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入门指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenTracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenTracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OpenTracing来为交互式网络应用程序提供分布式跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring Performance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>衡量性能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate ORM and JPA</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Hibernate ORM和JPA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started With Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Reactive_ is a set of principles to build robust, efficient, and concurrent applications and systems.  These principles let you handle more load than traditional approaches while using the resources (CPU and memory) more efficiently while also reacting to failures gracefully.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_Reactive_ 是一组用于构建健壮、高效且并发的应用程序和系统的原则。 这些原则使您可以处理比传统方法更多的负载，同时更有效地使用资源（CPU 和内存），同时还可以优雅地对故障做出反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is a _Reactive_ framework.  Since the beginning, _Reactive_ has been an essential tenet of the Quarkus architecture.  It includes many reactive features and offers a broad ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个 _Reactive_ 框架。 从一开始，_Reactive_ 就一直是Quarkus架构的基本原则。 它包括许多反应式功能，并提供广泛的生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is not an in-depth article about what _Reactive_ is and how Quarkus enables reactive architectures.  If you want to read more about these topics, refer to the xref:quarkus-reactive-architecture.adoc[Reactive Architecture guide], which provides an overview of the Quarkus reactive ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南不是一篇关于 _Reactive_ 是什么以及Quarkus如何实现响应式架构的深入文章。 如果你想阅读更多关于这些主题的信息，请参考 xref:quarkus-reactive-architecture.adoc[响应式架构指南]，它提供了Quarkus响应式生态系统的概述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will get you started with some reactive features of Quarkus.  We are going to implement a simple CRUD application.  Yet, unlike in the xref:hibernate-orm-panache.adoc[Hibernate with Panache guide], it uses the reactive features of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将带您开始了解Quarkus的一些响应式功能。 我们将实现一个简单的 CRUD 应用程序。 这部分与 xref:hibernate-orm-panache.adoc[Hibernate与Panache指南]不同，它使用了Quarkus的响应式功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will help you with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将帮助您：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping a reactive CRUD application with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Quarkus 引导响应式 CRUD 应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate Reactive with Panache to interact with a database in a reactive fashion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 Hibernate Reactive 与 Panache 结合使用，以响应式方式与数据库进行交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RESTEasy Reactive to implement HTTP API while enforcing the reactive principle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RESTEasy Reactive 实现 HTTP API，同时强制执行响应式原则</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and Running the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包和运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Verify that Maven is using the Java version you expect.  If you have multiple JDKs installed, make sure Maven is using the expected one.  You can verify which JDK Maven uses by running `mvn --version.`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>验证Maven正在使用您期望的Java版本。如果安装了多个JDK，请确保Maven使用的是适当的版本。你可以通过运行 `mvn --version` 来验证Maven使用的是哪个JDK</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative vs. Reactive: a question of threads</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式与响应式：线程的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, in this guide, we are going to implement a reactive CRUD application.  But you may wonder what the differences and benefits are in comparison to the traditional and imperative model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，在本指南中，我们将实现一个响应式CRUD应用程序。但您可能想知道，与传统的、指令式的模式相比，它有什么不同和好处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand the contrast, we need to explain the difference between the reactive and imperative execution models.  It's essential to comprehend that _Reactive_ is not just a different execution model, but that distinction is necessary to understand this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了更好地理解这种对比，我们需要解释响应式执行模型和指令式执行模型之间的区别。理解 _Reactive_ 不仅仅是一种不同的执行模型是必要的，而且这一区别对于理解本指南是必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the traditional and imperative approach, frameworks assign a thread to handle the request.  So, the whole processing of the request runs on this worker thread.  This model does not scale very well.  Indeed, to handle multiple concurrent requests, you need multiple threads; and so your application concurrency is constrained by the number of threads.  In addition, these threads are blocked as soon as your code interacts with remote services.  So, it leads to inefficient usage of the resources, as you may need more threads, and each thread, as they are mapped to OS threads, has a cost in terms of memory and CPU.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在传统的指令式方法中，框架分配一个线程来处理请求。因此，请求的整个处理都运行在这个工作线程上。这个模型的扩展性不太好。事实上，要处理多个并发请求，你需要多个线程。因此，应用程序的并发性受到线程数量的限制。此外，只要您的代码与远程服务交互，这些线程就会被阻塞。因此，这会导致资源的低效使用，因为您可能需要更多的线程，而每个线程在映射到OS线程时，在内存和CPU方面都有成本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the other side, the reactive model relies on non-blocking I/Os and a different execution model.  Non-blocking I/O provides an efficient way to deal with concurrent I/O.  A minimal amount of threads called I/O threads, can handle many concurrent I/O.  With such a model, request processing is not delegated to a worker thread but uses these I/O threads directly.It saves memory and CPU as there is no need to create worker threads to handle the requests.  It also improves the concurrency as it removes the constraint on the number of threads.  Finally, it also improves response time as it reduces the number of thread switches.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一方面，响应式模型依赖于非阻塞 I/O和不同的执行模型。非阻塞I/O提供了一种处理并发I/O的有效方法。最小数量的线程称为I/O线程，可以处理许多并发I/O。使用这样的模型，请求处理不会委托给工作线程，而是直接使用这些I/O线程。它节省了内存和CPU，因为不需要创建工作线程来处理请求。它还改善了并发性，因为它消除了对线程数量的限制。最后，它还改善了响应时间，因为它减少了线程开关的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From sequential to continuation style</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从顺序到延续风格</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, with the reactive execution model, the requests are processed using I/O threads.  But that's not all.  An I/O thread can handle multiple concurrent requests.  How? Here is the trick and one of the most significant differences between reactive and imperative.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，使用响应式执行模型，请求是使用I/O线程处理的。但这还不是全部。一个I/O线程可以处理多个并发请求。如何实现？这是一个技巧，也是响应式和指令式之间最重要的区别之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When processing a request requires interacting with a remote service, like an HTTP API or a database, it does not block the execution while waiting for the response.  Instead, it schedules the I/O operation and attaches a continuation, i.e., the request processing remaining code.  This continuation can be passed as a callback (a function invoked with the I/O outcome), or use more advanced constructs such as reactive programming or co-routines.  Regardless of how the continuation is expressed, the essential aspect is the release of the I/O thread and, as a consequence, the fact that this thread can be used to process another request.  When the scheduled I/O completes, the I/O thread executes the continuation, and the processing of the pending request continues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当处理请求需要与远程服务(如HTTP API或数据库)交互时，它不会在等待响应时阻塞执行。相反，它调度I/O操作并附加一个延续，即请求处理剩余的代码。这种延续可以作为回调传递 (与I/O结果一起调用的函数)，或者使用更高级的结构，诸如响应式编程或协同程序。不管延续是如何表示的，最基本的方面是释放I/O线程，因此，这个线程可以用来处理另一个请求。当计划的I/O完成时，I/O线程执行延续，并继续处理挂起的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, unlike the imperative model, where I/O blocks the execution, reactive switches to a continuation-based design, where the I/O threads are released, and continuation invoked when the I/Os complete.  As a result, the I/O thread can handle multiple concurrent requests, improving the overall concurrency of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，与I/O阻塞执行的指令式模型不同，响应式切换到基于延续的设计，其中I/O线程被释放，而延续在I/O完成时被调用。因此，I/O线程可以处理多个并发请求，从而提高应用程序的整体并发性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, there is a catch.  We need a way to write continuation-passing code.  There are many ways of doing this.  In Quarkus, we propose:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，有一个问题。我们需要一种方法来编写延续传递代码。有很多方法可以做到这一点。在Quarkus，我们提出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will use Mutiny.  To know more about Mutiny, check the xref:mutiny-primer.adoc[Mutiny documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将使用Mutiny。想要了解更多关于Mutiny的信息，请查看 xref:mutiny-primer.adoc[Mutiny文档]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Loom is coming to the JDK soon and proposes a virtual thread-based model.  The Quarkus architecture is ready to support Loom as soon as it's become globally available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Loom项目很快就会加入到JDK中，它提出了一个基于虚拟线程的模型。一旦在全局范围内可用，Quarkus架构就可以支持Loom。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the Reactive Fruits application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动响应式水果应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this in mind, let's see how we can develop a CRUD application with Quarkus, which will use the I/O thread to handle the HTTP requests, interact with a database, process the result, and write the HTTP response; in other words: a reactive CRUD application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>考虑到这一点，让我们看看如何使用Quarkus开发一个CRUD应用程序，它将使用I/O线程处理HTTP请求，与数据库交互，处理结果，并编写HTTP响应，换句话说：一个响应式CRUD应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While we recommend you to follow the step-by-step instructions, you can find the final solution on https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-reactive-panache-quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们建议您按照步骤操作，但您可以在 https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-reactive-panache-quickstart上找到最终的解决方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, go to https://code.quarkus.io[code.quarkus.io] and select the following extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，访问 https://code.quarkus.io[code.quarkus.io] 并选择以下扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last extension is the reactive database driver for PostgreSQL.  Hibernate Reactive uses that driver to interact with the database without blocking the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一个扩展是PostgreSQL的响应式数据库驱动程序。Hibernate响应式使用该驱动程序与数据库交互，而不会阻塞调用线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once selected, click on "Generate your application", download the zip file, unzip it and open the code in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选中后，单击 "Generate your application"，下载压缩文件，解压缩并在您喜欢的IDE中打开代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Panache Entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式Panache实体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the `Fruit` entity.Create the `src/main/java/org/acme/hibernate/orm/panache/Fruit.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从 `Fruit` 实体开始。创建 `src/main/java/org/acme/hibernate/orm/panache/Fruit.java` 文件，内容如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you import the reactive variant of `PanacheEntity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确保你导入了 `PanacheEntity` 的响应式类库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class represents `Fruits`.  It's a straightforward entity with a single field (`name`).  Note that it uses `io.quarkus.hibernate.reactive.panache.PanacheEntity`, the reactive variant of `PanacheEntity`.  So, behind the scenes, Hibernate uses the execution model we described above.  It interacts with the database without blocking the thread.  In addition, this reactive `PanacheEntity` proposes a reactive API.  We will use this API to implement the REST endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个类代表 `Fruits`。它是一个简单的实体，只有一个字段 (`name`)。注意，它使用的是 `io.quarkus.hibernate.reactive.panache.PanacheEntity`，是 `PanacheEntity` 的响应式类库。因此，Hibernate在幕后使用我们前面描述的执行模型。它与数据库交互而不阻塞线程。此外，这个响应式的 `PanacheEntity` 提出了一个响应式API。我们将使用这个API来实现REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, open the `src/main/resource/application.properties` file and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在继续之前，打开 `src/main/resource/application.properties` 文件并添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It instructs the application to use PostgreSQL for the database and to handle the database schema generation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它指示应用程序对数据库使用PostgreSQL，并处理数据库模式的生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the same directory, create an `import.sql` file, which inserts a few fruits, so we don't start with an empty database in dev mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在同一个目录中，创建一个 `import.sql` 文件，它插入了一些水果数据，所以我们不会在dev模式中面对一个空数据库开始：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a terminal, launch the application in dev mode using: `./mvnw quarkus:dev`.  Quarkus automatically starts a database instance for you and configure the application. Now we only need to implement the HTTP endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在终端中，使用：`./mvnw quarkus:dev`。Quarkus会自动为您启动一个数据库实例并配置应用程序。现在我们只需要实现HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because the interaction with the database is non-blocking and asynchronous, we need to use asynchronous constructs to implement our HTTP resource.  Quarkus uses Mutiny as its central reactive programming model.  So, it supports returning Mutiny types (`Uni` and `Multi`) from HTTP endpoints.  Also, our Fruit Panache entity exposes methods using these types, so we only need to implement the _glue_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于与数据库的交互是非阻塞的和异步的，我们需要使用异步构造来实现我们的HTTP资源。Quarkus使用Mutiny作为其核心响应式编程模型。因此，它支持从HTTP端点返回Mutiny类型 (`Uni` and `Multi`) 。此外，水果Panache实例使用这些类型公开方法，因此我们只需要实现 _glue_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/hibernate/orm/panache/FruitResource.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/hibernate/orm/panache/FruitResource.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the `getAll` method. The `getAll` method returns all the fruits stored in the database.  In the `FruitResource`, add the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从 `getAll` 方法开始。 `getAll` 方法返回存储在数据库中的所有水果对象。在 `FruitResource` 中，添加以下代码：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open http://localhost:8080/fruits to invoke this method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开 http://localhost:8080/fruits 调用这个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We get the expected JSON array.  RESTEasy Reactive automatically maps the list into a JSON Array, except if instructed otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们得到了预期的JSON数组。RESTEasy Reactive自动将列表映射到JSON数组，除非另有指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look at the return type; it returns a `Uni` of `List&lt;Fruit&gt;`.  `Uni` is an asynchronous type.  It's a bit like a future.  It's a placeholder that will get its value (item) later.  When it receives the item (Mutiny says it _emits_ its item), you can attach some behavior.  That's how we express the continuation: get a uni, and when the uni emits its item, execute the rest of the processing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>看看返回类型，它返回 `List&lt;Fruit&gt;` 的 `Uni` 。`Uni` 是一个异步类型。这有点像未来。它是一个占位符，稍后将获得它的值条目 (item) 。当它接收条目(Mutiny说它 _输出_ 的条目)时，你可以附加一些行为。这就是我们表示延续的方式：获取一个uni，当uni输出它的条目时，执行其余的处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive developers may wonder why we can't return a stream of fruits directly.  It tends to be a bad idea when dealing with a database.  Relational databases do not handle streaming well.  It’s a problem of protocols not designed for this use case.  So, to stream rows from the database, you need to keep a connection (and sometimes a transaction) open until all the rows are consumed.  If you have slow consumers, you break the golden rule of databases: don’t hold connections for too long.  Indeed, the number of connections is rather low, and having consumers keeping them for too long will dramatically reduce the concurrency of your application.  So, when possible, use a `Uni&lt;List&lt;T&gt;&gt;` and load the content.  If you have a large set of results, implement pagination.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式程序开发者可能会想为什么我们不能直接返回水果流。在处理数据库时，这往往不是一个好主意。关系数据库不能很好地处理流。这是协议不是为这个用例设计的问题。因此，要从数据库流输出行，您需要保持一个连接（有时是一个事务）打开，直到所有行都被消耗掉。如果您的用户很慢，那么您就违反了数据库的黄金法则：不要保持连接太长时间。实际上，可用连接的数量相当少，并且让使用者保持这些连接太长时间将极大地降低应用程序的并发性。所以，如果可能的话，使用 `Uni&lt;List&lt;T&gt;&gt;` 并加载内容。如果有大量结果，则实现分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's continue our API with `getSingle`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们用 `getSingle` 继续我们的API：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, we use `Fruit.findById` to retrieve the fruit.  It returns a `Uni`, which will complete when the database has retrieved the row.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本例中，我们使用 `Fruit.findById` 来检索水果。当数据库检索到该行时，它将返回一个 `Uni`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `create` method allows adding a new fruit to the database:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`create` 方法允许向数据库中添加新水果记录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is a bit more involved.  To write to a database, we need a transaction.  So we use `Panache.withTransaction` to get one (asynchronously) and call the `persist` method when we receive the transaction.  The `persist` method is also returning a `Uni`.  This `Uni` emits the result of the insertion of the fruit in the database.  Once the insertion completes (and that's our continuation), we create a `201 CREATED` response.  RESTEasy Reactive automatically reads the request body as JSON and creates the `Fruit` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码稍微复杂一些。要写入数据库，我们需要一个事务。所以我们用 `Panache.withTransaction` 来获取一个（异步），并在接收到事务时调用 `persist` 方法。 `persist` 方法也返回一个 `Uni`。这个 `Uni` 发出水果插入数据库的结果。一旦插入完成（这就是我们的延续），我们创建一个 `201 CREATED` 响应。RESTEasy Reactive会自动将请求体读取为JSON并创建 `Fruit` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `.onItem().transform(...)` can be replaced with `.map(...)`.  `map` is a shortcut.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.onItem().transform(...)`  可以用 `.map(...)` 取代。`map` 是它的快捷方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have https://curl.se/[curl] on your machine, you can try the endpoint using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在您的机器安装了 https://curl.se/[curl]命令，便可以尝试使用端点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the same ideas, you can implement the other CRUD methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>遵循相同的思路，您可以实现其他CRUD方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing and Running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试和运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a reactive application is similar to testing a non-reactive one: use the HTTP endpoint and verify the HTTP responses.  The fact that the application is reactive does not change anything.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试响应式应用程序与测试非响应式应用程序类似：使用HTTP端点并验证HTTP响应。应用程序是响应式的这一事实并没有改变任何事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In https://github.com/quarkusio/quarkus-quickstarts/blob/main/hibernate-reactive-panache-quickstart/src/test/java/org/acme/hibernate/orm/panache/FruitsEndpointTest.java[FruitsEndpointTest.java] you can see how the test for the fruit application can be implemented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 https://github.com/quarkusio/quarkus-quickstarts/blob/main/hibernate-reactive-panache-quickstart/src/test/java/org/acme/hibernate/orm/panache/FruitsEndpointTest.java[FruitsEndpointTest.java]中，您可以看到如何实现水果应用程序的测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and running the application does not change either.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包和运行应用程序也不会改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the following command as usual:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以像往常一样使用以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or to build a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者构建一个原生可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also package the application in a container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>还可以将应用程序打包在容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run the application, don’t forget to start a database and provide the configuration to your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要运行应用程序，不要忘记启动数据库并为应用程序提供配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you can use Docker to run your database:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，你可以使用Docker来运行你的数据库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, launch the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，使用以下命令启动应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, if you packaged your application as native executable, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，如果你将你的应用打包为原生可执行文件，使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters passed to the application are described in the datasource guide.  There are other ways to configure the application - please check the xref:config-reference.adoc#configuration_sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传递给应用程序的参数在数据源指南中进行了描述。还有其他配置应用程序的方法 - 请查看 xref:config-reference.adoc#configuration_sources[配置指南]来概览各种可能性（例如env变量，.env文件等等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a brief introduction to some reactive features offered by Quarkus.  Quarkus is a reactive framework, and so offers a lot of reactive features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南简要介绍了Quarkus提供的一些响应式特性。Quarkus是一个响应式框架，因此提供了许多响应式特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to continue on this topic check:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想继续这个话题，请检查：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) Multi-Tenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）多租户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenTelemetry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenTelemetry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Profiles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with RabbitMQ.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的 Quarkus 应用程序如何利用 SmallRye响应式消息传递与RabbitMQ进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`channel-name` 片段必须与 `@Incoming` 和 `@Outgoing` 注解中设定的值相匹配:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending Configuration Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展配置支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Tools in your favorite IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你最喜欢的IDE中使用Quarkus工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://camel.apache.org/[Apache Camel] is the Swiss knife of integrating heterogeneous systems with more than a decade of history and a lively community of users and developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://camel.apache.org/[Apache Camel] 是集成异构系统的瑞士军刀，拥有十多年的历史以及活跃的用户和开发人员社区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to https://camel.apache.org/camel-quarkus/latest/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus上对Apache Camel的支持由 https://github.com/apache/camel-quarkus[Apache Camel Quarkus 项目] 提供。 有关更多信息，请参阅 https://camel.apache.org/camel-quarkus/latest/[他们的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with .properties File</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用.properties文件的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>平台</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class Loading Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类加载参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container First</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>容器优先</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developer Joy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发者的乐趣</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conditional Extension Dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>条件性扩展的依赖性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate ORM with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化的Hibernate ORM与Panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using SSL With Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在原生可执行文件中使用SSL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native executables to support SSL, as native executables don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将讨论如何让你的原生可执行文件支持SSL，因为原生可执行文件并不支持开箱即用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个编辑器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OAuth2 RBAC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OAuth2 RBAC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OAuth2 tokens to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OAuth2令牌来提供对JAX-RS端点的安全访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenAPI and Swagger UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenAPI和Swagger UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>License</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>许可证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试你的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Your Own Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写您自己的扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Capabilities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using JMS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以本机可执行文件运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用以下命令构建本机可执行文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once started, you can request the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦启动，你可以发送请求到提供服务的端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatically add newline with `curl -w "\n"`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自动添加换行符 `curl -w "\n"` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using `curl -w "\n"` in this example to avoid your terminal printing a '%' or put both result and next command prompt on the same line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们在这个例子中使用 `curl -w "\n"` ，以避免你的终端打印出'%'或把结果和下一个命令提示符放在同一行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注入法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io[Vert.x] is a toolkit for building reactive applications.  As described in the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture], Quarkus uses Vert.x underneath.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io[Vert.x] 是一个用于构建响应式应用程序的工具集。正如 link:quarkus-reactive-architecture.html[Quarkus响应式架构] 中所描述的，下面，Quarkus将使用Vert.x。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Vert.x 客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing application properties with Spring Boot properties API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot属性API访问应用程序属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Spring Boot `@ConfigurationProperties` annotated class to access application properties instead of a Quarkus native `@ConfigProperties` or a MicroProfile `@ConfigProperty` approach, you can do that with this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你更喜欢使用Spring Boot `@ConfigurationProperties` 注解类来访问应用程序的属性，而不是Quarkus本地的 `@ConfigProperties` 或MicroProfile `@ConfigProperty` 的注解方式，你可以通过使用该扩展来做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Boot `@ConfigurationProperties` has a few limitations. For instance, `Map` injection is not supported. Consider using xref:config-mappings.adoc[Mapping configuration to objects].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Boot `@ConfigurationProperties` 有一些限制。例如，不支持 `Map` 注入。你可以考虑使用 link:config-mappings.html[将配置映射到对象] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `spring-boot-properties-quickstart` {quickstarts-tree-url}/spring-boot-properties-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `spring-boot-properties-quickstart` {quickstarts-tree-url}/spring-boot-properties-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a project and imports the `spring-boot-properties` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个项目并导入了 `spring-boot-properties` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-boot-properties` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以在项目的根目录下运行以下命令，并将 `spring-boot-properties` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a `GreetingResource` JAX-RS resource in the `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在 `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` 文件中创建一个包含如下内容的 `GreetingResource` JAX-RS资源:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new class `src/main/java/org/acme/spring/boot/properties/GreetingProperties.java` with a message field:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个包含消息字段的 `src/main/java/org/acme/spring/boot/properties/GreetingProperties.java` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here `text` field is public, but it could also be a private field with getter and setter or just a public getter in an interface.  Because `text` does not have a default value it is considered required and unless it is defined in a configuration file (`application.properties` by default)  your application will fail to start.  Define this property in your `src/main/resources/application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里 `text` 字段是公共的，但它也可以是一个带有getter和setter的私有字段，或者只是一个接口中的公共getter。因为 `text` 没有默认值，所以它被认为是必需的，除非它被定义在一个配置文件中（默认为 `application.properties` ），否则你的应用程序将无法启动。在你的 `src/main/resources/application.properties` 文件中定义该属性:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Your configuration properties
greeting.text = hello
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 你的属性配置
greeting.text = hello
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now modify `GreetingResource` to start using the `GreetingProperties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，修改 `GreetingResource` 以使用 `GreetingProperties` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the tests to verify that application still functions correctly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行测试以验证应用程序是否仍能正常运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application in dev mode with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下运行该应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the configuration file is immediately reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更改配置文件的内容将会立即得到反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default values</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a suffix for a greeting for which we'll set a default value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们为greeting 添加一个后缀，我们将为其设置一个默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties with default values can be configured in a configuration file just like any other property.  However, the default value will be used if the property was not defined in a configuration file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>具有默认值的属性可以像其他属性一样在配置文件中被配置。然而，如果该属性没有在配置文件中被定义，则将使用默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go ahead and add the new field to the `GreetingProperties` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>继续在 `GreetingProperties` 类中添加新的字段:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And update the `GreetingResource` and its test `GreetingResourceTest`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并更新 `GreetingResource` 及其对应的 `GreetingResourceTest` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the tests to verify the change.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行该测试以验证更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional values</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可选值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties with optional values are the middle-ground between standard and properties with default values.  While a missing property in a configuration file will not cause your application to fail, it will nevertheless not have a value set.  We use `java.util.Optional` type to define such properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>具有可选值的属性处于标准属性和具有默认值属性之间的中间地带。尽管在配置文件中缺少一个属性不会导致你的应用程序启动失败，但它还是没有被设置一个值。我们使用 `java.util.Optional` 类型来定义这种属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add an optional `name` property to the `GreetingProperties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `GreetingProperties` 中添加一个可选的 `name` 属性:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grouping properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分组属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have three properties in our `GreetingProperties` class.  While `name` could be considered more of a runtime property (and maybe could be passed as an HTTP query parameter in the future), `text` and `suffix` are used to define a message template.  Let's group these two properties in a separate inner class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，在我们的 `GreetingProperties` 类中有三个属性。虽然 `name` 可以更多地被认为是运行时属性（也许在将来可以被作为HTTP查询参数进行传递），而 `text` 和 `suffix` 被用于定义一个消息模板。让我们将这两个属性作为一组放在一个独立的内部类中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here `Message` properties class is defined as an inner class, but it could also be a top level class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里 `Message` 属性类被定义为一个内部类，但它也可以作为一个顶层类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having such property groups brings more structure to your configuration.  This is especially useful when then number of properties grows.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样的属性分组可以为你的配置带来更加丰富的结构。当属性的数量增加时，这尤其有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of the additional class, our property names have changed.  Let's update the properties file and the `GreetingResource` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为有了额外的类，我们的属性名也发生了改变。让我们更新一下属性配置文件和 `GreetingResource` 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Your configuration properties
greeting.message.text = hello
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 你的属性配置
greeting.message.text = hello
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Apache Kafka with Schema Registry and Avro</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka与模式仓库和Avro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito DMN support to add decision automation capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito DMN支持为应用程序添加决策自动化功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating Your First Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建你的第一个应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>学习如何创建一个Hello World Quarkus应用程序。本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a JAX-RS endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个JAX-RS端点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入beans</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functional tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>功能测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging of the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序打包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Verify Maven is using the Java you expect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>验证Maven是否使用了你期望的Java版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你安装了多个JDK，那么Maven不一定能找到预期的java，你可能会得到意想不到的结果。你可以通过运行 `mvn --version` ，验证Maven使用哪个JDK。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们创建了一个简单的应用程序，为 `hello` 端点提供服务。为了演示依赖性注入，这个端点使用了一个 `greeting` bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide also covers the testing of the endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南还包括对终端的测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions from &lt;&lt;bootstrapping-the-project,Bootstrapping project&gt;&gt; and onwards to create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照从 link:#bootstrapping-the-project[构建项目] 开始的指示，一步一步地创建应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，你可以直接进入完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive] or clone the git repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下载一个 {quickstarts-archive-url}[存档] 或克隆git仓库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` {quickstarts-tree-url}/getting-started[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `getting-started` {quickstarts-tree-url}/getting-started[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to create a new Quarkus project is to open a terminal and run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个新的Quarkus项目最简单的方法是打开终端并运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux &amp; MacOS users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>针对Linux和MacOS用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Windows users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Windows用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd , (don't use backward slash `\` and put everything on the same line)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用cmd ，（不要使用反斜线 `\` ，并将所有内容放在同一行）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes e.g. `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用Powershell，用双引号包住 `-D` 参数，例如： `"-DprojectArtifactId=getting-started"` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它在 `./getting-started` 中产生了以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例 `Dockerfile` 文件，用于 `native` 和 `jvm` 两种模式，在 `src/main/docker` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version of the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦生成，请看 `pom.xml` 。你会发现Quarkus BOM的导入，允许你省略不同Quarkus依赖的版本。此外，你可以看到 `quarkus-maven-plugin` ，负责应用程序的打包，也提供开发模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a Gradle project, you would find a similar setup:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Gradle项目中，你会发现一个类似的设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Quarkus Gradle plugin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Gradle插件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `enforcedPlatform` directive for the Quarkus BOM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`enforcedPlatform` ，用于指示Quarkus BOM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果我们把重点放在依赖关系部分，你可以看到允许开发REST应用程序的扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/GreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在项目创建过程中， `src/main/java/org/acme/GreetingResource.java` 文件已被创建，其内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Differences with vanilla JAX-RS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与vanilla JAX-RS的区别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus，不需要创建一个 `Application` 类。它支持这么做，但不是必须的。此外，只有一个资源的实例被创建，而不是每个请求一个。你可以使用不同的 `*Scoped` 注解（ `ApplicationScoped` , `RequestScoped` , 等等）来配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们已经准备好运行我们的应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application, or keep it running and enjoy the blazing fast hot-reload.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `CTRL+C` ，停止应用程序，或保持运行，享受极快的热重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus中的依赖注入是基于ArC的，ArC是一个基于CDI的依赖注入解决方案，。如果你是CDI的新手，那么我们推荐你阅读 link:cdi.html[CDI简介] 指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus only implements a subset of the CDI features and comes with non-standard features and specific APIS, you can learn more about it in the xref:cdi-reference.adoc[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus只实现了CDI功能的一个子集，并且带有非标准的功能和特定的APIS，你可以在 link:cdi-reference.html[Contexts和依赖注入指南] 中了解更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们修改应用程序并添加一个bean。创建 `src/main/java/org/acme/GreetingService.java` 文件，内容如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `GreetingResource` class to inject the `GreetingService` and create a new endpoint using it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编辑 `GreetingResource` 类，注入 `GreetingService` ，并使用它创建一个新的端点:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you stopped the application (keep in mind you don't have to do it, changes will be automatically deployed by our live reload feature), restart the application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你停止了应用程序（请记住，你不必这样做，变化将由我们的实时重载功能自动部署），用以下方法重新启动应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then check that the endpoint returns `hello quarkus` as expected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后检查端点是否按预期返回 `hello quarkus` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus:dev` 在开发模式下运行Quarkus。这使得后台编译的实时重载成为可能，这意味着当你修改你的Java文件或者资源文件并刷新你的浏览器时，这些变化将自动生效。这也适用于资源文件，如配置属性文件。刷新浏览器会触发对工作区的扫描，如果检测到任何变化，Java文件会被重新编译，应用程序会被重新部署；然后你的请求会被重新部署的应用程序提供服务。如果编译或部署有任何问题，错误页面会让你知道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you can pass `-Dsuspend` on the command line. If you don't want the debugger at all you can use `-Ddebug=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这也将在端口 `5005` 上监听调试器。如果你想在运行前等待调试器的连接，你可以在命令行中传递 `-Dsuspend` 。如果你根本不想要调试器，你可以使用 `-Ddebug=false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All right, so far so good, but wouldn't it be better with a few tests, just in case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>好吧，到目前为止还不错。为了以防万一， 我们需要再做一些测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the generated build file, you can see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在生成的构建文件中，你可以看到2个测试依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[JUnit 5] tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持 link:https://junit.org/junit5/[JUnit 5] 测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of this, in the case of Maven, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support JUnit 5:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正因为如此，就Maven而言，必须设置 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] 的版本，因为默认版本不支持JUnit 5：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging` system property to make sure tests will use the correct log manager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还设置了 `java.util.logging` 系统属性，以确保测试将使用正确的日志管理器和 `maven.home` ，以确保应用 `${maven.home}/conf/settings.xml` 的自定义配置（如果有的话）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目包含一个简单的测试。编辑 `src/test/java/org/acme/GreetingResourceTest.java` ，以匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过使用 `QuarkusTest` runner，你指示JUnit在测试前启动应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the HTTP response status code and content</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检查HTTP回应状态代码和内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These tests use http://rest-assured.io/[RestAssured], but feel free to use your favorite library.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些测试使用 link:http://rest-assured.io/[RestAssured] ，但也可以随意使用你最喜欢的库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run these using Maven:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用Maven来运行这些：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run the test from your IDE directly (be sure you stopped the application first).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以直接从你的IDE中运行测试（要确保你先停止了应用程序）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests will run on port `8081` so as not to conflict with the running application. We automatically configure RestAssured to use this port. If you want to use a different client you should use the `@TestHTTPResource` annotation to directly inject the URL of the tested application into a field on the test class. This field can be of the type `String`, `URL` or `URI`. This annotation can also be given a value for the test path. For example, if I want to test a Servlet mapped to `/myservlet` I would just add the following to my test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，测试将在端口 `8081` 上运行，以便不与正在运行的应用程序冲突。我们自动将RestAssured配置为使用该端口。如果你想使用不同的客户端，你应该使用 `@TestHTTPResource` 注释，直接将测试应用程序的URL注入到测试类的一个字段中。这个字段的类型可以是 `String` , `URL` 或 `URI` 。这个注解也可以给测试路径一个值。例如，如果我想测试一个映射到 `/myservlet` 的Servlet，只需在测试中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试端口可以通过 `quarkus.http.test-port` 配置属性来控制。Quarkus还创建了一个名为 `test.url` 的系统属性，在不能使用注入的情况下被设置为基本测试URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module project or external modules</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与多模块项目或外部模块一起工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus在构建时大量使用 link:https://github.com/wildfly/jandex[Jandex] ，以发现各种类或注解。其中一个应用就是可以发现并识别CDI Bean。因此，如果没有在构建时正确设置，大多数Quarkus扩展将无法正常工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This index is created by default on the project on which Quarkus is configured for, thanks to our Maven and Gradle plugins.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过使用Maven和Gradle插件，这个索引在Quarkus的项目上的默认配置是自动创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the xref:maven-tooling.adoc#multi-module-maven[Maven] or xref:gradle-tooling.adoc#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不过，在处理多模块项目时，请务必阅读 link:maven-tooling.html#multi-module-maven[Maven] 或 link:gradle-tooling.html#multi-module-maven[Gradle] 指南中的 `多模块项目` 部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你计划使用外部模块（例如，一个用于你所有领域对象的外部库），你将需要通过添加Jandex插件（如果你能修改它们）或通过 `application.properties` 里的属性`quarkus.index-dependency` （在你不能修改模块的情况下很有用）使这些模块为索引过程所知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to read the xref:cdi-reference.adoc#bean_discovery[Bean Discovery] section of the CDI guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请务必阅读CDI指南中的 link:cdi-reference.html#bean_discovery[Bean发现] 部分以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序打包和运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is packaged using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该应用程序是用以下方式打包的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It produces several outputs in `/target`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它在 `/target` ，产生几个输出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it's the regular artifact produced by the Maven build - it is *not* the runnable jar;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - 它只包含项目的类和资源，是Maven构建时产生的常规组件——它是不可运行的jar。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-app` 目录，其中包含 `quarkus-run.jar` jar文件--是一个可执行的 _jar_ 。请注意，它不是 _über-jar_ ，因为依赖项目被复制到 `quarkus-app/lib/` 的子目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用以下方式运行该应用程序。 `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application somewhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想把你的应用程序部署到某个地方（通常是在一个容器中），你需要部署整个 `quarkus-app` 目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running the application, don't forget to stop the hot reload mode (hit `CTRL+C`), or you will have a port conflict.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在运行应用程序之前，不要忘记停止热重载模式（使用 `CTRL+C` ），否则你会有一个端口冲突。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the banner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置banner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，当Quarkus应用程序启动时（在常规或开发模式下），它将显示一个ASCII。通过在 `application.properties` 中设置 `quarkus.banner.enabled=false` ，通过设置 `-Dquarkus.banner.enabled=false` Java系统属性，或者通过将 `QUARKUS_BANNER_ENABLED` 环境变量设置为 `false` ，可以禁用该横幅。此外，用户可以通过将横幅文件放在 `src/main/resources` ，并在 `application.properties` 中配置 `quarkus.banner.path=name-of-file` ，从而提供一个自定义的横幅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the xref:building-native-image.adoc[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the xref:getting-started-reactive.adoc[Getting Started with Reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了使用 Quarkus 创建应用程序的内容。 然而，下面还有更多内容。 我们建议您继续学习 xref:building-native-image.adoc[构建本地可执行文件指南]，您可以在其中了解如何创建本地可执行文件并将其打包到容器中。 如果您对响应式感兴趣，我们推荐 xref:getting-started-reactive.adoc[响应式入门指南]，您可以在其中了解如何使用 Quarkus 实现响应式应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the xref:tooling.adoc[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，xref:tooling.adoc[工具指南] 文档解释了如何做到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import the project in your favorite IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你喜欢的编辑器里面导入项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with JDBC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JDBC的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用数据库来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add rule engine capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加规则引擎功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add prediction capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加预测功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker, podman)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个工作的容器运行时（Docker 或 podman）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-In Authentication Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内置的认证支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is developed by a third party and is part of the Quarkus Platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此扩展程序由第三方开发，是 Quarkus 平台的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains logging and how to configure it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了日志记录以及如何配置它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Category</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Centralized Log Management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集中的日志管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This technology is considered {extension-status}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这项技术被认为是{extension-status}。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _experimental_ mode, early feedback is requested to mature the idea.  There is no guarantee of stability nor long term presence in the platform until the solution matures.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _experimental(实验)_ 模式下，要求早期反馈以使想法成熟。在解决方案成熟之前，不保证稳定性或长期存在于平台中。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题列表] 中提出问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _preview_, backward compatibility and presence in the ecosystem is not guaranteed.  Specific improvements might require changing configuration or APIs, and plans to become _stable_ are under way.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _preview(预览)_ 中，不保证向后兼容和在生态系统中的存在。具体的改进可能需要改变配置或API，并且正在计划变得 _稳定_ 。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题列表] 中提出问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being _stable_, backward compatibility and presence in the ecosystem are taken very seriously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_stable(稳定)_ 版本，确保向后兼容和生态系统的持续性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a full list of possible statuses, check our https://quarkus.io/faq/#extension-status[FAQ entry].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>想要了解完整的扩展状态信息，请查看 https://quarkus.io/faq/#extension-status[常见问题入口] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization of Web Endpoints</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网络端点的授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ease the containerization of native executables, Quarkus provides a base image providing the requirements to run these executables.  The `quarkus-micro-image:1.0` image is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了简化本地可执行文件的容器化步骤，Quarkus提供了一个包含运行这些可执行文件依赖的基础镜像。 `quarkus-micro-image:1.0` 镜像是:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>small (based on `ubi8-micro`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>小的 (基于 `ubi8-micro` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>contains the right set of dependencies (glibc, libstdc++, zlib)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含正确的依赖项（glibc、libstdc++、zlib）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>support upx-compressed executables (more details on the xref:upx.adoc[enabling compression documentation])</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持upx压缩的可执行文件（更多相关细节在 link:upx.html[启用压缩文档] 中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用此基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `Dockerfile`, just use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的 `Dockerfile` 中，只需使用:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending the image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展该镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your application may have additional requirements.  For example, if you have an application that requires `libfreetype.so`, you need to copy the native libraries to the container.  In this case, you need to use a multi-stage `dockerfile` to copy the required libraries:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的应用程序可能有其他的额外要求。例如，如果你有一个依赖于 `libfreetype.so` 的应用程序，你需要将本地库拷贝到容器当中。在这种情况下，你需要使用一个多阶段的 `dockerfile` 来拷贝所需要的依赖库:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Second stage - copy the dependencies
FROM quay.io/quarkus/quarkus-micro-image:1.0
COPY --from=BUILD \
   /lib64/libfreetype.so.6 \
   /lib64/libbz2.so.1 \
   /lib64/libpng16.so.16 \
   /lib64/
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 第二阶段 - 拷贝依赖库
FROM quay.io/quarkus/quarkus-micro-image:1.0
COPY --from=BUILD \
   /lib64/libfreetype.so.6 \
   /lib64/libbz2.so.1 \
   /lib64/libpng16.so.16 \
   /lib64/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to have access to the full AWT support, you need more than just `libfreetype.so`, but also the font and font configurations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要获得对AWT的完整支持，你需要的不仅仅是 `libfreetype.so` ，同时还需要字体和字体配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Second stage - copy the dependencies
FROM quay.io/quarkus/quarkus-micro-image:1.0
COPY --from=BUILD \
   /lib64/libfreetype.so.6 \
   /lib64/libgcc_s.so.1 \
   /lib64/libbz2.so.1 \
   /lib64/libpng16.so.16 \
   /lib64/libm.so.6 \
   /lib64/libbz2.so.1 \
   /lib64/libexpat.so.1 \
   /lib64/libuuid.so.1 \
   /lib64/
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 第二阶段 - 拷贝依赖库
FROM quay.io/quarkus/quarkus-micro-image:1.0
COPY --from=BUILD \
   /lib64/libfreetype.so.6 \
   /lib64/libgcc_s.so.1 \
   /lib64/libbz2.so.1 \
   /lib64/libpng16.so.16 \
   /lib64/libm.so.6 \
   /lib64/libbz2.so.1 \
   /lib64/libexpat.so.1 \
   /lib64/libuuid.so.1 \
   /lib64/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative - Using ubi-minimal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>替代方案 - 使用 ubi-minimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the micro image does not suit your requirements, you can use https://catalog.redhat.com/software/containers/ubi8/ubi-minimal/5c359a62bed8bd75a2c3fba8[UBI- Minimal].  It's a bigger image, but contains more utilities and is closer to a full Linux distribution.  Typically, it contains a package manager (`microdnf`), so you can install packages more easily.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果微镜像不符合你的要求，你可以使用 https://catalog.redhat.com/software/containers/ubi8/ubi-minimal/5c359a62bed8bd75a2c3fba8[UBI- Minimal]。这是一个更大的镜像，但包含了更多实用程序 且更接近于完整的 Linux 发行版。通常，它包含一个包管理器 (`microdnf`)，因此你可以利用它更方便地安装软件包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this base image, use the following `Dockerfile`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用该基础镜像，使用以下 `Dockerfile`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tips for writing native applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写原生应用程序的提示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide contains various tips and tricks for getting around problems that might arise when attempting to run Java applications as native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包含各种提示和技巧，以解决在尝试以原生可执行文件形式运行Java应用程序时可能出现的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we differentiate two contexts where the solution applied might be different:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，我们区分了两种情况，适用的解决方案可能是不同的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the context of an application, you will rely on configuring the `native-image` configuration by tweaking your `pom.xml`;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个应用程序的背景下，你将依靠配置 `native-image` ，通过调整你的 `pom.xml` ；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the context of an extension, Quarkus offers a lot of infrastructure to simplify all of this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在扩展的背景下，Quarkus提供了很多基础设施来简化这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please refer to the appropriate section depending on your context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请根据你的情况，参考适当的章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in your application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的应用程序中支持原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM imposes a number of constraints and making your application a native executable might require a few tweaks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM施加了一些限制，使你的应用程序成为原生可执行文件可能需要进行一些调整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when building a native executable, GraalVM will not include any of the resources that are on the classpath into the native executable it creates.  Resources that are meant to be part of the native executable need to be configured explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，在构建本地可执行文件时，GraalVM不会将classpath上的任何资源纳入其创建的原生可执行文件。要成为原生可执行文件一部分的资源，需要明确地进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus automatically includes the resources present in `META-INF/resources` (the web resources) but, outside of this directory, you are on your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自动包括存在于 `META-INF/resources` (网络资源）的资源，但是，在这个目录之外，你就得靠自己了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you need to be extremely careful here as anything in `META-INF/resources` will be exposed as static web resources.  So this directory is not a shortcut for "let's automatically include these resources in the native executable" and should only be used for static web resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，你在这里需要非常小心，因为 `META-INF/resources` 中的任何东西都会作为静态网络资源暴露出来。所以这个目录不是 "让我们自动把这些资源包含在本地可执行文件中 "的捷径，而应该只用于静态网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other resources should be declared explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其他资源应明确声明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To include more resources in the native executable, the easiest way is to use the `quarkus.native.resources.includes` configuration property, and its counterpart to exclude resources `quarkus.native.resources.excludes`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要在原生可执行文件中包含更多的资源，最简单的方法是使用 `quarkus.native.resources.includes` 配置属性，及其对应的排除资源 `quarkus.native.resources.excludes`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both configuration properties support glob patterns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这两个配置属性都支持glob模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, having the following properties in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，在你的 `application.properties`中有以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will include:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all files in the `foo/` directory and its subdirectories except for files in `foo/private/` and its subdirectories,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `foo/` 目录及其子目录中的所有文件，但 `foo/private/` 及其子目录中的文件除外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all text files in the `bar/` directory and its subdirectories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `bar/` 目录及其子目录下的所有文本文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If globs are not sufficiently precise for your use case and you need to rely on regular expressions or if you prefer relying on the GraalVM infrastructure, you can also create a `resources-config.json` (the most common location is within `src/main/resources`) JSON file defining which resources should be included:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果globs对于你的使用情况来说不够精确，你需要依靠正则表达式，或者你更喜欢依靠GraalVM的基础设施，你也可以创建一个 `resources-config.json` (最常见的位置是在`src/main/resources`) JSON文件，定义哪些资源应该被包含：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The patterns are valid Java regexps.  Here we include all the XML files and JSON files into the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些模式都是有效的Java重组函数。在这里，我们将所有的XML文件和JSON文件纳入原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this topic in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[GraalVM文档]中找到更多关于这个主题的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final order of business is to make the configuration file known to the `native-image` executable by adding the proper configuration to `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一项工作是通过向 `application.properties`添加适当的配置，使配置文件为 `native-image` 可执行文件所知：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `resources-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.  If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面的片段中，我们能够简单地使用 `resources-config.json` ，而不是指定文件的整个路径，只是因为它被添加到了 `src/main/resources` 。如果该文件被添加到了另一个目录，就必须手动指定适当的文件路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple options may be separated by a comma. For example, one could use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个选项可以用逗号隔开。例如，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in order to ensure that various resources are included and additional reflection is registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以确保各种资源被包括在内，并登记了额外的反射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for some reason adding the aforementioned configuration to `application.properties` is not desirable, it is possible to configure the build tool to effectively perform the same operation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果由于某种原因，将上述配置添加到 `application.properties` ，是不可取的，可以通过配置构建工具来有效地执行相同的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Maven, we could use the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Maven时，我们可以使用以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering for reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>登记反射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building a native executable, GraalVM operates with a closed world assumption.  It analyzes the call tree and removes all the classes/methods/fields that are not used directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在构建本地可执行文件时，GraalVM以封闭世界的假设进行操作。它分析调用树并删除所有不直接使用的类/方法/字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements used via reflection are not part of the call tree so they are dead code eliminated (if not called directly in other cases).  To include these elements in your native executable, you need to register them for reflection explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过反射使用的元素不是调用树的一部分，所以它们是被消除的死代码（如果不是在其他情况下直接调用）。要在你的本地可执行文件中包含这些元素，你需要为反射明确地注册它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a very common case as JSON libraries typically use reflection to serialize the objects to JSON:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常常见的情况，因为JSON库通常使用反射来将对象序列化为JSON：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we were to use the code above, we would get an exception like the following when using the native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果我们使用上面的代码，在使用原生可执行文件时，我们会得到一个类似下面的异常：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you are using Jackson:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或如果你在使用Jackson：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An even nastier possible outcome could be for no exception to be thrown, but instead the JSON result would be completely empty.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个更糟糕的结果是没有抛出异常，而JSON的结果是完全空的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two different ways to fix this type of issues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有两种不同的方法来解决这种类型的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the @RegisterForReflection annotation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用@RegisterForReflection注解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to register a class for reflection is to use the `@RegisterForReflection` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为反射注册一个类的最简单方法是使用 `@RegisterForReflection` 注解：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your class is in a third-party jar, you can do it by using an empty class that will host the `@RegisterForReflection` for it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的类在第三方的jar中，你可以通过使用一个空的类来做，这个空的类将为它托管 `@RegisterForReflection` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `MyClassRequiringReflection` and `MySecondClassRequiringReflection` will be registered for reflection but not `MyReflectionConfiguration`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `MyClassRequiringReflection` 和 `MySecondClassRequiringReflection` 将被注册为反射，但不包括 `MyReflectionConfiguration` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This feature is handy when using third-party libraries using object mapping features (such as Jackson or GSON):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在运用使用对象映射功能的第三方库（如Jackson或GSON）时，这个功能很方便：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用一个配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a configuration file to register classes for reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用一个配置文件来为反射注册类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, in order to register all methods of class `com.acme.MyClass` for reflection, we create `reflection-config.json` (the most common location is within `src/main/resources`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为一个例子，为了注册类 `com.acme.MyClass` 的所有方法进行反射，我们创建 `reflection-config.json` （最常见的位置是在 `src/main/resources` 内）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details on the format of this file, please refer to https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于该文件格式的更多细节，请参考 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `reflection-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.  If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面的片段中，我们能够简单地使用 `reflection-config.json` ，而不是指定文件的整个路径，只是因为它被添加到了 `src/main/resources` 。如果该文件被添加到了另一个目录，就必须手动指定适当的文件路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delaying class initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>推迟类的初始化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus initializes all classes at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus在构建时初始化所有类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases where the initialization of certain classes is done in a static block needs to be postponed to runtime.  Typically omitting such configuration would result in a runtime exception like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些情况下，某些类的初始化是在静态块中完成的，需要推迟到运行时。通常情况下，省略这样的配置会导致运行时的异常，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to delay the initialization of a class, you can use the `--initialize-at-run-time=&lt;package or class&gt;` configuration knob.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要延迟一个类的初始化，你可以使用 `--initialize-at-run-time=&lt;package or class&gt;` 配置旋钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should be added to the `native-image` configuration using the `quarkus.native.additional-build-args` configuration property as shown in the examples above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它应该使用 `quarkus.native.additional-build-args` 配置属性添加到 `native-image` 配置中，如上面的例子所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about all this in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[GraalVM的文档]中找到更多关于这一切的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes or packages need to be specified via the `quarkus.native.additional-build-args` configuration property, the `,` symbol needs to be escaped.  An example of this is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当需要通过 `quarkus.native.additional-build-args` 配置属性指定多个类或包时，需要对 `,` 符号进行转义。这方面的一个例子如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and in the case of using the Maven configuration instead of `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以及在使用Maven配置而不是 `application.properties` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing Proxy Classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理代理类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While writing native application you'll need to define proxy classes at image build time by specifying the list of interfaces that they implement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写本地应用程序时，你需要在图像构建时通过指定它们实现的接口列表来定义代理类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such a situation, the error you might encounter is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，你可能遇到的错误是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solving this issue requires adding the `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` option and to provide a dynamic proxy configuration file.  You can find all the information about the format of this file in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md#manual-configuration[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决这个问题需要添加 `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` 选项，并提供一个动态代理配置文件。你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md#manual-configuration[GraalVM文档]中找到关于这个文件格式的所有信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in a Quarkus extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus扩展中支持原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in a Quarkus extension is even easier as Quarkus provides a lot of tools to simplify all this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus扩展中支持本机更容易，因为Quarkus提供了很多工具来简化这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything described here will only work in the context of Quarkus extensions, it won't work in an application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里描述的一切只在Quarkus扩展的范围内起作用，在应用程序中不会起作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>登记反射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes registration of reflection in an extension a breeze by using `ReflectiveClassBuildItem`, thus eliminating the need for a JSON configuration file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过使用 `ReflectiveClassBuildItem` ，使得在扩展中注册反射变得轻而易举，从而消除了对JSON配置文件的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To register a class for reflection, one would need to create a Quarkus processor class and add a build step that registers reflection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要为反射注册一个类，需要创建一个Quarkus处理器类并添加一个注册反射的构建步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information about reflection in GraalVM can be found https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于GraalVM中反射的更多信息可以 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[在这里] 找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the context of an extension, Quarkus eliminates the need for a JSON configuration file by allowing extension authors to specify a `NativeImageResourceBuildItem`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在扩展的背景下，Quarkus通过允许扩展的作者指定一个 `NativeImageResourceBuildItem` 来消除对JSON配置文件的需求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about GraalVM resource handling in native executables please refer to https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于本地可执行文件中GraalVM资源处理的更多信息，请参考 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delay class initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>延迟类的初始化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus simplifies things by allowing extensions authors to simply register a `RuntimeInitializedClassBuildItem`. A simple example of doing so could be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过允许扩展作者简单地注册一个 `RuntimeInitializedClassBuildItem` 来简化操作。这样做的一个简单例子是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a construct means that a `--initialize-at-run-time` option will automatically be added to the `native-image` command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用这样的结构意味着 `--initialize-at-run-time` 选项将被自动添加到 `native-image` 命令行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about `--initialize-at-run-time`, please read https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于 `--initialize-at-run-time` 的更多信息，请阅读 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very similarly, Quarkus allows extensions authors to register a `NativeImageProxyDefinitionBuildItem`. An example of doing so is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非常相似的是，Quarkus允许扩展作者注册一个 `NativeImageProxyDefinitionBuildItem` 。这样做的一个例子是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a construct means that a `-H:DynamicProxyConfigurationResources` option will automatically be added to the `native-image` command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用这样的结构意味着 `-H:DynamicProxyConfigurationResources` 选项将被自动添加到 `native-image` 命令行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about Proxy Classes you can read https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于代理类的更多信息，你可以阅读 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging with Native Image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用原生镜像日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using dependencies that require logging components such as Apache Commons Logging or Log4j and are experiencing a `ClassNotFoundException` when building the native executable, you can resolve this by excluding the logging library and adding the corresponding JBoss Logging adapter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在使用需要日志组件（如Apache Commons logging或Log4j）的依赖，并且在构建原生可执行文件时遇到了' ClassNotFoundException '，你可以通过排除日志库并添加相应的JBoss日志适配器来解决这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details please refer to the xref:logging.adoc#logging-adapters[Logging guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节请参考 xref:logging.adoc#logging-adapters[日志指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with JPA</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JPA的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式SQL客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Hibernate响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测量你的测试的覆盖率</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Heroku</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到Heroku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate ORM with Panache and Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Panache和Kotlin简化Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Blaze-Persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Blaze-Persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started to SmallRye Reactive Messaging with Apache Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始使用Apache Kafka的SmallRye响应式消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的Quarkus应用程序如何利用SmallRye响应式消息传递与Apache Kafka进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuous Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持续测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate Reactive with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化的Hibernate 响应式与Panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名称</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation with Hibernate Validator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Hibernate验证器进行验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Re-augment a Quarkus Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重新增强Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Eclipse Vert.x API from a Quarkus Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus应用程序中使用Eclipse Vert.x API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications can access and use the Vert.x APIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序能够访问和使用Vert.x APIs。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide presents how you can build a Quarkus application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南介绍如何使用以下方法构建 Quarkus 应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Vert.x event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Vert.x Web Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 网络客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's an introductory guide.  The xref:vertx-reference.adoc[Vert.x reference guide] covers more advanced features such as verticles, and native transports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一项介绍性的指南。 link:vertx-reference.html[Vert.x参考指南] 涵盖了更多的高级功能，例如 verticles 和 本地传输 (native transports) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to build a simple application exposing four HTTP endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将构建一个简单应用程序 它包含四个暴露出的端点:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/vertx/book` returns the content from a large file (a book)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/vertx/book` 返回一个大文件的内容（一本书）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the following sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照下一节的说明逐步创建应用程序。然而，你也可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `vertx-quickstart` {quickstarts-tree-url}/vertx-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `vertx-quickstart` {quickstarts-tree-url}/vertx-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide uses the Mutiny API.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive, reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南使用Mutiny API。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的、响应式的编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引导启动该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on https://code.quarkus.io/?a=quarkus-getting-started-vertx&amp;nc=true&amp;e=resteasy-reactive-jackson&amp;e=vertx[this link] to configure your application.  It selected a few extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 link:https://code.quarkus.io/?a=quarkus-getting-started-vertx&amp;nc=true&amp;e=resteasy-reactive-jackson&amp;e=vertx[这个链接] 来配置你的应用程序。它选择了几个扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`resteasy-reactive-jackson`, which also brings `resteasy-reactive`. We are going to use it to expose our HTTP endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`resteasy-reactive-jackson` ，它也带来了 `resteasy-reactive` 。我们将使用它来暴露出我们的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`vertx`, which provides access to the underlying managed Vert.x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`vertx` ，它提供了对底层管理的Vert.x的访问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on the `Generate your application` button, download the zip file and unzip it.  Then, open the project in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `生成你的应用程序` 按钮，下载压缩文件并解压。然后，在你喜欢的编辑器中打开该项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you open the generated build file, you can see the selected extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你打开生成的构建文件，你可以看到以下选定的扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are in your build file, add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的构建文件中，添加以下依赖项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the Vert.x Web Client, which we will be using to implement the `/web` endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该依赖项提供了Vert.x Web客户端，我们将用它来实现 `/web` 端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问被管理的Vert.x实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/VertxResource.java` file.  It will contain our HTTP endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/VertxResource.java` 文件。它将包含我们的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this file, copy the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在该文件中，拷贝以下代码:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the root HTTP path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>声明HTTP根路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use constructor injection to receive the managed Vert.x instance. Field injection works too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用构造函数注入的方式来接收被管理的Vert.x实例。当然 字段注入也被允许。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receives the Vert.x instance as a constructor parameter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收Vert.x实例作为构造函数的参数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Store the managed Vert.x instance into a field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将被管理的Vert.x实例存储到一个字段当中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, we can start implementing the endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了这些，我们就可以开始实现端点了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x Core API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x核心API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance provides a set of APIs you can use.  The one we are going to use in this section is the Vert.x File System.  It provides a non-blocking API to access files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>被注入的Vert.x实例提供了一组你可以使用的API。我们在本节中要使用的是Vert.x文件系统。它提供了一个非阻塞的API来访问文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `src/main/resource` directory, create a `lorem.txt` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `src/main/resource` 目录中，创建一个包含以下内容的 `lorem.txt` 文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, in the `VertxResource` file add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，在 `VertxResource` 文件中添加以下方法:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint handles HTTP `GET` request on path `/lorem` (so the full path will be `vertx/lorem`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该端点处理路径 `/lorem` 上的 HTTP `GET` 请求（因此完整路径是 `vertx/lorem` ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the Vert.x API is asynchronous, our method returns a `Uni`. The content is written into the HTTP response when the asynchronous operation represented by the Uni completes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于Vert.x API是异步的，我们的方法返回一个 `Uni` 对象 。当Uni所代表的异步操作完成后，内容将会被写入HTTP响应中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the Vert.x file system API to read the created file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用Vert.x文件系统API来读取创建的文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the file is read, the content is stored in an in-memory buffer.  We transform this buffer into a String.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦文件被读取，其内容就被存储在一个内存缓冲区内。我们将这个缓冲区的内容转换为一个字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a terminal, navigate to the root of the project and run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在终端中，切换到项目根目录下 运行以下命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see the content of the file printed in the console.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你应该会在控制台中看到打印的文件内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides other ways to serve static files. This is an example made for the guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了其他方式来处理静态文件。这是专为该指南制作的一个例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x stream capability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x流的功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading a file and storing the content in memory works for small files, but not big ones.  In this section, we will see how you can use Vert.x streaming capability.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>读取文件并将内容存储在内存中适用于小文件，但不适用于大文件。在本节中，我们将带领你了解如何使用 Vert.x 流功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, download https://www.gutenberg.org/files/2600/2600-0.txt[War and Peace] and store it in `src/main/resources/book.txt`.  It's a 3.2 Mb file, which, while not being huge, illustrates the purpose of streams.  This time, we will not accumulate the file's content in memory and write it in one batch, but read it chunk by chunk and write these chunks into the HTTP response one by one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，下载 link:https://www.gutenberg.org/files/2600/2600-0.txt[《战争与和平] 》，并将其存储在 `src/main/resources/book.txt` 。这是一个3.2Mb的文件，虽然不是很大，但说明了流的用途。这一次，我们将不会把文件的内容堆积在内存中并一次性写入，而是逐块读取，并把这些块逐一写入到HTTP响应中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, you should have the following files in your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，你的项目中应该包含以下文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following method to the `VertxResource` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将以下方法添加到 `VertxResource` 类中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time, we return a Multi as we want to stream the chunks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这一次，我们返回一个Multi类型的对象，因为我们想要流式地处理这些块</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We open the file using the `open` method. It returns a `Uni&lt;AsyncFile&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用 `open` 方法打开该文件。它返回一个 `Uni&lt;AsyncFile&gt;` 类型的对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the file is opened, we retrieve a `Multi` which will contain the chunks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当文件被打开时，我们获得到一个 `Multi` ，它包含了块的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each chunk, we produce a String</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于每个块，我们生成一个字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To visually see the chunks in the response, we append a separator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了直观地看到响应中的分块，我们添加了一个分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, in a terminal, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，在终端中，运行以下命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should retrieve the book content.  In the output you should see the separator like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它应该获取到书籍的内容。在输出中，你应该会看到像这样包含分隔符的内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the core features of Vert.x is the https://vertx.io/docs/vertx-core/java/#event_bus[event bus].  It provides a message-based backbone to your application.  So, you can have components interacting using asynchronous message passing, and so decouple your components.  You can send a message to a single consumer, or dispatch to multiple consumers, or implement a request-reply interaction, where you send a message (request) and expect a response.  This is what we are going to use in this section.  Our `VertxResource` will send a message containing a name to the `greetings` address.  Another component will receive the message and produce the "hello $name" response.  The `VertxResource` will receive the response and return it as the HTTP response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 的核心特点之一是 https://vertx.io/docs/vertx-core/java/#event_bus[事件总线]。它为你的应用程序提供了基于消息的主干。因此，你可以使用异步消息传递的方式在组件之间进行交互，并且将你的组件解耦。您可以向单个消费者发送消息，或分派给多个消费者，亦或是实现请求-响应的交互，在其中发送消息（请求）并期许响应。这是我们将在本节中使用的内容。我们的 `VertxResource`  将向问候地址发送一条包含姓名的消息。另一个组件将会接收到这条消息并生成 "hello $name" 的响应。 `VertxResource` 将收到响应并将其作为 HTTP 响应进行返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, first, let's extend our `VertxResource` class with the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，首先，让我们使用以下代码来扩展我们的 `VertxResource` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Inject the event bus. Alternatively you can use `vertx.eventBus()`.
&lt;2&gt; We receive a _name_ as a query parameter
&lt;3&gt; We use the `request` method to initiate the request-reply interaction. We send the name to the "greetings" address.
&lt;4&gt; When the response is received, we extract the body and return it as the HTTP response
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 注入事件总线。或者你可以使用 `vertx.eventBus()` 
&lt;2&gt; 我们接收到一个姓名作为查询参数 
&lt;3&gt; 我们使用 `request` 方法来发起请求-回复的交互。我们将姓名发送到 "greetings" 地址 
&lt;4&gt; 收到响应后，我们提取正文并将其作为 HTTP 响应进行返回 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we need the other side: the component receiving the name and replying.
Create the `src/main/java/org/acme/GreetingService.java` file with the following content:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，我们需要另一侧: 接收姓名并回复的组件。
使用以下内容创建 `src/main/java/org/acme/GreetingService.java` 文件:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Declaring a CDI Bean in the Application scope. Quarkus will create a single instance of this class.
&lt;2&gt; Use the `@ConsumeEvent` annotation to declare a consumer. It is possible to use the Vert.x API https://vertx.io/docs/vertx-core/java/#_acknowledging_messages_sending_replies[directly] too.
&lt;3&gt; Receive the message payload as a method parameter. The returned object will be the reply.
&lt;4&gt; Return the response. This response is sent back to the `VertxResource` class
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 以 Application scope 声明一个 CDI Bean。 Quarkus 将会为此类创建一个单实例对象。
&lt;2&gt; 使用 `@ConsumeEvent` 注解声明一个消费者. 你也可以直接使用 Vert.x API https://vertx.io/docs/vertx-core/java/#_acknowledging_messages_sending_replies[directly] 。
&lt;3&gt; 接收消息负载作为方法的参数。返回的对象将会被作为回复。
&lt;4&gt; 返回该响应。该响应将会被发送回 `VertxResource` 类
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try this.
In a terminal, run:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们试试这个。
在终端中，运行以下命令:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should get the expected `Hello bob` message back.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你应该会收到预期的 `Hello bob` 消息。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we have used the Vert.x Core API.  Vert.x offers much more.  It provides a vast ecosystem.  In this section, we will see how you can use the Vert.x Web Client, a reactive HTTP client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们已经使用了 Vert.x 核心 API。 Vert.x 提供的不仅仅是这些。它提供了一个广阔的生态系统。在本节中，我们将会带你了解如何使用 Vert.x Web 客户端 - 一个响应式 HTTP 客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that some Quarkus extensions are wrapping Vert.x clients and manage them for you.  That's the case for the reactive data sources, Redis, mail...  That's not the case with the Web Client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，部分 Quarkus 扩展正在封装 Vert.x 客户端并为您管理它们。如响应式数据源、Redis、邮件等...  但Web 客户端，并不在此行列之内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, at the beginning of the guide, we added the `smallrye-mutiny-vertx-web-client` dependency to our `pom.xml` file.  It's now time to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请记住，在本指南的开头，我们将 `smallrye-mutiny-vertx-web-client` 作为依赖项添加到了我们的 pom.xml 文件中。现在，是时候使用它了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create an instance of `WebClient`.  Extend the `VertxResource` class with the `client` field and the creation of the web client in the constructor:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要创建一个 `WebClient` 的实例。使用 client 字段扩展 `VertxResource` 类并在构造函数中创建 Web 客户端:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Store the `WebClient`, so we will be able to use it in our HTTP endpoint
&lt;2&gt; Create the `WebClient`. Be sure to use the `io.vertx.mutiny.ext.web.client.WebClient` class
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 存储 `WebClient`，以便我们在 HTTP 端点中使用它
&lt;2&gt; 创建 `WebClient`。确保使用 `io.vertx.mutiny.ext.web.client.WebClient` 类
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now implement a new HTTP endpoint that queries the Wikipedia API to retrieve the pages about Quarkus in the different languages.
Add the following method to the `VertxResource` class:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们实现一个新的 HTTP 端点，它通过查询 Wikipedia API 以检索不同语言有关 Quarkus 的页面。
将以下方法添加到 `VertxResource` 类中:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; This endpoint returns a JSON Array. Vert.x provides a convenient way to manipulate JSON Object and Array. More details about these in xref:vertx-reference.adoc#using-vert-x-json[the reference guide].
&lt;2&gt; Send a `GET` request to the Wikipedia API
&lt;3&gt; Once the response is received, extract it as a JSON Object
&lt;4&gt; Extract the `langlinks` array from the response.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 该端点返回一个 JSON 数组。Vert.x 提供了一种便捷的方式来操作 JSON 对象和数组。 有关这些的更多详细信息，请参阅 xref:vertx-reference.adoc#using-vert-x-json[参考指南] 
&lt;2&gt; 向 Wikipedia API 发送 `GET` 请求 
&lt;3&gt; 收到响应后，将其提取为 JSON 对象 
&lt;4&gt; 从响应中提取 `langlinks` 数组 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, invoke the endpoint using:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，使用以下命令请求该端点:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response indicates that, in addition to the English page, there are a German and a French page about Quarkus on wikipedia.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该响应表明，除了英文页面，维基百科上还有关于 Quarkus 的德文和法文页面。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide introduced how you can use Vert.x APIs from a Quarkus application.  It's just a brief overview.  If you want to know more, check the xref:vertx-reference.adoc[reference guide about Vert.x in Quarkus].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在 Quarkus 应用程序中使用 Vert.x API。这只是一个简短的概述。如果你想了解更多信息，请查看 xref:vertx-reference.adoc[Quarkus 中有关 Vert.x 的参考指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen, the event bus is the connecting tissue of Vert.x applications.  Quarkus integrates it so different beans can interact with asynchronous messages.  This part is covered in the xref:reactive-event-bus.adoc[event bus documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如我们所见，事件总线是 Vert.x 应用程序之间的连接桥梁。 Quarkus 集成了它，因此不同的bean之间能够以异步消息的方式进行交互。这部分内容包含在 xref:reactive-event-bus.adoc[事件总线文档] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to implement highly performant, low-overhead database applications on Quarkus with the xref:reactive-sql-clients.adoc[Reactive SQL Clients].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用 xref:reactive-sql-clients.adoc[响应式SQL客户端] 在 Quarkus 上实现高性能、低开销的数据库应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client with Multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Multipart的REST客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式路由</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始使用gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add business automation capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加业务自动化功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Kogito to add business automation to power it up with business processes and rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用Kogito来添加业务自动化，从而为其提供业务流程和规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using JWT RBAC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JWT RBAC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-standard Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非标准功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using our Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用我们的工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application. In addition there are plugins and extensions to all major IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个工具链，支持开发人员从实时重新加载一直到部署Kubernetes应用程序。此外，所有主流IDE都有插件和扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will explore:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将探讨：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何在你的IDE中开发应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choosing your build tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选择您的构建工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.  You can use Maven or Gradle as build tool.  And we offer a CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带的工具链可以在各个开发阶段帮助你。你可以使用Maven或Gradle作为构建工具。我们还提供了一个方便使用的CLI（即将推出）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:maven-tooling.adoc[Maven]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:maven-tooling.adoc[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:gradle-tooling.adoc[Gradle]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:gradle-tooling.adoc[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:cli-tooling.adoc[CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:cli-tooling.adoc[CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:ide-tooling.adoc[IDE]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:ide-tooling.adoc[IDE]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Apache Kafka Streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka Streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用如何利用Apache Kafka Streams API来实现基于Apache Kafka的流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HashiCorp Vault with Databases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在数据库中使用HashiCorp Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>证书提供者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南以 link:getting-started[入门指南]中开发的应用程序作为输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel目前只推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着Mandrel用户应该使用容器来构建他们的原生可执行文件。如果你正在为macOS或Windows目标平台构建原生可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前并不针对这些平台。直接在裸金属Linux上构建原生可执行文件是可能的，详细信息请参见 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel releases]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The prerequisites vary slightly depending on whether you are using Oracle GraalVM CE/EE or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前提条件依据您使用的是Oracle GraalVM CE/EE还是Mandrel略有不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Java 11 version of GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装Java 11版本的GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Oracle GraalVM is available for both Java 8 and Java 11 (Mandrel only supports Java 11), Quarkus only works with the Java 11 version.  If you use the Oracle distribution, make sure to install the Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Oracle GraalVM在Java 8和Java 11上都可以使用(Mandrel只支持Java 11)，而Quarkus只支持Java 11版本。如果您使用Oracle发行版，请确保安装Java 11版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide using Mandrel, you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用Mandrel完成本指南，你需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序开发的代码在 link:getting-started[入门指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skip to &lt;&lt;#container-runtime,this section&gt;&gt; to continue with the guide for Mandrel, and follow the Mandrel-specific instructions in that section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>跳转到 &lt;&lt;#container-runtime,this section&gt;&gt; 继续指导Mandrel，并遵循该节中特定于Mandrel的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM version {graalvm-version} (be sure to install the Java 11 support) installed and xref:configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM的版本 {graalvm-version} （确保安装了Java 11支持）已安装并且 xref:configuring-graalvm[配置适当]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM (pick the java 11 version) if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果还没有安装GraalVM（选择java 11版本），您有几个选择：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用平台特定的安装工具，如 https://github.com/graalvm/homebrew-tap[homebrew]，https://sdkman.io/jdks#Oracle[sdkman]，或 https://github.com/ScoopInstaller/Java[scoop]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate Community Edition archive from &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.  Make sure to download and install at Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;下载适当的社区版归档文件，然后像解包其他JDK一样解包。确保Java 11版本已经下载并安装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS, point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在macOS中，将变量指向 `Home` 子目录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `gu install` 安装 `native-image` 工具：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用： `./mvnw package -Pnative` 创建一个原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the future, `@NativeImageTest` will be deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the link:getting-started-testing#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在未来， `@NativeImageTest` 将被弃用，取而代之的是`@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 link:getting-started-testing#quarkus-integration-test[测试指南]中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:container-image[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节见 link:container-image[容器镜像指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手工</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>产生的可执行文件将是一个64位的Linux可执行文件，所以取决于您的操作系统，它可能不再能够运行。然而，这不是一个问题，因为我们要把它复制到一个容器中。生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided `Dockerfiles` use https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI] (Universal Base Image) as parent image.  This base image has been tailored to work perfectly in containers.  The `Dockerfiles` use the https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version] of the base image to reduce the size of the produced image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供的 `Dockerfiles` 使用 https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI]（通用基础镜像）作为父镜像。这个基础镜像经过量身定做，可以在容器中完美工作。 `Dockerfiles` 使用基础镜像的 https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version]来减小生成镜像的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI on:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在以下网站阅读更多关于UBI的信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[the _UBI-minimal_ image page]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[ _UBI-minimal_ image 页面]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/containers/?tab=tags#/registry.access.redhat.com/ubi8/ubi-minimal[the list of _UBI-minimal_ tags]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/containers/?tab=tags#/registry.access.redhat.com/ubi8/ubi-minimal[ _UBI-minimal_ 标签列表]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This multi-stage Docker build copies the Maven wrapper from the host machine.  The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.  It avoids having to create a base image with Maven and Gradle.  To provision the Maven Wrapper in your project, use: `mvn -N io.takari:maven:0.7.7:wrapper`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种多阶段Docker构建从主机上复制Maven包装器。Maven包装器（或Gradle包装器）是提供特定版本Maven/Gradle的一种便捷方式。它避免了用Maven和Gradle创建一个基础镜像。要在项目中配置Maven包装器，请使用： `mvn -N io.takari:maven:0.7.7:wrapper`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:native-and-ssl#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息请参见 link:native-and-ssl#working-with-containers[我们的使用SSL与原生可执行文件指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a distroless base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用无发行版基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Oracle GraalVM 20.2或Mandrel 20.1开始，可以为Linux环境生成本地可执行文件的调试符号（Windows支持仍在开发中）。这些符号可用于用工具调试本地可执行文件，如 `gdb` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions and macOS you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.debug` 文件的生成取决于 `objcopy` 。在常见的Linux发行版和macOS上，你将需要安装 `binutils` 包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the link:deploying-to-kubernetes[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议继续阅读 link:deploying-to-kubernetes[部署到Kubernetes和OpenShift]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java 11+ installed with `JAVA_HOME` configured appropriately.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 11+安装并适当配置了 `JAVA_HOME` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters passed to the application are described in the datasource guide.  There are other ways to configure the application - please check the link:config-reference#configuration_sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传递给应用程序的参数在数据源指南中进行了描述。还有其他配置应用程序的方法 - 请查看 link:config-reference#configuration_sources[配置指南]来概览各种可能性（例如env变量，.env文件等等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using WebSockets with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebSockets与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM, Docker or Podman installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想以本地模式运行，请确保已经安装GraalVM、Docker或Podman。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To let a user easily try out the service, we will implement an HTTP resource summing up the costs (`CostCollector`), and a simple web page to add new costs and watch the sum.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了让用户轻松试用该服务，我们将实现一个 HTTP 资源来汇总成本 ( `CostCollector` )，以及一个简单的网页来添加新的成本并查看总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Converter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>转换器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume messages from the `incoming-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 `incoming-costs` 流中消费消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dispatch returned values to the `outgoing-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送返回值到 `outgoing-costs` 流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's define the `Cost` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们定义 `Cost` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the next step, we will create configurations for both streams in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下一步，我们将在 `application.properties` 文件中为这两个流创建配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.{property}=value`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.{property}=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CostCollector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>成本收集器（The CostCollector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To conveniently interact with the application, let's create a simple web page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了方便地与应用程序交互，让我们创建一个简单的网页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The page will provide a form to add costs, and an info of the current sum of costs.  The page periodically updates the sum by requesting the current sum from `/cost-collector`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该页面将提供一个表格用以添加成本，以及展示当前成本总和的信息。 该页面通过请求 `/cost-collector` 来定期更新当前成本的总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令运行应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/index.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在您的浏览器中打开 `http://localhost:8080/index.html`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension utilizes SmallRye Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此扩展利用 SmallRye 响应式消息来构建数据流应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想进一步了解文档 https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], 在Quarkus中使用的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with HashiCorp Vault’s Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与HashiCorp Vault的认证合作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HTTP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用HTTP与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce HTTP messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye响应式消息传递来消费和提供HTTP消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will implement a service, namely `CostConverter` that consumes HTTP messages with costs in multiple currencies and converts each cost to its value in Euro.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中我们将实现一项服务，名为 `CostConverter` ，它将以多种货币成本的方式消费 HTTP 消息，并将每个成本转换为其以欧元为单位的价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `reactive-messaging-http-quickstart` {quickstarts-treeurl}/reactive-messaging-http-quickstart[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and HTTP connector extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven项目，导入Reactive Messaging和HTTP 连接扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/reactivehttp/CostConverter.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/reactivehttp/CostConverter.java` 文件，内容如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume an event with payload of type `Cost` and produce a `double`.  In the case of consuming an arbitrary object, the reactive-messaging-http extension will attempt to deserialize the request body as a JSON object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费一个具有 `Cost` 类型的有效载荷的事件，并生成一个 `double` 。在消费任意一个对象的情况下，reactive-messaging-http 扩展将尝试把请求体反序列化为一个JSON对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the HTTP connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置HTTP连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the HTTP connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要配置HTTP连接器。这是在 `application.properties` 文件中完成的。 键的结构如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To illustrate that converting messages and passing them through works, let's add an endpoint that will receive the outgoing costs and sum them up.  This is a usual JAX-RS endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了说明转换消息和传递消息是可行的，让我们添加一个端点来接收传出成本并将它们相加。 这是一个常见的 JAX-RS 端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/index.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/resources/META-INF/resources/index.html` 文件, 包含以下内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `quarkus-http` connector options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有 `quarkus-http` 连接器选项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Message payload serializer, optional, implementation of `io.quarkus.reactivemessaging.http.runtime.serializers.Serializer`
mp.messaging.outgoing.&lt;channelName&gt;.serializer=com.example.MySerializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 消息负载序列化器，可选的， `io.quarkus.reactivemessaging.http.runtime.serializers.Serializer` 的实现
mp.messaging.outgoing.&lt;channelName&gt;.serializer=com.example.MySerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># The number of attempts to make for sending a request to a remote endpoint. Must not be less than zero
# Zero by default
mp.messaging.outgoing.&lt;channelName&gt;.maxRetries=3
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 尝试向远程端点发送请求的次数。不得小于零
# 默认为0
mp.messaging.outgoing.&lt;channelName&gt;.maxRetries=3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configures the random factor when using back-off with maxRetries &gt; 0. 0.5 by default
mp.messaging.outgoing.&lt;channelName&gt;.jitter=0.3
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 配置当使用回退且maxRetries &gt; 0时使用的随机因子。 默认为0.5
mp.messaging.outgoing.&lt;channelName&gt;.jitter=0.3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configures a back-off delay between attempts to send a request.
# A random factor (jitter) is applied to increase the delay when several failures happen.
mp.messaging.outgoing.&lt;channelName&gt;.delay=1s
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 配置尝试发送请求之间的回退延迟。
# 当发生多个故障时，随机因子（抖动）被使用来增加延迟。
mp.messaging.outgoing.&lt;channelName&gt;.delay=1s
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#The HTTP method (either `POST` or `PUT`), `POST` by default
mp.messaging.outgoing.&lt;channelName&gt;.method=PUT
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>#HTTP 请求方式 ( `POST` 或 `PUT` ),默认为 `POST` 
mp.messaging.outgoing.&lt;channelName&gt;.method=PUT
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#INCOMING
# The HTTP method (either `POST` or `PUT`, `POST` by default
mp.messaging.incoming.&lt;channelName&gt;.method=POST
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>#INCOMING
# HTTP 请求方式 ( `POST` 或 `PUT` ,默认为 `POST` 
mp.messaging.incoming.&lt;channelName&gt;.method=POST
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:cli-tooling[CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:cli-tooling[CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel目前只推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着Mandrel用户应该使用容器来构建他们的原生可执行文件。如果你正在为macOS或Windows目标平台构建原生可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前并不针对这些平台。直接在裸金属Linux上构建原生可执行文件是可能的，详细信息请参见 https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel releases]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会等待60秒，等待原生镜像启动，然后原生测试自动失败。这个持续时间可以通过 `quarkus.test.native-image-wait-time` 系统属性来改变。例如，要将持续时间增加到300秒，可以使用： `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in tiny Docker images, check the {quarkus-images-url}/master/distroless[distroless] version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您对小型Docker镜像感兴趣，请查看 {quarkus-images-url}/master/distroless[无发行版]版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven, but implicitly required that the proper GraalVM version be installed on the building machine (be it your local machine or your CI/CD infrastructure).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上一节向您展示了如何使用Maven构建原生可执行文件，但隐式地要求在构建机器上安装适当的GraalVM版本(无论是您的本地机器还是CI/CD基础设施)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In cases where the GraalVM requirement cannot be met, you can use Docker to perform the Maven or Gradle build by using a multi-stage Docker build. A multi-stage Docker build is like two Dockerfile files combined in one, the first is used to build the artifact used by the second.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在GraalVM的需求不能满足的情况下，你可以使用Docker通过使用多阶段Docker构建来执行Maven或Gradle构建。一个多阶段的Docker构建就像两个Dockerfile文件合并在一起，第一个用来构建，第二个使用工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will use the first stage to generate the native executable and the second stage to create our runtime image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将使用第一阶段生成原生可执行文件，第二阶段创建运行时镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory and as we plan to build inside a container we need to be able to copy the `src` directory. So edit your `.dockerignore` and remove or comment its content.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在启动我们的Docker构建之前，我们需要更新默认的 `.dockerignore` 文件，因为它过滤了除 `target` 目录之外的所有内容，而我们计划在容器中构建时，我们需要能够复制 `src` 目录。所以编辑你的 `.dockerignore` 并删除或注释其内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用Quarkus创建响应式应用程序，并探索Quarkus提供的不同响应式功能。 本指南涵盖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quick glance at the Quarkus engine and how it enables reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>快速浏览一下Quarkus引擎和它如何实现响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bootstrap of a reactive application using RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RESTEasy Reactive 的响应式应用程序的引导</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建响应式 JAX-RS 端点（异步、流等）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式数据库访问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与其他响应式API交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solutions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案位于 `getting-started-reactive` 和 `getting-started-reactive-crud` 目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是响应式的。如果您仔细观察，就会发现一个为Quarkus应用程序提供动力的响应式引擎。这个引擎就是Eclipse Vert.x (https://vertx.io)。所有网络I/O都通过非阻塞和响应性的 Vert.x 引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们举两个例子来解释它是如何工作的。想象一个传入的HTTP请求。嵌入在Quarkus中的 (Vert.x) HTTP服务器接收请求，然后将其路由到应用程序。如果请求的目标是一个 _imperative_ 方法（传统的JAX-RS，代码注释为 `@Blocking`…），路由层在 _worker_ 线程中调用资源方法，并在数据可用时写入响应。到目前为止，还没有什么新的或突出的。下图描述了这种行为。在这种情况下，应用程序代码是在工作线程上调用的，而业务逻辑会阻塞该线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，如果HTTP请求的目标是一个响应式方法（JAX-RS使用RESTEasy响应式，响应式路由， `@Incoming` 方法没有注释 `@Blocking`…），路由层会在I/O线程上调用路由，这会带来很多好处，比如更高的并发性和性能：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为Quarkus使用I/O线程来调用代码，所以我们节省了上下文切换，避免了大型线程池管理，从而提高了资源利用率。但是，代码必须 **NOT** 阻塞该线程。为什么？因为，I/O线程用于处理多个并发请求。一旦一个请求的处理因为需要执行一些I/O而无法进行，它就会调度这些I/O，并传递一个延续。它释放可以处理另一个请求的线程。当计划的I/O完成时，继续执行，返回到I/O线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，许多Quarkus组件在设计时都考虑了响应式，比如数据库访问（PostgreSQL, MySQL, Mongo等），应用服务（邮件，模板引擎等），消息传递（Kafka, AMQP等）等等。但是，要完全受益于此模型，应用程序代码应该以非阻塞的方式编写。这就是运用一个响应式API这个终极武器的地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny]是一个响应式编程库，允许表达和组合异步动作。它提供两种类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.mutiny.Multi` - 用于多条目(回压)流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这两种类型都是惰性的，并且遵循订阅模式。计算只在有实际需要时才开始（即订阅者登记）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Uni` 和 `Multi` 都公开了事件驱动的API：你表达了在给定事件上你想做什么(成功，失败等)。这些API被分成组（操作类型），以使其更具表达性，并避免将100个方法附加到单个类上。主要的操作类型是对失败、完成、操作项、提取或收集它们作出反应。它提供了一种流畅的编码体验，具有可导航的API，并且结果不需要太多关于响应式的知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能想知道响应流 (https://www.reactive-streams.org/)。  `Multi` 实现了响应流 `Publisher`，因此实现了响应流回压机制。  `Uni` 没有实现 `Publisher` ，因为' Uni '的订阅足以表明你对结果感兴趣。由于响应流的订阅/请求仪式更加复杂，所以它再次考虑了更简单、更流畅的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拥抱来自Quarkus的响应和指令支柱的统一， `Uni` 和 `Multi` 都为指令式结构提供了桥梁。例如，你可以将 `Multi` 转换为 `Iterable` ，或者 _await_ `Uni` 生成元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这一点上，如果你是RxJava或Reactor的用户，你可能想知道如何使用你熟悉的 `Flowable`，`Single`，`Flux`，`Mono`… Mutiny允许从 `Unis` 和 `Multis` 到RX Java和Reactor类型的转换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，Vert.x呢？Vert.x API也可以使用Mutiny类型。下面的代码片段展示了Vert.x Web 客户端的用法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后但并非最不重要的是，Mutiny内置了与MicroProfile上下文传播的集成，因此您可以在响应管道中传播事务、跟踪数据等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But enough talking, let's get our hands dirty!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>说得够多了，我们动手吧！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus实现响应式应用程序有几种方法。在本指南中，我们将使用RESTEasy Reactive，一个受益于Quarkus Reactive引擎的RESTEasy的实现。默认情况下，它调用I/O线程上的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然可以使用_traditional_ RESTEasy，但需要添加 `quarkus-resteasy-mutiny` 扩展，该方法仍然会在 _worker_ 线程上调用。因此，虽然它将使用响应式编程，但仍然需要工作线程，这与目的不符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux and macOS users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Linux和macOS用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd, (don't use forward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用cmd，（不要使用正斜杠 `\`）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell, wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用Powershell，请将 `-D` 参数用双引号括起来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started-reactive`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它会在 `./getting-started-reactive`中生成如下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive JAX-RS resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式 JAX-RS 资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在项目创建过程中， `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` 文件已经创建了以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello RESTEasy Reactive" to requests on "/hello".  As it uses RESTEAsy Reactive, this method is called on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常简单的REST端点，在 "/hello"上返回 "Hello RESTEasy Reactive" 请求。当它使用RESTEAsy响应式时，这个方法在I/O线程上被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要让Quarkus在_worker_线程上调用这个方法，请使用 `io.smallrye.common.annotation.Blocking` 注释它。你可以在一个方法、类上使用 ' @Blocking '，或者在整个应用中通过注释一个 `Application` 类来启用它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create a `ReactiveGreetingService` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们创建一个 `ReactiveGreetingService` 类，包含以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, edit the `ReactiveGreetingResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，编辑 `ReactiveGreetingResource` 类，以匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingService` 类包含一个生成 `Uni` 的简单方法。虽然在这个例子中，产生的条目是立即发出的，你可以想象任何异步API产生一个 `Uni`。我们将在本指南的后面讨论这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, start the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，使用以下命令启动应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行后，通过打开 http://localhost:8080/hello/greeting/neo 检查您是否得到了预期的问候信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们只返回一个异步结果。在本节中，我们使用传输多个条目的流来扩展应用程序。这些数据流可以来自Kafka或任何其他数据源，但为了简单起见，我们只生成周期性的问候消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingService`, add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `ReactiveGreetingService` 中，添加以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能需要添加 `import io.smallrye.mutiny.Multi;` 和 `import java.time.Duration;` 语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates a greeting message every second and stops after `count` messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它每秒钟生成一条问候信息，并在 `count` 信息后停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingResource` add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `ReactiveGreetingResource` 中添加以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个端点将项目以JSON数组的形式发送给客户端。消息的名称和数量用路径参数进行参数化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So calling the endpoint produces something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所以调用端点会产生如下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can also generate Server-Sent Event responses by returning a `Multi`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们也可以通过返回一个 `Multi` 来生成服务器发送的事件响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与前面代码片段唯一的区别是生成的类型和指示每个事件类型的 `@RestSseElementType` 注解。由于 `@Produces` 注解定义了 `SERVER_SENT_EVENTS`，JAX-RS需要它知道每个（嵌套）事件的内容类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能需要添加 `import org.jboss.resteasy.reactive.RestSseElementType;` 语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the result using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用以下命令看到结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式 API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Quarkus reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus响应式API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus使用Mutiny模型提供了许多响应式API。在本节中，我们将看到如何使用响应式PostgreSQL驱动程序以一种非阻塞和响应式的方式与数据库交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new project using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令创建一个新项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application is interacting with a PostgreSQL database, so you need one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个应用程序与一个PostgreSQL数据库交互，所以你需要一个：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，让我们配置数据源。打开 `src/main/resources/application.properties` 并添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第3行定义数据源。最后一行将在应用程序中用于指示在应用程序初始化时是否插入一些条目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们创建 _entity_。创建 `org.acme.reactive.crud.Fruit` 类具有以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 _entity_ 包含一些字段和方法，用于从数据库中查找、更新和删除行。当检索到结果时，所生成的项被异步触发，这些方法返回 `Unis` 或 `Multis` 。注意，响应式PostgreSQL客户端已经提供了 `Uni` 和 `Multi` 实例。因此，您只需将来自数据库的结果转换为 _business-friendly_ 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了在应用程序启动时初始化数据库，我们将创建一个名为 `DBInit` 的类，其内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，让我们在 `FruitResource` 中使用这个 `Fruit` 类。编辑 `FruitResource` 类，匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个资源根据 `Fruit` 类产生的结果返回 `Uni` 和 `Multi` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的示例使用了Quarkus提供的_service_。同样，你也可以直接使用Vert.x客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，确保存在 `quarkus-vertx` 扩展。如果没有激活扩展，请执行如下命令来激活：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or add `quarkus-vertx` into your dependencies manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者手动将 `quarkus-vertx` 添加到依赖项中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个Mutiny 版本的Vert.x的API。这个API被分为几个可以独立导入的工件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您还可以在 http://smallrye.io/smallrye-reactive-utils/apidocs/ 上查看可用的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example.  Add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们举个例子。添加以下依赖到你的应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它提供了Vert.x Web客户端的Mutiny API。然后，您可以使用如下web客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 important points:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有两点很重要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入的 Vert.x 实例是 `io.vertx.mutiny.core.Vertx` 类型，它是 Vert.x 的 Mutiny 变量；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Web客户端是从 `io.vertx.mutiny.ext.web.client.WebClient` 创建的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny version of the Vert.x APIs also offers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny 版本的 Vert.x API 还提供：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`andAwait` 方法，例如 `sendAndAwait`。 `andAwait` 表示调用方线程被阻塞，直到结果可用。注意不要用这种方式阻塞事件循环/ IO线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`andForget` 方法，如 `writeAndForget`。 `andForget` 可用于返回 `Uni` 的方法。  `andForget` 表示你不需要结果的 `Uni` 来表示操作的成功或失败。但是请记住，如果您不订阅，操作将不会被触发。  `andForget` 为您管理这个和管理订阅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RxJava or Reactor APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RxJava 或 Reactor API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny提供工具来将 RxJava 2 和 Project Reactor 类型转换为 `Uni` 和 `Multi`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RxJava 2 converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RxJava 2转换器有以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，如果你有一个返回RxJava 2类型 (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`) 的API，你可以创建 `Unis` 和 `Multis` ，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into RxJava types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以将 `Unis` 和 `Multis` 转换成 RxJava 类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Reactor converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目 Reactor 转换器在以下依赖项中可用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么如果你有一个API返回 Reactor 类型 (`Mono`, `Flux`)，你可以创建 `Unis` 和 `Multis` 如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into Reactor types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以将 `Unis` 和 `Multis` 转换为 Reactor 类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using CompletionStages or Publisher API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用CompletionStages或Publisher API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier&lt;CompletionStage&gt;`. For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你面对的是使用 `CompletionStage`, `CompletableFuture` 或 `Publisher` 的API，你可以来回转换。首先， `Uni` 和 `Multi` 都可以从 `CompletionStage` 或 `Supplier&lt;CompletionStage&gt;`创建。例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `Uni` 上，你也可以使用 `subscribeAsCompletionStage()` 来产生一个 `CompletionStage` 。 `CompletionStage` 会获得由 `Uni` 发出的条目或失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以使用 `createFrom().publisher(Publisher)` 从 `Publisher` 的实例中创建 `Unis` 和 `Multis` 。你可以使用 `toMulti` 将 `Uni` 转换为 `Publisher` 。事实上， `Multi` 实现了 `Publisher`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是关于Quarkus响应式的介绍。Quarkus 的许多特性已经具有了响应式风格。下面列出了一些例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mailer[Sending email]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mailer[发送电邮件]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:reactive-routes[Using reactive routes]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:reactive-routes[使用响应式路由]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an in memory data grid that allows running in a server outside of application processes. This extension provides functionality to allow the client that can connect to said server when running in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan是一个内存中的数据网格，允许在应用程序进程之外的服务器中运行。这个扩展提供了功能，允许在Quarkus中运行时可以连接到所述服务器的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use the CLI for your toolchain (coming soon)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何为你的工具链使用CLI（即将到来）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with WebAuthn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebAuthn的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use WebAuthn authentication instead of passwords.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用WebAuthn认证来代替密码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If building with Mandrel, make sure to use version Mandrel 22.1 or above, for example `ubi-quarkus-mandrel:22.1-java17`.  With older versions, you might encounter errors when trying to deserialize JSON documents that have null or missing fields, similar to the errors mentioned in the &lt;&lt;kotlin-jackson&gt;&gt; section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用Mandrel构建，确保使用Mandrel 22.1或以上的版本，例如 `ubi-quarkus-mandrel:22.1-java17` 。对于旧版本，当您试图反序列化有空字段或缺失字段的JSON文档时，可能会遇到错误，类似于 link:#kotlin-jackson&lt;&lt;kotlin-jackson&gt;&gt; 部分提到的错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring live reload compiler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置实时重载编译器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to customize the compiler flags used by `kotlinc` in development mode, you can configure them in the quarkus plugin:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要定制 `kotlinc` 在开发模式下使用的编译标志（compiler flags），您可以在quarkus插件中配置它们。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle (Groovy DSL)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle (Groovy DSL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle (Kotlin DSL)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，如果您使用Gradle Kotlin DSL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following extensions provide support for Kotlin Coroutines by allowing the use of Kotlin's `suspend` keyword on method signatures.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下扩展通过允许在方法签名上使用Kotlin的 `suspend` 关键字，为Kotlin Coroutines提供支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-resteasy-reactive`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-resteasy-reactive`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for JAX-RS Resource Methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为JAX-RS Resource方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-rest-client-reactive`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-rest-client-reactive`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for REST Client interface methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为REST客户端接口方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-reactive-messaging`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-reactive-messaging`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for Reactive messaging methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供对响应式信息传递方法的支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-scheduler`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-scheduler`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for scheduler methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为调度器方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-fault-tolerance`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-fault-tolerance`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for the declarative annotation-based API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对基于声明性注解的API提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin coroutines provide an imperative programming model that actually gets executed in an asynchronous, reactive manner.  To simplify the interoperability between Mutiny and Kotlin there is the module `io.smallrye.reactive:mutiny-kotlin`, described link:https://smallrye.io/smallrye-mutiny/guides/kotlin[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin coroutines提供了一个命令式的编程模型，实际上是以异步、响应式的方式执行。这里提供了一个模块 `io.smallrye.reactive:mutiny-kotlin` ，以简化Mutiny和Kotlin之间的互操作性 ，link:https://smallrye.io/smallrye-mutiny/guides/kotlin[在此] 描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `GreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要看到 `GreetingResourceIT` 面向原生可执行文件运行，使用 `./mvnw verify -Pnative` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This procedure was formerly accomplished using the `@NativeImageTest` annotation. `@NativeImageTest` is considered deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个过程以前是用 `@NativeImageTest` 注释来完成的。 `@NativeImageTest` 正考虑被废弃掉，而采用 `@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 xref:getting-started-testing.adoc#quarkus-integration-test[测试指南] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, integration tests both *build* and *run* the native executable using the `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，集成测试使用 `prod` 配置文件 *build* 和 *run* 原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable *runs* with during the test using the `quarkus.test.native-image-profile` property.  Either by adding it to `application.properties` or by appending it to the command line: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  Your `%test.` prefixed properties will be used at the test runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以在可执行文件 *runs* 测试期间覆盖配置文件的 `quarkus.test.native-image-profile` 属性。添加到 `application.properties` 或将其附加到命令行： `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`。您的 `%test.` 前缀属性将在测试运行时使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable is *built* with and *runs* with using the `quarkus-profile=test` property, e.g.  `./mvnw clean verify -Pnative -Dquarkus-profile=test`. This might come handy if there are test specific resources to be processed, such as importing test data into the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以使用 `quarkus-profile=test` 属性覆盖可执行文件 *built* 和 *runs* 的配置文件。例如 `./mvnw clean verify -Pnative -Dquarkus-profile=test`。如果要处理特定于测试的资源，例如将测试数据导入数据库，那么这可能会很方便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the aforementioned example in your `application.properties`, your Hibernate ORM managed database will be populated with test data both during the JVM mode test run and during the native mode test run. The production executable will contain only the `version.txt` resource, no superfluous test data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面提到的 `application.properties` 例子中。在JVM模式测试运行期间和原生模式测试运行期间，Hibernate ORM管理的数据库将填充测试数据。生产可执行文件将只包含 `version.txt` 资源，没有多余的测试数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable built with `-Dquarkus-profile=test` is not suitable for production deployment.  It contains your test resources files and settings. Once the testing is done, the executable would have to be built again, using the default, `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `-Dquarkus-profile=test` 构建的可执行文件不适合生产部署。它包含您的测试资源文件和设置。一旦测试完成，就必须使用默认的 `prod` 配置文件再次构建可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnIntegrationTest` annotation in order to skip them when testing against a native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您像我们上面建议的那样在JVM和原生执行之间共享测试类，您可以使用 `@DisabledOnIntegrationTest` 注解标记某些测试，以便在针对原生镜像进行测试时跳过它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@DisabledOnIntegrationTest` will also disable the test in all integration test instances, including testing the application in JVM mode, in a container image, and native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@DisabledOnIntegrationTest` 还将禁用所有集成测试实例中的测试，包括在JVM模式、容器镜像和原生镜像中测试应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test -Pnative`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以针对已经建立的原生可执行文件重新运行测试。要做到这一点，运行 `./mvnw test-compile failsafe:integration-test -Pnative`。这将发现现有的原生镜像，并使用failsafe对其运行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/GreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，打开 `src/test/java/org/acme/quickstart/GreetingResourceIT.java` 。它包含了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC comes as a dependency of `quarkus-resteasy-reactive` so you already have it handy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ArC作为 `quarkus-resteasy-reactive` 的一个依赖项，所以你已经有了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello from RESTEasy Reactive" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常简单的REST端点，对"/hello "上的请求返回 "Hello from RESTEasy Reactive"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Components</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been honored to receive multiple awards and recognition. We feel these are an affirmation of the great work being done by our dedicated community. We’ve started a trophy case to share the kudos with everyone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus有幸获得多个奖项和认可。我们认为这些都是对我们的社区所做的伟大工作的肯定。我们设立了奖杯陈列柜，与大家分享荣誉。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Awards and Recognition</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>奖项及表彰</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get answers to some of your common Quarkus questions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>找到一些常见Quarkus问题的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用什么许可证？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个使用https://www.apache.org/licenses/LICENSE-2.0[Apache License 2.0版]授权的开源项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我在哪儿能获得到?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus发布在Maven Central中，请查看 link:/extensions[扩展]，只需将它们导入到 `pom.xml`中就可以获得Quarkus。我们建议您通过我们的 link:/get-started[入门指南]开始您的Quarkus体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, we consider Quarkus stable. Remember 95% of the features Quarkus apps use are provided by the ecosystem like Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy, etc. These libraries are rock solid :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是的，我们认为Quarkus是稳定的。请记住，Quarkus应用程序使用的95%的特性都是由Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy等生态系统提供的。这些库是坚如磐石的 :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to https://code.quarkus.io/[code.quarkus.io] to see if a particular extension is _stable_ (default) or _preview_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以访问 https://code.quarkus.io/[code.quarkus.io] 查看特定扩展是否为 _stable_ (默认) or _preview_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的主要目标之一是易于扩展和构建一个充满活力的生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以将Quarkus扩展视为您的项目依赖项。扩展可以配置、引导并将框架或技术集成到您的Quarkus应用程序中。它们还做了所有繁重的工作，为GraalVM提供正确的信息，以便应用程序本地编译。这将允许第三方项目轻松地利用我们所做的工作，使其更容易瞄准GraalVM。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么是扩展状态?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展在进入Quarkus生态系统时具有不同程度的成熟度。状态提供了你可以依赖的期望。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Stable*: backward compatibility and presence in the ecosystem are taken very seriously. An application can safely rely on these extensions. Extensions not marked as preview or experimental (the majority) are stable.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Stable*: 向后兼容性和在生态系统中的存在被非常重视。应用程序可以安全地依赖于这些扩展。没有标记为预览或实验的扩展(大多数)是稳定的。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Preview*: 不能保证向后兼容性和在生态系统中的存在。具体的改进可能需要改变配置、API和计划，使之变得 _stable_ 。这些扩展还处于成熟过程的中间阶段。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Experimental*: early feedback is requested to mature the idea. There is no guarantee of stability nor long term presence in the platform until the solution matures. Such extensions are at the beginning of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Experimental*: 尽早反馈，以使想法更加成熟。在解决方案成熟之前，无法保证平台的稳定性或长期存在。这些扩展正处于其成熟过程的开始阶段。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on https://code.quarkus.io[code.quarkus.io] or in the extension link:/guides/[guides].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在 https://code.quarkus.io[code.quarkus.io] 或在扩展 link:/guides/[手册]中找到扩展状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我可以写一个扩展吗?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will the Quarkus team accept my extension?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus团队会接受我的扩展吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>噢，是的！我们在Quarkus "初始" 团队之外编写了相当多的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an open ecosystem and we hope to see all the extensions people need to write their apps. We are working as we speak to allow an extension to be published in separate repos and separate GAVs and thus published in Maven repos independently of Quarkus core. This will greatly simplify the publication process. Expect news soon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个开放的生态系统，我们希望看到人们编写应用程序所需的所有扩展。我们正在工作，正如我们所说，允许一个扩展在单独的repo和单独的GAV中发布，从而在Maven repo中独立于Quarkus核心发布。这将大大简化发布过程，期待很快有新消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our https://quarkus.io/community/#discussions[mailing list] to discuss your ideas and get help. And you can start reading our https://quarkus.io/guides/writing-extensions[Writing extensions guide] as well or more simply get inspiration from the https://github.com/quarkusio/quarkus/tree/main/extensions[existing ones].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当前的一个限制是，扩展必须同时在OpenJDK和GraalVM本机可执行文件中工作。这是我们给Quarkus用户的保证(他们应用程序的交叉编译)。我们有一个成熟度模型来改进扩展，使其完全 "Quarked" ，并从Quarkus中受益，所有这些都是在增量步骤中完成的。请登录我们的 https://quarkus.io/community/#discussions[邮件列表] 讨论您的想法并获得帮助。你也可以开始阅读我们的 https://quarkus.io/guides/writing-extensions[编写扩展指南]，或者更简单地从 https://github.com/quarkusio/quarkus/tree/main/extensions[现有的扩展] 中获得灵感。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 什么是GraalVM？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.graalvm.org[GraalVM] is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.graalvm.org[GraalVM] 是一个通用的虚拟机，用于运行用各种不同语言编写的应用程序，并提供将JVM字节码编译为原生可执行文件的能力(这个原生可执行文件运行一个名为SubstrateVM的特殊虚拟机)。与传统JVM相比，这些原生可执行文件启动速度更快，使用的内存也少得多，但是并不是所有JVM特性都得到支持，有些特性的限制比一般的要多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，默认情况下，GraalVM中的反射将不能工作，除非类/成员已显式地为反射注册。这通常是通过列出JSON文件中的每个类、方法、字段和构造函数，并将其作为参数传递到原生镜像构建中实现的。显然，除了最简易的项目外，这对于所有项目来说都是相当麻烦的。Quarkus提供了一个框架，可以轻松地处理这些注解，并以编程的方式确定应该注册哪些内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 如何统一指令式编程和响应式编程?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/continuum[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/continuum[了解更多].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/container-first[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/container-first[了解更多].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 对标准有什么考虑?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/standards[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/standards[了解更多].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 项目会做些什么来提高开发者的乐趣?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/developer-joy[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/developer-joy[了解更多].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 continues the mission of making Java the preferred framework for Kubernetes-native development with new developer tools and improved performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2.0继续致力于通过新的开发工具和改进的性能，使Java成为kubernetes原生开发的首选框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proven Java for the Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>经过验证的云计算Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Short informative videos that highlight unique technical points and instructions on how to get the most out of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简短的信息视频突出了独特的技术要点和关于如何最大限度地利用Quarkus的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s go to the quark of things.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们来看看quark的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ways to connect with others via forum, stack, chat, or email groups.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过论坛、Stack、聊天或电子邮件组多种方式同我们保持联系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discussion about Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>讨论Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Core</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>核心</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Video podcast hosted by Quarkus Developers about things moving in and around Quarkus ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由Quarkus开发者主办的关于在Quarkus生态系统内和周边事物的视频播客。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连续统一体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus团队和社区非常重视所有的安全漏洞。你可以在这里找到关于我们的政策和安全披露的指导方针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reporting security issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>报告安全问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please report any security issues you find in Quarkus to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请将您在Quarkus中发现的任何安全问题报告给：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone can post to this list. The subscribers are only trusted individuals from the Quarkus community who will handle the resolution of any reported security issues in confidence. In your report, please note how you would like to be credited for discovering the issue and the details of any embargo you would like to impose. Currently the security response teams for the following distributions are subscribed to this list and will respond to your report:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任何人都可以在这个列表上发帖。订阅者仅是来自Quarkus社区的受信任的个人，他们将在保密的情况下处理任何报告的安全问题的解决方案。请在你的报告中注明你希望因发现该问题而获得的荣誉，以及你希望实施的任何禁运措施的细节。目前，以下发行版的安全响应团队已经订阅了这个列表，并将对您的报告作出响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ecosystem</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生态系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an ecosystem made from many extensions and many libraries (like Eclipse Vert.x, Hibernate, Apache Camel and more), most of them not under the direct responsibility of the Quarkus team. If you find a security bug possibly rooted in one of these libraries, you can either disclose to them directly or disclose them to the Quarkus team (following this process) and we will responsibly disclose the issue to the respective extension or library maintainer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个由许多扩展和许多库组成的生态系统（如Eclipse Vert.x, Hibernate, Apache Camel等），其中大多数都不是由Quarkus团队直接负责的。如果您发现一个安全漏洞可能根植于这些库中的一个，您可以直接向他们披露，也可以向Quarkus团队披露（遵循此过程），我们将负责地向相应的扩展或库维护人员披露问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为什么要遵循这个过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the sensitive nature of security bugs, the disclosure process is more constrained than a regular bug. We appreciate you following these industry accepted guidelines, which gives time for a proper fix and limit the time window of attack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于安全性缺陷的敏感性，披露过程比普通缺陷更受限制。我们感谢您遵循这些业界公认的指导方针，这些方针为适当的修复提供了时间，并限制了攻击的时间窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Versions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受支持版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>社区将修复最新的major.minor版本安全漏洞，发布于 https://quarkus.io/get-started/。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We may fix the vulnerability to older versions depending on the severity of the issue and the age of the release, but we are only committing to the latest version released.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>根据问题的严重程度和发布的时间，我们可能会修复旧版本的漏洞，但我们只承诺发布的最新版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling security issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理安全问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you represent a Quarkus extension or a Quarkus platform, you are welcome to subscribe to the security at quarkus.io mailing list. Your subscription will only be approved if you can demonstrate that you will handle issues in confidence and properly credit reporters for discovering issues (e.g. experience with embargoe process).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您代表一个Quarkus扩展或Quarkus平台，欢迎您订阅quarkus.io的安全性邮件列表。只有当你能证明你会保密地处理问题，并正确地信任问题发现者时，你的订阅才会被批准（例如，禁运流程的经验）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have found nowhere.&lt;br/&gt;The pathway to normal space&lt;br/&gt;is found in the nav.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>没有找到您要访问的资源。&lt;br/&gt;请通过导航栏返回到正常空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn step by step how to build a simple extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一步一步地学习如何构建一个简单的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building My First Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建我的第一个扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-my-first-extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/building-my-first-extension</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions optimize your applications by pushing as much work as possible to the build operation. This guide explains the rationale of Quarkus extensions and guides you through authoring your own extensions.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus扩展通过将尽可能多的工作推给构建操作来优化你的应用程序。本指南解释了Quarkus扩展的基本原理，并指导你编写你自己的扩展。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus class loading infrastructure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解关于Quarkus类加载基础设施的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何将你的扩展与Quarkus的CDI容器集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi-integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何让你的扩展为Dev UI贡献功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to Dev UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为开发用户界面做出贡献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-ui</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-ui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore all the BuildItems you can consume/produce in your extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索你可以在你的扩展中消费/提供的所有BuildItems。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All BuildItems</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有BuildItems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-builditems</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/all-builditems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about what we call a Platform in the Quarkus world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus 世界中我们称之为平台的东西。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Understanding the Platform concept</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>理解平台概念</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to create your first Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何创建您的第一个Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through First Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指导您完成第一个应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about developing reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解有关使用Quarkus开发响应式应用程序的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build native executables with GraalVM or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用GraalVM或Mandrel构建原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-native-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/building-native-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the Quarkus developer toolchain which makes Quarkus development so fast and enjoyable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索Quarkus开发者工具链，让Quarkus开发如此快速和愉快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus integrations in IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus在IDE中的整合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/ide-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/ide-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code is a no go (even if we all did it at some point ;-)). In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的代码中将值硬编码是行不通的（即使我们在某些时候都会这样做;-)）。在本指南中，我们学习如何配置你的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to configure your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何配置你的Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Group multiple configuration properties into an object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将多个配置属性分组到一个对象中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping Configuration to Objects</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将配置映射到对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-mappings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-mappings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extend and customize the Configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展和定制配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-extending-support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-extending-support</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YAML as a Configuration Source.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML 作为配置源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-yaml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List all the configuration properties per extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>列出每个扩展的所有配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/all-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops. This guide explains how to be notified when an application stops or starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你经常需要在应用程序启动时执行自定义动作，在应用程序停止时清理一切。本指南解释了如何在应用程序停止或启动时获得通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lifecycle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/lifecycle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus DI解决方案是基于 [Java的上下文和依赖注入 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) 规范。本指南解释了CDI的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go more in depth into the Quarkus implementation of CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更深入地了解Quarkus对CDI的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to develop reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何用Quarkus开发响应式应用程序的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mutiny-primer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mutiny-primer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括：
* 在JVM模式下的测试
* 在原生模式下的测试
* 将资源注入测试
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get early test feedback with Continuous Testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过持续测试获得早期测试反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/continuous-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/continuous-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of all extensions that support Dev Services and their configuration options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有支持开发服务的扩展及其配置选项的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic Service Setup with Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用开发服务的自动服务设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/logging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains how to develop command line applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南解释了如何用Quarkus开发命令行应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Mode Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令模式参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can pass contextual information with SmallRye Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何利用SmallRye Context Propagation传递上下文信息的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context Propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务和安全上下文传播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/context-propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/context-propagation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the base runtime image used by Quarkus for native executables and how you can tweak it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus用于原生可执行文件的基本运行时镜像，以及如何调整它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base Runtime Image for Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生可执行文件的基本运行时镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quarkus-runtime-base-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quarkus-runtime-base-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how you can reduce the size of your native executables with UPX.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解你如何用UPX减少你的原生可执行文件的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compress Native Executables with UPX</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用UPX压缩原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/upx</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/upx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南收集了一些提示，帮助你解决将应用程序编译为原生可执行文件时遇到的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Native Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写原生应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore in more details how to debug native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更详细地探讨如何调试原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/native-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网络</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON现在是微服务之间的通用语言。在本指南中，我们看看如何让你的REST服务消费和提供JSON有效载荷。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction to writing REST JSON Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST JSON服务的介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-json</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-json</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to develop highly scalable REST services with JAX-RS and RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用JAX-RS和RESTEasy Reactive开发高度可扩展的REST服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing REST Services Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST服务参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy Reactive REST Client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用RESTEasy Reactive REST客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用REST客户端（包括JSON）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to migrate an application from RESTEasy Classic to RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将一个应用从RESTEasy 指令式迁移到RESTEasy 响应式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Migrating from RESTEasy Classic to RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从RESTEasy 指令式迁移到RESTEasy 响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive-migration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy-reactive-migration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache simplifies the creation of CRUD applications based on JAX-RS and Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用Panache来操作Hibernate ORM REST数据，简化了基于JAX-RS和Hibernate ORM的CRUD应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple REST CRUD Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写简单的REST CRUD服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation in your REST services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在REST服务中使用Hibernate验证器/Bean验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy REST Client to send multipart REST requests, typically to upload documents.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍如何使用RESTEasy REST客户端发送多部分REST请求，通常是为了上传文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize web sockets to create interactive web applications. Because it’s the canonical web socket application, we are going to create a simple chat application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用网络套接字来创建交互式网络应用。因为它是典型的网络套接字应用程序，我们将创建一个简单的聊天应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/websockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/websockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用OpenAPI扩展来生成OpenAPI描述符，并获得一个Swagger UI前端来测试你的REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy REST Client in order to interact with REST APIs (JSON and other) with very little effort.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用RESTEasy REST客户端，以便用很少的精力与REST API（JSON和其他）进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developing REST Services with RESTEasy Classic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用RESTEasy Classic开发REST服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the RESTEasy Classic REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用RESTEasy Classic REST客户端（包括JSON）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于配置Quarkus基于Vert.x的HTTP层的信息--如果你使用servlets的话，还有Undertow。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/http-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/http-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Fault Tolerance specification through the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何通过SmallRye容错扩展来利用SmallRye容错规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用容错技术</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-fault-tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-fault-tolerance</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use reactive routes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用响应式路由。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-routes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage SmallRye GraphQL to implement GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何利用SmallRye GraphQL来实现GraphQL服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing GraphQL Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实施GraphQL服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-graphql</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-graphql</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage SmallRye GraphQL Client to consume GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何利用SmallRye GraphQL客户端来消费GraphQL服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming GraphQL Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费GraphQL服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-graphql-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-graphql-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, you can easily configure a datasource, or several if need be.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus，你可以很容易地配置一个数据源，如果需要的话，也可以配置若干个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置你的数据源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breath of an Object Relational Mapper. It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，为你提供了对象关系映射器的全部功能。它在Quarkus中工作得很好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Panache focuses on making your entities trivial and fun to write.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，为你提供了对象关系映射器的全部范围。
它使复杂的映射成为可能，但它并没有使简单和普通的映射变得微不足道。
Panache专注于使你的实体变得简单和有趣。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This explain the specifics of using Hibernate ORM with Panache in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将解释在Kotlin项目中使用Hibernate ORM与Panache的具体细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search allows you to index your entities in an Elasticsearch cluster and easily offer full text search in all your Hibernate ORM-based applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Search允许你在Elasticsearch集群中索引你的实体，并在你所有基于Hibernate ORM的应用程序中轻松提供全文搜索。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带一个事务管理器，并使用它来协调和暴露事务给你的应用程序。每个处理持久性的扩展都会为你与它集成。而且你将通过CDI明确地与事务进行交互。本指南将指导你完成这一切。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/transaction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Blaze-Persistence to simplify your data and DTO layers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Blaze-Persistence来简化你的数据和DTO层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to cache expensive method calls of your CDI beans using simple annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用简单的注解来缓存CDI Bean中昂贵的方法调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cache your application data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>缓存你的应用程序数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Flyway extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何使用Flyway扩展来管理你的模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Schema Migration with Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Flyway进行模式迁移</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Liquibase extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何使用Liquibase扩展来管理你的模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Schema Migration with Liquibase</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Liquibase进行模式迁移</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/liquibase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Reactive SQL Clients in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Quarkus中使用响应式SQL客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified reactive ORM layer based on Hibernate Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于Hibernate 响应式的简化响应式ORM层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-reactive-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-reactive-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Infinispan Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Infinispan客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/infinispan-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/infinispan-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use an Elasticsearch cluster using the low level or high level REST clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何使用低级或高级的REST客户端来使用Elasticsearch集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Elasticsearch automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Elasticsearch。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/elasticsearch-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use MongoDB in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用MongoDB。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manage your MongoDB schema migrations with Liquibase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Liquibase管理你的MongoDB模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase MongoDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibase MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase-mongodb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/liquibase-mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了MongoDB使用活动记录和存储库的用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了在Kotlin项目中使用活动记录和存储库的MongoDB的用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache and Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache和Kotlin的MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use a Redis datastore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Redis数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to customize the Redis client to your needs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何根据自己的需要定制Redis客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Redis automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Redis。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Neo4j graph database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用Neo4j图数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkiverse-hub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkiverse-hub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-neo4j/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-neo4j/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Apache Cassandra NoSQL database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Apache Cassandra NoSQL数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cassandra</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cassandra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon DynamoDB database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Amazon DynamoDB数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon DynamoDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon DynamoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-dynamodb.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-dynamodb.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon S3 cloud storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Amazon S3云存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon S3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-s3.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-s3.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP BigQuery in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP BigQuery。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud BigQuery</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud BigQuery</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigquery.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigquery.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Bigtable in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Bigtable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Bigtable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Bigtable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigtable.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigtable.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Firestore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Firestore。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Firestore</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Firestore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/firestore.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/firestore.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Spanner in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Spanner。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Spanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Spanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/spanner.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/spanner.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Storage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Storage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/storage.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/storage.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of Software Transactional Memory (STM).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了软件事务性内存（STM）的使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Software Transactional Memory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用软件事务性内存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of LRA to coordinate activities across services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了使用LRA来协调跨服务的活动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using LRA (Long Running Actions)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用LRA（长期运行的活动）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lra</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/lra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-reactive-getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-reactive-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide provides an in-depth look on Apache Kafka and Smallrye Reactive Messaging framework.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南深入介绍了Apache Kafka和Smallrye响应式消息传递框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Apache Kafka automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Apache Kafka。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Apache Kafka, Avro serialized records, and connect to a schema registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka，Avro序列化记录，并连接到一个模式注册中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-schema-registry-avro</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-schema-registry-avro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Apicurio Registry automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Apicurio仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/apicurio-registry-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/apicurio-registry-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye响应式消息传递与AMQP进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AMQP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用AMQP与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference guide for SmallRye Reactive Messaging and AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye响应式消息传递和AMQP的参考指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start AMQP automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动AMQP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RabbitMQ with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用RabbitMQ与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference guide for SmallRye Reactive Messaging and RabbitMQ.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye响应式消息传递和RabbitMQ的参考指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start RabbitMQ automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动 RabbitMQ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce messages via WebSockets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的Quarkus应用程序如何利用SmallRye响应式消息通过WebSockets来消费和产生消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-messaging-websocket</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-messaging-websocket</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how different beans can interact using the event bus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了不同的Bean如何使用事件总线进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use JMS messaging with AMQP 1.0 using Apache Qpid JMS, or using Apache ActiveMQ Artemis JMS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用AMQP 1.0的Apache Qpid JMS，或使用Apache ActiveMQ Artemis JMS进行JMS信息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/jms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP PubSub in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP PubSub。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud PubSub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud PubSub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/pubsub.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/pubsub.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the entry point for everything security in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是Quarkus中一切安全问题的入口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Overview</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secure your web endpoints with authorizations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用授权来保护你的网络端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how Quarkus handles authentication.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus如何处理认证的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-built-in-authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-built-in-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customize Quarkus' security layer behavior.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义Quarkus的安全层行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Customization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全定制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-customization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-customization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test the security of your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试你的Quarkus应用程序的安全性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a .properties file to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用.properties文件来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-perties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用Hibernate ORM的数据库来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jpa</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jdbc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jdbc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a LDAP directory to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用LDAP目录来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with LDAP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用LDAP的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-ldap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-ldap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect extension to protect your Quarkus JAX-RS service application using Bearer Token Authorization where the tokens are issued by OpenID Connect Providers such as Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用OpenID Connect扩展来保护你的Quarkus JAX-RS服务应用程序，使用Bearer令牌授权，其中令牌由OpenID Connect提供者（如Keycloak）出具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) to Protect Service Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）来保护服务应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect extension to protect your Quarkus JAX-RS web application using the Authorization Code Flow and OpenID Connect Providers such as Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用OpenID Connect扩展来保护你的Quarkus JAX-RS网络应用程序，使用授权代码流和OpenID Connect提供者，如Keycloak。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) to Protect Web Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）来保护网络应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your OpenID Connect application can support multi-tenancy so that you can serve multiple tenants from a single application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的OpenID Connect应用程序如何支持多租户，这样你就可以从一个应用程序中为多个租户提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize access to protected resources using Keycloak Authorization Services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用Keycloak授权服务来授权访问受保护的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) and Keycloak to Centralize Authorizations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）和Keycloak来集中授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use OpenID Connect and OAuth2 Client and Filters to acquire, refresh and propagate access tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用OpenID Connect和OAuth2客户端和过滤器来获取、刷新和传播访问令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) and OAuth2 Client and Filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）和OAuth2客户端和过滤器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to configure Quarkus to authenticate against well-known OpenID Connect providers such as GitHub, Google, Microsoft, Apple...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何配置Quarkus来验证著名的OpenID Connect提供者，如GitHub、谷歌、微软、苹果...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Well-Known OpenID Connect (OIDC) Providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置知名的OpenID Connect（OIDC）提供者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-providers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Keycloak or other providers automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Keycloak或其他提供者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenID Connect (OIDC) Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect（OIDC）开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can utilize SmallRye JWT to verify JWT tokens and provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的应用程序如何利用SmallRye JWT来验证JWT令牌并为JAX-RS端点提供安全访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jwt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can build, sign and/or encrypt JWT tokens with a fluent and configurable SmallRye JWT Build API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的应用程序如何利用流畅且可配置的SmallRye JWT构建API构建、签署和/或加密JWT令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build, Sign and Encrypt JSON Web Tokens (JWT)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立、签署和加密JSON网络令牌(JWT)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt-build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jwt-build</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-oauth2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-oauth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault to securely store your credentials in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用HashiCorp Vault在Quarkus中安全地存储您的凭证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault for "encryption as a service".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用HashiCorp Vault进行 "加密即服务"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault Transit Secret Engine</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vault Transit保密引擎</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-transit.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-transit.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep confidential your database credentials by storing them in Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将你的数据库凭证存储在Vault中，对其进行保密。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-datasource.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-datasource.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains the various methods supported by Quarkus to authenticate to your Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Quarkus支持的各种方法来验证您的Vault。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-auth.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-auth.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate X.509 certificates with Vault’s PKI Secret Engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Vault的PKI加密引擎生成X.509证书。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HashiCorp Vault’s PKI Secret Engine</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用HashiCorp Vault的PKI加密引擎</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-pki.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-pki.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides explains how to use the Vault credentials provider or implement your own custom one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Vault凭证提供者或实现你自己的自定义凭证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/credentials-provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/credentials-provider</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-webauthn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-webauthn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business Automation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>业务自动化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add business automation and power it up with DMN decision support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来增加业务自动化，并通过DMN决策支持为其提供动力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-dmn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-dmn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add DRL files with rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来添加带有规则的DRL文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-drl</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-drl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add business automation to power it up with predictions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来添加业务自动化，为其提供预测的动力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-pmml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-pmml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Kogito automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Kogito。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将引导你完成用OptaPlanner的约束解决人工智能（AI）创建Quarkus应用程序的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AI to optimize a schedule with OptaPlanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用人工智能来优化OptaPlanner的日程安排</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/optaplanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/optaplanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the systems integration with Apache Camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括与Apache Camel的系统集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令行应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplify command line applications creation with the Picocli extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Picocli扩展简化了命令行应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Picocli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/picocli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Quarkus-based scripting with jbang.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用jbang轻松实现基于Quarkus的脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jbang整合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scripting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scripting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to use SmallRye Stork for service discovery and load balacing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用SmallRye Stork进行服务发现和负载平衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stork</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stork</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/stork</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/stork</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have a more in-depth look at how SmallRye Stork can be configured and used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更深入地了解如何配置和使用SmallRye Stork。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/stork-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/stork-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to build and push container images with Jib, S2I or Docker as part of the Quarkus build.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用Jib、S2I或Docker构建和推送容器镜像，作为Quarkus构建的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Container Images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建容器镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/container-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/container-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Kubernetes上部署一个原生应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying Quarkus Applications on Kubernetes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kubernetes上部署Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在OpenShift上部署一个原生应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying Quarkus Applications on OpenShift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在OpenShift上部署Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying toopenshift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ConfigMaps as a configuration source for your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用ConfigMaps作为Quarkus应用程序的配置源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming Kubernetes ConfigMaps</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费Kubernetes ConfigMaps</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the Fabric8 Kubernetes client to interact with your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用Fabric8 Kubernetes客户端与你的Kubernetes集群互动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Kubernetes Client to Interact with a Kubernetes Cluster</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kubernetes客户端与Kubernetes集群互动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Microsoft Azure Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何将Quarkus应用程序部署到Microsoft Azure云中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Azure Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Azure Function。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Functions (Serverless) with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x Web、Servlet或RESTEasy的Azure Functions（无服务器）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Amazon Lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何部署基于Quarkus的Amazon Lambdas。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Amazon Lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Vert.x Web、Servlet或RESTEasy的Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何将Quarkus应用程序部署到谷歌云。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Google Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到谷歌云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何部署基于Quarkus的Google Cloud Functions。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as a Google Cloud Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Google Cloud Function。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x Web、Servlet或RESTEasy的Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy your Quarkus applications on Heroku.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Heroku上部署你的Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-heroku</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying toheroku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains basics of the Funqy framework, a simple portable cross-provider cloud function API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy框架的基础知识，这是一个简单的可移植的跨供应商的云功能API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Amazon Lambda绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Amazon Lambda HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Knative Events binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Knative Events绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Azure Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Azure Functions HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Google Cloud Platform Functions绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Google Cloud Platform Functions HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Key Management Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用亚马逊密钥管理服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon KMS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon KMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-kms.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-kms.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Identity and Access Management in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊身份和访问管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon IAM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon IAM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-iam.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-iam.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Email Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊简单电子邮件服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ses.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ses.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Notification Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊简单通知服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SNS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SNS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sns.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sns.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Queue Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Quarkus中使用Amazon Simple Queue Service。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SQS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SQS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sqs.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sqs.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the AWS Systems Manager in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用AWS系统管理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SSM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SSM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ssm.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ssm.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use multiple GCP services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何使用多种GCP服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Access Google Cloud services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Access Google Cloud services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可观察性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Health extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了您的Quarkus应用程序如何利用SmallRye Health扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用健康检查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTelemetry to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OpenTelemetry来为交互式Web应用程序提供分布式跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentelemetry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/opentelemetry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/opentracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can collect metrics using the Micrometer extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用Micrometer扩展来收集指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Collecting Metrics with Micrometer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Micrometer收集指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/micrometer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/micrometer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Metrics extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye Metrics扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Collecting Metrics with SmallRye Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用SmallRye Metrics收集指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye容错扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Sentry to monitor your application and be notified when exceptions occur.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Sentry来监控你的应用程序，并在发生异常时得到通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Sentry to Monitor your Logs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Sentry来监控你的日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-logging-sentry/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-logging-sentry/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to centralize your logs with Logstash or Fluentd using the Graylog Extended Log Format (GELF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Graylog扩展日志格式（GELF）用Logstash或Fluentd集中管理你的日志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing REST JSON Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST JSON服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Entry point for everything gRPC.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一切gRPC的总入口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to start using gRPC in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中开始使用gRPC。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to implement gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中实现gRPC服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing gRPC Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现gRPC服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to consume gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中消费gRPC服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming gRPC Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费gRPC服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Quarkus CLI to create, build, run, and manage extensions for Quarkus projects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus CLI来创建、构建、运行和管理Quarkus项目的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cli-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cli-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了以下内容：
* Maven配置
* 创建新项目
* 处理扩展
* 开发模式 
* 调试
* 在IDE中导入 
* 构建原生可执行文件 
* 构建容器友好型可执行文件
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Applications with Maven</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Maven构建应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/maven-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/maven-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了以下内容：
* Gradle配置 
* 创建新项目 
* 处理扩展 
* 开发模式 
* 调试 
* 在你的IDE中导入 
* 构建原生可执行文件 
* 构建容器友好型可执行文件 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Applications with Gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Gradle构建应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how you can streamline the release process of your Quarkus applications with JReleaser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何利用JReleaser简化Quarkus应用程序的发布过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Releasing your Quarkus applications with JReleaser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用JReleaser发布你的Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jreleaser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/jreleaser</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to measure the test coverage of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何测量你的Quarkus应用程序的测试覆盖率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use mutable jars to rebuild your application with different build time configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用易变的jars来重建具有不同构建时间配置的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reaugmentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reaugmentation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatibility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>兼容性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the spring-di extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用CDI注解进行注入，但Quarkus以spring-di扩展的形式为Spring依赖注入提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring DI API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring DI API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-di</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-di</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use JAX-RS annotations for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the spring-web extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用JAX-RS注解来定义REST端点，但Quarkus以spring-web扩展的形式为Spring Web提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Web API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Web API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use Hibernate ORM with Panache for your data layer, Quarkus provides a compatibility layer for Spring Data JPA in the form of the spring-data-jpa extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Hibernate ORM与Panache作为你的数据层，但Quarkus以spring-data-jpa扩展的形式为Spring Data JPA提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Data JPA API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Data JPA API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST simplifies the creation of CRUD applications based on our Spring Data compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Data REST简化了基于我们Spring Data兼容层的CRUD应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple CRUD Applications with Spring Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Spring Data编写简单的CRUD应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Quarkus security layer to secure your applications, Quarkus provides a compatibility layer for Spring Security in the form of the spring-security extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Quarkus安全层来保护你的应用程序，但Quarkus以spring-security扩展的形式为Spring Security提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Security API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Security API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Cache extension for your application-level caching, Quarkus provides a compatibility layer for Spring Cache in the form of the spring-cache extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Cache扩展来进行应用级缓存，但Quarkus以spring-cache扩展的形式为Spring Cache提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Scheduler or Quartz extensions to schedule tasks, Quarkus provides a compatibility layer for Spring Scheduled in the form of the spring-scheduled extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Scheduler或Quartz扩展来安排任务，但Quarkus以spring-scheduled扩展的形式为Spring Scheduled提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Scheduled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot的 `@ConfigurationProperties` ，代替MicroProfile配置注解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Spring Boot's ConfigurationProperties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot的ConfigurationProperties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a compatibility layer for Spring Cloud Config in the form of the spring-cloud-config-client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus以spring-cloud-config-client扩展的形式为Spring Cloud Config提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Cloud Config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Cloud Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Miscellaneous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>杂项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically. In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现代应用程序经常需要定期运行特定的任务。在本指南中，你将学习如何安排定期任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scheduler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the Scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Scheduler扩展的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need clustering support for your scheduled tasks? This guide explains how to use the Quartz extension for that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的计划任务需要集群支持？本指南解释了如何使用Quartz扩展来实现这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Clustered Tasks with Quartz</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Quartz调度集群任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quartz</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can send email from a Quarkus application with our reactive email client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何使用我们的响应式电子邮件客户端从Quarkus应用程序发送电子邮件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Emails using SMTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用SMTP发送邮件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mailer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains in more details the configuration and usage of the Quarkus Mailer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南更详细地解释了Quarkus Mailer的配置和使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mailer-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can use templating in your applications with the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何利用Qute模板引擎在你的应用程序中使用模板。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templating with Qute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Qute进行模板设计</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn everything you need to know about the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解你需要知道的关于Qute模板引擎的一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/qute-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you extract content from documents using the Apache Tika toolkit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何使用Apache Tika工具包从文档中提取内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extracting Content with Apache Tika</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Apache Tika提取内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-tika/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-tika/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Vert.x in Quarkus to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在Quarkus中使用Vert.x来构建响应式应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vertx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide provides advanced details about the usage and the configuration of the Vert.x instance used by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南提供了关于Quarkus使用的Vert.x实例的使用和配置的高级细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vertx-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can access Git repositories with JGit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何用JGit访问Git仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Access Git repositories with JGit</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用JGit访问Git存储库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-jgit/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-jgit/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from Consul.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何在运行时从Consul读取配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume Configuration from Consul</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Consul中消费配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-config-extensions/dev/consul.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-config-extensions/dev/consul.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to best measure the footprint of a Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何最好地测量Quarkus应用程序的占用空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/performance-measure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/performance-measure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Secret Manager in Quarkus to consume configuration properties directly or via your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用GCP Secret Manager直接或通过 `application.properties` 来使用配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume Configuration from Google Cloud Secret Manager</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从谷歌云秘密管理器中消费配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/secretmanager.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/secretmanager.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Languages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>替代语言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Kotlin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Kotlin。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How capabilities are implemented and used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus中如何实现和使用功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/capabilities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/capabilities</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Trigger the inclusion on additional extensions based on certain conditions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于特定条件触发包含附加扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/conditional-extension-dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/conditional-extension-dependencies</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provide users with initial code for extensions when generating Quarkus applications on code.quarkus.io and all the Quarkus tooling. This guide explains how to create and configure a Codestart for an extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当用户在 code.quarkus.io 和所有Quarkus工具上生成Quarkus应用程序时，为扩展提供初始代码。本指南解释如何为扩展创建和配置Codestart。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a Codestart for an extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为扩展编写Codestart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/extension-codestart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/extension-codestart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus reactive architecture.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解关于Quarkus响应式架构的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quarkus-reactive-architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quarkus-reactive-architecture</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the notion of extension registry and how you can use your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于扩展仓库的概念，以及如何使用自己的扩展仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/extension-registry-user</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/extension-registry-user</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How dev mode differs from a production application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式与生产应用程序有何不同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Mode Differences</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式的差异</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-mode-differences</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-mode-differences</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour 2021 - Sound Check... Getting Started with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年世界巡演-试音…从Quarkus开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond simply working, we’re aiming for Joy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了工作，我们的目标是充满乐趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It’s a snap to be up and running with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>和Quarkus一起工作很容易。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get Started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始体验</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour - Abstracts and Support materials.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡回-摘要和支持材料。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, integration tests runs using the `prod` profile.  This can be overridden using the `quarkus.test.native-image-profile` property.  For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.  Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  However, don't forget that when the native executable is built the `prod` profile is enabled.  So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，集成测试使用 `prod` 配置文件运行。这可以用 `quarkus.test.native-image-profile` 属性来覆盖。例如，在你的 `application.properties` 文件中，添加： `quarkus.test.native-image-profile=test` 。或者，你可以用以下方式运行你的测试。 `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` 。然而，不要忘记当原生可执行文件被构建时， `prod` 配置文件被启用。因此，你通过这种方式启用的配置文件必须与生成的可执行文件兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在函数中使用任何Quarkus特性，并受益于快速启动和低内存利用率。使用Quarkus，您无需改变编程语言就可以拥抱这个新世界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} - Publications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} - 发表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below is a list of articles, blogs, podcast and other tidbits published online around {project-name}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是网上发布的文章、博客、播客和其他趣闻 {project-name}。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you believe we are missing an article, blog or video https://github.com/quarkusio/quarkusio.github.io[submit an issue].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你认为我们少了一篇文章，博客或视频 https://github.com/quarkusio/quarkusio.github.io[提交一个议题]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reduction in Reflection Usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>减少反射的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Guides - Latest</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最新指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour 2021 - Abstracts and Support materials.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年世界巡演-摘要和支持材料。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A virtual (and in person where possible) tour of Java User Groups creating a unique hands-on experience with access to Quarkus experts designed to help you get started with Java in a Kubernetes world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个Java用户组的虚拟之旅(如果可能的话还可以亲自去)，创建一个独特的亲身体验，造访旨在帮助您在Kubernetes世界中开始使用Java的Quarkus专家。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java" target="_blank"&gt;an IDE&lt;/a&gt; like &lt;a href="https://www.jetbrains.com/idea/download/"&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href="https://www.eclipse.org/downloads/"&gt;Eclipse&lt;/a&gt;, &lt;a href="https://code.visualstudio.com/Download"&gt;VSCode&lt;/a&gt; or even &lt;a href="https://spacevim.org/use-vim-as-a-java-ide/"&gt;Vim&lt;/a&gt; or &lt;a href="http://spacemacs.org"&gt;Emacs&lt;/a&gt;!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java" target="_blank"&gt;一个IDE&lt;/a&gt;，比如&lt;a href="https://www.jetbrains.com/idea/download/"&gt;IntelliJ IDEA&lt;/a&gt;，&lt;a href="https://www.eclipse.org/downloads/"&gt;Eclipse&lt;/a&gt;、&lt;a href="https://code.visualstudio.com/Download"&gt;VSCode&lt;/a&gt;或者至少有一个&lt;a href="https://spacevim.org/use-vim-as-a-java-ide/"&gt;Vim&lt;/a&gt;、&lt;a href="http://spacemacs.org"&gt;Emacs&lt;/a&gt;文本编辑器！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need a &lt;a href="https://adoptopenjdk.net" target="_blank"&gt;a JDK {{ site.data.versions.jdk }}&lt;/a&gt; (any distribution)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要一个&lt;a href="https://adoptopenjdk.net" target="_blank"&gt;JDK {{ site.data.version.jdk }}&lt;/a&gt;（任意发行版）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally get &lt;a href="https://www.graalvm.org/" target="_blank"&gt;GraalVM&lt;/a&gt; {{ site.data.versions.graalvm }} for native compilation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可选择获取&lt;a href="https://www.graalvm.org/" target="_blank"&gt;GraalVM&lt;/a&gt; {{ site.data.version.graalvm }}进行原生编译</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.versions.maven }}&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.version.maven }}&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://code.quarkus.io"&gt;Start Coding&lt;/a&gt; with Quarkus {{ site.data.versions.quarkus.version }} [&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;announce&lt;/a&gt;|&lt;a href="https://github.com/quarkusio/quarkus/releases/tag/{{ site.data.versions.quarkus.version }}"&gt;changelog&lt;/a&gt;]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用Quarkus {{ site.data.versions.quarkus.version }} [&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;通告&lt;/a&gt;|&lt;a href="https://github.com/quarkusio/quarkus/releases/tag/{{ site.data.versions.quarkus.version }}"&gt;变更日志&lt;/a&gt;]&lt;a href="https://code.quarkus.io"&gt;开始写代码&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS 2.0 IS HERE!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QUARKUS 2.0来了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For years, the client-server architecture has been the de-facto standard to build applications. But a significant shift happened. The &lt;em&gt;one model rules them all&lt;/em&gt; age is over. A new range of applications and architectural styles have emerged and transformed how code is written and how applications are deployed and executed. HTTP microservices, reactive applications, event-driven architecture, and serverless are now central players in modern systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多年来，客户端服务器（CS）架构一直是构建应用程序的事实标准。但是，一个重大的转变发生了。&lt;em&gt;一种模式统治一切&lt;/em&gt;的时代已经过去。一系列新的应用程序和架构风格已经出现，并改变了代码的编写方式以及应用程序的部署和执行方式。HTTP微服务、响应式应用、事件驱动架构和无服务器现在是现代系统的核心角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been designed with this new world in mind and provides first-class support for these different paradigms. That does not mean you cannot build monoliths with Quarkus; you can do it smoothly. On the contrary, it means that the Quarkus development model morphs to adapt itself to the type of application you are developing, monolith, microservice, reactive, event-driven, functions…</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的设计考虑到了这个新的世界，并为这些不同的范式提供了一流的支持。这并不意味着你不能用Quarkus建立单体；你可以顺利地做到这一点。反而这意味着Quarkus的开发模型会变化，来适应您正在开发的应用程序的类型，单片机、微服务、响应式、事件驱动、无服务......</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s start with the basics: HTTP microservices. In this context, you need to develop an HTTP endpoint, often called REST or CRUD. You process incoming HTTP requests, and to do so you often need to rely on other services, such as databases, or another HTTP service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从最基本的开始：HTTP微服务。在这种情况下，你需要开发一个HTTP端点，通常称为REST或CRUD。你处理传入的HTTP请求，而要做到这一点，你往往需要依靠其他服务，如数据库，或另一个HTTP服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this type of application, Quarkus relies on well-known standards such as JAX-RS, JPA and MicroProfile Rest Client, but also Hibernate with Panache to simplify interactions with databases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于这种类型的应用，Quarkus依赖于众所周知的标准，如JAX-RS、JPA和MicroProfile Rest Client，但也有Hibernate与Panache来简化与数据库的交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s take a very simple application handling &lt;em&gt;elements&lt;/em&gt; from the periodic table. The code would be something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们来看看一个非常简单的处理周期表中&lt;em&gt;元素&lt;/em&gt;的应用程序。代码将是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a Java EE or Spring user, this development model should look familiar.  You expose a resource containing methods annotated with &lt;code&gt;@GET&lt;/code&gt;, &lt;code&gt;@POST&lt;/code&gt;…&amp;ZeroWidthSpace;&amp;ZeroWidthSpace; to handle the different requests.  The path is specified using the &lt;code&gt;@Path&lt;/code&gt; annotation.  Quarkus also supports &lt;a href="https://quarkus.io/guides/spring-web"&gt;Spring controller&lt;/a&gt; annotations such as &lt;code&gt;@GetMapping&lt;/code&gt; or &lt;code&gt;@RestController&lt;/code&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是一个Java EE或Spring的用户，这个开发模型应该看起来很熟悉。你暴露一个资源，其中包含有&lt;code&gt;@GET&lt;/code&gt;, &lt;code&gt;@POST&lt;/code&gt;...&amp;ZeroWidthSpace;&amp;ZeroWidthSpace; 注释的方法来处理不同的请求。路径是使用&lt;code&gt;@Path&lt;/code&gt;注解指定的。Quarkus还支持&lt;a href="https://quarkus.io/guides/spring-web"&gt;Spring控制器&lt;/a&gt;注释，如&lt;code&gt;@GetMapping&lt;/code&gt;或&lt;code&gt;@RestController&lt;/code&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the JPA entity manager directly.  Panache proposes an alternative removing boilerplate and exposing an active record and repository models.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以直接使用JPA实体管理器。Panache提出了一个替代方案，去掉了模板，暴露了一个活跃的记录和存储库模型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Panache, the &lt;code&gt;Element&lt;/code&gt; class would be as simple as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了Panache，&lt;code&gt;Element&lt;/code&gt;类就会像这样简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microservices tend to come in systems.  Let’s now imagine you need to access another HTTP endpoint.  You can use an HTTP client directly; this is nothing more than repeating boilerplate code.  Quarkus provides a way to call HTTP endpoints easily using the &lt;a href="https://quarkus.io/guides/rest-client"&gt;MicroProfile Rest Client API&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>微服务往往是以系统的形式出现的。现在让我们想象一下，你需要访问另一个HTTP端点。你可以直接使用HTTP客户端；这不过是在重复模板代码。Quarkus提供了一种方法，可以使用&lt;a href="https://quarkus.io/guides/rest-client"&gt;MicroProfile Rest Client API&lt;/a&gt;轻松调用HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First declare your service as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先声明你的服务如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each call you are intending to do, add a method and use annotations to describe the behavior.  You can combine the REST Client with the &lt;a href="https://quarkus.io/guides/smallrye-fault-tolerance"&gt;fault tolerance extension&lt;/a&gt; to handle failure gracefully.  Then, in your resource, just use the &lt;code&gt;ElementService&lt;/code&gt; interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于你打算做的每个调用，添加一个方法并使用注解来描述行为。您可以将REST客户端与&lt;a href="https://quarkus.io/guides/smallrye-fault-tolerance"&gt;容错扩展&lt;/a&gt;结合起来，以优雅地处理失败。然后，在你的资源中，只需使用&lt;code&gt;ElementService&lt;/code&gt;接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you may be wondering where the URL is configured as it’s not in the code. Remember, it must not be hard-coded because the URL likely depends on the environment. The URL is configured in the application configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但你可能想知道URL是在哪里配置的，因为它不在代码中。记住，它不能是硬编码的，因为URL很可能取决于环境。URL是在应用程序配置中设置的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL can now be updated during the deployment or at launch time using system properties or environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在可以在部署期间或在启动时使用系统属性或环境变量更新URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is not limited to HTTP.  You can use &lt;a href="https://quarkus.io/guides/grpc-getting-started"&gt;gRPC&lt;/a&gt; or &lt;a href="https://quarkus.io/guides/smallrye-graphql"&gt;GraphQL&lt;/a&gt;, two prominent alternatives in the microservice space.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus并不局限于HTTP。您可以使用&lt;a href="https://quarkus.io/guides/grpc-getting-started"&gt;gRPC&lt;/a&gt;或&lt;a href="https://quarkus.io/guides/smallrye-graphql"&gt;GraphQL&lt;/a&gt;，这是微服务领域的两个突出的替代方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a class="anchor" href="#being-reactive"&gt;&lt;/a&gt;Being reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a class="anchor" href="#being-reactive"&gt;&lt;/a&gt;响应式风格</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, Big Data, or IoT, going reactive is increasingly becoming the architecture style to follow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在过去的几年里，应用需求发生了巨大的变化。任何应用要想在云计算、大数据或物联网时代取得成功，采取响应式的做法正日益成为应遵循的架构风格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today’s users embrace applications with milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput, and elasticity. However, these features are nearly impossible to achieve using yesterday’s software architecture without a considerable investment in resources, infrastructure, and tooling. The world changed, and having dozens of servers, long response times (&amp;gt; 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今天的用户接受具有几毫秒响应时间、100%正常运行时间、更低延迟、推送数据而不是拉动、更高的吞吐量和弹性的应用程序。然而，如果不对资源、基础设施和工具进行大量投资，使用昨天的软件架构几乎不可能实现这些功能。世界变了，拥有几十台服务器、较长的响应时间（&gt;500毫秒）、因维护或瀑布式的故障而导致的停机时间，并不能满足预期的用户体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus aids you on your journey to reactive.  Quarkus is based on a &lt;a href="https://quarkus.io/version/main/guides/quarkus-reactive-architecture"&gt;reactive core&lt;/a&gt; allowing your application to mix reactive and imperative components.  As an example, you can implement reactive HTTP endpoint using the &lt;a href="https://quarkus.io/guides/resteasy-reactive"&gt;RESTEasy Reactive extension&lt;/a&gt; as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus可以帮助您实现响应式的旅程。Quarkus基于&lt;a href="https://quarkus.io/version/main/guides/quarkus-reactive-architecture"&gt;响应式核心&lt;/a&gt;，允许您的应用程序混合响应式和指令式组件。例如，您可以使用&lt;a href="https://quarkus.io/guides/resteasy-reactive"&gt;RESTEasy 响应式扩展&lt;/a&gt;实现响应式HTTP端点，具体如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , you can compose asynchronous operations and complete the result when everything is done without blocking the I/O threads.  This greatly improves resource consumption and elasticity.  Most Quarkus APIs are available in both imperative and reactive.  As example, you can use the reactive version of the REST Client:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用&lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny 响应式API&lt;/a&gt;，你可以组成异步操作，并在不阻塞I/O线程的情况下达成一切结果。这大大改善了资源消耗和弹性。大多数Quarkus API都可以使用指令式和响应式两种方式。例如，你可以使用REST客户端的响应式版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about streams? Generating a &lt;em&gt;server-sent event&lt;/em&gt; response with Quarkus is just as simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>还有，事件流怎么处理？用Quarkus生成一个&lt;em&gt;server-sent 事件&lt;/em&gt;响应也同样简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, HTTP characteristics prohibit implementing &lt;a href="https://www.reactivemanifesto.org/"&gt;reactive systems&lt;/a&gt;, where all the components interact using asynchronous messages passing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，HTTP的特性禁止实现&lt;a href="https://www.reactivemanifesto.org/"&gt;响应式系统&lt;/a&gt;，即所有组件都使用异步消息传递进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you can consume messages from various brokers such as AMQP or Apache Kafka, and process these messages smoothly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，你可以从AMQP或Apache Kafka等各种代理那里消费消息，并顺利地处理这些消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;code&gt;@Incoming&lt;/code&gt; and &lt;code&gt;@Outgoing&lt;/code&gt; annotations are part of &lt;a href="https://www.smallrye.io/smallrye-reactive-messaging"&gt;Reactive Messaging&lt;/a&gt;.  They are used to express from which &lt;em&gt;channel&lt;/em&gt; you are consuming and to which &lt;em&gt;channel&lt;/em&gt; you are sending.  Thanks to Reactive Messaging you can consume and send messages from and to different brokers and transports such as HTTP, Kafka, or &lt;a href="http://camel.apache.org"&gt;Apache Camel&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;@Incoming&lt;/code&gt; 和 &lt;code&gt;@Outgoing&lt;/code&gt; 注解是&lt;a href="https://www.smallrye.io/smallrye-reactive-messaging"&gt;响应式消息&lt;/a&gt;的一部分。它们用于表达您从哪个&lt;em&gt;channel&lt;/em&gt;消费，以及向哪个&lt;em&gt;channel&lt;/em&gt;发送。由于响应式消息传递，您可以从不同的代理和传输工具（如HTTP、Kafka或&lt;a href="http://camel.apache.org"&gt;Apache Camel&lt;/a&gt;）消费和发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you need more than just handling messages one by one.  You can also express your message processing logic using reactive programming as illustrated in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时你需要的不仅仅是逐一处理消息。你也可以使用响应式编程来表达消息处理逻辑，如下面的片段所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for the reactive APIs exposed by Quarkus, stream manipulation uses the Mutiny API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么Quarkus的采用Mutiny API作为响应式API来进行流操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments.  Quarkus provides Funqy, an approach to writing functions that are deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative Events (Cloud Events). It is also usable as a standalone service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于其出色的启动时间和较低的内存使用，您可以使用Quarkus实现在无服务器环境中使用的功能。Quarkus提供了Funqy，一种编写可部署到各种FaaS环境中的函数的方法，如AWS Lambda、Azure函数、Knative和Knative事件(云事件)。它也可以作为一个独立的服务使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Funqy, a function is just:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy函数就像是这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License version 2.0&lt;/a&gt;. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and contributors are welcome. Let’s join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个在&lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache许可证2.0版&lt;/a&gt;下许可的开源项目。首先，它是一个开放的社区，在这里，贡献、想法和讨论都是公开进行的，并且欢迎贡献者。让我们携手共建Java应用的未来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roadmap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>路线图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read about the community plans for the future. Here is &lt;a href="https://github.com/orgs/quarkusio/projects/5"&gt;our current roadmap&lt;/a&gt;. This is driven by the community, come and tell us what &lt;i&gt;your&lt;/i&gt; needs are.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>阅读有关社区未来的计划。这里是&lt;a href="https://github.com/orgs/quarkusio/projects/5"&gt;我们目前的路线图&lt;/a&gt;。这是由社区推动的，来告诉我们&lt;i&gt;你&lt;/i&gt;的需求是什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code and Issue Tracker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码和问题跟踪</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code is hosted on &lt;a href="https://github.com/quarkusio/quarkus"&gt;GitHub&lt;/a&gt;. If you need to report a bug or request a new feature, look for a similar one on our &lt;a href="https://github.com/quarkusio/quarkus/issues"&gt;GitHub issue tracker&lt;/a&gt;. If you don’t find any, &lt;a href="https://github.com/quarkusio/quarkus/issues/new/choose"&gt;create a new issue&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>源代码被托管在&lt;a href="https://github.com/quarkusio/quarkus"&gt;GitHub&lt;/a&gt;。如果您需要报告一个错误或要求一个新功能，请在我们的&lt;a href="https://github.com/quarkusio/quarkus/issues"&gt;GitHub问题跟踪&lt;/a&gt;上寻找类似的问题。如果您没有找到，&lt;a href="https://github.com/quarkusio/quarkus/issues/new/choose"&gt;创建一个新问题&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write QuickStart Guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写快速入门指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are always new users trying to get started quickly. Share your experience with everyone by writing a Quickstart and submitting it for peer review.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>总有一些新用户试图快速入门。通过撰写 "快速入门 "并提交给同行评审，与大家分享你的经验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write New Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写新的扩展程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are an extension developer or want to contribute to Quarkus development, join our mailing list either &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;emailing us&lt;/a&gt; or by visiting our &lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groups page&lt;/a&gt;. Make sure you visit our extensive &lt;a href="{{site.baseurl}}/guides/writing-extensions"&gt;Writing extensions guide&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是一个扩展程序的开发者，或者想为Quarkus的发展做出贡献，请加入我们的邮件列表，可以&lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;给我们写信&lt;/a&gt;，或者访问我们的&lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groups页面&lt;/a&gt;。请务必访问我们广泛的&lt;a href="{{site.baseurl}}/guides/writing-extensions"&gt;写作扩展指南&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A periodical video podcast hosted by Quarkus Developers about things moving in and around Quarkus ecosystem. View the &lt;a href="{{site.baseurl}}/insights"&gt;live podcasts&lt;/a&gt; and check out older episodes on the Podcasts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由Quarkus开发者主持的定期视频播客，讲述Quarkus生态系统内和周边事物。查看&lt;a href="{{site.baseurl}}/insights"&gt;实时播客&lt;/a&gt;，并在播客中查看先前的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow Quarkus on Twitter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Twitter上关注Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of our updates go out on &lt;a href="https://twitter.com/quarkusio"&gt;Twitter&lt;/a&gt;. Sometimes our project team speaks at industry events, and sometimes they post cool ways people use Quarkus. Wash, rinse, and retweet.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的大部分更新都是在&lt;a href="https://twitter.com/quarkusio"&gt;Twitter&lt;/a&gt;上发布的。有时我们的项目团队会在行业活动中发言，有时他们会发布人们使用Quarkus的很酷的方法。欢迎一键三连，多多转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community publishes thoughtful how-to videos to help you get started. Check them out on &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;YouTube&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus社区发布了周到的操作视频，以帮助您开始使用。请在&lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;YouTube&lt;/a&gt;上查看它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Publications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are heaps of helpful &lt;a href="{{site.baseurl}}/publications"&gt;articles and blog posts&lt;/a&gt; out there presenting interesting use-cases and examples of Quarkus in action.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有很多有用的&lt;a href="{{site.baseurl}}/publications"&gt;文章和博文&lt;/a&gt;，介绍了Quarkus的有趣用例和实际应用的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Newsletter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新闻</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subscribe to the &lt;a href="{{site.baseurl}}/newsletter"&gt;monthly newsletter&lt;/a&gt; to have choice Quarkus content from across our community delivered to your inbox.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>订阅&lt;a href="{{site.baseurl}}/newsletter"&gt;每月通讯&lt;/a&gt;，将来自我们整个社区的Quarkus精选内容发送到您的收件箱。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Awards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>获奖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Share in our excitement when the project receives &lt;a href="{{site.baseurl}}/awards"&gt;awards and recognition&lt;/a&gt; for all of the hard work done by the community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为社区所做的所有辛勤工作，当项目获得&lt;a href="{{site.baseurl}}/awards"&gt;奖项和认可&lt;/a&gt;时，分享我们的兴奋之情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Report a Vulnerability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>报告漏洞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Found a security vulnerability in Quarkus, its extensions or the dependencies they use? See the &lt;a href="{{site.baseurl}}/security"&gt;security policy page&lt;/a&gt; to learn to report it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus、其扩展或其使用的依赖项中发现了安全漏洞？请参阅&lt;a href="{{site.baseurl}}/security"&gt;安全策略页面&lt;/a&gt;，了解如何报告它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Books</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>书籍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get new and deeper views into Quarkus from the community through &lt;a href="{{site.baseurl}}/books"&gt;these great books&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 &lt;a href="{{site.baseurl}}/books"&gt;这些很棒的书&lt;/a&gt;，从社区获得对Quarkus新的、更深入的看法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The core foundation of every good open source project is open discussion and collaboration. Quarkus is committed to this belief. We've enabled GitHub Discussions so the community can have open communication. This gives a focal point for the community to ask and answer questions regarding the project. This means all of that great knowledge can be shared and is discoverable. Additionally, other conversations about the Quarkus Community can be had there as well. Come collaborate with us.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每个好的开源项目的核心基础是公开讨论和合作。Quarkus致力于这一信念。我们已经启用了GitHub讨论，以便社区能够进行公开交流。这为社区提供了一个焦点，以提出和回答关于项目的问题。这意味着所有这些伟大的知识都可以被分享和发现。此外，关于Quarkus社区的其他对话也可以在这里进行。来与我们合作吧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For usage questions, we recommend to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于使用问题，我们建议到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow with the &lt;code&gt;quarkus&lt;/code&gt; tag&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow的&lt;code&gt;quarkus&lt;/code&gt;标签&lt;/a&gt;下提问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For questions related to the development of Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于与Quarkus自身开发相关的问题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;a href="https://groups.google.com/d/forum/quarkus-dev" target="_blank"&gt;quarkus-dev Google Groups&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以访问 &lt;a href="https://groups.google.com/d/forum/quarkus-dev" target="_blank"&gt;quarkus-dev Google Groups&lt;/a&gt;讨论组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chat using &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或在 &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream) 聊天室发问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Quarkus?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional Java stacks were engineered for monolithic applications with long startup times and large memory requirements in a world where the cloud, containers, and Kubernetes did not exist. Java frameworks needed to evolve to meet the needs of this new world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的Java堆栈是为单体应用设计的，启动时间长，内存需求大，而当时还没有云、容器和Kubernetes的存在。Java框架需要发展以满足这个新世界的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was created to enable Java developers to create applications for a modern, cloud-native world. Quarkus is a Kubernetes-native Java framework tailored for GraalVM and HotSpot, crafted from best-of-breed Java libraries and standards. The goal is to make Java the leading platform in Kubernetes and serverless environments while offering developers a framework to address a wider range of distributed application architectures.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的创建是为了使Java开发人员能够为现代的、云原生的世界创建应用程序。Quarkus是一个为GraalVM和HotSpot定制的Kubernetes原生Java框架，由最佳的Java库和标准精心打造。其目标是使Java成为Kubernetes和无服务器环境的领先平台，同时为开发者提供一个框架，以解决更广泛的分布式应用架构问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open Source Utterly and Absolutely</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全和绝对地开放源代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What Makes Quarkus Different?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是什么让Quarkus与众不同？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developers are critical to the success of almost every organization and they need the tools to build cloud-native applications quickly and efficiently. Quarkus provides a frictionless development experience through a combination of tools, libraries, extensions, and more. Quarkus makes developers more efficient with tools to improve the inner loop development cycle while in dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发人员对几乎每个组织的成功都至关重要，他们需要工具来快速、高效地构建云原生应用程序。Quarkus通过工具、库、扩展等的组合提供了无摩擦的开发体验。Quarkus通过工具使开发人员在开发模式下更有效率地改善内循环开发周期。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was built from the ground up for Kubernetes making it easy to deploy applications without having to understand all of the complexities of the platform. Quarkus allows developers to automatically generate Kubernetes resources including building and deploying container images without having to manually create YAML files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是为Kubernetes建立的，使其能够轻松部署应用程序，而无需了解该平台的所有复杂性。Quarkus允许开发者自动生成Kubernetes资源，包括构建和部署容器镜像，而无需手动创建YAML文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Best of Breed Libraries and Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最好的类库和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of hundreds of best-of-breed libraries that you love and use. All wired on a standard backbone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个内聚的、使用起来有趣的全栈框架，它利用了您所喜爱和使用的数百个最佳组合库，都将其连接在一个标准主干上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative and reactive code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式和响应式代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is designed to seamlessly combine the familiar imperative style code and the non-blocking, reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的设计是为了在开发应用程序时将熟悉的指令式和非阻塞的响应式代码无缝结合起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is helpful for both Java developers who are used to working with the imperative model and don’t want to switch things up, and those working with a cloud-native/reactive approach. The Quarkus development model can adapt itself to whatever app you’re developing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这对于那些习惯于使用指令式模型并且不想改变的Java开发人员，以及那些使用原生云/响应式方法的开发人员都是有帮助的。Quarkus开发模型可以适应您正在开发的任何应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickly Bootstrap Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>快速引导您的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With &lt;a href="https://code.quarkus.io/"&gt;code.quarkus.io&lt;/a&gt;, in a few clicks, you can bootstrap your Quarkus application and discover its extension ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 &lt;a href="https://code.quarkus.io/"&gt;code.quarkus.io&lt;/a&gt;链接, 只需几次单击就可以引导您的Quarkus应用程序并发现其扩展生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the wide breadth of technologies Quarkus with which applications can be made.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索Quarkus可以应用的广泛的技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The combination of Quarkus and Kubernetes provides an ideal environment for creating scalable, fast, and lightweight applications. Quarkus significantly increases developer productivity with tooling, pre-built integrations, application services, and more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus和Kubernetes的组合为创建可伸缩、快速和轻量级的应用程序提供了理想的环境。Quarkus通过工具、预构建集成、应用程序服务等显著提高了开发人员的生产率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does it mean to be a Kubernetes-native framework?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为一个Kubernetes原生框架意味着什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single-step Deployments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>单步执行部署</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes it easy to deploy microservice applications to Kubernetes without having to understand the intricacies of the underlying Kubernetes framework. Extensions are available for Kubernetes, and Kubernetes distributions, to facilitate this process with only a minimal amount of configuration variables needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus使得在Kubernetes上部署微服务应用变得容易，而不需要了解Kubernetes底层框架的复杂性。Kubernetes和Kubernetes发行版都有相应的扩展，以促进这个过程，只需要最小的配置变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Kubernetes extension, developers can perform or automate a single-step deployment using Jib, Docker, and Source-to-Image (S2i) including the creation of DeploymentConfig to trigger automatic redeployments. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Kubernetes扩展，开发人员可以使用Jib、Docker和Source-to-Image（S2i）执行或自动进行单步部署，包括创建DeploymentConfig以触发自动重新部署。 &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;阅读指南了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, Quarkus includes extensions that make it easy to deploy serverless microservices to cloud providers including AWS Lambda, Azure Functions, and Google Cloud Functions as well as Knative to take advantage of Quarkus application’s fast startup times. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，Quarkus还包括一些扩展，使其能够轻松地将无服务器微服务部署到云提供商，包括AWS Lambda、Azure Functions和Google Cloud Functions以及Knative，以获得Quarkus应用程序的快速启动时间方面优势。&lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing &amp; Debugging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追踪和调试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides developers the tools and capabilities to troubleshoot distributed microservices applications in Kubernetes including tracing and debugging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为开发者提供了工具和能力，以解决Kubernetes中分布式微服务应用程序的故障，包括跟踪和调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus utilizes &lt;a href="https://opentracing.io/" target="_blank"&gt;OpenTracing&lt;/a&gt; which is a vendor-agnostic API to help developers easily instrument tracing into their codebase. Distributed tracing helps pinpoint where failures occur and what causes poor performance. &lt;a href="{{site.baseurl}}/guides/opentracing"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 利用&lt;a href="https://opentracing.io/" target="_blank"&gt;OpenTracing&lt;/a&gt;，这是一个与供应商无关的 API，可帮助开发人员轻松地将跟踪功能纳入其代码库。分布式跟踪有助于确定故障发生的位置以及导致性能不佳的原因。 &lt;a href="{{site.baseurl}}/guides/opentracing"&gt;阅读该指南以了解更多详情&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Health &amp; Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用健康和指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus leverages SmallRye Health, an implementation of the MicroProfile Health specification. This allows applications to provide information about their state to external viewers in a Kubernetes environment where automated processes must be able to determine whether the application should be discarded or restarted. &lt;a href="{{site.baseurl}}/guides/microprofile-health"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus利用SmallRye Health，这是MicroProfile Health规范的一个实现。这允许应用程序在Kubernetes环境中向外部查看者提供有关其状态的信息，在这种环境中，自动化流程必须能够确定应用程序是否应该被丢弃或重新启动。 &lt;a href="{site.baseurl}}/guides/microprofile-health"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus utilizes the &lt;a href="https://micrometer.io/" target="_blank"&gt;Micrometer&lt;/a&gt; metrics library for runtime and application metrics. It provides a simple facade for the most popular monitoring systems to instrument your JVM-based application code without vendor lock-in. Application-specific and built-in metrics can be exposed using Micrometer. &lt;a href="{{site.baseurl}}/guides/micrometer#support-for-the-microprofile-metrics-api"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus利用&lt;a href="https://micrometer.io/" target="_blank"&gt;Micrometer&lt;/a&gt;度量库来实现运行时和应用程序的度量。它为最流行的监控系统提供了一个简单的接口，以便在不锁定供应商的情况下对基于JVM的应用程序代码进行检测。&lt;a href="{{site.baseurl}}/guides/micrometer#support-for-the-microprofile-metrics-api"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes an extension that allows developers to use Kubernetes ConfigMaps and Secrets as a configuration source, without having to mount them into the Pod running the Quarkus application or make any other modifications to their Kubernetes Deployment (or Openshift DeploymentConfig) &lt;a href="{{site.baseurl}}/guides/kubernetes-config"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus包含一个扩展，允许开发者使用Kubernetes ConfigMaps和Secrets作为配置源，而无需将它们挂载到运行Quarkus应用的Pod中，也无需对Kubernetes的部署(或Openshift DeploymentConfig)进行任何修改。&lt;a href="{{site.baseurl}}/guides/kubernetes-config"&gt;阅读指南了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote Development</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>远程开发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create and debug applications in the same environment where applications run. Live coding in development mode where any changes made locally will be immediately visible in a clustered Kubernetes environment. &lt;a href="https://developers.redhat.com/blog/2021/02/11/enhancing-the-development-loop-with-quarkus-remote-development"&gt;Read this blog post for greater insight.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在应用程序运行的同一环境中创建和调试应用程序。在开发模式下的实时编码，在集群化的Kubernetes环境中，本地做出的任何更改都将立即可见。&lt;a href="https://developers.redhat.com/blog/2021/02/11/enhancing-the-development-loop-with-quarkus-remote-development"&gt;阅读这篇博客可以获得更深刻的见解&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/about/"&gt;About &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/about/"&gt;关于&lt;i class="fas fa-chevron-down"&gt; &lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;WHAT IS QUARKUS?&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;QUARKUS是什么？&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/container-first" class="{% if page.url contains '/container-first/' %}active{% endif %}"&gt;CONTAINER FIRST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/container-first" class="{% if page.url contains '/container-first/' %}active{% endif %}"&gt;容器优先 &lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;DEVELOPER JOY&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;开发者的乐趣 &lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Learn &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;学习 &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;GET STARTED&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;入门&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides" class="{% if page.url contains '/guides/' %}active{% endif %}"&gt;GUIDES&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides" class="{% if page.url contains '/guides/' %}active{% endif %}" &gt;指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Extensions &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;扩展&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog" class="{% if page.url contains '/catalog/' %}active{% endif %}"&gt;EXTENSION CATALOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/catalog" class="{% if page.url contains '/catalog/' %}active{% endif %}"&gt;扩展目录&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/useextensions" class="{% if page.url contains '/useextensions/' %}active{% endif %}"&gt;USE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/useextensions" class="{% if page.url contains '/useextensions/' %}active{% endif %}"&gt;使用扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/createextensions" class="{% if page.url contains '/createextensions/' %}active{% endif %}"&gt;CREATE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/createextensions" class="{% if page.url contains '/createextensions/' %}active{% endif %}"&gt;创建扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Community &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;社区&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}" &gt;博客&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}" &gt;播客&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is not just about being great for writing Web Applications or Micro-Services. We’re focusing on more than the feature set: we make sure that every feature works well, simply, with little to no configuration, in the most intuitive way possible. It should be trivial to develop simple things, and easy to develop the more complex ones.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus不仅仅是为编写网络应用程序或微服务提供良好的条件。我们关注的不仅仅是功能集：我们要确保每个功能都能很好地工作，简单地工作，几乎不需要配置，以最直观的方式进行。开发简单的东西应该是微不足道的，而开发更复杂的东西应该是容易的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Improve and expedite the inner loop development process with live coding where code changes are automatically reflected in your running application. code -&gt; refresh browser -&gt; repeat</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过实时编码改善和加快内循环开发过程，代码的变化会自动反映在你运行的应用程序中。 代码 -&gt; 刷新浏览器 -&gt; 重复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode/"&gt;Read the Dev Mode guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/maven-tooling#dev-mode/"&gt;阅读开发模式指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unified Config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gone are the days of a thousand configuration files and formats. A single configuration file is all it takes for Quarkus applications to configure every single extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>千篇一律的配置文件和格式的时代已经过去了。Quarkus应用程序只需要一个配置文件就可以配置每一个扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Opinionated</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有态度的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus focuses on the simplest and most useful way to use a given feature, trimming it to its most useful essence. This includes upfront analysis on how to best use a feature and guiding you in what we think is the best way to do things.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus专注于使用给定特性最简单和最有用的方法，将其裁剪到最有用的本质。这包括关于如何最好地使用一个功能的前期分析，以及指导您我们认为最好的做事方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visualize and configure extensions as well as access to application logs and testing components</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可视化和配置扩展，以及访问应用程序日志和测试组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Read the Dev UI guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/dev-ui"&gt;阅读开发用户界面指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic provisioning and application wiring of supporting services such as databases, identity servers, and more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持服务(如数据库、标识服务器等)的自动配置和应用程序连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-services"&gt;Read the Dev Services guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/dev-services"&gt;阅读开发服务指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get instant feedback on code changes as tests run in the background on impacted code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当测试在后台对受影响的代码运行时，获得对代码变化的即时反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/continuous-testing"&gt;Read the Continuous Testing guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/continuous-testing"&gt;阅读持续测试指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Interface</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令行界面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create projects, manage extensions, and execute essential build and dev commands.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建项目，管理扩展，并执行基本的构建和开发命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run &lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode"&gt;dev mode&lt;/a&gt; remotely with changes to local files immediately available in a containerize environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行远程 &lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode"&gt;开发者模式&lt;/a&gt; 可以在容器化环境中立即对本地文件进行更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://github.com/quarkusio/quarkus/discussions/categories/events"&gt;Check out the "Events" section of Quarkus Discussions&lt;/a&gt; for additional community related events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://github.com/quarkusio/quarkus/discussions/categories/events"&gt;查看Quarkus讨论组的”活动“部分&lt;/a&gt; 参与其他社区相关活动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Need More Than Community Support?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要超出社区范围的支持?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you require a higher level of support, you have options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要更高级别的支持，您可以选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Red Hat Build of Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>红帽的Quarkus构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enterprise support provided by Red Hat for the product.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该产品由红帽公司提供企业级支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feedback and Help</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反馈和帮助</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the &lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;Discussions&lt;/a&gt; section on our GitHub project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用我们GitHub项目上的&lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;讨论&lt;/a&gt;部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chat using &lt;a href="https://quarkusio.zulipchat.com" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或在 &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream) 聊天室发问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your help is more than welcome! Don’t hesitate to join the crowd.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们非常欢迎您的帮助！不要犹豫，加入我们大家吧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Join the Quarkus Community</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>加入Quarkus社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out our &lt;a href="https://github.com/quarkusio/quarkus" target="_blank"&gt;GitHub&lt;/a&gt; for details on reporting issues and the process for submitting pull requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看我们的&lt;a href="https://github.com/quarkusio/quarkus" target="_blank"&gt;GitHub&lt;/a&gt;，了解有关报告问题和提交合并请求流程的详细信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every contribution is valuable. It can be a bug report, an example application, a feature request, a fix in the documentation or just feedback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每一份贡献都是有价值的。它可以是bug报告、示例应用程序、功能请求、文档中的修复或仅仅是反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;1&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;1&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install via Command Line Interface</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过命令行界面安装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open your favorite terminal and use JBang to install the Quarkus CLI. You do not need to have Java installed first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开您喜欢的终端并使用JBang安装Quarkus CLI。您不需要首先安装Java。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux, macOS, and Windows (using WSL or bash compatible shell like Cygwin or MinGW)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Linux、macOS和Windows（使用WSL或bash兼容的shell，如Cygwin或MinGW）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Windows using Powershell</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>面向Windows使用Powershell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, you can also install the CLI with SDKMAN!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，您也可以用SDKMAN安装CLI！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more options, such as Homebrew or Chocolatey, see &lt;a href="/guides/cli-tooling"&gt;the Quarkus CLI guide&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多的选项，如Homebrew或Chocolatey，请参见&lt;a href="/guides/cli-tooling"&gt;Quarkus CLI指南&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;2&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;2&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the Getting Started Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 "入门 "应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run this script in your CLI:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的CLI中运行这个脚本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;3&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;3&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the Getting Started Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行 "入门 "应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boom! Your Quarkus app is now running at &lt;code&gt;localhost:8080&lt;/code&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当当当！您的Quarkus应用已经在&lt;code&gt;localhost:8080&lt;/code&gt;运行了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;4&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;4&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus进行实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes it easy to change your code on the fly. Let's modify the &lt;a href="localhost:8080/hello"&gt;RESTful endpoint&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus使您可以轻松地动态更改代码。让我们修改 &lt;a href="localhost:8080/hello"&gt;RESTful 端点&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open &lt;code&gt;src/main/java/GreetingsResource.java&lt;/code&gt; in a text editor or your &lt;a href="https://quarkus.io/guides/ide-tooling"&gt;favorite IDE&lt;/a&gt; and change "hello RESTEasy" to "hola RESTEasy". Then refresh the browser and see the changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用文本编辑器或您惯用的 &lt;a href="https://quarkus.io/guides/ide-tooling"&gt;IDE&lt;/a&gt; 打开&lt;code&gt;src/main/java/GreetingsResource.java&lt;/code&gt; ，把 ”hello RESTEasy“ 改为 ”你好 RESTEasy“。然后刷新浏览器并查看更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cool stuff right? &lt;a href="https://quarkus.io/guides/maven-tooling#dev-mode"&gt;Learn more about Quarkus's dev mode&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很Cool的东东对吧？&lt;a href="https://quarkus.io/guides/maven-tooling#dev-mode"&gt;了解更多Quarkus的开发模式&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supersonic Subatomic Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>超音速 亚原子 Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes Native Java栈为OpenJDK HotSpot和GraalVM量身定制，从Java库和标准中精心打造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Available</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现已可用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A cohesive platform for optimized developer joy:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个优化开发者乐趣的有凝聚力的平台：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unified configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Zero config, live reload in the blink of an eye</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>零配置，瞬间重新加载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Streamlined code for the 80% common usages, flexible for the 20%</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化80%的常用代码，灵活处理剩余的20%</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No hassle native executable generation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>轻松生成本机可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/vision/developer-joy"&gt;Learn more&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/vision/developer-joy"&gt;了解更多&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of hundreds of best-of-breed libraries that you love and use. All wired on a standard backbone. &lt;a href="/vision/standards"&gt;Learn more about Quarkus Extensions&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个内聚的、使用起来有趣的全栈框架，它利用了您所喜爱和使用的数百个最佳组合库，都将其连接在一个标准主干上。&lt;a href="/vision/standards"&gt;了解更多关于Quarkus扩展的信息&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUPERSONIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>超音速&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUBATOMIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>亚原子&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;Read the release notes&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;阅读发布说明&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog"&gt;Extension Catalog&lt;/a&gt; &lt;i class="fas fa-chevron-right"&gt;&lt;/i&gt; {{ page.title }}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/catalog"&gt;扩展目录&lt;/a&gt; &lt;i class="fas fa-chevron-right"&gt;&lt;/i&gt; {{ page.title }}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Title Quarkiverse-JBeret</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展标题Quarkiverse-JBeret</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provided by the JBeret Project Team</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由JBeret项目组提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus JBeret Extension adds support for JSR-352 Batch Applications for the Java Platform. JBeret is an implementation of the JSR-352.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus JBeret Extension增加了对Java平台的JSR-352批处理应用的支持。JBeret是JSR-352的一个实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DOCUMENTATION</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure use the documentation to have your questions answered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保使用文档来寻求问题答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS GUIDES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QUARKUS指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get a better understanding on how to use this extension in the Quarkus Guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在Quarkus指南中更好地了解如何使用这个扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out these applicable guides:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看这些适用的指南：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>USAGE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the extension, add the dependency to the target project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用该扩展，请将该依赖性添加到目标项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch API and Runtime will be available out of the box. Please refer to the &lt;a href="#"&gt;Batch documentation&lt;/a&gt;, or the &lt;a href="#"&gt;JBeret documentation&lt;/a&gt; to learn about Batch Applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API和运行时将是开箱即用的。请参考&lt;a href=""&gt;批处理文档&lt;/a&gt;，或&lt;a href=""&gt;JBeret文档&lt;/a&gt;以了解批处理应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CONFIGURATION</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret Quarkus extension supports the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret Quarkus扩展支持以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The repository type to store JBeret and Job data. A jdbc type requires a JDBC datasource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>存储JBeret和Job数据的存储库类型。jdbc类型需要JDBC数据源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NON-STANDARD FEATURES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非标准功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch API requires the @BatchProperty annotation to inject the specific configuration from the batch definition file. Instead, you can use the @ConfigProperty annotation, which is used to inject configuration properties in Quarkus using the MicroProfile Config API and keep consistency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API需要@BatchProperty注解来注入批处理定义文件中的特定配置。或者，你可以使用@ConfigProperty注解，它被用来在Quarkus中使用MicroProfile配置API注入配置属性，并保持一致性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although, there is a slight limitation: since job configuration is mostly dynamic and only injected on job execution, Quarkus may fail to start due to invalid configuration (can’t find the Job configuration values). In this case, configuration injection points with the @ConfigProperty annotation need to set a default value or use an Optional.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然，有一个小小的限制：由于作业配置大多是动态的，并且只在作业执行时注入，Quarkus可能会因为无效的配置（找不到作业配置值）而启动失败。在这种情况下，带有@ConfigProperty注解的配置注入点需要设置一个默认值或使用一个Optional。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch APIs JobOperator and JobRepository are available as CDI beans, so they can be injected directly into any code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API的JobOperator和JobRepository可以作为CDI Bean使用，所以它们可以直接注入到任何代码中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret Scheduler is integrated out of the box in this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个扩展中，JBeret Scheduler是开箱即用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To schedule a Job execution, please refer to the quarkus.jberet.job.”job-name”.cron and quarkus.jberet.job.”job-name”.params.”param-key” configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要安排工作的执行，请参考quarkus.jberet.job.”job-name”.cron和quarkus.jberet.job.”job-name”.params.”param-key”配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Job can also be scheduled programmatically, using the JobScheduler API and the Quarkus startup event:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作业也可以通过程序安排，使用JobScheduler API和Quarkus的启动事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JobScheduler does not support persistent schedules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JobScheduler不支持持久化调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret REST is integrated as separate extension that can be easily added to the target project with the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret REST被集成为独立的扩展，可以通过以下依赖关系轻松地添加到目标项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret REST API, provides REST resources to several operations around the Batch API: starting and stopping jobs, querying the status of a job, schedule a job, and many more. The extension includes a REST client to simplify the REST API calls:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret REST API，为围绕Batch API的几个操作提供REST资源：启动和停止作业、查询作业状态、安排作业等等。该扩展包括一个REST客户端来简化REST API的调用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>EXAMPLE APPLICATIONS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code&gt;chunk&lt;/code&gt; - A simple Job that reads, processes, and stores data from a file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;chunk&lt;/code&gt; - 一个简单的作业，从文件中读取、处理和存储数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code&gt;jdbc-repository&lt;/code&gt; - A Job that uses a jdbc datasource to store JBeret and Job metadata.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;jdbc-repository&lt;/code&gt; - 一个使用jdbc数据源来存储JBeret和作业元数据的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or take a look into the World of Warcraft Auctions - Batch Application. It downloads the World of Warcraft Auction House data and provides statistics about items prices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者看看《魔兽世界》的拍卖 - 批处理应用。它下载魔兽世界拍卖行的数据并提供物品价格的统计数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CONTRIBUTORS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks goes to these wonderful people:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>感谢这些优秀的人：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This project follows the &lt;a href="#"&gt;all-contributors&lt;/a&gt; specification. Contributions of any kind welcome!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本项目遵循&lt;a href="#"&gt;所有贡献者&lt;/a&gt;规范。欢迎任何形式的贡献!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>LICENSE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>许可证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Version</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatible with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Quarkus兼容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;Passing&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;通过&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Repository</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;Documentation&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;文档&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maintainer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>维护者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Homepage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目主页</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>缺陷</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pull Requests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>合并请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Size</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大小</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last Publish Date</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后发布日期</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jan 01, 2021</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年1月1日</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Weekly Builds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每周构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Total Builds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>总构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Created on</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jan 01, 2016</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2016年1月1日</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributors</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;62 Contributors&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;62位贡献者&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/community/"&gt;Community &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/community/"&gt;社区 &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kube-Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kube-Native</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus tailors your application for GraalVM and HotSpot. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes. We use a technique we call compile time boot.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为GraalVM和HotSpot定制你的应用程序。令人惊讶的快速启动时间，令人难以置信的低RSS内存（不仅仅是堆的大小！），在Kubernetes等容器协调平台中提供近乎即时的扩展和高密度的内存利用。我们使用一种我们称之为编译时启动的技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/container-first"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/container-first"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unifies imperative and reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一指令式和响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combine both the familiar imperative code and the reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发应用程序时，将熟悉的指令式和响应式代码风格结合起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/continuum"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/continuum"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Community and Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>社区和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of over fifty best-of-breed libraries that you love and use. All wired on a standard backbone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个有凝聚力的、有趣的、全栈式的框架，它利用了各类不断增长的50多个你喜欢和使用的最好的库。所有这些都在一个标准的主干上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/standards"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/standards"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/developer-joy"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/vision/developer-joy"&gt;了解更多&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the outset, Quarkus has been designed around a container-first philosophy. What this means in concrete terms is that Quarkus applications are optimised for low memory usage and fast startup times in the following ways:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从一开始，Quarkus的设计就围绕着容器优先的理念。这意味着Quarkus应用程序在以下方面进行了优化，以达到低内存使用和快速启动的目的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建时处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The central idea behind Quarkus is to do at build-time what traditional frameworks do at runtime: configuration parsing, classpath scanning, feature toggle based on classloading, and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的中心思想是在构建时做传统框架在运行时做的事情：配置解析、classpath扫描、基于classloading的功能切换，等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much processing as possible is done at build time; thus, your application only contains the classes used at runtime. In traditional frameworks, all the classes required to perform the initial application deployment hang around for the application’s life, even though they are only used once. With Quarkus, they are not even loaded into the production JVM! Quarkus does not stop here. During the build-time processing, it prepares the initialization of all components used by your application. It results in less memory usage and faster startup time as all metadata processing has already been done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尽可能将更多的处理在构建时完成；因此，你的应用程序只包含在运行时使用的类。在传统的框架中，所有执行初始应用部署所需的类都在应用的生命周期中存在，尽管它们只被使用一次。在Quarkus中，它们甚至不会被加载到生产用的JVM中。Quarkus并没有到此为止。在构建时的处理过程中，它为你的应用程序使用的所有组件的初始化做准备。由于所有的元数据处理都已经完成，这带来了更少的内存使用和更快的启动时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible Quarkus tries to avoid reflection, reducing startup time and memory usage. During the built-time processing, extensions can analyze the application code and the classes available on the classpath and replace reflection calls with regular invocations. The usage of dynamic proxies is also prevented by using generating custom proxy at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus尽可能地避免反射，减少启动时间和内存使用。在构建时的处理过程中，扩展可以分析应用程序代码和classpath上可用的类，并以常规调用取代反射调用。通过在构建时使用生成的自定义代理，也可以防止使用动态代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arc, the dependency injection framework used by Quarkus, eliminates all the reflection calls and deduces the injection graph at build time. So, when the application starts, no expensive lookups; it’s done already!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Arc是Quarkus使用的依赖注入框架，它消除了所有的反射调用，并在构建时推断出注入图。因此，当应用程序启动时，不需要昂贵的查找，它已经完成了!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First-Class Support for GraalVM Native Images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>优秀的对GraalVM原生镜像支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM Native Executable support has been an essential part of the design for Quarkus from the beginning. When an application is compiled down to a native executable, it starts much faster and can run with a much smaller heap than a standard JVM. The native compiler uses aggressive dead-code elimination techniques to only embed the parts of the JVM and classes that are absolutely required by your application. Quarkus makes building optimized native executables plain easy. The build-time approach allows Quarkus to collect enough metadata on your application to fine-tune the compilation. No &lt;code&gt;-H:+ReportUnsupportedElementsAtRuntime&lt;/code&gt; flag, no fallback, no compromise!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM原生可执行文件支持从一开始就是Quarkus设计的重要组成部分。当一个应用程序被编译成一个原生可执行文件时，它的启动速度要快得多，并且可以在比标准JVM小得多的堆中运行。原生编译器使用积极的死代码消除技术，只嵌入JVM的部分和应用程序绝对需要的类。Quarkus使构建优化的原生可执行文件变得非常容易。构建时的方法允许Quarkus在你的应用程序上收集足够的元数据，以便对编译进行微调。没有&lt;code&gt;-H:+ReportUnsupportedElementsAtRuntime&lt;/code&gt;标志，没有回退，没有妥协！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Pre-Boot</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生镜像预启动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We pre-boot as many of the frameworks as possible during the native compilation of a Quarkus application. It means that the resulting native executable has already run most of the startup code and serialized the result into the executable: even faster startup!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus应用程序的原生编译过程中，我们尽可能多地对框架进行预启动。这意味着产生的原生可执行文件已经运行了大部分的启动代码，并将结果序列化到可执行文件中：启动速度更快！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the techniques allowing reducing the memory usage and provide faster startup times are not only advantageous in containers. Even on bare metal, it would reduce your memory pressure, and it’s always pleasant to not have to wait 10 seconds to see your application running.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有允许减少内存使用和提供更快的启动时间的技术，不仅在容器中是有利的。即使在裸金属环境上，它也会减少你的内存压力，而且不必等待10秒就能看到你的应用程序运行，这总是令人愉快的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Quarkus was designed, we didn’t focus only on containers but also on deploying Quarkus applications on container orchestrators such as Kubernetes. Quarkus build-time processing also generates the Kubernetes metadata, so your application is ready to be deployed on Kubernetes. Runtime capabilities such as health checks and metrics are exposed out of the box. Quarkus collects all the required metadata at build time to create the Kubernetes deployment descriptor and produce a container image. A single command line can deploy your application onto your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在设计Quarkus时，我们不仅关注容器，还关注将Quarkus应用程序部署到容器协调器(如Kubernetes)上。Quarkus构建时处理还会生成Kubernetes元数据，这样就可以将应用程序部署到Kubernetes上了。运行时功能(如健康检查和指标)是开箱即用的。Quarkus在构建时收集所有必需的元数据，以创建Kubernetes部署描述符并生成容器镜像。一个命令行就可以将应用程序部署到Kubernetes集群上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus tailors your application for GraalVM and HotSpot. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes. We use a technique we call compile time boot. &lt;a href="/vision/container-first"&gt;Learn more.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为GraalVM和HotSpot定制您的应用程序。惊人的快速启动时间，令人难以置信的低RSS内存（不仅仅是堆大小！）提供近乎即时的扩展和在Kubernetes等容器编排平台中高密度内存利用率。我们使用一种称为编译时引导的技术。&lt;a href="/vision/container-first"&gt;了解更多信息。&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.versions.maven }}&lt;/a&gt; or &lt;a href="https://gradle.org/" target="_blank"&gt;Gradle&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.version.maven }}&lt;/a&gt;或&lt;a href="https://gradle.org/" target="_blank"&gt;Gradle&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Help from the Community</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从社区获得帮助</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a lot of documentation. Be sure to check our &lt;a href="{{site.baseurl}}/get-started/"&gt;Getting started page&lt;/a&gt;, and all our &lt;a href="{{site.baseurl}}/guides/"&gt;guides&lt;/a&gt;. Also check out our &lt;a href="{{site.baseurl}}/faq/"&gt;FAQ section&lt;/a&gt; and &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips Playlist&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们有大量的文档。请务必查看我们的&lt;a href="{{site.baseurl}}/get-started/"&gt;入门页面&lt;/a&gt;，以及我们所有的&lt;a href="{{site.baseurl}}/guides/"&gt;指南&lt;/a&gt;。还可以查看我们的&lt;a href="{{site.baseurl}}/faq/"&gt;FAQ部分&lt;/a&gt;和&lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips 播放列表&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stack Overflow</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stack Overflow</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask your questions on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow&lt;/a&gt;. After the documentation, it’s probably the best place to look for answers. We actively monitor the &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Quarkus tag&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow&lt;/a&gt;上提出您的问题。在文档化之后，它可能是寻找答案的最佳地方。我们积极跟踪&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Quarkus标签&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discussions and Collaboration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>讨论与合作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out our &lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;GitHub Discussions&lt;/a&gt; collaboration area to interact with other Quarkus users and developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看我们的&lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;GitHub讨论&lt;/a&gt;协作区，与其他Quarkus用户和开发人员进行互动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discuss the development of Quarkus with the team in the &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;development mailing list &lt;/a&gt; or by &lt;a href="https://quarkusio.zulipchat.com/"&gt;Zulip Chat&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与团队讨论Quarkus开发的地方是 &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;开发邮件列表 &lt;/a&gt; 或通过 &lt;a href="https://quarkusio.zulipchat.com/"&gt;Zulip Chat&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/continuum"&gt;Unifies imperative and reactive&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/continuum"&gt;统一指令式和响应式&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A cohesive platform for optimized developer joy with unified configuration and no hassle native executable generation. Zero config, live reload in the blink of an eye and streamlined code for the 80% common usages, flexible for the remainder 20%.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个内聚的平台，优化开发人员的乐趣，统一的配置和没有麻烦的本地可执行文件生成。零配置，瞬间重新加载，简化80%的常用代码，灵活处理剩余的20%。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Selected Filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选定的筛选</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Filter the Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>筛选扩展程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Want to have your extension added to the Quarkiverse?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>想让您的扩展功能加入到Quarkiverse中吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog/catalog-detail"&gt;&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/catalog/catalog-detail"&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provided by JBeret project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由JBeret项目组提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Category: Web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类别：Web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Version: 1.1.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本: 1.1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Works with Quarkus 1.1.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>适用于 Quarkus 1.1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't see and extension you need? &lt;a href="{{site.baseurl}}/createextensions"&gt;Request a new extension&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>没有看到您需要的扩展吗? &lt;a href="{{site.baseurl}}/createextensions"&gt;申请新的扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don’t want you to spend hours learning new technologies. Instead, the Quarkus programming model builds on top of proven standards. Be it official standards such as Eclipse MicroProfile or leading frameworks in a specific domain such as Eclipse Vert.x.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们不希望你花时间学习新技术。相反，Quarkus编程模型构建在经过验证的标准之上。无论是官方标准(如Eclipse MicroProfile)还是特定领域的领先框架(如Eclipse Vert.x)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our dependency injection solution is based on CDI. You can use JAX-RS annotations to define the REST endpoints. You can use JPA annotations to map your persistent entities and JTA annotations to declare the transaction boundaries. You can use Eclipse MicroProfile to configure and monitor your application. You can use Vert.x, Apache Camel and we support much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的依赖注入方案是基于CDI的。可以使用JAX-RS注解定义REST端点。您可以使用JPA注解来映射持久实体，使用JTA注解来声明事务边界。可以使用Eclipse MicroProfile配置和监视应用程序。你可以使用Vert.x, Apache Camel，我们还支持更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we’re not limited to standards we can go beyond and extend your possibilities. Of course, Quarkus is not a passive consumer. Our goal is to improve and innovate the technologies we use and contribute back to the open source projects and standards we rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们不受标准的限制，我们可以超越并扩展您的可能性。当然，Quarkus不是一个被动的消费者。我们的目标是改进和创新我们所使用的技术，并为我们所依赖的开源项目和标准做出贡献。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unifies Imperative and Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一指令式和响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combine both the familiar imperative code and the reactive style when developing applications.  &lt;a href="/vision/continuum"&gt;Learn more&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发应用程序时，将熟悉的命令式代码和响应式风格结合起来。&lt;a href="/vision/continuum"&gt;了解更多&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support When You Need It.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你需要的时候给予支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Articles, blogs, podcast and other tidbits published online around Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>围绕Quarkus在线发布的文章、博客、播客和其他花絮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-Person and online events which feature Quarkus tracks, discussion and topics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以Quarkus为特色的现场和在线活动、讨论和话题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>活动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为Quarkus.io网站贡献力量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>欢迎贡献，请为 `develop` 分支提交pull requests。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**重要：** 指南保存在主Quarkus仓库中，合并请求应该提交在那里：
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>博客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Browse through these selections of new Quarkus related books and resources to expand your knowledge and hone your coding skills to step up your Quarkus game.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览这些与Quarkus相关的新书籍和资源，扩展您的知识，磨练您的编码技能，从而提升您的Quarkus游戏水平。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour - Sound Check... Getting Started with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡回-试音…从Quarkus开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What we mean by "Supersonic Subatomic Java".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"超音速亚原子Java"是什么意思。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡演</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序被设计为在容器中运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序针对低内存使用和快速启动时间进行了优化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These instructions will get you a copy of the Quarkus.io website up and running on your local machine for development and testing purposes.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些指令会给你一份Quarkus.io网站的副本，启动并运行在本地机器上，用于开发和测试。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install a full [Ruby development environment](https://jekyllrb.com/docs/installation/). If you use `rvm`, run: `rvm use 2.7.1`.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装完整的 [Ruby开发环境](https://jekyllrb.com/docs/installation/)。如果你使用 `rvm`, 运行: `rvm use 2.7.1`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install [bundler](https://jekyllrb.com/docs/ruby-101/#bundler)  [gems](https://jekyllrb.com/docs/ruby-101/#gems)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装 [bundler](https://jekyllrb.com/docs/ruby-101/#bundler)  [gems](https://jekyllrb.com/docs/ruby-101/#gems)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fork the [project repository](https://github.com/quarkusio/quarkusio.github.io), then clone your fork.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 [项目 repository](https://github.com/quarkusio/quarkusio.github.io)打分支，然后克隆您的 fork.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change into the project directory:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>切换到工程目录：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use bundler to fetch all required gems in their respective versions
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用bundler获取各自版本中所需的所有gems
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the site and make it available on a local server
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建站点并使其在本地服务器上可用
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now browse to http://localhost:4000
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在用浏览器访问 http://localhost:4000
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt; If you encounter any unexpected errors during the above, please refer to the [troubleshooting](https://jekyllrb.com/docs/troubleshooting/#configuration-problems) page or the [requirements](https://jekyllrb.com/docs/installation/#requirements) page, as you might be missing development headers or other prerequisites.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&gt; 如果您在上述过程中遇到任何意外错误，请参阅 [排错](https://jekyllrb.com/docs/troubleshooting/#configuration-problems) 页面或者 [需求](https://jekyllrb.com/docs/installation/#requirements) 页面，因为您可能会错过开发headers或其他先决条件。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**For more regarding the use of Jekyll, please refer to the [Jekyll Step by Step Tutorial](https://jekyllrb.com/docs/step-by-step/01-setup/).**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**更多关于使用Jekyll，请参考 [Jekyll循序渐进教程](https://jekyllrb.com/docs/step-by-step/01-setup/).**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to GitHub Pages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到GitHub页面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The website deployment is automatically performed by GitHub Actions (when commits are pushed to the `develop` branch).
If for some reason you need to deploy from your local machine, follow these instructions:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网站部署由GitHub Actions自动执行(当提交被推送到 `develop` 分支时)。
如果由于某些原因需要从本地机器进行部署，请遵循以下说明：

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the [act](https://github.com/nektos/act#installation) executable to run GitHub Actions locally
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装 [act](https://github.com/nektos/act#installation) 可执行文件本地运行GitHub Actions
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run `act -s GITHUB_TOKEN=&lt;GITHUB_TOKEN&gt;`, where *&lt;GITHUB_TOKEN&gt;* needs to be replaced with a token that allows you to push to the https://github.com/quarkusio/quarkusio.github.io repository.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行 `act -s GITHUB_TOKEN=&lt;GITHUB_TOKEN&gt;`，其中 *&lt;GITHUB_TOKEN&gt;* 需要替换为允许您推送到 https://github.com/quarkusio/quarkusio.github.io repository 的令牌。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a blog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写博客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write a blog:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写博客：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`emailhash` you can get by running `echo -n your@email.org | md5sum` on Linux or `echo -n your@email.org | md5` on macOS using an email you have registered from the [Gravatar service](https://gravatar.com),
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用您已经在 [Gravatar service](https://gravatar.com) 注册的电子邮件，在Linux运行 `echo -n your@email.org | md5sum` 或在macOS运行 `echo -n your@email.org | md5` 获得`emailhash` 。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`tags` should be used with some care as an archive page is created for of them. Below are some basic rules to try follow:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`tags` 应该谨慎使用，因为存档页面是为它们创建的。以下是一些你可以尝试遵循的基本规则：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`announcement` used for general announcement with some impact.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`announcement` 用于具有一定影响的一般公告。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`extension` used for blogs related to a specific extension.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`extension` 用于与特定扩展相关的博客。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`user-story` used for stories from users/companies adopting Quarkus.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`user-story` 用于用户/公司采用Quarkus的故事。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`development-tips` used for blogs with tips to develop using Quarkus or Quarkus itself. 
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`development-tips` 用于带有使用Quarkus或Quarkus本身开发提示的博客。 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add a tech specific, like `kafka`, if your post has a significant mention/relevance to that technology.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的帖子与该技术有显著的相关性，可以添加一个技术细节，比如 `kafka`。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be aware that the `date` attribute in the asciidoc preamble defines when the article will be published. Use a present date while writing your article to test locally, then switch to the actual target date before submitting. 
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，asciidoc序言中的 `date` 属性定义了文章将于何时发布。在写文章时使用当前日期进行本地测试，然后在提交之前切换到实际的目标日期。 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please read [CONTRIBUTING.md](https://github.com/quarkusio/quarkusio.github.io/blob/master/CONTRIBUTING.md) for details on our code of conduct, and the process for submitting pull requests to us.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参考 [CONTRIBUTING.md](https://github.com/quarkusio/quarkusio.github.io/blob/master/CONTRIBUTING.md) 关于我们的行为准则的细节，以及提交合并请求给我们的过程。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This website is licensed under the [Creative Commons Attribution 3.0](https://creativecommons.org/licenses/by/3.0/).
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本网站是根据 [知识共享署名许可协议 3.0](https://creativecommons.org/licenses/by/3.0/) 维护。
</seg>
      </tuv>
    </tu>
  </body>
</tmx>
