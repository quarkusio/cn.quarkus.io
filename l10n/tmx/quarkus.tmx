<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.8.4" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText" />
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>    // Run the same tests
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    // 运行相同测试
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @ConfigProperty(name = "address") String address;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @ConfigProperty(name = "address") String address;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> For more information about how Quarkus supports secure connections with SSL/TLS, see the xref:http-reference.adoc#ssl[HTTP reference] information.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> 更多信息请参见 link:http-reference.html#adoc[HTTP reference] 指南。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configures a back-off delay between attempts to send a request.
# A random factor (jitter) is applied to increase the delay when several failures happen.
mp.messaging.outgoing.&lt;channelName&gt;.delay=1s
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 配置尝试发送请求之间的回退延迟。
# 当发生多个故障时，随机因子（抖动）被使用来增加延迟。
mp.messaging.outgoing.&lt;channelName&gt;.delay=1s
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configures the random factor when using back-off with maxRetries &gt; 0. 0.5 by default
mp.messaging.outgoing.&lt;channelName&gt;.jitter=0.3
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 配置当使用回退且maxRetries &gt; 0时使用的随机因子。 默认为0.5
mp.messaging.outgoing.&lt;channelName&gt;.jitter=0.3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Disable both liveness and readiness checks with `health-enabled=false`:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 通过 `health-enabled=false` 来同时禁用活跃性检查和就绪检查:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Disable only the readiness check with `health-readiness-enabled=false`:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 通过 `health-readiness-enabled=false` 来单独禁用就绪检查:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># HTTP endpoint buffers messages if a consumer is not able to keep up. This setting specifies the size of the buffer.
# 8 by default.
mp.messaging.incoming.&lt;channelName&gt;.buffer-size=13
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 如果消费者无法跟上，HTTP 端点会缓冲消息。 此设置指定缓冲区的大小。
# 默认为 8 
mp.messaging.incoming.&lt;channelName&gt;.buffer-size=13
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Message payload serializer, optional, implementation of `io.quarkus.reactivemessaging.http.runtime.serializers.Serializer`
mp.messaging.outgoing.&lt;channelName&gt;.serializer=com.example.MySerializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 消息负载序列化器，可选的， `io.quarkus.reactivemessaging.http.runtime.serializers.Serializer` 的实现
mp.messaging.outgoing.&lt;channelName&gt;.serializer=com.example.MySerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># OUTGOING
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># OUTGOING
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># POST is the default method. Another possibility is PUT
mp.messaging.incoming.incoming-costs.method=POST
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># POST是默认的方式。 PUT方式也被支持
mp.messaging.incoming.incoming-costs.method=POST
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># POST is the default method. Another possibility is PUT
mp.messaging.outgoing.outgoing-costs.method=POST
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># POST是默认的方式。 PUT方式也被支持
mp.messaging.outgoing.outgoing-costs.method=POST
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># The number of attempts to make for sending a request to a remote endpoint. Must not be less than zero
# Zero by default
mp.messaging.outgoing.&lt;channelName&gt;.maxRetries=3
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 尝试向远程端点发送请求的次数。不得小于零
# 默认为0
mp.messaging.outgoing.&lt;channelName&gt;.maxRetries=3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># The path of the endpoint
mp.messaging.incoming.&lt;channelName&gt;.path=/my-reactive-ws-endpoint
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 端点的路径
mp.messaging.incoming.&lt;channelName&gt;.path=/my-reactive-ws-endpoint
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># The target URL
mp.messaging.outgoing.&lt;channelName&gt;.url=http://localhost:8213
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 目标 URL
mp.messaging.outgoing.&lt;channelName&gt;.url=http://localhost:8213
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># With profiles
"%test":
   quarkus:
     oidc:
       enabled: false
     security:
        users:
            file:
              enabled: true
              realm-name: quarkus
              plain-text: true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 使用环境
"%test":
   quarkus:
     oidc:
       enabled: false
     security:
        users:
            file:
              enabled: true
              realm-name: quarkus
              plain-text: true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Your configuration properties
greeting.message.text = hello
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 你的属性配置
greeting.message.text = hello
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Your configuration properties
greeting.text = hello
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 你的属性配置
greeting.text = hello
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># here we are using a URL pointing to an endpoint
# you can use e.g. an environment variable to change it
mp.messaging.outgoing.outgoing-costs.url=http://localhost:${quarkus.http.port}/cost-collector
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 这里我们使用一个指向端点的URL
# 你可以使用 例如一个环境变量来改变它
mp.messaging.outgoing.outgoing-costs.url=http://localhost:${quarkus.http.port}/cost-collector
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># the incoming-costs channel will be fed via an endpoint on the `/costs` path
mp.messaging.incoming.incoming-costs.path=/costs
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 传入成本通道将通过 `/costs` 路径上的端点提供
mp.messaging.incoming.incoming-costs.path=/costs
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># we need to use a different port for tests:
%test.mp.messaging.outgoing.outgoing-costs.url=http://localhost:${quarkus.http.test-port}/cost-collector
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 我们需要使用不同的端口进行测试:
%test.mp.messaging.outgoing.outgoing-costs.url=http://localhost:${quarkus.http.test-port}/cost-collector
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 如何统一指令式编程和响应式编程?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 项目会做些什么来提高开发者的乐趣?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What does Container First mean?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 容器优先是什么意思?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 什么是GraalVM？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 对标准有什么考虑?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#INCOMING
# The HTTP method (either `POST` or `PUT`, `POST` by default
mp.messaging.incoming.&lt;channelName&gt;.method=POST
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>#INCOMING
# HTTP 请求方式 ( `POST` 或 `PUT` ,默认为 `POST` 
mp.messaging.incoming.&lt;channelName&gt;.method=POST
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#The HTTP method (either `POST` or `PUT`), `POST` by default
mp.messaging.outgoing.&lt;channelName&gt;.method=PUT
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>#HTTP 请求方式 ( `POST` 或 `PUT` ),默认为 `POST` 
mp.messaging.outgoing.&lt;channelName&gt;.method=PUT
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>' '</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>' '</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Only for Oracle GraalVM CE/EE) Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(仅适用于Oracle GraalVM CE/EE）使用 `gu install` 安装 `native-image` 工具：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Add the GraalVM `bin` directory to the path</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(可选）将GraalVM `bin` 目录添加到路径中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(可选）将 `JAVA_HOME` 环境变量设置为GraalVM的安装目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(and similarly `maven.failsafe.plugin` when testing in native image).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(在原生image中测试时也是如此 `maven.failsafe.plugin` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Best of breed frameworks and standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 最好的类库和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 容器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Developer Joy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 开发者喜悦</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Docker image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* Docker镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* GraalVM native image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* GraalVM原生镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Kubernetes Native Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* Kubernetes原生Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Live coding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Substrate VM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 底层VM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Supersonic Subatomic Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 超音速亚原子Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Unify Imperative and Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 统一指令式和响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**For more regarding the use of Jekyll, please refer to the [Jekyll Step by Step Tutorial](https://jekyllrb.com/docs/step-by-step/01-setup/).**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**更多关于使用Jekyll，请参考 [Jekyll循序渐进教程](https://jekyllrb.com/docs/step-by-step/01-setup/).**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**重要：** 指南保存在主Quarkus仓库中，合并请求应该提交在那里：
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Experimental*: early feedback is requested to mature the idea. There is no guarantee of stability nor long term presence in the platform until the solution matures. Such extensions are at the beginning of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Experimental*: 尽早反馈，以使想法更加成熟。在解决方案成熟之前，无法保证平台的稳定性或长期存在。这些扩展正处于其成熟过程的开始阶段。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Multiple consumer applications inside a consumer group*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*一个消费者组内有多个消费者应用程序* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Multiple consumer applications inside a consumer group*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*一个消费者组内有多个消费者应用程序* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Multiple consumer threads inside a consumer group*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*一个消费者组内使用多个消费者线程* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Multiple consumer threads inside a consumer group*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*一个消费者组内使用多个消费者线程* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Preview*: 不能保证向后兼容性和在生态系统中的存在。具体的改进可能需要改变配置、API和计划，使之变得 _stable_ 。这些扩展还处于成熟过程的中间阶段。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Pub/Sub: Multiple consumer groups subscribed to a topic*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*发布/订阅：多个消费者群体订阅同一个topic* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Pub/Sub: Multiple consumer groups subscribed to a topic*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*发布/订阅：多个消费者群体订阅同一个topic* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Single consumer thread inside a consumer group*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*消费者组内使用单一消费者线程*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Single consumer thread inside a consumer group*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*消费者组内使用单一消费者线程*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Stable*: backward compatibility and presence in the ecosystem are taken very seriously. An application can safely rely on these extensions. Extensions not marked as preview or experimental (the majority) are stable.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Stable*: 向后兼容性和在生态系统中的存在被非常重视。应用程序可以安全地依赖于这些扩展。没有标记为预览或实验的扩展(大多数)是稳定的。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-cause*: the cause of the failure if any</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-cause* ：失败的起因(如果有)。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-cause*: the cause of the failure if any
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-cause* ：失败的起因(如果有)。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-offset*: the original offset of the record (long mapped to String)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-offset* ：失败记录的原始偏移量(long映射为String)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-offset*: the original offset of the record (long mapped to String)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-offset* ：失败记录的原始偏移量(long映射为String)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-partition*: the original partition of the record (integer mapped to String)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-partition* ：失败记录的原始分区(integer映射为String)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-partition*: the original partition of the record (integer mapped to String)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-partition* ：失败记录的原始分区(integer映射为String)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-reason*: the reason of the failure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-reason* ：失败原因
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-reason*: the reason of the failure
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-reason* ：失败原因
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-topic*: the original topic of the record</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-topic* ：失败记录的原始topic
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-topic*: the original topic of the record
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-topic* ：失败记录的原始topic
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*process* streams of records as they occur or retrospectively.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对流式记录进行起始或回溯*处理*。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*process* streams of records as they occur or retrospectively.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对流式记录进行起始或回溯*处理*。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*publish* (write) and *subscribe* to (read) streams of events, called _records_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*发布* (写)以及 *订阅* (读)事件流，称为 _记录_ 。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*publish* (write) and *subscribe* to (read) streams of events, called _records_.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*发布* (写)以及 *订阅* (读)事件流，称为 _记录_ 。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*store* streams of records durably and reliably inside _topics_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _topic_ 内持久而可靠地 *存储* 流式记录。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*store* streams of records durably and reliably inside _topics_.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _topic_ 内持久而可靠地 *存储* 流式记录。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-builditems</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/all-builditems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/all-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/apicurio-registry-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/apicurio-registry-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-my-first-extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/building-my-first-extension</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-native-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/building-native-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/capabilities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/capabilities</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cassandra</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cassandra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi-integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cli-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cli-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/conditional-extension-dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/conditional-extension-dependencies</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-extending-support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-extending-support</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-mappings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-mappings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-yaml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/container-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/container-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/context-propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/context-propagation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/continuous-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/continuous-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/credentials-provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/credentials-provider</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-heroku</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying toheroku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying toopenshift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-mode-differences</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-mode-differences</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-ui</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-ui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/elasticsearch-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/extension-codestart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/extension-codestart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/extension-registry-user</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/extension-registry-user</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-reactive-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-reactive-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/http-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/http-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/ide-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/ide-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/infinispan-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/infinispan-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/jms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jreleaser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/jreleaser</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-reactive-getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-reactive-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-schema-registry-avro</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-schema-registry-avro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-dmn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-dmn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-drl</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-drl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-pmml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-pmml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lifecycle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/lifecycle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/liquibase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase-mongodb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/liquibase-mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/logging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lra</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/lra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mailer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mailer-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/maven-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/maven-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/micrometer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/micrometer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mutiny-primer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mutiny-primer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/native-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentelemetry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/opentelemetry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/opentracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/optaplanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/optaplanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/performance-measure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/performance-measure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/picocli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quarkus-reactive-architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quarkus-reactive-architecture</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quarkus-runtime-base-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quarkus-runtime-base-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quartz</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/qute-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-routes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reaugmentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reaugmentation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-json</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-json</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive-migration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy-reactive-migration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scheduler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scripting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scripting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-built-in-authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-built-in-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-customization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-customization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jdbc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jdbc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jwt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt-build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jwt-build</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-ldap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-ldap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-oauth2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-oauth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-providers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-perties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-webauthn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-webauthn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-fault-tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-fault-tolerance</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-graphql</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-graphql</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-graphql-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-graphql-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-di</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-di</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/stork</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/stork</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/stork-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/stork-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/transaction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/upx</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/upx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vertx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vertx-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/websockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/websockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2020 Awards and Nominations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2020年奖项及提名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2021 Awards and Nominations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年奖项及提名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2021 Stevie Award</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年Stevie奖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>30</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>60</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>60</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>80</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>80</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Declaring a CDI Bean in the Application scope. Quarkus will create a single instance of this class.
&lt;2&gt; Use the `@ConsumeEvent` annotation to declare a consumer. It is possible to use the Vert.x API https://vertx.io/docs/vertx-core/java/#_acknowledging_messages_sending_replies[directly] too.
&lt;3&gt; Receive the message payload as a method parameter. The returned object will be the reply.
&lt;4&gt; Return the response. This response is sent back to the `VertxResource` class
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 以 Application scope 声明一个 CDI Bean。 Quarkus 将会为此类创建一个单实例对象。
&lt;2&gt; 使用 `@ConsumeEvent` 注解声明一个消费者. 你也可以直接使用 Vert.x API https://vertx.io/docs/vertx-core/java/#_acknowledging_messages_sending_replies[directly] 。
&lt;3&gt; 接收消息负载作为方法的参数。返回的对象将会被作为回复。
&lt;4&gt; 返回该响应。该响应将会被发送回 `VertxResource` 类
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Inject the event bus. Alternatively you can use `vertx.eventBus()`.
&lt;2&gt; We receive a _name_ as a query parameter
&lt;3&gt; We use the `request` method to initiate the request-reply interaction. We send the name to the "greetings" address.
&lt;4&gt; When the response is received, we extract the body and return it as the HTTP response
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 注入事件总线。或者你可以使用 `vertx.eventBus()` 
&lt;2&gt; 我们接收到一个姓名作为查询参数 
&lt;3&gt; 我们使用 `request` 方法来发起请求-回复的交互。我们将姓名发送到 "greetings" 地址 
&lt;4&gt; 收到响应后，我们提取正文并将其作为 HTTP 响应进行返回 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Store the `WebClient`, so we will be able to use it in our HTTP endpoint
&lt;2&gt; Create the `WebClient`. Be sure to use the `io.vertx.mutiny.ext.web.client.WebClient` class
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 存储 `WebClient`，以便我们在 HTTP 端点中使用它
&lt;2&gt; 创建 `WebClient`。确保使用 `io.vertx.mutiny.ext.web.client.WebClient` 类
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; This endpoint returns a JSON Array. Vert.x provides a convenient way to manipulate JSON Object and Array. More details about these in xref:vertx-reference.adoc#using-vert-x-json[the reference guide].
&lt;2&gt; Send a `GET` request to the Wikipedia API
&lt;3&gt; Once the response is received, extract it as a JSON Object
&lt;4&gt; Extract the `langlinks` array from the response.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 该端点返回一个 JSON 数组。Vert.x 提供了一种便捷的方式来操作 JSON 对象和数组。 有关这些的更多详细信息，请参阅 xref:vertx-reference.adoc#using-vert-x-json[参考指南] 
&lt;2&gt; 向 Wikipedia API 发送 `GET` 请求 
&lt;3&gt; 收到响应后，将其提取为 JSON 对象 
&lt;4&gt; 从响应中提取 `langlinks` 数组 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a class="anchor" href="#being-reactive"&gt;&lt;/a&gt;Being reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a class="anchor" href="#being-reactive"&gt;&lt;/a&gt;响应式风格</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a class="anchor" href="#event-driven-architectures"&gt;&lt;/a&gt;Event-driven Architectures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a class="anchor" href="#event-driven-architectures"&gt;&lt;/a&gt;事件驱动的架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a class="anchor" href="#functions-as-a-service-and-serverless"&gt;&lt;/a&gt;Functions as a Service and Serverless</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a class="anchor" href="#functions-as-a-service-and-serverless"&gt;&lt;/a&gt;函数作为服务（FaaS）和无服务（Serverless）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a class="anchor" href="#http-microservices"&gt;&lt;/a&gt;HTTP microservices</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a class="anchor" href="#http-microservices"&gt;&lt;/a&gt;HTTP微服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;62 Contributors&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;62位贡献者&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;Documentation&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;文档&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;Extension Repo&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;扩展版本库&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;JBeret Project&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;JBeret 项目&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;JBeret makes you jump higher&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;JBeret让你跳得更高&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;Passing&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;通过&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;Use Jberet to do something cool&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;使用Jberet来做一些很酷的事情&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/container-first"&gt;Container First&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/container-first"&gt;容器优先&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/container-first"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/container-first"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/continuum"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/continuum"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/continuum"&gt;Unifies imperative and reactive&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/continuum"&gt;统一指令式和响应式&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/continuum/"&gt;Learn more about Reactive&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/continuum/"&gt;了解更多关于响应式&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/developer-joy"&gt;Developer Joy&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/developer-joy"&gt;开发者的乐趣&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/developer-joy"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/vision/developer-joy"&gt;了解更多&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/developer-joy/"&gt;Learn more about Developer Joy&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/developer-joy/"&gt;了解更多关于开发者的乐趣&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/kubernetes-native/"&gt;Learn more about Kubernetes-native&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/kubernetes-native/"&gt;了解更多关于Kubernetes原生&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/standards"&gt;Community and Standards&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/standards"&gt;社区和标准&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/standards"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/standards"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/standards/"&gt;Learn more about Standards&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/standards/"&gt;了解更多关于标准&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://code.quarkus.io" class="button-cta secondary white"&gt;START CODING&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://code.quarkus.io" class="button-cta secondary white"&gt;开始编码&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://code.quarkus.io" class="button-cta secondary white"&gt;Start Coding&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://code.quarkus.io" class="button-cta secondary white"&gt;开始写代码&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://code.quarkus.io"&gt;Start Coding&lt;/a&gt; with Quarkus {{ site.data.versions.quarkus.version }} [&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;announce&lt;/a&gt;|&lt;a href="https://github.com/quarkusio/quarkus/releases/tag/{{ site.data.versions.quarkus.version }}"&gt;changelog&lt;/a&gt;]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用Quarkus {{ site.data.versions.quarkus.version }} [&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;通告&lt;/a&gt;|&lt;a href="https://github.com/quarkusio/quarkus/releases/tag/{{ site.data.versions.quarkus.version }}"&gt;变更日志&lt;/a&gt;]&lt;a href="https://code.quarkus.io"&gt;开始写代码&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="{% if page.url contains '/roadmap/' %}active{% endif %}"&gt;ROADMAP&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="{% if page.url contains '/roadmap/' %}active{% endif %}"&gt;路线图&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;Go to the Quarkus GitHub Discussions&lt;i class="fas fa-external-link-alt"&gt;&lt;/i&gt;&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;进入Quarkus GitHub讨论&lt;i class="fas fa-external-link-alt"&gt;&lt;/i&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://github.com/quarkusio/quarkus/discussions/categories/events"&gt;Check out the "Events" section of Quarkus Discussions&lt;/a&gt; for additional community related events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://github.com/quarkusio/quarkus/discussions/categories/events"&gt;查看Quarkus讨论组的”活动“部分&lt;/a&gt; 参与其他社区相关活动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://quarkus.io/extensions/" class="{% if page.url contains '/extensions/' %}active{% endif %}"&gt;BROWSE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://quarkus.io/extensions/" class="{% if page.url contains '/extenions/' %}active{% endif %}"&gt;浏览扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://www.redhat.com/en/topics/cloud-native-apps/why-choose-red-hat-quarkus" class="button-cta btn-sm"&gt;Red Hat Support&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://www.redhat.com/en/topics/cloud-native-apps/why-choose-red-hat-quarkus" class="button-cta btn-sm"&gt;红帽技术支持&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;More Information&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;更多信息&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;Read the release notes&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;阅读发布说明&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;WHAT IS QUARKUS?&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;QUARKUS是什么？&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/awards" class="{% if page.url contains '/awards/' %}active{% endif %}"&gt;AWARDS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/awards" class="{% if page.url contains '/awards/' %}active{% endif %}"&gt;获奖&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}" &gt;博客&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/books" class="{% if page.url contains '/books/' %}active{% endif %}"&gt;BOOKS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/books" class="{% if page.url contains '/books/' %}active{% endif %}"&gt;书籍&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog" class="{% if page.url contains '/catalog/' %}active{% endif %}"&gt;EXTENSION CATALOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/catalog" class="{% if page.url contains '/catalog/' %}active{% endif %}"&gt;扩展目录&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog"&gt;Extension Catalog&lt;/a&gt; &lt;i class="fas fa-chevron-right"&gt;&lt;/i&gt; {{ page.title }}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/catalog"&gt;扩展目录&lt;/a&gt; &lt;i class="fas fa-chevron-right"&gt;&lt;/i&gt; {{ page.title }}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog/catalog-detail"&gt;&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/catalog/catalog-detail"&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/container-first" class="{% if page.url contains '/container-first/' %}active{% endif %}"&gt;CONTAINER FIRST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/container-first" class="{% if page.url contains '/container-first/' %}active{% endif %}"&gt;容器优先 &lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/continuum" class="{% if page.url contains '/continuum/' %}active{% endif %}"&gt;REACTIVE&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/continuum" class="{% if page.url contains '/continuum/' %}active{% endif %}"&gt;响应式&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/createextensions" class="{% if page.url contains '/createextensions/' %}active{% endif %}"&gt;CREATE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/createextensions" class="{% if page.url contains '/createextensions/' %}active{% endif %}"&gt;创建扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/createextensions"&gt; Learn How &lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/createextensions"&gt; 了解如何 &lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;DEVELOPER JOY&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;开发者的乐趣 &lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/discussion" class="{% if page.url contains '/discussion/' %}active{% endif %}"&gt;DISCUSSION&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/discussion" class="{% if page.url contains '/discussion/' %}active{% endif %}"&gt;讨论&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/events" class="{% if page.url contains '/events/' %}active{% endif %}"&gt;EVENTS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/events" class="{% if page.url contains '/events/' %}active{% endif %}"&gt;活动&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/faq/#what-is-a-quarkus-extension" class="{% if page.url contains 'what-is-a-quarkus-extension' %}active{% endif %}"&gt;USE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/faq/#what-is-a-quarkus-extension" class="{% if page.url contains 'what-is-a-quarkus-extension' %}active{% endif %}"&gt;使用扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;GET STARTED&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;入门&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/get-started/" class="button-cta"&gt;Get Started with Quarkus&lt;/a&gt; &lt;a href="{{site.baseurl}}/guides/" class="button-cta"&gt;Read the Guides&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/get-started/" class="button-cta"&gt;开始体验Quarkus&lt;/a&gt; &lt;a href="{{site.baseurl}}/guides/" class="button-cta"&gt;阅读指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides" class="{% if page.url contains '/guides/' %}active{% endif %}"&gt;DOCUMENTATION&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides" class="{% if page.url contains '/guides/' %}active{% endif %}" &gt;指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides" class="{% if page.url contains '/guides/' %}active{% endif %}"&gt;GUIDES&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides" class="{% if page.url contains '/guides/' %}active{% endif %}" &gt;指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/cli-tooling"&gt;Read the CLI Tooling guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides/cli-tooling"&gt;阅读CLI工具指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/continuous-testing"&gt;Read the Continuous Testing guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/continuous-testing"&gt;阅读持续测试指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-services"&gt;Read the Dev Services guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/dev-services"&gt;阅读开发服务指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Read the Dev UI guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/dev-ui"&gt;阅读开发用户界面指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode/"&gt;Read the Dev Mode guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/maven-tooling#dev-mode/"&gt;阅读开发模式指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/maven-tooling#remote-development-mode"&gt;Read the Remote Development Mode guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides/maven-tooling#remote-development-mode"&gt;阅读远程开发模式指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/writing-extensions" class="{% if page.url contains '/guides/writing-extensions' %}active{% endif %}"&gt;CREATE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides/writing-extensions" class="{% if page.url contains '/guides/writing-extensions' %}active{% endif %}" &gt;创建扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}" &gt;播客&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/kubernetes-native" class="{% if page.url contains '/kubernetes-native/' %}active{% endif %}"&gt;KUBERNETES NATIVE&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/kubernetes-native" class="{% if page.url contains '/kubernetes-native/' %}active{% endif %}"&gt;KUBERNETES 原生&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/newsletter" class="{% if page.url contains '/newsletter/' %}active{% endif %}"&gt;NEWSLETTER&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/newsletter" class="{% if page.url contains '/newsletter/' %}active{% endif %}"&gt;新闻&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/publications" class="{% if page.url contains '/publications/' %}active{% endif %}"&gt;PUBLICATIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/publications" class="{% if page.url contains '/publications/' %}active{% endif %}"&gt;发表&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/qtips" class="{% if page.url contains '/qtips/' %}active{% endif %}"&gt;"Q" TIP VIDEOS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/qtips" class="{% if page.url contains '/qtips/' %}active{% endif %}"&gt;"Q" TIP视频&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/quarkus2/" class="button-cta"&gt;Learn More about 2.0&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/quarkus2/" class="button-cta"&gt;了解更多关于2.0&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/standards" class="{% if page.url contains '/standards/' %}active{% endif %}"&gt;STANDARDS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/standards" class="{% if page.url contains '/standards/' %}active{% endif %}"&gt;标准&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/support/" class="{% if page.url contains '/support/' %}active{% endif %}"&gt;SUPPORT&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/support/" class="{% if page.url contains '/support/' %}active{% endif %}"&gt;支持&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/training" class="{% if page.url contains '/training/' %}active{% endif %}"&gt;TRAINING&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/training" class="{% if page.url contains '/training/' %}active{% endif %}"&gt;培训&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/useextensions" class="{% if page.url contains '/useextensions/' %}active{% endif %}"&gt;USE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/useextensions" class="{% if page.url contains '/useextensions/' %}active{% endif %}"&gt;使用扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/worldtour/"&gt;Learn more about the Quarkus World Tour&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/worldtour/"&gt;了解更多关于Quarkus世界巡演的信息&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code&gt;chunk&lt;/code&gt; - A simple Job that reads, processes, and stores data from a file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;chunk&lt;/code&gt; - 一个简单的作业，从文件中读取、处理和存储数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code&gt;jdbc-repository&lt;/code&gt; - A Job that uses a jdbc datasource to store JBeret and Job metadata.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;jdbc-repository&lt;/code&gt; - 一个使用jdbc数据源来存储JBeret和作业元数据的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code&gt;scheduler&lt;/code&gt; - Schedule a Job to run every 10 seconds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;scheduler&lt;/code&gt; - 调度一个作业，每10秒运行一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="https://quarkus.io/extensions/"&gt;Extensions&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="https://quarkus.io/extensions/"&gt;扩展&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/about/"&gt;About &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/about/"&gt;关于&lt;i class="fas fa-chevron-down"&gt; &lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/community/"&gt;Community&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/community/"&gt;社区 &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Community &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;社区&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Extensions &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;扩展&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Learn &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;学习 &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Learn&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;学习 &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt; If you encounter any unexpected errors during the above, please refer to the [troubleshooting](https://jekyllrb.com/docs/troubleshooting/#configuration-problems) page or the [requirements](https://jekyllrb.com/docs/installation/#requirements) page, as you might be missing development headers or other prerequisites.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&gt; 如果您在上述过程中遇到任何意外错误，请参阅 [排错](https://jekyllrb.com/docs/troubleshooting/#configuration-problems) 页面或者 [需求](https://jekyllrb.com/docs/installation/#requirements) 页面，因为您可能会错过开发headers或其他先决条件。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@PermitAll is a JSR 250 common security annotation that indicates that the given endpoint is accessible by any caller, authenticated or not.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@PermitAll是JSR 250的一个通用安全注解，它表明给定的端点可以被任何调用者访问，无论是否经过验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterForReflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RegisterForReflection</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RolesAllowed is a JSR 250 common security annotation that indicates that the given endpoint is accessible by a caller if
they have either a "User" or "Admin" role assigned.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RolesAllowed是一个JSR 250通用安全注解，表明如果调用者分配了 "用户 "或 "管理员 "角色，那么他们可以访问给定的端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RolesAllowed is a JSR 250 common security annotation that indicates that the given endpoint is accessible by a caller if they have either a "User" or "Admin" role assigned.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RolesAllowed是一个JSR 250通用安全注解，表明如果调用者分配了 "用户 "或 "管理员 "角色，那么他们可以访问给定的端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Transactional</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Transactional</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Job can also be scheduled programmatically, using the JobScheduler API and the Quarkus startup event:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作业也可以通过程序安排，使用JobScheduler API和Quarkus的启动事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes Native Java栈为OpenJDK HotSpot和GraalVM量身定制，从Java库和标准中精心打造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `MutinyEmitter` to send message to a channel, so it can be easily integrated with the Mutiny API exposed by Hibernate Reactive or Hibernate Reactive with Panache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`MutinyEmitter` 会向 channel 发送消息，所以它可以很容易地与Hibernate Reactive或Hibernate Reactive with Panache所暴露的Mutiny API进行集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `RuntimeException` crossing the transaction boundaries will rollback the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个 `RuntimeException` ，越过事务边界，将回滚交易。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `persistOrUpdate()` method exist that persist or update an entity in the database, it uses the __upsert__ capability of MongoDB to do it in a single query.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>存在一个 `persistOrUpdate()` 方法来持久化或更新数据库中的实体，它使用MongoDB的 __upsert__ 功能在单个查询中完成此操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A brief introduction to Mutiny - the reactive programming library used by Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny的简要介绍 - Quarkus使用的响应式编程库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A cohesive platform for optimized developer joy with unified configuration and no hassle native executable generation. Zero config, live reload in the blink of an eye and streamlined code for the 80% common usages, flexible for the remainder 20%.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个内聚的平台，优化开发人员的乐趣，统一的配置和没有麻烦的本地可执行文件生成。零配置，瞬间重新加载，简化80%的常用代码，灵活处理剩余的20%。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A cohesive platform for optimized developer joy:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个优化开发者乐趣的有凝聚力的平台：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A comma-separated list of host:port to use for establishing the initial connection to the Kafka cluster.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用逗号分隔的主机：端口列表，用于建立与Kafka集群的初始连接。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A comma-separating list of incoming record headers to be propagated to the outgoing record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个以逗号分隔的传入记录头的列表，将被添加到传出记录中

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A comma-separating list of topics to be consumed. Cannot be used with the `topic` or `pattern` properties

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个以逗号分隔的用于消费的主题列表。不能与 `topic` 或 `pattern` 属性一起使用。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A custom `bootstrap` script</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个自定义的 `bootstrap` 脚本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A given Panache entity can be attached to only a single persistence unit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个Panache实体类只能配置到一个持久化单元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A high level overview of what the various steps of a CI/CD pipeline would look is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下是对CI/CD管道的各个步骤的高度概述：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#resources[resource] is a representation
of the entity that is producing telemetry, it adds attributes to the exported trace to characterize who is producing the trace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Opentelemetry link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#resources[资源] 是产生telemetry的实体的表示，它向输出的trace中添加属性，用以描述谁在产生trace。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#resources[resource] is a representation of the entity that is producing telemetry, it adds attributes to the exported trace to characterize who is producing the trace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Opentelemetry link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#resources[资源] 是产生telemetry的实体的表示，它向输出的trace中添加属性，用以描述谁在产生trace。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#sampling[sampler] decides whether
a trace should be sampled and exported, controlling noise and overhead by reducing the number of sample of traces collected and sent
to the collector.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Opentelemetry link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#sampling[采样器] 决定了是否应该对一个trace进行采样和输出，通过减少收集和发送至exporter的trace样本数量来控制噪音和开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#sampling[sampler] decides whether a trace should be sampled and exported, controlling noise and overhead by reducing the number of sample of traces collected and sent to the collector.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Opentelemetry link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#sampling[采样器] 决定了是否应该对一个trace进行采样和输出，通过减少收集和发送至exporter的trace样本数量来控制噪音和开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A key to used when writing the record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写入记录时使用的键值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A leading slash will change how the configured permission path is interpreted.
The configured URL will be used as-is, and paths will not be adjusted if the value of `quarkus.http.root-path` is changed.
For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有前置的斜杠将改变配置的权限路径的解释方式。配置的URL将按原样使用，并且如果 `quarkus.http.root-path` 的值改变后路径将不会被调整。例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A leading slash will change how the configured permission path is interpreted.  The configured URL will be used as-is, and paths will not be adjusted if the value of `quarkus.http.root-path` is changed.  For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有前置的斜杠将改变配置的权限路径的解释方式。配置的URL将按原样使用，并且如果 `quarkus.http.root-path` 的值改变后路径将不会被调整。例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A leading slash will change how the configured permission path is interpreted. The configured URL will be used as-is, and paths will not be adjusted if the value of `quarkus.http.root-path` is changed. For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有前置的斜杠将改变配置的权限路径的解释方式。配置的URL将按原样使用，并且如果 `quarkus.http.root-path` 的值改变后路径将不会被调整。例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of all extensions that support Dev Services and their configuration options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有支持开发服务的扩展及其配置选项的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A minimal configuration for the Kafka connector with an incoming channel looks like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个配有消息接收channel的Kafka connector的最小配置如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more advanced option would be to directly provide a bean of `javax.json.bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` scope).
If the latter approach is leveraged it is very important to manually inject and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI producer that produces `javax.json.bind.Jsonb`.
Failure to do so will prevent JSON-B specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个更高级的选择是直接提供一个 `javax.json.bind.JsonbConfig` 的bean（具有 `Dependent` 范围），或者在极端情况下，提供一个 `javax.json.bind.Jsonb` 的bean（具有 `Singleton` 范围）。如果采用后一种方法，那么在产成 `javax.json.bind.Jsonb` 的CDI生产者中手动注入和应用所有 `io.quarkus.jsonb.JsonbConfigCustomizer` Bean是非常重要的。如果不这样做，就会阻止由各种扩展提供的JSON-B特定的自定义功能被应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more advanced option would be to directly provide a bean of `javax.json.bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` scope).  If the latter approach is leveraged it is very important to manually inject and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI producer that produces `javax.json.bind.Jsonb`.  Failure to do so will prevent JSON-B specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个更高级的选择是直接提供一个 `javax.json.bind.JsonbConfig` 的bean（具有 `Dependent` 范围），或者在极端情况下，提供一个 `javax.json.bind.Jsonb` 的bean（具有 `Singleton` 范围）。如果采用后一种方法，那么在产成 `javax.json.bind.Jsonb` 的CDI生产者中手动注入和应用所有 `io.quarkus.jsonb.JsonbConfigCustomizer` Bean是非常重要的。如果不这样做，就会阻止由各种扩展提供的JSON-B特定的自定义功能被应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A periodical video podcast hosted by Quarkus Developers about things moving in and around Quarkus ecosystem. View the &lt;a href="{{site.baseurl}}/insights"&gt;live podcasts&lt;/a&gt; and check out older episodes on the Podcasts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由Quarkus开发者主持的定期视频播客，讲述Quarkus生态系统内和周边事物。查看&lt;a href="{{site.baseurl}}/insights"&gt;实时播客&lt;/a&gt;，并在播客中查看先前的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A port value of zero will result in a randomly assigned port.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>端口值为零将导致随机分配端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quick glance at the Quarkus engine and how it enables reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>快速浏览一下Quarkus引擎和它如何实现响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A reactive MongoDB Client is included in Quarkus.
Using it is as easy as using the classic MongoDB Client.
You can rewrite the previous example to use it like the following.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus中包含一个响应式MongoDB客户端。使用它就像使用经典的MongoDB客户端一样简单。你可以重写前面的例子来使用它，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A reactive MongoDB Client is included in Quarkus.  Using it is as easy as using the classic MongoDB Client.  You can rewrite the previous example to use it like the following.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus中包含一个响应式MongoDB客户端。使用它就像使用经典的MongoDB客户端一样简单。你可以重写前面的例子来使用它，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A running Redis server, or Docker Compose to start one</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个正在运行的Redis服务，也可以使用Docker Compose启动一个Redis服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A sample configuration should look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例配置应如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A starter template has been generated for both JVM and native execution modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>已经为JVM和原生执行模式生成了一个启动模板。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A unique string that identifies the consumer group the application belongs to.

If not set, defaults to the application name as set by the `quarkus.application.name` configuration property.

If that is not set either, a unique, generated id is used.

It is recommended to always define a `group.id`, the automatic generation is only a convenient feature for development.
You can explicitly ask for automatically generated unique id by setting this property to `${quarkus.uuid}`.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个唯一的字符串，用于识别应用程序所属的消费者组。

如果未设置, 那么默认为通过 `quarkus.application.name` 所设定的应用程序名称。

如果这个属性也没有设置，那么会使用一个生成的唯一的id。

建议总是设置一个 `group.id`，因为自动生成只是一个方便在开发模式中使用的特性。
你可以通过将该属性设置为 `${quarkus.uuid}` 来显示的获取自动生成的唯一的id。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个很常见的需求是在Quarkus应用程序启动测试之前，启动一些您的Quarkus应用程序所依赖的服务。为了解决这个需求，Quarkus提供了 `@io.quarkus.test.common.QuarkusTestResource` 和 `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A virtual (and in person where possible) tour of Java User Groups creating a unique hands-on experience with access to Quarkus experts designed to help you get started with Java in a Kubernetes world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个Java用户组的虚拟之旅(如果可能的话还可以亲自去)，创建一个独特的亲身体验，造访旨在帮助您在Kubernetes世界中开始使用Java的Quarkus专家。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker or Podman)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以工作的容器 (Docker或者Podman)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker, podman)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个工作的容器运行时（Docker 或 podman）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A xref:configuring-c-development[working C development environment]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个 xref:configuring-c-development[C语言工作开发环境]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Body Type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP主体类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Connector Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器配置参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Data (with binary content) and the `content-type` is set to `application/json`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP数据（有二进制内容），并且 `content-type` 被设为 `application/json` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Data using a binary content. No `content-type` set</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用二进制内容的AMQP数据。没有设置 `content-type` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Data using a binary content. The `content-type` is set to `application/json`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用二进制内容的AMQP数据。 `content-type` 被设置为 `application/json` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Data with a different `content-type`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有不同 `content-type` 的AMQP数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Message Body</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP消息主体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Sequence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP 序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Value containing a http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#section-primitive-type-definitions[AMQP Primitive Type]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#section-primitive-type-definitions[AMQP原始类型] 的AMQP值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Value using the `Binary` type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `Binary` 类型的AMQP值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Value using the corresponding AMQP Type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用相应的AMQP类型的AMQP值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP Value with the payload</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有有效载荷的AMQP值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP connector extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API Gateway supports many ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.
If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document]
and look for security based metadata and register a `java.security.Principal` internally that can be looked up in JAX-RS
by injecting a `javax.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.
If you want more security information, the `Principal` object can be typecast to
a class that will give you more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>API Gateway支持许多不同的方式来对你的HTTP端点进行安全调用，这些端点是由Lambda和Quarkus支持的。如果你启用了它，Quarkus会自动解析 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[事件json文档] 的相关部分，查找基于安全的元数据，并在内部注册一个 `java.security.Principal` ，通过注入 `javax.ws.rs.core.SecurityContext` ，通过Servlet中的 `HttpServletRequest.getUserPrincipal()` ，以及Reactive Routes中的 `RouteContext.user()` ，可以在JAX-RS中进行查找。如果你了解更多的安全信息， `Principal` 对象可以被类型转化为一个能给你更多信息的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.
This is explicitly set in `manage.sh` `cmd_create()`. Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS X-Ray确实在你的发行版中添加了许多类，确保你至少使用了256MB的AWS Lambda内存大小。这在 `manage.sh` `cmd_create()` 中进行了明确的设置。虽然原生镜像可能总是使用较低的内存设置，但建议保持设置不变，特别是为了帮助比较性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in `manage.sh` `cmd_create()`. Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS X-Ray确实在你的发行版中添加了许多类，确保你至少使用了256MB的AWS Lambda内存大小。这在 `manage.sh` `cmd_create()` 中进行了明确的设置。虽然原生镜像可能总是使用较低的内存设置，但建议保持设置不变，特别是为了帮助比较性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>About serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accept JWT as a cookie</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接受JWT作为cookie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Access Git repositories with JGit</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用JGit访问Git存储库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Access Google Cloud services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Access Google Cloud services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Access to Public Resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>获取公共资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing JWT claims</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问JWT声明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing Kafka clients directly</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>直接访问Kafka客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing application properties with Spring Boot properties API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot属性API访问应用程序属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问Vert.x实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问被管理的Vert.x实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Acknowledgement</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消息确认</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Acknowledgment Strategies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确认策略(Acknowledgment Strategies)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus-jaxb` as a dependency in your Maven `pom.xml`, or Gradle `build.gradle` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>把 `quarkus-jaxb` 作为一个依赖项添加到你的Maven `pom.xml` ，或Gradle `build.gradle` 文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `quarkus.kafka.snappy.enabled=true` 添加到您的 `application.properties` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a SQL migration to the default folder following the Flyway naming conventions: `{migrations-path}/V1.0.0__Quarkus.sql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>按照Flyway的命名惯例，在默认文件夹中添加SQL迁移： `{migrations-path}/V1.0.0__Quarkus.sql` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add an optional `name` property to the `GreetingProperties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `GreetingProperties` 中添加一个可选的 `name` 属性:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add custom queries on your entities inside the entities themselves.
That way, you and your co-workers can find them easily, and queries are co-located with the object they operate on.
Adding them as static methods in your entity class is the Panache Active Record way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在实体本身内部的实体上添加自定义查询。这样，您和您的同事可以轻松找到它们，并且查询与他们操作的对象位于同一位置。将它们作为静态方法添加到实体类中是 Panache Active Record 方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add custom queries on your entities inside the entities themselves.  That way, you and your co-workers can find them easily, and queries are co-located with the object they operate on.  Adding them as static methods in your entity class is the Panache Active Record way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在实体本身内部的实体上添加自定义查询。这样，您和您的同事可以轻松找到它们，并且查询与他们操作的对象位于同一位置。将它们作为静态方法添加到实体类中是 Panache Active Record 方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following dependencies to your test project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的测试项目中添加以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>添加以下依赖关系：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following method to the `VertxResource` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将以下方法添加到 `VertxResource` 类中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add this dependency to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将此依赖添加到你的 `pom.xml` 中 ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add this dependency to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将以下依赖性添加到你的构建文件中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add this dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>添加这个依赖性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding a Public Key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>添加公钥</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding a `%prod.` profile prefix to `quarkus.oidc.auth-server-url` ensures that `Dev Services for Keycloak` will launch a container for you when the application is run in a dev mode. See &lt;&lt;keycloak-dev-mode, Running the Application in Dev mode&gt;&gt; section below for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `quarkus.oidc.auth-server-url` 上添加一个 `%prod.` profile前缀，可以确保 `Keycloak开发服务` 在应用程序以开发模式运行时为您启动一个容器。更多信息请参见下面的 " link:#keycloak-dev-mode[在开发模式下运行应用程序] "部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding entity methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>添加实体方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional Quarkus resources for OIDC authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于OIDC认证的其他Quarkus资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional SmallRye JWT configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>额外的SmallRye JWT配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其他配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional instrumentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其他的植入(instrumentation)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional requirements for client SSL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对客户端SSL的额外要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional set `-Djavax.net.ssl.trustStorePassword=changeit` if your `cacerts` file is password protected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的 `cacerts` 文件有密码保护，则额外设置 `-Djavax.net.ssl.trustStorePassword=changeit` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, Quarkus includes extensions that make it easy to deploy serverless microservices to cloud providers including AWS Lambda, Azure Functions, and Google Cloud Functions as well as Knative to take advantage of Quarkus application’s fast startup times. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，Quarkus还包括一些扩展，使其能够轻松地将无服务器微服务部署到云提供商，包括AWS Lambda、Azure Functions和Google Cloud Functions以及Knative，以获得Quarkus应用程序的快速启动时间方面优势。&lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, `quarkus-oidc` provides a simple default memory based token cache which implements both `quarkus.oidc.TokenIntrospectionCache` and `quarkus.oidc.UserInfoCache` interfaces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外， `quarkus-oidc` 提供了一个简单的基于内存的默认令牌缓存，该缓存同时实现了 `quarkus.oidc.TokenIntrospectionCache` 和 `quarkus.oidc.UserInfoCache` 接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, a custom `SecurityIdentityAugmentor` can also be used to add the roles as documented xref:security.adoc#security-identity-customization[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，一个自定义的 `SecurityIdentityAugmentor` ，也可以用来添加角色，文档请查阅 link:security.html#security-identity-customization[这里] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced Query</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高级查询</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced configuration of the transaction is possible with the use of the `@TransactionConfiguration` annotation that is set in addition to the standard `@Transactional` annotation on your entry method or at the class level.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了在你的入口方法上或在类的层面上设置标准的 `@Transactional` 注解之外，事务的高级配置还可以通过使用 `@TransactionConfiguration` 注解来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After compilation has finished, you find the build artifact in `target/native-sources`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译完成后，你可以在 `target/native-sources` 找到构建工件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After getting a cup of coffee, you'll be able to run this binary directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一杯咖啡的时间后，您就可以直接运行该二进制文件了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After importing the realm you can see the resource permissions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>导入realm后，您可以看到资源的权限：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you make this addition to your `TokenSecuredResource`, rerun the `./mvnw compile quarkus:dev` command, and then try `curl -v http://127.0.0.1:8080/secured/roles-allowed; echo` to attempt to access the new endpoint. Your output should be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在对你的 `TokenSecuredResource` 进行这一补充后，重新运行 `./mvnw compile quarkus:dev` 命令，然后尝试 `curl -v http://127.0.0.1:8080/secured/roles-allowed; echo` 来访问新的端点。你的输出应该是:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files
are in the build directory:  `target/` for Maven, `build/` for Gradle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行构建后，你所使用的Quarkus lambda扩展会生成一些额外的文件。对于Maven，这些文件位于构建目录： `target/` 中，对于Gradle，则位于 `build/` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the build directory: `target/` for Maven, `build/` for Gradle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行构建后，你所使用的Quarkus lambda扩展会生成一些额外的文件。对于Maven，这些文件位于构建目录： `target/` 中，对于Gradle，则位于 `build/` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the `quarkus-amazon-lambda` extension.  These files
are in the the build directory:  `target/` for maven, `build/` for gradle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行构建后，有几个由 `quarkus-amazon-lambda` 扩展额外生成的文件。对于maven，这些文件位于构建目录：`target/` 中，对于gradle，则位于 `build/` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the `quarkus-amazon-lambda` extension.  These files are in the the build directory: `target/` for maven, `build/` for gradle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行构建后，有几个由 `quarkus-amazon-lambda` 扩展额外生成的文件。对于maven，这些文件位于构建目录：`target/` 中，对于gradle，则位于 `build/` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All BuildItems</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有BuildItems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `list` methods have equivalent `stream` versions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有 `list` 方法都有相对应的 `stream` 版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `quarkus-http` connector options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有 `quarkus-http` 连接器选项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All configuration options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有配置选项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All messages received by a consumer must be acknowledged.
In the absence of acknowledgment, the processing is considered in error.
If the consumer method receives a `Record` or a payload, the message will be acked on method return, also known as `Strategy.POST_PROCESSING`.
If the consumer method returns another reactive stream or `CompletionStage`, the message will be acked when the downstream message is acked.
You can override the default behavior to ack the message on arrival (`Strategy.PRE_PROCESSING`),
or do not ack the message at all (`Strategy.NONE`) on the consumer method as in the following example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者收到的所有消息都必须被确认(acknowleged)。在没有确认的情况下，消息处理会出错。如果消费者方法收到一个 `Record` 或一个payload，该消息将通过方法返回被确认，也被称为 `Strategy.POST_PROCESSING` 。如果消费者方法返回另一个reactive stream或 `CompletionStage` ，那么当下游消息(downstream message)被确认时，该消息也将被确认。您可以覆盖默认行为从而在消息到达时进行确认( `Strategy.PRE_PROCESSING` )，或者在消费者方法中不进行任何确认( `Strategy.NONE` )，如下例所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All messages received by a consumer must be acknowledged.  In the absence of acknowledgment, the processing is considered in error.  If the consumer method receives a `Record` or a payload, the message will be acked on method return, also known as `Strategy.POST_PROCESSING`.  If the consumer method returns another reactive stream or `CompletionStage`, the message will be acked when the downstream message is acked.  You can override the default behavior to ack the message on arrival (`Strategy.PRE_PROCESSING`), or do not ack the message at all (`Strategy.NONE`) on the consumer method as in the following example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者收到的所有消息都必须被确认(acknowleged)。在没有确认的情况下，消息处理会出错。如果消费者方法收到一个 `Record` 或一个payload，该消息将通过方法返回被确认，也被称为 `Strategy.POST_PROCESSING` 。如果消费者方法返回另一个reactive stream或 `CompletionStage` ，那么当下游消息(downstream message)被确认时，该消息也将被确认。您可以覆盖默认行为从而在消息到达时进行确认( `Strategy.PRE_PROCESSING` )，或者在消费者方法中不进行任何确认( `Strategy.NONE` )，如下例所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All methods accepting a query string also accept an optional `Sort` parameter, which allows you to abstract your sorting:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有接受查询字符串的方法也接受一个可选的 `Sort` 参数，这使你可以抽象出你的排序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All methods accepting a query string also accept the following simplified query form:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有接收查询字符串的方法也能接收以下简化形式的查询：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All opaque and sometimes JWT Bearer access tokens have to be remotely introspected. If `UserInfo` is also required then the same access token will be used to do a remote call to OpenID Connect Provider again. So, if `UserInfo` is required and the current access token is opaque then for every such token there will be 2 remote calls done - one to introspect it and one to get UserInfo with it, and if the token is JWT then usually only a single remote call will be needed - to get UserInfo with it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有不透明的、有时是JWT不记名的访问令牌都必须进行远程自省。如果还需要 `UserInfo` ，那么相同的访问令牌将被用来再次远程调用OpenID Connect Provider。因此，如果需要 `UserInfo` ，并且当前的访问令牌是不透明的，那么对于每一个这样的令牌，将进行两次远程调用--一次是反省，一次是用它来获取UserInfo，如果令牌是JWT，那么通常只需要一次远程调用--用它来获取UserInfo。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All right, so far so good, but wouldn't it be better with a few tests, just in case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>好吧，到目前为止还不错。为了以防万一， 我们需要再做一些测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All spans created from the application will include an OpenTelemetry `Resource` indicating the span was created by the `myservice` application. If not set, it will default to the artifact id.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有从应用程序创建的spans将包含一个OpenTelemetry `Resource` ，表明该span是由 `myservice` 应用程序创建。如果没有设置，它将默认为artifact id。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the JWT claims can also be injected.
Let's expand our `TokenSecuredResource` with another endpoint /secured/roles-allowed-admin which uses the injected `birthdate` claim (as opposed to getting it from `JsonWebToken`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有的JWT声明(claims)也可以被注入。让我们用另一个端点/secured/roles-allowed-admin来扩展我们的 `TokenSecuredResource` ，它使用注入的 `birthdate` （而不是从 `JsonWebToken` 得来）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the JWT claims can also be injected. Let's expand our `TokenSecuredResource` with another endpoint /secured/roles-allowed-admin which uses the injected `birthdate` claim
(as opposed to getting it from `JsonWebToken`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有的JWT声明(claims)也可以被注入。让我们用另一个端点/secured/roles-allowed-admin来扩展我们的 `TokenSecuredResource` ，它使用注入的 `birthdate` （而不是从 `JsonWebToken` 得来）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the JWT claims can also be injected. Let's expand our `TokenSecuredResource` with another endpoint /secured/roles-allowed-admin which uses the injected `birthdate` claim (as opposed to getting it from `JsonWebToken`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有的JWT声明(claims)也可以被注入。让我们用另一个端点/secured/roles-allowed-admin来扩展我们的 `TokenSecuredResource` ，它使用注入的 `birthdate` （而不是从 `JsonWebToken` 得来）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server are formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览器和服务器之间的所有信息都被格式化为JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server is formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览器和服务器之间的所有信息都被格式化为JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the operations that are defined on `PanacheEntityBase` are available on your repository, so using it
is exactly the same as using the active record pattern, except you need to inject it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PanacheEntityBase` 中定义的所有方法都可以在你的Repository类上使用，所以它使用起来与Active Record模式完全一样，只是你需要注入Repository类的实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the operations that are defined on `PanacheEntityBase` are available on your repository, so using it is exactly the same as using the active record pattern, except you need to inject it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PanacheEntityBase` 中定义的所有方法都可以在你的Repository类上使用，所以它使用起来与Active Record模式完全一样，只是你需要注入Repository类的实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the operations that are defined on `PanacheMongoEntityBase` are available on your repository, so using it
is exactly the same as using the active record pattern, except you need to inject it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有在 `PanacheMongoEntityBase` 上定义的操作都可以在你的版本库上使用，所以使用它与使用active record（活动记录）模式完全一样，只是你需要注入它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the operations that are defined on `PanacheMongoEntityBase` are available on your repository, so using it is exactly the same as using the active record pattern, except you need to inject it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有在 `PanacheMongoEntityBase` 上定义的操作都可以在你的版本库上使用，所以使用它与使用active record（活动记录）模式完全一样，只是你需要注入它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the techniques allowing reducing the memory usage and provide faster startup times are not only advantageous in containers. Even on bare metal, it would reduce your memory pressure, and it’s always pleasant to not have to wait 10 seconds to see your application running.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有允许减少内存使用和提供更快的启动时间的技术，不仅在容器中是有利的。即使在裸金属环境上，它也会减少你的内存压力，而且不必等待10秒就能看到你的应用程序运行，这总是令人愉快的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the test profile configuration is stored in a single class, which makes it easy to tell if the previous test ran with the
same configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有的测试profile配置都存储在一个单一的类中，这使得我们很容易知道之前的测试是否以相同的配置运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the test profile configuration is stored in a single class, which makes it easy to tell if the previous test ran with the same configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有的测试profile配置都存储在一个单一的类中，这使得我们很容易知道之前的测试是否以相同的配置运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All these delivery mechanisms are non-blocking and are providing one of the fundamental bricks to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有这些交付机制都是无阻塞的，并提供了构建响应式应用的基本砖块之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All these methods have default implementations so just override the ones you need to override.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有这些方法都有默认的实现，所以只要覆盖您需要覆盖的方法就可以。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, Quarkus makes it very easy to configure various Jackson settings via CDI beans.
The simplest (and suggested) approach is to define a CDI bean of type `io.quarkus.jackson.ObjectMapperCustomizer`
inside of which any Jackson configuration can be applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，Quarkus使得通过CDI beans来配置各种Jackson设置变得非常容易。最简单的（也是建议的）方法是定义一个类型为 `io.quarkus.jackson.ObjectMapperCustomizer` 的CDI Bean，在其中可以使用任何Jackson配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, Quarkus makes it very easy to configure various Jackson settings via CDI beans.  The simplest (and suggested) approach is to define a CDI bean of type `io.quarkus.jackson.ObjectMapperCustomizer` inside of which any Jackson configuration can be applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，Quarkus使得通过CDI beans来配置各种Jackson设置变得非常容易。最简单的（也是建议的）方法是定义一个类型为 `io.quarkus.jackson.ObjectMapperCustomizer` 的CDI Bean，在其中可以使用任何Jackson配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow`
dependencies are all optional.  Pick which HTTP framework(s) you want to use (JAX-RS, Reactive Routes, and/or Servlet) and
remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，至少在生成的Maven原型 `pom.xml` 中， `quarkus-resteasy-reactive` 、 `quarkus-reactive-routes` 和 `quarkus-undertow` 依赖项都是可选的。选择你想使用的HTTP框架（JAX-RS、Reactive Routes和/或Servlet），并删除其他依赖项以缩小部署规模。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (JAX-RS, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，至少在生成的Maven原型 `pom.xml` 中， `quarkus-resteasy-reactive` 、 `quarkus-reactive-routes` 和 `quarkus-undertow` 依赖项都是可选的。选择你想使用的HTTP框架（JAX-RS、Reactive Routes和/或Servlet），并删除其他依赖项以缩小部署规模。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, you can configure the lookup timeout using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，您可以使用以下方法配置来查找超时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Altering the test class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>改动测试类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative - Using ubi-minimal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>替代方案 - 使用 ubi-minimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Languages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>替代语言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为拦截器的替代或补充，您可以通过实现以下回调接口来增强 *所有* 的 `@QuarkusTest` 类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, if the discovery endpoint is not available, or if you would like to save on the discovery endpoint round-trip, you can disable the discovery and configure them with relative path values, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，如果发现端点不可用，或者你想节省发现端点的往返开销，你可以禁用发现，用相对路径值配置它们，比如说：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, prefer the use of constructor injection which works without modification of the Java examples, increases testability and complies best to a Kotlin programming style.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，更喜欢使用构造函数注入，它可以在不修改Java示例的情况下工作，提高可测试性，并且最符合Kotlin编程风格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can start a Kafka broker in a test resource.
The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，您也可以在测试资源中启动一个Kafka broker。下面的片段展示了如何在一个测试资源使用 link:https://www.testcontainers.org/modules/kafka/[Testcontainers] 启动一个Kafka broker：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，您也可以在测试资源中启动一个Kafka broker。下面的片段展示了如何在一个测试资源使用 link:https://www.testcontainers.org/modules/kafka/[Testcontainers] 启动一个Kafka broker：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can use the `blocking` attribute from the `@ConsumeEvent` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，你可以使用 `@ConsumeEvent` 注解中的 `blocking` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, your application can inject a `Multi` in your bean and subscribe to its events as the following example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，您的应用程序可以在您的Bean中注入一个 `Multi` ，然后像下面的例子那样订阅它的事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test
we would most likely configure a mock, but then test a bean that uses the mocked bean.
Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尽管上面的测试很好地展示了 `@InjectMock` 的能力，但它并不能很好地表示一个真实的测试案例。在一个真实的测试案例中，我们很可能会配置一个mock，然后测试一个使用了mocked Bean的Bean。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test we would most likely configure a mock, but then test a bean that uses the mocked bean.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尽管上面的测试很好地展示了 `@InjectMock` 的能力，但它并不能很好地表示一个真实的测试案例。在一个真实的测试案例中，我们很可能会配置一个mock，然后测试一个使用了mocked Bean的Bean。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although, there is a slight limitation: since job configuration is mostly dynamic and only injected on job execution, Quarkus may fail to start due to invalid configuration (can’t find the Job configuration values). In this case, configuration injection points with the @ConfigProperty annotation need to set a default value or use an Optional.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然，有一个小小的限制：由于作业配置大多是动态的，并且只在作业执行时注入，Quarkus可能会因为无效的配置（找不到作业配置值）而启动失败。在这种情况下，带有@ConfigProperty注解的配置注入点需要设置一个默认值或使用一个Optional。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Alexa Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>亚马逊Alexa整合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon DynamoDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon DynamoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon IAM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon IAM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon KMS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon KMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda with RESTEasy Reactive, Undertow, or Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有RESTEasy Reactive、Undertow或Reactive Routes的Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Vert.x Web、Servlet或RESTEasy的Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon S3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SNS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SNS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SQS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SQS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SSM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SSM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编辑器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An Open Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个开放的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An additional step is needed for generating the private key for converting it into the PKCS#8 format.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成私钥后需要一个额外的步骤，以便将其转换为PKCS#8格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An even nastier possible outcome could be for no exception to be thrown, but instead the JSON result would be completely empty.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个更糟糕的结果是没有抛出异常，而JSON的结果是完全空的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example configuration follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是一个配置实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example explaining how to deploy verticles during the initialization of the application will follow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接下来会有一个例子解释如何在应用程序的初始化过程中部署verticles：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of a `Person` class defined as a Kotlin data class would look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个定义为Kotlin数据类的 `Person` 类的例子是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example usage can be found in &lt;&lt;chaining-kafka-transactions-with-hibernate-reactive-transactions&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例用法可以在 &lt;&lt;chaining-kafka-transactions-with-hibernate-reactive-transactions&gt;&gt; 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example usage could look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例用法如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example use of this could be the following Maven command, that forces `@QuarkusIntegrationTest` to execute against that is accessible at `http://1.2.3.4:4321`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这方面的一个例子是下面的Maven命令，该命令强制 `@QuarkusIntegrationTest` 对位于 `link:http://1.2.3.4:4321[http://1.2.3.4:4321]` 节点执行测试 :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example where a custom module needs to be registered would look like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注册自定义模块的示例如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And all this functionality is provided in a distributed, highly scalable, elastic, fault-tolerant, and secure manner.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而所有这些功能都是以分布式、高可扩展性、弹性、容错以及安全的方式提供的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And configure the Maven Surefire plugin as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并按以下方式配置Maven Surefire插件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And executed using `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并使用 `java -jar target/quarkus-app/quarkus-run.jar` 命令运行该应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And executed using `java -jar target/quarkus-app/quarkus-run.jar`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>执行程序使用 `java -jar target/quarkus-app/quarkus-run.jar` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，用以下方式运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And thanks to our field access rewrite, when your users read `person.name` they will actually call your `getName()` accessor,
and similarly for field writes and the setter.
This allows for proper encapsulation at runtime as all fields calls will be replaced by the corresponding getter/setter calls.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而且由于我们的字段访问重写，当你的用户读取 `person.name` ，他们实际上会调用你的 `getName()` 方法，类似的还有字段写入和设置器。这允许在运行时进行适当的封装，因为所有字段的调用都将被相应的getter/setter调用所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And thanks to our field access rewrite, when your users read `person.name` they will actually call your `getName()` accessor, and similarly for field writes and the setter.
This allows for proper encapsulation at runtime as all fields calls will be replaced by the corresponding getter/setter calls.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而且由于我们的字段访问重写，当你的用户读取 `person.name` ，他们实际上会调用你的 `getName()` 方法，类似的还有字段写入和设置器。这允许在运行时进行适当的封装，因为所有字段的调用都将被相应的getter/setter调用所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And thanks to our field access rewrite, when your users read `person.name` they will actually call your `getName()` accessor, and similarly for field writes and the setter.  This allows for proper encapsulation at runtime as all fields calls will be replaced by the corresponding getter/setter calls.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而且由于我们的字段访问重写，当你的用户读取 `person.name` ，他们实际上会调用你的 `getName()` 方法，类似的还有字段写入和设置器。这允许在运行时进行适当的封装，因为所有字段的调用都将被相应的getter/setter调用所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And this repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>还有这个储存库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And update the `GreetingResource` and its test `GreetingResourceTest`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并更新 `GreetingResource` 及其对应的 `GreetingResourceTest` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而我们想用它来接收来自Kafka的消息，从而进行一些价格转换，并将消息传回Kafka。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And, finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，用以下方式运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And, in a separate terminal:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并且，在另一台终端中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotating a method in any CDI aware bean with the `io.opentelemetry.extension.annotations.WithSpan`
annotation will create a new Span and establish any required relationships with the current Trace context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在任何CDI可感知的Bean中用 `io.opentelemetry.extension.annotations.WithSpan` 注解来注释一个方法将会创建一个新的Span，并与当前Trace上下文建立所需要的任何关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotating a method in any CDI aware bean with the `io.opentelemetry.extension.annotations.WithSpan` annotation will create a new Span and establish any required relationships with the current Trace context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在任何CDI可感知的Bean中用 `io.opentelemetry.extension.annotations.WithSpan` 注解来注释一个方法将会创建一个新的Span，并与当前Trace上下文建立所需要的任何关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotating with `@MongoEntity` is optional. Here the entity will be stored in the `ThePerson` collection instead of the default `Person` collection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@MongoEntity` 注解是可选的。在这里，实体将被存储在 `ThePerson` 集合中，而不是默认的 `Person` 集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotation-based test resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于注解的测试资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another bean receives this message and computes the response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一个Bean收到这个消息，并计算出响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another common pattern in the JAX-RS world is to use the `Response` object.
`Response` comes with some nice perks:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RS世界中另一个常见的模式是使用 `Response` 对象。 `Response` 有一些很好的好处：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another common pattern in the JAX-RS world is to use the `Response` object.  `Response` comes with some nice perks:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RS世界中另一个常见的模式是使用 `Response` 对象。 `Response` 有一些很好的好处：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another option is to use the `@BsonCreator` annotation to tell the `PojoCodecProvider` to use the Kotlin data class default constructor,
in this case all constructor parameters have to be annotated with `@BsonProperty`: see link:{mongodb-doc-root-url}/bson/pojos/#supporting-pojos-without-no-args-constructors[Supporting pojos without no args constructor].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一个选择是使用 `@BsonCreator` 注解来告诉 `PojoCodecProvider` 使用Kotlin数据类的默认构造函数，在这种情况下，所有的构造函数参数都必须用 `@BsonProperty` 注解：见 link:{mongodb-doc-root-url}/bson/pojos/#supporting-pojos-without-no-args-constructors[支持pojos无args构造函数] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another option is to use the `@BsonCreator` annotation to tell the `PojoCodecProvider` to use the Kotlin data class default constructor, in this case all constructor parameters have to be annotated with `@BsonProperty`: see link:{mongodb-doc-root-url}/bson/pojos/#supporting-pojos-without-no-args-constructors[Supporting pojos without no args constructor].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一个选择是使用 `@BsonCreator` 注解来告诉 `PojoCodecProvider` 使用Kotlin数据类的默认构造函数，在这种情况下，所有的构造函数参数都必须用 `@BsonProperty` 注解：见 link:{mongodb-doc-root-url}/bson/pojos/#supporting-pojos-without-no-args-constructors[支持pojos无args构造函数] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一种做法是在你的 `application.properties` ，填写 `quarkus.native.additional-build-args` 配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another solution is to write a script to do this for you:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一个解决方案是写一个脚本来为您做这件事：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If
everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>回答所有的问题，你的lambda将被部署，必要的钩子将被设置到API网关。如果一切部署成功，你的微服务的根URL将被输出到控制台。类似这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>回答所有的问题，你的lambda将被部署，必要的钩子将被设置到API网关。如果一切部署成功，你的微服务的根URL将被输出到控制台。类似这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any other class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任何其他类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any type which can be converted to one of the two previous types using Reactive Type Converters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任何可以使用响应式类型转换器转换为前两种类型之一的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any user is allowed to access the
`http://localhost:8080/api/users/me` endpoint
which basically returns a JSON payload with details about the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任何用户都被允许访问 `&lt;a href="http://localhost:8080/api/users/me" class="bare"&gt;http://localhost:8080/api/users/me&lt;/a&gt;` 节点，该节点会返回一个包含用户详细信息的JSON payload。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any user is allowed to access the `http://localhost:8080/api/users/me` endpoint which basically returns a JSON payload with details about the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任何用户都被允许访问 `&lt;a href="http://localhost:8080/api/users/me" class="bare"&gt;http://localhost:8080/api/users/me&lt;/a&gt;` 节点，该节点会返回一个包含用户详细信息的JSON payload。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any you files and directories you create under your zip directory will be included within `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你在zip目录下创建的任何文件和目录都将包括在 `function.zip` 内</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone can post to this list. The subscribers are only trusted individuals from the Quarkus community who will handle the resolution of any reported security issues in confidence. In your report, please note how you would like to be credited for discovering the issue and the details of any embargo you would like to impose. Currently the security response teams for the following distributions are subscribed to this list and will respond to your report:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任何人都可以在这个列表上发帖。订阅者仅是来自Quarkus社区的受信任的个人，他们将在保密的情况下处理任何报告的安全问题的解决方案。请在你的报告中注明你希望因发现该问题而获得的荣誉，以及你希望实施的任何禁运措施的细节。目前，以下发行版的安全响应团队已经订阅了这个列表，并将对您的报告作出响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Cassandra Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Cassandra客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Kafka Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Kafka开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Kafka Reference Guide</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Kafka参考指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache-2.0 License</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache-2.0许可证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apart from application-specific metrics, which are described in this guide, you may also utilize built-in metrics
exposed by various Quarkus extensions. These are described in the guide for each particular extension that supports
built-in metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了在本指南中所述的一些的应用特定的metrics之外，您也可以利用各种Quarkus扩展所暴露的内置metrics。这些将在支持内置metrics的每个特定扩展的指南中描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apart from application-specific metrics, which are described in this guide, you may also utilize built-in metrics exposed by various Quarkus extensions. These are described in the guide for each particular extension that supports built-in metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了在本指南中所述的一些的应用特定的metrics之外，您也可以利用各种Quarkus扩展所暴露的内置metrics。这些将在支持内置metrics的每个特定扩展的指南中描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apicurio Registry Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apicurio 仓库开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Health &amp; Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用健康和指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Initialization and Termination</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序的初始化和终止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, Big Data, or IoT, going reactive is increasingly becoming the architecture style to follow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在过去的几年里，应用需求发生了巨大的变化。任何应用要想在云计算、大数据或物联网时代取得成功，采取响应式的做法正日益成为应遵循的架构风格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications send and receive *messages*. A message wraps a _payload_ and can be extended with some _metadata_. With the Kafka connector, a _message_ corresponds to a Kafka _record_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序发送和接收 *messages* 。一条消息包含一个 _payload_ ，并可以用一些 _metadata_ 进行扩展。通过Kafka connector，一条 _message_ 对应于一条Kafka _record_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications streaming data often need to consume some events from a topic, process them and publish the result to a different topic.
A processor method can be simply implemented using both the `@Incoming` and `@Outgoing` annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用的流式数据常常需要从一个topic中消费一些事件，对其进行处理并将结果发布到不同的topic中。一个处理器方法可以简单地通过使用 `@Incoming` 和 `@Outgoing` 注解来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications streaming data often need to consume some events from a topic, process them and publish the result to a different topic.  A processor method can be simply implemented using both the `@Incoming` and `@Outgoing` annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用的流式数据常常需要从一个topic中消费一些事件，对其进行处理并将结果发布到不同的topic中。一个处理器方法可以简单地通过使用 `@Incoming` 和 `@Outgoing` 注解来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applying Interceptors to Tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在测试中使用拦截器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC comes as a dependency of `quarkus-resteasy-reactive` so you already have it handy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ArC作为 `quarkus-resteasy-reactive` 的一个依赖项，所以你已经有了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arc, the dependency injection framework used by Quarkus, eliminates all the reflection calls and deduces the injection graph at build time. So, when the application starts, no expensive lookups; it’s done already!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Arc是Quarkus使用的依赖注入框架，它消除了所有的反射调用，并在构建时推断出注入图。因此，当应用程序启动时，不需要昂贵的查找，它已经完成了!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用结构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Articles, blogs, podcast and other tidbits published online around Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>围绕Quarkus在线发布的文章、博客、播客和其他花絮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As MongoDB with Panache allows writing simplified queries, it is sometimes handy to log the generated native queries for debugging purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于带有Panache的MongoDB允许编写简化的查询，有时为调试目的而记录生成的原生查询是很方便的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, it’s not possible to change the destination dynamically (using message metadata) when using RabbitMQ.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，在使用 RabbitMQ 时，不可能动态改变目的地（使用消息元数据）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，许多Quarkus组件在设计时都考虑了响应式，比如数据库访问（PostgreSQL, MySQL, Mongo等），应用服务（邮件，模板引擎等），消息传递（Kafka, AMQP等）等等。但是，要完全受益于此模型，应用程序代码应该以非阻塞的方式编写。这就是运用一个响应式API这个终极武器的地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a test annotated with `@QuarkusIntegrationTest` tests the result of the build, it should be run as part of the integration test suite - i.e. by setting `-DskipITs=false` if using Maven or the `quarkusIntTest` task if using Gradle.
These tests will **not** work if run in the same phase as `@QuarkusTest` as Quarkus has not yet created the final artifact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于用 `@QuarkusIntegrationTest` 注释的测试是对构建结果的测试，它应该作为集成测试套件的一部分来运行--即如果使用Maven，则设置 `-DskipITs=false`，而如果使用Gradle，则通过 `quarkusIntTest` 任务。如果与 `@QuarkusTest` 在同一阶段运行，这些测试将 *无法* 工作，因为Quarkus还没有产生出最终的artifact。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a test annotated with `@QuarkusIntegrationTest` tests the result of the build, it should be run as part of the integration test suite - i.e. by setting `-DskipITs=false` if using Maven or the `quarkusIntTest` task if using Gradle.  These tests will **not** work if run in the same phase as `@QuarkusTest` as Quarkus has not yet created the final artifact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于用 `@QuarkusIntegrationTest` 注释的测试是对构建结果的测试，它应该作为集成测试套件的一部分来运行--即如果使用Maven，则设置 `-DskipITs=false`，而如果使用Gradle，则通过 `quarkusIntTest` 任务。如果与 `@QuarkusTest` 在同一阶段运行，这些测试将 *无法* 工作，因为Quarkus还没有产生出最终的artifact。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish
to work with native image builds.  The script will take care of the rest of the details necessary to manage your native
image function deployments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，命令可以叠加。如果你想使用原生镜像构建，唯一的要求是 `native` 是第一个参数。该脚本将处理管理你原生镜像功能部署所需的其余细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish to work with native image builds.  The script will take care of the rest of the details necessary to manage your native image function deployments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，命令可以叠加。如果你想使用原生镜像构建，唯一的要求是 `native` 是第一个参数。该脚本将处理管理你原生镜像功能部署所需的其余细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, in order to register all methods of class `com.acme.MyClass` for reflection, we create `reflection-config.json` (the most common location is within `src/main/resources`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为一个例子，为了注册类 `com.acme.MyClass` 的所有方法进行反射，我们创建 `reflection-config.json` （最常见的位置是在 `src/main/resources` 内）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As before, the UI is exposed on http://localhost:8080/quotes.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与之前一样，UI也是在 http://localhost:8080/quotes.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As by default, `MongoClient` is configured to access a local MongoDB database on port 27017 (the default MongoDB port), if you have a local running database on this port, there is nothing more to do before being able to test it!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在默认情况下， `MongoClient` 被配置为在27017端口（默认的MongoDB端口）上访问本地的MongoDB数据库，如果你在这个端口上有一个本地运行的数据库，那么在能够测试之前，不需要做其他操作！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As explained in https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the rhoas CLI for Red Hat OpenShift Streams for Apache Kafka], to use Red Hat OpenShift Streams for Apache Kafka, you must create the topic beforehand, create a _Service Account_, and provide permissions to read and write to your topic from that service account.
The authentication data (client id and secret) relates to the service account, which means you can implement fine-grain permissions and restrict access to the topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如在《 link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[红帽OpenShift Streams for Apache Kafka的 `rhoas` 命令行入门] 》中所解释的那样，要使用红帽OpenShift Streams for Apache Kafka，您必须事先创建topic，创建一个 _Service Account_ ，并提供从该服务账户读取和写入topic的权限。认证数据(客户端ID和密码)与服务账户有关，这意味着您可以实现细粒度的权限，并限制对topic的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As explained in https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the rhoas CLI for Red Hat OpenShift Streams for Apache Kafka], to use Red Hat OpenShift Streams for Apache Kafka, you must create the topic beforehand, create a _Service Account_, and provide permissions to read and write to your topic from that service account.  The authentication data (client id and secret) relates to the service account, which means you can implement fine-grain permissions and restrict access to the topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如在《 link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[红帽OpenShift Streams for Apache Kafka的 `rhoas` 命令行入门] 》中所解释的那样，要使用红帽OpenShift Streams for Apache Kafka，您必须事先创建topic，创建一个 _Service Account_ ，并提供从该服务账户读取和写入topic的权限。认证数据(客户端ID和密码)与服务账户有关，这意味着您可以实现细粒度的权限，并限制对topic的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for the Java Properties format, you can define your own profile:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>至于Java Properties 格式，你可以定义你自己的环境配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for the reactive APIs exposed by Quarkus, stream manipulation uses the Mutiny API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么Quarkus的采用Mutiny API作为响应式API来进行流操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As indicated in the property name, it uses Vert.x to retrieve the DNS records.
By default, it tries to read the first `nameserver` from `/etc/resolv.conf`, if this file exists.
You can also configure your DNS server:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如属性名称所示，它使用 Vert.x 检索 DNS 记录。默认情况下，如果此文件存在，它会尝试从 `etcresolv.conf` 中读取第一个 `nameserver`。您还可以这样配置 DNS 服务器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As indicated in the property name, it uses Vert.x to retrieve the DNS records.  By default, it tries to read the first `nameserver` from `/etc/resolv.conf`, if this file exists.  You can also configure your DNS server:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如属性名称所示，它使用 Vert.x 检索 DNS 记录。默认情况下，如果此文件存在，它会尝试从 `etcresolv.conf` 中读取第一个 `nameserver`。您还可以这样配置 DNS 服务器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is the case with `@NativeImageTest`, this is a black box test that supports the same set features and has the same limitations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如同 `@NativeImageTest` ，这是一个黑盒测试，支持相同的功能集且具有相同的限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As it uses a dedicated JDBC driver, you must configure your datasource and Hibernate ORM to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于它使用专用的JDBC驱动，您必须配置您的数据源和Hibernate ORM来使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would
normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the
`@Transactional` annotation to the method and the transaction interceptor will handle it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，Quarkus测试实际上是完整的CDI Bean，因此您可以自由的使用CDI拦截器。举个例子，如果您想让测试方法在事务上下文中运行，您可以将 `@Transactional` 注解加到该方法上，之后事务拦截器将会处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the `@Transactional` annotation to the method and the transaction interceptor will handle it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，Quarkus测试实际上是完整的CDI Bean，因此您可以自由的使用CDI拦截器。举个例子，如果您想让测试方法在事务上下文中运行，您可以将 `@Transactional` 注解加到该方法上，之后事务拦截器将会处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, in this guide, we are going to implement a reactive CRUD application.
But you may wonder what the differences and benefits are in comparison to the traditional and imperative model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，在本指南中，我们将实现一个响应式CRUD应用程序。但您可能想知道，与传统的、指令式的模式相比，它有什么不同和好处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, in this guide, we are going to implement a reactive CRUD application.  But you may wonder what the differences and benefits are in comparison to the traditional and imperative model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，在本指南中，我们将实现一个响应式CRUD应用程序。但您可能想知道，与传统的、指令式的模式相比，它有什么不同和好处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the issue is that Quarkus was not able to determine the `Legume` class will require some reflection by analyzing the REST endpoints.
The JSON serialization library tries to get the list of fields of `Legume` and gets an empty list so it does not serialize the fields' data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，问题是Quarkus无法通过分析REST节点来确定 `Legume` 类将需要一些反射。JSON序列化库试图获取 `Legume` 的字段列表，但得到的是一个空列表，所以它没有序列化字段的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the issue is that Quarkus was not able to determine the `Legume` class will require some reflection by analyzing the REST endpoints.  The JSON serialization library tries to get the list of fields of `Legume` and gets an empty list so it does not serialize the fields' data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，问题是Quarkus无法通过分析REST节点来确定 `Legume` 类将需要一些反射。JSON序列化库试图获取 `Legume` 的字段列表，但得到的是一个空列表，所以它没有序列化字段的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the method can also override the acknowledgment strategy to `PRE_PROCESSING` or `NONE`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，该方法还可以将确认策略设置为 `PRE_PROCESSING` 或 `NONE` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in &lt;4&gt;, you need a deserializer that can create a `Fruit` from the record.
This can be done using a Jackson deserializer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如&lt;4&gt;中提到的，您需要一个能从记录中重建 `Fruit` 对象的反序列化器。可以使用Jackson的反序列化器来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in &lt;4&gt;, you need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如&lt;4&gt;中提到的，您需要一个能从记录中重建 `Fruit` 对象的反序列化器。可以使用Jackson的反序列化器来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible Quarkus tries to avoid reflection, reducing startup time and memory usage. During the built-time processing, extensions can analyze the application code and the classes available on the classpath and replace reflection calls with regular invocations. The usage of dynamic proxies is also prevented by using generating custom proxy at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus尽可能地避免反射，减少启动时间和内存使用。在构建时的处理过程中，扩展可以分析应用程序代码和classpath上可用的类，并以常规调用取代反射调用。通过在构建时使用生成的自定义代理，也可以防止使用动态代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much processing as possible is done at build time; thus, your application only contains the classes used at runtime. In traditional frameworks, all the classes required to perform the initial application deployment hang around for the application’s life, even though they are only used once. With Quarkus, they are not even loaded into the production JVM! Quarkus does not stop here. During the build-time processing, it prepares the initialization of all components used by your application. It results in less memory usage and faster startup time as all metadata processing has already been done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尽可能将更多的处理在构建时完成；因此，你的应用程序只包含在运行时使用的类。在传统的框架中，所有执行初始应用部署所需的类都在应用的生命周期中存在，尽管它们只被使用一次。在Quarkus中，它们甚至不会被加载到生产用的JVM中。Quarkus并没有到此为止。在构建时的处理过程中，它为你的应用程序使用的所有组件的初始化做准备。由于所有的元数据处理都已经完成，这带来了更少的内存使用和更快的启动时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As shown in the &lt;&lt;developing-with-flyway&gt;&gt; section, to start using Flyway with your project, you just need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>参照 &lt;&lt;用flyway开发&gt;&gt; ，要开始在项目中使用Flyway，只需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As stated above, Quarkus provides the option of using JSON-B instead of Jackson via the use of the `quarkus-resteasy-jsonb` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，Quarkus通过使用 `quarkus-resteasy-jsonb` 扩展提供了使用JSON-B而不是Jackson的选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the Vert.x API is asynchronous, our method returns a `Uni`. The content is written into the HTTP response when the asynchronous operation represented by the Uni completes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于Vert.x API是异步的，我们的方法返回一个 `Uni` 对象 。当Uni所代表的异步操作完成后，内容将会被写入HTTP响应中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于注入的实例在这里不可用，我们使用了 `installMockForType` ，这个mock用在于所有两个测试方法中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the list of commands which are supported out-of-box by both https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] and https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] depends on what is available in https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`], then there might be case when you need a command which is not (yet) available via https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] 和 https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] 开箱即支持的命令列表取决于 https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] 所支持的命令，那么可能会出现你需要用的命令 https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] （还）不支持的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, Quarkus further simplifies things under the hood when running your application as a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>像往常一样，当您将应用程序作为本机可执行文件运行时，Quarkus 进一步简化了内部工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>像往常一样，该应用程序能够使用以下方式进行打包:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we are writing in a database, we must be in a transaction. This annotation starts a new transaction and commits it when the method returns.
Quarkus automatically considers the method as _blocking_. Indeed, writing to a database using classic Hibernate is blocking. So, Quarkus calls the method on a worker thread you can block (and not an I/O thread).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们是往数据库中写入数据，所以必须使用事务。这个注解启动了一个新的事务，并在方法返回时提交它。Quarkus会自动认为这个方法是 _阻塞的_ 。事实上，使用常规的Hibernate方法向数据库写入是阻塞操作。所以，Quarkus会在一个可阻塞的工作线程中调用这个方法(而不是在I/O线程中)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we are writing in a database, we must be in a transaction. This annotation starts a new transaction and commits it when the method returns.  Quarkus automatically considers the method as _blocking_. Indeed, writing to a database using classic Hibernate is blocking. So, Quarkus calls the method on a worker thread you can block (and not an I/O thread).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们是往数据库中写入数据，所以必须使用事务。这个注解启动了一个新的事务，并在方法返回时提交它。Quarkus会自动认为这个方法是 _阻塞的_ 。事实上，使用常规的Hibernate方法向数据库写入是阻塞操作。所以，Quarkus会在一个可阻塞的工作线程中调用这个方法(而不是在I/O线程中)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we are writing to the database, make sure we run inside a transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当我们向数据库中写入数据时，请确保运行在事务中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen above, the API exposes five Rest endpoints.
In this section we are going to see how to initialise an increment, see the list of current increments,
incrementing a value given its key, retrieving the current value of an increment, and finally deleting
a key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从上文可以看到，该API服务暴露了五个Restful接口。在这一节中，我们将看到如何初始化一个增量，查看当前的增量列表，给指定键的值递增，查询一个增量的当前值，以及删除一个键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen above, the API exposes five Rest endpoints.  In this section we are going to see how to initialise an increment, see the list of current increments, incrementing a value given its key, retrieving the current value of an increment, and finally deleting a key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从上文可以看到，该API服务暴露了五个Restful接口。在这一节中，我们将看到如何初始化一个增量，查看当前的增量列表，给指定键的值递增，查询一个增量的当前值，以及删除一个键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen, the event bus is the connecting tissue of Vert.x applications.
Quarkus integrates it so different beans can interact with asynchronous messages.
This part is covered in the xref:reactive-event-bus.adoc[event bus documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如我们所见，事件总线是 Vert.x 应用程序之间的连接桥梁。 Quarkus 集成了它，因此不同的bean之间能够以异步消息的方式进行交互。这部分内容包含在 xref:reactive-event-bus.adoc[事件总线文档] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen, the event bus is the connecting tissue of Vert.x applications.  Quarkus integrates it so different beans can interact with asynchronous messages.  This part is covered in the xref:reactive-event-bus.adoc[event bus documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如我们所见，事件总线是 Vert.x 应用程序之间的连接桥梁。 Quarkus 集成了它，因此不同的bean之间能够以异步消息的方式进行交互。这部分内容包含在 xref:reactive-event-bus.adoc[事件总线文档] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we saw in the MongoDB with Panache guide, it allows us to extend the functionality in our entities and repositories (also known as DAOs) with some automatically
provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight
change or two.  To Panache-enable your entity, you would define it something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如我们在MongoDB with Panache指南中所看到的，它允许我们用一些自动提供的功能来扩展我们实体和存储库（也称为DAO）中的功能。在使用Kotlin时，该方法与我们在Java版本中看到的非常相似，只是有一两个微小的变化。为了使你的实体具有Panache功能，你可以这样定义它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we saw in the MongoDB with Panache guide, it allows us to extend the functionality in our entities and repositories (also known as DAOs) with some automatically provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight change or two.  To Panache-enable your entity, you would define it something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如我们在MongoDB with Panache指南中所看到的，它允许我们用一些自动提供的功能来扩展我们实体和存储库（也称为DAO）中的功能。在使用Kotlin时，该方法与我们在Java版本中看到的非常相似，只是有一两个微小的变化。为了使你的实体具有Panache功能，你可以这样定义它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we want to use configuration properties obtained from the Config Server, we will update the `GreetingResource` to inject the `message` property. The updated code will look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们想使用从配置服务器(Config Server)中获取到的配置属性，我们将更新 `GreetingResource` 以注入 `message` 属性。更新后的代码将如下所示:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the previous `Message` example, if your injected channel receives payloads (`Multi&lt;T&gt;`), it acknowledges the message automatically, and support multiple subscribers.
If you injected channel receives Message (`Multi&lt;Message&lt;T&gt;&gt;`), you will be responsible for the acknowledgment and broadcasting.
We will explore sending broadcast messages in &lt;&lt;broadcasting-messages-on-multiple-consumers&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如前面 `Message` 例子所示，如果您的注入channel接收到了playloads( `Multi&lt;T&gt;` )，它可以支持多订阅者自动确认消息。如果您的注入channel收到Message( `Multi&lt;Message&lt;T&gt;&gt;` )，那么您需要自行负责消息确认和广播。我们将在&lt;&lt;broadcasting-messages-on-multiple-consumers&gt;&gt; 中探讨消息的发送和广播。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the previous `Message` example, if your injected channel receives payloads (`Multi&lt;T&gt;`), it acknowledges the message automatically, and support multiple subscribers.  If you injected channel receives Message (`Multi&lt;Message&lt;T&gt;&gt;`), you will be responsible for the acknowledgment and broadcasting.  We will explore sending broadcast messages in &lt;&lt;broadcasting-messages-on-multiple-consumers&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如前面 `Message` 例子所示，如果您的注入channel接收到了playloads( `Multi&lt;T&gt;` )，它可以支持多订阅者自动确认消息。如果您的注入channel收到Message( `Multi&lt;Message&lt;T&gt;&gt;` )，那么您需要自行负责消息确认和广播。我们将在&lt;&lt;broadcasting-messages-on-multiple-consumers&gt;&gt; 中探讨消息的发送和广播。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see in the previous snippet, you can use xref:config-reference.adoc#profiles[profiles] in YAML. The profile
key requires double quotes: `"%test"`. This is because YAML does not support keys starting with `%`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如你在之前的代码片段中所看到的，你可以在YAML中使用 link:config-reference.html#profiles[profiles] 。该环境配置的key 需要使用双引号: `"%test"` 。这是因为YAML不支持以 `%` 开始的键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see in the previous snippet, you can use xref:config-reference.adoc#profiles[profiles] in YAML. The profile key requires double quotes: `"%test"`. This is because YAML does not support keys starting with `%`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如你在之前的代码片段中所看到的，你可以在YAML中使用 link:config-reference.html#profiles[profiles] 。该环境配置的key 需要使用双引号: `"%test"` 。这是因为YAML不支持以 `%` 开始的键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see our entities remain simple.  There is, however, a slight difference from the Java version.  The Kotlin
language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we must use a
https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects[companion object]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如你所见，我们的实体仍然很简单。然而，与Java版本有一点不同。Kotlin语言并不像Java那样支持静态方法的概念。相反，我们必须使用一个 link:https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects[companion object（同伴对象）] ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see our entities remain simple.  There is, however, a slight difference from the Java version.  The Kotlin language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we must use a https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects[companion object]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如你所见，我们的实体仍然很简单。然而，与Java版本有一点不同。Kotlin语言并不像Java那样支持静态方法的概念。相反，我们必须使用一个 link:https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects[companion object（同伴对象）] ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols,
setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files
for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.
This source cache is useful for native debugging tools,
to establish the link between the symbols and matching source code.
It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了调试符号外，设置 `-Dquarkus.native.debug.enabled=true` 标志会生成一个源文件缓存，用于生成原生可执行文件时解决的任何JDK运行时类、GraalVM类和应用程序类。这个源码缓存对原生调试工具很有用，可以在符号和匹配的源代码之间建立联系。在调试本原生执行文件时，它提供了一种方便的方法，使调试器/IDE仅能获得必要的源文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols, setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.  This source cache is useful for native debugging tools, to establish the link between the symbols and matching source code.  It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了调试符号外，设置 `-Dquarkus.native.debug.enabled=true` 标志会生成一个源文件缓存，用于生成原生可执行文件时解决的任何JDK运行时类、GraalVM类和应用程序类。这个源码缓存对原生调试工具很有用，可以在符号和匹配的源代码之间建立联系。在调试本原生执行文件时，它提供了一种方便的方法，使调试器/IDE仅能获得必要的源文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow with the &lt;code&gt;quarkus&lt;/code&gt; tag&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow的&lt;code&gt;quarkus&lt;/code&gt;标签&lt;/a&gt;下提问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask your questions on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow&lt;/a&gt;. After the documentation, it’s probably the best place to look for answers. We actively monitor the &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Quarkus tag&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow&lt;/a&gt;上提出您的问题。在文档化之后，它可能是寻找答案的最佳地方。我们积极跟踪&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Quarkus标签&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assuming `/tmp/` is writable this can be fixed by setting the `vertx.cacheDirBase` property to point to a directory in `/tmp/` for instance in OpenShift by creating an environment variable `JAVA_OPTS` with the value `-Dvertx.cacheDirBase=/tmp/vertx`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>假设 `/tmp/` 是可写的，可以通过将 `vertx.cacheDirBase` 属性设置为指向 `/tmp/` 中的目录来修复此问题，例如在OpenShift中，通过创建一个值为 `-Dvertx.cacheDirBase=/tmp/vertx` ,名为 `JAVA_OPTS` 的环境变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>异步处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that point you should have the following structure:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此时，你应该有如下的结构：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这一点上，如果你是RxJava或Reactor的用户，你可能想知道如何使用你熟悉的 `Flowable`，`Single`，`Flux`，`Mono`… Mutiny允许从 `Unis` 和 `Multis` 到RX Java和Reactor类型的转换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment, when JSON-B or Jackson tries to get the list of fields of a class, if the class is not registered for reflection, no exception will be thrown.
GraalVM will simply return an empty list of fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目前，当JSON-B或Jackson尝试获取一个类的字段列表时，如果该类没有注册反射，则不会抛出异常。GraalVM将简单地返回一个空的字段列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment, when JSON-B or Jackson tries to get the list of fields of a class, if the class is not registered for reflection, no exception will be thrown.  GraalVM will simply return an empty list of fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目前，当JSON-B或Jackson尝试获取一个类的字段列表时，如果该类没有注册反射，则不会抛出异常。GraalVM将简单地返回一个空的字段列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute (_alias_)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性 _（别名）_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute values are resolved as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性值的解决方式如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Auth Type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>认证类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authentication with OAuth</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用OAuth进行认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization Code Flow authentication mechanis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Authorization Code Flow 认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization is based on user roles that are provided by the security provider.
To customize these roles, a `SecurityIdentityAugmentor` can be created, see
xref:security-customization.adoc#security-identity-customization[Security Identity Customization].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>授权是基于security provider所提供的用户角色来进行的。为了自定义这些角色，可以创建一个 `SecurityIdentityAugmentor` 。请参考 xref:security-customization.adoc#security-identity-customization[Security Identity Customization].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization is based on user roles that are provided by the security provider.  To customize these roles, a `SecurityIdentityAugmentor` can be created, see xref:security-customization.adoc#security-identity-customization[Security Identity Customization].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>授权是基于security provider所提供的用户角色来进行的。为了自定义这些角色，可以创建一个 `SecurityIdentityAugmentor` 。请参考 xref:security-customization.adoc#security-identity-customization[Security Identity Customization].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization of Web Endpoints</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网络端点的授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization using Annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注解的授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization using Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用配置进行授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic Service Setup with Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用开发服务的自动服务设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic provisioning and application wiring of supporting services such as databases, identity servers, and more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持服务(如数据库、标识服务器等)的自动配置和应用程序连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatically add newline with `curl -w "\n"`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自动添加换行符 `curl -w "\n"` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Available APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可用的API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Available properties to customize the Redis DevService.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis DevService的可用配置属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Avro Serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Avro序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Await completion of the consumer task.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>等待消费者任务的完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Awards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>获奖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Awards and Recognition</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>奖项及表彰</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Event Hub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Event Hub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Event Hubs for Kafka is not available in the _basic_ tier.
You need at least the _standard_ tier to use Kafka.
See https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs Pricing] to see the other options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Event Hubs for Kafka在 _基础(basic)_ 层中不可用。您至少需要 _标准(standard)_ 层才能使用Kafka。请参阅 link:https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs定价] 查看其他选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Event Hubs for Kafka is not available in the _basic_ tier.  You need at least the _standard_ tier to use Kafka.  See https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs Pricing] to see the other options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Event Hubs for Kafka在 _基础(basic)_ 层中不可用。您至少需要 _标准(standard)_ 层才能使用Kafka。请参阅 link:https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs定价] 查看其他选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Functions (Serverless) with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x Web、Servlet或RESTEasy的Azure Functions（无服务器）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back Pressure and Credits</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>背压和信用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to our `producer` project.
Let's modify the `QuotesResource` to consume quotes, bind it to an HTTP endpoint to send events to clients:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>回到我们的 `producer` 项目。让我们修改 `QuotesResource` 来消费报价，将其绑定到一个HTTP端点，来向客户端发送事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to our `producer` project.  Let's modify the `QuotesResource` to consume quotes, bind it to an HTTP endpoint to send events to clients:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>回到我们的 `producer` 项目。让我们修改 `QuotesResource` 来消费报价，将其绑定到一个HTTP端点，来向客户端发送事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Backpressure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>背压</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base Runtime Image for Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生可执行文件的基本运行时镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form HTTP authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Basic和Form HTTP认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through First Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指导您完成第一个应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful that locks are released when the transaction ends, so the method that invokes the lock query must be annotated with the `@Transactional` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，事务结束时锁会被释放，所以调用了带锁查询的方法必须加上 `@Transactional` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful that locks are released when the transaction ends, so the method that invokes the lock query must be called within a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，事务结束时锁会被释放，所以带锁查询的方法必须在事务中调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful to use the `@Transactional` annotation on the operations that modify the database,
you can add the annotation at the class level for simplicity purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在修改数据库的操作上需要使用 `@Transactional` 注解，为了简单起见，你可以给类添加这个注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful to use the `@Transactional` annotation on the operations that modify the database, you can add the annotation at the class level for simplicity purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在修改数据库的操作上需要使用 `@Transactional` 注解，为了简单起见，你可以给类添加这个注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to call your `verify` and `do*` methods on `PanacheMock` rather than `Mockito`, otherwise you won't know
what mock object to pass.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保是在 `PanacheMock` 上调用 `verify` 和 `do*` 方法，而不是在 `Mockito` 上调用，否则无法传递mock对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to call your `verify` and `do*` methods on `PanacheMock` rather than `Mockito`, otherwise you won't know what mock object to pass.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保是在 `PanacheMock` 上调用 `verify` 和 `do*` 方法，而不是在 `Mockito` 上调用，否则无法传递mock对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to call your `verify` methods on `PanacheMock` rather than `Mockito`, otherwise you won't know
what mock object to pass.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保在 `PanacheMock` 而不是 `Mockito` 上调用你的 `verify` 方法，否则你将不知道要传递什么模拟对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to call your `verify` methods on `PanacheMock` rather than `Mockito`, otherwise you won't know what mock object to pass.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保在 `PanacheMock` 而不是 `Mockito` 上调用你的 `verify` 方法，否则你将不知道要传递什么模拟对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to read the xref:cdi-reference.adoc#bean_discovery[Bean Discovery] section of the CDI guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请务必阅读CDI指南中的 link:cdi-reference.html#bean_discovery[Bean发现] 部分以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bearer Token authentication mechanis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bearertoken认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为Quarkus使用I/O线程来调用代码，所以我们节省了上下文切换，避免了大型线程池管理，从而提高了资源利用率。但是，代码必须 **NOT** 阻塞该线程。为什么？因为，I/O线程用于处理多个并发请求。一旦一个请求的处理因为需要执行一些I/O而无法进行，它就会调度这些I/O，并传递一个延续。它释放可以处理另一个请求的线程。当计划的I/O完成时，继续执行，返回到I/O线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Smallrye Reactive Messaging framework supports different messaging backends like Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为Smallrye Reactive Messaging框架支持不同的消息后端，如Apache Kafka，AMQP，Apache Camel，JMS以及MQTT等，所以它使用了一个通用的术语表：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because `GreetingResource` is annotated with `@Path("/hello")` the injected URL
will end with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为 `GreetingResource` 用到了注解 `@Path("/hello")` ，注入的URL会以 `/hello` 结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because `GreetingResource` is annotated with `@Path("/hello")` the injected URL will end with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为 `GreetingResource` 用到了注解 `@Path("/hello")` ，注入的URL会以 `/hello` 结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of the additional class, our property names have changed.
Let's update the properties file and the `GreetingResource` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为有了额外的类，我们的属性名也发生了改变。让我们更新一下属性配置文件和 `GreetingResource` 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of the additional class, our property names have changed.  Let's update the properties file and the `GreetingResource` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为有了额外的类，我们的属性名也发生了改变。让我们更新一下属性配置文件和 `GreetingResource` 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of this, in the case of Maven, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support JUnit 5:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正因为如此，就Maven而言，必须设置 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] 的版本，因为默认版本不支持JUnit 5：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because starting a Kafka broker can be long, Dev Services for Kafka uses https://vectorized.io/redpanda[Redpanda], a Kafka compatible broker which starts in ~1 second.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为启动Kafka broker的时间可能很长，所以Kafka开发服务使用了 link:https://vectorized.io/redpanda[Redpanda] ，这是一个与Kafka兼容的broker，而且启动时间仅为1秒左右。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because the interaction with the database is non-blocking and asynchronous, we need to use asynchronous constructs to implement our HTTP resource.
Quarkus uses Mutiny as its central reactive programming model.
So, it supports returning Mutiny types (`Uni` and `Multi`) from HTTP endpoints.
Also, our Fruit Panache entity exposes methods using these types, so we only need to implement the _glue_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于与数据库的交互是非阻塞的和异步的，我们需要使用异步构造来实现我们的HTTP资源。Quarkus使用Mutiny作为其核心响应式编程模型。因此，它支持从HTTP端点返回Mutiny类型 (`Uni` and `Multi`) 。此外，水果Panache实例使用这些类型公开方法，因此我们只需要实现 _glue_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because the interaction with the database is non-blocking and asynchronous, we need to use asynchronous constructs to implement our HTTP resource.  Quarkus uses Mutiny as its central reactive programming model.  So, it supports returning Mutiny types (`Uni` and `Multi`) from HTTP endpoints.  Also, our Fruit Panache entity exposes methods using these types, so we only need to implement the _glue_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于与数据库的交互是非阻塞的和异步的，我们需要使用异步构造来实现我们的HTTP资源。Quarkus使用Mutiny作为其核心响应式编程模型。因此，它支持从HTTP端点返回Mutiny类型 (`Uni` and `Multi`) 。此外，水果Panache实例使用这些类型公开方法，因此我们只需要实现 _glue_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin]
must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为我们使用的是JUnit 5，所以必须设置 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven插件] 的版本，因为默认版本不支持Junit 5：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为我们使用的是JUnit 5，所以必须设置 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven插件] 的版本，因为默认版本不支持Junit 5：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we want to consume messages from the `quotes-requests` queue into the `requests` channel, we need to configure this association.
Open the `src/main/resources/application.properties` file and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为我们想把 `quotes-requests` 队列中的消息消费到 `requests` 通道中，因此我们需要配置这个关联。请打开 `src/main/resources/application.properties` 文件并添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we want to consume messages from the `quotes-requests` queue into the `requests` channel, we need to configure this association.  Open the `src/main/resources/application.properties` file and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为我们想把 `quotes-requests` 队列中的消息消费到 `requests` 通道中，因此我们需要配置这个关联。请打开 `src/main/resources/application.properties` 文件并添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we write to a database, we must run this method in a transaction.
Yet, sending the entity to Kafka happens asynchronously.
The operation returns a `CompletionStage` (or a `Uni` if you use a `MutinyEmitter`) reporting when the operation completes.
We must be sure that the transaction is still running until the object is written.
Otherwise, you may access the object outside the transaction, which is not allowed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为我们要往数据库写入数据，所以我们必须在事务中运行该方法。然而，向Kafka发送消息是异步的。该操作完成后会返回一个 `CompletionStage` (如果您使用 `MutinyEmitter`，则返回 `Uni`)。我们必须确认在对象被写入之前事务仍然在运行。否则，您可能会在事务之外访问到该对象，而这是不允许的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we write to a database, we must run this method in a transaction.  Yet, sending the entity to Kafka happens asynchronously.  The operation returns a `CompletionStage` (or a `Uni` if you use a `MutinyEmitter`) reporting when the operation completes.  We must be sure that the transaction is still running until the object is written.  Otherwise, you may access the object outside the transaction, which is not allowed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为我们要往数据库写入数据，所以我们必须在事务中运行该方法。然而，向Kafka发送消息是异步的。该操作完成后会返回一个 `CompletionStage` (如果您使用 `MutinyEmitter`，则返回 `Uni`)。我们必须确认在对象被写入之前事务仍然在运行。否则，您可能会在事务之外访问到该对象，而这是不允许的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker
on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在进一步行动之前，请确保有一个工作的容器运行环境（Docker或podman）。如果你在Windows上使用Docker，你应该在Docker Desktop文件共享设置中共享你的项目的驱动器，并重新启动Docker Desktop。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在进一步行动之前，请确保有一个工作的容器运行环境（Docker或podman）。如果你在Windows上使用Docker，你应该在Docker Desktop文件共享设置中共享你的项目的驱动器，并重新启动Docker Desktop。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, open the `src/main/resource/application.properties` file and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在继续之前，打开 `src/main/resource/application.properties` 文件并添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, open the `src/main/resources/application.properties` file and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在进行下一步之前，请打开 `src/main/resource/application.properties` 文件并添加下面这一段内容到该文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory and as we plan to build inside a container we need to be able to copy the `src` directory. So edit your `.dockerignore` and remove or comment its content.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在启动我们的Docker构建之前，我们需要更新默认的 `.dockerignore` 文件，因为它过滤了除 `target` 目录之外的所有内容，而我们计划在容器中构建时，我们需要能够复制 `src` 目录。所以编辑你的 `.dockerignore` 并删除或注释其内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory. As we plan to build inside a container, we need to copy the `src` directory. Thus, edit your `.dockerignore` and update the content.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在启动我们的Docker构建之前，我们需要更新默认的 `.dockerignore` 文件，因为它过滤了除 `target` 目录之外的所有内容。由于我们计划在容器内构建，我们需要复制 `src` 目录。因此，编辑你的 `.dockerignore` ，并更新内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running the application, don't forget to stop the hot reload mode (hit `CTRL+C`), or you will have a port conflict.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在运行应用程序之前，不要忘记停止热重载模式（使用 `CTRL+C` ），否则你会有一个端口冲突。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you start building security into your Quarkus applications, review the overview information to learn about the Quarkus Security architecture and the different authentication and authorization mechanisms that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在您开始在您的Quarkus应用程序中建立安全机制之前，请回顾一下概述信息，了解Quarkus Security架构以及Quarkus支持的不同认证和授权机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being _stable_, backward compatibility and presence in the ecosystem are taken very seriously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_stable(稳定)_ 版本，确保向后兼容和生态系统的持续性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below is a list of articles, blogs, podcast and other tidbits published online around {project-name}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是网上发布的文章、博客、播客和其他趣闻 {project-name}。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below, you can see how the container images created above can be built and deployed to AWS using the `docker` and `aws` command line tools. These instructions work for both native and jvm container images and assume that the `aws` command line tool has been logged in.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面，你可以看到如何使用 `docker` 和 `aws` 命令行工具将上面创建的容器镜像构建并部署到AWS中。这些指令对原生和jvm容器镜像都适用，并假设已经登录到 `aws` 命令行工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Best of Breed Libraries and Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最好的类库和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond simply working, we’re aiming for Joy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了工作，我们的目标是充满乐趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bi-directional communication with browsers using SockJS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用SockJS与浏览器进行双向通信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blocking processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>阻塞处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>博客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Books</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>书籍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boom! Your Quarkus app is now running at &lt;code&gt;localhost:8080&lt;/code&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当当当！您的Quarkus应用已经在&lt;code&gt;localhost:8080&lt;/code&gt;运行了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping a reactive CRUD application with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Quarkus 引导响应式 CRUD 应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the Reactive Fruits application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动响应式水果应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引导启动该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding
a path. This currently supports both JAX-RS endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints
a given test is testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTassured和 `@TestHTTPResource` 都允许您指定要测试的节点类，而不是对路径硬编码。这目前支持JAX-RS节点、Servlets和Reactive Routes。这使您更容易查看给定的测试用例到底在测试哪些节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding a path. This currently supports both JAX-RS endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints a given test is testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTassured和 `@TestHTTPResource` 都允许您指定要测试的节点类，而不是对路径硬编码。这目前支持JAX-RS节点、Servlets和Reactive Routes。这使您更容易查看给定的测试用例到底在测试哪些节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Uni` 和 `Multi` 都公开了事件驱动的API：你表达了在给定事件上你想做什么(成功，失败等)。这些API被分成组（操作类型），以使其更具表达性，并避免将100个方法附加到单个类上。主要的操作类型是对失败、完成、操作项、提取或收集它们作出反应。它提供了一种流畅的编码体验，具有可导航的API，并且结果不需要太多关于响应式的知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `findByNameWithPanacheQLQuery()` and `findByNameWithNativeQuery()` methods will return the same result but query written in PanacheQL
will use the entity field name: `name`, and native query will use the MongoDB field name: `lastname`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`findByNameWithPanacheQLQuery()` 和 `findByNameWithNativeQuery()` 方法都将返回相同的结果，但用PanacheQL编写的查询将使用实体字段名： `name` ，而原生查询将使用MongoDB字段名： `lastname` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `findByNameWithPanacheQLQuery()` and `findByNameWithNativeQuery()` methods will return the same result but query written in PanacheQL will use the entity field name: `name`, and native query will use the MongoDB field name: `lastname`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`findByNameWithPanacheQLQuery()` 和 `findByNameWithNativeQuery()` 方法都将返回相同的结果，但用PanacheQL编写的查询将使用实体字段名： `name` ，而原生查询将使用MongoDB字段名： `lastname` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both configuration properties support glob patterns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这两个配置属性都支持glob模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both timers and distribution summaries can be configured to emit additional statistics, like histogram data,
precomputed percentiles, or service level objective (SLO) boundaries. Note that the count, sum, and histogram data
can be re-aggregated across dimensions (or across a series of instances), while precomputed percentile values cannot.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Timers和distritution summaries都可以被配置为发送额外的统计数据，如hitogram数据、预计算的百分位数或service level object（SLO）的边界值。请注意，计数、总和和histogram数据可以跨维度（或跨一系列实例）重新汇总，而预计算的百分数则不能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both timers and distribution summaries can be configured to emit additional statistics, like histogram data, precomputed percentiles, or service level objective (SLO) boundaries. Note that the count, sum, and histogram data can be re-aggregated across dimensions (or across a series of instances), while precomputed percentile values cannot.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Timers和distritution summaries都可以被配置为发送额外的统计数据，如hitogram数据、预计算的百分位数或service level object（SLO）的边界值。请注意，计数、总和和histogram数据可以跨维度（或跨一系列实例）重新汇总，而预计算的百分数则不能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这两种类型都是惰性的，并且遵循订阅模式。计算只在有实际需要时才开始（即订阅者登记）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Broadcasting messages on multiple consumers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对多个消费者广播信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Browse through these selections of new Quarkus related books and resources to expand your knowledge and hone your coding skills to step up your Quarkus game.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览这些与Quarkus相关的新书籍和资源，扩展您的知识，磨练您的编码技能，从而提升您的Quarkus游戏水平。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Container Images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建容器镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Items</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建时处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建和部署</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build fully static native executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建纯静态原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build native executables with GraalVM or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用GraalVM或Mandrel构建原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the Docker image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建Docker镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the site and make it available on a local server
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建站点并使其在本地服务器上可用
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build, Sign and Encrypt JSON Web Tokens (JWT)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立、签署和加密JSON网络令牌(JWT)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Applications with Gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Gradle构建应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Applications with Maven</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Maven构建应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building My First Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建我的第一个扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个本地可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.
There are three distributions:
Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.
The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个原生可执行文件需要使用GraalVM的发行版。有三个发行版：Oracle GraalVM社区版（CE）、Oracle GraalVM企业版（EE）和Mandrel。Oracle和Mandrel发行版之间的区别如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.  There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.  The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个原生可执行文件需要使用GraalVM的发行版。有三个发行版：Oracle GraalVM社区版（CE）、Oracle GraalVM企业版（EE）和Mandrel。Oracle和Mandrel发行版之间的区别如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.
This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于 `InjectMock` 所提供的功能，Quarkus还允许用户很容易利用 link:https://site.mockito.org/[Mockito] 来对 `QuarkusMock` 所支持的bean进行spy操作。这个功能可以通过 `@io.quarkus.test.junit.mockito.InjectSpy` 注解来实现，该注解通过 `quarkus-junit5-mockito` 依赖导入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于 `InjectMock` 所提供的功能，Quarkus还允许用户很容易利用 link:https://site.mockito.org/[Mockito] 来对 `QuarkusMock` 所支持的bean进行spy操作。这个功能可以通过 `@io.quarkus.test.junit.mockito.InjectSpy` 注解来实现，该注解通过 `quarkus-junit5-mockito` 依赖导入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.
This functionality is available via the `@io.quarkus.test.junit.mockito.InjectMock` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于 `QuarkusMock` 所提供的功能，Quarkus还允许用户很容易地利用 link:https://site.mockito.org/[Mockito] 来mock `QuarkusMock` 所支持的bean。该功能可以通过 `@io.quarkus.test.junit.mockito.InjectMock` 注解来实现，该注解可以通过添加 `quarkus-junit5-mockito` 依赖而导入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectMock` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于 `QuarkusMock` 所提供的功能，Quarkus还允许用户很容易地利用 link:https://site.mockito.org/[Mockito] 来mock `QuarkusMock` 所支持的bean。该功能可以通过 `@io.quarkus.test.junit.mockito.InjectMock` 注解来实现，该注解可以通过添加 `quarkus-junit5-mockito` 依赖而导入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building with Mandrel requires a custom builder image parameter to be passed additionally:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Mandrel构建需要额外传递一个自定义的构建器镜像参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建并返回一个 `Map` ，包含配置应用程序使用内存 channels 所需的所有属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-In Authentication Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内置的认证支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-in Quarkus features available in Eclipse Che incl. che.openshift.io.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse Che内置的Quarkus功能支持，包括che.openshift.io。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-in Quarkus features available only in IntelliJ IDEA Ultimate</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IntelliJ IDEA Ultimate独享的内置Quarkus支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business Automation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>业务自动化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But enough talking, let's get our hands dirty!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>说得够多了，我们动手吧！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But if you already have all the required `quarkus-oidc` properties configured then you only need to associate `quarkus.oidc.auth-server-url` with the `prod` profile for `Dev Services for Keycloak`to start a container, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是如果你已经配置了所需的 `quarkus-oidc` 属性，那么你只需要将 `quarkus.oidc.auth-server-url` 与 `Keycloak开发服务` 的 `prod` 配置文件联系起来，以启动一个容器，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But these methods also accept an optional `Sort` parameter, which allows your to abstract your sorting:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些方法也可以接收一个 `Sort` 参数，它是对排序的抽象封装：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But this type of class comes with some limitations: all fields needs to be initialized at construction time or be marked as nullable,
and the generated constructor needs to have as parameters all the fields of the data class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是这种类型的类有一些限制：所有的字段都需要在构造时被初始化或者被标记为nullable（可空），而且生成的构造函数需要有数据类的所有字段作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But this type of class comes with some limitations: all fields needs to be initialized at construction time or be marked as nullable, and the generated constructor needs to have as parameters all the fields of the data class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是这种类型的类有一些限制：所有的字段都需要在构造时被初始化或者被标记为nullable（可空），而且生成的构造函数需要有数据类的所有字段作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you may be wondering where the URL is configured as it’s not in the code. Remember, it must not be hard-coded because the URL likely depends on the environment. The URL is configured in the application configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但你可能想知道URL是在哪里配置的，因为它不在代码中。记住，它不能是硬编码的，因为URL很可能取决于环境。URL是在应用程序配置中设置的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，如果HTTP请求的目标是一个响应式方法（JAX-RS使用RESTEasy响应式，响应式路由， `@Incoming` 方法没有注释 `@Blocking`…），路由层会在I/O线程上调用路由，这会带来很多好处，比如更高的并发性和性能：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, there is a catch.
We need a way to write continuation-passing code.
There are many ways of doing this.
In Quarkus, we propose:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，有一个问题。我们需要一种方法来编写延续传递代码。有很多方法可以做到这一点。在Quarkus，我们提出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, there is a catch.  We need a way to write continuation-passing code.  There are many ways of doing this.  In Quarkus, we propose:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，有一个问题。我们需要一种方法来编写延续传递代码。有很多方法可以做到这一点。在Quarkus，我们提出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，Vert.x呢？Vert.x API也可以使用Mutiny类型。下面的代码片段展示了Vert.x Web 客户端的用法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about streams? Generating a &lt;em&gt;server-sent event&lt;/em&gt; response with Quarkus is just as simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>还有，事件流怎么处理？用Quarkus生成一个&lt;em&gt;server-sent 事件&lt;/em&gt;响应也同样简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus automatically detects the container runtime.
If you want to explicitely select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在默认情况下，Quarkus会自动检测容器的运行时。如果你想明确地选择容器的运行时，你可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus automatically detects the container runtime.  If you want to explicitely select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在默认情况下，Quarkus会自动检测容器的运行时。如果你想明确地选择容器的运行时，你可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus will restrict the use of JNDI within an application, as a precaution to try and mitigate any future vulnerabilities similar to log4shell.
Because the `mongo+srv` protocol often used to connect to MongoDB requires JNDI, this protection is automatically disabled when using the MongoDB client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会限制在应用程序中使用JNDI，作为一种预防措施，以尝试缓解所有将来类似于 log4shell 的漏洞。因为通常用于连接MongoDB的 `mongo+srv` 协议需要JNDI，所以在使用MongoDB客户端扩展时，这种保护会自动关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`,
by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.
Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，当Quarkus应用程序启动时（在常规或开发模式下），它将显示一个ASCII。通过在 `application.properties` 中设置 `quarkus.banner.enabled=false` ，通过设置 `-Dquarkus.banner.enabled=false` Java系统属性，或者通过将 `QUARKUS_BANNER_ENABLED` 环境变量设置为 `false` ，可以禁用该横幅。此外，用户可以通过将横幅文件放在 `src/main/resources` ，并在 `application.properties` 中配置 `quarkus.banner.path=name-of-file` ，从而提供一个自定义的横幅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，当Quarkus应用程序启动时（在常规或开发模式下），它将显示一个ASCII。通过在 `application.properties` 中设置 `quarkus.banner.enabled=false` ，通过设置 `-Dquarkus.banner.enabled=false` Java系统属性，或者通过将 `QUARKUS_BANNER_ENABLED` 环境变量设置为 `false` ，可以禁用该横幅。此外，用户可以通过将横幅文件放在 `src/main/resources` ，并在 `application.properties` 中配置 `quarkus.banner.path=name-of-file` ，从而提供一个自定义的横幅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for AMQP picks a random port and configures the application.
You can set the port by configuring the `quarkus.amqp.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，AMQP的开发服务会选择一个随机端口，并配置应用程序。您可以通过配置 `quarkus.amqp.devservices.port` 属性来设置端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for AMQP picks a random port and configures the application.  You can set the port by configuring the `quarkus.amqp.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，AMQP的开发服务会选择一个随机端口，并配置应用程序。您可以通过配置 `quarkus.amqp.devservices.port` 属性来设置端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Apicurio Registry picks a random port and configures the application.
You can set the port by configuring the `quarkus.apicurio-registry.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Apicurio注册表的开发服务会选择一个随机端口，并配置应用程序。你可以通过配置 `quarkus.apicurio-registry.devservices.port` 属性来设置端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Apicurio Registry picks a random port and configures the application.  You can set the port by configuring the `quarkus.apicurio-registry.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Apicurio注册表的开发服务会选择一个随机端口，并配置应用程序。你可以通过配置 `quarkus.apicurio-registry.devservices.port` 属性来设置端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Kafka picks a random port and configures the application.
You can set the port by configuring the `quarkus.kafka.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Kafka开发服务会随机挑选一个端口并配置应用程序。您可以通过配置 `quarkus.kafka.devservices.port` 属性来设置端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Kafka picks a random port and configures the application.  You can set the port by configuring the `quarkus.kafka.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Kafka开发服务会随机挑选一个端口并配置应用程序。您可以通过配置 `quarkus.kafka.devservices.port` 属性来设置端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus automatically detects the container runtime.
If you want to explicitly select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会自动检测容器的运行时。如果你想显式指定择容器的运行时，你可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus automatically detects the container runtime.  If you want to explicitly select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会自动检测容器的运行时。如果你想显式指定择容器的运行时，你可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus does proactive authentication, which means that all incoming requests with credentials are authenticated regardless of whether the target page requires authentication.
For more information, see xref:security-built-in-authentication.adoc#proactive-authentication[Proactive authentication].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会进行我们所说的主动认证。这意味着所有包含证书的请求将总是被认证，而不论目标页面是否需要认证。更多信息见 link:security-built-in-authentication.html#proactive-authentication[主动认证] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus does proactive authentication, which means that all incoming requests with credentials are authenticated regardless of whether the target page requires authentication.  For more information, see xref:security-built-in-authentication.adoc#proactive-authentication[Proactive authentication].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会进行我们所说的主动认证。这意味着所有包含证书的请求将总是被认证，而不论目标页面是否需要认证。更多信息见 link:security-built-in-authentication.html#proactive-authentication[主动认证] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus initializes all classes at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus在构建时初始化所有类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This
duration can be changed using the `quarkus.test.wait-time` system property. For example, to increase the duration
to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会等待60秒的时间来启动原生镜像，然后本地测试自动失败。这个持续时间可以使用 `quarkus.test.wait-time` 系统属性来改变。例如，要增加持续时间到300秒，使用： `./mvnw verify -Pnative -Dquarkus.test.wait-time=300` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会等待60秒，等待原生镜像启动，然后原生测试自动失败。这个持续时间可以通过 `quarkus.test.native-image-wait-time` 系统属性来改变。例如，要将持续时间增加到300秒，可以使用： `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会等待60秒的时间来启动原生镜像，如果超时则本地测试自动失败。这个持续时间可以使用 `quarkus.test.wait-time` 系统属性来改变。例如，要增加持续时间到300秒，使用： `./mvnw verify -Pnative -Dquarkus.test.wait-time=300` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `KeycloakTestResourceLifecycleManager` uses HTTPS to initialize a Keycloak instance which can be disabled with `keycloak.use.https=false`.
Default realm name is `quarkus` and client id - `quarkus-service-app` - set `keycloak.realm` and `keycloak.service.client` system properties to customize the values if needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `KeycloakTestResourceLifecycleManager` 使用HTTPS来初始化Keycloak实例，可以用 `keycloak.use.https=false` 来禁用。默认的领域(realm)名称是 `quarkus` ，客户端ID - `quarkus-service-app` - 如果需要，可以设置 `keycloak.realm` 和 `keycloak.service.client` 系统属性来定制数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `KeycloakTestResourceLifecycleManager` uses HTTPS to initialize a Keycloak instance which can be disabled with `keycloak.use.https=false`.  Default realm name is `quarkus` and client id - `quarkus-service-app` - set `keycloak.realm` and `keycloak.service.client` system properties to customize the values if needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `KeycloakTestResourceLifecycleManager` 使用HTTPS来初始化Keycloak实例，可以用 `keycloak.use.https=false` 来禁用。默认的领域(realm)名称是 `quarkus` ，客户端ID - `quarkus-service-app` - 如果需要，可以设置 `keycloak.realm` 和 `keycloak.service.client` 系统属性来定制数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `quarkus.http.root-path` is prepended automatically to configured permission paths then do not use a forward slash, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `quarkus.http.root-path` 会自动被加在配置的权限路径之前并且不需要指定一个前置的斜杠，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a channel can be linked to a single consumer, using `@Incoming` method or `@Channel` reactive stream.
At application startup, channels are verified to form a chain of consumers and producers with single consumer and producer.
You can override this behavior by setting `mp.messaging.$channel.broadcast=true` on a channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，一个channel可以关联到一个单一的消费者上，通过使用 `@Incoming` 方法或 `@Channel` 响应式应式流。在程序启动时，channels 会被验证，以形成一个由单个消费者和生产者组成的消费者和生产者链。您可以通过在channel上设置 `mp.messaging.$channel.broadcast=true` 来覆盖这种行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a channel can be linked to a single consumer, using `@Incoming` method or `@Channel` reactive stream.  At application startup, channels are verified to form a chain of consumers and producers with single consumer and producer.  You can override this behavior by setting `mp.messaging.$channel.broadcast=true` on a channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，一个channel可以关联到一个单一的消费者上，通过使用 `@Incoming` 方法或 `@Channel` 响应式应式流。在程序启动时，channels 会被验证，以形成一个由单个消费者和生产者组成的消费者和生产者链。您可以通过在channel上设置 `mp.messaging.$channel.broadcast=true` 来覆盖这种行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, applications using the `quarkus-oidc` extension are marked as a `service` type application (see `quarkus.oidc.application-type`). This extension also supports only  `web-app` type applications but only if the access token returned as part of the authorization code grant response is marked as a source of roles: `quarkus.oidc.roles.source=accesstoken` (`web-app` type applications check ID token roles by default).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，使用 `quarkus-oidc` 扩展的应用程序被标记为 `service` 类型的应用程序（见 `quarkus.oidc.application-type` ）。这个扩展也仅支持 `web-app` 类型的应用程序且只有当作为授权码授予响应的一部分而返回的访问token被标记为角色的来源时可行： `quarkus.oidc.roles.source=accesstoken` （ `web-app` 类型的应用程序会默认检查ID token角色）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, applications using the `quarkus-oidc` extension are marked as a `service` type application (see `quarkus.oidc.application-type`). This extension also supports only `web-app` type applications but only if the access token returned as part of the authorization code grant response is marked as a source of roles: `quarkus.oidc.roles.source=accesstoken` (`web-app` type applications check ID token roles by default).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，使用 `quarkus-oidc` 扩展的应用程序被标记为 `service` 类型的应用程序（见 `quarkus.oidc.application-type` ）。这个扩展也仅支持 `web-app` 类型的应用程序且只有当作为授权码授予响应的一部分而返回的访问token被标记为角色的来源时可行： `quarkus.oidc.roles.source=accesstoken` （ `web-app` 类型的应用程序会默认检查ID token角色）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, incoming methods receive each Kafka record individually.
Under the hood, Kafka consumer clients poll the broker constantly and receive records in batches, presented inside the `ConsumerRecords` container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，接收方法会单独接收每条Kafka记录。在后台，Kafka消费者client会不断地轮询broker，并批量接收记录然后放入 `ConsumerRecords` 容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, incoming methods receive each Kafka record individually.  Under the hood, Kafka consumer clients poll the broker constantly and receive records in batches, presented inside the `ConsumerRecords` container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，接收方法会单独接收每条Kafka记录。在后台，Kafka消费者client会不断地轮询broker，并批量接收记录然后放入 `ConsumerRecords` 容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, integration tests both *build* and *run* the native executable using the `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集成测试默认使用  `prod` 的配置（profile） *构建* 并 *运行* 原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, native tests runs using the `prod` profile.
This can be overridden using the `quarkus.test.native-image-profile` property.
For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.
Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.
However, don't forget that when the native executable is built the `prod` profile is enabled.
So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，原生测试使用 `prod` 配置文件运行。这可以用 `quarkus.test.native-image-profile` 属性来覆盖。例如，在你的 `application.properties` 文件中，添加： `quarkus.test.native-image-profile=test` 。或者，你可以用以下方式运行你的测试。 `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` 。然而，不要忘记当原生可执行文件被构建时， `prod` 配置文件被启用。因此，你通过这种方式启用的配置文件必须与生成的可执行文件兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, native tests runs using the `prod` profile.  This can be overridden using the `quarkus.test.native-image-profile` property.  For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.  Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  However, don't forget that when the native executable is built the `prod` profile is enabled.  So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，原生测试使用 `prod` 配置文件运行。这可以用 `quarkus.test.native-image-profile` 属性来覆盖。例如，在你的 `application.properties` 文件中，添加： `quarkus.test.native-image-profile=test` 。或者，你可以用以下方式运行你的测试。 `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` 。然而，不要忘记当原生可执行文件被构建时， `prod` 配置文件被启用。因此，你通过这种方式启用的配置文件必须与生成的可执行文件兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests should just work with xref:dev-services.adoc[Dev Services], however from some use cases you may need access to
the automatically configured properties in your tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，测试应该只与 link:dev-services.html[开发服务] 一起工作，然而在一些用例中，您可能需要访问测试中自动配置的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests should just work with xref:dev-services.adoc[Dev Services], however from some use cases you may need access to the automatically configured properties in your tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，测试应该只与 link:dev-services.html[开发服务] 一起工作，然而在一些用例中，您可能需要访问测试中自动配置的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests will run on port `8081` so as not to conflict with the running application. We automatically
configure RestAssured to use this port. If you want to use a different client you should use the `@TestHTTPResource`
annotation to directly inject the URL of the tested application into a field on the test class. This field can be of the type
`String`, `URL` or `URI`. This annotation can also be given a value for the test path. For example, if I want to test
a Servlet mapped to `/myservlet` I would just add the following to my test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，测试将在端口 `8081` 上运行，以便不与正在运行的应用程序冲突。我们自动将RestAssured配置为使用该端口。如果你想使用不同的客户端，你应该使用 `@TestHTTPResource` 注释，直接将测试应用程序的URL注入到测试类的一个字段中。这个字段的类型可以是 `String` , `URL` 或 `URI` 。这个注解也可以给测试路径一个值。例如，如果我想测试一个映射到 `/myservlet` 的Servlet，只需在测试中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests will run on port `8081` so as not to conflict with the running application. We automatically configure RestAssured to use this port. If you want to use a different client you should use the `@TestHTTPResource` annotation to directly inject the URL of the tested application into a field on the test class. This field can be of the type `String`, `URL` or `URI`. This annotation can also be given a value for the test path. For example, if I want to test a Servlet mapped to `/myservlet` I would just add the following to my test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，测试将在端口 `8081` 上运行，以便不与正在运行的应用程序冲突。我们自动将RestAssured配置为使用该端口。如果你想使用不同的客户端，你应该使用 `@TestHTTPResource` 注释，直接将测试应用程序的URL注入到测试类的一个字段中。这个字段的类型可以是 `String` , `URL` 或 `URI` 。这个注解也可以给测试路径一个值。例如，如果我想测试一个映射到 `/myservlet` 的Servlet，只需在测试中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the OpenTelemetry extension enables the https://www.w3.org/TR/trace-context/[W3C Trace Context] and the https://www.w3.org/TR/baggage/[W3C Baggage]
propagators, you can however choose any of the supported OpenTelemetry propagators by setting the `propagators` config that is described in the &lt;&lt;configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，OpenTelemetry扩展启用了 link:https://www.w3.org/TR/trace-context/[W3C Trace Context] 和 link:https://www.w3.org/TR/baggage/[W3C Baggage] propagators，但是您可以通过设置 link:#configuration-reference[[参考配置]] 中描述的 `propagators` 配置来选择任何支持的OpenTelemetry propagators。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the OpenTelemetry extension enables the https://www.w3.org/TR/trace-context/[W3C Trace Context] and the https://www.w3.org/TR/baggage/[W3C Baggage] propagators, you can however choose any of the supported OpenTelemetry propagators by setting the `propagators` config that is described in the &lt;&lt;configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，OpenTelemetry扩展启用了 link:https://www.w3.org/TR/trace-context/[W3C Trace Context] 和 link:https://www.w3.org/TR/baggage/[W3C Baggage] propagators，但是您可以通过设置 link:#configuration-reference[[参考配置]] 中描述的 `propagators` 配置来选择任何支持的OpenTelemetry propagators。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Reactive Messaging `Message` is acknowledged when the broker acknowledged the message.
When using routers, this acknowledgement may not be enabled.
In this case, configure the `auto-acknowledgement` attribute to acknowledge the message as soon as it has been sent to the router.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，当代理确认消息时，响应式消息 `Message` 也会被确认。当使用路由器时，这种确认可能不会被启用。在这种情况下，配置 `auto-acknowledgement` 属性，以便在消息被发送到路由器后立即确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Reactive Messaging `Message` is acknowledged when the broker acknowledged the message.  When using routers, this acknowledgement may not be enabled.  In this case, configure the `auto-acknowledgement` attribute to acknowledge the message as soon as it has been sent to the router.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，当代理确认消息时，响应式消息 `Message` 也会被确认。当使用路由器时，这种确认可能不会被启用。在这种情况下，配置 `auto-acknowledgement` 属性，以便在消息被发送到路由器后立即确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Red Panda broker does not act as a transaction coordinator.
To enable transactions, set:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Red Panda broker不会作为一个事务协调器来运行。如果想启用事务，请设置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `@InjectMock` annotation can be used for any normal CDI scoped bean (e.g. `@ApplicationScoped`, `@RequestScoped`).
Mocking `@Singleton` beans can be performed by setting the `convertScopes` property to true (such as `@InjectMock(convertScopes = true`).
This will convert the `@Singleton` bean to an `@ApplicationScoped` bean for the test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `@InjectMock` 注解可用于任何正常的CDI scoped的Bean（例如 `@ApplicationScoped` , `@RequestScoped` ）。如果要mock `@Singleton` Bean则可以通过设置 `convertScopes` 属性为true来达到目的（如 `@InjectMock(convertScopes = true)` ）。这会把 `@Singleton` bean转换为 `@ApplicationScoped` bean来测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `@InjectMock` annotation can be used for any normal CDI scoped bean (e.g. `@ApplicationScoped`, `@RequestScoped`).  Mocking `@Singleton` beans can be performed by setting the `convertScopes` property to true (such as `@InjectMock(convertScopes = true`).  This will convert the `@Singleton` bean to an `@ApplicationScoped` bean for the test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `@InjectMock` 注解可用于任何正常的CDI scoped的Bean（例如 `@ApplicationScoped` , `@RequestScoped` ）。如果要mock `@Singleton` Bean则可以通过设置 `convertScopes` 属性为true来达到目的（如 `@InjectMock(convertScopes = true)` ）。这会把 `@Singleton` bean转换为 `@ApplicationScoped` bean来测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `JsonbSerializer` serializes null as the `"null"` String, this can be customized by setting the Kafka configuration
property `json.serialize.null-as-null=true` which will serialize null as `null`.
This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `JsonbSerializer` 将null序列化为 `"null"` 字符串，这可以通过设置Kafka配置属性 `json.serialize.null-as-null=true` 来将null序列化为 `null` 。这在使用压缩的topic时很方便，因为 `null` 被用作标记来表示在压缩阶段哪些消息被删除了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `JsonbSerializer` serializes null as the `"null"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `JsonbSerializer` 将null序列化为 `"null"` 字符串，这可以通过设置Kafka配置属性 `json.serialize.null-as-null=true` 来将null序列化为 `null` 。这在使用压缩的topic时很方便，因为 `null` 被用作标记来表示在压缩阶段哪些消息被删除了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `ObjectMapperSerializer` serializes null as the `"null"` String, this can be customized by setting the Kafka configuration
property `json.serialize.null-as-null=true` which will serialize null as `null`.
This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `ObjectMapperSerializer` 将null序列化为 `"null"` 字符串，这可以通过设置Kafka配置属性 `json.serialize.null-as-null=true` ，将null序列化为 `null` 。这在使用压缩的topic时很方便，因为 `null` 被用作标记来表示在压缩阶段哪些消息被删除了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `ObjectMapperSerializer` serializes null as the `"null"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `ObjectMapperSerializer` 将null序列化为 `"null"` 字符串，这可以通过设置Kafka配置属性 `json.serialize.null-as-null=true` ，将null序列化为 `null` 。这在使用压缩的topic时很方便，因为 `null` 被用作标记来表示在压缩阶段哪些消息被删除了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `iss` claim value is compared to the `issuer` property which may have been discovered in the well-known provider configuration.
But if `quarkus.oidc.token.issuer` property is set then the `iss` claim value is compared to it instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `iss` 声明的值会与 `issuer` 属性进行比较，该属性有可能会在众所周知的提供者配置中找到。但是，如果 `quarkus.oidc.token.issuer` 属性被设置，那么 `iss` 声明的值将与它进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `iss` claim value is compared to the `issuer` property which may have been discovered in the well-known provider configuration.  But if `quarkus.oidc.token.issuer` property is set then the `iss` claim value is compared to it instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `iss` 声明的值会与 `issuer` 属性进行比较，该属性有可能会在众所周知的提供者配置中找到。但是，如果 `quarkus.oidc.token.issuer` 属性被设置，那么 `iss` 声明的值将与它进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the code consuming the event must be _non-blocking_, as it's called on an I/O thread.
If your processing is blocking, use the `@io.smallrye.common.annotation.Blocking` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，消费该事件的代码必须是 _非阻塞的_ ，因为它是在一个I/O线程上调用的。如果你的处理是阻塞的，请使用 `@io.smallrye.common.annotation.Blocking` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the code consuming the event must be _non-blocking_, as it's called on an I/O thread.  If your processing is blocking, use the `@io.smallrye.common.annotation.Blocking` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，消费该事件的代码必须是 _非阻塞的_ ，因为它是在一个I/O线程上调用的。如果你的处理是阻塞的，请使用 `@io.smallrye.common.annotation.Blocking` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the connector does wait for Kafka to acknowledge the record to continue the processing (acknowledging the received Message).
You can disable this by setting the `waitForWriteCompletion` attribute to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，connector会等待Kafka确认记录以继续处理(确认收到的消息)。您可以通过将 `waitForWriteCompletion` 设置为 `false` 来禁用这个功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the connector does wait for Kafka to acknowledge the record to continue the processing (acknowledging the received Message).  You can disable this by setting the `waitForWriteCompletion` attribute to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，connector会等待Kafka确认记录以继续处理(确认收到的消息)。您可以通过将 `waitForWriteCompletion` 设置为 `false` 来禁用这个功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the extension is going to fetch resources on-demand from Keycloak where their `URI` are used to map the resources in your application that should be protected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，扩展将从Keycloak按需获取资源，而资源 `URI` 被用于映射您的应用程序中应被保护的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the topic name is same as the channel name. You can configure the topic attribute to override it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，topic名称与channel名称相同。您可以配置topic属性来覆盖它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, they are discovered by adding a `/.well-known/openid-configuration` path to the configured `quarkus.oidc.auth-server-url`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，它们是通过在配置的 `quarkus.oidc.auth-server-url` 中，添加一个 `/.well-known/openid-configuration` 路径来发现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when building a native executable, GraalVM will not include any of the resources that are on the classpath into the native executable it creates.
Resources that are meant to be part of the native executable need to be configured explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，在构建本地可执行文件时，GraalVM不会将classpath上的任何资源纳入其创建的原生可执行文件。要成为原生可执行文件一部分的资源，需要明确地进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when building a native executable, GraalVM will not include any of the resources that are on the classpath into the native executable it creates.  Resources that are meant to be part of the native executable need to be configured explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，在构建本地可执行文件时，GraalVM不会将classpath上的任何资源纳入其创建的原生可执行文件。要成为原生可执行文件一部分的资源，需要明确地进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By externalizing authorization from your application, you are allowed to protect your applications using different access control mechanisms as well as avoid re-deploying your application every time your security requirements change, where Keycloak will be acting as a centralized authorization service from where your protected resources and their associated permissions are managed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过将授权功能从您的应用程序中抽离并外部化，您可以使用不同的访问控制机制来保护您的应用程序，也可以避免在您的安全控制需求发生变化时重新部署您的应用程序。Keycloak将作为一个集中的授权服务，它允许您的受保护资源和它们的相关权限在它这里得到管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，从你的Quarkus应用程序中创建一个容器镜像的最简单方法是利用容器镜像扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By itself this will not disable the tcp socket which by default will open on
`0.0.0.0:8080`. It can be explicitly disabled:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>就其本身而言，这不会禁用默认情况下将在 0.0.0.0:8080 上打开的 tcp socket（套接字）。可以明确禁用它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By itself this will not disable the tcp socket which by default will open on `0.0.0.0:8080`. It can be explicitly disabled:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>就其本身而言，这不会禁用默认情况下将在 0.0.0.0:8080 上打开的 tcp socket（套接字）。可以明确禁用它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By simply annotating any test in the test suite with `@QuarkusTestResource`, Quarkus will run the corresponding `QuarkusTestResourceLifecycleManager` before any tests are run.
A test suite is also free to utilize multiple `@QuarkusTestResource` annotations, in which case all the corresponding `QuarkusTestResourceLifecycleManager` objects will be run before the tests. When using multiple test resources they can be started concurrently. For that you need to set `@QuarkusTestResource(parallel = true)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过简单地在测试套件中用 `@QuarkusTestResource` 注释测试，Quarkus将在测试运行之前运行相应的 `QuarkusTestResourceLifecycleManager` 。测试套件也可以自由地利用多个 `@QuarkusTestResource` 注释，从而使所有对应的 `QuarkusTestResourceLifecycleManager` 对象在测试前运行。当使用多个测试资源时，它们可以并行启动。为此，您需要设置 `@QuarkusTestResource(parallel = true)` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By simply annotating any test in the test suite with `@QuarkusTestResource`, Quarkus will run the corresponding `QuarkusTestResourceLifecycleManager` before any tests are run.  A test suite is also free to utilize multiple `@QuarkusTestResource` annotations, in which case all the corresponding `QuarkusTestResourceLifecycleManager` objects will be run before the tests. When using multiple test resources they can be started concurrently. For that you need to set `@QuarkusTestResource(parallel = true)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过简单地在测试套件中用 `@QuarkusTestResource` 注释测试，Quarkus将在测试运行之前运行相应的 `QuarkusTestResourceLifecycleManager` 。测试套件也可以自由地利用多个 `@QuarkusTestResource` 注释，从而使所有对应的 `QuarkusTestResourceLifecycleManager` 对象在测试前运行。当使用多个测试资源时，它们可以并行启动。为此，您需要设置 `@QuarkusTestResource(parallel = true)` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using a Bson `Codec`, the MongoDB Client will take care of the transformation of your domain object to/from a MongoDB `Document` automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过使用Bson `Codec` ，MongoDB 客户端将自动处理您的域对象与 MongoDB `Document` 的相互转化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过使用 `QuarkusTest` runner，你指示JUnit在测试前启动应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI @Inject with Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kotlin的CDI @Inject</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI `@Alternative` mechanism.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI `@Alternative` 机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CONFIGURATION</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CONTRIBUTORS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cache your application data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>缓存你的应用程序数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Call `native-image` with the content of file `native-image.args` as arguments. We also supply an additional argument to limit the process's maximum memory to 4 Gigabytes (this may vary depending on the project being built and the machine building it).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以文件 `native-image.args` 的内容为参数调用 `native-image` 。我们还提供了一个额外的参数，将进程的最大内存限制在4G字节（这可能取决于正在构建的项目和构建它的机器）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我可以写一个扩展吗?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Capabilities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Category</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Category: Web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类别：Web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Centralized Log Management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集中的日志管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change into the project directory:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>切换到工程目录：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the configuration file is immediately reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更改配置文件的内容将会立即得到反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the test port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>改变测试端口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Channels are connected to message backends using *connectors*. Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. Each connector is dedicated to a specific messaging technology. For example, the connector dealing with Kafka is named `smallrye-kafka`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Channels 通过 *connectors* 连接到消息后端。Connectors通过配置将传入的消息映射到一个指定channel上(该channel由应用程序来消费)，并对发送到指定channel的消息进行收集。每个connector都专用于某种特定的消息传递技术。例如，与Kafka交互的的connector被命名为 `smallrye-kafka` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chat using &lt;a href="https://quarkusio.zulipchat.com" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或在 &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream) 聊天室发问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chat using &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或在 &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream) 聊天室发问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check &lt;&lt;jackson-serialization&gt;&gt; for more detail about the usage of Jackson with Kafka.
You can also use Avro.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参看 link:#jackson-serialization[[jackson序列化]]，了解更多关于Jackson与Kafka的使用细节。您也可以使用Avro。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check &lt;&lt;jackson-serialization&gt;&gt; for more detail about the usage of Jackson with Kafka.  You can also use Avro.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参看 link:#jackson-serialization[[jackson序列化]]，了解更多关于Jackson与Kafka的使用细节。您也可以使用Avro。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out our &lt;a href="https://github.com/quarkusio/quarkus" target="_blank"&gt;GitHub&lt;/a&gt; for details on reporting issues and the process for submitting pull requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看我们的&lt;a href="https://github.com/quarkusio/quarkus" target="_blank"&gt;GitHub&lt;/a&gt;，了解有关报告问题和提交合并请求流程的详细信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out our &lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;GitHub Discussions&lt;/a&gt; collaboration area to interact with other Quarkus users and developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看我们的&lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;GitHub讨论&lt;/a&gt;协作区，与其他Quarkus用户和开发人员进行互动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out these applicable guides:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看这些适用的指南：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the HTTP response status code and content</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检查HTTP回应状态代码和内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Checking Permissions Programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以编程方式检查权限</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choose Your Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选择你的Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choosing between OpenID Connect, SmallRye JWT, and OAuth2 authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在OpenID Connect、SmallRye JWT和OAuth2扩展之间做出选择</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choosing your build tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选择您的构建工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Circuit Breaker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>熔断器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class Loading Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类加载参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on https://code.quarkus.io/?a=quarkus-getting-started-vertx&amp;nc=true&amp;e=resteasy-reactive-jackson&amp;e=vertx[this link] to configure your application.
It selected a few extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 link:https://code.quarkus.io/?a=quarkus-getting-started-vertx&amp;nc=true&amp;e=resteasy-reactive-jackson&amp;e=vertx[这个链接] 来配置你的应用程序。它选择了几个扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on https://code.quarkus.io/?a=quarkus-getting-started-vertx&amp;nc=true&amp;e=resteasy-reactive-jackson&amp;e=vertx[this link] to configure your application.  It selected a few extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 link:https://code.quarkus.io/?a=quarkus-getting-started-vertx&amp;nc=true&amp;e=resteasy-reactive-jackson&amp;e=vertx[这个链接] 来配置你的应用程序。它选择了几个扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on the `Generate your application` button, download the zip file and unzip it.
Then, open the project in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `生成你的应用程序` 按钮，下载压缩文件并解压。然后，在你喜欢的编辑器中打开该项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on the `Generate your application` button, download the zip file and unzip it.  Then, open the project in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `生成你的应用程序` 按钮，下载压缩文件并解压。然后，在你喜欢的编辑器中打开该项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an
{quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>克隆 Git 仓库: `git clone {quickstarts-clone-url}` ，或下载一个 {quickstarts-archive-url}[存档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>克隆 Git 仓库: `git clone {quickstarts-clone-url}` ，或下载一个 {quickstarts-archive-url}[存档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the git repository: `git clone {quickstarts-clone-url}`, or</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>克隆git存储库。 `git clone {quickstarts-clone-url}` ，或</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Closed-Source</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>闭源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code and Issue Tracker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码和问题跟踪</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cognito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito JWT</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cognito JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Collecting Metrics with Micrometer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Micrometer收集指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Collecting Metrics with SmallRye Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用SmallRye Metrics收集指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combine both the familiar imperative code and the reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发应用程序时，将熟悉的指令式和响应式代码风格结合起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining HTTP and the event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>结合HTTP和事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>组合认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comma separated list of the audiences that a token `aud` claim may contain.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>逗号分隔的列表，其中列出了一个令牌的 `aud` 声明可能包含的受众。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comma separated list of the audiences that a token `aud` claim may contain. This property is deprecated - use `mp.jwt.verify.audiences`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>逗号分隔的列表，列出了令牌 `aud` 声明可能包含的受众。该属性已被废弃—请使用 `mp.jwt.verify.audiences` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comma separated list of the claims that a token must contain.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个token必须包含逗号分隔的声明(claims)列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comma-separated list containing an alternative single or multiple schemes, for example, `DPoP`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>逗号分隔的列表，其中包含一个可替代的单一或多个schemes，例如， `DPoP` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令行应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Interface</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令行界面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Mode Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令模式参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command to Generate JWT</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成JWT的命令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Commands may also be stacked:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令也可以是叠加的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>备注</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comments </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>备注</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Commit Strategies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提交策略(Commit Strategies)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Committing every offset has performance penalties as Kafka offset management can be slow.
However, not committing the offset often enough may lead to message duplication if the application crashes between two commits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于Kafka的偏移量管理可能很慢，所以每次提交偏移量都会有性能上的损失。然而，如果程序在两次提交之间崩溃，不够频繁的偏移量提交可能会导致消息出现重复提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Committing every offset has performance penalties as Kafka offset management can be slow.  However, not committing the offset often enough may lead to message duplication if the application crashes between two commits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于Kafka的偏移量管理可能很慢，所以每次提交偏移量都会有性能上的损失。然而，如果程序在两次提交之间崩溃，不够频繁的偏移量提交可能会导致消息出现重复提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Community and Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>社区和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatibility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>兼容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatible with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Quarkus兼容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compilation will take a bit longer, so this step is disabled by default;
let's build again by enabling the `native` profile:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译会花一点时间，所以这一步默认是禁用的；让我们通过启用 `native` profile来再次构建：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compilation will take a bit longer, so this step is disabled by default; let's build again by enabling the `native` profile:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译会花一点时间，所以这一步默认是禁用的；让我们通过启用 `native` profile来再次构建：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling a native executable takes a bit longer, as GraalVM performs additional
steps to remove unnecessary codepaths. Use the  `native` profile to compile a
native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译一个本地可执行文件需要很长的时间，因为GraalVM会执行额外的步骤来删除不必要的代码路径。可使用 `native` profile来编译一个本地可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling a native executable takes a bit longer, as GraalVM performs additional steps to remove unnecessary codepaths. Use the `native` profile to compile a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译一个本地可执行文件需要很长的时间，因为GraalVM会执行额外的步骤来删除不必要的代码路径。可使用 `native` profile来编译一个本地可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling fully static binaries is done by statically linking https://musl.libc.org/[musl] instead of `glibc` and should not be used in production without rigorous testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译纯静态的二进制文件是通过静态链接 link:https://musl.libc.org/[musl] 而不是 `glibc` ，如果没有严格的测试，不应该在生产中使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling the application to a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将应用程序编译为原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Components</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compress Native Executables with UPX</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用UPX压缩原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conclusion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conditional Extension Dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>条件性扩展的依赖性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config autocompletion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置自动补全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config editor</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义向导</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config jump to definition</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置跳转定义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config outline</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置大纲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config profiles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Profile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config property allows for an external or internal location of Private Decryption Key to be specified.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置属性允许指定私人解密密钥的外部或内部位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config property allows for an external or internal location of Private Decryption Key to be specified. This property is deprecated - use 'mp.jwt.decrypt.key.location'.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置属性允许指定私人解密密钥的外部或内部位置。此属性已被废弃 - 请使用 `mp.jwt.decrypt.key.location` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config property allows for an external or internal location of Public Key to be specified.  The value may be a relative path or a URL. If the value points to an HTTPS based JWK set then, for it to work in native mode, the `quarkus.ssl.native` property must also be set to `true`, see xref:native-and-ssl.adoc[Using SSL With Native Executables] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置属性允许指定公钥的外部或内部位置。该值可以是一个相对路径或一个URL。如果该值指向一个基于HTTPS的JWK集，那么为了让它在本地模式下工作， `quarkus.ssl.native` 属性也必须被设置为 `true` ，更多细节请参见 link:native-and-ssl.html[使用SSL与本地可执行程序] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config property specifies the value of the `iss` (issuer) claim of the JWT that the server will accept as valid.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置属性指定了服务器将接受为有效的JWT的 `iss` （签发者）声明的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置元数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Properties to Deny access</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拒绝访问的配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration authorization checks are executed before any annotation-based authorization check is done, so both
checks have to pass for a request to be allowed. This means you cannot use `@PermitAll` to open up a path if the path has
been blocked using `quarkus.http.auth.` configuration. If you are using JAX-RS you may want to consider using the
`quarkus.security.jaxrs.deny-unannotated-endpoints` or `quarkus.security.jaxrs.default-roles-allowed` to set default security
requirements instead of HTTP path level matching, as these properties can be overridden by annotations on an individual
endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置授权检查会在任何基于注解的授权检查之前执行，所以只有这两种检查都通过后请求才会被允许执行。这意味着如果使用 `quarkus.http.auth.` 配置阻止了一个路径，您就不能使用 `@PermitAll` 来开放该路径。如果您使用 JAX-RS，您可能需要考虑使用 `quarkus.security.jaxrs.deny-unannotated-endpoints` 或 `quarkus.security.jaxrs.default-roles-allowed` 来设置默认的安全要求，而不是基于HTTP 路径级别的匹配，因为这些属性可以被独立节点上的注解所覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration authorization checks are executed before any annotation-based authorization check is done, so both checks have to pass for a request to be allowed. This means you cannot use `@PermitAll` to open up a path if the path has been blocked using `quarkus.http.auth.` configuration. If you are using JAX-RS you may want to consider using the `quarkus.security.jaxrs.deny-unannotated-endpoints` or `quarkus.security.jaxrs.default-roles-allowed` to set default security requirements instead of HTTP path level matching, as these properties can be overridden by annotations on an individual endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置授权检查会在任何基于注解的授权检查之前执行，所以只有这两种检查都通过后请求才会被允许执行。这意味着如果使用 `quarkus.http.auth.` 配置阻止了一个路径，您就不能使用 `@PermitAll` 来开放该路径。如果您使用 JAX-RS，您可能需要考虑使用 `quarkus.security.jaxrs.deny-unannotated-endpoints` 或 `quarkus.security.jaxrs.default-roles-allowed` 来设置默认的安全要求，而不是基于HTTP 路径级别的匹配，因为这些属性可以被独立节点上的注解所覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration for the Kafka connector outgoing channels is similar to that of incoming:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Connector中用于发送的 channels 的配置与用于接收的 channel 的配置类似：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration key conflicts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置键冲突</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置要连接的Redis主机。这里我们连接到上一节中启动的Redis服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the Kafka bootstrap location, so the application connects to this broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Kafka bootstrap位置，这样应用程序就会连接到这个broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the OpenTelemetry Collector by creating an `otel-collector-config.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过创建一个 `otel-collector-config.yaml` 文件来配置OpenTelemetry Collector：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.incoming.$channel.bootstrap.servers` property.
In dev mode and when running tests, &lt;&lt;kafka-dev-services&gt;&gt; automatically starts a Kafka broker.
When not provided this property defaults to `localhost:9092`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请务必为生产环境配置broker地址。您可以在全局环境配置或使用 `mp.messaging.incoming.$channel.bootstrap.servers` 属性来针对特定channel配置。在开发模式和运行测试时， &lt;&lt;kafka-dev-services&gt;&gt;会自动启动一个Kafka broker。如果没有提供这个属性，则默认为 `localhost:9092` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.incoming.$channel.bootstrap.servers` property.  In dev mode and when running tests, &lt;&lt;kafka-dev-services&gt;&gt; automatically starts a Kafka broker.  When not provided this property defaults to `localhost:9092`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请务必为生产环境配置broker地址。您可以在全局环境配置或使用 `mp.messaging.incoming.$channel.bootstrap.servers` 属性来针对特定channel配置。在开发模式和运行测试时， &lt;&lt;kafka-dev-services&gt;&gt;会自动启动一个Kafka broker。如果没有提供这个属性，则默认为 `localhost:9092` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.outgoing.$channel.bootstrap.servers` property.
In dev mode and when running tests, &lt;&lt;kafka-dev-services&gt;&gt; automatically starts a Kafka broker.
When not provided, this property defaults to `localhost:9092`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请配置生产环境的broker位置。您可以在全局配置，或使用 `mp.messaging.outgoing.$channel.bootstrap.servers` 来针对特定channel配置它。在开发模式和运行测试时， &lt;&lt;kafka-dev-services&gt;&gt;会自动启动一个Kafka broker。如果该属性未提供，它将默认为 `localhost:9092` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.outgoing.$channel.bootstrap.servers` property.  In dev mode and when running tests, &lt;&lt;kafka-dev-services&gt;&gt; automatically starts a Kafka broker.  When not provided, this property defaults to `localhost:9092`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请配置生产环境的broker位置。您可以在全局配置，或使用 `mp.messaging.outgoing.$channel.bootstrap.servers` 来针对特定channel配置它。在开发模式和运行测试时， &lt;&lt;kafka-dev-services&gt;&gt;会自动启动一个Kafka broker。如果该属性未提供，它将默认为 `localhost:9092` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the connector to manage the `prices-out` channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置connector来管理 `prices-out` channel。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the connector to manage the prices channel. By default the topic name is same as the channel name. You can configure the topic attribute to override it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置connector来管理prices channel。默认情况下，topic名称与channel名称相同。您可以通过配置topic属性来覆盖它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `datacontenttype` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `datacontenttype` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `datacontenttype` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `datacontenttype` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `dataschema` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `dataschema` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `dataschema` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `dataschema` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `source` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `source` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `source` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `source` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `subject` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `subject` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `subject` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `subject` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `type` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `type` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `type` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `type` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置运行环境。例如将 `GRAALVM_HOME` 环境变量设置为GraalVM的安装目录，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures the broker/router host name. You can do it per channel (using the `host` attribute) or globally using `amqp-host`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置代理/路由器的主机名。你可以按通道进行配置（使用 `host` 属性），或使用 `amqp-host` 进行全局配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures the broker/router password if required. You can do it per channel (using the `password` attribute) or globally using `amqp-password`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果需要，请配置代理/路由器的密码。你可以按通道（使用 `password` 属性）进行配置，或使用 `amqp-password` 进行全局配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures the broker/router port. You can do it per channel (using the `port` attribute) or globally using `amqp-port`. The default is `5672`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置代理/路由器的端口。你可以按通道（使用 `port` 属性）进行配置，或使用 `amqp-port` 进行全局配置。默认是 `5672` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures the broker/router username if required. You can do it per channel (using the `username` attribute) or globally using `amqp-username`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果需要，请配置代理/路由器的用户名。你可以按通道（使用 `username` 属性）进行配置，或使用 `amqp-username` 进行全局配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring JSON support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置JSON支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Kafka topics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Kafka主题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Keycloak programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以编程方式配置Keycloak</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Redis properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Smallrye Kafka Connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Smallrye Kafka Connector</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Well-Known OpenID Connect (OIDC) Providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置知名的OpenID Connect（OIDC）提供者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置你的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring live reload compiler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置实时重载编译器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the AMQP Broker access</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置AMQP代理访问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the AMQP address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置AMQP地址</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the HTTP connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置HTTP连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the MongoDB database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置MongoDB数据库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Vert.x实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置地址</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the banner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置banner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the incoming channel. This channel reads from Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传入 channel 。该 channel 从Kafka读取消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the transaction timeout</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置事务超时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the {extension-name} Extension Security Information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置{extension-name}扩展安全信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring transaction node name identifier</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置事务节点名称标识符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置你的数据源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connecting to Managed Kafka clusters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接到受管理的Kafka集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connection Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接健康检查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connector auto-attachment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Connector auto-attachment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consul Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Consul客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume Configuration from Consul</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Consul中消费配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume Configuration from Google Cloud Secret Manager</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从谷歌云秘密管理器中消费配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume an event with payload of type `Cost` and produce a `double`.  In the case of consuming an arbitrary object, the reactive-messaging-http extension will attempt to deserialize the request body as a JSON object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费一个具有 `Cost` 类型的有效载荷的事件，并生成一个 `double` 。在消费任意一个对象的情况下，reactive-messaging-http 扩展将尝试把请求体反序列化为一个JSON对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume messages from the `incoming-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 `incoming-costs` 流中消费消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumer Groups</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者组(Consumer Groups)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumer Rebalance Listener</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者再平衡监听器(Consumer Rebalance Listener)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming GraphQL Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费GraphQL服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming Kubernetes ConfigMaps</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费Kubernetes ConfigMaps</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming gRPC Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费gRPC服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container First</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>容器优先</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context Propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务和安全上下文传播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuing from the previous minimal configuration, your Quarkus application can receive message payload directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们继续刚才的最小配置。您的Quarkus应用程序可以直接接收消息payload：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuous Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持续测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连续统一体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to Dev UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为开发用户界面做出贡献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为Quarkus.io网站贡献力量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>欢迎贡献，请为 `develop` 分支提交pull requests。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributors</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Controlling HTTP interaction timeout</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>控制HTTP交互超时时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Controlling the test port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>控制测试端口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conversely, if the processing throws an exception, all messages are _nacked_, applying the failure strategy for all the records inside the batch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反之，如果处理过程抛出一个异常，所有的消息都_不会被确认(nacked)_ ，并且对批次中的所有记录应用失败策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cool stuff right? &lt;a href="https://quarkus.io/guides/maven-tooling#dev-mode"&gt;Learn more about Quarkus's dev mode&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很Cool的东东对吧？&lt;a href="https://quarkus.io/guides/maven-tooling#dev-mode"&gt;了解更多Quarkus的开发模式&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the build.gradle, gradle.properties and settings.gradle into the above generated Maven archetype project, to follow along with this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将build.gradle、gradle.properties和settings.gradle复制到上述生成的Maven archetype项目中，以按照本指南进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy your current "Installed JRE" definition into a new one, where you will add the properties as a new VM arguments:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将您当前的 "已安装的JRE "定义复制为一个新的定义，在这里您会将其作为新的虚拟机参数配置来添加属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Core</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>核心</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Coroutines support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Coroutines 支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>计数器（Counters）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counters are used to measure values that only increase. In the example below, you will count the number of times you
test a number to see if it is prime:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Counters是用来测量只增加的数值的。在下面的例子中，您将统计您测试一个数字是否是质数的次数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counters are used to measure values that only increase. In the example below, you will count the number of times you test a number to see if it is prime:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Counters是用来测量只增加的数值的。在下面的例子中，您将统计您测试一个数字是否是质数的次数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a Quarkus Test using the test resource created above:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用上面创建的测试资源创建一个Quarkus测试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a REST endpoint in `src/main/java/org/acme/security/jwt/TokenSecuredResource.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `src/main/java/org/acme/security/jwt/TokenSecuredResource.java` 里，创建一个REST端点，内容如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `security-jwt-quickstart/src/main/resources/application.properties` with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个 `security-jwt-quickstart/src/main/resources/application.properties` ，内容如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `src/main/java/org/acme/opentelemetry/TracedResource.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个 `src/main/java/org/acme/opentelemetry/TracedResource.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下方法创建一个原生可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用： `./mvnw package -Pnative` 创建一个原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new class `src/main/java/org/acme/spring/boot/properties/GreetingProperties.java` with a message field:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个包含消息字段的 `src/main/java/org/acme/spring/boot/properties/GreetingProperties.java` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new project using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令创建一个新项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an ECR repository in the users AWS account</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在用户的AWS账户中创建一个ECR存储库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an Execution Role</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个执行角色</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create and debug applications in the same environment where applications run. Live coding in development mode where any changes made locally will be immediately visible in a clustered Kubernetes environment. &lt;a href="https://developers.redhat.com/blog/2021/02/11/enhancing-the-development-loop-with-quarkus-remote-development"&gt;Read this blog post for greater insight.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在应用程序运行的同一环境中创建和调试应用程序。在开发模式下的实时编码，在集群化的Kubernetes环境中，本地做出的任何更改都将立即可见。&lt;a href="https://developers.redhat.com/blog/2021/02/11/enhancing-the-development-loop-with-quarkus-remote-development"&gt;阅读这篇博客可以获得更深刻的见解&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create consumer task which subscribes to 'orders-processed' topic and consumes 10 records.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建消费者任务，用来订阅'orders-processed'topic并消费10条记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create inside the `producer` project `src/main/resources/META-INF/resources/quotes.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `producer` 项目中创建 `src/main/resources/META-INF/resources/quotes.html` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create projects, manage extensions, and execute essential build and dev commands.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建项目，管理扩展，并执行基本的构建和开发命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the AWS lambda function with the AWS CLI tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用AWS CLI工具创建AWS lambda函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the Getting Started Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 "入门 "应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the Quarkus AWS Lambda Maven project using our Maven Archetype.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用我们的Maven 原型创建Quarkus AWS Lambda Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the Quarkus AWS Lambda maven project using our Maven Archetype.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用我们的Maven Archetype创建Quarkus AWS Lambda maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `CountResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建包含以下内容的 `CountResource` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/VertxResource.java` file.
It will contain our HTTP endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/VertxResource.java` 文件。它将包含我们的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/VertxResource.java` file.  It will contain our HTTP endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/VertxResource.java` 文件。它将包含我们的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/hibernate/orm/panache/FruitResource.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/hibernate/orm/panache/FruitResource.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/reactivehttp/CostConverter.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/reactivehttp/CostConverter.java` 文件，内容如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/redis/IncrementResource.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/redis/IncrementService.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/index.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/resources/META-INF/resources/index.html` 文件, 包含以下内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/test/java/org/acme/redis/IncrementResourceTest.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/test/java/org/acme/redis/IncrementResourceTest.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the function</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the record using `Record.of(k, v)`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `Record.of(k, v)` 来创建记录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Created on</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating Clients Programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以编程方式创建Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating JSON REST services with Quarkus is easy as it relies on proven and well known technologies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Quarkus 创建 JSON REST 服务很容易，因为它依赖于经过验证且众所周知的技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating Your First Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建你的第一个应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a JAX-RS endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个JAX-RS端点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a Linux executable without GraalVM installed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在没有安装GraalVM的情况下创建一个Linux可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个容器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a customized MeterRegistry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个自定义的MeterRegistry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a frontend</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个网页</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new increment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个新的增量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建响应式 JAX-RS 端点（异步、流等）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a scheduled job</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个计划作业</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment POJO</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Increment POJO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment Resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Increment资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Increment服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven Deployment Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Maven部署项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the resource and the test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建资源和测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the test class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建测试类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating your first JSON REST service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建你的第一个JSON REST服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有 AWS 开发工具包和 AWS CLI 共享的默认位置 （ `~.awscredentials` ）的凭证配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>证书提供者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials delivered through the Amazon ECS if the `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the security manager has permission to access the variable,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置了 `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` 环境变量并且安全管理员有权访问该变量，则通过 Amazon ECS 传递的凭证，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cross Origin Resource Sharing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>跨域资源共享(CORS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cross-origin resource sharing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cross-Origin 资源共享</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cross-site Request Forgery (CSRF) prevention</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>防止跨站请求伪造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, Quarkus doesn't support link:https://docs.mongodb.com/manual/core/security-client-side-encryption/[Client-Side Field Level Encryption] in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目前，Quarkus在本地模式下不支持 link:https://docs.mongodb.com/manual/core/security-client-side-encryption/[客户端字段级加密] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Factories</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定制工厂</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom IDs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Security Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义安全集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom `bootstrap` script</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义 `bootstrap` 脚本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom test resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义测试资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom token verification</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义token验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customize Quarkus' security layer behavior.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义Quarkus的安全层行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing the underlying AMQP client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定制底层AMQP客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DB2 Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DB2客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DOCUMENTATION</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dealing with messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dealing with the verification keys</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理验证密钥</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>调试原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declarative approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>声明式方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the bean in the _application_ scope. Spring only detects @Scheduled annotations in beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以 _application_ scope声明该Bean。Spring只检测Bean上的@Scheduled注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the root HTTP path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>声明HTTP根路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decryption Key identifier. If it is set then the decryption JWK key as well every JWT token must have a matching `kid` header.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解密密钥标识符。如果它被设置，那么解密JWK密钥以及每个JWT标记必须有一个匹配的 `kid` header。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decryption algorithm.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解密算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decryption key supplied as a string.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以字符串形式提供的解密密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default values</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job to be executed at a fixed interval of time `fixedRate.expr` which is configurable in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `application.properties` 中定义一个以固定时间间隔执行的 `fixedRate.expr` 作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression `cron.expr` which is configurable in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `application.properties` 中使用类似于cron表达式的方式定义一个名为 `cron.expr` 的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a method to be executed at a fixed interval of time. The period is expressed in milliseconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义一个以固定时间间隔执行的方法。周期以毫秒表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines the default role requirements for unannotated endpoints. The role '**' is a special role that means any authenticated user. This cannot be combined with
`deny-unannotated-endpoints`, as the deny will take effect instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义了未加注解节点的默认角色要求。角色'**'是一个特殊的角色，意味着任何认证的用户。该项不能与 `deny-unannotated-endpoints` 混合使用，因为deny会代替它生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines the default role requirements for unannotated endpoints. The role '**' is a special role that means any authenticated user. This cannot be combined with `deny-unannotated-endpoints`, as the deny will take effect instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义了未加注解节点的默认角色要求。角色'**'是一个特殊的角色，意味着任何认证的用户。该项不能与 `deny-unannotated-endpoints` 混合使用，因为deny会代替它生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining entities in external projects or jars</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在外部项目或jar中定义实体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining your entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义你的实体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining your repository</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义你的存储库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delay class initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>延迟类的初始化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delaying class initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>推迟类的初始化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the `first` increment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>删除 `first` 的增量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deleting a key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>删除指定的键</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.
If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus中的依赖注入是基于ArC的，ArC是一个基于CDI的依赖注入解决方案，。如果你是CDI的新手，那么我们推荐你阅读 link:cdi.html[CDI简介] 指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus中的依赖注入是基于ArC的，ArC是一个基于CDI的依赖注入解决方案，。如果你是CDI的新手，那么我们推荐你阅读 link:cdi.html[CDI简介] 指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on what the final desired output of the CI/CD pipeline is, the generated binary might then be used to create a container image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>根据CI/CD管道的最终期望输出，生成的二进制文件可能被用来创建一个容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy to AWS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到AWS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy to AWS Lambda Custom (native) Runtime</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到AWS Lambda Custom (native) Runtime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy to AWS Lambda Java Runtime</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到AWS Lambda Java Runtime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy to AWS Lambda using a Container Image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用容器镜像部署到AWS Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy your Quarkus applications on Heroku.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Heroku上部署你的Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying Quarkus Applications on Kubernetes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kubernetes上部署Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying Quarkus Applications on OpenShift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在OpenShift上部署Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying a container image lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署一个容器镜像lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署一个本地可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to GitHub Pages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到GitHub页面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Google Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到谷歌云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Heroku</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到Heroku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Microsoft Azure Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到微软Azure云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying verticles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署verticles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>弃用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>描述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deserialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Despite the existence of the plugin, a few AMQP 1.0 features won’t work with RabbitMQ.
Thus, we recommend the following configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尽管存在插件，但少数 AMQP 1.0 特性并不能与 RabbitMQ 一起工作。因此，我们建议采用以下配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Despite the existence of the plugin, a few AMQP 1.0 features won’t work with RabbitMQ.  Thus, we recommend the following configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尽管存在插件，但少数 AMQP 1.0 特性并不能与 RabbitMQ 一起工作。因此，我们建议采用以下配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Detailed information on the usage of `@Blocking` annotation can be found in https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging – Handling blocking execution].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于 `@Blocking` 注解的详细信息，可以在 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging – 阻塞处理] 找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Mode Differences</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式的差异</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services (Configuration Free Databases)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发服务（免配置数据库）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP的开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP automatically starts an AMQP 1.0 broker in dev mode and when running tests.
So, you don't have to start a broker manually.
The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当运行测试时，AMQP的开发服务会在开发模式下自动启动一个AMQP 1.0代理。所以，你不需要手动启动代理。应用程序会自动配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP automatically starts an AMQP 1.0 broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当运行测试时，AMQP的开发服务会在开发模式下自动启动一个AMQP 1.0代理。所以，你不需要手动启动代理。应用程序会自动配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP is automatically enabled unless:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP的开发服务是自动启用的，除非：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP relies on Docker to start the broker.
If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.
You can configure the broker access using the `amqp-host`, `amqp-port`, `amqp-user` and `amqp-password` properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP的开发服务依赖于Docker来启动代理。如果你的环境不支持Docker，你将需要手动启动代理，或者连接到一个已经运行的代理。你可以使用 `amqp-host` , `amqp-port` , `amqp-user` 和 `amqp-password` 属性来配置代理访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker access using the `amqp-host`, `amqp-port`, `amqp-user` and `amqp-password` properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP的开发服务依赖于Docker来启动代理。如果你的环境不支持Docker，你将需要手动启动代理，或者连接到一个已经运行的代理。你可以使用 `amqp-host` , `amqp-port` , `amqp-user` 和 `amqp-password` 属性来配置代理访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP starts the container with the `quarkus-dev-service-amqp` label which is used to identify the container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP的开发服务使用 `quarkus-dev-service-amqp` 标签来启动容器，该标签用于识别容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP uses https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] images.
You can configure the image and version using the `quarkus.amqp.devservices.image-name` property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP的开发服务使用 https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] 镜像。你可以使用 `quarkus.amqp.devservices.image-name` 属性来配置镜像和版本:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP uses https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] images.  You can configure the image and version using the `quarkus.amqp.devservices.image-name` property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP的开发服务使用 https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] 镜像。你可以使用 `quarkus.amqp.devservices.image-name` 属性来配置镜像和版本:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apicurio注册表的开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry is automatically enabled unless:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apicurio注册表的开发服务是自动启用的，除非：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry relies on Docker to start the registry.
If your environment does not support Docker, you will need to start the registry manually, or use an already running registry.
In such case, you can configure the registry URL for all Kafka channels in SmallRye Reactive Messaging with a single property.
For Apicurio Registry serde, that is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apicurio注册表的开发服务依赖于Docker来启动注册表。如果你的环境不支持Docker，你需要手动启动注册表，或者使用一个已运行的注册表。在这种情况下，你可以使用一个属性为SmallRye响应式消息中的所有Kafka通道配置注册表的URL。对于Apicurio Registry serde来说，就是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry relies on Docker to start the registry.  If your environment does not support Docker, you will need to start the registry manually, or use an already running registry.  In such case, you can configure the registry URL for all Kafka channels in SmallRye Reactive Messaging with a single property.  For Apicurio Registry serde, that is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apicurio注册表的开发服务依赖于Docker来启动注册表。如果你的环境不支持Docker，你需要手动启动注册表，或者使用一个已运行的注册表。在这种情况下，你可以使用一个属性为SmallRye响应式消息中的所有Kafka通道配置注册表的URL。对于Apicurio Registry serde来说，就是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry starts the container with the `quarkus-dev-service-apicurio-registry` label which is used to identify the container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apicurio注册表的开发服务使用 `quarkus-dev-service-apicurio-registry` 标签来启动容器，该标签用于识别容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry uses `apicurio/apicurio-registry-mem` images.
You can select any 2.x version from https://hub.docker.com/r/apicurio/apicurio-registry-mem:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apicurio注册表的开发服务使用 `apicurio/apicurio-registry-mem` 镜像. 你可以从 https://hub.docker.com/r/apicurio/apicurio-registry-mem 中选择任何一个2.x版本:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry uses `apicurio/apicurio-registry-mem` images.  You can select any 2.x version from https://hub.docker.com/r/apicurio/apicurio-registry-mem:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apicurio注册表的开发服务使用 `apicurio/apicurio-registry-mem` 镜像. 你可以从 https://hub.docker.com/r/apicurio/apicurio-registry-mem 中选择任何一个2.x版本:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka开发服务（Dev Services）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka is automatically enabled unless:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的开发服务是自动启用的，除非：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka relies on Docker to start the broker.
If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.
You can configure the broker address using `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的开发服务依赖于Docker来启动broker。如果您的环境不支持Docker，您需要手动启动broker，或者连接到一个已经运行的broker。您可以使用 `kafka.bootstrap.servers` 来配置broker地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker address using `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的开发服务依赖于Docker来启动broker。如果您的环境不支持Docker，您需要手动启动broker，或者连接到一个已经运行的broker。您可以使用 `kafka.bootstrap.servers` 来配置broker地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka starts the container with the `quarkus-dev-service-kafka` label which is used to identify the container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka开发服务用 `quarkus-dev-service-kafka` 标签来启动容器，该标签用于识别容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka supports https://redpanda.com[Redpanda] and https://strimzi.io[Strimzi] (in https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] mode).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka开发服务支持 link:https://redpanda.com[Redpanda] 和 link:https://strimzi.io[Strimzi] （在 link:https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] 模式下）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Keycloak</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为Keycloak提供的开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Redis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis的Dev Services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Redis relies on Docker to start the server.
If your environment does not support Docker, you will need to start the server manually, or connect to an already running server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis的Dev Services依赖Docker来启动服务器。如果你的环境不支持Docker，则需要手动启动服务，或者连接到一个运行中的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Redis relies on Docker to start the server.  If your environment does not support Docker, you will need to start the server manually, or connect to an already running server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis的Dev Services依赖Docker来启动服务器。如果你的环境不支持Docker，则需要手动启动服务，或者连接到一个运行中的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Redis starts the container with the `quarkus-dev-service-redis` label which is used to identify the container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis的Dev Services启动容器时使用 `quarkus-dev-service-redis` 标签，该标签用于识别容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发用户界面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developer Joy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发者的乐趣</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developers are critical to the success of almost every organization and they need the tools to build cloud-native applications quickly and efficiently. Quarkus provides a frictionless development experience through a combination of tools, libraries, extensions, and more. Quarkus makes developers more efficient with tools to improve the inner loop development cycle while in dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发人员对几乎每个组织的成功都至关重要，他们需要工具来快速、高效地构建云原生应用程序。Quarkus通过工具、库、扩展等的组合提供了无摩擦的开发体验。Quarkus通过工具使开发人员在开发模式下更有效率地改善内循环开发周期。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developing REST Services with RESTEasy Classic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用RESTEasy Classic开发REST服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developing with Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Flyway开发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Differences with vanilla JAX-RS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与vanilla JAX-RS的区别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling a policy check using a Keycloak Authorization Policy such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Keycloak授权策略禁用一个策略检查，如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling permissions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>禁用权限 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling permissions </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>禁用权限 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to create your first Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何创建您的第一个Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to develop highly scalable REST services with JAX-RS and RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用JAX-RS和RESTEasy Reactive开发高度可扩展的REST服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how you can streamline the release process of your Quarkus applications with JReleaser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何利用JReleaser简化Quarkus应用程序的发布过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discuss the development of Quarkus with the team in the &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;development mailing list &lt;/a&gt; or by &lt;a href="https://quarkusio.zulipchat.com/"&gt;Zulip Chat&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与团队讨论Quarkus开发的地方是 &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;开发邮件列表 &lt;/a&gt; 或通过 &lt;a href="https://quarkusio.zulipchat.com/"&gt;Zulip Chat&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discussion about Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>讨论Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discussions and Collaboration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>讨论与合作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dispatch returned values to the `outgoing-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送返回值到 `outgoing-costs` 流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distribution summaries are populated by calling the `record` method to record observed values, while timers provide
additional capabilities specific to working with time and measuring durations. For example, we can use a timer to
measure how long it takes to calculate prime numbers using one of the `record` methods that wraps the invocation of a
Supplier function:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Distribution summaries是通过调用 `record` 方法来记录观测值，而timers则提供了专门用于处理时间和测量持续时间的额外功能。例如，我们可以通过如下方式使用一个timer来测量计算素数所需的时间：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distribution summaries are populated by calling the `record` method to record observed values, while timers provide additional capabilities specific to working with time and measuring durations. For example, we can use a timer to measure how long it takes to calculate prime numbers using one of the `record` methods that wraps the invocation of a Supplier function:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Distribution summaries是通过调用 `record` 方法来记录观测值，而timers则提供了专门用于处理时间和测量持续时间的额外功能。例如，我们可以通过如下方式使用一个timer来测量计算素数所需的时间：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distroless image support is experimental.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>无发行版支持是试验性的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distroless images should not be used in production without rigorous testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在没有经过严格测试的情况下，不应该在生产中使用无发行版镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not change the handler switch.  This must be hardcoded to `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`.  This
handler bootstraps Quarkus and wraps your actual handler so that injection can be performed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不要改变处理程序的开关。这必须被硬编码为 `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest` 。这个处理程序引导Quarkus，并包装你实际的处理程序，以便可以执行注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not change the handler switch.  This must be hardcoded to `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`.  This handler bootstraps Quarkus and wraps your actual handler so that injection can be performed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不要改变处理程序的开关。这必须被硬编码为 `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest` 。这个处理程序引导Quarkus，并包装你实际的处理程序，以便可以执行注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not start the Keycloak server when you run the application in a dev mode - `Dev Services for Keycloak` will launch a container. See &lt;&lt;keycloak-dev-mode, Running the Application in Dev mode&gt;&gt; section below for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当您以开发模式运行应用程序时，请不要启动Keycloak服务器 - `Keycloak开发服务` 将启动一个容器。更多信息请参见下面在 link:#keycloak-dev-mode[开发模式下运行应用程序] 的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not start the Keycloak server when you run the application in a dev mode - `Dev Services for Keycloak` will launch a container. See &lt;&lt;keycloak-dev-mode, Running the Application in Dev mode&gt;&gt; section below for more information. Make sure to put the {quickstarts-tree-url}/security-openid-connect-quickstart/config/quarkus-realm.json[realm configuration file] on the classpath (`target/classes` directory) so that it gets imported automatically when running in dev mode - unless you have already built a {quickstarts-tree-url}/security-openid-connect-quickstart[complete solution] in which case this realm file will be added to the classpath during the build.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你以开发模式运行应用程序时，不要启动Keycloak服务器 - `Keycloak开发模式` 将启动一个容器。更多信息请参见下面在 link:#keycloak-dev-mode[在keycloak开发模式下运行应用程序] 的部分。确保把{quickstarts-tree-url}/security-openid-connect-quickstart/config/quarkus-realm.json[境界配置文件]放在classpath（ `target/classes` 目录）上，以便在开发模式下运行时自动导入--除非你已经构建了{quickstarts-tree-url}/security-openid-connect-quickstart[完整解决方案]，这样的话，这个领域文件会在构建时被加入classpath。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker and Docker Compose</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Docker和Docker Compose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation about the Vert.x Mutiny variant is available on https://smallrye.io/smallrye-mutiny-vertx-bindings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于Vert.x Mutiny变体的文档可在 https://smallrye.io/smallrye-mutiny-vertx-bindings </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does Micrometer support annotations?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer支持注解吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does it do 2 Phase Commit and slow down my app?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>两阶段提交是否会减慢了我的应用程序？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does it work everywhere I want to?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它能在我希望的所有地方工作吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't see and extension you need? &lt;a href="{{site.baseurl}}/createextensions"&gt;Request a new extension&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>没有看到您需要的扩展吗? &lt;a href="{{site.baseurl}}/createextensions"&gt;申请新的扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't write parts of the query that you don't need: write `Person.find("order by name")` or
`Person.find("name = ?1 and status = ?2", "Loïc", Status.Alive)` or even better `Person.find("name", "Loïc")`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不要写你不需要的查询部分：写 `Person.find("order by name")` 或 `Person.find("name = ?1 and status = ?2", "Loïc", Status.Alive)` ，甚至更好的 `Person.find("name", "Loïc")` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't write parts of the query that you don't need: write `Person.find("order by name")` or
`Person.find("name = ?1 and status = ?2", "stef", Status.Alive)` or even better
`Person.find("name", "stef")`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不要写多余的查询语句：可以写 `Person.find("order by name")` 或 `Person.find("name = ?1 and status = ?2", "stef", Status.Alive)` ，甚至更好的 `Person.find("name", "stef")` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't write parts of the query that you don't need: write `Person.find("order by name")` or `Person.find("name = ?1 and status = ?2", "Loïc", Status.Alive)` or even better `Person.find("name", "Loïc")`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不要写你不需要的查询部分：写 `Person.find("order by name")` 或 `Person.find("name = ?1 and status = ?2", "Loïc", Status.Alive)` ，甚至更好的 `Person.find("name", "Loïc")` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't write parts of the query that you don't need: write `Person.find("order by name")` or `Person.find("name = ?1 and status = ?2", "stef", Status.Alive)` or even better `Person.find("name", "stef")`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不要写多余的查询语句：可以写 `Person.find("order by name")` 或 `Person.find("name = ?1 and status = ?2", "stef", Status.Alive)` ，甚至更好的 `Person.find("name", "stef")` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive] or clone the git repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下载一个 {quickstarts-archive-url}[存档] 或克隆git仓库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下载这个 {quickstarts-archive-url}[档案] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate Community Edition archive from &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.  Make sure to download and install at Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;下载适当的社区版归档文件，然后像解包其他JDK一样解包。确保Java 11版本已经下载并安装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate archive from &lt;https://github.com/graalvm/mandrel/releases&gt; or &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 &lt;https://github.com/graalvm/mandrel/releases&gt; 或 &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt; 下载相应的归档文件，然后像对待其他 JDK 一样将其解压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Downloads</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下载地址</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the sensitive nature of security bugs, the disclosure process is more constrained than a regular bug. We appreciate you following these industry accepted guidelines, which gives time for a proper fix and limit the time window of attack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于安全性缺陷的敏感性，披露过程比普通缺陷更受限制。我们感谢您遵循这些业界公认的指导方针，这些方针为适当的修复提供了时间，并限制了攻击的时间窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dumb getters and setters: since Java lacks support for properties in the language, we have to create fields,
then generate getters and setters for those fields, even if they don't actually do anything more than read/write
the fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>繁琐的 getters 和 setters：由于Java语言中缺乏对属性的支持，我们必须创建字段，然后为这些字段getters 和 setters，即使它们除了read/write字段外实际上没有做任何事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dumb getters and setters: since Java lacks support for properties in the language, we have to create fields, then generate getters and setters for those fields, even if they don't actually do anything more than read/write the fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>繁琐的 getters 和 setters：由于Java语言中缺乏对属性的支持，我们必须创建字段，然后为这些字段getters 和 setters，即使它们除了read/write字段外实际上没有做任何事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Duplicating ID logic: most entities need an ID, most people don't care how it's set, because it's not really
relevant to your model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重复ID逻辑：大多数实体需要一个ID，大多数人并不关心它是如何设置的，因为它与你的模型并不真正相关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Duplicating ID logic: most entities need an ID, most people don't care how it's set, because it's not really relevant to your model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重复ID逻辑：大多数实体需要一个ID，大多数人并不关心它是如何设置的，因为它与你的模型并不真正相关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During normal operation, a Kafka consumer preserves the order of records inside each partition assigned to it.
Smallrye Reactive Messaging keeps this order for processing, unless `@Blocking(ordered = false)` is used (see &lt;&lt;blocking-processing&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正常操作中，Kafka消费者会保留分配给它的每个分区里面的records的顺序。Smallrye Reactive Messaging会使用这个顺序进行处理，除非设置了 `@Blocking(ordered = false)` (参见&lt;&lt;blocking-processing&gt;&gt; )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During normal operation, a Kafka consumer preserves the order of records inside each partition assigned to it.  Smallrye Reactive Messaging keeps this order for processing, unless `@Blocking(ordered = false)` is used (see &lt;&lt;blocking-processing&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正常操作中，Kafka消费者会保留分配给它的每个分区里面的records的顺序。Smallrye Reactive Messaging会使用这个顺序进行处理，除非设置了 `@Blocking(ordered = false)` (参见&lt;&lt;blocking-processing&gt;&gt; )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/GreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在项目创建过程中， `src/main/java/org/acme/GreetingResource.java` 文件已被创建，其内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在项目创建过程中， `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` 文件已经创建了以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the startup and readiness health check, the connector connects to the broker and retrieves the list of topics. This attribute specifies the maximum duration (in ms) for the retrieval. If exceeded, the channel is considered not-ready.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在启动和就绪的健康检查期间，连接器会连接到broker并获取主题列表。这个属性指定了获取的最大耗时（ms）。如果超时，通道就被认为是没有就绪的。

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dynamic address names</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>动态地址名称</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E.g. the following sample callback:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如下面的回调例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>EXAMPLE APPLICATIONS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each OIDC tenant can either permit or deny storing its `quarkus.oidc.TokenIntrospection` and/or `quarkus.oidc.UserInfo` data with boolean `quarkus.oidc."tenant".allow-token-introspection-cache` and `quarkus.oidc."tenant".allow-user-info-cache` properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每个OIDC租户可以允许或拒绝存储其 `quarkus.oidc.TokenIntrospection` 和/或 `quarkus.oidc.UserInfo` 数据，其属性为布尔值 `quarkus.oidc."tenant".allow-token-introspection-cache` 和 `quarkus.oidc."tenant".allow-user-info-cache` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each channel can be disabled via configuration using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每个 channel 都可以通过配置来禁用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Launch debug/dev:mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>快速启动 调试/dev模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Quarkus-based scripting with jbang.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用jbang轻松实现基于Quarkus的脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse plugin to install into Eclipse using an update-site</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用更新站点安装的Eclipse插件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse separate JRE definition</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse中独立的JRE定义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ecosystem</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生态系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `GreetingResource` class to inject the `GreetingService` and create a new endpoint using it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编辑 `GreetingResource` 类，注入 `GreetingService` ，并使用它创建一个新的端点:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `application.properties` file and add the `cron.expr` and the `fixedRate.expr` configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编辑 `application.properties` 文件，添加 `cron.expr` 和 `fixedRate.expr` 配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.
This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda
Custom (Provided) Runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这两个命令中的任何一个都会编译并创建一个本地可执行镜像。它还会生成一个zip文件 `target/function.zip` 。这个zip文件包含已重命名为 `bootstrap` 的本地可执行镜像，。这是AWS Lambda Custom (Provided) Runtime的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.  This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda Custom (Provided) Runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这两个命令中的任何一个都会编译并创建一个本地可执行镜像。它还会生成一个zip文件 `target/function.zip` 。这个zip文件包含已重命名为 `bootstrap` 的本地可执行镜像，。这是AWS Lambda Custom (Provided) Runtime的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Elasticsearch Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearch客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Elasticsearch Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearch开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Email used to subscribe to our mailing list.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于订阅我们邮件列表的电子邮件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拥抱来自Quarkus的响应和指令支柱的统一， `Uni` 和 `Multi` 都为指令式结构提供了桥梁。例如，你可以将 `Multi` 转换为 `Iterable` ，或者 _await_ `Uni` 生成元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the appropriate &lt;&lt;native-transport&gt;&gt; and set the following
environment property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用适当的 link:#native-transport[[native-transport]] 并设置以下环境属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the appropriate &lt;&lt;native-transport&gt;&gt; and set the following environment property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用适当的 link:#native-transport[[native-transport]] 并设置以下环境属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabled with `mp.messaging.outgoing.$channel.propagate-record-key=true` configuration,
record key propagation produces the outgoing record with the same _key_ as the incoming record.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过启用 `mp.messaging.outgoing.$channel.propagate-record-key=true` ，记录键传播可以产生与传入记录的 _键_ 相同的传出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabled with `mp.messaging.outgoing.$channel.propagate-record-key=true` configuration, record key propagation produces the outgoing record with the same _key_ as the incoming record.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过启用 `mp.messaging.outgoing.$channel.propagate-record-key=true` ，记录键传播可以产生与传入记录的 _键_ 相同的传出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用（默认启用）或停用云事件支持。如果在 _传入_ 通道上启用，连接器会分析传入记录并尝试创建云事件元数据。如果在 _传出_ 通道上启用，并且如果消息包括云事件元数据，连接器会将传出的消息作为云事件发送。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for AMQP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用/禁用AMQP的开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Apicurio Registry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用/禁用Apicurio注册表的开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用/禁用Kafka开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling YAML Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用YAML配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enrichment via QuarkusTest*Callback</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过QuarkusTest*Callback来增强</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that the response contains `count`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确保响应中包含 `count`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that the value of the `auth-mechanism` property matches the authentication scheme supported by `HttpAuthenticationMechanism`, for example, `basic`, `bearer`, or `form`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`auth-mechanism` 属性值必须与 HttpAuthenticationMechanism 支持的认证方案相匹配，如 `basic` 或 `bearer` 或 `form` 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that you review and update the suppression list regularly to ensure that the results are up to date.
You can optionally apply a time limit to individual suppressions by adding an expiry attribute, as outlined in the following example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确保您会检查和更新这个suppression列表以保证结果是及时更新的。
您可以选择通过添加过期属性来对单个的suppression项目应用一个时间限制，如下面所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that you review and update the suppression list regularly to ensure that the results are up to date.
You can optionally apply a time limit to individual suppressions by adding an expiry attribute, as outlined in the following example: 
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确保您会检查和更新这个suppression列表以保证结果是及时更新的。
您可以选择通过添加过期属性来对单个的suppression项目应用一个时间限制，如下面所示：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that you review and update the suppression list regularly to ensure that the results are up to date.  You can optionally apply a time limit to individual suppressions by adding an expiry attribute, as outlined in the following example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确保您会检查和更新这个suppression列表以保证结果是及时更新的。
您可以选择通过添加过期属性来对单个的suppression项目应用一个时间限制，如下面所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure the following dependency is present in your build file if you require the MicroProfile Metrics API:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要使用MicroProfile Metrics API，请确保您的构建文件中存在以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enterprise support provided by Red Hat for the product.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该产品由红帽公司提供企业级支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Entry point for everything gRPC.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一切gRPC的总入口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>环境变量 - `AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error Handling Strategies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>错误处理策略(Error Handling Strategies)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error handling for the exactly-once processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>（exactly-once）精确一次处理的错误处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Essentially, any `QuarkusTestProfile` with at least one matching tag matching the value of `quarkus.test.profile.tags` will be considered active
and all the tests annotated with `@TestProfile` of active profiles, will be run while the rest will be skipped.
This is best shown in the following example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本质上，任何至少有一个标签与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 将被认为是激活的，并且所有被激活的profiles中注解了 `@TestProfile` 的测试将被运行，而其余的将被跳过。这在下面的例子中得到了最好的体现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Essentially, any `QuarkusTestProfile` with at least one matching tag matching the value of `quarkus.test.profile.tags` will be considered active and all the tests annotated with `@TestProfile` of active profiles, will be run while the rest will be skipped.  This is best shown in the following example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本质上，任何至少有一个标签与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 将被认为是激活的，并且所有被激活的profiles中注解了 `@TestProfile` 的测试将被运行，而其余的将被跳过。这在下面的例子中得到了最好的体现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>活动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every contribution is valuable. It can be a bug report, an example application, a feature request, a fix in the documentation or just feedback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每一份贡献都是有价值的。它可以是bug报告、示例应用程序、功能请求、文档中的修复或仅仅是反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every query operation accepts passing parameters by index (`Object...`), or by name (`Map&lt;String,Object&gt;` or `Parameters`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每个查询操作都接受按索引（ `Object...` ）或按名称（ `Map&lt;String,Object&gt;` 或 `Parameters` ）传递参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything described here will only work in the context of Quarkus extensions, it won't work in an application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里描述的一切只在Quarkus扩展的范围内起作用，在应用程序中不会起作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything under the `"%test"` key is only enabled when the `test` profile is active. For example, in the previous
snippet it disables OIDC (`quarkus.oidc.enabled: false`), whereas without the `test` profile, it would be enabled.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>只有当 `test` 环境配置处于激活状态时， `"%test"` 键下的所有内容才会被启用。例如在前面的代码片段中，它禁用了OIDC ( `quarkus.oidc.enabled: false` )，反之，如果没有 `test` 环境配置，它将会被启用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything under the `"%test"` key is only enabled when the `test` profile is active. For example, in the previous snippet it disables OIDC (`quarkus.oidc.enabled: false`), whereas without the `test` profile, it would be enabled.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>只有当 `test` 环境配置处于激活状态时， `"%test"` 键下的所有内容才会被启用。例如在前面的代码片段中，它禁用了OIDC ( `quarkus.oidc.enabled: false` )，反之，如果没有 `test` 环境配置，它将会被启用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exactly-Once Processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>（Exactly-Once Processing）精确一次处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine sam.yaml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检查sam.yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the JAX-RS resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检查JAX-RS资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the POM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检查POM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the POM and Gradle build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检查POM和Gradle构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the output of the `manage.sh` script if you want to learn what aws commands are executed
to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想了解执行了哪些aws命令来创建、删除和更新lambdas，请检查 `manage.sh` 脚本的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想了解执行了哪些aws命令来创建、删除和更新lambdas，请检查 `manage.sh` 脚本的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Gradle dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle依赖项示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example of usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excellent, we have not provided any JWT in the request, so we should not be able to access the endpoint, and we were not. Instead, we received an HTTP 401 Unauthorized error.
We need to obtain and pass in a valid JWT to access that endpoint. There are two steps to this, 1) configuring our {extension-name} extension with information on how to validate a JWT, and 2) generating a matching JWT with the appropriate claims.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很好，我们在请求中没有提供任何JWT，所以我们应该不能够访问这个端点，而我们确实没有。相反，我们收到了一个HTTP 401 Unauthorized错误。我们需要获得并传入一个有效的JWT来访问该端点。这有两个步骤，1）用如何验证JWT的信息配置我们的{extension-name}扩展；2）用适当的声明(claim)生成一个匹配的JWT。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excellent, we have not provided any JWT in the request, so we should not be able to access the endpoint, and we were not. Instead, we received an HTTP 401 Unauthorized error. We need to obtain and pass in a valid JWT to access that endpoint. There are two steps to this, 1) configuring our {extension-name} extension with information on how to validate a JWT, and 2) generating a matching JWT with the appropriate claims.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很好，我们在请求中没有提供任何JWT，所以我们应该不能够访问这个端点，而我们确实没有。相反，我们收到了一个HTTP 401 Unauthorized错误。我们需要获得并传入一个有效的JWT来访问该端点。这有两个步骤，1）用如何验证JWT的信息配置我们的{extension-name}扩展；2）用适当的声明(claim)生成一个匹配的JWT。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excluding tests when running as a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为原生可执行文件运行时排除测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execute: gradle wrapper to setup the gradle wrapper (recommended).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>执行：gradle wrapper来设置gradle wrapper（推荐）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Executing against a running application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对正在运行的应用程序执行测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execution model</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>执行模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execution model and Blocking processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>执行模型和阻塞处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expiration grace in seconds. By default, an expired token will still be accepted if the current time is no more than 1 min after the token expiry time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>过期时间，以秒为单位。默认情况下，如果当前时间不超过令牌过期时间1分钟，过期的令牌仍将被接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore all the BuildItems you can consume/produce in your extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索你可以在你的扩展中消费/提供的所有BuildItems。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore in more details how to debug native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更详细地探讨如何调试原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the Quarkus developer toolchain which makes Quarkus development so fast and enjoyable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索Quarkus开发者工具链，让Quarkus开发如此快速和愉快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the Solution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the wide breadth of technologies Quarkus with which applications can be made.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索Quarkus可以应用的广泛的技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expressions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>表达式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extend and customize the Configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展和定制配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending Configuration Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展配置支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending the image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展该镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Repository</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Title Quarkiverse-JBeret</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展标题Quarkiverse-JBeret</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Version</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Version: 1.1.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本: 1.1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension or Dependency</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展或依赖性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展在进入Quarkus生态系统时具有不同程度的成熟度。状态提供了你可以依赖的期望。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>External and Internal Access to OpenID Connect Provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>外部和内部访问OpenID Connect的提供者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>External application.yaml file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>外部application.yaml 文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extra Build Generated Files</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建额外生成的文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extracting Content with Apache Tika</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Apache Tika提取内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Failure Management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>失败管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feedback and Help</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反馈和帮助</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Filter the Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>筛选扩展程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Final touch, the HTML page reading the converted prices using SSE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，HTML页面使用SSE读取转换后的价格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, Secured Access to /secured/roles-allowed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，安全访问/secured/roles-allowed</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your channels to use the JSON-B serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，通过配置来使您的 channels 使用JSON-B串行器和反串行器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your channels to use the Jackson serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，配置您的 channelss 以使用Jackson序列化器和反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, if port 8080 or port 8081 is not available on your computer, you can modify the dev
and test mode ports with application.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，如果端口8080或端口8081在你的电脑上不可用，你可以使用application.properties修改开发和测试模式的端口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, if port 8080 or port 8081 is not available on your computer, you can modify the dev and test mode ports with application.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，如果端口8080或端口8081在你的电脑上不可用，你可以使用application.properties修改开发和测试模式的端口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, if you declare</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，如果您声明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is one specific thing for AWS Gateway REST API deployments.
That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are
binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all
HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，对于AWS Gateway REST API的部署，有一件特别的事情。该API假定HTTP响应体是文本，除非你通过配置明确告诉它哪些媒体类型是二进制。为了使事情更简单，Quarkus扩展强制对所有的HTTP响应信息进行二进制（base 64）编码， `sam.yaml` 文件必须配置API网关，以假设所有的媒体类型都是二进制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，对于AWS Gateway REST API的部署，有一件特别的事情。该API假定HTTP响应体是文本，除非你通过配置明确告诉它哪些媒体类型是二进制。为了使事情更简单，Quarkus扩展强制对所有的HTTP响应信息进行二进制（base 64）编码， `sam.yaml` 文件必须配置API网关，以假设所有的媒体类型都是二进制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, when getting the `MongoCollection` from the database you can use directly the `Fruit` class instead of the `Document` one, the codec will automatically map the `Document` to/from your `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，当从数据库中获取 `MongoCollection` 时，你可以直接使用 `Fruit` 类，而不是 `Document` ，编解码器会自动将 `Document` 与 `Fruit` 类相互映射（从 `Fruit` 类映射 `Document` 或者将 `Document` 映射到 `Fruit` 类）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, write your test which will be executed in JVM mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后编写你的测试，它将在JVM模式下执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First compile it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先编译它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First declare your service as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先声明你的服务如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First let's define a few `QuarkusTestProfile` implementations like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先让我们定义这么几个 `QuarkusTestProfile` 实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，确保存在 `quarkus-vertx` 扩展。如果没有激活扩展，请执行如下命令来激活：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you need to add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，你需要添加以下依赖关系：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you need to create a Bson `Codec` that will tell Bson how to transform your entity to/from a MongoDB `Document`.
Here we use a `CollectibleCodec` as our object is retrievable from the database (it has a MongoDB identifier), if not we would have used a `Codec` instead.
More information in the codec documentation: https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先你需要创建一个Bson `Codec` ，它将告诉Bson如何将你的实体与MongoDB `Document` 的相互转化。这里我们使用一个 `CollectibleCodec` ，因为我们的对象可以从数据库中检索到（它有一个MongoDB标识符），如果不是这样，我们会使用一个 `Codec` 。更多信息见编解码器文档 https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you need to create a Bson `Codec` that will tell Bson how to transform your entity to/from a MongoDB `Document`.  Here we use a `CollectibleCodec` as our object is retrievable from the database (it has a MongoDB identifier), if not we would have used a `Codec` instead.  More information in the codec documentation: https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先你需要创建一个Bson `Codec` ，它将告诉Bson如何将你的实体与MongoDB `Document` 的相互转化。这里我们使用一个 `CollectibleCodec` ，因为我们的对象可以从数据库中检索到（它有一个MongoDB标识符），如果不是这样，我们会使用一个 `Codec` 。更多信息见编解码器文档 https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add the following test dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在您的应用程序中添加以下测试依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a `GreetingResource` JAX-RS resource in the
`src/main/java/org/acme/spring/boot/properties/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在 `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` 文件中创建一个包含如下内容的 `GreetingResource` JAX-RS资源:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a `GreetingResource` JAX-RS resource in the `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在 `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` 文件中创建一个包含如下内容的 `GreetingResource` JAX-RS资源:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a simple `GreetingResource` JAX-RS resource in the
`src/main/java/org/acme/spring/cloud/config/client/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在 `src/main/java/org/acme/spring/cloud/config/client/GreetingResource.java` 文件中创建一个简单的包含以下内容的 `GreetingResource` JAX-RS资源:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a simple `GreetingResource` JAX-RS resource in the `src/main/java/org/acme/spring/cloud/config/client/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在 `src/main/java/org/acme/spring/cloud/config/client/GreetingResource.java` 文件中创建一个简单的包含以下内容的 `GreetingResource` JAX-RS资源:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, download https://www.gutenberg.org/files/2600/2600-0.txt[War and Peace] and store it in `src/main/resources/book.txt`.
It's a 3.2 Mb file, which, while not being huge, illustrates the purpose of streams.
This time, we will not accumulate the file's content in memory and write it in one batch, but read it chunk by chunk and write these chunks into the HTTP response one by one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，下载 link:https://www.gutenberg.org/files/2600/2600-0.txt[《战争与和平] 》，并将其存储在 `src/main/resources/book.txt` 。这是一个3.2Mb的文件，虽然不是很大，但说明了流的用途。这一次，我们将不会把文件的内容堆积在内存中并一次性写入，而是逐块读取，并把这些块逐一写入到HTTP响应中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, download https://www.gutenberg.org/files/2600/2600-0.txt[War and Peace] and store it in `src/main/resources/book.txt`.  It's a 3.2 Mb file, which, while not being huge, illustrates the purpose of streams.  This time, we will not accumulate the file's content in memory and write it in one batch, but read it chunk by chunk and write these chunks into the HTTP response one by one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，下载 link:https://www.gutenberg.org/files/2600/2600-0.txt[《战争与和平] 》，并将其存储在 `src/main/resources/book.txt` 。这是一个3.2Mb的文件，虽然不是很大，但说明了流的用途。这一次，我们将不会把文件的内容堆积在内存中并一次性写入，而是逐块读取，并把这些块逐一写入到HTTP响应中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, go to https://code.quarkus.io[code.quarkus.io] and select the following extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，访问 https://code.quarkus.io[code.quarkus.io] 并选择以下扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, include one of the RESTEasy Reactive extensions to enable JAX-RS endpoints, for example, add the `io.quarkus:quarkus-resteasy-reactive-jackson` dependency for JAX-RS and JSON support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，请添加任意一个RESTEasy Reactive扩展的依赖，以启用JAX-RS端点，例如，添加支持JAX-RS和JSON的 `io.quarkus:quarkus-resteasy-reactive-jackson` 依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, include one of the RESTEasy extensions to enable JAX-RS endpoints, for example, add the `io.quarkus:quarkus-resteasy-reactive-jackson` dependency for JAX-RS and JSON support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，包括RESTEasy的一个扩展，以启用JAX-RS端点，例如，添加 `io.quarkus:quarkus-resteasy-reactive-jackson` 依赖来支持JAX-RS和JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's create the `Fruit` bean as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，让我们创建 `Fruit` 实体类，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's start the GraalVM container, noting the container id output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，让我们启动GraalVM容器，注意容器ID的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, libsunec.so, the C library used for the SSL implementation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先是libsunec.so，用于SSL实现的C库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, make sure you stopped the applications, and build both applications in JVM mode with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，确保你停止了应用程序，并在JVM模式下使用以下命令构建这两个应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new Kotlin project. This can be done using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要一个新的Kotlin项目。这可以通过以下命令来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project.
Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要一个新的工程项目。用以下命令创建一个新项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project.  Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要一个新的工程项目。用以下命令创建一个新项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project. Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要一个新的项目。使用以下命令创建一个新的项目:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create an instance of `WebClient`.
Extend the `VertxResource` class with the `client` field and the creation of the web client in the constructor:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要创建一个 `WebClient` 的实例。使用 client 字段扩展 `VertxResource` 类并在构造函数中创建 Web 客户端:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create an instance of `WebClient`.  Extend the `VertxResource` class with the `client` field and the creation of the web client in the constructor:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要创建一个 `WebClient` 的实例。使用 client 字段扩展 `VertxResource` 类并在构造函数中创建 Web 客户端:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create two projects: the _producer_ and the _processor_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要创建两个项目： _producer_ 和 _processor_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we will need to package it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，需要打包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you can consume messages from various brokers such as AMQP or Apache Kafka, and process these messages smoothly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，你可以从AMQP或Apache Kafka等各种代理那里消费消息，并顺利地处理这些消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you can create a BSON Codec which will be automatically registered by Quarkus and will be used instead of the `PojoCodecProvider`.
See this part of the documentation: xref:mongodb.adoc#simplifying-mongodb-client-usage-using-bson-codec[Using BSON codec].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，你可以创建一个BSON编解码器，它将被Quarkus自动注册，并代替 `PojoCodecProvider` 。见这部分文档。 link:mongodb.html#simplifying-mongodb-client-usage-using-bson-codec[使用BSON编解码器] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you can create a BSON Codec which will be automatically registered by Quarkus and will be used instead of the `PojoCodecProvider`.  See this part of the documentation: xref:mongodb.adoc#simplifying-mongodb-client-usage-using-bson-codec[Using BSON codec].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，你可以创建一个BSON编解码器，它将被Quarkus自动注册，并代替 `PojoCodecProvider` 。见这部分文档。 link:mongodb.html#simplifying-mongodb-client-usage-using-bson-codec[使用BSON编解码器] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to include the `quarkus-jsonb` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，您需要引入 `quarkus-jsonb` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First-Class Support for GraalVM Native Images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>优秀的对GraalVM原生镜像支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First: Locking using findById().</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一：通过findById()方法使用数据库锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First: an example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一：一个例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway and Hibernate ORM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway和Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway support relies on the Quarkus datasource config.
It can be customized for the default datasource as well as for every &lt;&lt;multiple-datasources,named datasource&gt;&gt;.
First, you need to add the datasource config to the `{config-file}` file
in order to allow Flyway to manage the schema.
Also, you can customize the Flyway behaviour by using the following properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway支持依赖于Quarkus的数据源配置。它可以为默认的数据源以及每个 link:#multiple-datasources[命名的数据源] 进行定制。首先，你需要将数据源配置添加到 `{config-file}` 文件中，以便让Flyway管理数据库模型。另外，你可以根据以下属性来设置Flyway。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway support relies on the Quarkus datasource config.  It can be customized for the default datasource as well as for every &lt;&lt;multiple-datasources,named datasource&gt;&gt;.  First, you need to add the datasource config to the `{config-file}` file in order to allow Flyway to manage the schema.  Also, you can customize the Flyway behaviour by using the following properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway支持依赖于Quarkus的数据源配置。它可以为默认的数据源以及每个 link:#multiple-datasources[命名的数据源] 进行定制。首先，你需要将数据源配置添加到 `{config-file}` 文件中，以便让Flyway管理数据库模型。另外，你可以根据以下属性来设置Flyway。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow Quarkus on Twitter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Twitter上关注Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the xref:hibernate-orm.adoc#setting-up-and-configuring-hibernate-orm[Hibernate set-up guide for all configuration].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>按照 link:hibernate-orm.html#setting-up-and-configuring-hibernate-orm[Hibernate 设置指南] 进行其他配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the same approach as described in the previous section, JSON-B can be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>按照上一节所述的相同方法，JSON-B可以使用 `io.quarkus.jsonb.JsonbConfigCustomizer` bean进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the same ideas, you can implement the other CRUD methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>遵循相同的思路，您可以实现其他CRUD方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following types can be injected as channels:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下类型可以作为 channels 被注入：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Confluent Schema Registry serde, that is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Confluent Schema Registry serde来说，就是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Docker:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Docker：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Gradle projects please &lt;&lt;gradle,see below&gt;&gt;, or for further reference consult the guide in the xref:gradle-tooling.adoc[Gradle setup page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Gradle项目，请 link:#gradle[见下文] ，或进一步参考 link:gradle-tooling.html[Gradle设置页面]中 的指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this
you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于HTTP，要覆盖的重要方法是 `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)` 。为此，你将根据你从 `APIGatewayV2HTTPEvent` 映射安全数据的方式来分配一个SecurityIdentity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于HTTP，要覆盖的重要方法是 `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)` 。为此，你将根据你从 `APIGatewayV2HTTPEvent` 映射安全数据的方式来分配一个SecurityIdentity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Kafka producer client serialization failures are not recoverable, thus the message dispatch is not retried. In these cases you may need to apply a failure strategy for the serializer.
To achieve this, you need to create a bean implementing `SerializationFailureHandler&lt;T&gt;` interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Kafka生产者客户端来说序列化失败是不可恢复的，因此消息发送不会被重试。在这些情况下，您可能需要为序列化器设置一个失败策略。为了实现这一点，您需要一个实现了 `SerializationFailureHandler&lt;T&gt;` 接口的bean：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Kafka producer client serialization failures are not recoverable, thus the message dispatch is not retried. In these cases you may need to apply a failure strategy for the serializer.  To achieve this, you need to create a bean implementing `SerializationFailureHandler&lt;T&gt;` interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Kafka生产者客户端来说序列化失败是不可恢复的，因此消息发送不会被重试。在这些情况下，您可能需要为序列化器设置一个失败策略。为了实现这一点，您需要一个实现了 `SerializationFailureHandler&lt;T&gt;` 接口的bean：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux &amp; MacOS users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>针对Linux和MacOS用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux and macOS users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Linux和macOS用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux hosts, execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Linux主机，执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux, macOS, and Windows (using WSL or bash compatible shell like Cygwin or MinGW)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Linux、macOS和Windows（使用WSL或bash兼容的shell，如Cygwin或MinGW）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Maven, add the following to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Maven，在你的 `pom.xml` 中添加以下内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For MongoDB with Panache, you could use the `@MongoEntity` annotation on your data class for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于带有Panache的MongoDB，你可以在你的数据类上使用 `@MongoEntity` 注解来实现这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this
you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于REST，要覆盖的重要方法是 `LambdaIdentityProvider.authenticate(AwsProxyRequest event)` 。为此，你将根据你从 `AwsProxyRequest` 映射安全数据的方式来分配一个SecurityIdentity。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于REST，要覆盖的重要方法是 `LambdaIdentityProvider.authenticate(AwsProxyRequest event)` 。为此，你将根据你从 `AwsProxyRequest` 映射安全数据的方式来分配一个SecurityIdentity。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Strimzi, you can select any image with a Kafka version which has Kraft support (2.8.1 and higher) from https://quay.io/repository/strimzi-test-container/test-container?tab=tags</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Strimzi，您可以从 https://quay.io/repository/strimzi-test-container/test-container?tab=tags ，选择任何可以获得Kraft支持的Kafka版本（2.8.1及以上）的镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Windows users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Windows用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Windows using Powershell</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>面向Windows使用Powershell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For `@QuarkusIntegrationTest` tests that result in launcher the application as a container, `io.quarkus.test.common.DevServicesContext` also provides access to the id of the container network on which the application container was launched (via the `containerNetworkId` method).
This can be used by `QuarkusTestResourceLifecycleManager` that need to launch additional containers that the application will communicate with.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于将应用程序作为容器启动的 `@QuarkusIntegrationTest` 测试，`io.quarkus.test.common.DevServicesContext` 也提供了对应用容器所启动的容器网络id的访问(通过 `containerNetworkId` 方法)。这可以被 `QuarkusTestResourceLifecycleManager` 使用来启动一些应用程序需要通信的其他容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For `@QuarkusIntegrationTest` tests that result in launcher the application as a container, `io.quarkus.test.common.DevServicesContext` also provides access to the id of the container network on which the application container was launched (via the `containerNetworkId` method).  This can be used by `QuarkusTestResourceLifecycleManager` that need to launch additional containers that the application will communicate with.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于将应用程序作为容器启动的 `@QuarkusIntegrationTest` 测试，`io.quarkus.test.common.DevServicesContext` 也提供了对应用容器所启动的容器网络id的访问(通过 `containerNetworkId` 方法)。这可以被 `QuarkusTestResourceLifecycleManager` 使用来启动一些应用程序需要通信的其他容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a full list of possible statuses, check our https://quarkus.io/faq/#extension-status[FAQ entry].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>想要了解完整的扩展状态信息，请查看 https://quarkus.io/faq/#extension-status[常见问题入口] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a given application instance, the number of consumers inside the consumer group can be configured using `mp.messaging.incoming.$channel.partitions` property.
The partitions of the subscribed topic will be divided among the consumer threads.
Note that if the `partitions` value exceed the number of partitions of the topic, some consumer threads won't be assigned any partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于一个给定的应用程序实例，消费者组内的消费者数量可以使用 `mp.messaging.incoming.$channel.partitions` 进行配置。被订阅的topic中的分区将会在所有的消费者线程间进行分配。请注意，如果 `partitions` 值超过topic本身的分区数量，那么某些消费者线程将得不到分区分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a given application instance, the number of consumers inside the consumer group can be configured using `mp.messaging.incoming.$channel.partitions` property.  The partitions of the subscribed topic will be divided among the consumer threads.  Note that if the `partitions` value exceed the number of partitions of the topic, some consumer threads won't be assigned any partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于一个给定的应用程序实例，消费者组内的消费者数量可以使用 `mp.messaging.incoming.$channel.partitions` 进行配置。被订阅的topic中的分区将会在所有的消费者线程间进行分配。请注意，如果 `partitions` 值超过topic本身的分区数量，那么某些消费者线程将得不到分区分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a more detailed guide about debugging native images please refer to the xref:native-reference.adoc[Native Reference Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于调试原生镜像的更详细指南，请参考 xref:native-reference.adoc[原生参考指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a regular JVM distribution you need to base your image off the official AWS Java base images. Below is an example of a Dockerfile that would create a container image from your Quarkus Lambda project. It assumes that `mvn package` has been executed and binaries are available in the `target/` directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于正常的JVM发行版，你需要在官方AWS Java基础镜像之上建立你的镜像。下面是一个Dockerfile的例子，它将从你的Quarkus Lambda项目创建一个容器镜像。它假设已经执行了 `mvn package` ，并且二进制文件已存在于 `target/` 目录中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For advanced configuration of the MongoDB client, you can follow the xref:mongodb.adoc#configuring-the-mongodb-database[Configuring the MongoDB database guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于MongoDB客户端的高级配置，你可以遵循配置 link:mongodb.html#configuring-the-mongodb-database[MongoDB数据库指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For applying retry mechanism on processing errors, see the section on &lt;&lt;retrying-processing&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于如何对错误处理应用重试机制，请参见 link:#retrying-processing[[重试-处理]] 一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each call you are intending to do, add a method and use annotations to describe the behavior.  You can combine the REST Client with the &lt;a href="https://quarkus.io/guides/smallrye-fault-tolerance"&gt;fault tolerance extension&lt;/a&gt; to handle failure gracefully.  Then, in your resource, just use the &lt;code&gt;ElementService&lt;/code&gt; interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于你打算做的每个调用，添加一个方法并使用注解来描述行为。您可以将REST客户端与&lt;a href="https://quarkus.io/guides/smallrye-fault-tolerance"&gt;容错扩展&lt;/a&gt;结合起来，以优雅地处理失败。然后，在你的资源中，只需使用&lt;code&gt;ElementService&lt;/code&gt;接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each channel, you can disable the checks using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于每个 channel ，您都可以禁用检查，通过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each chunk, we produce a String</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于每个块，我们生成一个字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For every authenticated resource, you can inject a `SecurityIdentity` instance to get the authenticated identity information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于每个认证资源，您可以注入一个 `SecurityIdentity` 实例来获得认证的身份信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，默认情况下，GraalVM中的反射将不能工作，除非类/成员已显式地为反射注册。这通常是通过列出JSON文件中的每个类、方法、字段和构造函数，并将其作为参数传递到原生镜像构建中实现的。显然，除了最简易的项目外，这对于所有项目来说都是相当麻烦的。Quarkus提供了一个框架，可以轻松地处理这些注解，并以编程的方式确定应该注册哪些内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，下面的代码演示了如何使用Hibernate与Panache将接收到的payload存储到数据库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, here is how you can use `keycloak.js` to authenticate the users and refresh the expired tokens from the SPA:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，以下是你如何使用 `keycloak.js` 来验证用户并从SPA中刷新过期的令牌：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you declare</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您声明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you need to send a message to a stream when receiving a POST request inside a REST endpoint.
In this case, you cannot use `@Outgoing` because your method has parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您需要在REST节点内收到一个POST请求时向一个流发送消息。在这种情况下，您无法使用 `@Outgoing` ，因为您的方法有参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you need to send a message to a stream when receiving a POST request inside a REST endpoint.  In this case, you cannot use `@Outgoing` because your method has parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您需要在REST节点内收到一个POST请求时向一个流发送消息。在这种情况下，您无法使用 `@Outgoing` ，因为您的方法有参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if your OpenID Connect provider sets a token audience then the following configuration pattern is recommended:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果你的OpenID Connect提供商设置了一个令牌受众，那么建议采用以下配置模式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, this defines the `@WithKubernetesTestServer` annotation, which you can use on your tests to activate the `KubernetesServerTestResource`,
but only for the annotated test class. You can also place them on your `QuarkusTestProfile` test profiles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，下面代码定义了 `@WithKubernetesTestServer` 注释，您可以在您的测试上使用它来激活 `KubernetesServerTestResource` ，但只针对被注释的测试类。您也可以把它们加入到您的 `QuarkusTestProfile` 测试profile中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, this defines the `@WithKubernetesTestServer` annotation, which you can use on your tests to activate the `KubernetesServerTestResource`, but only for the annotated test class. You can also place them on your `QuarkusTestProfile` test profiles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，下面代码定义了 `@WithKubernetesTestServer` 注释，您可以在您的测试上使用它来激活 `KubernetesServerTestResource` ，但只针对被注释的测试类。您也可以把它们加入到您的 `QuarkusTestProfile` 测试profile中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to configure the `max.block.ms` property, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，要配置 `max.block.ms` 属性，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to configure the `max.poll.records` property, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，要配置 `max.poll.records` 属性，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you can send to a dynamic address based on the incoming message:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，你可以根据传入的消息发送至一个动态地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you can use Docker to run your database:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，你可以使用Docker来运行你的数据库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For full Gradle details &lt;&lt;gradle, see below&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于Gradle的全部细节，link:#gradle[请见下文] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, having the following properties in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，在你的 `application.properties`中有以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>比如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details on the format of this file, please refer to https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于该文件格式的更多细节，请参考 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details please refer to the xref:logging.adoc#logging-adapters[Logging guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节请参考 xref:logging.adoc#logging-adapters[日志指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more examples, please consult the xref:mongodb-panache.adoc[Java version] for complete details.  Both APIs
are the same and work identically except for some Kotlin-specific tweaks to make things feel more natural to
Kotlin developers.  These tweaks include things like better use of nullability and the lack of `Optional` on API
methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于更多的例子，请参考 link:mongodb-panache.html[Java版本] 以获取完整详细信息。除了一些针对Kotlin的调整以使Kotlin开发者感觉更自然外，两个API都是一样的，工作方式也是一样的。这些调整包括更好地使用nullability和API方法上缺乏 `Optional` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more examples, please consult the xref:mongodb-panache.adoc[Java version] for complete details.  Both APIs are the same and work identically except for some Kotlin-specific tweaks to make things feel more natural to Kotlin developers.  These tweaks include things like better use of nullability and the lack of `Optional` on API methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于更多的例子，请参考 link:mongodb-panache.html[Java版本] 以获取完整详细信息。除了一些针对Kotlin的调整以使Kotlin开发者感觉更自然外，两个API都是一样的，工作方式也是一样的。这些调整包括更好地使用nullability和API方法上缺乏 `Optional` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about GraalVM resource handling in native executables please refer to https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于本地可执行文件中GraalVM资源处理的更多信息，请参考 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about OIDC authentication and authorization methods you can use to secure your Quarkus applications, see the following detailed resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于可以应用于保护Quarkus程序的OIDC认证和授权的更多方式，请看以下更详细的资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about Proxy Classes you can read https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于代理类的更多信息，你可以阅读 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about RESTEasy Reactive, please refer to the xref:resteasy-reactive.adoc[dedicated guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有关RESTEasy Reactive的更多信息，请参考 link:resteasy-reactive.html[专用指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about `--initialize-at-run-time`, please read https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于 `--initialize-at-run-time` 的更多信息，请阅读 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about `Basic` or `Form` HTTP-based authentication, see the following resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于基于 `Basic` 或 `Form` HTTP的认证的更多信息，请参阅一下资料：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about customizing Quarkus Security including reactive security, and how to register a security provider, see xref:security-customization.adoc[Security customization].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于定制Quarkus Security包括响应式Security的更多信息，以及如何注册一个安全提供者，请参见 link:security-customization.html[安全定制] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about the usage of a `QuarkusTestResourceLifecycleManager` please read xref:getting-started-testing.adoc#quarkus-test-resource[Quarkus test resource].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有关 `QuarkusTestResourceLifecycleManager` 的更多信息，请阅读 link:getting-started-testing.html#quarkus-test-resource[Quarkus测试资源] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information on receiving Cloud Events, see https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.12/amqp/amqp.html#_receiving_cloud_events[Receiving Cloud Events] in SmallRye Reactive Messaging documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于接收云事件的更多信息，请参阅SmallRye响应式消息文档中的 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.12/amqp/amqp.html#_receiving_cloud_events[接收云事件] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information on sending Cloud Events, see https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.12/amqp/amqp.html#_sending_cloud_events[Sending Cloud Events] in SmallRye Reactive Messaging documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于发送云事件的更多信息，请参阅SmallRye响应式消息文档中的 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.12/amqp/amqp.html#_sending_cloud_events[发送云事件] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, see the xref:security-openid-connect-client.adoc[OpenID Connect client and token propagation quickstart] and xref:security-openid-connect-client-reference.adoc[OpenID Connect (OIDC) and OAuth2 client and filters reference] guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息请参见《 link:security-openid-connect-client.html[使用OpenID Connect客户端和token传递quickstart] 》和 《 link:security-openid-connect-client-reference.htmlOpenID Connect (OIDC) 和 OAuth2 客户端以及过滤器参考] 》指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, see xref:security-jwt.adoc[Using SmallRye JWT role-based access control].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息请参见《 link:security-jwt.html[使用SmallRye JWT RBAC] 》指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more options, such as Homebrew or Chocolatey, see &lt;a href="/guides/cli-tooling"&gt;the Quarkus CLI guide&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多的选项，如Homebrew或Chocolatey，请参见&lt;a href="/guides/cli-tooling"&gt;Quarkus CLI指南&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For native image, however the URL Connection client must be preferred over the Apache HTTP Client
when using synchronous mode, due to issues in the GraalVM compilation (at present).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，对于原生镜像，由于GraalVM编译中的问题（目前），在使用同步模式时，URL Connection客户端必须优先于Apache HTTP客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For native image, however the URL Connection client must be preferred over the Apache HTTP Client when using synchronous mode, due to issues in the GraalVM compilation (at present).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，对于原生镜像，由于GraalVM编译中的问题（目前），在使用同步模式时，URL Connection客户端必须优先于Apache HTTP客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目前为止 `@TestHTTPResource` 允许您注入 `URI` 、 `URL` 以及 `String` 的URL表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For podman:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于podman：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For questions related to the development of Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于与Quarkus自身开发相关的问题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is
automatically set to 8081 by Quarkus, so you don't have to worry about setting this up.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了测试，Quarkus在端口8081下启动了一个单独的模拟事件服务器。Rest Assured的默认端口被Quarkus自动设置为8081，所以你不必担心设置这个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了测试，Quarkus在端口8081下启动了一个单独的模拟事件服务器。Rest Assured的默认端口被Quarkus自动设置为8081，所以你不必担心设置这个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and
`com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于AWS HTTP API，你可以注入AWS变量 `com.amazonaws.services.lambda.runtime.Context` 和 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` 。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于AWS HTTP API，你可以注入AWS变量 `com.amazonaws.services.lambda.runtime.Context` 和 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` 。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and
`io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于AWS REST API，你可以注入AWS变量 `com.amazonaws.services.lambda.runtime.Context` 和 `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext` 。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于AWS REST API，你可以注入AWS变量 `com.amazonaws.services.lambda.runtime.Context` 和 `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext` 。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了在应用程序启动时初始化数据库，我们将创建一个名为 `DBInit` 的类，其内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of these examples I am going to assume we have an endpoint that looks like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了演示这些例子的目的，这里将假设我们有一个类似于下面的节点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the sam template files, add the following to the YAML function Properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Sam模板文件，将以下内容添加到YAML函数属性中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the test class here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于测试类，这里有一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For these operations, you can express the update document the same way you express your queries, here are some examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于这些操作，你可以用表达查询的同样方式来表达更新文件，这里有一些例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this example, we'll use the Prometheus registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个例子中，我们将使用Prometheus registry。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this type of application, Quarkus relies on well-known standards such as JAX-RS, JPA and MicroProfile Rest Client, but also Hibernate with Panache to simplify interactions with databases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于这种类型的应用，Quarkus依赖于众所周知的标准，如JAX-RS、JPA和MicroProfile Rest Client，但也有Hibernate与Panache来简化与数据库的交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, you can use an `Emitter`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种情况下您可以使用 `Emitter` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, you need to create a class (a POJO) that will only contain the projected fields.
This POJO needs to be annotated with `@ProjectionFor(Entity.class)` where `Entity` is the name of your entity class.
The field names, or getters, of the projection class will be used to restrict which properties will be loaded from the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为此，你需要创建一个只包含映射字段的类（一个POJO）。这个POJO需要被注释为 `@ProjectionFor(Entity.class)` ，其中 `Entity` 是你的实体类的名称。映射类的字段名称或 getter 将用于限制将从数据库加载的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, you need to create a class (a POJO) that will only contain the projected fields.  This POJO needs to be annotated with `@ProjectionFor(Entity.class)` where `Entity` is the name of your entity class.  The field names, or getters, of the projection class will be used to restrict which properties will be loaded from the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为此，你需要创建一个只包含映射字段的类（一个POJO）。这个POJO需要被注释为 `@ProjectionFor(Entity.class)` ，其中 `Entity` 是你的实体类的名称。映射类的字段名称或 getter 将用于限制将从数据库加载的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For usage questions, we recommend to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于使用问题，我们建议到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For using `KafkaCompanion` API in tests, start by adding the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了在测试中使用 `KafkaCompanion` API，首先要添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For years, the client-server architecture has been the de-facto standard to build applications. But a significant shift happened. The &lt;em&gt;one model rules them all&lt;/em&gt; age is over. A new range of applications and architectural styles have emerged and transformed how code is written and how applications are deployed and executed. HTTP microservices, reactive applications, event-driven architecture, and serverless are now central players in modern systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多年来，客户端服务器（CS）架构一直是构建应用程序的事实标准。但是，一个重大的转变发生了。&lt;em&gt;一种模式统治一切&lt;/em&gt;的时代已经过去。一系列新的应用程序和架构风格已经出现，并改变了代码的编写方式以及应用程序的部署和执行方式。HTTP微服务、响应式应用、事件驱动架构和无服务器现在是现代系统的核心角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For your unit tests, you can also invoke on the mock event server using any HTTP client you want.  Here's an example
using rest-assured.  Quarkus starts up a separate Mock Event server under port 8081.
The default port for Rest Assured is automatically set to 8081 by Quarkus so you can invoke
on this endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于单元测试，你也可以使用任何你想要的HTTP客户端在模拟事件服务器上进行调用。下面是一个使用rest-assured的例子。Quarkus在端口8081上启动了一个单独的模拟事件服务器。Rest Assured的默认端口被Quarkus自动设为8081，所以你可以在这个端点上进行调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Forced JWK cache refresh interval in minutes which is used to restrict the frequency of the forced refresh attempts which may happen when the token verification fails due to the cache having no JWK key with a `kid` property matching the current token's `kid` header. It will be ignored unless the `mp.jwt.verify.publickey.location` points to the HTTP or HTTPS URL based JWK set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>强制刷新JWK缓存的时间间隔，以分钟为单位，用于限制强制刷新尝试的频率，这可能发生在令牌验证失败时，因为缓存中没有能与当前令牌带 `kid` 属性的JWK密钥，相匹配的 `kid` header。除非 `mp.jwt.verify.publickey.location` 指向基于HTTP或HTTPS URL的JWK集，否则它将被忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fork the [project repository](https://github.com/quarkusio/quarkusio.github.io), then clone your fork.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 [项目 repository](https://github.com/quarkusio/quarkusio.github.io)打分支，然后克隆您的 fork.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Found a security vulnerability in Quarkus, its extensions or the dependencies they use? See the &lt;a href="{{site.baseurl}}/security"&gt;security policy page&lt;/a&gt; to learn to report it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus、其扩展或其使用的依赖项中发现了安全漏洞？请参阅&lt;a href="{{site.baseurl}}/security"&gt;安全策略页面&lt;/a&gt;，了解如何报告它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From sequential to continuation style</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从顺序到延续风格</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the output above one can see that, in addition to the produced jar file and the associated lib directory, a text file named `native-image.args` was created.
This file holds all parameters (including the name of the JAR to compile) to pass along to GraalVM's `native-image` command.
If you have GraalVM installed, you can start the native compilation by executing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从上面的输出可以看出，除了生成的jar文件和相关的lib目录外，还创建了一个名为 `native-image.args` 的文本文件。这个文件包含了所有的参数（包括要编译的JAR的名字），以及传递给GraalVM的 `native-image` 命令。如果你已经安装了GraalVM，你可以通过执行以下命令开始本地编译：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the output above one can see that, in addition to the produced jar file and the associated lib directory, a text file named `native-image.args` was created.  This file holds all parameters (including the name of the JAR to compile) to pass along to GraalVM's `native-image` command.  If you have GraalVM installed, you can start the native compilation by executing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从上面的输出可以看出，除了生成的jar文件和相关的lib目录外，还创建了一个名为 `native-image.args` 的文本文件。这个文件包含了所有的参数（包括要编译的JAR的名字），以及传递给GraalVM的 `native-image` 命令。如果你已经安装了GraalVM，你可以通过执行以下命令开始本地编译：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the outset, Quarkus has been designed around a container-first philosophy. What this means in concrete terms is that Quarkus applications are optimised for low memory usage and fast startup times in the following ways:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从一开始，Quarkus的设计就围绕着容器优先的理念。这意味着Quarkus应用程序在以下方面进行了优化，以达到低内存使用和快速启动的目的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fully static native executables support is experimental.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>纯静态原生可执行文件支持是试验性的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functional tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>功能测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further simplification with `@InjectMock`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@InjectMock` 进行进一步简化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the `ObjectMapper` is configured to format dates and time in ISO-8601
(by disabling the `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外， `ObjectMapper` 被配置为ISO-8601的日期和时间格式（通过禁用 `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the `ObjectMapper` is configured to format dates and time in ISO-8601 (by disabling the `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外， `ObjectMapper` 被配置为ISO-8601的日期和时间格式（通过禁用 `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Future versions of Quarkus will configure the Kotlin compiler plugin in a way that will make it unnecessary to alter this configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的未来版本将以无需更改此配置文件的方式来配置Kotlin编译器插件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gauges measure a value that can increase or decrease over time, like the speedometer on a car. Gauges can be
useful when monitoring the statistics for a cache or collection. Consider the following simple example that
observes the size of a list:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gauges测量的是一个可以随时间增加或减少的数值，就像汽车上的车速表。Gauges在监控一个缓存或集合的统计数据时很有用。考虑下面这个观察列表大小的简单例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gauges measure a value that can increase or decrease over time, like the speedometer on a car. Gauges can be useful when monitoring the statistics for a cache or collection. Consider the following simple example that observes the size of a list:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gauges测量的是一个可以随时间增加或减少的数值，就像汽车上的车速表。Gauges在监控一个缓存或集合的统计数据时很有用。考虑下面这个观察列表大小的简单例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate X.509 certificates with Vault’s PKI Secret Engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Vault的PKI加密引擎生成X.509证书。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate a new `Command` based on the nodejs code available in https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 link:https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] 仓库中的Nodejs代码，生成一个新的 `Command`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GenerateToken main Driver Class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GenerateToken主驱动类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating Keys with OpenSSL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用OpenSSL生成密钥</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating a JWT</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成一个JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generation does not support collections such as `List&lt;Fruit&gt;`.
Refer to &lt;&lt;jackson-serialization&gt;&gt; to write your own serializer/deserializer for this case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成机制不支持诸如 `List&lt;Fruit&gt;` 这样的集合。请参考 link:#jackson-serialization[[jackson序列化]] 为这种情况编写您自己的序列化器/反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generation does not support collections such as `List&lt;Fruit&gt;`.  Refer to &lt;&lt;jackson-serialization&gt;&gt; to write your own serializer/deserializer for this case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成机制不支持诸如 `List&lt;Fruit&gt;` 这样的集合。请参考 link:#jackson-serialization[[jackson序列化]] 为这种情况编写您自己的序列化器/反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get Started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始体验</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get answers to some of your common Quarkus questions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>找到一些常见Quarkus问题的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get early test feedback with Continuous Testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过持续测试获得早期测试反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get instant feedback on code changes as tests run in the background on impacted code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当测试在后台对受影响的代码运行时，获得对代码变化的即时反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get it running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让它运行起来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get new and deeper views into Quarkus from the community through &lt;a href="{{site.baseurl}}/books"&gt;these great books&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 &lt;a href="{{site.baseurl}}/books"&gt;这些很棒的书&lt;/a&gt;，从社区获得对Quarkus新的、更深入的看法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Help from the Community</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从社区获得帮助</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入门指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started With Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started to SmallRye Reactive Messaging with AMQP 1.0</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye响应式消息与AMQP 1.0入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started to SmallRye Reactive Messaging with Apache Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始使用Apache Kafka的SmallRye响应式消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始使用gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting started with Quarkus Security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始使用Quarkus Security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given that, Panache already provides the necessary plumbing to transparently find the appropriate `EntityManager` associated to a Panache entity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>鉴于此，Panache已经提供了必要的管道， 可以透明地找到Panache实体类对应的 `EntityManager` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /api/foo` would match both permission sets' paths,
so would require both the `user` and `admin` roles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于上述权限集， `GET /api/foo` 符合两个权限集的路径，所以需要 `user` 和 `admin` 两个角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /api/foo` would match both permission sets' paths, so would require both the `user` and `admin` roles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于上述权限集， `GET /api/foo` 符合两个权限集的路径，所以需要 `user` 和 `admin` 两个角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /public/foo` would match both permission sets' paths,
but because it matches the `permit1` permission set's explicit method, `permit1` will be chosen and the request will
be accepted. `PUT /public/foo` on the other hand, will not match the method permissions of `permit1` and so
`deny1` will be activated and reject the request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于上述权限集， `GET /public/foo` 将与两个权限集的路径相匹配，但由于它与 `permit1` 权限集的明确方法相匹配， `permit1` 将被选择，请求将被接受。另外， `PUT /public/foo` 没有匹配到 `permit1` 的方法权限，因此 `deny1` 将被激活并拒绝请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /public/foo` would match both permission sets' paths, but because it matches the `permit1` permission set's explicit method, `permit1` will be chosen and the request will be accepted. `PUT /public/foo` on the other hand, will not match the method permissions of `permit1` and so `deny1` will be activated and reject the request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于上述权限集， `GET /public/foo` 将与两个权限集的路径相匹配，但由于它与 `permit1` 权限集的明确方法相匹配， `permit1` 将被选择，请求将被接受。另外， `PUT /public/foo` 没有匹配到 `permit1` 的方法权限，因此 `deny1` 将被激活并拒绝请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /public/foo` would match both the path and method and thus be allowed,
whereas `POST /public/foo` would match the path but not the method and would thus be rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于上述权限设置， `GET /public/foo` 同时匹配了路径和方法，因此被允许，而 `POST /public/foo` 匹配路径但不匹配方法，因此被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /public/foo` would match both the path and method and thus be allowed, whereas `POST /public/foo` would match the path but not the method and would thus be rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于上述权限设置， `GET /public/foo` 同时匹配了路径和方法，因此被允许，而 `POST /public/foo` 匹配路径但不匹配方法，因此被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /public/forbidden-folder/foo` would match both permission sets' paths,
but because it matches the `deny1` permission set's path on a longer match, `deny1` will be chosen and the request will
be rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于上述权限集， `GET /public/forbidden-folder/foo` 与两个权限集的路径相匹配，但由于 `deny1` 权限集的路径较长，所以 `deny1` 将被选择，请求将被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /public/forbidden-folder/foo` would match both permission sets' paths, but because it matches the `deny1` permission set's path on a longer match, `deny1` will be chosen and the request will be rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于上述权限集， `GET /public/forbidden-folder/foo` 与两个权限集的路径相匹配，但由于 `deny1` 权限集的路径较长，所以 `deny1` 将被选择，请求将被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given this simple entity:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供这个简单的实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Glossary</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>词汇表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go ahead and add the new field to the `GreetingProperties` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>继续在 `GreetingProperties` 类中添加新的字段:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go more in depth into the Quarkus implementation of CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更深入地了解Quarkus对CDI的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going further</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>进一步探索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gone are the days of a thousand configuration files and formats. A single configuration file is all it takes for Quarkus applications to configure every single extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>千篇一律的配置文件和格式的时代已经过去了。Quarkus应用程序只需要一个配置文件就可以配置每一个扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud BigQuery</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud BigQuery</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Bigtable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Bigtable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Firestore</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Firestore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x Web、Servlet或RESTEasy的Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud PubSub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud PubSub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Spanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Spanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Storage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Storage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM Native Executable support has been an essential part of the design for Quarkus from the beginning. When an application is compiled down to a native executable, it starts much faster and can run with a much smaller heap than a standard JVM. The native compiler uses aggressive dead-code elimination techniques to only embed the parts of the JVM and classes that are absolutely required by your application. Quarkus makes building optimized native executables plain easy. The build-time approach allows Quarkus to collect enough metadata on your application to fine-tune the compilation. No &lt;code&gt;-H:+ReportUnsupportedElementsAtRuntime&lt;/code&gt; flag, no fallback, no compromise!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM原生可执行文件支持从一开始就是Quarkus设计的重要组成部分。当一个应用程序被编译成一个原生可执行文件时，它的启动速度要快得多，并且可以在比标准JVM小得多的堆中运行。原生编译器使用积极的死代码消除技术，只嵌入JVM的部分和应用程序绝对需要的类。Quarkus使构建优化的原生可执行文件变得非常容易。构建时的方法允许Quarkus在你的应用程序上收集足够的元数据，以便对编译进行微调。没有&lt;code&gt;-H:+ReportUnsupportedElementsAtRuntime&lt;/code&gt;标志，没有回退，没有妥协！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM binaries are not (yet) notarized for macOS Catalina as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `gu`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM的二进制文件（尚未）对macOS Catalina进行认证，正如这个 https://github.com/oracle/graal/issues/1724[GralVM问题]中所报告的那样。这意味着您在使用 `gu` 时可能会看到以下错误：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM imposes a number of constraints and making your application a native executable might require a few tweaks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM施加了一些限制，使你的应用程序成为原生可执行文件可能需要进行一些调整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM version {graalvm-version} (be sure to install the Java 11 support) installed and xref:configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM的版本 {graalvm-version} （确保安装了Java 11支持）已安装并且 xref:configuring-graalvm[配置适当]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM versions can have different paths for these files, and whether you using the Java 8 or 11 version. Adjust accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于这些文件，GraalVM版本可能有不同的路径，不论你使用的是Java 8还是11版本。请做相应的调整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM, Docker or Podman installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想以本地模式运行，请确保已经安装GraalVM、Docker或Podman。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle (Groovy DSL)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle (Groovy DSL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle (Kotlin DSL)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，如果您使用Gradle Kotlin DSL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GreetingController</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GreetingController</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Group multiple configuration properties into an object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将多个配置属性分组到一个对象中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grouping properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分组属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Guides - Latest</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最新指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP Reference Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP参考文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP `quarkus-amazon-lambda-http` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP connector options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP 连接器选项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP proxy host.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP代理主机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP proxy port.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP代理端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling Deserialization Failures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反序列化失败的处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling Failures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling Serialization Failures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理序列化失败</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling security issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理安全问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hang Detection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>挂起侦测</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code is a no go (even if we all did it at some point ;-)). In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的代码中将值硬编码是行不通的（即使我们在某些时候都会这样做;-)）。在本指南中，我们学习如何配置你的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have a more in-depth look at how SmallRye Stork can be configured and used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更深入地了解如何配置和使用SmallRye Stork。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having `final` classes however does not work well with various frameworks that need to create https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[Dynamic Proxies].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，拥有 `final` 类并不能很好地与需要创建 link:https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[动态代理] 的各种框架配合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having such property groups brings more structure to your configuration.
This is especially useful when then number of properties grows.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样的属性分组可以为你的配置带来更加丰富的结构。当属性的数量增加时，这尤其有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having such property groups brings more structure to your configuration.  This is especially useful when then number of properties grows.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样的属性分组可以为你的配置带来更加丰富的结构。当属性的数量增加时，这尤其有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health Checks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>健康检查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health reporting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>健康报告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here `Message` properties class is defined as an inner class, but it could also be a top level class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里 `Message` 属性类被定义为一个内部类，但它也可以作为一个顶层类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here `text` field is public, but it could also be a private field with getter and setter or just a public getter in an interface.
Because `text` does not have a default value it is considered required and unless it is defined in a configuration file (`application.properties` by default)  your application will fail to start.
Define this property in your `src/main/resources/application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里 `text` 字段是公共的，但它也可以是一个带有getter和setter的私有字段，或者只是一个接口中的公共getter。因为 `text` 没有默认值，所以它被认为是必需的，除非它被定义在一个配置文件中（默认为 `application.properties` ），否则你的应用程序将无法启动。在你的 `src/main/resources/application.properties` 文件中定义该属性:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here `text` field is public, but it could also be a private field with getter and setter or just a public getter in an interface.  Because `text` does not have a default value it is considered required and unless it is defined in a configuration file (`application.properties` by default)  your application will fail to start.  Define this property in your `src/main/resources/application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里 `text` 字段是公共的，但它也可以是一个带有getter和setter的私有字段，或者只是一个接口中的公共getter。因为 `text` 没有默认值，所以它被认为是必需的，除非它被定义在一个配置文件中（默认为 `application.properties` ），否则你的应用程序将无法启动。在你的 `src/main/resources/application.properties` 文件中定义该属性:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are some query examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是一些查询例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of the usage of the flush method to allow making a specific action in case of `PersistenceException`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是一个使用 flush 方法的例子，它在捕获到 `PersistenceException` 异常时执行指定操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of using a `MongoCollection` with the `FruitCodec`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个将 `MongoCollection` 与 `FruitCodec` 一起使用的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here there are options, but we've chosen the `lateinit` approach.  This allows us to declare these fields as non-null
knowing they will be properly assigned either by the constructor (not shown) or by the MongoDB POJO codec loading data from the
database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里有一些选项，但我们选择了 `lateinit` 的方法。这允许我们将这些字段声明为非空，因为我们知道它们会被构造函数（未显示）或从数据库加载数据的MongoDB POJO编解码器正确分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here there are options, but we've chosen the `lateinit` approach.  This allows us to declare these fields as non-null knowing they will be properly assigned either by the constructor (not shown) or by the MongoDB POJO codec loading data from the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里有一些选项，但我们选择了 `lateinit` 的方法。这允许我们将这些字段声明为非空，因为我们知道它们会被构造函数（未显示）或从数据库加载数据的MongoDB POJO编解码器正确分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we are telling the Spy to return "hi" instead of "hello". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们令Spy返回 "hi "而不是 "hello"。当 `GreetingResource` 向 `GreetingService` 请求greeting时，我们得到的是mock的响应，而不是正常的 `GreetingService` Bean的响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we build the reply the same way as in the `hello` method but also add a value of the JWT `birthdate` claim by directly calling the injected `JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里，我们以与 `hello` 方法相同的方式建立回复，但也通过直接调用注入的 `JsonWebToken` ，添加JWT `birthdate` 要求的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we check if the call is insecure by checking the request user/caller `Principal` against null.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里，我们通过检查请求用户/呼叫者 `Principal` 是否是null值，如果是则不安全。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we check that the Principal and JsonWebToken have the same name since JsonWebToken does represent the current Principal.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们检查Principal和JsonWebToken是否有相同的名字，因为JsonWebToken代表了当前的Principal。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we get the Principal name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们得到了Principal的名字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we inject `JsonWebToken`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里，我们注入 `JsonWebToken`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we inject the JAX-RS SecurityContext to inspect the security state of the call and use a `getResponseString()` function to populate a response string.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们注入JAX-RS SecurityContext来检查调用的安全状态，并使用 `getResponseString()` 函数来得到响应字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we inject the JsonWebToken interface, an extension of the java.security.Principal
interface that provides access to the claims associated with the current authenticated token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们注入JsonWebToken接口，这是java.security.Principal接口的扩展，提供了对与当前认证令牌authenticated token相关声明的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we inject the JsonWebToken interface, an extension of the java.security.Principal interface that provides access to the claims associated with the current authenticated token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们注入JsonWebToken接口，这是java.security.Principal接口的扩展，提供了对与当前认证令牌authenticated token相关声明的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we inject the JsonWebToken.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们注入JsonWebToken。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we inject the `birthday` claim as `String` - this is why the `@RequestScoped` scope is now required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里，我们把 `birthday` 的声明(claim)作为 `String` 注入 - 这就是为什么现在需要 `@RequestScoped` 范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we use `var` but note that `val` can also be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们使用 `var` ，但注意也可以使用 `val` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we use the injected `birthday` claim to build the final reply.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里，我们使用注入的 `birthday` 声明(claim)来建立最终的回复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can find a list of Build Items and the extension that provides them:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里，您可以找到构建项目的列表以及提供它们的扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's how its mapped:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是它的映射方式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's the same example, but with the AWS Gateway REST API:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是同样的例子，但是使用了AWS Gateway REST API:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache simplifies the creation of CRUD applications based on JAX-RS and Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用Panache来操作Hibernate ORM REST数据，简化了基于JAX-RS和Hibernate ORM的CRUD应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Hibernate ORM with Panache focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，提供了全方位的对象关系映射（Object Relational Mapper，简称ORM）支持。它支持编写复杂的映射，但编写简单常用的映射却不够简便。Panache专注于简化Hibernate ORM实体，让你的Quarkus开发有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Panache focuses on making your entities trivial and fun to write.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，提供了全方位的对象关系映射支持。
它支持编写复杂的映射，但编写简单常用的映射却不够简便。
Panache专注于简化Hibernate ORM实体，让你的Quarkus开发有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.  It makes complex mappings possible, but it does not make simple and common mappings trivial.  Hibernate ORM with Panache focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，提供了全方位的对象关系映射（Object Relational Mapper，简称ORM）支持。它支持编写复杂的映射，但编写简单常用的映射却不够简便。Panache专注于简化Hibernate ORM实体，让你的Quarkus开发有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breath of an Object Relational Mapper. It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，为你提供了对象关系映射器的全部功能。它在Quarkus中工作得很好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM with Panache relies on compile-time bytecode enhancements to your entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM Panache依赖于编译时对实体类的字节码增强。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Reactive in Quarkus currently does not support multiple persistence units.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus中的Hibernate Reactive目前不支持多个持久化单元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Reactive with Panache relies on compile-time bytecode enhancements to your entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Reactive Panache依赖于编译时对实体类的字节码增强。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate搜索+Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search allows you to index your entities in an Elasticsearch cluster and easily offer full text search in all your Hibernate ORM-based applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Search允许你在Elasticsearch集群中索引你的实体，并在你所有基于Hibernate ORM的应用程序中轻松提供全文搜索。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate is very general-purpose, but does not make it trivial to do trivial operations that make up 90% of our
model usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate很通用，但对于模型里90%的琐碎操作，编写起来并不简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate is very general-purpose, but does not make it trivial to do trivial operations that make up 90% of our model usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate很通用，但对于模型里90%的琐碎操作，编写起来并不简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate queries are super powerful, but overly verbose for common operations, requiring you to write queries even
when you don't need all the parts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate查询功能很强大，但对于普通操作来说过于冗长，即使是简单操作也要求写完整的HQL语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate queries are super powerful, but overly verbose for common operations, requiring you to write queries even when you don't need all the parts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate查询功能很强大，但对于普通操作来说过于冗长，即使是简单操作也要求写完整的HQL语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.
This is also called **dynamic instantiation** or **constructor expression**, more info can be found on the Hibernate guide:
link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate会使用 *DTO投影* ，并根据投影的类的属性生成SELECT子句。这也被称为 *动态实例化* 或 *构造器表达* ，更多信息可以在Hibernate指南中找到： link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[HQL select子句]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.  This is also called **dynamic instantiation** or **constructor expression**, more info can be found on the Hibernate guide: link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate会使用 *DTO投影* ，并根据投影的类的属性生成SELECT子句。这也被称为 *动态实例化* 或 *构造器表达* ，更多信息可以在Hibernate指南中找到： link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[HQL select子句]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application, or keep it running and enjoy the blazing fast hot-reload.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `CTRL+C` ，停止应用程序，或保持运行，享受极快的热重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `CTRL+C` 来停止应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hopefully, this will change in the future and make the error more obvious.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>希望这在将来会有所改变，使错误更加明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How and why we simplify Hibernate ORM mappings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们为什么简化Hibernate ORM映射？怎么做到的？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How and why we simplify Hibernate Reactive mappings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们为什么简化Hibernate Reactive映射？怎么做到的？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How and why we simplify MongoDB API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们如何以及为什么要简化MongoDB的API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How capabilities are implemented and used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus中如何实现和使用功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How dev mode differs from a production application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式与生产应用程序有何不同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to Add SmallRye JWT directly</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何直接添加SmallRye JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to Create Quarkus Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何创建Quarkus文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to check the errors in the logs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何检查日志中的错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to use 'client-id' property</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何使用 `client-id` 属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to use custom Redis Commands</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何使用自定义Redis命令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, HTTP characteristics prohibit implementing &lt;a href="https://www.reactivemanifesto.org/"&gt;reactive systems&lt;/a&gt;, where all the components interact using asynchronous messages passing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，HTTP的特性禁止实现&lt;a href="https://www.reactivemanifesto.org/"&gt;响应式系统&lt;/a&gt;，即所有组件都使用异步消息传递进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, `@RequestScoped` must be used when the individual token claims are injected as simple types such as `String`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，当单个令牌要求被注入为简单的类型，例如 `String` ，必须使用 `@RequestScoped` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, there could be cases where JWT tokens must be verified via the introspection only. It can be forced by configuring an introspection endpoint address only, for example, in case of Keycloak you can do it like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，在某些情况下，JWT令牌必须只通过自省来验证。它可以通过配置一个自省端点地址来强制进行，例如，在Keycloak的情况下，你可以这样做：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the
xref:maven-tooling.adoc#multi-module-maven[Maven] or xref:gradle-tooling.adoc#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不过，在处理多模块项目时，请务必阅读 link:maven-tooling.html#multi-module-maven[Maven] 或 link:gradle-tooling.html#multi-module-maven[Gradle] 指南中的 `多模块项目` 部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the xref:maven-tooling.adoc#multi-module-maven[Maven] or xref:gradle-tooling.adoc#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不过，在处理多模块项目时，请务必阅读 link:maven-tooling.html#multi-module-maven[Maven] 或 link:gradle-tooling.html#multi-module-maven[Gradle] 指南中的 `多模块项目` 部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，你可以直接进入完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I could mock it with the following class in `src/test/java`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我可以在 `src/test/java` 中用以下类来mock它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I don't need transaction when I do read only operations, it's faster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当我做只读操作时，就不需要事务，这样会更快</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IAM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IAM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ID Generator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ID生成器（ID Generator）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IDs are often a touchy subject, and not everyone's up for letting them handled by the framework, once again we
have you covered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ID往往是一个敏感的话题，并不是所有人都愿意让框架来处理，因此我们提供了相应的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IDs are often a touchy subject, and not everyone's up for letting them handled by the framework, once again we have you covered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ID往往是一个敏感的话题，并不是所有人都愿意让框架来处理，因此我们提供了相应的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IDs are often a touchy subject. In MongoDB, they are usually auto-generated by the database with an `ObjectId` type.
In MongoDB with Panache the ID are defined by a field named `id` of the `org.bson.types.ObjectId` type,
but if you want to customize them, once again we have you covered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ID往往是一个敏感的话题。在MongoDB中，，它们通常由数据库以 `ObjectId` 类型自动生成。 在带有 Panache 的 MongoDB 中，ID是由一个名为 `org.bson.types.ObjectId` 类型的名为 `id` 的字段定义的，但如果你想自定义它们，我们再次为您提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IDs are often a touchy subject. In MongoDB, they are usually auto-generated by the database with an `ObjectId` type.  In MongoDB with Panache the ID are defined by a field named `id` of the `org.bson.types.ObjectId` type, but if you want to customize them, once again we have you covered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ID往往是一个敏感的话题。在MongoDB中，，它们通常由数据库以 `ObjectId` 类型自动生成。 在带有 Panache 的 MongoDB 中，ID是由一个名为 `org.bson.types.ObjectId` 类型的名为 `id` 的字段定义的，但如果你想自定义它们，我们再次为您提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identifier of a CDI bean that provides the default Kafka consumer/producer configuration for this channel. The channel configuration can still override any attribute. The bean must have a type of Map&lt;String, Object&gt; and must use the @io.smallrye.common.annotation.Identifier qualifier to set the identifier.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为通道提供默认Kafka消费者/生产者配置的CDI bean的标识符。通道自身的配置仍可以覆盖任何属性。该bean必须有一个Map&lt;String, Object&gt;的类型，并且必须使用@io.smallrye.common.annotation.Identifier限定符来设置标识符。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>身份提供者（Identity Providers）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If UserInfo is the source of the roles then set `quarkus.oidc.authentication.user-info-required=true` and `quarkus.oidc.roles.source=userinfo`, and if needed, `quarkus.oidc.roles.role-claim-path`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用UserInfo为角色的来源，那么要设置 `quarkus.oidc.authentication.user-info-required=true` 和 `quarkus.oidc.roles.source=userinfo` ，如果需要的话，设置 `quarkus.oidc.roles.role-claim-path` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `groups` claim is available then its value is used</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果存在 `groups` 声明，则这个声明的值会被使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `kafka-configuration` is set and no `Map` can be found, the deployment fails.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置了 `kafka-configuration` ，但没有找到 `Map` ，则部署会失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `quarkus.oidc.roles.role-claim-path` property is set and matching array or string claims are found then the roles are extracted from these claims.
For example, `customroles`, `customroles/array`, `scope`, `"http://namespace-qualified-custom-claim"/roles`, `"http://namespace-qualified-roles"`, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `quarkus.oidc.roles.role-claim-path` 属性被设置，并且找到匹配的数组或字符串声明，那么角色将从这些声明中提取。例如， `customroles` , `customroles/array` , `scope` , `"http://namespace-qualified-custom-claim"/roles` , `"http://namespace-qualified-roles"` , 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `quarkus.oidc.roles.role-claim-path` property is set and matching array or string claims are found then the roles are extracted from these claims.  For example, `customroles`, `customroles/array`, `scope`, `"http://namespace-qualified-custom-claim"/roles`, `"http://namespace-qualified-roles"`, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `quarkus.oidc.roles.role-claim-path` 属性被设置，并且找到匹配的数组或字符串声明，那么角色将从这些声明中提取。例如， `customroles` , `customroles/array` , `scope` , `"http://namespace-qualified-custom-claim"/roles` , `"http://namespace-qualified-roles"` , 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `realm_access/roles` or `resource_access/client_id/roles` (where `client_id` is the value of the `quarkus.oidc.client-id` property) claim is available then its value is used.
This check supports the tokens issued by Keycloak</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `realm_access/roles` 或 `resource_access/client_id/roles` （其中 `client_id` 是 `quarkus.oidc.client-id` 属性的值）声明是存在的，那么它的值会被使用。该检查支持由Keycloak发行的令牌</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `realm_access/roles` or `resource_access/client_id/roles` (where `client_id` is the value of the `quarkus.oidc.client-id` property) claim is available then its value is used.  This check supports the tokens issued by Keycloak</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `realm_access/roles` 或 `resource_access/client_id/roles` （其中 `client_id` 是 `quarkus.oidc.client-id` 属性的值）声明是存在的，那么它的值会被使用。该检查支持由Keycloak发行的令牌</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a `client.id` is not provided, it is generated as `kafka-consumer-[channel][-index]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有提供 `client.id` ，则使用 `kafka-consumer-[channel][-index]` 来生成 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a `client.id` is provided, it is used as-is or suffixed with client index if `partitions` property is set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果提供了一个 `client.id` ，它将直接被使用， 或者如果 `partitions` 属性被设置的话，则会被加上客户端索引的后缀。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a custom realm file has to be imported into Keycloak before running the tests then you can configure `Dev Services for Keycloak` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在运行测试前必须将自定义领域文件导入Keycloak，那么你可以按以下方式配置 `Keycloak开发服务` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a message produced from a Kafka record is nacked, a failure strategy is applied. The Kafka connector supports three strategies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果从Kafka record中产生的消息未被确认，那么一个失败策略就会被启用。Kafka connector支持三种策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a message produced from an AMQP message is _nacked_, a failure strategy is applied.
The AMQP connector supports six strategies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个由AMQP消息产生的消息是 _nacked_ ，就会应用一个失败策略。AMQP连接器支持六种策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a message produced from an AMQP message is _nacked_, a failure strategy is applied.  The AMQP connector supports six strategies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个由AMQP消息产生的消息是 _nacked_ ，就会应用一个失败策略。AMQP连接器支持六种策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a method annotated with `@ConsumeEvent` throws an exception, then:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个用 `@ConsumeEvent` 注解的方法抛出一个异常，那么：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a path is registered with multiple permission sets then any permission sets that specify an HTTP method will take
precedence and permissions sets without a method will not be considered (assuming of course the method matches). In this
instance, the permission sets without methods will only come into effect if the request method does not match any of the
sets with method permissions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个路径被注册了多个权限集，那么任何指定了HTTP方法的权限集将被优先考虑，没有指定方法的权限集将不被考虑 (当然, 假设方法匹配的话)。在这种情况下，没有指定方法的权限集只有在请求方法与任何有方法权限的权限集不匹配时才会生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a path is registered with multiple permission sets then any permission sets that specify an HTTP method will take precedence and permissions sets without a method will not be considered (assuming of course the method matches). In this instance, the permission sets without methods will only come into effect if the request method does not match any of the sets with method permissions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个路径被注册了多个权限集，那么任何指定了HTTP方法的权限集将被优先考虑，没有指定方法的权限集将不被考虑 (当然, 假设方法匹配的话)。在这种情况下，没有指定方法的权限集只有在请求方法与任何有方法权限的权限集不匹配时才会生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a record cannot be written, the message is nacked.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一条记录无法写入，消息就会被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a request would match one or more permission sets based on the path, but does not match any due to method requirements
then the request is rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个请求匹配了一个或多个基于路径的权限集，但由于方法不匹配，那么该请求将被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a request would match one or more permission sets based on the path, but does not match any due to method requirements then the request is rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个请求匹配了一个或多个基于路径的权限集，但由于方法不匹配，那么该请求将被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a serializer/deserializer is set by configuration, it won't be replaced by the autodetection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个序列化器/反序列化器是通过配置设置的，那么它不会被自动检测所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a topic already exists with the given name, the creation is skipped,
without trying to re-partition the existing topic to a different number of partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果具有某个指定名称的主题已经存在，那么创建会被跳过，并且不会尝试对已经存在的主题重新分区到不同的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a topic already exists with the given name, the creation is skipped, without trying to re-partition the existing topic to a different number of partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果具有某个指定名称的主题已经存在，那么创建会被跳过，并且不会尝试对已经存在的主题重新分区到不同的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a transaction is already associated with the current thread a `QuarkusTransactionException` will be thrown,
otherwise a new transaction is started, and follows all the normal lifecycle rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个事务已经与当前线程相关联，将抛出一个 `QuarkusTransactionException` ，否则将启动一个新的事务，并遵循所有正常的生命周期规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a transaction is already associated with the current thread a `QuarkusTransactionException` will be thrown, otherwise a new transaction is started, and follows all the normal lifecycle rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个事务已经与当前线程相关联，将抛出一个 `QuarkusTransactionException` ，否则将启动一个新的事务，并遵循所有正常的生命周期规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If all is well quarkus will log:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一切顺利的话，quarkus 会输出以下日志：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an AMQP message is rejected/released/modified by the broker (or cannot be sent successfully), the message is nacked.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个AMQP消息被代理拒绝/释放/修改（或不能成功发送），那么该消息是不被认可的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an application relies on `java.security.Principal` returning a name then a token must have a `upn` or `preferred_username` or `sub` claim set. Setting this property will result in SmallRye JWT throwing an exception if none of these claims is available for the application code to reliably deal with a non-null `Principal` name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个应用程序依赖于 `java.security.Principal` ，返回一个名称，那么一个标记必须有一个 `upn` 、 `preferred_username` 或 `sub` 的声明集。如果应用程序代码没有这些要求来可靠地处理非空的 `Principal` 名称，设置此属性将导致SmallRye JWT抛出一个异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an extension for schema registry, such as `quarkus-apicurio-registry-avro` or `quarkus-confluent-registry-avro`, is present, Dev Services for Apicurio Registry automatically starts an Apicurio Registry instance in dev mode and when running tests.
Also, all Kafka channels in SmallRye Reactive Messaging are automatically configured to use this registry.
This automatic configuration only applies to serializers and deserializers from Apicurio Registry serde libraries and Confluent Schema Registry serde libraries, because there properties are set:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果存在模式注册表的扩展，如 `quarkus-apicurio-registry-avro` 或 `quarkus-confluent-registry-avro` ，则Apicurio注册表的开发服务会在开发模式下和运行测试时自动启动一个Apicurio注册表实例。此外，SmallRye 响应式消息中的所有Kafka通道都被自动配置为使用该注册表。这个自动配置只适用于Apicurio Registry serde库和Confluent Schema Registry serde库的序列化器和反序列化器，因为设置了以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an extension for schema registry, such as `quarkus-apicurio-registry-avro` or `quarkus-confluent-registry-avro`, is present, Dev Services for Apicurio Registry automatically starts an Apicurio Registry instance in dev mode and when running tests.  Also, all Kafka channels in SmallRye Reactive Messaging are automatically configured to use this registry.  This automatic configuration only applies to serializers and deserializers from Apicurio Registry serde libraries and Confluent Schema Registry serde libraries, because there properties are set:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果存在模式注册表的扩展，如 `quarkus-apicurio-registry-avro` 或 `quarkus-confluent-registry-avro` ，则Apicurio注册表的开发服务会在开发模式下和运行测试时自动启动一个Apicurio注册表实例。此外，SmallRye 响应式消息中的所有Kafka通道都被自动配置为使用该注册表。这个自动配置只适用于Apicurio Registry serde库和Confluent Schema Registry serde库的序列化器和反序列化器，因为设置了以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Kafka-related extension is present (e.g. `quarkus-smallrye-reactive-messaging-kafka`), Dev Services for Kafka automatically starts a Kafka broker in dev mode and when running tests.
So, you don't have to start a broker manually.
The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果有任何Kafka相关的扩展（如 `quarkus-smallrye-reactive-messaging-kafka` ），Kafka开发服务会在开发模式和运行测试时自动启动一个Kafka broker。所以您不需要手动启动broker。这是由应用程序是自动配置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Kafka-related extension is present (e.g. `quarkus-smallrye-reactive-messaging-kafka`), Dev Services for Kafka automatically starts a Kafka broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果有任何Kafka相关的扩展（如 `quarkus-smallrye-reactive-messaging-kafka` ），Kafka开发服务会在开发模式和运行测试时自动启动一个Kafka broker。所以您不需要手动启动broker。这是由应用程序是自动配置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If both are present, Quarkus prioritizes configuration properties from the YAML file first and then from the
Properties file. However, to avoid confusion, we recommend removing the Properties file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果两者都存在，Quarkus会优先考虑YAML文件中的配置属性，接着是 Properties 文件中的配置属性。然而，为了避免混淆，我们建议删除 Properties 文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If both are present, Quarkus prioritizes configuration properties from the YAML file first and then from the Properties file. However, to avoid confusion, we recommend removing the Properties file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果两者都存在，Quarkus会优先考虑YAML文件中的配置属性，接着是 Properties 文件中的配置属性。然而，为了避免混淆，我们建议删除 Properties 文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If by any means you need to use a custom resource or one that is provided by one of the https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK Extensions]
you can create multiple resource producers. The OpenTelemetry extension will detect the `Resource` CDI beans and will merge them when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果通过您需要的任何方式来使用自定义的资源或由 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK扩展] 之一提供的资源，您可以创建多个资源生产者。OpenTelemetry扩展将检测 `Resource` CDI beans，并在配置tracer生成器时将其合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If by any means you need to use a custom resource or one that is provided by one of the https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK Extensions] you can create multiple resource producers. The OpenTelemetry extension will detect the `Resource` CDI beans and will merge them when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果通过您需要的任何方式来使用自定义的资源或由 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK扩展] 之一提供的资源，您可以创建多个资源生产者。OpenTelemetry扩展将检测 `Resource` CDI beans，并在配置tracer生成器时将其合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If defined on a class, it is equivalent to defining it on all the methods of the class marked with `@Transactional`.
The configuration defined on a method takes precedence over the configuration defined on a class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在一个类上定义，就相当于在该类所有标有 `@Transactional` 的方法上定义了它。在方法上定义的配置优先于在类上定义的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If defined on a class, it is equivalent to defining it on all the methods of the class marked with `@Transactional`.  The configuration defined on a method takes precedence over the configuration defined on a class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在一个类上定义，就相当于在该类所有标有 `@Transactional` 的方法上定义了它。在方法上定义的配置优先于在类上定义的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If enabled, consumer's offset will be periodically committed in the background by the underlying Kafka client, ignoring the actual processing outcome of the records. It is recommended to NOT enable this setting and let Reactive Messaging handles the commit.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果启用，消费者的偏移量将由底层Kafka客户端在后台定期提交，并忽略记录的实际处理结果。建议不要启用这个设置，而是由Reactive Messaging来处理提交。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for example a custom serializer named `FooSerializer` for type `com.example.Foo` needs to be registered with JSON-B, the addition of a bean like the following would suffice:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果需要使用 JSON-B 注册类型为 `com.example.Foo` 的名为 `FooSerializer` 的自定义序列化程序，则添加如下所示的 bean 就足够了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for some reason adding the aforementioned configuration to `application.properties` is not desirable, it is possible to configure the build tool to effectively perform the same operation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果由于某种原因，将上述配置添加到 `application.properties` ，是不可取的，可以通过配置构建工具来有效地执行相同的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for whatever reason, the aforementioned solution is deemed unacceptable, there are alternatives.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果由于某种原因，上述解决方案被认为是不可接受的，那么还有其他选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If globs are not sufficiently precise for your use case and you need to rely on regular expressions or if you prefer relying on the GraalVM infrastructure,
you can also create a `resources-config.json` (the most common location is within `src/main/resources`) JSON file defining which resources should be included:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果globs对于你的使用情况来说不够精确，你需要依靠正则表达式，或者你更喜欢依靠GraalVM的基础设施，你也可以创建一个 `resources-config.json` (最常见的位置是在`src/main/resources`) JSON文件，定义哪些资源应该被包含：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If globs are not sufficiently precise for your use case and you need to rely on regular expressions or if you prefer relying on the GraalVM infrastructure, you can also create a `resources-config.json` (the most common location is within `src/main/resources`) JSON file defining which resources should be included:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果globs对于你的使用情况来说不够精确，你需要依靠正则表达式，或者你更喜欢依靠GraalVM的基础设施，你也可以创建一个 `resources-config.json` (最常见的位置是在`src/main/resources`) JSON文件，定义哪些资源应该被包含：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If in the DTO projection object you have a field from a referenced entity, you can use the `@ProjectedFieldName` annotation to provide the path for the SELECT statement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果DTO投影对象中有来自引用的实体字段，可以使用 `@ProjectedFieldName` 注解指定SELECT语句使用的查询路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is the case in your production then it can be recommended that the token introspection and `UserInfo` data are cached for a short period of time, for example, for 3 or 5 minutes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在你的生产中有这种情况，那么可以建议将令牌自省和 `UserInfo` 数据缓存一小段时间，例如，3或5分钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If multiple permission sets specify the same path and method (or multiple have no method) then both permissions have to
allow access for the request to proceed. Note that for this to happen both have to either have specified the method, or
have no method, method specific matches take precedence as stated above:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果多个权限组指定了相同的路径和方法(或者多个权限组没有指定方法)， 那么这两个权限都必须允许访问才能使请求被处理。请注意，要做到这一点，两个权限要么都必须指定方法，要么都不指定方法。这里就如之前所述那样，有具体的方法匹配会优先：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If multiple permission sets specify the same path and method (or multiple have no method) then both permissions have to allow access for the request to proceed. Note that for this to happen both have to either have specified the method, or have no method, method specific matches take precedence as stated above:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果多个权限组指定了相同的路径和方法(或者多个权限组没有指定方法)， 那么这两个权限都必须允许访问才能使请求被处理。请注意，要做到这一点，两个权限要么都必须指定方法，要么都不指定方法。这里就如之前所述那样，有具体的方法匹配会优先：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no transaction is active then a new transaction will be started, and committed when the method ends.
If an exception is thrown the exception handler registered by `#exceptionHandler(Function)` will be called to
decide if the TX should be committed or rolled back.
If an existing transaction is active then the method is run in the context of the existing transaction. If an
exception is thrown the exception handler will be called, however
a result of `ExceptionResult#ROLLBACK` will result in the TX marked as rollback only, while a result of
`ExceptionResult#COMMIT` will result in no action being taken.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有活动的事务，那么一个新的事务将被启动，并在方法结束时提交。如果一个异常被抛出，由 `#exceptionHandler(Function)` 注册的异常处理程序将被调用，以决定TX是否应该被提交或回滚。如果一个现有的事务处于活动状态，那么该方法将在现有事务的背景下运行。如果抛出一个异常，将调用异常处理程序，但是 `ExceptionResult#ROLLBACK` 的结果将导致TX被标记为回滚，而 `ExceptionResult#COMMIT` 的结果将导致不采取任何行动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no transaction is active then a new transaction will be started, and committed when the method ends.  If an exception is thrown the exception handler registered by `#exceptionHandler(Function)` will be called to decide if the TX should be committed or rolled back.  If an existing transaction is active then the method is run in the context of the existing transaction. If an exception is thrown the exception handler will be called, however a result of `ExceptionResult#ROLLBACK` will result in the TX marked as rollback only, while a result of `ExceptionResult#COMMIT` will result in no action being taken.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有活动的事务，那么一个新的事务将被启动，并在方法结束时提交。如果一个异常被抛出，由 `#exceptionHandler(Function)` 注册的异常处理程序将被调用，以决定TX是否应该被提交或回滚。如果一个现有的事务处于活动状态，那么该方法将在现有事务的背景下运行。如果抛出一个异常，将调用异常处理程序，但是 `ExceptionResult#ROLLBACK` 的结果将导致TX被标记为回滚，而 `ExceptionResult#COMMIT` 的结果将导致不采取任何行动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no transaction is active then this semantic is basically a no-op.
If a transaction is active then it is suspended, and resumed after the task is run.
The exception handler will never be consulted when this semantic is in use, specifying both an exception handler and
this semantic is considered an error.
This semantic allows for code to easily be run outside the scope of a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有事务处于活动状态，那么这个语义基本上就是一个无用功。如果一个事务处于活动状态，那么它就会被暂停，并在任务运行之后恢复。在使用这种语义的时候，将永远不会查询异常处理程序，同时指定异常处理程序和这种语义被认为是一个错误。这种语义允许在事务的范围之外轻松地运行代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, `key.deserializer` is set to `org.apache.kafka.common.serialization.StringDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置， `key.deserializer` 则会被设置为 `org.apache.kafka.common.serialization.StringDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, `key.serializer` is set to `org.apache.kafka.common.serialization.StringSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置， `key.serializer` 则会被设置为 `org.apache.kafka.common.serialization.StringSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, `reconnect.backoff.max.ms` is set to `10000` to avoid high load on disconnection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置， `reconnect.backoff.max.ms` 则会被配置为 `10000` ，以避免断开时导致的高负载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, producer `client.id` is generated as `kafka-producer-[channel]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置，生产者 `client.id` 则会按照 `kafka-producer-[channel]` 来生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, the address is the fully qualified name of the bean; for instance, in this snippet, it's `org.acme.vertx.GreetingService`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置，地址是Bean的完全限定名称；例如，在这个片段中，它是 `org.acme.vertx.GreetingService` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果这些扩展之一是存在的，那么为原生可执行文件创建一个容器镜像基本上就是执行一个命令的问题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If running `gdb` from a different directory than `target`, then the sources can be loaded by running:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果从与 `target` 不同的目录下运行 `gdb` ，那么可以通过运行源代码加载：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If set to a positive number, the connector will try to resend any record that was not delivered successfully (with a potentially transient error) until the number of retries is reached. If set to 0, retries are disabled. If not set, the connector tries to resend any record that failed to be delivered (because of a potentially transient error) during an amount of time configured by `delivery.timeout.ms`.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置为正数，连接器将尝试重新发送任何没有成功传递的记录（有可能是瞬时错误），直到达到重试的上限。如果设置为0，重试将被禁用。如果不设置，连接器会在 `delivery.timeout.ms` 配置的时间内，尝试重新发送任何未能交付的记录（由于潜在的瞬时错误）。

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If set to true, the access will be denied for all JAX-RS endpoints by default, so if a JAX-RS endpoint does not have any security annotations
then it will default to `@DenyAll` behaviour. This is useful to ensure you cannot accidentally expose an endpoint that is supposed to be secured. Defaults to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设为 true，默认情况下将拒绝所有 JAX-RS 节点的访问，所以如果一个 JAX-RS 节点没有任何安全注解，那么它将默认为 `@DenyAll` 注解。这对于确保您不会意外地暴露出一个本应是安全的节点很有用。默认为 `false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If set to true, the access will be denied for all JAX-RS endpoints by default, so if a JAX-RS endpoint does not have any security annotations then it will default to `@DenyAll` behaviour. This is useful to ensure you cannot accidentally expose an endpoint that is supposed to be secured. Defaults to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设为 true，默认情况下将拒绝所有 JAX-RS 节点的访问，所以如果一个 JAX-RS 节点没有任何安全注解，那么它将默认为 `@DenyAll` 注解。这对于确保您不会意外地暴露出一个本应是安全的节点很有用。默认为 `false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If set, configure the hostname value used for the connection AMQP Open frame and TLS SNI server name (if TLS is in use)

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置了，配置用于连接AMQP开放框架和TLS SNI服务器名称的主机名值（如果正在使用TLS）

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If set, explicitly override the hostname to use for the TLS SNI server name

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置了，明确地覆盖用于TLS SNI服务器名称的主机名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the JWT token can not be injected, for example, if it is embedded in the service request payload or the service endpoint acquires it out of band, then one can use `JWTParser`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果JWT令牌不能被注入，例如，如果它被嵌入到服务请求的有效载荷中，或者服务端点在带外获得它，那么人们可以使用 `JWTParser` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the Kafka Dev Service is available during tests, `KafkaCompanionResource` uses the created Kafka broker, otherwise it creates a Kafka broker using https://github.com/strimzi/test-container[Strimzi Test Container].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果Kafka Dev Service在测试期间是可用的， `KafkaCompanionResource` 则会使用创建的Kafka broker，否则就使用 link:https://github.com/strimzi/test-container[Strimzi测试容器]创建一个Kafka broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the Micrometer registry you would like to use does not yet have an associated extension,
use the `quarkus-micrometer` extension and bring in the packaged MeterRegistry dependency directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想使用的Micrometer registry还没有对应的扩展，请使用 `quarkus-micrometer` 扩展，并直接添加已打包的MeterRegistry依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the Micrometer registry you would like to use does not yet have an associated extension, use the `quarkus-micrometer` extension and bring in the packaged MeterRegistry dependency directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想使用的Micrometer registry还没有对应的扩展，请使用 `quarkus-micrometer` 扩展，并直接添加已打包的MeterRegistry依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the NVE database flags a CVE against a Quarkus tag, a link that provides more details about the CVE is added to the given CPE name entry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果NVE数据库针对一个Quarkus tag标记了一个CVE，那么一个提供了这个CVE更多细节的链接就会被添加到给定的CPE名录下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `address` attribute is not set, the connector uses the channel name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置 `address` 属性，连接器将使用通道名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `com.fasterxml.jackson.module:jackson-module-kotlin` dependency and the `quarkus-jackson` extension (or one of the `quarkus-resteasy-jackson` or `quarkus-resteasy-reactive-jackson` extensions) have been added to the project,
then Quarkus automatically registers the `KotlinModule` to the `ObjectMapper` bean (see xref:rest-json.adoc#jackson[this] guide for more details).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `com.fasterxml.jackson.module:jackson-module-kotlin` 依赖和 `quarkus-jackson` 扩展（或 `quarkus-resteasy-jackson` 或 `quarkus-resteasy-reactive-jackson` 其中之一）已经被添加到项目中，那么 Quarkus 会自动将 `KotlinModule` 注册到 `ObjectMapper` Bean 中（更多细节请参见 link:rest-json.html#jackson[这篇指南] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `com.fasterxml.jackson.module:jackson-module-kotlin` dependency and the `quarkus-jackson` extension (or one of the `quarkus-resteasy-jackson` or `quarkus-resteasy-reactive-jackson` extensions) have been added to the project, then Quarkus automatically registers the `KotlinModule` to the `ObjectMapper` bean (see xref:rest-json.adoc#jackson[this] guide for more details).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `com.fasterxml.jackson.module:jackson-module-kotlin` 依赖和 `quarkus-jackson` 扩展（或 `quarkus-resteasy-jackson` 或 `quarkus-resteasy-reactive-jackson` 其中之一）已经被添加到项目中，那么 Quarkus 会自动将 `KotlinModule` 注册到 `ObjectMapper` Bean 中（更多细节请参见 link:rest-json.html#jackson[这篇指南] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `group.id` attribute is not set, it defaults the `quarkus.application.name` configuration property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置 `group.id` ，则其默认与 `quarkus.application.name` 相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `iss` property is tenant specific in a multi-tenant deployment then you can use the `SecurityIdentity` `tenant-id` attribute to check the issuer is correct in the endpoint itself or the custom JAX-RS filter, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在多租户部署中， `iss` 属性是租户特定的，那么你可以使用 `SecurityIdentity` `tenant-id` 属性来检查端点本身或自定义 JAX-RS 过滤器中的签发者是否正确，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the connector cannot extract the Cloud Event metadata, it sends the Message without the metadata.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果连接器不能提取云事件元数据，它将发送没有元数据的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the consumer method receives a `Message`, the acknowledgment strategy is `Strategy.MANUAL`
and the consumer method is in charge of ack/nack the message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果消费者方法接收到一个 `Message` ，那么确认策略是 `Strategy.MANUAL` 并且消费者方法将负责对消息进行ack/nack。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the consumer method receives a `Message`, the acknowledgment strategy is `Strategy.MANUAL` and the consumer method is in charge of ack/nack the message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果消费者方法接收到一个 `Message` ，那么确认策略是 `Strategy.MANUAL` 并且消费者方法将负责对消息进行ack/nack。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the endpoint does not return a `CompletionStage`, the HTTP response may be written before the message is sent to Kafka, and so failures won't be reported to the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果节点没有返回 `CompletionStage` ，HTTP响应可能会返回在消息被发送到Kafka之前，因此失败不会被报告给用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the message payload cannot be serialized to JSON, the message is _nacked_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果消息的有效载荷不能被序列化为JSON，那么该消息是 _nacked_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the micro image does not suit your requirements, you can use https://catalog.redhat.com/software/containers/ubi8/ubi-minimal/5c359a62bed8bd75a2c3fba8[UBI- Minimal].
It's a bigger image, but contains more utilities and is closer to a full Linux distribution.
Typically, it contains a package manager (`microdnf`), so you can install packages more easily.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果微镜像不符合你的要求，你可以使用 https://catalog.redhat.com/software/containers/ubi8/ubi-minimal/5c359a62bed8bd75a2c3fba8[UBI- Minimal]。这是一个更大的镜像，但包含了更多实用程序 且更接近于完整的 Linux 发行版。通常，它包含一个包管理器 (`microdnf`)，因此你可以利用它更方便地安装软件包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the outgoing record already contains a _key_, it *won't be overridden* by the incoming record key.
If the incoming record does have a _null_ key, the `mp.messaging.outgoing.$channel.key` property is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果传出的记录已经包含一个 _键_，那么它 *不会* 被传入的记录键的键所覆盖。如果传入的记录键为_空_，那么 `mp.messaging.outgoing.$channel.key` 设置的值会被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the outgoing record already contains a _key_, it *won't be overridden* by the incoming record key.  If the incoming record does have a _null_ key, the `mp.messaging.outgoing.$channel.key` property is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果传出的记录已经包含一个 _键_，那么它 *不会* 被传入的记录键的键所覆盖。如果传入的记录键为_空_，那么 `mp.messaging.outgoing.$channel.key` 设置的值会被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the
target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果进程由于某种原因找不到原生镜像，或者你想测试一个已经不在目标目录中的原生镜像，你可以用 `-Dnative.image.path=` 系统属性指定可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果进程由于某种原因找不到原生镜像，或者你想测试一个已经不在目标目录中的原生镜像，你可以用 `-Dnative.image.path=` 系统属性指定可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the processing completes successfully, _before committing the transaction_, the topic partition offsets of the given batch message will be committed to the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果处理成功完成，_在提交事务之前_ ，给定批处理消息的主题分区偏移量将提交给事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the processing completes successfully, the producer is flushed and the transaction is committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果处理成功完成，则刷新生产者并提交事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the processing needs to abort, _after aborting the transaction_, the consumer's position is reset to the last committed offset, effectively resuming the consumption from that offset. If no consumer offset has been committed to a topic-partition, the consumer's position is reset to the beginning of the topic-partition, _even if the offset reset policy is `latest`_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果处理需要中止，_在中止事务后_ ，消费者的位置将重置为最后提交的偏移量，能有效地从该偏移量恢复消费。 如果没有消费者偏移量被提交到主题分区，消费者的位置将被重置到主题分区的开头，_即使把 `latest` 做为偏移量重置策略_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the processing throws an exception, returns a failing `Uni`, or marks the `TransactionalEmitter` for abort, the transaction is aborted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果处理过程抛出异常，会返回失败的 `Uni`，或将 `TransactionalEmitter` 标记为中止，然后事务会被中止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the rebalance listener handles offset commit on behalf of the user (using the `NONE` commit strategy),
the rebalance listener must commit the offset synchronously in the partitionsRevoked callback.
We also recommend applying the same logic when the application stops.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用再平衡监听器代替用户来处理偏移量提交(使用 `NONE` 提交策略)，再平衡监听器就必须在partitionRevoked回调中同步提交偏移量。我们也建议在应用程序停止时使用同样的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the rebalance listener handles offset commit on behalf of the user (using the `NONE` commit strategy), the rebalance listener must commit the offset synchronously in the partitionsRevoked callback.  We also recommend applying the same logic when the application stops.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用再平衡监听器代替用户来处理偏移量提交(使用 `NONE` 提交策略)，再平衡监听器就必须在partitionRevoked回调中同步提交偏移量。我们也建议在应用程序停止时使用同样的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the resolved `Map` does not contain the value the default `Map` is used (exposed with the `default-kafka-broker` name)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `Map` 不包含该值，则使用默认的 `Map` (通过 `default-kafka-broker` 名称暴露)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the token is a JWT token then, by default, it will be verified with a `JsonWebKey` (JWK) key from a local `JsonWebKeySet` retrieved from the OpenID Connect Provider's JWK endpoint. The token's key identifier `kid` header value will be used to find the matching JWK key.
If no matching `JWK` is available locally then `JsonWebKeySet` will be refreshed by fetching the current key set from the JWK endpoint. The `JsonWebKeySet` refresh can be repeated only after the `quarkus.oidc.token.forced-jwk-refresh-interval` (default is 10 minutes) expires.
If no matching `JWK` is available after the refresh then the JWT token will be sent to the OpenID Connect Provider's token introspection endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果令牌是 JWT 令牌，则默认情况下，将使用从 OpenID Connect 提供程序的 JWK 端点检索到的本地 `JsonWebKeySet` 中的 `JsonWebKey`（JWK） 密钥对其进行验证。令牌的密钥标识符 `kid` 标头值( header value)将用于查找匹配的 JWK 密钥。 如果本地没有匹配的 `JWK` 可用，则 `JsonWebKeySet` 将通过从JWK端点获取当前密钥集来刷新。`JsonWebKeySet` 刷新只能在 `quarkus.oidc.token.forced-jwk-refresh-interval`（默认值为10分钟）过期后重复。 如果在刷新后没有匹配的“JWK”可用，则 JWT 令牌将发送到 OpenID Connect 提供程序的令牌自检终结点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the token is a JWT token then, by default, it will be verified with a `JsonWebKey` (JWK) key from a local `JsonWebKeySet` retrieved from the OpenID Connect Provider's JWK endpoint. The token's key identifier `kid` header value will be used to find the matching JWK key.  If no matching `JWK` is available locally then `JsonWebKeySet` will be refreshed by fetching the current key set from the JWK endpoint. The `JsonWebKeySet` refresh can be repeated only after the `quarkus.oidc.token.forced-jwk-refresh-interval` (default is 10 minutes) expires.  If no matching `JWK` is available after the refresh then the JWT token will be sent to the OpenID Connect Provider's token introspection endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果令牌是 JWT 令牌，则默认情况下，将使用从 OpenID Connect 提供程序的 JWK 端点检索到的本地 `JsonWebKeySet` 中的 `JsonWebKey`（JWK） 密钥对其进行验证。令牌的密钥标识符 `kid` 标头值( header value)将用于查找匹配的 JWK 密钥。 如果本地没有匹配的 `JWK` 可用，则 `JsonWebKeySet` 将通过从JWK端点获取当前密钥集来刷新。`JsonWebKeySet` 刷新只能在 `quarkus.oidc.token.forced-jwk-refresh-interval`（默认值为10分钟）过期后重复。 如果在刷新后没有匹配的“JWK”可用，则 JWT 令牌将发送到 OpenID Connect 提供程序的令牌自检终结点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the token is opaque (binary) then a `scope` property from the remote token introspection response will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果令牌是不透明的（二进制），那么将使用来自远程令牌自省(token introspection)响应的 `scope` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the token is opaque (it can be a binary token or an encrypted JWT token) then it will always be sent to the OpenID Connect Provider's token introspection endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果令牌是不透明的（可以是二进制令牌或加密的JWT令牌），那么它将总是被发送到OpenID Connect提供者的令牌自省端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the user authentication requires Authorization Code flow or you need to support multiple tenants, use `quarkus-oidc`.
`quarkus-oidc` can also request user information by using both Authorization Code Flow and Bearer access tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用户认证需要是使用Authorization Code flow或者您需要支持多租户，请使用 `quarkus-oidc` 。 `quarkus-oidc` 也可以通过Authorization Code Flow 和 Bearer access tokens来请求用户信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the user authentication requires Authorization Code flow or you need to support multiple tenants, use `quarkus-oidc`.  `quarkus-oidc` can also request user information by using both Authorization Code Flow and Bearer access tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用户认证需要是使用Authorization Code flow或者您需要支持多租户，请使用 `quarkus-oidc` 。 `quarkus-oidc` 也可以通过Authorization Code Flow 和 Bearer access tokens来请求用户信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the user credentials are provided by different sources, you can combine  authentication mechanisms.
For example, you can combine built-in `Basic` and `quarkus-oidc` `Bearer` authentication mechanisms.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用户证书是由不同的来源提供的，您可以使用组合认证机制。例如，您可以结合内置的 `Basic` 和 `quarkus-oidc` `Bearer` 认证机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the user credentials are provided by different sources, you can combine authentication mechanisms.  For example, you can combine built-in `Basic` and `quarkus-oidc` `Bearer` authentication mechanisms.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用户证书是由不同的来源提供的，您可以使用组合认证机制。例如，您可以结合内置的 `Basic` 和 `quarkus-oidc` `Bearer` 认证机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are any problems creating the function, you must delete it with the `delete` function before re-running
the `create` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在创建函数时有任何问题，你必须在重新运行 `create` 命令之前使用 `delete` 函数来删除它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are any problems creating the function, you must delete it with the `delete` function before re-running the `create` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在创建函数时有任何问题，你必须在重新运行 `create` 命令之前使用 `delete` 函数来删除它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is an immediate need for a test to define Wiremock stubs not currently supported by `OidcWiremockTestResource`
one can do so via a `WireMockServer` instance injected into the test class, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个测试需要立即定义Wiremock存根(stubs)，而目前 `OidcWiremockTestResource` 不支持，可以通过注入测试类的 `WireMockServer` 实例来实现，例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is an immediate need for a test to define Wiremock stubs not currently supported by `OidcWiremockTestResource` one can do so via a `WireMockServer` instance injected into the test class, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个测试需要立即定义Wiremock存根(stubs)，而目前 `OidcWiremockTestResource` 不支持，可以通过注入测试类的 `WireMockServer` 实例来实现，例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this is the only key property which is set then the incoming token is expected to contain the encrypted claims only.
If either `mp.jwt.verify.publickey` or `mp.jwt.verify.publickey.location` verification properties are also set then the incoming token is expected to contain
the encrypted inner-signed token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果这是唯一被设置的密钥属性，那么传入的令牌预计将只包含加密的claims。如果 `mp.jwt.verify.publickey` 或 `mp.jwt.verify.publickey.location` 验证属性也被设置，那么传入的令牌预计将包含加密的内签令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this is the only key property which is set then the incoming token is expected to contain the encrypted claims only.  If either `mp.jwt.verify.publickey` or `mp.jwt.verify.publickey.location` verification properties are also set then the incoming token is expected to contain the encrypted inner-signed token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果这是唯一被设置的密钥属性，那么传入的令牌预计将只包含加密的claims。如果 `mp.jwt.verify.publickey` 或 `mp.jwt.verify.publickey.location` 验证属性也被设置，那么传入的令牌预计将包含加密的内签令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this property is enabled then a signed token must contain either 'x5t' or 'x5t#S256' X509Certificate thumbprint headers. Verification keys can only be in JWK or PEM Certificate key formats in this case. JWK keys must have a 'x5c' (Base64-encoded X509Certificate) property set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果此属性被启用，那么签名的令牌必须包含 `x5t` 或 `x5t#S256` X509Certificate的thumbprint headers。在这种情况下，验证密钥只能是JWK或PEM证书密钥格式。JWK密钥必须有一个 `x5c`（Base64编码的X509Certificate）属性设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用Gradle，YAML模板中的二进制文件的路径必须从 `target` 改为 `build` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Gradle, the path to the binaries in the `manage.sh` must be changed from `target` to `build`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用Gradle， `manage.sh` 中二进制文件的路径必须从 `target` 变为 `build` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes e.g. `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用Powershell，用双引号包住 `-D` 参数，例如： `"-DprojectArtifactId=getting-started"` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell, wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用Powershell，请将 `-D` 参数用双引号括起来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd , (don't use backward slash `\` and put everything on the same line)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用cmd ，（不要使用反斜线 `\` ，并将所有内容放在同一行）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd, (don't use forward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用cmd，（不要使用正斜杠 `\`）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果我们把重点放在依赖关系部分，你可以看到允许开发REST应用程序的扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and
`@Transactional` annotations, e.g.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果我们将这个注解应用于测试类，那它就类似于我们同时应用了 `@QuarkusTest` 和 `@Transactional` 注解一样，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and `@Transactional` annotations, e.g.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果我们将这个注解应用于测试类，那它就类似于我们同时应用了 `@QuarkusTest` 和 `@Transactional` 注解一样，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we were to use the code above, we would get an exception like the following when using the native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果我们使用上面的代码，在使用原生可执行文件时，我们会得到一个类似下面的异常：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `micrometer-registry-prometheus` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已有配置好的Quarkus项目，您可以通过在您的项目根目录下运行以下命令来将 `micrometer-registry-prometheus` 扩展添加到您的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `micrometer-registry-prometheus` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已有配置好的Quarkus项目，您可以通过在您的项目根目录下运行以下命令来将 `micrometer-registry-prometheus` 扩展添加到您的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `mongodb-client` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `mongodb-client` 扩展添加到你的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `mongodb-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `mongodb-client` 扩展添加到你的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `oidc` and `keycloak-authorization` extensions
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已经配置了Quarkus项目，您可以通过在项目根目录中执行以下命令将 `oidc` 和 `keycloak-authorization` 扩展添加到您的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `oidc` and `keycloak-authorization` extensions to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已经配置了Quarkus项目，您可以通过在项目根目录中执行以下命令将 `oidc` 和 `keycloak-authorization` 扩展添加到您的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `oidc` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `oidc` 扩展加入到你的项目中去：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `oidc` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `oidc` 扩展加入到你的项目中去：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `quarkus-opentelemetry-exporter-otlp` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已经配置了您的Quarkus项目，您可以通过在您的项目根目录下运行以下命令，将 `quarkus-opentelemetry-exporter-otlp` 扩展添加到您的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `quarkus-opentelemetry-exporter-otlp` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已经配置了您的Quarkus项目，您可以通过在您的项目根目录下运行以下命令，将 `quarkus-opentelemetry-exporter-otlp` 扩展添加到您的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `redis-client` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了Quarkus项目，可以通过在项目根目录下运行以下命令，将 `redis-client` 扩展添加到你的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `redis-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了Quarkus项目，可以通过在项目根目录下运行以下命令，将 `redis-client` 扩展添加到你的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-jwt` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `smallrye-jwt` 扩展到你的项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-jwt` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `smallrye-jwt` 扩展到你的项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-boot-properties` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以在项目的根目录下运行以下命令，并将 `spring-boot-properties` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-boot-properties` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以在项目的根目录下运行以下命令，并将 `spring-boot-properties` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-cloud-config-client` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目根目录下运行以下命令，将 `spring-cloud-config-client` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-cloud-config-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目根目录下运行以下命令，将 `spring-cloud-config-client` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-scheduled` extension
to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以在你的项目根目录下运行以下命令，将 `spring-scheduled` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-scheduled` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以在你的项目根目录下运行以下命令，将 `spring-scheduled` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a Java EE or Spring user, this development model should look familiar.  You expose a resource containing methods annotated with &lt;code&gt;@GET&lt;/code&gt;, &lt;code&gt;@POST&lt;/code&gt;…&amp;ZeroWidthSpace;&amp;ZeroWidthSpace; to handle the different requests.  The path is specified using the &lt;code&gt;@Path&lt;/code&gt; annotation.  Quarkus also supports &lt;a href="https://quarkus.io/guides/spring-web"&gt;Spring controller&lt;/a&gt; annotations such as &lt;code&gt;@GetMapping&lt;/code&gt; or &lt;code&gt;@RestController&lt;/code&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是一个Java EE或Spring的用户，这个开发模型应该看起来很熟悉。你暴露一个资源，其中包含有&lt;code&gt;@GET&lt;/code&gt;, &lt;code&gt;@POST&lt;/code&gt;...&amp;ZeroWidthSpace;&amp;ZeroWidthSpace; 注释的方法来处理不同的请求。路径是使用&lt;code&gt;@Path&lt;/code&gt;注解指定的。Quarkus还支持&lt;a href="https://quarkus.io/guides/spring-web"&gt;Spring控制器&lt;/a&gt;注释，如&lt;code&gt;@GetMapping&lt;/code&gt;或&lt;code&gt;@RestController&lt;/code&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are already familiar with Keycloak, you’ll notice that the extension is basically another adapter implementation but specific for Quarkus applications.
Otherwise, you can find more information in the Keycloak https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview[documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已经熟悉Keycloak，您会注意到这个扩展基本上是另一个专门针对Quarkus的keycloak适配器的实现。另外，您也可以在Keycloak link:https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview[文档] 中找到更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are already familiar with Keycloak, you’ll notice that the extension is basically another adapter implementation but specific for Quarkus applications.  Otherwise, you can find more information in the Keycloak https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview[documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已经熟悉Keycloak，您会注意到这个扩展基本上是另一个专门针对Quarkus的keycloak适配器的实现。另外，您也可以在Keycloak link:https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview[文档] 中找到更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are an extension developer or want to contribute to Quarkus development, join our mailing list either &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;emailing us&lt;/a&gt; or by visiting our &lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groups page&lt;/a&gt;. Make sure you visit our extensive &lt;a href="{{site.baseurl}}/guides/writing-extensions"&gt;Writing extensions guide&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是一个扩展程序的开发者，或者想为Quarkus的发展做出贡献，请加入我们的邮件列表，可以&lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;给我们写信&lt;/a&gt;，或者访问我们的&lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groups页面&lt;/a&gt;。请务必访问我们广泛的&lt;a href="{{site.baseurl}}/guides/writing-extensions"&gt;写作扩展指南&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda
you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray
library is not fully compatible with GraalVM so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在构建原生镜像，并希望在你的lambda中使用 link:https://aws.amazon.com/xray[AWS X-Ray Tracing] ，那么你将需要在你的pom中包含 `quarkus-amazon-lambda-xray` 来作为一个依赖项。AWS X-Ray库与GraalVM并不完全兼容，因此我们不得不做一些整合工作来使其正常运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda
you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray
library is not fully compatible with GraalVM, so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在构建原生镜像，并希望在你的lambda中使用 link:https://aws.amazon.com/xray[AWS X-Ray 追踪] ，你将需要在你的pom中把 `quarkus-amazon-lambda-xray` 作为一个依赖项来包括。AWS X-Ray库与GraalVM并不完全兼容，因此我们不得不做一些整合工作来使其可以正常工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在构建原生镜像，并希望在你的lambda中使用 link:https://aws.amazon.com/xray[AWS X-Ray Tracing] ，那么你将需要在你的pom中包含 `quarkus-amazon-lambda-xray` 来作为一个依赖项。AWS X-Ray库与GraalVM并不完全兼容，因此我们不得不做一些整合工作来使其正常运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM, so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在构建原生镜像，并希望在你的lambda中使用 link:https://aws.amazon.com/xray[AWS X-Ray 追踪] ，你将需要在你的pom中把 `quarkus-amazon-lambda-xray` 作为一个依赖项来包括。AWS X-Ray库与GraalVM并不完全兼容，因此我们不得不做一些整合工作来使其可以正常工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing Quarkus to use a docker build as Amazon
Lambda requires linux binaries.  You can do this by passing this property to your build:
`-Dquarkus.native.container-build=true`. This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在非Linux系统上构建，你还需要传入一个属性，指示Quarkus使用docker构建，因为Amazon Lambda需要linux二进制文件。你可以通过向你的构建传递这个属性来实现： `-Dquarkus.native.container-build=true` 。不过，这需要你在本地安装了Docker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing Quarkus to use a docker build as Amazon Lambda requires linux binaries.  You can do this by passing this property to your build: `-Dquarkus.native.container-build=true`. This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在非Linux系统上构建，你还需要传入一个属性，指示Quarkus使用docker构建，因为Amazon Lambda需要linux二进制文件。你可以通过向你的构建传递这个属性来实现： `-Dquarkus.native.container-build=true` 。不过，这需要你在本地安装了Docker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon
Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.
This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在非Linux系统上进行构建，你还需要传入一个属性，指示quarkus使用Docker构建，因为Amazon Lambda需要Linux二进制文件。你可以通过将 `-Dquarkus.native.container-build=true` 传给你的构建命令来实现。不过，这需要你在本地安装了Docker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在非Linux系统上进行构建，你还需要传入一个属性，指示quarkus使用Docker构建，因为Amazon Lambda需要Linux二进制文件。你可以通过将 `-Dquarkus.native.container-build=true` 传给你的构建命令来实现。不过，这需要你在本地安装了Docker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier&lt;CompletionStage&gt;`. For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你面对的是使用 `CompletionStage`, `CompletableFuture` 或 `Publisher` 的API，你可以来回转换。首先， `Uni` 和 `Multi` 都可以从 `CompletionStage` 或 `Supplier&lt;CompletionStage&gt;`创建。例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in tiny Docker images, check the {quarkus-images-url}/master/distroless[distroless] version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您对小型Docker镜像感兴趣，请查看 {quarkus-images-url}/master/distroless[无发行版]版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are looking for small container images, the https://github.com/GoogleContainerTools/distroless[distroless] approach reduces the size of the base layer.
The idea behind _distroless_ is the usage of a single and minimal base image containing all the requirements, and sometimes even the application itself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在寻找小型的容器镜像，https://github.com/GoogleContainerTools/distroless[无发行] 的方法可以减少基础层的大小。 _distroless_ 背后的想法是使用一个单一和最小的基础镜像包含所有的需求，有时甚至是应用程序本身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are looking for small container images, the https://github.com/GoogleContainerTools/distroless[distroless] approach reduces the size of the base layer.  The idea behind _distroless_ is the usage of a single and minimal base image containing all the requirements, and sometimes even the application itself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在寻找小型的容器镜像，https://github.com/GoogleContainerTools/distroless[无发行] 的方法可以减少基础层的大小。 _distroless_ 背后的想法是使用一个单一和最小的基础镜像包含所有的需求，有时甚至是应用程序本身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are running on a Windows machine, please keep in mind that the binary was created within a Linux docker container.
Hence, the binary will not be executable on the host Windows machine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是在Windows机器上运行，请记住，二进制文件是在Linux docker容器中创建的。因此，二进制文件在Windows主机上是无法执行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are running on a Windows machine, please keep in mind that the binary was created within a Linux docker container.  Hence, the binary will not be executable on the host Windows machine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是在Windows机器上运行，请记住，二进制文件是在Linux docker容器中创建的。因此，二进制文件在Windows主机上是无法执行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are testing your application with `sam local` you can
hardcode a principal name to use when your application runs by setting
the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `sam local` 测试你的应用程序，你可以通过设置 `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` 环境变量来硬编码一个主体名，以便在应用程序运行时使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `sam local` 测试你的应用程序，你可以通过设置 `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` 环境变量来硬编码一个主体名，以便在应用程序运行时使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using &lt;&lt;kafka-dev-services&gt;&gt;, a Kafka broker will be started and available throughout the tests, unless it is disabled in `%test` profile.
While it is possible to connect to this broker using Kafka Clients API,
https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] proposes an easier way of interacting with a Kafka broker and, creating consumer, producer and admin actions inside tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用 link:#kafka-dev-services[[kafka-dev-services]] ，Kafka broker将被启动并在整个测试中可用，除非它在 `%test` profile中被禁用。虽然可以使用Kafka客户端API连接到这个broker，但 link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] 提出了一种更简单的方式来与Kafka broker通信，并在测试中创建消费者、生产者和管理操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using &lt;&lt;kafka-dev-services&gt;&gt;, a Kafka broker will be started and available throughout the tests, unless it is disabled in `%test` profile.  While it is possible to connect to this broker using Kafka Clients API, https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] proposes an easier way of interacting with a Kafka broker and, creating consumer, producer and admin actions inside tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用 link:#kafka-dev-services[[kafka-dev-services]] ，Kafka broker将被启动并在整个测试中可用，除非它在 `%test` profile中被禁用。虽然可以使用Kafka客户端API连接到这个broker，但 link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] 提出了一种更简单的方式来与Kafka broker通信，并在测试中创建消费者、生产者和管理操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在项目中使用Gradle，你可以使用这个Docker文件例子。将其保存在 `src/main/docker/Dockerfile.multistage` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus Security, check out the xref:security-testing.adoc[Testing Security] section for information on how to easily test security features of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您正在使用Quarkus Security，请查看 link:security-testing.html[测试安全] 部分，了解如何轻松测试应用程序的安全功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy Reactive and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes
using the JAX-RS `@Context` annotation or anywhere else with the CDI `@Inject` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用RESTEasy Reactive和JAX-RS，您可以使用JAX-RS `@Context` 注解将各种AWS上下文变量注入到JAX-RS资源类中，或者注入到带有CDI `@Inject` 注解的任何其他地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy Reactive and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes using the JAX-RS `@Context` annotation or anywhere else with the CDI `@Inject` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用RESTEasy Reactive和JAX-RS，您可以使用JAX-RS `@Context` 注解将各种AWS上下文变量注入到JAX-RS资源类中，或者注入到带有CDI `@Inject` 注解的任何其他地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using a Docker image to build, then you must extract these files from this image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Docker镜像来进行构建，那么你必须从这个镜像中提取这些文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using dependencies that require logging components such as Apache Commons Logging or Log4j and are experiencing a `ClassNotFoundException` when building the native executable, you can resolve this by excluding the logging library and adding the corresponding JBoss Logging adapter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在使用需要日志组件（如Apache Commons logging或Log4j）的依赖，并且在构建原生可执行文件时遇到了' ClassNotFoundException '，你可以通过排除日志库并添加相应的JBoss日志适配器来解决这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the xref:hibernate-orm-panache.adoc#mocking[Hibernate ORM with Panache Mocking] and xref:mongodb-panache.adoc#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用 `quarkus-hibernate-orm-panache` 或 `quarkus-mongodb-panache` 扩展，请查看 link:hibernate-orm-panache.html#mocking[Hibernate ORM with Panache Mocking] 和 link:mongodb-panache.html#mocking[MongoDB with Panache Mocking] 文档，以了解mock数据访问的最简单方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-micrometer` or `quarkus-smallrye-metrics` extension, `quarkus-mongodb-client` can provide metrics about the connection pools.
This behavior must first be enabled by setting the `quarkus.mongodb.metrics.enabled` property to `true` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-micrometer` 或 `quarkus-smallrye-metrics` 扩展， `quarkus-mongodb-client` 可以提供关于连接池的指标。这种行为必须首先通过在你的 `application.properties` 中设置 `quarkus.mongodb.metrics.enabled` 属性为 `true` 来启用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-micrometer` or `quarkus-smallrye-metrics` extension, `quarkus-mongodb-client` can provide metrics about the connection pools.  This behavior must first be enabled by setting the `quarkus.mongodb.metrics.enabled` property to `true` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-micrometer` 或 `quarkus-smallrye-metrics` 扩展， `quarkus-mongodb-client` 可以提供关于连接池的指标。这种行为必须首先通过在你的 `application.properties` 中设置 `quarkus.mongodb.metrics.enabled` 属性为 `true` 来启用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-mongodb-client` will automatically add a readiness health check
to validate the connection to the cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-smallrye-health` 扩展， `quarkus-mongodb-client` 将自动添加就绪状态检查，以验证与集群的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-mongodb-client` will automatically add a readiness health check to validate the connection to the cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-smallrye-health` 扩展， `quarkus-mongodb-client` 将自动添加就绪状态检查，以验证与集群的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-vertx-redis` will automatically add a readiness health check
to validate the connection to the Redis server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用了 `quarkus-smallrye-health` 扩展， `quarkus-vertx-redis` 将自动添加就绪健康检查，以验证与Redis服务的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-vertx-redis` will automatically add a readiness health check to validate the connection to the Redis server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用了 `quarkus-smallrye-health` 扩展， `quarkus-vertx-redis` 将自动添加就绪健康检查，以验证与Redis服务的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-opentracing` extension, `quarkus-mongodb-client` can register traces about the commands executed.
This behavior must be enabled by setting the `quarkus.mongodb.tracing.enabled` property to `true` in your `application.properties` and adding the dependency `io.opentracing.contrib:opentracing-mongo-common` to your pom.xml (for more info read the xref:opentracing.adoc#mongodb-client[OpenTracing - MongoDB client] section).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-smallrye-opentracing` 扩展， `quarkus-mongodb-client` 可以注册关于所执行命令的跟踪。必须通过在你的 `application.properties` 中将 `quarkus.mongodb.tracing.enabled` 属性设置为 `true` 并在你的 pom.xml 中添加依赖性 `io.opentracing.contrib:opentracing-mongo-common` 来启用这一行为（更多信息请阅读 link:opentracing.html#mongodb-client[OpenTracing - MongoDB 客户端] 部分）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-opentracing` extension, `quarkus-mongodb-client` can register traces about the commands executed.  This behavior must be enabled by setting the `quarkus.mongodb.tracing.enabled` property to `true` in your `application.properties` and adding the dependency `io.opentracing.contrib:opentracing-mongo-common` to your pom.xml (for more info read the xref:opentracing.adoc#mongodb-client[OpenTracing - MongoDB client] section).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-smallrye-opentracing` 扩展， `quarkus-mongodb-client` 可以注册关于所执行命令的跟踪。必须通过在你的 `application.properties` 中将 `quarkus.mongodb.tracing.enabled` 属性设置为 `true` 并在你的 pom.xml 中添加依赖性 `io.opentracing.contrib:opentracing-mongo-common` 来启用这一行为（更多信息请阅读 link:opentracing.html#mongodb-client[OpenTracing - MongoDB 客户端] 部分）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the active record pattern you cannot use Mockito directly as it does not support mocking static methods,
but you can use the `quarkus-panache-mock` module which allows you to use Mockito to mock all provided static
methods, including your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用了Active Record模式，那么不能直接使用Mockito，因为它不支持Mock静态方法。你可以使用 `quarkus-panache-mock` 模块，它允许你使用Mockito来模拟所有静态方法，包括你自己编写的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the active record pattern you cannot use Mockito directly as it does not support mocking static methods, but you can use the `quarkus-panache-mock` module which allows you to use Mockito to mock all provided static methods, including your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用了Active Record模式，那么不能直接使用Mockito，因为它不支持Mock静态方法。你可以使用 `quarkus-panache-mock` 模块，它允许你使用Mockito来模拟所有静态方法，包括你自己编写的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the active-record pattern you cannot use Mockito directly as it does not support mocking static methods,
but you can use the `quarkus-panache-mock` module which allows you to use Mockito to mock all provided static
methods, including your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用active-record模式，你不能直接使用Mockito，因为它不支持模拟静态方法，但你可以使用 `quarkus-panache-mock` 模块，它允许你使用Mockito来模拟所有提供的静态方法，包括你自己的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the active-record pattern you cannot use Mockito directly as it does not support mocking static methods, but you can use the `quarkus-panache-mock` module which allows you to use Mockito to mock all provided static methods, including your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用active-record模式，你不能直接使用Mockito，因为它不支持模拟静态方法，但你可以使用 `quarkus-panache-mock` 模块，它允许你使用Mockito来模拟所有提供的静态方法，包括你自己的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the repository pattern you can use Mockito directly, using the `quarkus-junit5-mockito` module,
which makes mocking beans much easier:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用存储库模式，你可以直接使用Mockito，使用 `quarkus-junit5-mockito` 模块，这使得模拟Bean变得更加容易：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the repository pattern you can use Mockito directly, using the `quarkus-junit5-mockito` module, which makes mocking beans much easier:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用存储库模式，你可以直接使用Mockito，使用 `quarkus-junit5-mockito` 模块，这使得模拟Bean变得更加容易：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are working with your native image build, simply replace the template name with the native version:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在使用原生镜像构建，只需将模板名称替换为原生版本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you aren't using Prometheus, you have a few options. Some Micrometer registry implementations
have been wrapped in
https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse extensions].
To use the Micrometer StackDriver MeterRegistry, for example, you would use the
`quarkus-micrometer-registry-stackdriver` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您不使用Prometheus，您可以有其他选择。一些Micrometer registry的实现已经包含在 link:https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse扩展] 中了。例如，要使用Micrometer StackDriver MeterRegistry，您可以使用 `quarkus-micrometer-registry-stackdriver` 扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you aren't using Prometheus, you have a few options. Some Micrometer registry implementations have been wrapped in https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse extensions].  To use the Micrometer StackDriver MeterRegistry, for example, you would use the `quarkus-micrometer-registry-stackdriver` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您不使用Prometheus，您可以有其他选择。一些Micrometer registry的实现已经包含在 link:https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse扩展] 中了。例如，要使用Micrometer StackDriver MeterRegistry，您可以使用 `quarkus-micrometer-registry-stackdriver` 扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you believe we are missing an article, blog or video https://github.com/quarkusio/quarkusio.github.io[submit an issue].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你认为我们少了一篇文章，博客或视频 https://github.com/quarkusio/quarkusio.github.io[提交一个议题]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. There is an explanation of how to do this at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你无法安装GraalVM，你可以使用多阶段Docker构建在嵌入GraalVM的Docker容器内运行Maven。本指南最后有关于如何操作的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you configure `mp.jwt.verify.publickey.location` to point to HTTPS or HTTP based JsonWebKey (JWK) set then you can use the same approach as described in the xref:security-openid-connect.adoc#integration-testing[OpenID Connect Bearer Token Integration testing] `Wiremock` section but only change the `application.properties` to use MP JWT configuration properties instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你配置 `mp.jwt.verify.publickey.location` ，以指向HTTPS或基于HTTP的JsonWebKey（JWK）集，那么你可以使用与 link:security-openid-connect.html#integration-testing[OpenID Connect Bearer Token集成测试] `Wiremock` 部分所述相同的方法，但只需改变 `application.properties` ，以使用MP JWT配置属性来代替：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did not leave Quarkus running in dev mode, start it again:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的Quarkus从之前的开发模式下退出了，那么请再次启动它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did the Kafka quickstart, you have realized that it's the same code.
The only difference is the connector configuration and the JSON mapping.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你学过Kafka快速入门，你会意识到这是相同的代码。唯一的区别是连接器配置和JSON映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did the Kafka quickstart, you have realized that it's the same code.  The only difference is the connector configuration and the JSON mapping.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你学过Kafka快速入门，你会意识到这是相同的代码。唯一的区别是连接器配置和JSON映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not want to use the mock event server, you can test your lambdas with SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不想使用模拟事件服务器，你可以用SAM CLI测试lambdas。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't have a Redis service running locally, you can run Redis in a Docker container:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你没有本地运行的Redis服务，可以在Docker容器中运行Redis：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to bother defining getters/setters for your entities, you can make them extend `PanacheEntityBase` and
Quarkus will generate them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不想自己定义实体的getter和setter方法，可以让实体类继承 `PanacheEntityBase` ，Quarkus将自动生成getter和setter方法。你也可以继承 `PanacheEntity` ，相比 `PanacheEntityBase` ，其优势是它还提供默认的ID字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to bother defining getters/setters for your entities, you can make them extend `PanacheEntityBase` and Quarkus will generate them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不想自己定义实体的getter和setter方法，可以让实体类继承 `PanacheEntityBase` ，Quarkus将自动生成getter和setter方法。你也可以继承 `PanacheEntity` ，相比 `PanacheEntityBase` ，其优势是它还提供默认的ID字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to create a deserializer for each data object, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`
that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您不想为每个数据对象创建一个反序列化器，您可以使用通用的 `io.vertx.kafka.client.serialization.JsonObjectDeserializer` ，它将把消息反序列化为一个 `io.vertx.core.json.JsonObject` 。也可以使用与之相对应的序列化器： `io.vertx.kafka.client.serialization.JsonObjectSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to create a deserializer for each data object, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您不想为每个数据对象创建一个反序列化器，您可以使用通用的 `io.vertx.kafka.client.serialization.JsonObjectDeserializer` ，它将把消息反序列化为一个 `io.vertx.core.json.JsonObject` 。也可以使用与之相对应的序列化器： `io.vertx.kafka.client.serialization.JsonObjectSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to generate a new project, add the dependency in your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不想生成一个新的项目，可以在你的构建文件中添加该依赖关系：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enable the `staging` profile, the HTTP port will be 8082, whereas it would be 8081 otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你启用了 `staging` 环境配置，HTTP 端口将会是 8082，反之，端口将会是 8081。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you encounter the following error when running your application in native mode: +
`Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can't find a codec for class org.acme.MyVariable.` +
This means that the `org.acme.MyVariable` class is not known to GraalVM, the remedy is to add the `@RegisterForReflection` annotation to your `MyVariable class`.
More details about the `@RegisterForReflection` annotation can be found on the xref:writing-native-applications-tips.adoc#registerForReflection[native application tips] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在本地模式下运行你的应用程序时遇到以下错误。+ `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can’t find a codec for class org.acme.MyVariable.` + 这意味着GeralVM不知道 `org.acme.MyVariable` 类，补救措施是将 `@RegisterForReflection` 注解添加到你的 `MyVariable class` 。关于 `@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips.html#registerForReflection[本地应用程序提示] 页面找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you encounter the following error when running your application in native mode: + `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can't find a codec for class org.acme.MyVariable.` + This means that the `org.acme.MyVariable` class is not known to GraalVM, the remedy is to add the `@RegisterForReflection` annotation to your `MyVariable class`.  More details about the `@RegisterForReflection` annotation can be found on the xref:writing-native-applications-tips.adoc#registerForReflection[native application tips] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在本地模式下运行你的应用程序时遇到以下错误。+ `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can’t find a codec for class org.acme.MyVariable.` + 这意味着GeralVM不知道 `org.acme.MyVariable` 类，补救措施是将 `@RegisterForReflection` 注解添加到你的 `MyVariable class` 。关于 `@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips.html#registerForReflection[本地应用程序提示] 页面找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have the Redis server running.
Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已按上文指引操作，则应该已经运行了Redis服务。然后需要用以下方法运行应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have the Redis server running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已按上文指引操作，则应该已经运行了Redis服务。然后需要用以下方法运行应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a single connector on your classpath, you can omit the `connector` attribute configuration.
Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.
_Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在你的classpath上有一个连接器，你可以省略 `connector` 属性配置。Quarkus会自动将 _orphan_ 通道与classpath上找到的（唯一的）连接器联系起来。 _Orphans_ 通道是没有下游消费者的传出通道或没有上游生产者的传入通道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a single connector on your classpath, you can omit the `connector` attribute configuration.  Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.  _Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在你的classpath上有一个连接器，你可以省略 `connector` 属性配置。Quarkus会自动将 _orphan_ 通道与classpath上找到的（唯一的）连接器联系起来。 _Orphans_ 通道是没有下游消费者的传出通道或没有上游生产者的传入通道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经从前面的教程中生成了应用程序，你可以在 `pom.xml` ，找到以下 _profile_：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have https://curl.se/[curl] on your machine, you can try the endpoint using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在您的机器安装了 https://curl.se/[curl]命令，便可以尝试使用端点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java
and you could end up with unexpected results.
You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你安装了多个JDK，那么Maven不一定能找到预期的java，你可能会得到意想不到的结果。你可以通过运行 `mvn --version` ，验证Maven使用哪个JDK。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你安装了多个JDK，那么Maven不一定能找到预期的java，你可能会得到意想不到的结果。你可以通过运行 `mvn --version` ，验证Maven使用哪个JDK。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have started from the Getting Started example you should already have a completed test, including the correct
tooling setup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已从入门的例子开始，那您应该已经有了一个完成的测试例子，包括正确的安装了工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have started from the Getting Started example you should already have a completed test, including the correct tooling setup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已从入门的例子开始，那您应该已经有了一个完成的测试例子，包括正确的安装了工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you include the jpa-modelgen annotation processor this will exclude the Panache
annotation processor by default. If you do this you should either create the marker file
yourself, or add the `quarkus-panache-common` as well, as shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的项目包含 jpa-modelgen 注解处理器，则默认情况下会排除 Panache 注解处理器。这种情况下，你应该自己创建标记文件，或者添加 `quarkus-panache-common` 插件，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you include the jpa-modelgen annotation processor this will exclude the Panache annotation processor by default. If you do this you should either create the marker file yourself, or add the `quarkus-panache-common` as well, as shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的项目包含 jpa-modelgen 注解处理器，则默认情况下会排除 Panache 注解处理器。这种情况下，你应该自己创建标记文件，或者添加 `quarkus-panache-common` 插件，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the three generated handler classes in the project, you'll see that they are `@Named` differently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你查看项目中生成的三个处理程序类，你会发现它们的 `@Named` 不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的原生可执行文件需要SSL支持，你可以轻松地在Docker镜像中包含必要的库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need a lightweight library for the remote introspection of opaque or JWT tokens, use `quarkus-elytron-security-oauth2`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要一个轻量级的库来进行不透明或JWT token 的远程自查，请使用 `quarkus-elytron-security-oauth2` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need more configuration properties, there is a full list at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要更多的配置属性，在本指南的末尾有一个完整的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.amqp.devservices.service-name` attribute and indicate the broker name.
It looks for a container with the same value, or starts a new one if none can be found.
The default service name is `amqp`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要多个（共享的）代理，你可以配置 `quarkus.amqp.devservices.service-name` 属性，并指定代理的名字。它会查找一个具有同样值的容器，如果找不到，就会启动一个新的容器。默认的服务名称是 `amqp` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.amqp.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `amqp`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要多个（共享的）代理，你可以配置 `quarkus.amqp.devservices.service-name` 属性，并指定代理的名字。它会查找一个具有同样值的容器，如果找不到，就会启动一个新的容器。默认的服务名称是 `amqp` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.kafka.devservices.service-name` attribute and indicate the broker name.
It looks for a container with the same value, or starts a new one if none can be found.
The default service name is `kafka`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要多个（共享的）broker，您可以配置 `quarkus.kafka.devservices.service-name` 属性并指明broker的名称。它会查询一个具有相同名称的容器，如果找不到的话就启动一个新的容器。默认的服务名称是 `kafka` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.kafka.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `kafka`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要多个（共享的）broker，您可以配置 `quarkus.kafka.devservices.service-name` 属性并指明broker的名称。它会查询一个具有相同名称的容器，如果找不到的话就启动一个新的容器。默认的服务名称是 `kafka` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) registries, you can configure the `quarkus.apicurio-registry.devservices.service-name` attribute and indicate the registry name.
It looks for a container with the same value, or starts a new one if none can be found.
The default service name is `apicurio-registry`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要多个（共享）注册表，你可以配置 `quarkus.apicurio-registry.devservices.service-name` 属性，并指示注册表名称。它会寻找一个具有相同值的容器，如果找不到，就启动一个新容器。默认的服务名称是 `apicurio-registry` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) registries, you can configure the `quarkus.apicurio-registry.devservices.service-name` attribute and indicate the registry name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `apicurio-registry`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要多个（共享）注册表，你可以配置 `quarkus.apicurio-registry.devservices.service-name` 属性，并指示注册表名称。它会寻找一个具有相同值的容器，如果找不到，就启动一个新容器。默认的服务名称是 `apicurio-registry` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) servers, you can configure the `quarkus.redis.devservices.service-name` attribute and indicate the server name.
It looks for a container with the same value, or starts a new one if none can be found.
The default service name is `redis`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果需要多个（共享的）Dev Services，可以用 `quarkus.redis.devservices.service-name` 属性指定服务名称。Quarkus将尝试查找具有相同服务名称的容器，如果找不到，则启动一个新容器。默认的服务名称是 `redis` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) servers, you can configure the `quarkus.redis.devservices.service-name` attribute and indicate the server name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `redis`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果需要多个（共享的）Dev Services，可以用 `quarkus.redis.devservices.service-name` 属性指定服务名称。Quarkus将尝试查找具有相同服务名称的容器，如果找不到，则启动一个新容器。默认的服务名称是 `redis` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to access JWT token claims then you can inject `JsonWebToken`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要访问JWT令牌声明，那么你要注入 `JsonWebToken` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to customize the compiler flags used by `kotlinc` in development mode, you can configure them in the quarkus plugin:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要定制 `kotlinc` 在开发模式下使用的编译标志（compiler flags），您可以在quarkus插件中配置它们。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to delay the initialization of a class, you can use the `--initialize-at-run-time=&lt;package or class&gt;` configuration knob.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要延迟一个类的初始化，你可以使用 `--initialize-at-run-time=&lt;package or class&gt;` 配置旋钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to do some integration testing against Keycloak then you are encouraged to do it with &lt;&lt;integration-testing-keycloak-devservices,Dev Services For Keycloak&gt;&gt;.
Use `KeycloakTestResourceLifecycleManager` for your tests only if there is a good reason not to use `Dev Services for Keycloak`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要对Keycloak做一些集成测试，那么我们鼓励你使用 link:#integration-testing-keycloak-devservices[Keycloak开发服务] 来做。只有在有充分理由不使用 `Keycloak开发服务` 的情况下，才使用 `KeycloakTestResourceLifecycleManager` 进行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to do some integration testing against Keycloak then you are encouraged to do it with &lt;&lt;integration-testing-keycloak-devservices,Dev Services For Keycloak&gt;&gt;.  Use `KeycloakTestResourceLifecycleManager` for your tests only if there is a good reason not to use `Dev Services for Keycloak`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要对Keycloak做一些集成测试，那么我们鼓励你使用 link:#integration-testing-keycloak-devservices[Keycloak开发服务] 来做。只有在有充分理由不使用 `Keycloak开发服务` 的情况下，才使用 `KeycloakTestResourceLifecycleManager` 进行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to enable the Quarkus OIDC extension at runtime, set `quarkus.oidc.tenant-enabled=false` at build time and then re-enable it at runtime by using a system property.
For more information about managing the individual tenant configurations in multitenant OIDC deployments, see the _Disabling tenant configurations_ section in the xref:security-openid-connect-multitenancy.adoc#disable-tenant[Using OpenID Connect (OIDC) multi-tenancy] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想在运行时启用Quarkus OIDC扩展，那么在构建时设置 `quarkus.oidc.tenant-enabled=false` ，并在运行时使用系统属性重新启用它。更多关于管理多租户OIDC部署中各个租户配置的信息，请参见 link:security-openid-connect-multitenancy.html#disable-tenant[禁用租户配置] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to enable the Quarkus OIDC extension at runtime, set `quarkus.oidc.tenant-enabled=false` at build time and then re-enable it at runtime by using a system property.  For more information about managing the individual tenant configurations in multitenant OIDC deployments, see the _Disabling tenant configurations_ section in the xref:security-openid-connect-multitenancy.adoc#disable-tenant[Using OpenID Connect (OIDC) multi-tenancy] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想在运行时启用Quarkus OIDC扩展，那么在构建时设置 `quarkus.oidc.tenant-enabled=false` ，并在运行时使用系统属性重新启用它。更多关于管理多租户OIDC部署中各个租户配置的信息，请参见 link:security-openid-connect-multitenancy.html#disable-tenant[禁用租户配置] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to have access to the full AWT support, you need more than just `libfreetype.so`, but also the font and font configurations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要获得对AWT的完整支持，你需要的不仅仅是 `libfreetype.so` ，同时还需要字体和字体配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to introspect the JWT tokens remotely, you can use either `quarkus-oidc` or `quarkus-elytron-security-oauth2` because they support the verification of the opaque or binary tokens by using remote introspection.
`quarkus-smallrye-jwt` does not support the remote introspection of both opaque or JWT tokens but instead relies on the locally available keys that are usually retrieved from the OpenID Connect provider.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要进行JWT tokens远程自查，您可以使用 `quarkus-oidc` 或 `quarkus-elytron-security-oauth2` ，因为它们支持通过使用远程自查来验证不透明或二进制token。 `quarkus-smallrye-jwt` 不支持对不透明或JWT token进行远程自查，而是依赖于通常从OpenID Connect提供者那里检索的本地可用密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to introspect the JWT tokens remotely, you can use either `quarkus-oidc` or `quarkus-elytron-security-oauth2` because they support the verification of the opaque or binary tokens by using remote introspection.  `quarkus-smallrye-jwt` does not support the remote introspection of both opaque or JWT tokens but instead relies on the locally available keys that are usually retrieved from the OpenID Connect provider.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要进行JWT tokens远程自查，您可以使用 `quarkus-oidc` 或 `quarkus-elytron-security-oauth2` ，因为它们支持通过使用远程自查来验证不透明或二进制token。 `quarkus-smallrye-jwt` 不支持对不透明或JWT token进行远程自查，而是依赖于通常从OpenID Connect提供者那里检索的本地可用密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to mock entity instance methods, such as `persist()` you can do it by mocking the Hibernate ORM `Session` object:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要模拟实体类的实例方法，比如 `persist()` ，可以通过模拟Hibernate ORM的 `Session` 对象来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to mock entity instance methods, such as `persist()` you can do it by mocking the Hibernate Reactive `Mutiny.Session` object:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要模拟实体类的实例方法，比如 `persist()` ，可以通过模拟Hibernate Reactive的 `Mutiny.Session` 对象来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to propagate your transaction context across your reactive pipeline, please see the
xref:context-propagation.adoc[Context Propagation guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要在你的响应式管道中传播你的事务上下文，请看 link:context-propagation.html[上下文传播指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to propagate your transaction context across your reactive pipeline, please see the xref:context-propagation.adoc[Context Propagation guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要在你的响应式管道中传播你的事务上下文，请看 link:context-propagation.html[上下文传播指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to provide your own factory, for example, to avoid verifying the tokens again which have already been verified by the firewall, then you can either use a `ServiceLoader` mechanism by providing a `META-INF/services/io.smallrye.jwt.auth.principal.JWTCallerPrincipalFactory` resource or simply have an `Alternative` CDI bean implementation like this one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要提供你自己的工厂，例如，避免再次验证已经被防火墙验证过的令牌，那么你可以通过提供 `META-INF/services/io.smallrye.jwt.auth.principal.JWTCallerPrincipalFactory` 资源来使用 `ServiceLoader` 机制，或者干脆像这样有一个 `Alternative` CDI bean 实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to send a Kafka record, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要发送一条Kafka记录，请使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to use `mongo+srv://` in native mode, you can configure an alternative DNS resolver.
This feature is **experimental** and may introduce a difference between JVM applications and native applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要在原生模式下使用 `mongo+srv:` ，你可以配置一个备用的DNS解析器。此功能是**实验性**的，可能会在 JVM 应用程序和本机应用程序之间产生差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to use `mongo+srv://` in native mode, you can configure an alternative DNS resolver.  This feature is **experimental** and may introduce a difference between JVM applications and native applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要在原生模式下使用 `mongo+srv:` ，你可以配置一个备用的DNS解析器。此功能是**实验性**的，可能会在 JVM 应用程序和本机应用程序之间产生差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to use a custom sampler or to use one that is provided by one of the https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK Extensions]
you can create a sampler producer. The OpenTelemetry extension will detect the `Sampler` CDI bean and will use it when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要使用一个自定义的采样器或使用一个由 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK扩展] 提供的采样器，您可以创建一个采样器生成器。OpenTelemetry扩展将检测到 `Sampler` CDI bean，并在配置tracer生成器时使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to use a custom sampler or to use one that is provided by one of the https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK Extensions] you can create a sampler producer. The OpenTelemetry extension will detect the `Sampler` CDI bean and will use it when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要使用一个自定义的采样器或使用一个由 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK扩展] 提供的采样器，您可以创建一个采样器生成器。OpenTelemetry扩展将检测到 `Sampler` CDI bean，并在配置tracer生成器时使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to verify the token signature using the asymmetric RSA or Elliptic Curve (EC) key then use the `mp.jwt.verify.publickey.location` property to refer to the local or remote verification key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要使用非对称RSA或椭圆曲线（EC）密钥来验证令牌签名，那么请使用 `mp.jwt.verify.publickey.location` 属性来参考本地或远程验证密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to verify the token signature using the symmetric secret key then either a `JSON Web Key` (JWK) or `JSON Web Key Set` (JWK Set) format must be used to represent this secret key, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要使用对称密匙验证令牌签名，那么必须使用 `JSON Web Key` （JWK）或 `JSON Web Key Set` （JWK Set）格式来呈现这个密匙，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to write accessors, you can:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要编写访问器，你可以这样编写：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you open the generated build file, you can see the selected extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你打开生成的构建文件，你可以看到以下选定的扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to consume your OpenID Connect `service` application from a Single Page Application running on a different domain, you will need to configure CORS (Cross-Origin Resource Sharing). Please read the xref:http-reference.adoc#cors-filter[HTTP CORS documentation] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你打算从运行在不同域的单页应用中使用你的OpenID Connect `service` 应用程序，你将需要配置CORS（跨源资源共享）。请阅读 link:http-reference.html#cors-filter[HTTP CORS文档] 以了解更多细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects),
you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)
or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你计划使用外部模块（例如，一个用于你所有领域对象的外部库），你将需要通过添加Jandex插件（如果你能修改它们）或通过 `application.properties` 里的属性`quarkus.index-dependency` （在你不能修改模块的情况下很有用）使这些模块为索引过程所知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你计划使用外部模块（例如，一个用于你所有领域对象的外部库），你将需要通过添加Jandex插件（如果你能修改它们）或通过 `application.properties` 里的属性`quarkus.index-dependency` （在你不能修改模块的情况下很有用）使这些模块为索引过程所知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[code.quarkus.io]
adding the `quarkus-amazon-lambda` extension as a dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你喜欢使用Gradle，你可以通过 link:https://code.quarkus.io/[code.quarkus.io] 将 `quarkus-amazon-lambda` 扩展添加为依赖项，来快速而轻松地生成一个Gradle项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[code.quarkus.io] adding the `quarkus-amazon-lambda` extension as a dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你喜欢使用Gradle，你可以通过 link:https://code.quarkus.io/[code.quarkus.io] 将 `quarkus-amazon-lambda` 扩展添加为依赖项，来快速而轻松地生成一个Gradle项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Spring Boot `@ConfigurationProperties` annotated class to access application properties instead of
a Quarkus native `@ConfigProperties` or a MicroProfile `@ConfigProperty` approach, you can do that with this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你更喜欢使用Spring Boot `@ConfigurationProperties` 注解类来访问应用程序的属性，而不是Quarkus本地的 `@ConfigProperties` 或MicroProfile `@ConfigProperty` 的注解方式，你可以通过使用该扩展来做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Spring Boot `@ConfigurationProperties` annotated class to access application properties instead of a Quarkus native `@ConfigProperties` or a MicroProfile `@ConfigProperty` approach, you can do that with this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你更喜欢使用Spring Boot `@ConfigurationProperties` 注解类来访问应用程序的属性，而不是Quarkus本地的 `@ConfigProperties` 或MicroProfile `@ConfigProperty` 的注解方式，你可以通过使用该扩展来做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer using Reactive Stream APIs, you can use `MutinyEmitter` that will return `Uni&lt;Void&gt;` from the `send` method.
You can therefore use Mutiny APIs for handling downstream messages and errors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您偏好于使用Reactive Stream APIs，您可以使用 `MutinyEmitter` ，它将在 `send` 方法中返回 `Uni&lt;Void&gt;` 。因此，您可以使用Mutiny APIs来处理下游的信息和错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer using Reactive Stream APIs, you can use `MutinyEmitter` that will return `Uni&lt;Void&gt;` from the `send` method.  You can therefore use Mutiny APIs for handling downstream messages and errors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您偏好于使用Reactive Stream APIs，您可以使用 `MutinyEmitter` ，它将在 `send` 方法中返回 `Uni&lt;Void&gt;` 。因此，您可以使用Mutiny APIs来处理下游的信息和错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you require a higher level of support, you have options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要更高级别的支持，您可以选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you see the following invalid path error for your application JAR when trying to create a native executable using a container build, even though your JAR was built successfully, you're most likely using a remote daemon for your container runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在试图使用容器构建创建原生可执行文件时，尽管你的JAR已经成功构建，仍看到应用程序JAR出现以下无效路径错误，您很可能为容器运行时使用了一个远程守护进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you send objects with this AMQP connector (outbound connector), it gets encoded as JSON and sent as binary.
The `content-type` is set to `application/json`.
So, you can rebuild the object as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你用这个AMQP连接器（出站连接器）发送对象，它会被编码为JSON，并以二进制形式发送。 `content-type` 被设置为 `application/json` 。因此，你可以按以下方式重建对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you send objects with this AMQP connector (outbound connector), it gets encoded as JSON and sent as binary.  The `content-type` is set to `application/json`.  So, you can rebuild the object as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你用这个AMQP连接器（出站连接器）发送对象，它会被编码为JSON，并以二进制形式发送。 `content-type` 被设置为 `application/json` 。因此，你可以按以下方式重建对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you set `quarkus.oidc.client-id` but your endpoint does not require remote access to one of OpenID Connect Provider endpoints (introspection, token acquisition, etc.) then do not set a client secret with the `quarkus.oidc.credentials` or similar properties as it will not be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你设置了 `quarkus.oidc.client-id` ，但你的端点不需要远程访问OpenID Connect提供者的一个端点（自省、令牌获取等），那么就不要设置带有 `quarkus.oidc.credentials` 或类似属性的客户秘钥，因为它不会被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests
with the `@DisabledOnIntegrationTest` annotation in order to skip them when testing against a native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你像我们上面建议的那样，在JVM和原生执行之间共享测试类，你可以用 `@DisabledOnNativeImage` 注解标记某些测试，被标注的测试只在JVM上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests
with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你像我们上面建议的那样，在JVM和原生执行之间共享你的测试类，你可以用 `@DisabledOnNativeImage` 注解标记某些测试，以便只在JVM上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnIntegrationTest` annotation in order to skip them when testing against a native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你像我们上面建议的那样，在JVM和原生执行之间共享测试类，你可以用 `@DisabledOnNativeImage` 注解标记某些测试，被标注的测试只在JVM上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你像我们上面建议的那样，在JVM和原生执行之间共享你的测试类，你可以用 `@DisabledOnNativeImage` 注解标记某些测试，以便只在JVM上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you stopped the application
(keep in mind you don't have to do it, changes will be automatically deployed by our live reload feature),
restart the application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你停止了应用程序（请记住，你不必这样做，变化将由我们的实时重载功能自动部署），用以下方法重新启动应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you stopped the application (keep in mind you don't have to do it, changes will be automatically deployed by our live reload feature), restart the application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你停止了应用程序（请记住，你不必这样做，变化将由我们的实时重载功能自动部署），用以下方法重新启动应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use &lt;&lt;dev-services,Dev Services&gt;&gt;, launching the container manually is not necessary!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 link:#dev-services[开发服务] ，则不需要手动启动容器！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Hibernate Reactive, look at &lt;&lt;persisting-kafka-messages-with-hibernate-reactive&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用Hibernate Reactive，请参看 link:#persisting-kafka-messages-with-hibernate-reactive[[使用Hibernate Reactive持久化Kafka消息]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Hibernate Reactive, look at &lt;&lt;writing-entities-managed-by-hibernate-reactive-to-kafka&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用Hibernate Reactive，请参看link:#writing-entities-managed-by-hibernate-reactive-to-kafka[[将hibernate reactive管理的实体写入kafka]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Keycloak and Bearer tokens then also see the xref:security-keycloak-authorization.adoc[Using Keycloak to Centralize Authorization] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用 Keycloak 和 不记名(Bearer) 令牌，则另请参阅 xref:security-keycloak-authorization.adoc[使用 Keycloak 集中授权]指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use MongoDB with Panache in conjunction with RESTEasy Reactive, you can directly return a reactive type inside your JAX-RS resource endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您将MongoDB和Panache和RESTEasy Reactive结合使用，您可以直接在JAX-RS资源端点内返回一个响应式类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use `Basic` or `Form` HTTP-based authentication then you must add an `IdentityProvider` instance that can convert a username and password to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用基于 `Basic` 或 `Form` HTTP的认证，那么您必须添加一个 `IdentityProvider` 实例，它可以将用户名和密码转换成 `SecurityIdentity` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the AMQP connector with the `quarkus-smallrye-health` extension, it contributes to the readiness and liveness probes.
The AMQP connector reports the readiness and liveness of each channel managed by the connector.
At the moment, the AMQP connector uses the same logic for the readiness and liveness checks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你将AMQP连接器与 `quarkus-smallrye-health` 扩展一起使用，它将有助于就绪性和活跃度探测。AMQP连接器报告连接器所管理的每个通道的就绪性和活跃度。目前，AMQP连接器对就绪性和活跃度检查使用同样的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the AMQP connector with the `quarkus-smallrye-health` extension, it contributes to the readiness and liveness probes.  The AMQP connector reports the readiness and liveness of each channel managed by the connector.  At the moment, the AMQP connector uses the same logic for the readiness and liveness checks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你将AMQP连接器与 `quarkus-smallrye-health` 扩展一起使用，它将有助于就绪性和活跃度探测。AMQP连接器报告连接器所管理的每个通道的就绪性和活跃度。目前，AMQP连接器对就绪性和活跃度检查使用同样的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the MicroProfile Metrics API in your application, the Micrometer extension will create an adaptive
layer to map those metrics into the Micrometer registry. Note that naming conventions between the two
systems is different, so the metrics that are emitted when using MP Metrics with Micrometer will change.
You can use a `MeterFilter` to remap names or tags according to your conventions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您在您的应用程序中使用MicroProfile Metrics API，Micrometer扩展将创建一个自适应层l来把这些metrics映射到Micrometer registry中。注意，两个系统之间的命名规则是不同的，所以在Micrometer中使用MP Metrics时发出的metrics将发生变化。您可以使用 `MeterFilter` ，根据您的规范重新映射名称或标签。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the MicroProfile Metrics API in your application, the Micrometer extension will create an adaptive layer to map those metrics into the Micrometer registry. Note that naming conventions between the two systems is different, so the metrics that are emitted when using MP Metrics with Micrometer will change.  You can use a `MeterFilter` to remap names or tags according to your conventions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您在您的应用程序中使用MicroProfile Metrics API，Micrometer扩展将创建一个自适应层l来把这些metrics映射到Micrometer registry中。注意，两个系统之间的命名规则是不同的，所以在Micrometer中使用MP Metrics时发出的metrics将发生变化。您可以使用 `MeterFilter` ，根据您的规范重新映射名称或标签。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the Mutiny-variant of Vert.x, be aware that the `deployVerticle` method returns a `Uni`, and you would need to trigger a subscription to make the actual deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Vert.x的Mutiny-variant，请注意 `deployVerticle` 方法返回一个 `Uni` ，你需要触发一个订阅来进行实际部署。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the standard `ObjectId` ID type, don't forget to retrieve your entity by creating a new `ObjectId` when the identifier comes from a path parameter. For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用标准的 `ObjectId` ID类型，当标识符来自路径参数时，不要忘记通过创建一个新的 `ObjectId` 来检索你的实体。例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use xref:redis-dev-services.adoc[Dev Services for Redis], launching the container manually is not necessary!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 link:redis-dev-services.html[Dev Services for Redis] ，则无需手动启动Redis服务容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want a lower memory footprint and faster initialization times for your lambda, you can compile your Java
code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想让你的lambda有更低的内存占用和更快的初始化时间，你可以把你的Java代码编译成本地可执行文件。只是确保要用 `-Pnative` 开关重建你的项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want a lower memory footprint and faster initialization times for your lambda, you can compile your Java code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想让你的lambda有更低的内存占用和更快的初始化时间，你可以把你的Java代码编译成本地可执行文件。只是确保要用 `-Pnative` 开关重建你的项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to access the Kafka record objects directly, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想直接访问Kafka record对象，请使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to build a native executable, make sure you have GraalVM installed correctly and just add a `native` property
to the build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想构建一个本地可执行文件，请确保你已经正确安装了GraalVM，并且只需向构建添加一个 `native` 属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to build a native executable, make sure you have GraalVM installed correctly and just add a `native` property to the build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想构建一个本地可执行文件，请确保你已经正确安装了GraalVM，并且只需向构建添加一个 `native` 属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to continue on this topic check:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想继续这个话题，请检查：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy every exposed `AbstractVerticle`, you can use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想部署每个暴露的 `AbstractVerticle` ，你可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application somewhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想把你的应用程序部署到某个地方（通常是在一个容器中），你需要部署整个 `quarkus-app` 目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deserialize a list of fruits, you need to create a deserializer with a Jackson `TypeReference` denoted the generic collection used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想反序列化一个fruit对象列表，您需要创建一个反序列化器，它会用Jackson `TypeReference` 表示所用到的通用集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deserialize a list of fruits, you need to create a deserializer with a `Type` denoted the generic collection used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想反序列化一个fruit对象列表，您需要创建一个反序列化器，它会用一个 `Type` 表示所用到的通用集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to disable this behavior and fetch resources during startup, you can use the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想禁用这种行为，并在启动期间获取资源，您可以使用以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想进一步了解文档 https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], 在Quarkus中使用的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想更进一步，请参看link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging]，在Quarkus中使用的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml`
you'll see this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用原生，那么必须为本地GraalVM部署设置一个环境变量。如果你看一下 `sam.native.yaml` ，你会看到这个变量：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用原生，那么必须为本地GraalVM部署设置一个环境变量。如果你看一下 `sam.native.yaml` ，你会看到这个变量：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is
`com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type
of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds
to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想为AWS HTTP API手工编码原始事件，AWS Lambda库有请求事件类型，是 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` ，响应事件类型是 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse` 。这与 `quarkus-amazon-lambda-http` 扩展和AWS HTTP API相对应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想为AWS HTTP API手工编码原始事件，AWS Lambda库有请求事件类型，是 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` ，响应事件类型是 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse` 。这与 `quarkus-amazon-lambda-http` 扩展和AWS HTTP API相对应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation:  `io.quarkus.amazon.lambda.http.model.AwsProxyRequest`
and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds
to `quarkus-amazon-lambda-rest` extension and the AWS REST API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想为AWS REST API手工编码原始事件，Quarkus有自己的实现： `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` 和 `io.quarkus.amazon.lambda.http.model.AwsProxyResponse` 。这与 `quarkus-amazon-lambda-rest` 扩展和AWS REST API相对应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想为AWS REST API手工编码原始事件，Quarkus有自己的实现： `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` 和 `io.quarkus.amazon.lambda.http.model.AwsProxyResponse` 。这与 `quarkus-amazon-lambda-rest` 扩展和AWS REST API相对应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to process all the records from a topic (from its beginning), you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想处理一个topic中的所有记录(从其最开始时)，您需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to simulate more complex
API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\_lambda_` (port 8081 in test mode) with
the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop
for processing.  Here's an example of that:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想在你的测试中模拟更复杂的API Gateway事件，那么请使用API Gateway json事件手动对 `http://localhost:8080/\_lambda_` (测试模式下的8081端口)做一个HTTP POST。这些事件将被直接放在Quarkus Lambda轮询循环中进行处理。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想在你的测试中模拟更复杂的API Gateway事件，那么请使用API Gateway json事件手动对 `http://localhost:8080/\_lambda_` (测试模式下的8081端口)做一个HTTP POST。这些事件将被直接放在Quarkus Lambda轮询循环中进行处理。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Docker to run a MongoDB database, you can use the following command to launch one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用Docker来运行MongoDB数据库，你可以使用以下命令来启动一个数据库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use RabbitMQ, you should use the xref:rabbitmq.adoc[SmallRye Reactive Messaging RabbitMQ extension].
Alternatively, if you want to use RabbitMQ with AMQP 1.0 you need to enable the AMQP 1.0 plugin in the RabbitMQ broker;
check the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.9/amqp/amqp.html#amqp-rabbitmq[connecting to RabbitMQ]
documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用 RabbitMQ，你应该使用 xref:rabbitmq.adoc[SmallRye响应式消息RabbitMQ 扩展] 。另外，如果你想使用带有 AMQP 1.0的RabbitMQ ，你需要在 RabbitMQ 代理中启用 AMQP 1.0 插件；请查看 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.9/amqp/amqp.html#amqp-rabbitmq[连接到 RabbitMQ] 文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use RabbitMQ, you should use the xref:rabbitmq.adoc[SmallRye Reactive Messaging RabbitMQ extension].  Alternatively, if you want to use RabbitMQ with AMQP 1.0 you need to enable the AMQP 1.0 plugin in the RabbitMQ broker; check the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.9/amqp/amqp.html#amqp-rabbitmq[connecting to RabbitMQ] documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用 RabbitMQ，你应该使用 xref:rabbitmq.adoc[SmallRye响应式消息RabbitMQ 扩展] 。另外，如果你想使用带有 AMQP 1.0的RabbitMQ ，你需要在 RabbitMQ 代理中启用 AMQP 1.0 插件；请查看 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.9/amqp/amqp.html#amqp-rabbitmq[连接到 RabbitMQ] 文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use SSL/TLS encryption, you need to add these properties in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用SSL/TLS加密，你需要在你的 `application.properties` 中添加这些属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use a specific codec, you need to set it on both ends explicitly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用一个特定的编解码器，你需要在两端明确地设置它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the AWS Gateway HTTP API, generate your project with this script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用AWS Gateway HTTP API，请用这个脚本生成你的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the AWS Gateway REST API, generate your project with this script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用AWS Gateway REST API，请用这个脚本生成你的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the legacy API, you need to add the following dependency to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用旧的API，你需要在你的构建文件中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you work with JWT tokens only and expect that a matching `JsonWebKey` will always be available (possibly after a key set refresh) then you should disable the token introspection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你只使用JWT令牌，并且期望一个匹配的 `JsonWebKey` ，那么你应该禁用令牌自省：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you work with Keycloak and configure `mp.jwt.verify.publickey.location` to point to HTTPS or HTTP based JsonWebKey (JWK) set then you can use the same approach as described in the xref:security-openid-connect.adoc#integration-testing-keycloak[OpenID Connect Bearer Token Integration testing] Keycloak section but only change the `application.properties` to use MP JWT configuration properties instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Keycloak，并配置了 `mp.jwt.verify.publickey.location` ，以指向HTTPS或基于HTTP的JsonWebKey（JWK）集，那么你可以使用与 link:security-openid-connect.html#integration-testing-keycloak[OpenID Connect Bearer Token集成测试] `Keycloak` 部分中描述的方法，只是需改变 `application.properties` ，以使用MP JWT配置属性来代替：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you work with Keycloak and observe the issuer verification errors due to the different host addresses then configure Keycloak with a `KEYCLOAK_FRONTEND_URL` property to ensure the same host address is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Keycloak，并观察到由于不同的主机地址导致发行人验证错误，那么用 `KEYCLOAK_FRONTEND_URL` 属性配置Keycloak，以确保使用相同的主机地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you work with Quarkus extensions which do not support `HTTP` (for example, `Quarkus GRPC`) or provide their own extension specific `HTTP` support conflicting with the one offered by `quarkus-smallrye-jwt` and `Vert.x HTTP` (example, `Quarkus Amazon Lambda`) and you would like to &lt;&lt;jwt-parser, Parse and Verify JsonWebToken with JWTParser&gt;&gt; then please use `smallrye-jwt` directly instead of `quarkus-smallrye-jwt`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用的Quarkus扩展不支持 `HTTP` （例如： `Quarkus GRPC` ），或者他们自己的扩展使用了特定的 `HTTP` ，与 `quarkus-smallrye-jwt` 和 `Vert.x HTTP` 提供的支持相冲突（例如： `Quarkus Amazon Lambda` ），并且你想 link:#jwt-parser[用JWTParser解析和验证JsonWebToken] ，那么请直接使用 `smallrye-jwt` ，而不是 `quarkus-smallrye-jwt` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you work with the opaque tokens then you can test them as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你用不透明的令牌，那么你可以按以下方式测试它们：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you'd like to access a public resource without `quarkus-keycloak-authorization` trying to apply its policies to it then you need to create a `permit` HTTP Policy configuration in `application.properties` as documented in the xref:security-authorization.adoc[Security Authorization] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想访问一个不受 `quarkus-keycloak-authorization` 授权策略影响的公共资源，那么您需要在 `application.properties` 中创建一个 `permit` HTTP策略配置，正如 link:security-authorization.html[安全授权] 指南中所记载的那样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you'd like to block access to the public resource to anonymous users then you can create an enforcing Keycloak Authorization Policy:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想阻止匿名用户访问公共资源，那么您可以创建一个强制的Keycloak授权策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you'd like to consume records only written and committed inside a Kafka transaction you need to configure the `isolation.level` property on the incoming channel as such:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想使用仅在 Kafka 事务中写入和提交的记录，您需要在传入通道上配置 `isolation.level` 属性，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you'd like to skip the token verification when the public endpoint methods are invoked then please disable the xref:security-built-in-authentication.adoc#proactive-authentication[proactive authentication].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想在调用公共端点方法时跳过令牌验证，那么请停用 link:security-built-in-authentication.html#proactive-authentication[主动验证] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're using repositories, then you will want to extend `PanacheMongoRepositoryBase` instead of `PanacheMongoRepository`
and specify your ID type as an extra type parameter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用存储库，那么你要继承 `PanacheMongoRepositoryBase` ，而不是 `PanacheMongoRepository` ，并指定你的ID类型作为一个额外的类型参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're using repositories, then you will want to extend `PanacheMongoRepositoryBase` instead of `PanacheMongoRepository` and specify your ID type as an extra type parameter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用存储库，那么你要继承 `PanacheMongoRepositoryBase` ，而不是 `PanacheMongoRepository` ，并指定你的ID类型作为一个额外的类型参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're using repositories, then you will want to extend `PanacheRepositoryBase` instead of `PanacheRepository`
and specify your ID type as an extra type parameter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Repository模式，那么要继承 `PanacheRepositoryBase` ，而非 `PanacheRepository` ，并将ID字段类型作为额外的类型参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're using repositories, then you will want to extend `PanacheRepositoryBase` instead of `PanacheRepository` and specify your ID type as an extra type parameter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Repository模式，那么要继承 `PanacheRepositoryBase` ，而非 `PanacheRepository` ，并将ID字段类型作为额外的类型参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Bearer tokens are in a JWT format, you can use either of the three extensions. Both `quarkus-oidc` and `quarkus-smallrye-jwt` support refreshing the JsonWebKey (JWK) set when the OpenID Connect provider rotates the keys.
Therefore, if remote token introspection must be avoided or is unsupported by the providers, use `quarkus-oidc` or `quarkus-smallrye-jwt` for verifying JWT tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您有JWT格式的 Bearer tokens，那么这三个扩展都可以使用。 `quarkus-oidc` 和 `quarkus-smallrye-jwt` 都支持在OpenID Connect提供者旋转密钥时刷新JsonWebKey（JWK）集，因此，如果必须避免远程token自查或提供者不支持，则应使用 `quarkus-oidc` 或 `quarkus-smallrye-jwt` 来验证JWTtoken。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Bearer tokens are in a JWT format, you can use either of the three extensions. Both `quarkus-oidc` and `quarkus-smallrye-jwt` support refreshing the JsonWebKey (JWK) set when the OpenID Connect provider rotates the keys.  Therefore, if remote token introspection must be avoided or is unsupported by the providers, use `quarkus-oidc` or `quarkus-smallrye-jwt` for verifying JWT tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您有JWT格式的 Bearer tokens，那么这三个扩展都可以使用。 `quarkus-oidc` 和 `quarkus-smallrye-jwt` 都支持在OpenID Connect提供者旋转密钥时刷新JsonWebKey（JWK）集，因此，如果必须避免远程token自查或提供者不支持，则应使用 `quarkus-oidc` 或 `quarkus-smallrye-jwt` 来验证JWTtoken。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Bearer tokens must be verified, use `quarkus-oidc`, `quarkus-smallrye-jwt`, or `quarkus-elytron-security-oauth2`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当需要验证Bearer tokens时，您可以使用 `quarkus-oidc` , `quarkus-smallrye-jwt` 和 `quarkus-elytron-security-oauth2` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.
First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的Kafka broker使用OAuth作为认证机制，您需要配置Kafka消费者来启用这个认证过程。首先，在您的应用程序中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的Kafka broker使用OAuth作为认证机制，您需要配置Kafka消费者来启用这个认证过程。首先，在您的应用程序中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Quarkus Security architecture includes RESTEasy Reactive and Jackson, Quarkus can limit the fields that are included in JSON serialization based on the configured security.
For more information, see xref:resteasy-reactive.adoc#secure-serialization[Writing REST services with RESTEasy Reactive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的Quarkus Security架构包含RESTEasy Reactive和Jackson时，Quarkus可以根据配置的安全性限制包含在JSON序列化中的字段。详情请参见 link:resteasy-reactive.html#secure-serialization[RESTEasy Reactive文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Quarkus Security architecture includes RESTEasy Reactive and Jackson, Quarkus can limit the fields that are included in JSON serialization based on the configured security.  For more information, see xref:resteasy-reactive.adoc#secure-serialization[Writing REST services with RESTEasy Reactive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的Quarkus Security架构包含RESTEasy Reactive和Jackson时，Quarkus可以根据配置的安全性限制包含在JSON序列化中的字段。详情请参见 link:resteasy-reactive.html#secure-serialization[RESTEasy Reactive文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your `@Transactional`-annotated method returns a reactive value, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的 `@Transactional` -注释的方法返回一个响应性的值，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application contains classes annotated with `javax.enterprise.context.ApplicationScoped`
for example, then `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` needs to be added as well. Same goes for any class that needs to have a dynamic proxy created at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您的应用程序包含了带有 `javax.enterprise.context.ApplicationScoped` 注解的类，那么也需要添加 `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` 。任何需要在运行时创建动态代理的类也是如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application contains classes annotated with `javax.enterprise.context.ApplicationScoped` for example, then `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` needs to be added as well. Same goes for any class that needs to have a dynamic proxy created at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您的应用程序包含了带有 `javax.enterprise.context.ApplicationScoped` 注解的类，那么也需要添加 `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` 。任何需要在运行时创建动态代理的类也是如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application needs to accept the tokens with the encrypted claims or with the encrypted inner signed claims then all you have to do is to set
`smallrye.jwt.decrypt.key.location` pointing to the decryption key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的应用程序需要接受带有加密的声明(claim)或带有加密的内部签名声明的令牌，那么你所要做的就是设置 `smallrye.jwt.decrypt.key.location` ，指向解密密钥的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application needs to accept the tokens with the encrypted claims or with the encrypted inner signed claims then all you have to do is to set `smallrye.jwt.decrypt.key.location` pointing to the decryption key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的应用程序需要接受带有加密的声明(claim)或带有加密的内部签名声明的令牌，那么你所要做的就是设置 `smallrye.jwt.decrypt.key.location` ，指向解密密钥的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your class doesn't obey these rules (for example by including a method that starts with `get` but is not a setter),
you could provide a custom codec for it.
Your custom codec will be automatically discovered and registered inside the codec registry.
See xref:mongodb.adoc#simplifying-mongodb-client-usage-using-bson-codec[Using BSON codec].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的类不遵守这些规则（例如，包括一个以 `get` 开始但不是setter的方法），你可以为它提供一个自定义的编解码器。你的自定义编解码器将被自动发现并在编解码器注册表内注册。参见 link:mongodb.html#simplifying-mongodb-client-usage-using-bson-codec[使用BSON编解码器] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your class doesn't obey these rules (for example by including a method that starts with `get` but is not a setter), you could provide a custom codec for it.  Your custom codec will be automatically discovered and registered inside the codec registry.  See xref:mongodb.adoc#simplifying-mongodb-client-usage-using-bson-codec[Using BSON codec].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的类不遵守这些规则（例如，包括一个以 `get` 开始但不是setter的方法），你可以为它提供一个自定义的编解码器。你的自定义编解码器将被自动发现并在编解码器注册表内注册。参见 link:mongodb.html#simplifying-mongodb-client-usage-using-bson-codec[使用BSON编解码器] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your class is in a third-party jar, you can do it by using an empty class that will host the `@RegisterForReflection` for it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的类在第三方的jar中，你可以通过使用一个空的类来做，这个空的类将为它托管 `@RegisterForReflection` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code makes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,
as GraalVM will only include the dependencies when explicitly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.
For further information, please consult the xref:native-and-ssl.adoc[Quarkus SSL guide]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的代码进行了HTTPS调用，如对微服务（或AWS服务）进行了调用，那么你将需要在原生镜像中添加配置，因为GraalVM只有在明确声明的情况下才会包含依赖项。Quarkus 默认会在隐含需要它的扩展上启用该功能。欲了解更多信息，请咨询 link:native-and-ssl.html[Quarkus SSL指南]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your delete query does not start with `delete`, we support the following additional forms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的删除语句不是以 `delete` 开始，我们还支持以下的形式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的方法加了 `@Transactional` 注解，那么它即使没有添加 `@Blocking` 注解也将被自动视为 _阻塞_ 方法 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your method returns a `Uni` or `CompletionStage`, you need to add the `@NonBlocking` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的方法返回一个 `Uni` 或 `CompletionStage` ，您需要添加 `@NonBlocking` 注解：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your query does not start with `{`, we will consider it a PanacheQL query:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的查询不是以 `{` 开始，我们将认为它是一个PanacheQL查询：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your select query does not start with `from`, we support the following additional forms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的查询语句不是以 `from` 开始，我们还支持以下的形式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your update query does not start with `update`, we support the following additional forms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的更新语句不是以 `update` 开始，我们还支持以下的形式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ignoring endpoints</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>忽略节点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine the following entity:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>想象一下下面这个实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine we have a `Fruit` data class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>假设我们有一个 `Fruit` 数据类，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative and reactive code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式和响应式代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative vs. Reactive: a question of threads</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式与响应式：线程的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing GraphQL Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实施GraphQL服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing fire and forget interactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现即发即弃（fire and forget）交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing gRPC Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现gRPC服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the {quickstarts-tree-url}/security-keycloak-authorization-quickstart/config/quarkus-realm.json[realm configuration file] to create a new realm.
For more details, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>导入{quickstarts-tree-url}/security-keycloak-authorization-quickstart/config/quarkus-realm.json[realm配置文件]来创建一个新realm。更多细节，请参阅Keycloak文档中关于如何 link:https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[创建一个新的realm] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the {quickstarts-tree-url}/security-keycloak-authorization-quickstart/config/quarkus-realm.json[realm configuration file] to create a new realm.  For more details, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>导入{quickstarts-tree-url}/security-keycloak-authorization-quickstart/config/quarkus-realm.json[realm配置文件]来创建一个新realm。更多细节，请参阅Keycloak文档中关于如何 link:https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[创建一个新的realm] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the {quickstarts-tree-url}/security-openid-connect-quickstart/config/quarkus-realm.json[realm configuration file] to create a new realm. For more details, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>导入 {quickstarts-tree-url}/security-openid-connect-quickstart/config/quarkus-realm.json[领域配置文件] 来创建一个新领域(realm)。更多细节，请参阅Keycloak文档中关于如何 https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[创建一个新的领域] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Important Gradle configuration points</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle配置要点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Important Maven configuration points</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven配置要点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Important Technical Note</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重要技术说明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Improve and expedite the inner loop development process with live coding where code changes are automatically reflected in your running application. code -&gt; refresh browser -&gt; repeat</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过实时编码改善和加快内循环开发过程，代码的变化会自动反映在你运行的应用程序中。 代码 -&gt; 刷新浏览器 -&gt; 重复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In *batch* mode, your application can receive all the records returned by the consumer *poll* in one go.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 *批量* 模式下，您的程序可以一次性接收消费者 *轮询* 返回的所有记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In JSON Web Key (JWK) format</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以JsonWebKey (JWK) 格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In JVM mode, it will work out of the box.
However, to compile your application to a native executable, you need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在JVM模式下，它开箱即用。然而，如果要把您的应用程序编译成一个原生的可执行文件，您需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在JVM模式下，它开箱即用。然而，如果要把您的应用程序编译成一个原生的可执行文件，您需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Kafka, a consumer group is a set of consumers which cooperate to consume data from a topic.
A topic is divided into a set of partitions.
The partitions of a topic are assigned among the consumers in the group, effectively allowing to scale consumption throughput.
Note that each partition is assigned to a single consumer from a group.
However, a consumer can be assigned multiple partitions if the number of partitions is greater than the number of consumer in the group.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kafka中，消费者组表示可以通过合作来消费来自于同一个topic的数据的一组消费者。 一个topic可以包含一组分区(partitions)。一个topic的分区会在组内的消费者之间分配，从而有效地提高消费的吞吐量。请注意，每个分区只会被分配给组内的一个消费者。但如果分区的数量大于组中消费者的数量， 那么一个消费者可以被分配多个分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Kafka, a consumer group is a set of consumers which cooperate to consume data from a topic.  A topic is divided into a set of partitions.  The partitions of a topic are assigned among the consumers in the group, effectively allowing to scale consumption throughput.  Note that each partition is assigned to a single consumer from a group.  However, a consumer can be assigned multiple partitions if the number of partitions is greater than the number of consumer in the group.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kafka中，消费者组表示可以通过合作来消费来自于同一个topic的数据的一组消费者。 一个topic可以包含一组分区(partitions)。一个topic的分区会在组内的消费者之间分配，从而有效地提高消费的吞吐量。请注意，每个分区只会被分配给组内的一个消费者。但如果分区的数量大于组中消费者的数量， 那么一个消费者可以被分配多个分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the default Jackson `ObjectMapper` obtained via CDI (and consumed by the Quarkus extensions) is configured to ignore unknown properties
(by disabling the `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus中，通过CDI获得的默认Jackson `ObjectMapper` （并由Quarkus扩展使用）被配置为忽略未知属性（通过禁用 `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the default Jackson `ObjectMapper` obtained via CDI (and consumed by the Quarkus extensions) is configured to ignore unknown properties (by disabling the `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus中，通过CDI获得的默认Jackson `ObjectMapper` （并由Quarkus扩展使用）被配置为忽略未知属性（通过禁用 `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _experimental_ mode, early feedback is requested to mature the idea.
There is no guarantee of stability nor long term presence in the platform until the solution matures.
Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _experimental(实验)_ 模式下，要求早期反馈以使想法成熟。在解决方案成熟之前，不保证稳定性或长期存在于平台中。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题列表] 中提出问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _experimental_ mode, early feedback is requested to mature the idea.  There is no guarantee of stability nor long term presence in the platform until the solution matures.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _experimental(实验)_ 模式下，要求早期反馈以使想法成熟。在解决方案成熟之前，不保证稳定性或长期存在于平台中。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题列表] 中提出问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _preview_, backward compatibility and presence in the ecosystem is not guaranteed.
Specific improvements might require changing configuration or APIs, and plans to become _stable_ are under way.
Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _preview(预览)_ 中，不保证向后兼容和在生态系统中的存在。具体的改进可能需要改变配置或API，并且正在计划变得 _稳定_ 。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题列表] 中提出问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _preview_, backward compatibility and presence in the ecosystem is not guaranteed.  Specific improvements might require changing configuration or APIs, and plans to become _stable_ are under way.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _preview(预览)_ 中，不保证向后兼容和在生态系统中的存在。具体的改进可能需要改变配置或API，并且正在计划变得 _稳定_ 。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题列表] 中提出问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a Gradle project, you would find a similar setup:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Gradle项目中，你会发现一个类似的设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a terminal, launch the application in dev mode using: `./mvnw quarkus:dev`.
Quarkus automatically starts a database instance for you and configure the application. Now we only need to implement the HTTP endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在终端中，使用：`./mvnw quarkus:dev`。Quarkus会自动为您启动一个数据库实例并配置应用程序。现在我们只需要实现HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a terminal, launch the application in dev mode using: `./mvnw quarkus:dev`.  Quarkus automatically starts a database instance for you and configure the application. Now we only need to implement the HTTP endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在终端中，使用：`./mvnw quarkus:dev`。Quarkus会自动为您启动一个数据库实例并配置应用程序。现在我们只需要实现HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a terminal, navigate to the root of the project and run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在终端中，切换到项目根目录下 运行以下命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to Vert.x core, you can use most Vert.x ecosystem libraries.
Some Quarkus extension already wraps Vert.x libraries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了Vert.x核心，你可以使用大多数Vert.x生态系统库。一些Quarkus扩展已经包装了Vert.x库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to Vert.x core, you can use most Vert.x ecosystem libraries.  Some Quarkus extension already wraps Vert.x libraries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了Vert.x核心，你可以使用大多数Vert.x生态系统库。一些Quarkus扩展已经包装了Vert.x库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.
You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了常规文件外，该构建还产生了 `target/getting-started-1.0.0-SNAPSHOT-runner` 。你可以用以下方式运行它： `./target/getting-started-1.0.0-SNAPSHOT-runner` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.  You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了常规文件外，该构建还产生了 `target/getting-started-1.0.0-SNAPSHOT-runner` 。你可以用以下方式运行它： `./target/getting-started-1.0.0-SNAPSHOT-runner` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to this default configuration, you can configure the name of the `Map` producer using the `kafka-configuration` attribute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了这个默认配置外，您还可以使用 `kafka-configuration` 属性配置 `Map` 生产者的名称：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to this you can also create your own test stereotypes. For example, we could create a `@TransactionalQuarkusTest`
as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除此以外，您还可以创建您自己的测试 stereotypes。例如，我们可以创建一个 `@TransactionalQuarkusTest` ，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to this you can also create your own test stereotypes. For example, we could create a `@TransactionalQuarkusTest` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除此以外，您还可以创建您自己的测试 stereotypes。例如，我们可以创建一个 `@TransactionalQuarkusTest` ，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, IntelliJ IDEA has additional support for Quarkus in their Ultimate non-open source version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，IntelliJ IDEA在其闭源的Ultimate版本中对Quarkus有额外的支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, remember to enable the AWS X-Ray tracing parameter in `manage.sh`, in the `cmd_create()` function.  This can also be set in the AWS Management Console.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，记得在 `manage.sh` ， `cmd_create()` 函数中启用AWS X-Ray追踪参数。这也可以在AWS管理控制台中进行设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the xref:tooling.adoc[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，xref:tooling.adoc[工具指南] 文档解释了如何做到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, run `curl localhost:8080/count` to check the counter value.
After a few seconds, re-run `curl localhost:8080/count` to verify the counter has been incremented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在另一个终端，运行 `curl localhost:8080/count` 检查计数器的值。几秒钟后，重新运行 `curl localhost:8080/count` ，以验证计数器已被递增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, run `curl localhost:8080/count` to check the counter value.  After a few seconds, re-run `curl localhost:8080/count` to verify the counter has been incremented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在另一个终端，运行 `curl localhost:8080/count` 检查计数器的值。几秒钟后，重新运行 `curl localhost:8080/count` ，以验证计数器已被递增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在另外一个终端中，运行:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case of in-memory channels, `@Broadcast` annotation can be used on the `@Outgoing` method. For example,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在内存 channels 的情况下， `@Broadcast` 注释可以用在 `@Outgoing` 方法上。比如说,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are interested in using the `Flyway` object directly, you can inject it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你有兴趣直接使用 `Flyway` 对象，可以按以下方式注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you encounter the `org.bson.codecs.configuration.CodecConfigurationException` exception, it means the codec is not able to
automatically convert your object.
This codec obeys the Java Bean standard, so it will successfully convert a POJO using public fields or getters/setters.
You can use `@BsonIgnore` to make a field, or a getter/setter, ignored by the codec.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你遇到了 `org.bson.codecs.configuration.CodecConfigurationException` 异常，这意味着编解码器不能自动转换你的对象。这个编解码器遵守Java Bean的标准，所以它将成功地转换使用公共字段或getter/setters的POJO。你可以使用 `@BsonIgnore` ，使一个字段或一个getter/setter被编解码器所忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you encounter the `org.bson.codecs.configuration.CodecConfigurationException` exception, it means the codec is not able to automatically convert your object.  This codec obeys the Java Bean standard, so it will successfully convert a POJO using public fields or getters/setters.  You can use `@BsonIgnore` to make a field, or a getter/setter, ignored by the codec.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你遇到了 `org.bson.codecs.configuration.CodecConfigurationException` 异常，这意味着编解码器不能自动转换你的对象。这个编解码器遵守Java Bean的标准，所以它将成功地转换使用公共字段或getter/setters的POJO。你可以使用 `@BsonIgnore` ，使一个字段或一个getter/setter被编解码器所忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.
If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您对使用序列化器自动侦测有任何疑问，您可以通过设置 `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false` 来彻底关闭它。如果您需要这样做，请在 link:https://github.com/quarkusio/quarkus/issues[Quarkus问题跟踪] 中提交一个bug，这样我们就能跟踪并解决您的任何问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.  If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您对使用序列化器自动侦测有任何疑问，您可以通过设置 `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false` 来彻底关闭它。如果您需要这样做，请在 link:https://github.com/quarkusio/quarkus/issues[Quarkus问题跟踪] 中提交一个bug，这样我们就能跟踪并解决您的任何问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In cases where the GraalVM requirement cannot be met, you can use Docker to perform the Maven or Gradle build by using a multi-stage Docker build. A multi-stage Docker build is like two Dockerfile files combined in one, the first is used to build the artifact used by the second.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在GraalVM的需求不能满足的情况下，你可以使用Docker通过使用多阶段Docker构建来执行Maven或Gradle构建。一个多阶段的Docker构建就像两个Dockerfile文件合并在一起，第一个用来构建，第二个使用工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In certain circumstances, you may want to build the native image in a separate step.
For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.
For this use case, you can set the `quarkus.package.type=native-sources`.
This will execute the java compilation as if you had started native compilation (`-Pnative`), but stops before triggering the actual call to GraalVM's `native-image`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，你可能想在独立的步骤中构建本地可执行文件。例如，在CI/CD pipeline中，你可能希望在独立步骤中生成用于原生可执行文件构建的源文件，另一个步骤才是使用这些源文件来构建原生可执行文件。对于这种情况，你可以设置 `quarkus.package.type=native-sources` 。这个属性会像原生编译一样（ `-Pnative` ）执行java编译，但不会触发调用GraalVM的 `native-image` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In certain circumstances, you may want to build the native image in a separate step.
For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.
For this use case, you can set the `quarkus.package.type=native-sources`.
This will execute the java compilation as if you would have started native compilation (`-Pnative`), but stops before triggering the actual call to GraalVM's `native-image`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，你可能想在一个单独的步骤中构建本地镜像。例如，在CI/CD管道中，你可能希望有一个步骤来生成用于原生镜像的源，另一个步骤是使用这些源来实际构建原生可执行文件。对于这种用例，你可以设置 `quarkus.package.type=native-sources` 。这将执行java编译，就像你已经开始原生编译一样（ `-Pnative` ），但在触发对GraalVM的 `native-image` 的实际调用之前停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In certain circumstances, you may want to build the native image in a separate step.  For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.  For this use case, you can set the `quarkus.package.type=native-sources`.  This will execute the java compilation as if you had started native compilation (`-Pnative`), but stops before triggering the actual call to GraalVM's `native-image`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，你可能想在独立的步骤中构建本地可执行文件。例如，在CI/CD pipeline中，你可能希望在独立步骤中生成用于原生可执行文件构建的源文件，另一个步骤才是使用这些源文件来构建原生可执行文件。对于这种情况，你可以设置 `quarkus.package.type=native-sources` 。这个属性会像原生编译一样（ `-Pnative` ）执行java编译，但不会触发调用GraalVM的 `native-image` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In certain circumstances, you may want to build the native image in a separate step.  For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.  For this use case, you can set the `quarkus.package.type=native-sources`.  This will execute the java compilation as if you would have started native compilation (`-Pnative`), but stops before triggering the actual call to GraalVM's `native-image`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，你可能想在一个单独的步骤中构建本地镜像。例如，在CI/CD管道中，你可能希望有一个步骤来生成用于原生镜像的源，另一个步骤是使用这些源来实际构建原生可执行文件。对于这种用例，你可以设置 `quarkus.package.type=native-sources` 。这将执行java编译，就像你已经开始原生编译一样（ `-Pnative` ），但在触发对GraalVM的 `native-image` 的实际调用之前停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev and test mode, Quarkus will start a mock AWS Lambda event server
that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying
Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment
as much as possible locally without requiring tools like Docker and SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下，Quarkus会启动一个模拟的AWS Lambda事件服务器，该服务器将HTTP请求转换为相应的API Gateway事件类型，并将其发布到底层的Quarkus HTTP lambda环境进行处理。这尽可能在本地模拟AWS Lambda环境，而不需要Docker和SAM CLI等工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下，Quarkus会启动一个模拟的AWS Lambda事件服务器，该服务器将HTTP请求转换为相应的API Gateway事件类型，并将其发布到底层的Quarkus HTTP lambda环境进行处理。这尽可能在本地模拟AWS Lambda环境，而不需要Docker和SAM CLI等工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev mode Quarkus will automatically restart the application if
any of the existing migration scripts get modified. If you want to take
advantage of this while developing and testing new migration scripts,
you will want to set `%dev.quarkus.flyway.clean-at-start=true`, so that
Flyway actually runs the modified migration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果任何当前迁移脚本被修改，Quarkus在开发模式下会自动重启应用。如果你想在开发测试新的迁移脚本的时候充分利用这个特性，你需要设置  `%dev.quarkus.flyway.clean-at-start=true` ，这样Flyway会运行被修改的迁移脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev mode Quarkus will automatically restart the application if any of the existing migration scripts get modified. If you want to take advantage of this while developing and testing new migration scripts, you will want to set `%dev.quarkus.flyway.clean-at-start=true`, so that Flyway actually runs the modified migration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果任何当前迁移脚本被修改，Quarkus在开发模式下会自动重启应用。如果你想在开发测试新的迁移脚本的时候充分利用这个特性，你需要设置  `%dev.quarkus.flyway.clean-at-start=true` ，这样Flyway会运行被修改的迁移脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev mode and when running tests, xref:amqp-dev-services.adoc[Dev Services for AMQP] automatically starts an AMQP broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下，当运行测试时，link:amqp-dev-services.html[AMQP的开发服务] 会自动启动一个AMQP代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In environments with read only file systems you may receive errors of the form:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在具有只读文件系统的环境中，您可能会收到以下形式的错误：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, Vert.x verticles are not CDI beans.
And so cannot use injection.
However, in Quarkus, you can deploy verticles as beans.
Note that in this case, CDI (Arc in Quarkus) is responsible for creating the instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般来说，Vert.x的verticles不是CDI beans。所以不能使用注入。然而，在Quarkus中，你可以把verticle部署为Bean。注意，在这种情况下，CDI（Quarkus中的Arc）负责创建实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, Vert.x verticles are not CDI beans.  And so cannot use injection.  However, in Quarkus, you can deploy verticles as beans.  Note that in this case, CDI (Arc in Quarkus) is responsible for creating the instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般来说，Vert.x的verticles不是CDI beans。所以不能使用注入。然而，在Quarkus中，你可以把verticle部署为Bean。注意，在这种情况下，CDI（Quarkus中的Arc）负责创建实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, these properties are prefixed using `%prod` to enable them only when running in production mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般来说，这些属性的前缀使用 `%prod` ，以便只在生产模式下运行时启用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In https://github.com/quarkusio/quarkus-quickstarts/blob/main/hibernate-reactive-panache-quickstart/src/test/java/org/acme/hibernate/orm/panache/FruitsEndpointTest.java[FruitsEndpointTest.java] you can see how the test for the fruit application can be implemented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 https://github.com/quarkusio/quarkus-quickstarts/blob/main/hibernate-reactive-panache-quickstart/src/test/java/org/acme/hibernate/orm/panache/FruitsEndpointTest.java[FruitsEndpointTest.java]中，您可以看到如何实现水果应用程序的测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在原生模式下，Snappy默认是禁用的，因为使用Snappy需要嵌入一个原生库，并在应用程序启动时对其进行解包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to access the admin endpoint you should obtain a token for the `admin` user:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了访问管理节点，您需要获得一个 `admin` 用户的token：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to show a more practical example of Kotlin usage we will add a simple link:https://kotlinlang.org/docs/reference/data-classes.html[data class] called `Greeting.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了展示一个更实际的Kotlin使用例子，我们将像这样添加一个简单的 link:https://kotlinlang.org/docs/reference/data-classes.html[数据类] ，叫做 `Greeting.kt` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other contexts, it is possible to have other parallel representations of the same information or parts of it, for example, `SecurityContext`
for JAX-RS or `JsonWebToken` for JSON Web Tokens (JWT).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在其他一些情况下，您可能有相同信息或部分相同信息的其他不同表示，如JAX-RS的 `SecurityContext` ，或JWT的 `JsonWebToken` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other contexts, it is possible to have other parallel representations of the same information or parts of it, for example, `SecurityContext` for JAX-RS or `JsonWebToken` for JSON Web Tokens (JWT).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在其他一些情况下，您可能有相同信息或部分相同信息的其他不同表示，如JAX-RS的 `SecurityContext` ，或JWT的 `JsonWebToken` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our case, we want to configure the `address` attribute to indicate the name of the queue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在我们的情形中，我们想配置 `address` 属性来表示队列的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In previous versions of this extension you had to set up your pom or gradle
to zip up your executable for native deployments, but this is not the case anymore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个扩展的前几个版本中，你必须设置你的pom或gradle来为原生部署压缩你的可执行文件，但现在不再是这样了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In previous versions of this extension you had to set up your pom or gradle to zip up your executable for native deployments, but this is not the case anymore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个扩展的前几个版本中，你必须设置你的pom或gradle来为原生部署压缩你的可执行文件，但现在不再是这样了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In rare cases, you may need to access the underlying Kafka clients.
`KafkaClientService` provides thread-safe access to `Producer` and `Consumer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在少数情况下，您可能需要访问底层的Kafka客户端。`KafkaClientService` 提供线程安全的方式来访问 `Producer` 和 `Consumer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In rare cases, you may need to access the underlying Kafka clients.  `KafkaClientService` provides thread-safe access to `Producer` and `Consumer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在少数情况下，您可能需要访问底层的Kafka客户端。`KafkaClientService` 提供线程安全的方式来访问 `Producer` 和 `Consumer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, this `iss` claim verification may not work. For example, if the discovered `issuer` property contains an internal HTTP/IP address while the token `iss` claim value contains an external HTTP/IP address. Or when a discovered `issuer` property contains the template tenant variable but the token `iss` claim value has the complete tenant-specific issuer value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，这种 `iss` 声明验证可能不起作用。例如，如果发现的 `issuer` 属性包含一个内部 HTTP/IP地址，而令牌 `iss` 声明值包含一个外部 HTTP/IP地址。或者当发现的 `issuer` 属性包含模板租户变量，但令牌 `iss` 声明值有完整的租户特定发行人(tenant-specific issuer )的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, you may want to programmatically check whether a request is granted to access a protected resource. By
injecting a `SecurityIdentity` instance in your beans, you are allowed to check permissions as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，您可能想以编程方式检查一个请求是否被允许访问受保护的资源。通过在您的Bean中注入一个 `SecurityIdentity` 实例，您就可以按以下方式检查权限了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, you may want to programmatically check whether a request is granted to access a protected resource. By injecting a `SecurityIdentity` instance in your beans, you are allowed to check permissions as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，您可能想以编程方式检查一个请求是否被允许访问受保护的资源。通过在您的Bean中注入一个 `SecurityIdentity` 实例，您就可以按以下方式检查权限了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, you may want to use the https://www.keycloak.org/docs/latest/authorization_services/#_service_client_api[Keycloak Authorization Client Java API] to perform
specific operations like managing resources and obtaining permissions directly from Keycloak. For that, you can inject a
`AuthzClient` instance into your beans as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，您可能想使用 link:https://www.keycloak.org/docs/latest/authorization_services/#_service_client_api[Keycloak授权客户端Java API] 来执行特定的操作，如管理资源和直接从Keycloak获得权限。为此，您可以按以下方式将一个 `AuthzClient` 实例注入到您的bean中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, you may want to use the https://www.keycloak.org/docs/latest/authorization_services/#_service_client_api[Keycloak Authorization Client Java API] to perform specific operations like managing resources and obtaining permissions directly from Keycloak. For that, you can inject a `AuthzClient` instance into your beans as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，您可能想使用 link:https://www.keycloak.org/docs/latest/authorization_services/#_service_client_api[Keycloak授权客户端Java API] 来执行特定的操作，如管理资源和直接从Keycloak获得权限。为此，您可以按以下方式将一个 `AuthzClient` 实例注入到您的bean中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some use cases, it is convenient to use the messaging patterns to transfer messages inside the same application.
When you don't connect a channel to a messaging backend like Kafka, everything happens in-memory, and the streams are created by chaining methods together.
Each chain is still a reactive stream and enforces the back-pressure protocol.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，使用消息模式在同一个应用程序内传输消息是很方便的。当您没有将channel连接到像Kafka这样的消息后端时，一切都会发生在内存中，并且流会通过链式方法创建。每个链式调用仍是一个响应式流，并执行背压策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some use cases, it is convenient to use the messaging patterns to transfer messages inside the same application.  When you don't connect a channel to a messaging backend like Kafka, everything happens in-memory, and the streams are created by chaining methods together.  Each chain is still a reactive stream and enforces the back-pressure protocol.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，使用消息模式在同一个应用程序内传输消息是很方便的。当您没有将channel连接到像Kafka这样的消息后端时，一切都会发生在内存中，并且流会通过链式方法创建。每个链式调用仍是一个响应式流，并执行背压策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such a situation, the error you might encounter is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，你可能遇到的错误是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such case (if you don't want to wait for the new command to be supported in https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`]), you can implement it in either https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] or https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`].
In order to do so, you will need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，如果你不想等到未来版本的 link:https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] 支持这些命令，可以在 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] 或 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] 中实现它们。实现自定义的Redis命令需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such cases you may want to consider skipping the issuer verification by setting `quarkus.oidc.token.issuer=any`. Please note that it is not recommended and should be avoided unless no other options are available:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，你可能要考虑通过设置 `quarkus.oidc.token.issuer=any` ，来跳过发行人验证。请注意，不建议这样做，除非没有其他选择，否则应避免这样做：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such cases, if you work with Keycloak then please start it with a `KEYCLOAK_FRONTEND_URL` system property set to the externally accessible base URL.
If you work with other Openid Connect providers then please check your provider's documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，如果你使用Keycloak，那么请用 `KEYCLOAK_FRONTEND_URL` 系统属性设置为外部可访问的基本URL来启动它。如果你使用其他Openid Connect提供商，那么请查看你的提供商的文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such cases, if you work with Keycloak then please start it with a `KEYCLOAK_FRONTEND_URL` system property set to the externally accessible base URL.  If you work with other Openid Connect providers then please check your provider's documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，如果你使用Keycloak，那么请用 `KEYCLOAK_FRONTEND_URL` 系统属性设置为外部可访问的基本URL来启动它。如果你使用其他Openid Connect提供商，那么请查看你的提供商的文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`]
functionality to the `companion object`.  Apart from this slight change, we can then work with our types in ways that map easily
from the Java side of world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kotlin版本中，我们只是把大部分的功能 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`] 转移到了 `companion object` 。除了这个细微的变化，我们还可以从 Java 方面轻松映射的方式来处理我们的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`] functionality to the `companion object`.  Apart from this slight change, we can then work with our types in ways that map easily from the Java side of world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kotlin版本中，我们只是把大部分的功能 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`] 转移到了 `companion object` 。除了这个细微的变化，我们还可以从 Java 方面轻松映射的方式来处理我们的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingResource` add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `ReactiveGreetingResource` 中添加以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingService`, add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `ReactiveGreetingService` 中，添加以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.spring.scheduler` package, create the `CounterBean` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `org.acme.spring.scheduler` 包中，使用以下内容创建 `CounterBean` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file, the `native` profile contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `pom.xml` 文件中， `native` 配置文件包含：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `src/main/resource` directory, create a `lorem.txt` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `src/main/resource` 目录中，创建一个包含以下内容的 `lorem.txt` 文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of `dead-letter-queue`, you can configure the following attributes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `dead-letter-queue` 情况下 ，您可以配置以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your
lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在控制台，你会看到lambda的启动信息。这个特定的部署启动了一个JVM，并将你的lambda作为纯Java加载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在控制台，你会看到lambda的启动信息。这个特定的部署启动了一个JVM，并将你的lambda作为纯Java加载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the context of an extension, Quarkus eliminates the need for a JSON configuration file by allowing extension authors to specify a `NativeImageResourceBuildItem`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在扩展的背景下，Quarkus通过允许扩展的作者指定一个 `NativeImageResourceBuildItem` 来消除对JSON配置文件的需求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the default configuration, Keycloak is responsible for managing the roles and deciding who can access which routes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在默认配置中，Keycloak负责管理角色并决定谁可以访问哪些路由。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the example below, this can be easily solved by adapting the annotation, adding @field: Default, to handle the lack of a @Target on the Kotlin reflection annotation definition.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在下面的示例中，通过调整注解，添加@field:Default来处理Kotlin反射注解定义中缺少@Target，就可以很容易地解决这一问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following example we set-up a consumer that always starts on messages from at most 10 minutes ago (or offset 0).
First we need to provide a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` and is annotated with `io.smallrye.common.annotation.Identifier`.
We then must configure our inbound connector to use this bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在下面例子设置的消费者中，它总是会在最多10分钟前(或偏移量0)的消息上启动。首先，我们需要提供一个实现了 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 并被注解为 `io.smallrye.common.annotation.Identifier` 的bean。然后我们必须配置inbound connector来使用这个Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following example we set-up a consumer that always starts on messages from at most 10 minutes ago (or offset 0).  First we need to provide a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` and is annotated with `io.smallrye.common.annotation.Identifier`.  We then must configure our inbound connector to use this bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在下面例子设置的消费者中，它总是会在最多10分钟前(或偏移量0)的消息上启动。首先，我们需要提供一个实现了 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 并被注解为 `io.smallrye.common.annotation.Identifier` 的bean。然后我们必须配置inbound connector来使用这个Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the future, `@NativeImageTest` will be deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing
capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在未来， `@NativeImageTest` 将被弃用，取而代之的是`@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 xref:getting-started-testing.adoc#quarkus-integration-test[测试指南]中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the future, `@NativeImageTest` will be deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the link:getting-started-testing#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在未来， `@NativeImageTest` 将被弃用，取而代之的是`@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 link:getting-started-testing#quarkus-integration-test[测试指南]中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the generated build file, you can see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在生成的构建文件中，你可以看到2个测试依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the next step, we will create configurations for both streams in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下一步，我们将在 `application.properties` 文件中为这两个流创建配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `reflection-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.
If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面的片段中，我们能够简单地使用 `reflection-config.json` ，而不是指定文件的整个路径，只是因为它被添加到了 `src/main/resources` 。如果该文件被添加到了另一个目录，就必须手动指定适当的文件路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `reflection-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.  If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面的片段中，我们能够简单地使用 `reflection-config.json` ，而不是指定文件的整个路径，只是因为它被添加到了 `src/main/resources` 。如果该文件被添加到了另一个目录，就必须手动指定适当的文件路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `resources-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.
If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面的片段中，我们能够简单地使用 `resources-config.json` ，而不是指定文件的整个路径，只是因为它被添加到了 `src/main/resources` 。如果该文件被添加到了另一个目录，就必须手动指定适当的文件路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `resources-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.  If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面的片段中，我们能够简单地使用 `resources-config.json` ，而不是指定文件的整个路径，只是因为它被添加到了 `src/main/resources` 。如果该文件被添加到了另一个目录，就必须手动指定适当的文件路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the same directory, create an `import.sql` file, which inserts a few fruits, so we don't start with an empty database in dev mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在同一个目录中，创建一个 `import.sql` 文件，它插入了一些水果数据，所以我们不会在dev模式中面对一个空数据库开始：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the traditional and imperative approach, frameworks assign a thread to handle the request.
So, the whole processing of the request runs on this worker thread.
This model does not scale very well.
Indeed, to handle multiple concurrent requests, you need multiple threads; and so your application concurrency is constrained by the number of threads.
In addition, these threads are blocked as soon as your code interacts with remote services.
So, it leads to inefficient usage of the resources, as you may need more threads, and each thread, as they are mapped to OS threads, has a cost in terms of memory and CPU.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在传统的指令式方法中，框架分配一个线程来处理请求。因此，请求的整个处理都运行在这个工作线程上。这个模型的扩展性不太好。事实上，要处理多个并发请求，你需要多个线程。因此，应用程序的并发性受到线程数量的限制。此外，只要您的代码与远程服务交互，这些线程就会被阻塞。因此，这会导致资源的低效使用，因为您可能需要更多的线程，而每个线程在映射到OS线程时，在内存和CPU方面都有成本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the traditional and imperative approach, frameworks assign a thread to handle the request.  So, the whole processing of the request runs on this worker thread.  This model does not scale very well.  Indeed, to handle multiple concurrent requests, you need multiple threads; and so your application concurrency is constrained by the number of threads.  In addition, these threads are blocked as soon as your code interacts with remote services.  So, it leads to inefficient usage of the resources, as you may need more threads, and each thread, as they are mapped to OS threads, has a cost in terms of memory and CPU.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在传统的指令式方法中，框架分配一个线程来处理请求。因此，请求的整个处理都运行在这个工作线程上。这个模型的扩展性不太好。事实上，要处理多个并发请求，你需要多个线程。因此，应用程序的并发性受到线程数量的限制。此外，只要您的代码与远程服务交互，这些线程就会被阻塞。因此，这会导致资源的低效使用，因为您可能需要更多的线程，而每个线程在映射到OS线程时，在内存和CPU方面都有成本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the connector looks for the `Map` associated with the `my-configuration` name.
If `kafka-configuration` is not set, an optional lookup for a `Map` exposed with the channel name (`my-channel` in the previous example) is done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，连接器会查询与 `my-configuration` 名称相关的 `Map` 。如果没有设置 `kafka-configuration` ，就会进行额外的查询来寻找与 channel 名称相关的 `Map` (在前面的例子中是 `my-channel` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the connector looks for the `Map` associated with the `my-configuration` name.  If `kafka-configuration` is not set, an optional lookup for a `Map` exposed with the channel name (`my-channel` in the previous example) is done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，连接器会查询与 `my-configuration` 名称相关的 `Map` 。如果没有设置 `kafka-configuration` ，就会进行额外的查询来寻找与 channel 名称相关的 `Map` (在前面的例子中是 `my-channel` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, use the parameter `-Dquarkus.native.remote-container-build=true` instead of `-Dquarkus.native.container-build=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，使用参数 `-Dquarkus.native.remote-container-build=true` ，而不是 `-Dquarkus.native.container-build=true` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, we use `Fruit.findById` to retrieve the fruit.
It returns a `Uni`, which will complete when the database has retrieved the row.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本例中，我们使用 `Fruit.findById` 来检索水果。当数据库检索到该行时，它将返回一个 `Uni`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, we use `Fruit.findById` to retrieve the fruit.  It returns a `Uni`, which will complete when the database has retrieved the row.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本例中，我们使用 `Fruit.findById` 来检索水果。当数据库检索到该行时，它将返回一个 `Uni`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, a singleton CDI bean will produce two different `MeterFilter` beans.
One will be applied only to
Prometheus `MeterRegistry` instances (using the `@MeterFilterConstraint` qualifier), and another will be applied
to all `MeterRegistry` instances.
An application configuration property is also injected and used as a tag value.
Additional examples of MeterFilters can be found in the
link:https://micrometer.io/docs/concepts[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个例子中，一个CDI bean单例将产生两个不同的 `MeterFilter` beans。一个将只用于Prometheus `MeterRegistry` 实例（使用 `@MeterFilterConstraint` 修饰符），另一个将用于所有 `MeterRegistry` 实例。一个应用配置属性也被注入并作为标签值使用。MeterFilters的其他例子可以在 link:https://micrometer.io/docs/concepts[官方文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, a singleton CDI bean will produce two different `MeterFilter` beans. One will be applied only to
Prometheus `MeterRegistry` instances (using the `@MeterFilterConstraint` qualifier), and another will be applied
to all `MeterRegistry` instances. An application configuration property is also injected and used as a tag value.
Additional examples of MeterFilters can be found in the
link:https://micrometer.io/docs/concepts[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个例子中，一个CDI bean单例将产生两个不同的 `MeterFilter` beans。一个将只用于Prometheus `MeterRegistry` 实例（使用 `@MeterFilterConstraint` 修饰符），另一个将用于所有 `MeterRegistry` 实例。一个应用配置属性也被注入并作为标签值使用。MeterFilters的其他例子可以在 link:https://micrometer.io/docs/concepts[官方文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, a singleton CDI bean will produce two different `MeterFilter` beans. One will be applied only to Prometheus `MeterRegistry` instances (using the `@MeterFilterConstraint` qualifier), and another will be applied to all `MeterRegistry` instances. An application configuration property is also injected and used as a tag value.  Additional examples of MeterFilters can be found in the link:https://micrometer.io/docs/concepts[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个例子中，一个CDI bean单例将产生两个不同的 `MeterFilter` beans。一个将只用于Prometheus `MeterRegistry` 实例（使用 `@MeterFilterConstraint` 修饰符），另一个将用于所有 `MeterRegistry` 实例。一个应用配置属性也被注入并作为标签值使用。MeterFilters的其他例子可以在 link:https://micrometer.io/docs/concepts[官方文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we are using a single instance running on localhost:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在此示例中，我们在 localhost 上运行的单个实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers two endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在该例子中，我们建立了一个非常简单的微服务并提供了两个节点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of fruits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个例子中，我们将创建一个应用程序来管理fruit列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this file, copy the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在该文件中，拷贝以下代码:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will implement a service, namely `CostConverter` that consumes HTTP messages with costs in multiple currencies and converts each cost to its value in Euro.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中我们将实现一项服务，名为 `CostConverter` ，它将以多种货币成本的方式消费 HTTP 消息，并将每个成本转换为其以欧元为单位的价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will use the first stage to generate the native executable and the second stage to create our runtime image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将使用第一阶段生成原生可执行文件，第二阶段创建运行时镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to develop two applications communicating with an AMQP broker.
We will use https://activemq.apache.org/components/artemis/[Artemis], but you can use any AMQP 1.0 broker.
The first application sends a _quote request_ to an AMQP queue and consumes messages from the _quote_ queue.
The second application receives the _quote request_ and sends a _quote_ back.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将开发两个与AMQP代理进行通信的应用程序。我们将使用 link:https://activemq.apache.org/components/artemis/[Artemis] ，但你可以使用任何AMQP 1.0代理。第一个应用程序向AMQP队列发送一个 _quote request_ ，并消费 _quote_ queue 中的消息。第二个应用程序接收 _quote request_ ， 并发送一个 _quote_ back。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to develop two applications communicating with an AMQP broker.  We will use https://activemq.apache.org/components/artemis/[Artemis], but you can use any AMQP 1.0 broker.  The first application sends a _quote request_ to an AMQP queue and consumes messages from the _quote_ queue.  The second application receives the _quote request_ and sends a _quote_ back.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将开发两个与AMQP代理进行通信的应用程序。我们将使用 link:https://activemq.apache.org/components/artemis/[Artemis] ，但你可以使用任何AMQP 1.0代理。第一个应用程序向AMQP队列发送一个 _quote request_ ，并消费 _quote_ queue 中的消息。第二个应用程序接收 _quote request_ ， 并发送一个 _quote_ back。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.
Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将开发一个简单的Rest API，其将使用 link:https://redis.io/commands/incrby[`INCRBY`] 命令来递增数字。在此过程中，我们将学会如何使用其他Redis命令，如 `GET` , `SET` , `DEL` 和 `KEYS` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.  Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将开发一个简单的Rest API，其将使用 link:https://redis.io/commands/incrby[`INCRBY`] 命令来递增数字。在此过程中，我们将学会如何使用其他Redis命令，如 `GET` , `SET` , `DEL` 和 `KEYS` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward REST application to demonstrate distributed tracing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们创建了一个简单的REST应用程序来演示分布式跟踪服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate
dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们创建了一个简单的应用程序，为 `hello` 端点提供服务。为了演示依赖性注入，这个端点使用了一个 `greeting` bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们创建了一个简单的应用程序，为 `hello` 端点提供服务。为了演示依赖性注入，这个端点使用了一个 `greeting` bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we expand on the initial test that was created as part of the Getting Started Guide.
We cover injection into tests and also how to test native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们对作为入门指南的一部分而创建的初始测试进行扩展。我们涵盖了注入测试以及如何测试本地可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we expand on the initial test that was created as part of the Getting Started Guide.  We cover injection into tests and also how to test native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们对作为入门指南的一部分而创建的初始测试进行扩展。我们涵盖了注入测试以及如何测试本地可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将了解如何使用REST服务和生成有效的JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use the MongoDB database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们看到如何让你的REST服务使用MongoDB数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native executables to support SSL,
as native executables don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将讨论如何让你的原生可执行文件支持SSL，因为原生可执行文件并不支持开箱即用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native executables to support SSL, as native executables don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将讨论如何让你的原生可执行文件支持SSL，因为原生可执行文件并不支持开箱即用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will explore:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将探讨：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will get you started with some reactive features of Quarkus.
We are going to implement a simple CRUD application.
Yet, unlike in the xref:hibernate-orm-panache.adoc[Hibernate with Panache guide], it uses the reactive features of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将带您开始了解Quarkus的一些响应式功能。 我们将实现一个简单的 CRUD 应用程序。 这部分与 xref:hibernate-orm-panache.adoc[Hibernate与Panache指南]不同，它使用了Quarkus的响应式功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will get you started with some reactive features of Quarkus.  We are going to implement a simple CRUD application.  Yet, unlike in the xref:hibernate-orm-panache.adoc[Hibernate with Panache guide], it uses the reactive features of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将带您开始了解Quarkus的一些响应式功能。 我们将实现一个简单的 CRUD 应用程序。 这部分与 xref:hibernate-orm-panache.adoc[Hibernate与Panache指南]不同，它使用了Quarkus的响应式功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will use Mutiny.
To know more about Mutiny, check the xref:mutiny-primer.adoc[Mutiny documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将使用Mutiny。想要了解更多关于Mutiny的信息，请查看 xref:mutiny-primer.adoc[Mutiny文档]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will use Mutiny.  To know more about Mutiny, check the xref:mutiny-primer.adoc[Mutiny documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将使用Mutiny。想要了解更多关于Mutiny的信息，请查看 xref:mutiny-primer.adoc[Mutiny文档]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this scenario, you do not need to protect your Quarkus endpoint by using the Quarkus OpenID Connect adapter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，您不需要通过使用Quarkus OpenID Connect适配器来保护您的Quarkus节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this test the `mockableBean2` is configured, so it returns the configured response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个测试中， `mockableBean2` 进行了配置，所以它返回配置好的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your HTTP endpoint class, inject the event bus and uses the `request` method to send a message to the event bus and expect a response:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的HTTP端点类中，注入事件总线，并使用 `request` 方法向事件总线发送一个消息，并期待一个响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `Dockerfile`, just use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的 `Dockerfile` 中，只需使用:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `pom.xml`, add the following dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的 `pom.xml` 文件中添加以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your build file you should see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在您的构建文件中应该有2个测试依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your build file, add the following dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的项目构建文件中，添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-Person and online events which feature Quarkus tracks, discussion and topics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以Quarkus为特色的现场和在线活动、讨论和话题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-memory channels</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内存 channels</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inbound Metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入站元数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incoming Attributes of the 'smallrye-kafka' connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>'smallrye-kafka' 连接器的传入属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incoming channel configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传入通道配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incoming channel configuration (polling from Kafka)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入站 channel 配置(从Kafka轮询)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Increment a value given its key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>递增指定键的值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Increment the `first` value by 27.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `first` 的值增加27。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that the `topic` property is a regular expression. Must be used with the `topic` property. Cannot be used with the `topics` property

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>表示 `topic` 属性是一个正则表达式。必须与 `topic` 属性一起使用。不能与 `topics` 属性一起使用

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that this injection point is meant to use an instance of `RestClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里表示这个注入点使用了 `RestClient` 的实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the content is sent using `Server Sent Events`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>表示内容是使用 `Server Sent Events` 发送的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the method consumes the items from the `requests` channel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>表示该方法消费 `requests` 通道中的项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the objects returned by the method are sent to the `quotes` channel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>表示方法返回的对象被发送给 `quotes` 通道</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the processing is _blocking_ and cannot be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>表示该处理是 _blocking_ ，不能在调用者线程上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an in memory data grid that allows running in a server outside of application processes. This extension provides functionality to allow the client that can connect to said server when running in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan是一个内存中的数据网格，允许在应用程序进程之外的服务器中运行。这个扩展提供了功能，允许在Quarkus中运行时可以连接到所述服务器的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为命名的数据源注入Flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources using the Quarkus `FlywayDataSource` qualifier</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus `FlywayDataSource` 限定符为指定的数据源注入Flyway。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject JWT as MP JSON Web Token (JWT)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将JWT注入为MP Json Web Token（JWT）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject a Reactive Messaging `Emitter` to send messages to the `quote-requests` channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入一个响应式消息 `Emitter` ，来向 `quote-requests` 通道发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject a `MutinyEmitter` which exposes a Mutiny API. It simplifies the integration with the Mutiny API exposed by Hibernate Reactive with Panache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入一个暴露了Mutiny API的 `MutinyEmitter` 。它简化了与Hibernate Reactive with Panache所暴露的Mutiny API的整合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject an `Emitter&lt;String&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入一个 `Emitter&lt;String&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Flyway object if you want to use it directly</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想直接使用Flyway对象，请注入该对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Reactive Redis client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入Redis响应式客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Redis synchronous client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入Redis同步客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CounterBean`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入 `CounterBean` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `TransactionManager` to be able to activate `setRollbackOnly` semantic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入 `TransactionManager` ，能够激活 `setRollbackOnly` 语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the in-memory connector in your test class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在您的测试类中注入内存内连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injectable AWS Context Variables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可注入的AWS上下文变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting `@Channel("prices")` or having `@Incoming("prices")` does not automatically configure the application to consume messages from Kafka.
You need to configure an inbound connector with `mp.messaging.incoming.prices\...` or have an `@Outgoing("prices")` method somewhere in your application (in which case, `prices` will be an in-memory channel).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入 `@Channel("prices")` 或使用 `@Incoming("prices")` 无法通过配置使应用程序自动从Kafka消费消息。您需要用 `mp.messaging.incoming.prices...` 配置一个接收connector，或者在您的应用程序中使用 `@Outgoing("prices")` 方法(在这种情况下， `prices` 将是一个内存型channel)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting `@Channel("prices")` or having `@Incoming("prices")` does not automatically configure the application to consume messages from Kafka.  You need to configure an inbound connector with `mp.messaging.incoming.prices\...` or have an `@Outgoing("prices")` method somewhere in your application (in which case, `prices` will be an in-memory channel).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入 `@Channel("prices")` 或使用 `@Incoming("prices")` 无法通过配置使应用程序自动从Kafka消费消息。您需要用 `mp.messaging.incoming.prices...` 配置一个接收connector，或者在您的应用程序中使用 `@Outgoing("prices")` 方法(在这种情况下， `prices` 将是一个内存型channel)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting a URI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入beans</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting the Authorization Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入授权客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection Discovery/Navigation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入发现/导航跳转</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection into tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection is also supported into objects that implement `io.quarkus.test.common.DevServicesContext.ContextAware`. If you
have a field that implements `io.quarkus.test.common.DevServicesContext.ContextAware` Quarkus will call the
`setIntegrationTestContext` method to pass the context into this object. This allows client logic to be encapsulated in
a utility class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该注入也支持在实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的对象中。如果您有一个实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的字段，Quarkus将调用 `setIntegrationTestContext` 方法来将上下文传入这个对象中。这将允许客户端逻辑被允许封装在一个实用类中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection is also supported into objects that implement `io.quarkus.test.common.DevServicesContext.ContextAware`. If you have a field that implements `io.quarkus.test.common.DevServicesContext.ContextAware` Quarkus will call the `setIntegrationTestContext` method to pass the context into this object. This allows client logic to be encapsulated in a utility class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该注入也支持在实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的对象中。如果您有一个实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的字段，Quarkus将调用 `setIntegrationTestContext` 方法来将上下文传入这个对象中。这将允许客户端逻辑被允许封装在一个实用类中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of `JsonWebToken` is supported in `@ApplicationScoped`, `@Singleton` and `@RequestScoped` scopes however the use of `@RequestScoped` is required if the individual claims are injected as simple types, please see xref:security-jwt.adoc#supported-injection-scopes[Support Injection Scopes for JsonWebToken and Claims] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@ApplicationScoped` , `@Singleton` 和 `@RequestScoped` 范围上下文中支持注入 `JsonWebToken` ，但是如果单个声明被注入为简单类型，则需要使用 `@RequestScoped` ，更多细节请参见 link:security-jwt.html#supported-injection-scopes[JsonWebToken和声明所支持注入范围(Injection Scopes)] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of resources into tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将资源注入测试中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of the `SecurityIdentity` is supported in both `@RequestScoped` and `@ApplicationScoped` contexts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@RequestScoped` 和 `@ApplicationScoped` 的上下文中都支持 `SecurityIdentity` 注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injects the `quotes` channel using the `@Channel` qualifier</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@Channel` 修饰符注入 `quotes` 通道</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inner-signed and encrypted or encrypted tokens</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Inner-Signed/Encrypted 或 Encrypted tokens</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside a consumer group, as new group members arrive and old members leave, the partitions are re-assigned so that each member receives a proportional share of the partitions.
This is known as rebalancing the group.
To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.
To achieve this, implement the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` interface and expose it as a CDI bean with the `@Idenfier` qualifier.
A common use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个消费者组内，随着新老组员的交替，分区将会被重新分配，从而使每个组员都能分配到分区。这就是组的再平衡。为了处理偏移提交以及分区的分配，您可以提供一个消费者再平衡监听器。为了实现这一点，请实现 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 接口，并将其暴露为CDI bean并使用 `@Idenfier` 修饰符修饰。一个常见的用例是将偏移量存储在一个单独的数据存储中以使其保证语义上的精准一次(exactly-once semantic)，或者在某一个特定的偏移量开始时处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside a consumer group, as new group members arrive and old members leave, the partitions are re-assigned so that each member receives a proportional share of the partitions.  This is known as rebalancing the group.  To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.  To achieve this, implement the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` interface and expose it as a CDI bean with the `@Idenfier` qualifier.  A common use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个消费者组内，随着新老组员的交替，分区将会被重新分配，从而使每个组员都能分配到分区。这就是组的再平衡。为了处理偏移提交以及分区的分配，您可以提供一个消费者再平衡监听器。为了实现这一点，请实现 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 接口，并将其暴露为CDI bean并使用 `@Idenfier` 修饰符修饰。一个常见的用例是将偏移量存储在一个单独的数据存储中以使其保证语义上的精准一次(exactly-once semantic)，或者在某一个特定的偏移量开始时处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside application configuration, channel names are unique.
Therefore, if you'd like to configure an incoming and outgoing channel on the same topic, you will need to name channels differently (like in the examples of this guide, `mp.messaging.incoming.prices` and `mp.messaging.outgoing.prices-out`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在应用配置里面，channel名称是唯一的。因此，如果您打算在相同topic上同时配置一个接收和一个发送的channel，您需要对这两个 channels 使用不同的名称(比如本指南的例子，`mp.messaging.incoming.prices` 和 `mp.messaging.outgoing.prices-out` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside application configuration, channel names are unique.  Therefore, if you'd like to configure an incoming and outgoing channel on the same topic, you will need to name channels differently (like in the examples of this guide, `mp.messaging.incoming.prices` and `mp.messaging.outgoing.prices-out`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在应用配置里面，channel名称是唯一的。因此，如果您打算在相同topic上同时配置一个接收和一个发送的channel，您需要对这两个 channels 使用不同的名称(比如本指南的例子，`mp.messaging.incoming.prices` 和 `mp.messaging.outgoing.prices-out` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside the `producer` project locate the generated  `src/main/java/org/acme/amqp/producer/QuotesResource.java` file, and update the content to be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `producer` 项目中找到生成的 `src/main/java/org/acme/amqp/producer/QuotesResource.java` 文件，并将其内容更新为：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside the `producer` project locate the generated `src/main/java/org/acme/amqp/producer/QuotesResource.java` file, and update the content to be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `producer` 项目中找到生成的 `src/main/java/org/acme/amqp/producer/QuotesResource.java` 文件，并将其内容更新为：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM (pick the java 11 version) if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果还没有安装GraalVM（选择java 11版本），您有几个选择：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你还没有安装 GraalVM。那么你有几个选择：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install [bundler](https://jekyllrb.com/docs/ruby-101/#bundler)  [gems](https://jekyllrb.com/docs/ruby-101/#gems)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装 [bundler](https://jekyllrb.com/docs/ruby-101/#bundler)  [gems](https://jekyllrb.com/docs/ruby-101/#gems)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install a full [Ruby development environment](https://jekyllrb.com/docs/installation/). If you use `rvm`, run: `rvm use 2.7.1`.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装完整的 [Ruby开发环境](https://jekyllrb.com/docs/installation/)。如果你使用 `rvm`, 运行: `rvm use 2.7.1`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Java 11 version of GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装Java 11版本的GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the [act](https://github.com/nektos/act#installation) executable to run GitHub Actions locally
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装 [act](https://github.com/nektos/act#installation) 可执行文件本地运行GitHub Actions
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `gu install` 安装 `native-image` 工具：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install via Command Line Interface</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过命令行界面安装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing AWS bits</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装AWS位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps
for installing AWS CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装所有AWS位可能是本指南中最困难的事情。请确保你遵循安装AWS CLI的所有步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps
for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装所有的AWS位可能是本指南中最困难的事情。请确保你遵循安装AWS SAM CLI的所有步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装所有AWS位可能是本指南中最困难的事情。请确保你遵循安装AWS CLI的所有步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装所有的AWS位可能是本指南中最困难的事情。请确保你遵循安装AWS SAM CLI的所有步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing via scoop will do this for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过scoop安装将为你做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instance profile credentials delivered through the Amazon EC2 metadata service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 Amazon EC2 元数据服务交付的实例配置文件凭证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们没有覆盖这个值，而只是想确保我们的 `GreetingService` 上的greet方法被这个测试所调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.kafka.Record` to send key/value pairs:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了发送键/值对， 您可以直接返回一个 `io.smallrye.reactive.messaging.kafka.Record` 来代理一个payload：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Panache to run the given (asynchronous) action in a transaction. The transaction completes when the action completes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指令使Panache在一个事务中运行给定的(异步)操作。当该操作完成时，事务会结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instructs the prices channel to be managed by the AMQP connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指示将由AMQP连接器管理的价格通道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integrating with Kafka - Common patterns</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Kafka的整合--通用模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IntelliJ IDEA JUnit template</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IntelliJ IDEA JUnit模板</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IntelliJ IDEA plugin that works in IntelliJ IDEA Community and Ultimate. Available from Marketplace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IntelliJ IDEA插件，可用于IntelliJ IDEA Community/Ultimate。在插件市场安装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与其他响应式API交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与应用程序进行交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction to CDI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI简介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction to writing REST JSON Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST JSON服务的介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introspection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoke the Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>调用Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>缺陷</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues using GraalVM with macOS Catalina</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在MacOS Catalina上使用GraalVM的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues with packaging on Windows</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上打包的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It allows more advanced reactive use cases, for example, you can use it to send server-sent events (SSE) via RESTEasy Reactive:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它允许更高级的响应式用例，例如，你可以用它来通过RESTEasy Reactive发送服务器发送的事件（SSE）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also enables producer idempotence support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这同样会启用生产者幂等性支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It attempts to identify archives with Panache entities (and consumers of Panache entities)
by the presence of the marker file `META-INF/panache-archive.marker`. Panache includes an
annotation processor that will automatically create this file in archives that depend on
Panache (even indirectly). If you have disabled annotation processors you may need to create
this file manually in some cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache通过判断是否存在标记文件 `META-INF/panache-archive.marker` 来识别jar包是否包含 Panache 实体类（及 Panache 实体类的调用方）。Panache 包含一个注解处理器，它会自动在依赖 Panache（包括间接依赖Panache）的jar包中创建此文件。如果在某些情况下你禁用了注解处理器，可能需要手动创建此文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It attempts to identify archives with Panache entities (and consumers of Panache entities)  by the presence of the marker file `META-INF/panache-archive.marker`. Panache includes an annotation processor that will automatically create this file in archives that depend on Panache (even indirectly). If you have disabled annotation processors you may need to create this file manually in some cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache通过判断是否存在标记文件 `META-INF/panache-archive.marker` 来识别jar包是否包含 Panache 实体类（及 Panache 实体类的调用方）。Panache 包含一个注解处理器，它会自动在依赖 Panache（包括间接依赖Panache）的jar包中创建此文件。如果在某些情况下你禁用了注解处理器，可能需要手动创建此文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It attempts to identity archives with Panache entities (and consumers of Panache entities)
by the presence of the marker file `META-INF/panache-archive.marker`. Panache includes an
annotation processor that will automatically create this file in archives that depend on
Panache (even indirectly). If you have disabled annotation processors you may need to create
this file manually in some cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它试图通过标记文件 `META-INFpanache-archive.marker` 的存在来识别具有 Panache 实体（和 Panache 实体的消费者）的档案。 Panache 包含一个注释处理器，它将自动在依赖于 Panache（甚至间接）的档案中创建此文件。如果您禁用了注释处理器，在某些情况下您可能需要手动创建此文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It attempts to identity archives with Panache entities (and consumers of Panache entities)  by the presence of the marker file `META-INF/panache-archive.marker`. Panache includes an annotation processor that will automatically create this file in archives that depend on Panache (even indirectly). If you have disabled annotation processors you may need to create this file manually in some cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它试图通过标记文件 `META-INFpanache-archive.marker` 的存在来识别具有 Panache 实体（和 Panache 实体的消费者）的档案。 Panache 包含一个注释处理器，它将自动在依赖于 Panache（甚至间接）的档案中创建此文件。如果您禁用了注释处理器，在某些情况下您可能需要手动创建此文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be activated and configured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它可以按以下方式激活和配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be useful to test the application without having to start a Kafka broker.
To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在不启动Kafka broker的情况下测试应用程序会很有用。为了实现这一点，您可以把Kafka连接器管理的 channels  _切换_ 到_内存 _中 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在不启动Kafka broker的情况下测试应用程序会很有用。为了实现这一点，您可以把Kafka连接器管理的 channels  _切换_ 到_内存 _中 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It explains why the endpoint has no `@RolesAllowed` annotations - the resource access permissions are set directly in Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这解释了为什么节点没有 `@RolesAllowed` 注解--资源访问权限是直接在Keycloak中设置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates a greeting message every second and stops after `count` messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它每秒钟生成一条问候信息，并在 `count` 信息后停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in  `./getting-started`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它在 `./getting-started` 中产生了以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started-reactive`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它会在 `./getting-started-reactive`中生成如下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它在 `./getting-started` 中产生了以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It instructs the application to use PostgreSQL for the database and to handle the database schema generation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它指示应用程序对数据库使用PostgreSQL，并处理数据库模式的生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to block on sending the event to the emitter with the `sendAndAwait` method.
It will only return from the method when the event is acked or nacked by the receiver.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以通过 `sendAndAwait` 方法在发送事件到emitter的时候进行阻塞。只有当事件被接收者确认或拒绝时，它才会从该方法中返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to block on sending the event to the emitter with the `sendAndAwait` method.  It will only return from the method when the event is acked or nacked by the receiver.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以通过 `sendAndAwait` 方法在发送事件到emitter的时候进行阻塞。只有当事件被接收者确认或拒绝时，它才会从该方法中返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to define role based policies, as shown in the example. These policies will only allow users with the
specified roles to access the resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以定义基于角色的策略，如例子所示。这些策略将只允许具有指定角色的用户访问资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to define role based policies, as shown in the example. These policies will only allow users with the specified roles to access the resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以定义基于角色的策略，如例子所示。这些策略将只允许具有指定角色的用户访问资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is
done via the `@TestHTTPResource` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以直接将URL注入测试中，从而可以更容易的使用不同的客户端。可通过 `@TestHTTPResource` 注解完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is done via the `@TestHTTPResource` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以直接将URL注入测试中，从而可以更容易的使用不同的客户端。可通过 `@TestHTTPResource` 注解完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to generate a public and private key pair using the OpenSSL command line tool.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以使用OpenSSL命令行工具生成一个公钥和私钥对。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run
`./mvnw test-compile failsafe:integration-test -Pnative`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以针对已经构建的原生可执行文件重新运行测试。要做到这一点，运行 `./mvnw test-compile failsafe:integration-test` 。这将查找现有的原生可执行文件，并使用failsafe插件对其运行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run
`./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using
failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以针对已经建立的原生可执行文件重新运行测试。要做到这一点，运行 `./mvnw test-compile failsafe:integration-test` 。这将发现现有的原生镜像，并使用故障安全系统对其运行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test -Pnative`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以针对已经构建的原生可执行文件重新运行测试。要做到这一点，运行 `./mvnw test-compile failsafe:integration-test` 。这将查找现有的原生可执行文件，并使用failsafe插件对其运行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以针对已经建立的原生可执行文件重新运行测试。要做到这一点，运行 `./mvnw test-compile failsafe:integration-test` 。这将发现现有的原生镜像，并使用故障安全系统对其运行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to test native executables using `@QuarkusIntegrationTest`. This supports all the features mentioned in this
guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以使用 `@QuarkusIntegrationTest` 来测试本地可执行文件。除了注入测试（本地可执行文件在一个单独的非JVM进程中运行，所以它实际上是不可能做到的）以外，该特性支持本指南中提到的所有功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to test native executables using `@QuarkusIntegrationTest`. This supports all the features mentioned in this guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以使用 `@QuarkusIntegrationTest` 来测试本地可执行文件。除了注入测试（本地可执行文件在一个单独的非JVM进程中运行，所以它实际上是不可能做到的）以外，该特性支持本指南中提到的所有功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is built on top of the xref:mongodb.adoc[MongoDB Client] extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它是建立在 link:mongodb.html[MongoDB客户端] 扩展之上的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise
it will take effect all the time, not just when testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，alternative要放置于 `src/test/java` 目录中而不是 `src/main/java` ，否则它将不仅仅只是在测试时生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise it will take effect all the time, not just when testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，alternative要放置于 `src/test/java` 目录中而不是 `src/main/java` ，否则它将不仅仅只是在测试时生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to note that gauges are sampled rather than set; there is no record of how the value associated with a
gauge might have changed between measurements. In this example, the size of the list is observed when the Prometheus
endpoint is visited.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注意的是，gauges是采样的，而不是设置的；因而与一个gauge相关的值在不同的测量之间可能会发生怎样的变化将无从记录。在本例中，列表的大小会在访问Prometheus节点时被观察到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to note that gauges are sampled rather than set; there is no record of how the value associated with a gauge might have changed between measurements. In this example, the size of the list is observed when the Prometheus endpoint is visited.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注意的是，gauges是采样的，而不是设置的；因而与一个gauge相关的值在不同的测量之间可能会发生怎样的变化将无从记录。在本例中，列表的大小会在访问Prometheus节点时被观察到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible for Quarkus to determine at build time the type included in the `Response` as the information is not available.
In this case, Quarkus won't be able to automatically register for reflection the required classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus不可能在构建时确定 `Response` 中包含的类型，因为该信息不可用。在这种情况下，Quarkus将无法自动注册反映所需的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible for Quarkus to determine at build time the type included in the `Response` as the information is not available.  In this case, Quarkus won't be able to automatically register for reflection the required classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus不可能在构建时确定 `Response` 中包含的类型，因为该信息不可用。在这种情况下，Quarkus将无法自动注册反映所需的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to add a tag that would convey a little more information, however. Let's adjust our code, and move
the counter to add some tags to convey additional information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不过添加一个标签以传达更多的信息也是有可能的。让我们调整我们的代码，改动一下counter来添加一些标签以传达更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to add a tag that would convey a little more information, however. Let's adjust our code, and move the counter to add some tags to convey additional information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不过添加一个标签以传达更多的信息也是有可能的。让我们调整我们的代码，改动一下counter来添加一些标签以传达更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to configure multiple policy enforcer configurations, one per each tenant, similarly to how it can be done for xref:security-openid-connect-multitenancy.adoc[Multi-Tenant OpenID Connect Service Applications].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以配置多个策略执行者的配置，每个租户一个，类似于 link:security-openid-connect-multitenancy.html[多租户OpenID连接服务应用程序] 的配置方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to read annotations from the test class or method to control what the callback shall be doing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以从测试类或方法中读取注解，从而控制回调应做什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to write test resources that are enabled and configured using annotations. This is enabled by placing the `@QuarkusTestResource`
on an annotation which will be used to enable and configure the test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们也可以编写使用注解来启用和配置的测试资源。这可以通过在一个注解上使用 `@QuarkusTestResource` 来启用，该注解将被用来启用和配置测试资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to write test resources that are enabled and configured using annotations. This is enabled by placing the `@QuarkusTestResource` on an annotation which will be used to enable and configure the test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们也可以编写使用注解来启用和配置的测试资源。这可以通过在一个注解上使用 `@QuarkusTestResource` 来启用，该注解将被用来启用和配置测试资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended to use exactly-once processing along with the batch consumption mode.
While it is possible to use it with a single Kafka message, it'll have a significant performance impact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建议在消费端批处理模式中采用exactly-once。 虽然可以将它与单个 Kafka 消息一起使用，但这样会对性能产生重大影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended to use exactly-once processing along with the batch consumption mode.  While it is possible to use it with a single Kafka message, it'll have a significant performance impact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建议在消费端批处理模式中采用exactly-once。 虽然可以将它与单个 Kafka 消息一起使用，但这样会对性能产生重大影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is worth mentioning that this injection into the test class is not under the control of CDI and happens after CDI has performed
any necessary injections into the test class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>值得一提的是，这种对测试类的注入并不在CDI的控制之下，而是发生在CDI对测试类进行了所有必要的注入之后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is worth mentioning that this injection into the test class is not under the control of CDI and happens after CDI has performed any necessary injections into the test class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>值得一提的是，这种对测试类的注入并不在CDI的控制之下，而是发生在CDI对测试类进行了所有必要的注入之后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might be tempting to add a label or tag to the counter indicating what value was checked, but remember that each
unique combination of metric name (`example.prime.number`) and label value produces a unique time series. Using an
unbounded set of data as label values can lead to a "cardinality explosion", an exponential increase in the creation
of new time series.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上代码打算给counter添加一个标签来表明是什么值被检查了，但是请记住，metric名称( `example.prime.number` )和标签值的每个独特组合只会产生一个唯一的时间序列。使用未绑定的数据集来作为标签值会导致 "基数爆炸(cardinality explosion)"，即新的时间序列的创建会呈指数级增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might be tempting to add a label or tag to the counter indicating what value was checked, but remember that each unique combination of metric name (`example.prime.number`) and label value produces a unique time series. Using an unbounded set of data as label values can lead to a "cardinality explosion", an exponential increase in the creation of new time series.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上代码打算给counter添加一个标签来表明是什么值被检查了，但是请记住，metric名称( `example.prime.number` )和标签值的每个独特组合只会产生一个唯一的时间序列。使用未绑定的数据集来作为标签值会导致 "基数爆炸(cardinality explosion)"，即新的时间序列的创建会呈指数级增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It produces several outputs in `/target`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它在 `/target` ，产生几个输出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它提供了Vert.x Web客户端的Mutiny API。然后，您可以使用如下web客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should be added to the `native-image` configuration using the `quarkus.native.additional-build-args` configuration property as shown in the examples above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它应该使用 `quarkus.native.additional-build-args` 配置属性添加到 `native-image` 配置中，如上面的例子所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should retrieve the book content.
In the output you should see the separator like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它应该获取到书籍的内容。在输出中，你应该会看到像这样包含分隔符的内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should retrieve the book content.  In the output you should see the separator like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它应该获取到书籍的内容。在输出中，你应该会看到像这样包含分隔符的内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It uses Jackson underneath.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它的底层使用了Jackson。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a mess because I don't know if my JPA persistence unit is using `JTA` or `Resource-level` Transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当不知道JPA persistence unit 使用的是“JTA”还是“Resource-level”事务，这可能会造成混乱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello RESTEasy Reactive" to requests on "/hello".  As it uses RESTEAsy Reactive, this method is called on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常简单的REST端点，在 "/hello"上返回 "Hello RESTEasy Reactive" 请求。当它使用RESTEAsy响应式时，这个方法在I/O线程上被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello from RESTEasy Reactive" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常简单的REST端点，对"/hello "上的请求返回 "Hello from RESTEasy Reactive"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's an introductory guide.
The xref:vertx-reference.adoc[Vert.x reference guide] covers more advanced features such as verticles, and native transports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一项介绍性的指南。 link:vertx-reference.html[Vert.x参考指南] 涵盖了更多的高级功能，例如 verticles 和 本地传输 (native transports) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's an introductory guide.  The xref:vertx-reference.adoc[Vert.x reference guide] covers more advanced features such as verticles, and native transports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一项介绍性的指南。 link:vertx-reference.html[Vert.x参考指南] 涵盖了更多的高级功能，例如 verticles 和 本地传输 (native transports) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not a mess in Quarkus :)
Resource-level was introduced to support JPA in a non managed environment.
But Quarkus is both lean and a managed environment so we can safely always assume we are in JTA mode.
The end result is that the difficulties of running Hibernate ORM + CDI + a transaction manager in Java SE mode are solved by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 Quarkus 中不会引起混乱 :) 引入资源级是为了在非托管环境中支持 JPA。 但是 Quarkus 既是精益环境又是托管环境，因此我们始终可以安全地假设我们处于 JTA 模式。 最终的结果是，Quarkus 解决了在 Java SE 模式下运行 Hibernate ORM + CDI + 事务管理器的困难。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not a mess in Quarkus :)  Resource-level was introduced to support JPA in a non managed environment.  But Quarkus is both lean and a managed environment so we can safely always assume we are in JTA mode.  The end result is that the difficulties of running Hibernate ORM + CDI + a transaction manager in Java SE mode are solved by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 Quarkus 中不会引起混乱 :) 引入资源级是为了在非托管环境中支持 JPA。 但是 Quarkus 既是精益环境又是托管环境，因此我们始终可以安全地假设我们处于 JTA 模式。 最终的结果是，Quarkus 解决了在 Java SE 模式下运行 Hibernate ORM + CDI + 事务管理器的困难。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It’s a snap to be up and running with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>和Quarkus一起工作很容易。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11 installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDK 11安装时适当配置了 `JAVA_HOME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装JDK 11以上版本并正确配置了 `JAVA_HOME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDK 8 或 11+安装并适当配置了 `JAVA_HOME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JPA batches changes you make to your entities and sends changes (it's called flush) at the end of the transaction or before a query.
This is usually a good thing as it's more efficient.
But if you want to check optimistic locking failures, do object validation right away or generally want to get immediate feedback, you can force the flush operation by calling `entity.flush()` or even use `entity.persistAndFlush()` to make it a single method call. This will allow you to catch any `PersistenceException` that could occur when JPA send those changes to the database.
Remember, this is less efficient so don't abuse it.
And your transaction still has to be committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JPA将实体的变更进行批量处理，并在事务结束时或查询前发送批量变更（这被称为flush）。这通常更有效率。但是当你想检查乐观锁的失败，即时进行对象验证，或者想得到即时的反馈，你可以通过调用 `entity.flush()` 或 `entity.persistAndFlush()` 强制执行flush。JPA向数据库发送这些变更时可能会抛出 `PersistenceException` ，你可以捕捉这些异常。记住，这样做的效率较低，所以不要滥用它。而且你的事务仍然需要提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JPA batches changes you make to your entities and sends changes (it's called flush) at the end of the transaction or before a query.  This is usually a good thing as it's more efficient.  But if you want to check optimistic locking failures, do object validation right away or generally want to get immediate feedback, you can force the flush operation by calling `entity.flush()` or even use `entity.persistAndFlush()` to make it a single method call. This will allow you to catch any `PersistenceException` that could occur when JPA send those changes to the database.  Remember, this is less efficient so don't abuse it.  And your transaction still has to be committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JPA将实体的变更进行批量处理，并在事务结束时或查询前发送批量变更（这被称为flush）。这通常更有效率。但是当你想检查乐观锁的失败，即时进行对象验证，或者想得到即时的反馈，你可以通过调用 `entity.flush()` 或 `entity.persistAndFlush()` 强制执行flush。JPA向数据库发送这些变更时可能会抛出 `PersistenceException` ，你可以捕捉这些异常。记住，这样做的效率较低，所以不要滥用它。而且你的事务仍然需要提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Object and JSON Array are both supported as Quarkus HTTP endpoint requests and response bodies (using classic RESTEasy and RESTEasy Reactive).
Consider these endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON Object和JSON Array都支持作为Quarkus HTTP端点的请求和响应体（使用经典的RESTEasy和RESTEasy Reactive）。考虑一下这些端点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Object and JSON Array are both supported as Quarkus HTTP endpoint requests and response bodies (using classic RESTEasy and RESTEasy Reactive).  Consider these endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON Object和JSON Array都支持作为Quarkus HTTP端点的请求和响应体（使用经典的RESTEasy和RESTEasy Reactive）。考虑一下这些端点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Serializer/deserializer generation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON序列化器/反序列化器的生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Web Key (JWK)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON网络密钥（JWK）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Web Key (JWK) Base64 URL encoded</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON Web Key (JWK) Base64 URL 编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Web Key Set (JWKS)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON网络密钥集(JWKS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Web Key Set (JWKS) Base64 URL encoded</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON网络密钥集（JWKS）Base64 URL编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Web Token Claim Verification</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON网络令牌声明验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the _lingua franca_ between microservices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON现在是微服务之间的 _通用_ 语言。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON现在是微服务之间的通用语言。在本指南中，我们看看如何让你的REST服务消费和提供JSON有效载荷。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON representation of `Quote` objects will be used in messages sent to the AMQP queues
and also in the server-sent events sent to browser clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Quote` 对象的JSON表示将被用在发送给AMQP队列的消息中，也被用在发送给浏览器客户端的服务器发送事件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON representation of `Quote` objects will be used in messages sent to the AMQP queues and also in the server-sent events sent to browser clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Quote` 对象的JSON表示将被用在发送给AMQP队列的消息中，也被用在发送给浏览器客户端的服务器发送事件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON serialization libraries use Java reflection to get the properties of an object and serialize them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON序列化库使用Java反射来获取一个对象的属性并将其序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JVM container image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVM容器镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JWK cache refresh interval in minutes. It will be ignored unless the `mp.jwt.verify.publickey.location` points to the HTTP or HTTPS URL based JWK set and no HTTP `Cache-Control` response header with a positive `max-age` parameter value is returned from a JWK HTTPS endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JWK缓存刷新时间间隔，单位是分钟。它将被忽略，除非 `mp.jwt.verify.publickey.location` 指向基于HTTP或HTTPS URL的JWK设置，并且没有从JWK HTTPS端点返回具有正 `max-age` 参数值的HTTP `Cache-Control` 响应header。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jan 01, 2016</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2016年1月1日</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jan 01, 2021</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年1月1日</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java 11+ installed with `JAVA_HOME` configured appropriately.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 11+安装并适当配置了 `JAVA_HOME` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java System Properties - `aws.accessKeyId` and `aws.secretAccessKey`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 系统属性 - `aws.accessKeyId` 和 `aws.secretAccessKey` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.
To produce a native executable, this means that the `--enable-preview` flag needs to be passed to the underlying native image invocation.
You can do so by prepending the flag with `-J` and passing it as additional native build argument: `-Dquarkus.native.additional-build-args=-J--enable-preview`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依赖于预览功能的Java代码需要特别注意。为了产生一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给底层的原生镜像调用。你可以这样做，用 `-J` 作为标志的前缀，并将其作为额外的原生构建参数传递：`-Dquarkus.native.additional-build-args=-J--enable-preview`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.
To test a native executable, this means that the `--enable-preview` flag needs to be passed to the Surefire plugin.
Adding `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` to its `configuration` section is one way to do so.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依赖于预览功能的Java代码需要特别注意。为了测试一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给Surefire插件。将 `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` 添加到其 `configuration` 片段是一种可行方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.  To produce a native executable, this means that the `--enable-preview` flag needs to be passed to the underlying native image invocation.  You can do so by prepending the flag with `-J` and passing it as additional native build argument: `-Dquarkus.native.additional-build-args=-J--enable-preview`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依赖于预览功能的Java代码需要特别注意。为了产生一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给底层的原生镜像调用。你可以这样做，用 `-J` 作为标志的前缀，并将其作为额外的原生构建参数传递：`-Dquarkus.native.additional-build-args=-J--enable-preview`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.  To test a native executable, this means that the `--enable-preview` flag needs to be passed to the Surefire plugin.  Adding `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` to its `configuration` section is one way to do so.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依赖于预览功能的Java代码需要特别注意。为了测试一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给Surefire插件。将 `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` 添加到其 `configuration` 片段是一种可行方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java preview features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java预览功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Join the Quarkus Community</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>加入Quarkus社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Json path of Principal Name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>主体名的Json路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Broker Readiness Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Broker就绪检查(Readiness Check)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Configuration Resolution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka配置方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Reactive Messaging Health Checks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka响应式消息传递健康检查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka事务处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Transactions allows managing consumer offsets inside a transaction, together with produced messages.
This enables coupling a consumer with a transactional producer in a _consume-transform-produce_ pattern, also known as *exactly-once processing*.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务可以同时管理其中的消费端和生产端的消息偏移量。 这使得消费端能够以 _consume-transform-produce_ 模式与生产端耦合，也称为 *exactly-once 精确一次性处理*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Transactions allows managing consumer offsets inside a transaction, together with produced messages.  This enables coupling a consumer with a transactional producer in a _consume-transform-produce_ pattern, also known as *exactly-once processing*.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务可以同时管理其中的消费端和生产端的消息偏移量。 这使得消费端能够以 _consume-transform-produce_ 模式与生产端耦合，也称为 *exactly-once 精确一次性处理*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka transactional producers require configuring `acks=all` client property, and a unique id for `transactional.id`, which implies `enable.idempotence=true`.
When Quarkus detects the use of `KafkaTransactions` for an outgoing channel it configures these properties on the channel,
providing a default value of `"${quarkus.application.name}-${channelName}"` for `transactional.id` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务生产者需要配置 `acks=all` 客户端属性，以及 `transactional.id` 的唯一 id，这意味着 `enable.idempotence=true` 。 当 Quarkus 检测到传出通道使用 `KafkaTransactions` 时，它会在通道上配置这些属性，为 `transactional.id` 属性提供默认值 `"${quarkus.application.name}-${channelName}"` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka transactional producers require configuring `acks=all` client property, and a unique id for `transactional.id`, which implies `enable.idempotence=true`.  When Quarkus detects the use of `KafkaTransactions` for an outgoing channel it configures these properties on the channel, providing a default value of `"${quarkus.application.name}-${channelName}"` for `transactional.id` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务生产者需要配置 `acks=all` 客户端属性，以及 `transactional.id` 的唯一 id，这意味着 `enable.idempotence=true` 。 当 Quarkus 检测到传出通道使用 `KafkaTransactions` 时，它会在通道上配置这些属性，为 `transactional.id` 属性提供默认值 `"${quarkus.application.name}-${channelName}"` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka transactions enable atomic writes to multiple Kafka topics and partitions.
The Kafka connector provides `KafkaTransactions` custom emitter for writing Kafka records inside a transaction.
It can be injected as a regular emitter `@Channel`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务支持对多个 Kafka 主题和分区进行原子写入。 Kafka 连接器提供了 `KafkaTransactions` 自定义emitter，用于在事务中写入 Kafka 记录。 它可以作为常规emitter `@Channel` 注入：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka transactions enable atomic writes to multiple Kafka topics and partitions.  The Kafka connector provides `KafkaTransactions` custom emitter for writing Kafka records inside a transaction.  It can be injected as a regular emitter `@Channel`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务支持对多个 Kafka 主题和分区进行原子写入。 Kafka 连接器提供了 `KafkaTransactions` 自定义emitter，用于在事务中写入 Kafka 记录。 它可以作为常规emitter `@Channel` 注入：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep confidential your database credentials by storing them in Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将你的数据库凭证存储在Vault中，对其进行保密。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Key identifier. If it is set then the verification JWK key as well every JWT token must have a matching `kid` header.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>密钥标识符。如果它被设置，那么验证JWK密钥以及每个JWT标记必须有一个匹配的 `kid` header。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keycloak</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloak</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keystore password. If `mp.jwt.verify.publickey.location` or `mp.jwt.decrypt.key.location` then this property has be set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keystore密码。如果有 `mp.jwt.verify.publickey.location` 或 `mp.jwt.decrypt.key.location` ，则此属性必须被设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kogito Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kogito 开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin and Jackson</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin和Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin and the Kubernetes Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin和Kubernetes客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin co-routines - a way to write asynchronous code in a sequential manner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin co-routines - 一种以顺序方式编写异步代码的方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin coroutines and Mutiny</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin coroutines和Mutiny</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin data classes are a very convenient way of defining data carrier classes, making them a great match to define an entity class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin data classes是定义数据载体类的一种非常方便的方式，非常适合定义实体类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin reflection annotation processing differs from Java.  You may experience an error when using CDI @Inject such as:
"kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin的反射注解处理与Java不同。在使用CDI @Inject时，您可能会遇到错误，比如。"kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin reflection annotation processing differs from Java.  You may experience an error when using CDI @Inject such as: "kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin的反射注解处理与Java不同。在使用CDI @Inject时，您可能会遇到错误，比如。"kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin requires a @field: xxx qualifier as it has no @Target on the annotation definition. Add @field: xxx in this example. @Default is used as the qualifier, explicitly specifying the use of the default bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin需要一个@field:xxx 限定符，因为它在注解定义上没有@Target。在此示例中添加@field: xxx 。@Default作为限定符，显式指定使用默认bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kube-Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kube-Native</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes Service Bindings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes服务绑定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes, but also bare metal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes，但也包括裸金属环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes-native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>LICENSE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>许可证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Label and tag can be used interchangably. You may also see "attribute" used in this context in some documentation.
The gist is each that each label or tag or attribute defines an additional bit of information associated with the
single numerical measurement that helps you classify, group, or aggregate the measured value later. The Micrometer API
uses `Tag` as the mechanism for specifying this additional data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Label和tag可以互换使用。您也可能在一些文档中看到 "属性 "在类似的上下文中使用。要点是每个标签，标记或属性都定义了与一个单一数字测量值相关的一组额外信息，以帮助您以后对测量值进行分类、分组或汇总。Micrometer API使用 `Tag` 作为指定这种额外数据的机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Label and tag can be used interchangably. You may also see "attribute" used in this context in some documentation.  The gist is each that each label or tag or attribute defines an additional bit of information associated with the single numerical measurement that helps you classify, group, or aggregate the measured value later. The Micrometer API uses `Tag` as the mechanism for specifying this additional data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Label和tag可以互换使用。您也可能在一些文档中看到 "属性 "在类似的上下文中使用。要点是每个标签，标记或属性都定义了与一个单一数字测量值相关的一组额外信息，以帮助您以后对测量值进行分类、分组或汇总。Micrometer API使用 `Tag` 作为指定这种额外数据的机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last Publish Date</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后发布日期</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后但并非最不重要的是，Mutiny内置了与MicroProfile上下文传播的集成，因此您可以在响应管道中传播事务、跟踪数据等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly different applications can subscribe independently to same topics using different *consumer group ids*.
For example, messages published to a topic called _orders_ can be consumed independently on two consumer applications, one with `mp.messaging.incoming.orders.group.id=invoicing` and second with `mp.messaging.incoming.orders.group.id=shipping`.
Different consumer groups can thus scale independently according to the message consumption requirements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，不同的应用程序可以使用不同的 *consumer group ids* 来的独立订阅同一topic。例如，发布在一个名为 _orders_ 的topic上的消息可以被两个消费者应用相互独立的消费，其中一个的group id是 `mp.messaging.incoming.orders.group.id=invoicing` ，另一个是 `mp.messaging.incoming.orders.group.id=shipping` 。因此，不同的消费者组可以根据消息消费的需求独立的进行扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly different applications can subscribe independently to same topics using different *consumer group ids*.  For example, messages published to a topic called _orders_ can be consumed independently on two consumer applications, one with `mp.messaging.incoming.orders.group.id=invoicing` and second with `mp.messaging.incoming.orders.group.id=shipping`.  Different consumer groups can thus scale independently according to the message consumption requirements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，不同的应用程序可以使用不同的 *consumer group ids* 来的独立订阅同一topic。例如，发布在一个名为 _orders_ 的topic上的消息可以被两个消费者应用相互独立的消费，其中一个的group id是 `mp.messaging.incoming.orders.group.id=invoicing` ，另一个是 `mp.messaging.incoming.orders.group.id=shipping` 。因此，不同的消费者组可以根据消息消费的需求独立的进行扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly, the `producer` will read the quotes and send them to the browser using server-sent events.
The user will therefore see the quote price updated from _pending_ to the received price in real-time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后， `producer` 将读取报价，并使用服务器发送事件将其发送给浏览器。因此，用户将实时看到报价从 _pending_ 更新为收到的价格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly, the `producer` will read the quotes and send them to the browser using server-sent events.  The user will therefore see the quote price updated from _pending_ to the received price in real-time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后， `producer` 将读取报价，并使用服务器发送事件将其发送给浏览器。因此，用户将实时看到报价从 _pending_ 更新为收到的价格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launching containers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动容器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn everything you need to know about the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解你需要知道的关于Qute模板引擎的一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to build and push container images with Jib, S2I or Docker as part of the Quarkus build.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用Jib、S2I或Docker构建和推送容器镜像，作为Quarkus构建的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.
This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>学习如何创建一个Hello World Quarkus应用程序。本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>学习如何创建一个Hello World Quarkus应用程序。本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用Quarkus创建响应式应用程序，并探索Quarkus提供的不同响应式功能。 本指南涵盖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to customize the Redis client to your needs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何根据自己的需要定制Redis客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何让你的扩展为Dev UI贡献功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to implement highly performant, low-overhead database applications on Quarkus with the xref:reactive-sql-clients.adoc[Reactive SQL Clients].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用 xref:reactive-sql-clients.adoc[响应式SQL客户端] 在 Quarkus 上实现高性能、低开销的数据库应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何将你的扩展与Quarkus的CDI容器集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to test your Quarkus Application.
This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>学习如何测试您的Quarkus应用程序。本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to test your Quarkus Application.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>学习如何测试您的Quarkus应用程序。本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how you can reduce the size of your native executables with UPX.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解你如何用UPX减少你的原生可执行文件的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus class loading infrastructure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解关于Quarkus类加载基础设施的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus integrations in IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus在IDE中的整合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus reactive architecture.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解关于Quarkus响应式架构的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于配置Quarkus基于Vert.x的HTTP层的信息--如果你使用servlets的话，还有Undertow。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about developing reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解有关使用Quarkus开发响应式应用程序的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how Quarkus handles authentication.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus如何处理认证的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to configure your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何配置你的Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to develop reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何用Quarkus开发响应式应用程序的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can pass contextual information with SmallRye Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何利用SmallRye Context Propagation传递上下文信息的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can send email from a Quarkus application with our reactive email client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何使用我们的响应式电子邮件客户端从Quarkus应用程序发送电子邮件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can use templating in your applications with the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何利用Qute模板引擎在你的应用程序中使用模板。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you extract content from documents using the Apache Tika toolkit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何使用Apache Tika工具包从文档中提取内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the Scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Scheduler扩展的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the base runtime image used by Quarkus for native executables and how you can tweak it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus用于原生可执行文件的基本运行时镜像，以及如何调整它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the notion of extension registry and how you can use your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于扩展仓库的概念，以及如何使用自己的扩展仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about what we call a Platform in the Quarkus world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus 世界中我们称之为平台的东西。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn step by step how to build a simple extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一步一步地学习如何构建一个简单的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Legacy API approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的API方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's consider the following scenarios:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们考虑以下场景：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's continue our API with `getSingle`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们用 `getSingle` 继续我们的API：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create the `Legume` class which will be serialized as JSON, following the same model as for our `Fruit` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们创建一个将被序列化为 JSON 的 `Legume` 类，遵循与我们的 `Fruit` 类相同的模型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's define the `Cost` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们定义 `Cost` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's do that and follow the same steps as before:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们这样做，并遵循与之前相同的步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's explore briefly different producer/consumer patterns and how to implement them using Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们简单展示一下不同的生产者/消费者模式以及如何使用Quarkus来实现它们：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine the following process:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们假设以下过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you receive `Fruit` objects.
For simplicity purposes, our `Fruit` class is pretty simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们假设您收到了 `Fruit` 对象。为了简单起见，我们的 `Fruit` 类非常简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you receive `Fruit` objects.  For simplicity purposes, our `Fruit` class is pretty simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们假设您收到了 `Fruit` 对象。为了简单起见，我们的 `Fruit` 类非常简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine your application receives `Message&lt;Double&gt;`.
You can consume the payload directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们想象一下你的应用程序接收 `Message&lt;Double&gt;` 。你可以直接消费该有效载荷：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine your application receives `Message&lt;Double&gt;`.  You can consume the payload directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们想象一下你的应用程序接收 `Message&lt;Double&gt;` 。你可以直接消费该有效载荷：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.
Create the `src/main/java/org/acme/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们修改应用程序并添加一个bean。创建 `src/main/java/org/acme/GreetingService.java` 文件，内容如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们修改应用程序并添加一个bean。创建 `src/main/java/org/acme/GreetingService.java` 文件，内容如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create a `ReactiveGreetingService` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们创建一个 `ReactiveGreetingService` 类，包含以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now implement a new HTTP endpoint that queries the Wikipedia API to retrieve the pages about Quarkus in the different languages.
Add the following method to the `VertxResource` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们实现一个新的 HTTP 端点，它通过查询 Wikipedia API 以检索不同语言有关 Quarkus 的页面。
将以下方法添加到 `VertxResource` 类中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now implement a new HTTP endpoint that queries the Wikipedia API to retrieve the pages about Quarkus in the different languages.
Add the following method to the `VertxResource` class:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们实现一个新的 HTTP 端点，它通过查询 Wikipedia API 以检索不同语言有关 Quarkus 的页面。
将以下方法添加到 `VertxResource` 类中:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.
It uses the request/reply dispatching mechanism.
Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.
Another bean consumes this message, and the response is sent using the _reply_ mechanism.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们重新访问一个响应的HTTP端点，并使用异步消息传递将调用委托给一个单独的bean。它使用了request/reply的调度机制。我们不是在JAX-RS端点内实现业务逻辑，而是发送一个消息。另一个Bean使用这个消息，并使用 _回复_ 机制发送响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.  It uses the request/reply dispatching mechanism.  Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.  Another bean consumes this message, and the response is sent using the _reply_ mechanism.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们重新访问一个响应的HTTP端点，并使用异步消息传递将调用委托给一个单独的bean。它使用了request/reply的调度机制。我们不是在JAX-RS端点内实现业务逻辑，而是发送一个消息。另一个Bean使用这个消息，并使用 _回复_ 机制发送响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's say we want to test the following processor application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>假设我们想测试以下的处理器应用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/users/me` endpoint.
As you can see from the source code below it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从实现 `/api/users/me` 端点开始。从下面的源代码可以看出，它只是一个普通的JAX-RS资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/users/me` endpoint.  As you can see from the source code below it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从实现 `/api/users/me` 节点开始。从下面的源代码可以看出，它就是一个普通的JAX-RS资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/users/me` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从实现 `/api/users/me` 端点开始。从下面的源代码可以看出，它只是一个普通的JAX-RS资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the `Fruit` entity.Create the `src/main/java/org/acme/hibernate/orm/panache/Fruit.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从 `Fruit` 实体开始。创建 `src/main/java/org/acme/hibernate/orm/panache/Fruit.java` 文件，内容如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the `getAll` method. The `getAll` method returns all the fruits stored in the database.
In the `FruitResource`, add the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从 `getAll` 方法开始。 `getAll` 方法返回存储在数据库中的所有水果对象。在 `FruitResource` 中，添加以下代码：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the `getAll` method. The `getAll` method returns all the fruits stored in the database.  In the `FruitResource`, add the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从 `getAll` 方法开始。 `getAll` 方法返回存储在数据库中的所有水果对象。在 `FruitResource` 中，添加以下代码：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们举两个例子来解释它是如何工作的。想象一个传入的HTTP请求。嵌入在Quarkus中的 (Vert.x) HTTP服务器接收请求，然后将其路由到应用程序。如果请求的目标是一个 _imperative_ 方法（传统的JAX-RS，代码注释为 `@Blocking`…），路由层在 _worker_ 线程中调用资源方法，并在数据可用时写入响应。到目前为止，还没有什么新的或突出的。下图描述了这种行为。在这种情况下，应用程序代码是在工作线程上调用的，而业务逻辑会阻塞该线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example.  Add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们举个例子。添加以下依赖到你的应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try this.
In a terminal, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们试试这个。
在终端中，运行以下命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try this.
In a terminal, run:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们试试这个。
在终端中，运行以下命令:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in
`src/main/resources/META-INF/resources/index.html` :</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们写一个简单的测试来演示如何加载一些静态资源。首先创建一个简单的HTML文件 `src/main/resources/META-INF/resources/index.html` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in `src/main/resources/META-INF/resources/index.html` :</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们写一个简单的测试来演示如何加载一些静态资源。首先创建一个简单的HTML文件 `src/main/resources/META-INF/resources/index.html` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s go to the quark of things.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们来看看quark的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s start with the basics: HTTP microservices. In this context, you need to develop an HTTP endpoint, often called REST or CRUD. You process incoming HTTP requests, and to do so you often need to rely on other services, such as databases, or another HTTP service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从最基本的开始：HTTP微服务。在这种情况下，你需要开发一个HTTP端点，通常称为REST或CRUD。你处理传入的HTTP请求，而要做到这一点，你往往需要依靠其他服务，如数据库，或另一个HTTP服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s take a very simple application handling &lt;em&gt;elements&lt;/em&gt; from the periodic table. The code would be something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们来看看一个非常简单的处理周期表中&lt;em&gt;元素&lt;/em&gt;的应用程序。代码将是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>License</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>许可证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like most Quarkus extensions, the Quarkus AWS Lambda HTTP/REST extensions support Live Coding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与大多数Quarkus扩展一样，Quarkus AWS Lambda HTTP/REST扩展支持实时编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase MongoDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibase MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List all the configuration properties per extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>列出每个扩展的所有配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening on a Unix domain socket allows us to dispense with the overhead of TCP
if the connection to the quarkus service is established from the same host.
This can happen if access to the service goes through a proxy which is often the case
if you're setting up a service mesh with a proxy like Envoy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果与 quarkus 服务的连接是从同一主机建立的，那么侦听 Unix 域套接字允许我们免除 TCP 的开销。如果通过代理访问服务可能会发生这种情况，如果您使用 Envoy 等代理设置服务网格，通常会出现这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening on a Unix domain socket allows us to dispense with the overhead of TCP
if the connection to the quarkus service is established from the same host. This can happen
if access to the service goes through a proxy which is often the case
if you're setting up a service mesh with a proxy like Envoy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果与 quarkus 服务的连接是从同一主机建立的，那么侦听 Unix 域套接字允许我们免除 TCP 的开销。如果通过代理访问服务可能会发生这种情况，如果您使用 Envoy 等代理设置服务网格，通常会出现这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening on a Unix domain socket allows us to dispense with the overhead of TCP if the connection to the quarkus service is established from the same host.  This can happen if access to the service goes through a proxy which is often the case if you're setting up a service mesh with a proxy like Envoy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果与 quarkus 服务的连接是从同一主机建立的，那么侦听 Unix 域套接字允许我们免除 TCP 的开销。如果通过代理访问服务可能会发生这种情况，如果您使用 Envoy 等代理设置服务网格，通常会出现这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening on a Unix domain socket allows us to dispense with the overhead of TCP if the connection to the quarkus service is established from the same host. This can happen if access to the service goes through a proxy which is often the case if you're setting up a service mesh with a proxy like Envoy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果与 quarkus 服务的连接是从同一主机建立的，那么侦听 Unix 域套接字允许我们免除 TCP 的开销。如果通过代理访问服务可能会发生这种情况，如果您使用 Envoy 等代理设置服务网格，通常会出现这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening to a Unix Domain Socket</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>监听Unix Domain Socket</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding and Simulating AWS Lambda Environment Locally</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实时编码和本地模拟AWS Lambda环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding and Unit/Integration Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实时编码和单元/集成测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus进行实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live reload</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实时重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local Public Key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地公钥</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local verification</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local verification or introspection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地验证或自查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Location of the verification key which can point to both public and secret keys. Secret keys can only be in the JWK format. Note that 'mp.jwt.verify.publickey.location' will be ignored if this property is set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>验证密钥的位置，可以指向公钥和秘钥。秘密密钥只能是JWK格式。注意，如果设置了这个属性，`mp.jwt.verify.publickey.location` 将被忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lock management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>锁管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log Docker into your ECR registry and push the Docker image to it</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Docker记录到你的ECR注册表中，并将Docker镜像推送到其中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log in as the `admin` user to access the Keycloak Administration Console.
Username should be `admin` and password `admin`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以 `admin` 用户身份登录，访问Keycloak管理控制台。用户名应该是 `admin` ，密码是 `admin` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log in as the `admin` user to access the Keycloak Administration Console.  Username should be `admin` and password `admin`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以 `admin` 用户身份登录，访问Keycloak管理控制台。管理员账户请使用 `admin` ，密码是 `admin` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log in as the `admin` user to access the Keycloak Administration Console. Username should be `admin` and password `admin`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以 `admin` 用户身份登录，访问Keycloak管理控制台。用户名应该是 `admin` ，密码是 `admin` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging with Native Image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用原生镜像日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Login as `alice` (password: `alice`) who has a `user` role</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以 `alice` （密码： `alice` ）的身份登录，他的角色(role)是 `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Login as `alice` (password: `alice`) who only has a `User Permission` to access the `/api/users/me` resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以 `alice` （密码： `alice` ）登录，该用户仅有一个 `User Permission` 可以访问 `/api/users/me` 资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logout and login as `admin` (password: `admin`) who has both `Admin Permission` to access the `/api/admin` resource and `User Permission` to access the `/api/users/me` resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>退出并以 `admin` （密码： `admin` ）的身份登录，他同时拥有 `Admin Permission` 以访问 `/api/admin` 资源以及 `User Permission` 以访问 `/api/users/me` 资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logout and login as `admin` (password: `admin`) who has both `admin` and `user` roles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>退出并以 `admin` （密码： `admin` ）的身份登录，他同时拥有 `admin` 和 `user` 的角色(roles)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look at the return type; it returns a `Uni` of `List&lt;Fruit&gt;`.
`Uni` is an asynchronous type.
It's a bit like a future.
It's a placeholder that will get its value (item) later.
When it receives the item (Mutiny says it _emits_ its item), you can attach some behavior.
That's how we express the continuation: get a uni, and when the uni emits its item, execute the rest of the processing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>看看返回类型，它返回 `List&lt;Fruit&gt;` 的 `Uni` 。`Uni` 是一个异步类型。这有点像未来。它是一个占位符，稍后将获得它的值条目 (item) 。当它接收条目(Mutiny说它 _输出_ 的条目)时，你可以附加一些行为。这就是我们表示延续的方式：获取一个uni，当uni输出它的条目时，执行其余的处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look at the return type; it returns a `Uni` of `List&lt;Fruit&gt;`.  `Uni` is an asynchronous type.  It's a bit like a future.  It's a placeholder that will get its value (item) later.  When it receives the item (Mutiny says it _emits_ its item), you can attach some behavior.  That's how we express the continuation: get a uni, and when the uni emits its item, execute the rest of the processing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>看看返回类型，它返回 `List&lt;Fruit&gt;` 的 `Uni` 。`Uni` 是一个异步类型。这有点像未来。它是一个占位符，稍后将获得它的值条目 (item) 。当它接收条目(Mutiny说它 _输出_ 的条目)时，你可以附加一些行为。这就是我们表示延续的方式：获取一个uni，当uni输出它的条目时，执行其余的处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looking at the data produced by this counter, you can tell how often a negative number was checked, or the number one,
or an even number, and so on. Try the following sequence and look for `example_prime_number_total` in the plain text
output. Note that the `_total` suffix is added when Micrometer applies Prometheus naming conventions to
`example.prime.number`, the originally specified counter name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>看一下这个counter产生的数据，您可以看到负数或者数字1被或者偶数等被检查的频率。尝试以下命令，并在文本输出中查找 `example_prime_number_total` 。请注意，当Micrometer将Prometheus命名规则应用于 `example.prime.number` ，即最初指定的counter名称时，会添加后缀 `_total` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looking at the data produced by this counter, you can tell how often a negative number was checked, or the number one, or an even number, and so on. Try the following sequence and look for `example_prime_number_total` in the plain text output. Note that the `_total` suffix is added when Micrometer applies Prometheus naming conventions to `example.prime.number`, the originally specified counter name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>看一下这个counter产生的数据，您可以看到负数或者数字1被或者偶数等被检查的频率。尝试以下命令，并在文本输出中查找 `example_prime_number_total` 。请注意，当Micrometer将Prometheus命名规则应用于 `example.prime.number` ，即最初指定的counter名称时，会添加后缀 `_total` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MQTT Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MQTT客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MS SQL Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MS SQL客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mail Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>邮件客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mailer Reference Guide</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mailer 参考指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mailing list index page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>邮件列表索引页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maintainer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>维护者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to use the reactive variant</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保使用响应式变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to wrap methods modifying your database (e.g. `entity.persist()`) within a transaction. Marking a
CDI bean method `@ReactiveTransactional` will do that for you and make that method a transaction boundary. Alternatively,
you can use `Panache.withTransaction()` for the same effect. We recommend doing
so at your application entry point boundaries like your REST endpoint controllers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保修改数据库的方法（例如： `entity.persist()` ）处于同一个事务中。给一个CDI bean方法增加 `@ReactiveTransactional` 注解，可以确保该方法即事务边界。另外，你也可以使用 `Panache.withTransaction()` 来达到同样的效果。我们建议在应用端点的边界这样做，比如REST端点的Controller。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to wrap methods modifying your database (e.g. `entity.persist()`) within a transaction. Marking a
CDI bean method `@Transactional` will do that for you and make that method a transaction boundary. We recommend doing
so at your application entry point boundaries like your REST endpoint controllers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保修改数据库的方法（例如： `entity.persist()` ）处于同一个事务中。给一个CDI bean方法增加 `@Transactional` 注解，可以确保该方法即事务边界。我们建议在应用端点的边界这样做，比如REST端点的Controller。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to wrap methods modifying your database (e.g. `entity.persist()`) within a transaction. Marking a CDI bean method `@ReactiveTransactional` will do that for you and make that method a transaction boundary. Alternatively, you can use `Panache.withTransaction()` for the same effect. We recommend doing so at your application entry point boundaries like your REST endpoint controllers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保修改数据库的方法（例如： `entity.persist()` ）处于同一个事务中。给一个CDI bean方法增加 `@ReactiveTransactional` 注解，可以确保该方法即事务边界。另外，你也可以使用 `Panache.withTransaction()` 来达到同样的效果。我们建议在应用端点的边界这样做，比如REST端点的Controller。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to wrap methods modifying your database (e.g. `entity.persist()`) within a transaction. Marking a CDI bean method `@Transactional` will do that for you and make that method a transaction boundary. We recommend doing so at your application entry point boundaries like your REST endpoint controllers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保修改数据库的方法（例如： `entity.persist()` ）处于同一个事务中。给一个CDI bean方法增加 `@Transactional` 注解，可以确保该方法即事务边界。我们建议在应用端点的边界这样做，比如REST端点的Controller。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure use the documentation to have your questions answered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保使用文档来寻求问题答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you import the reactive variant of `PanacheEntity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确保你导入了 `PanacheEntity` 的响应式类库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you reference the image you uploaded previously (assumes that a role exists that can be used to run the lambda). Please note that it is not unlikely that for the JVM lambda function, the default memory limit of `128Mb` will not be enough to run the function. In that case, you can increase the memory limit when creating the function by providing the `--memory-size 256` parameter to your `aws lambda create-function` command. You can also adjust the function in the AWS console after you've created it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保你引用了之前上传的镜像（假设存在一个可以用来运行lambda的角色）。请注意，对于JVM lambda函数来说，默认的 `128Mb` 内存限制不足以运行该函数，这不是不可能的。在这种情况下，你可以在创建函数时通过向 `aws lambda create-function` 命令提供 `--memory-size 256` 参数来增加内存限制。你也可以在创建函数后，在AWS控制台中调整该函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make your entities extend `PanacheEntity`: it has an ID field that is auto-generated. If you require
a custom ID strategy, you can extend `PanacheEntityBase` instead and handle the ID yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让你的实体类继承 `PanacheEntity` ：它有一个自动生成的ID字段。如果你需要自定义ID策略，可以继承 `PanacheEntityBase` ，而不用自己处理ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make your entities extend `PanacheEntity`: it has an ID field that is auto-generated. If you require a custom ID strategy, you can extend `PanacheEntityBase` instead and handle the ID yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让你的实体类继承 `PanacheEntity` ：它有一个自动生成的ID字段。如果你需要自定义ID策略，可以继承 `PanacheEntityBase` ，而不用自己处理ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make your entities extend `PanacheMongoEntity` (optional if you are using the repository pattern)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使你的实体继承 `PanacheMongoEntity` （如果你使用资源库模式，则是可选的）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make your entities extend `PanacheMongoEntity`: it has an ID field that is auto-generated. If you require
a custom ID strategy, you can extend `PanacheMongoEntityBase` instead and handle the ID yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让你的实体继承 `PanacheMongoEntity` ：它有一个自动生成的ID字段。如果你需要一个自定义的ID策略，你可以继承 `PanacheMongoEntityBase` ，而不是自己处理ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make your entities extend `PanacheMongoEntity`: it has an ID field that is auto-generated. If you require a custom ID strategy, you can extend `PanacheMongoEntityBase` instead and handle the ID yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让你的实体继承 `PanacheMongoEntity` ：它有一个自动生成的ID字段。如果你需要一个自定义的ID策略，你可以继承 `PanacheMongoEntityBase` ，而不是自己处理ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Making `MyWireMockResource` inject the `wireMockServer` field can be done as shown in the `inject` method of the following code snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了使 `MyWireMockResource` 注入 `wireMockServer` 字段，可按以下代码片断中的 `inject` 方法进行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manage your MongoDB schema migrations with Liquibase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Liquibase管理你的MongoDB模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing Proxy Classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理代理类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing the transactions manually via `entityManager.getTransaction().begin()` and friends lead to a butt ugly code with tons of try catch finally that people get wrong.
Transactions are also about JMS and other database access, so one API makes more sense.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `entityManager.getTransaction().begin()` 和手动管理事务会导致一段丑陋的代码，最终人们会出错。 事务也与 JMS 和其他数据库访问有关，因此一个 API 更有意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing the transactions manually via `entityManager.getTransaction().begin()` and friends lead to a butt ugly code with tons of try catch finally that people get wrong.  Transactions are also about JMS and other database access, so one API makes more sense.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `entityManager.getTransaction().begin()` 和手动管理事务会导致一段丑陋的代码，最终人们会出错。 事务也与 JMS 和其他数据库访问有关，因此一个 API 更有意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandatory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否强制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.
Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel是Oracle GraalVM CE的一个下游发行版。Mandrel的主要目标是提供一种方法来构建专门为支持Quarkus而设计的原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.  Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel是Oracle GraalVM CE的一个下游发行版。Mandrel的主要目标是提供一种方法来构建专门为支持Quarkus而设计的原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.
This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.
These enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.
This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel的构建方式与Oracle GraalVM CE略有不同，它使用标准的OpenJDK项目。这意味着，Oracle往OpenJDK增加了一些小增强功能，并用于构建Oracle自己的GraalVM，但Mandrel不能从中获益。这些增强功能被省略了，因为它上游的标准OpenJDK并不管理这些特性，也无法提供保障。这一点在涉及到一致性和安全性时尤其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.
This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.
This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.
This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel的构建方式与Oracle GraalVM CE略有不同，它使用的是标准的OpenJDK项目。这意味着它不能从Oracle对用于构建他们自己的GraalVM下载的OpenJDK版本添加的一些小的增强功能中获益。这些增强功能被省略了，因为上游的OpenJDK并不管理它们，也无法担保。在涉及到一致性和安全性时，这一点尤其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  These enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel的构建方式与Oracle GraalVM CE略有不同，它使用标准的OpenJDK项目。这意味着，Oracle往OpenJDK增加了一些小增强功能，并用于构建Oracle自己的GraalVM，但Mandrel不能从中获益。这些增强功能被省略了，因为它上游的标准OpenJDK并不管理这些特性，也无法提供保障。这一点在涉及到一致性和安全性时尤其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel的构建方式与Oracle GraalVM CE略有不同，它使用的是标准的OpenJDK项目。这意味着它不能从Oracle对用于构建他们自己的GraalVM下载的OpenJDK版本添加的一些小的增强功能中获益。这些增强功能被省略了，因为上游的OpenJDK并不管理它们，也无法担保。在涉及到一致性和安全性时，这一点尤其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel目前只推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着Mandrel用户应该使用容器来构建他们的原生可执行文件。如果你正在为macOS或Windows目标平台构建原生可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前并不针对这些平台。直接在裸金属Linux上构建原生可执行文件是可能的，详细信息请参见 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel releases]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel目前只推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着Mandrel用户应该使用容器来构建他们的原生可执行文件。如果你正在为macOS或Windows目标平台构建原生可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前并不针对这些平台。直接在裸金属Linux上构建原生可执行文件是可能的，详细信息请参见 https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel releases]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is recommended for building native executables that target Linux containerized environments.
This means that Mandrel users are encouraged to use containers to build their native executables.
If you are building native executables for macOS,
you should consider using Oracle GraalVM instead,
because Mandrel does not currently target this platform.
Building native executables directly on bare metal Linux or Windows is possible,
with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README]
and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel被推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着，我们鼓励Mandrel用户使用容器来构建他们的原生可执行文件。如果你要为macOS构建本地可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前不针对这个平台。直接在裸机Linux或Windows上构建原生可执行文件是可能的，详情可参见 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel发行版] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is recommended for building native executables that target Linux containerized environments.  This means that Mandrel users are encouraged to use containers to build their native executables.  If you are building native executables for macOS, you should consider using Oracle GraalVM instead, because Mandrel does not currently target this platform.  Building native executables directly on bare metal Linux or Windows is possible, with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel被推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着，我们鼓励Mandrel用户使用容器来构建他们的原生可执行文件。如果你要为macOS构建本地可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前不针对这个平台。直接在裸机Linux或Windows上构建原生可执行文件是可能的，详情可参见 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel发行版] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel or GraalVM installed and xref:building-native-image.adoc#configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以安装Mandrel或者GraalVM，并xref:building-native-image.adoc#configuring-graalvm[正确配置]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base,
with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.
They support the same capabilities to build native executables as Oracle GraalVM CE,
with no significant changes to functionality.
Notably, they do not include support for polyglot programming.
The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.
These exclusions also mean Mandrel offers a considerable reduction in its distribution size
when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel版本的代码库来自于上游的Oracle GraalVM CE代码库，只做了一些小的改动，但也有一些重要的对于Quarkus本地应用程序来说是没有必要的排除项。它们支持与Oracle GraalVM CE相同的构建原生可执行文件的能力，在功能上没有重大变化。值得注意的是，它们不包括对多语言编程的支持。之所以排除这些功能，是为了给大多数Quarkus用户提供更好的支持水平。与Oracle GraalVM CE/EE相比，这些不包括的内容也意味着Mandrel发布的软件包大小大大减小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base, with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.  They support the same capabilities to build native executables as Oracle GraalVM CE, with no significant changes to functionality.  Notably, they do not include support for polyglot programming.  The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.  These exclusions also mean Mandrel offers a considerable reduction in its distribution size when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel版本的代码库来自于上游的Oracle GraalVM CE代码库，只做了一些小的改动，但也有一些重要的对于Quarkus本地应用程序来说是没有必要的排除项。它们支持与Oracle GraalVM CE相同的构建原生可执行文件的能力，在功能上没有重大变化。值得注意的是，它们不包括对多语言编程的支持。之所以排除这些功能，是为了给大多数Quarkus用户提供更好的支持水平。与Oracle GraalVM CE/EE相比，这些不包括的内容也意味着Mandrel发布的软件包大小大大减小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手工</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually using the micro base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手动使用微基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually using the minimal base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手工使用最小基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping Configuration to Objects</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将配置映射到对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping Protected Resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>映射受保护资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching is always done on a longest path wins basis, less specific permission sets are not considered if a more specific one
has been matched:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>匹配总是在最长路径胜利的基础上进行，如果已经匹配了更具体的权限集，则不考虑其他模糊的权限集：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching is always done on a longest path wins basis, less specific permission sets are not considered if a more specific one has been matched:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>匹配总是在最长路径胜利的基础上进行，如果已经匹配了更具体的权限集，则不考虑其他模糊的权限集：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching multiple paths and methods: both win</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>匹配多条路径和方法：双赢</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching multiple paths: longest path wins</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>匹配多条路径：最长的路径获胜</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching multiple paths: most specific method wins</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>匹配多条路径：最具体的方法获胜</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching on paths, methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>路径、方法的匹配</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching path but not method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>匹配路径但不匹配方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven's `sourceDirectory` and `testSourceDirectory` build properties are configured to point to Kotlin sources (`src/main/kotlin` and `src/test/kotlin` respectively)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven的 `sourceDirectory` 和 `testSourceDirectory` 构建属性被配置为指向Kotlin代码(分别是： `src/main/kotlin` 和 `src/test/kotlin` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring Performance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>衡量性能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测量你的测试的覆盖率</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messages coming from AMQP contain an instance of `IncomingAmqpMetadata` in the metadata.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>来自AMQP的消息在元数据中包含一个 `IncomingAmqpMetadata` 的实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Kafka connector maps _channels_ to Kafka _topics_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>信息在 *channels* 上传输。应用程序组件通过连接 channels 来发布和消费消息。Kafka connector将 _channels_ 映射到Kafka的 _topics_上 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method parameters can be annotated with the `io.opentelemetry.extension.annotations.SpanAttribute` annotation to
indicate which method parameters should be part of the Trace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>方法参数可以使用 `io.opentelemetry.extension.annotations.SpanAttribute` 注解进行注释，来表示哪些方法参数是包含在Trace中的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method parameters can be annotated with the `io.opentelemetry.extension.annotations.SpanAttribute` annotation to indicate which method parameters should be part of the Trace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>方法参数可以使用 `io.opentelemetry.extension.annotations.SpanAttribute` 注解进行注释，来表示哪些方法参数是包含在Trace中的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MicroProfile JWT configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile JWT配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer defines a core library providing a registration mechanism for Metrics, and core metric types (Counters,
Gauges, Timers, Distribution Summaries, etc.). These core types provide an abstraction layer that can be adapted to
different backend monitoring systems. In essence, your application (or a library) can `register` a `Counter`,
`Gauge`, `Timer`, or `DistributionSummary` with a `MeterRegistry`. Micrometer will then delegate that registration to
one or more implementations, where each implementation handles the unique considerations for the associated
monitoring stack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer定义了一个核心库为Metrics提供注册机制，以及核心metric类型（Counters、Gauges、Timers、Distribution Summaries等）。这些核心类型提供了一个抽象层，以适应不同的后端监控系统。从本质上讲，您的应用程序（或一个库）可以向 `MeterRegistry` `注册` 一个 `Counter` ， `Gauge` ， `Timer` ，或 `DistributionSummary` 。Micrometer会将该注册委托给一个或多个实现，每个实现都会处理相关监控栈的特定考虑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer defines a core library providing a registration mechanism for Metrics, and core metric types (Counters, Gauges, Timers, Distribution Summaries, etc.). These core types provide an abstraction layer that can be adapted to different backend monitoring systems. In essence, your application (or a library) can `register` a `Counter`, `Gauge`, `Timer`, or `DistributionSummary` with a `MeterRegistry`. Micrometer will then delegate that registration to one or more implementations, where each implementation handles the unique considerations for the associated monitoring stack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer定义了一个核心库为Metrics提供注册机制，以及核心metric类型（Counters、Gauges、Timers、Distribution Summaries等）。这些核心类型提供了一个抽象层，以适应不同的后端监控系统。从本质上讲，您的应用程序（或一个库）可以向 `MeterRegistry` `注册` 一个 `Counter` ， `Gauge` ， `Timer` ，或 `DistributionSummary` 。Micrometer会将该注册委托给一个或多个实现，每个实现都会处理相关监控栈的特定考虑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer does define two annotations, `@Counted` and `@Timed`, that can be added to methods.
The `@Timed` annotation will wrap the execution of a method and will emit the following tags
in addition to any tags defined on the annotation itself:
class, method, and exception (either "none" or the simple class name of a detected exception).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer确实也定义了两个注解， `@Counted` 和 `@Timed` ，它们可以被添加到方法中。 `@Timed` 注解将修饰一个方法的执行。除了注解本身定义的标签外，还将添加以下标签：类名、方法名和异常（"none "或检测到的异常的简单类名）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer does define two annotations, `@Counted` and `@Timed`, that can be added to methods. The `@Timed` annotation
will wrap the execution of a method and will emit the following tags in addition to any tags defined on the
annotation itself: class, method, and exception (either "none" or the simple class name of a detected exception).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer确实也定义了两个注解， `@Counted` 和 `@Timed` ，它们可以被添加到方法中。 `@Timed` 注解将修饰一个方法的执行。除了注解本身定义的标签外，还将添加以下标签：类名、方法名和异常（"none "或检测到的异常的简单类名）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer does define two annotations, `@Counted` and `@Timed`, that can be added to methods. The `@Timed` annotation will wrap the execution of a method and will emit the following tags in addition to any tags defined on the annotation itself: class, method, and exception (either "none" or the simple class name of a detected exception).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer确实也定义了两个注解， `@Counted` 和 `@Timed` ，它们可以被添加到方法中。 `@Timed` 注解将修饰一个方法的执行。除了注解本身定义的标签外，还将添加以下标签：类名、方法名和异常（"none "或检测到的异常的简单类名）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer is the recommended approach to metrics for Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer是Quarkus推荐的metrics度量库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer maintains an internal mapping between unique metric identifier and tag combinations and specific meter
instances. Using `register`, `counter`,  or other methods to increment counters or record values does not create
a new instance of a meter unless that combination of identifier and tag/label values hasn't been seen before.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer在唯一的metric标识和标签组合与对应的meter实例之间维护着一种内部映射关系。使用 `register` , `counter` , 或其他方法来增加counters或记录的数值并不会创建一个新的meter实例，除非该标识符和标记/标签值的组合以前未曾出现过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer maintains an internal mapping between unique metric identifier and tag combinations and specific meter instances. Using `register`, `counter`, or other methods to increment counters or record values does not create a new instance of a meter unless that combination of identifier and tag/label values hasn't been seen before.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer在唯一的metric标识和标签组合与对应的meter实例之间维护着一种内部映射关系。使用 `register` , `counter` , 或其他方法来增加counters或记录的数值并不会创建一个新的meter实例，除非该标识符和标记/标签值的组合以前未曾出现过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer provides a few additional mechanisms for creating gauges. Note that Micrometer does not create strong
references to the objects it observes by default. Depending on the registry, Micrometer either omits gauges that observe
objects that have been garbage-collected entirely or uses `NaN` (not a number) as the observed value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer提供了一些额外的机制来创建gauges。请注意，Micrometer在默认情况下不会对它所观察的对象创建强引用。根据其所在的registry，Micrometer要么完全省略掉观察已经被垃圾收集的对象的gauge，要么使用 `NaN` （not a umber - 不是数字）作为观察值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer provides a few additional mechanisms for creating gauges. Note that Micrometer does not create strong references to the objects it observes by default. Depending on the registry, Micrometer either omits gauges that observe objects that have been garbage-collected entirely or uses `NaN` (not a number) as the observed value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer提供了一些额外的机制来创建gauges。请注意，Micrometer在默认情况下不会对它所观察的对象创建强引用。根据其所在的registry，Micrometer要么完全省略掉观察已经被垃圾收集的对象的gauge，要么使用 `NaN` （not a umber - 不是数字）作为观察值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer provides an API that allows you to construct your own custom metrics. The most common types of
meters supported by monitoring systems are gauges, counters, and summaries. The following sections build
an example endpoint, and observes endpoint behavior using these basic meter types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer提供了一个API，允许您构建自己的自定义度量。监测系统支持的最常见的meters类型是gauges、counters和summaries。下面的章节构建了一个示例节点，并使用这些基本的meter类型观察节点行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer provides an API that allows you to construct your own custom metrics. The most common types of meters supported by monitoring systems are gauges, counters, and summaries. The following sections build an example endpoint, and observes endpoint behavior using these basic meter types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer提供了一个API，允许您构建自己的自定义度量。监测系统支持的最常见的meters类型是gauges、counters和summaries。下面的章节构建了一个示例节点，并使用这些基本的meter类型观察节点行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer uses `MeterFilter` instances to customize the metrics emitted by `MeterRegistry` instances.
The Micrometer extension will detect `MeterFilter` CDI beans and use them when initializing `MeterRegistry`
instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer使用 `MeterFilter` 实例来定制 `MeterRegistry` 实例发出的metrics。Micrometer扩展将检测 `MeterFilter` CDI beans，并在初始化 `MeterRegistry` 实例时使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer uses `MeterFilter` instances to customize the metrics emitted by `MeterRegistry` instances.  The Micrometer extension will detect `MeterFilter` CDI beans and use them when initializing `MeterRegistry` instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer使用 `MeterFilter` 实例来定制 `MeterRegistry` 实例发出的metrics。Micrometer扩展将检测 `MeterFilter` CDI beans，并在初始化 `MeterRegistry` 实例时使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer uses naming conventions to translate between registered Meters and the conventions used by various backend
registries. Meter names, for example, should be created and named using dots to separate segments, `a.name.like.this`.
Micrometer then translates that name into the format that the selected registry prefers. Prometheus
uses underscores, which means the previous name will appear as `a_name_like_this` in Prometheus-formatted metrics
output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer使用了一套命名规范来翻译已注册的Meters和各种后端registries使用的规范。例如，Meters名称的创建和命名应使用点来分隔各段，如 `a.name.like.this` 。之后Micrometer会将该名称翻译成所选registries使用的格式。Prometheus使用的是下划线，这意味着之前的名称在Prometheus的格式的metrics输出中会显示为 `a_name_like_this` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer uses naming conventions to translate between registered Meters and the conventions used by various backend registries. Meter names, for example, should be created and named using dots to separate segments, `a.name.like.this`.  Micrometer then translates that name into the format that the selected registry prefers. Prometheus uses underscores, which means the previous name will appear as `a_name_like_this` in Prometheus-formatted metrics output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer使用了一套命名规范来翻译已注册的Meters和各种后端registries使用的规范。例如，Meters名称的创建和命名应使用点来分隔各段，如 `a.name.like.this` 。之后Micrometer会将该名称翻译成所选registries使用的格式。Prometheus使用的是下划线，这意味着之前的名称在Prometheus的格式的metrics输出中会显示为 `a_name_like_this` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer will apply Prometheus conventions when emitting metrics for this timer. Prometheus measures time in seconds.
Micrometer converts measured durations into seconds and includes the unit in the metric name, per convention. After
visiting the prime endpoint a few more times, look in the plain text output for the following three entries:
`example_prime_number_test_seconds_count`, `example_prime_number_test_seconds_sum`, and
`example_prime_number_test_seconds_max`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer在为这个timer发送metrics时将应用Prometheus规范。Prometheus测量时间的单位是秒。Micrometer会将测量的持续时间转换为秒，并按照规范在metric名称中包含单位。再访问几次prime节点后，在文本输出中寻找以下三个条目： `example_prime_number_test_seconds_count` , `example_prime_number_test_seconds_sum` , 和 `example_prime_number_test_seconds_max` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer will apply Prometheus conventions when emitting metrics for this timer. Prometheus measures time in seconds.  Micrometer converts measured durations into seconds and includes the unit in the metric name, per convention. After visiting the prime endpoint a few more times, look in the plain text output for the following three entries: `example_prime_number_test_seconds_count`, `example_prime_number_test_seconds_sum`, and `example_prime_number_test_seconds_max`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer在为这个timer发送metrics时将应用Prometheus规范。Prometheus测量时间的单位是秒。Micrometer会将测量的持续时间转换为秒，并按照规范在metric名称中包含单位。再访问几次prime节点后，在文本输出中寻找以下三个条目： `example_prime_number_test_seconds_count` , `example_prime_number_test_seconds_sum` , 和 `example_prime_number_test_seconds_max` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microservices tend to come in systems.  Let’s now imagine you need to access another HTTP endpoint.  You can use an HTTP client directly; this is nothing more than repeating boilerplate code.  Quarkus provides a way to call HTTP endpoints easily using the &lt;a href="https://quarkus.io/guides/rest-client"&gt;MicroProfile Rest Client API&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>微服务往往是以系统的形式出现的。现在让我们想象一下，你需要访问另一个HTTP端点。你可以直接使用HTTP客户端；这不过是在重复模板代码。Quarkus提供了一种方法，可以使用&lt;a href="https://quarkus.io/guides/rest-client"&gt;MicroProfile Rest Client API&lt;/a&gt;轻松调用HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Migrating from RESTEasy Classic to RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从RESTEasy 指令式迁移到RESTEasy 响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Miscellaneous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>杂项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mixing `@QuarkusTest` with other type of tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>混合使用 `@QuarkusTest` 与其他类型的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mixing tests annotated with `@QuarkusTest` with tests annotated with either `@QuarkusDevModeTest`, `@QuarkusProdModeTest` or `@QuarkusUnitTest`
is not allowed in a single execution run (in a single Maven Surefire Plugin execution, for instance),
while the latter three can coexist.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一次执行中（例如在一次Maven Surefire Plugin执行中），将注释为 `@QuarkusTest` 的测试与注释为 `@QuarkusDevModeTest` 、 `@QuarkusProdModeTest` 或 `@QuarkusUnitTest` 的测试混合执行是不被允许的，但是后三者可以共存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mixing tests annotated with `@QuarkusTest` with tests annotated with either `@QuarkusDevModeTest`, `@QuarkusProdModeTest` or `@QuarkusUnitTest` is not allowed in a single execution run (in a single Maven Surefire Plugin execution, for instance), while the latter three can coexist.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一次执行中（例如在一次Maven Surefire Plugin执行中），将注释为 `@QuarkusTest` 的测试与注释为 `@QuarkusDevModeTest` 、 `@QuarkusProdModeTest` 或 `@QuarkusUnitTest` 的测试混合执行是不被允许的，但是后三者可以共存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mock Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mock支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mocking</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mock模拟测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mocking `EntityManager`, `Session` and entity instance methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>模拟 `EntityManager` , `Session` 及实体类的实例方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mocking `Mutiny.Session` and entity instance methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>模拟 `Mutiny.Session` , 及实体类的实例方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mocking using QuarkusMock</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用QuarkusMock进行mock</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mocking with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache mock</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.
In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现代应用程序经常需要定期运行特定的任务。在本指南中，你将学习如何安排定期任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现代应用程序经常需要定期运行特定的任务。在本指南中，你将学习如何安排定期任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically. In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现代应用程序经常需要定期运行特定的任务。在本指南中，你将学习如何安排定期任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modifying `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>修改 `function.zip` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB allows you to configure multiple clients.
Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB允许你配置多个客户端。使用多个客户端的方式与拥有一个客户端的方式相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB allows you to configure multiple clients.  Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB允许你配置多个客户端。使用多个客户端的方式与拥有一个客户端的方式相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB installed or Docker installed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装了MongoDB或安装了Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used, but using its raw API can be cumbersome as you need to express your entities and your queries as a MongoDB link:{mongodb-doc-root-url}/bson/documents/#document[`Document`].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB是一个广为人知的NoSQL数据库，但使用其原始API可能很麻烦，因为你需要将你的实体和你的查询表达为MongoDB的 link:{mongodb-doc-root-url}/bson/documents/#document[`Document`] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB是一个众所周知的NoSQL数据库，被广泛使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used. MongoDB with Panache offers a
new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already
covered in the xref:mongodb-panache.adoc[MongoDB with Panache guide].  In this guide, we'll cover the Kotlin specific changes
needed to use MongoDB with Panache in your Kotlin-based Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB是一个众所周知的NoSQL数据库，被广泛使用。MongoDB与Panache在这个熟悉的框架之上提供了一个新的层次。本指南将不深入讨论这两者的具体细节，因为这些内容已经在 link:mongodb-panache.html[MongoDB with Panache指南] 中涵盖。在本指南中，我们将介绍在基于Kotlin的Quarkus应用程序中使用MongoDB with Panache所需的Kotlin特定变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used. MongoDB with Panache offers a new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already covered in the xref:mongodb-panache.adoc[MongoDB with Panache guide].  In this guide, we'll cover the Kotlin specific changes needed to use MongoDB with Panache in your Kotlin-based Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB是一个众所周知的NoSQL数据库，被广泛使用。MongoDB与Panache在这个熟悉的框架之上提供了一个新的层次。本指南将不深入讨论这两者的具体细节，因为这些内容已经在 link:mongodb-panache.html[MongoDB with Panache指南] 中涵盖。在本指南中，我们将介绍在基于Kotlin的Quarkus应用程序中使用MongoDB with Panache所需的Kotlin特定变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB offers ACID transactions since version 4.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB从4.0版本开始提供ACID事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB queries are JSON based, so you will need some String manipulation or using the `Document` type and it will need a lot of boilerplate code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB的查询是基于JSON的，所以你需要一些String操作或使用 `Document` 类型，它需要大量的模板代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB queries are super powerful, but overly verbose for common operations, requiring you to write queries even
when you don't need all the parts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB的查询功能超级强大，但对于普通操作来说过于冗长，即使不需要所有的部分，也需要你编写查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB queries are super powerful, but overly verbose for common operations, requiring you to write queries even when you don't need all the parts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB的查询功能超级强大，但对于普通操作来说过于冗长，即使不需要所有的部分，也需要你编写查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB queries must be valid JSON documents,
using the same field multiple times in a query is not allowed using PanacheQL as it would generate an invalid JSON
(see link:https://github.com/quarkusio/quarkus/issues/12086[this issue on github]).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB查询必须是有效的JSON文档，不允许使用 PanacheQL 在查询中多次使用同一字段，因为它将生成无效的JSON（见 link:https://github.com/quarkusio/quarkus/issues/12086[这个问题在github上] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB queries must be valid JSON documents, using the same field multiple times in a query is not allowed using PanacheQL as it would generate an invalid JSON (see link:https://github.com/quarkusio/quarkus/issues/12086[this issue on github]).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB查询必须是有效的JSON文档，不允许使用 PanacheQL 在查询中多次使用同一字段，因为它将生成无效的JSON（见 link:https://github.com/quarkusio/quarkus/issues/12086[这个问题在github上] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB与Panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache allows using reactive style implementation for both entities and repositories.
For this, you need to use the Reactive variants when defining your entities : `ReactivePanacheMongoEntity` or `ReactivePanacheMongoEntityBase`,
and when defining your repositories: `ReactivePanacheMongoRepository` or `ReactivePanacheMongoRepositoryBase`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB允许对实体和存储库使用响应式实现。为此，你需要在定义实体时使用Reactive变形： `ReactivePanacheMongoEntity` 或 `ReactivePanacheMongoEntityBase` ，在定义存储库时使用： `ReactivePanacheMongoRepository` 或 `ReactivePanacheMongoRepositoryBase` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache allows using reactive style implementation for both entities and repositories.  For this, you need to use the Reactive variants when defining your entities : `ReactivePanacheMongoEntity` or `ReactivePanacheMongoEntityBase`, and when defining your repositories: `ReactivePanacheMongoRepository` or `ReactivePanacheMongoRepositoryBase`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB允许对实体和存储库使用响应式实现。为此，你需要在定义实体时使用Reactive变形： `ReactivePanacheMongoEntity` 或 `ReactivePanacheMongoEntityBase` ，在定义存储库时使用： `ReactivePanacheMongoRepository` 或 `ReactivePanacheMongoRepositoryBase` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache also supports extended MongoDB queries by providing a `Document` query, this is supported by the find/list/stream/count/delete/update methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB还支持扩展的MongoDB查询，提供了一个 `Document` 查询，这被find/list/stream/count/delete/update方法所支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache and Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache和Kotlin的MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache offers operations to update multiple documents based on an update document and a query :
`Person.update("foo = ?1, bar = ?2", fooName, barName).where("name = ?1", name)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB提供了基于一个更新文档和一个查询的操作来更新多个文档： `Person.update("foo = ?1, bar = ?2", fooName, barName).where("name = ?1", name)` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache offers operations to update multiple documents based on an update document and a query : `Person.update("foo = ?1, bar = ?2", fooName, barName).where("name = ?1", name)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB提供了基于一个更新文档和一个查询的操作来更新多个文档： `Person.update("foo = ?1, bar = ?2", fooName, barName).where("name = ?1", name)` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache provides active record style entities (and repositories) like you have in xref:hibernate-orm-panache.adoc[Hibernate ORM with Panache] and focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB提供了活跃的记录风格的实体（和存储库），就像你在 link:hibernate-orm-panache.html[带有Panache的Hibernate ORM] 中所拥有的那样，并专注于使你的实体在Quarkus中编写起来既简单又有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache relies on compile-time bytecode enhancements to your entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB依赖于对你的实体进行编译时的字节码增强。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache uses the link:{mongodb-doc-root-url}/bson/pojos/[PojoCodecProvider] to convert your entities to a MongoDB `Document`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB使用 link:{mongodb-doc-root-url}/bson/pojos/[PojoCodecProvider] 将你的实体转换为MongoDB `Document` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache uses the link:{mongodb-doc-root-url}/bson/pojos[PojoCodecProvider], a MongoDB codec which mandates the presence of a parameterless constructor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB使用 link:{mongodb-doc-root-url}/bson/pojos[PojoCodecProvider] ，这是一个MongoDB编解码器，它强制要求存在一个无参数构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache uses the link:{mongodb-doc-root-url}/bson/pojos[PojoCodecProvider], with link:{mongodb-doc-root-url}/pojos/#pojo-support[automatic POJO support],
to automatically convert your object to a BSON document.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache的MongoDB使用 link:{mongodb-doc-root-url}/bson/pojos[PojoCodecProvider] ， link:{mongodb-doc-root-url}/pojos/#pojo-support[自动支持POJO] ，自动将你的对象转换为BSON文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More About Configuring Protected Resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于配置受保护资源的更多信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More About Configuring Protected Resources </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于配置受保护资源的更多信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Spring guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多 Spring 指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about Mutiny can be found in xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有关 Mutiny 的更多详细信息，请参见外部参考：xref:mutiny-primer.adoc[Mutiny - 一个直观的响应式编程库]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about the AMQP Address model can be found in the https://activemq.apache.org/components/artemis/documentation/2.0.0/address-model.html[Artemis documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于AMQP地址模型的更多详情，请参阅 link:https://activemq.apache.org/components/artemis/documentation/2.0.0/address-model.html[Artemis文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于SmallRye Reactive Messaging配置的更多细节可以在 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information about reflection in GraalVM can be found https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于GraalVM中反射的更多信息可以 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[在这里] 找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information can be found in the link:building-native-image#testing-the-native-executable[Testing the native executable Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多的信息可以在 link:building-native-image#testing-the-native-executable[Testing the native executable Guide] 里找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on how to use `Emitter` can be found in https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/emitter/emitter.html#_emitter_and_channel[SmallRye Reactive Messaging – Emitters and Channels]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于如何使用 `Emitter` ，可在 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/emitter/emitter.html#_emitter_and_channel[SmallRye Reactive Messaging – Emitters and Channels] 中找到更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most IDEs offer the possibility to run a selected class as a JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数IDE都提供了将选定的类直接作为JUnit测试运行的可能性。为了做到这点，您需要在您选择的IDE的设置中设置一些属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of our updates go out on &lt;a href="https://twitter.com/quarkusio"&gt;Twitter&lt;/a&gt;. Sometimes our project team speaks at industry events, and sometimes they post cool ways people use Quarkus. Wash, rinse, and retweet.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的大部分更新都是在&lt;a href="https://twitter.com/quarkusio"&gt;Twitter&lt;/a&gt;上发布的。有时我们的项目团队会在行业活动中发言，有时他们会发布人们使用Quarkus的很酷的方法。欢迎一键三连，多多转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the Quarkus tags are registered in the US link:https://nvd.nist.gov[National Vulnerability Database] (NVD) in Common Platform Enumeration (CPE) name format.
To view the registered Quarkus CPE names, use link:https://nvd.nist.gov/products/cpe/search/results?namingFormat=2.3&amp;keyword=quarkus[this search query].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数Quarkus标签已经在美国 link:https://nvd.nist.gov[国家漏洞数据库] （NVD）中使用通用平台条目（Common Platform Enumeration，CPE）名称格式注册。所有注册的Quarkus CPE名称都可以通过 link:https://nvd.nist.gov/products/cpe/search/results?namingFormat=2.3&amp;keyword=quarkus[这个搜索查询] 找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the Quarkus tags are registered in the US link:https://nvd.nist.gov[National Vulnerability Database] (NVD) in Common Platform Enumeration (CPE) name format.  To view the registered Quarkus CPE names, use link:https://nvd.nist.gov/products/cpe/search/results?namingFormat=2.3&amp;keyword=quarkus[this search query].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数Quarkus标签已经在美国 link:https://nvd.nist.gov[国家漏洞数据库] （NVD）中使用通用平台条目（Common Platform Enumeration，CPE）名称格式注册。所有注册的Quarkus CPE名称都可以通过 link:https://nvd.nist.gov/products/cpe/search/results?namingFormat=2.3&amp;keyword=quarkus[这个搜索查询] 找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.
Dev Services for AMQP implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数情况下，你需要在应用程序之间共享代理。AMQP的开发服务为在 _开发_ 模式下运行的多个Quarkus应用程序实现了一个 _服务发现_ 机制，来共享一个代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.
Dev Services for Kafka implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数情况下，您需要在应用程序之间共享broker。Kafka的开发服务实现了一个 _服务发现(service discovery)_ 机制，可以让您的多个在 _开发_ 模式下运行的Quarkus应用程序共享一个broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for AMQP implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数情况下，你需要在应用程序之间共享代理。AMQP的开发服务为在 _开发_ 模式下运行的多个Quarkus应用程序实现了一个 _服务发现_ 机制，来共享一个代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for Kafka implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数情况下，您需要在应用程序之间共享broker。Kafka的开发服务实现了一个 _服务发现(service discovery)_ 机制，可以让您的多个在 _开发_ 模式下运行的Quarkus应用程序共享一个broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the registry between applications.
Dev Services for Apicurio Registry implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数情况下，你需要在应用程序之间共享注册表。Apicurio注册表的开发服务为你在 _dev_ 模式下运行的多个Quarkus应用程序实现了一种 _service discovery_ 机制，以共享单个注册表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the registry between applications.  Dev Services for Apicurio Registry implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数情况下，你需要在应用程序之间共享注册表。Apicurio注册表的开发服务为你在 _dev_ 模式下运行的多个Quarkus应用程序实现了一种 _service discovery_ 机制，以共享单个注册表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the server between applications.
Dev Services for Redis implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很多时候你需要在多个应用之间共享Dev Services。Redis的Dev Services实现了 _服务发现_ 机制，允许多个以 _dev_ 模式运行的Quarkus应用共享同一个Dev Services。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the server between applications.  Dev Services for Redis implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很多时候你需要在多个应用之间共享Dev Services。Redis的Dev Services实现了 _服务发现_ 机制，允许多个以 _dev_ 模式运行的Quarkus应用共享同一个Dev Services。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most useful operations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最有用的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mount the host's directory `target/native-image` to the container's `/work`. Thus, the generated binary will also be written to this directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将主机的目录 `target/native-image` 挂载到容器的 `/work` 。因此，生成的二进制文件也将被写入这个目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multi-Tenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多租户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multi-tenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多租户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple MongoDB Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个MongoDB客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Persistence Units</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个持久化单元</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple options may be separated by a comma. For example, one could use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个选项可以用逗号隔开。例如，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple tenants that can support Bearer Token or Authorization Code Flow mechanism</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可支持 Bearer Token or Authorization Code Flow 机制的多租户模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ways to connect with others via forum, stack, chat, or email groups.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过论坛、Stack、聊天或电子邮件组多种方式同我们保持联系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiplier factor to determine maximum number of records queued for processing, using `max.poll.records` * `max-queue-size-factor`. Defaults to 2. In `batch` mode `max.poll.records` is considered `1`.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于决定队列中待处理的记录的最大值的乘数因子，使用 `max.poll.records` * `max-queue-size-factor` 来决定。默认为2。在 `batch` 模式下 `max.poll.records` 为 `1`。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny - A reactive programming library</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny - 一个响应式编程库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny - an intuitive and event-driven reactive programming library</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny - 一个直观的事件驱动的响应式编程库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny提供工具来将 RxJava 2 和 Project Reactor 类型转换为 `Uni` 和 `Multi`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny, Reactive for Bare Mortals</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny, 裸金属的响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutual TLS (mTLS) authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TLS互认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MySQL客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NB: For Gradle project setup please see below, and for further reference consult the guide in the xref:gradle-tooling.adoc[Gradle setup page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意：关于Gradle项目的设置，请见下文，如需进一步参考，请查阅 link:gradle-tooling.html[Gradle设置页面] 的指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NON-STANDARD FEATURES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非标准功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名称</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Name of the cookie containing a token. This property will be effective only if `mp.jwt.token.header` is set to `Cookie`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含令牌的cookie的名称。只有当 `mp.jwt.token.header` 被设置为 `Cookie` ，该属性才会有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Name of the cookie containing a token. This property will be effective only if `smallrye.jwt.token.header` is set to `Cookie`. This property is deprecated - use 'mp.jwt.token.cookie`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含token的cookie的名称。该属性只有在 `smallrye.jwt.token.header` 被设置为 `Cookie` 时才有效。该属性已被废弃--请使用 `mp.jwt.token.cookie`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Mongo client Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以Mongo客户端的名字进行注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Redis Client Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入有命名的Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named queries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命名查询</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named queries can only be defined inside your JPA entity classes (being the Panache entity class, or the repository parameterized type),
or on one of its super classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命名查询只能在JPA实体类（必须是Panache实体类，或Repository类的参数化类型）内定义，或在它的父类中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named queries can only be defined inside your JPA entity classes (being the Panache entity class, or the repository parameterized type), or on one of its super classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命名查询只能在JPA实体类（必须是Panache实体类，或Repository类的参数化类型）内定义，或在它的父类中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Narayana, as the underlying transaction manager, has a concept of a unique node identifier.
This is important if you consider using XA transactions that involve multiple resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Narayana作为底层事务管理器，有一个唯一节点标识符的概念。如果你考虑使用涉及多个资源的XA事务，这就很重要了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Narayana, as the underlying transaction manager, has a concept of a unique node identifier.  This is important if you consider using XA transactions that involve multiple resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Narayana作为底层事务管理器，有一个唯一节点标识符的概念。如果你考虑使用涉及多个资源的XA事务，这就很重要了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>National Vulnerability Database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>国家安全漏洞数据库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Native Executable的例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地可执行程序测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Pre-Boot</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生镜像预启动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Linux Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地Linux传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native MacOS Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地MacOS传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地运输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable compression</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生可执行文件压缩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable container image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地可执行的容器镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native transports are not supported in GraalVM produced binaries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM生产的二进制文件中不支持本地传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Need More Than Community Support?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要超出社区范围的支持?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Neo4j Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Neo4j客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Newsletter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新闻</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next prepare your `application.properties`. You can start with a completely empty `application.properties` as `Dev Services for Keycloak` will register `quarkus.oidc.auth-server-url` pointing to the running test container as well as `quarkus.oidc.client-id=quarkus-app` and `quarkus.oidc.credentials.secret=secret`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接下来准备你的 `application.properties` 。你可以从一个完全空的 `application.properties` 开始，因为 `Keycloak开发服务` 将注册指向运行中的测试容器的 `quarkus.oidc.auth-server-url` ，以及 `quarkus.oidc.client-id=quarkus-app` 和 `quarkus.oidc.credentials.secret=secret` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next you must copy some files from your GraalVM distribution into `src/main/zip.native/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接下来，你必须将GraalVM发行版中的一些文件复制到 `src/main/zip.native/` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, configure the plugin as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以像这样配置该插件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, while being in https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] root folder execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，在 link:https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] 的根目录下执行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No further action will be taken, and the tests will continue as normal (generally until CI times out), however the printed
stack traces should help diagnose why the build has failed. You can control this timeout with the
`quarkus.test.hang-detection-timeout` system property (you can also set this in application.properties, but this won't
be read until Quarkus has started, so the timeout for Quarkus start will be the default of 10 minutes).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不会有进一步的动作执行，测试将继续正常进行（通常直到CI超时），但是打印出来的堆栈信息应该有助于诊断为什么构建失败了。您可以用 `quarkus.test.hang-detection-timeout` 系统属性来控制这个超时值（您也可以在application.properties中设置这个值，但是在Quarkus启动之前它不会被读取，所以Quarkus启动的默认超时时间将是10分钟）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No further action will be taken, and the tests will continue as normal (generally until CI times out), however the printed stack traces should help diagnose why the build has failed. You can control this timeout with the `quarkus.test.hang-detection-timeout` system property (you can also set this in application.properties, but this won't be read until Quarkus has started, so the timeout for Quarkus start will be the default of 10 minutes).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不会有进一步的动作执行，测试将继续正常进行（通常直到CI超时），但是打印出来的堆栈信息应该有助于诊断为什么构建失败了。您可以用 `quarkus.test.hang-detection-timeout` 系统属性来控制这个超时值（您也可以在application.properties中设置这个值，但是在Quarkus启动之前它不会被读取，所以Quarkus启动的默认超时时间将是10分钟）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No hassle native executable generation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>轻松生成本机可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No legumes there.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那里没有legumes。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No, this is an old folk tale.
Let's assume it essentially comes for free and let you scale to more complex cases involving several datasources as needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不，这是一个古老的民间故事。让我们假设它基本上是免费的，让你根据需要扩展到涉及几个数据源的更复杂的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No, this is an old folk tale.  Let's assume it essentially comes for free and let you scale to more complex cases involving several datasources as needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不，这是一个古老的民间故事。让我们假设它基本上是免费的，让你根据需要扩展到涉及几个数据源的更复杂的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-standard Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非标准功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nonetheless, setting this property is encouraged even if the endpoint does not require access to the remote introspection endpoint. The reasons behind it that `client-id`, if set, can be used to verify the token audience and will also be included in the logs when the token verification fails for the better traceability of the tokens issued to specific clients to be analyzed over a longer period of time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尽管如此，即使端点不需要访问远程自省端点，也鼓励设置该属性。其背后的原因是： `client-id` ，如果设置了这个属性，就可以用来验证令牌受众，当令牌验证失败时，也会包含在日志中，以便更好地追踪发放给特定客户的令牌，并在较长的时间内进行分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally, HQL queries are of this form: `from EntityName [where ...] [order by ...]`, with optional elements
at the end.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常情况下，HQL查询语句是这种形式： `from EntityName [where ...​] [order by ...​]` ，结尾处有可选元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally, HQL queries are of this form: `from EntityName [where ...] [order by ...]`, with optional elements at the end.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常情况下，HQL查询语句是这种形式： `from EntityName [where ...​] [order by ...​]` ，结尾处有可选元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally, MongoDB queries are of this form: `{'firstname': 'John', 'lastname':'Doe'}`, this is what we call MongoDB native queries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常情况下，MongoDB的查询是这种形式： `{'firstname': 'John', 'lastname':'Doe'}` ，这就是我们所说的MongoDB原生查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note Quarkus `web-app` applications always require `quarkus.oidc.client-id` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意Quarkus `web-app` 应用程序总是需要 `quarkus.oidc.client-id` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note for this code to work we need the content of the RSA private key that corresponds to the public key we have in the TokenSecuredResource application. Take the following PEM content and place it into `security-jwt-quickstart/src/test/resources/privateKey.pem`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意为了使这段代码工作，我们需要RSA私钥的内容，它与我们在TokenSecuredResource应用程序中的公钥相对应。将以下PEM内容放入 `security-jwt-quickstart/src/test/resources/privateKey.pem` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how the AMQP broker location is configured.
The `amqp.host` and `amqp.port` (`AMQP_HOST` and `AMQP_PORT` environment variables) properties configure location.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意AMQP代理的位置是如何配置的。 `amqp.host` 和 `amqp.port` ( `AMQP_HOST` 和 `AMQP_PORT` 环境变量) 属性配置位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how the AMQP broker location is configured.  The `amqp.host` and `amqp.port` (`AMQP_HOST` and `AMQP_PORT` environment variables) properties configure location.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意AMQP代理的位置是如何配置的。 `amqp.host` 和 `amqp.port` ( `AMQP_HOST` 和 `AMQP_PORT` 环境变量) 属性配置位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note it is also recommended to use `quarkus.oidc.token.audience` property to verify the token `aud` (`audience`) claim value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，建议使用 `quarkus.oidc.token.audience` 属性来验证令牌 `aud` ( `audience` )声明的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note only the default tenant configuration applies when controlling anonymous access to the public resource is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意只有在需要控制公共资源的匿名访问时才适用默认租户配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `@TestSecurity` `user` and `roles` attributes are available as `TokenIntrospection` `username` and `scope` properties and you can use `io.quarkus.test.security.oidc.TokenIntrospection` to add the additional introspection response properties such as an `email`, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `@TestSecurity` `user` 和 `roles` 属性可作为 `TokenIntrospection` `username` 和 `scope` 属性，你可以使用 `io.quarkus.test.security.oidc.TokenIntrospection` 来添加额外的自省响应属性，如 `email` ，等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `@TestSecurity` annotation must always be used and its `user` property is returned as `JsonWebToken.getName()` and `roles` property - as `JsonWebToken.getGroups()`.
`@JwtSecurity` annotation is optional and can be used to set the additional token claims.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，必须始终使用 `@TestSecurity` 注解，并且其 `user` 属性作为 `JsonWebToken.getName()` ， `roles` 属性-作为 `JsonWebToken.getGroups()` 。 `@JwtSecurity` 注释是可选的，可以用来设置额外的标记要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `@TestSecurity` annotation must always be used and its `user` property is returned as `JsonWebToken.getName()` and `roles` property - as `JsonWebToken.getGroups()`.
`@OidcSecurity` annotation is optional and can be used to set the additional token claims, as well as `UserInfo` and `OidcConfigurationMetadata` properties.
Additionally, if `quarkus.oidc.token.issuer` property is configured then it will be used as an `OidcConfigurationMetadata` `issuer` property value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，必须始终使用 `@TestSecurity` 注解，其 `user` 属性将作为 `JsonWebToken.getName()` 和 `roles` 属性-作为 `JsonWebToken.getGroups()` 。 `@OidcSecurity` 注解是可选的，可用于设置额外的标记要求，以及 `UserInfo` 和 `OidcConfigurationMetadata` 属性。此外，如果配置了 `quarkus.oidc.token.issuer` 属性，那么它将被用作 `OidcConfigurationMetadata` `issuer` 属性的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `@TestSecurity` annotation must always be used and its `user` property is returned as `JsonWebToken.getName()` and `roles` property - as `JsonWebToken.getGroups()`.  `@JwtSecurity` annotation is optional and can be used to set the additional token claims.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，必须始终使用 `@TestSecurity` 注解，并且其 `user` 属性作为 `JsonWebToken.getName()` ， `roles` 属性-作为 `JsonWebToken.getGroups()` 。 `@JwtSecurity` 注释是可选的，可以用来设置额外的标记要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `@TestSecurity` annotation must always be used and its `user` property is returned as `JsonWebToken.getName()` and `roles` property - as `JsonWebToken.getGroups()`.  `@OidcSecurity` annotation is optional and can be used to set the additional token claims, as well as `UserInfo` and `OidcConfigurationMetadata` properties.  Additionally, if `quarkus.oidc.token.issuer` property is configured then it will be used as an `OidcConfigurationMetadata` `issuer` property value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，必须始终使用 `@TestSecurity` 注解，其 `user` 属性将作为 `JsonWebToken.getName()` 和 `roles` 属性-作为 `JsonWebToken.getGroups()` 。 `@OidcSecurity` 注解是可选的，可用于设置额外的标记要求，以及 `UserInfo` 和 `OidcConfigurationMetadata` 属性。此外，如果配置了 `quarkus.oidc.token.issuer` 属性，那么它将被用作 `OidcConfigurationMetadata` `issuer` 属性的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `MyClassRequiringReflection` and  `MySecondClassRequiringReflection` will be registered for reflection but not `MyReflectionConfiguration`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `MyClassRequiringReflection` 和 `MySecondClassRequiringReflection` 将被注册为反射，但不包括 `MyReflectionConfiguration` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `MyClassRequiringReflection` and `MySecondClassRequiringReflection` will be registered for reflection but not `MyReflectionConfiguration`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `MyClassRequiringReflection` 和 `MySecondClassRequiringReflection` 将被注册为反射，但不包括 `MyReflectionConfiguration` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `io.quarkus.oidc.TokenIntrospection` (a simple `javax.json.JsonObject` wrapper) object will be created and can be either injected or accessed as a SecurityIdentity `introspection` attribute if either JWT or opaque token has been successfully introspected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `io.quarkus.oidc.TokenIntrospection` （一个简单的 `javax.json.JsonObject` 包装器）对象将被创建，如果JWT或不透明令牌已被成功自省，可以被注入或作为SecurityIdentity `introspection` 属性访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that a message processing failures nacks the message, which is then handled by the `failure-strategy`.
It is the responsibility of the `failure-strategy` to report the failure and influence the outcome of the checks.
The `fail` failure strategy reports the failure, and so the check will report the fault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，消息处理失败会不认可消息，其然后由 `failure-strategy` 进行处理。报告失败并影响检查的结果是 `failure-strategy` 的责任。 `fail` 失败策略报告失败，因此检查将报告故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that a message processing failures nacks the message, which is then handled by the `failure-strategy`.  It is the responsibility of the `failure-strategy` to report the failure and influence the outcome of the checks.  The `fail` failure strategy reports the failure, and so the check will report the fault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，消息处理失败会不认可消息，其然后由 `failure-strategy` 进行处理。报告失败并影响检查的结果是 `failure-strategy` 的责任。 `fail` 失败策略报告失败，因此检查将报告故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that at present this approach does not work with native image testing, as this would require the test alternatives
to be baked into the native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外需要注意的是，目前这种方法不能用于本地镜像测试，因为这需要将测试用的alternatives加入本地镜像中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that at present this approach does not work with native image testing, as this would require the test alternatives to be baked into the native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外需要注意的是，目前这种方法不能用于本地镜像测试，因为这需要将测试用的alternatives加入本地镜像中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that due to consumer rebalances, Kafka consumers only guarantee at-least-once processing of single records, meaning that uncommitted records _can_ be processed again by consumers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，由于消费者之间的再平衡(rebalances)，Kafka消费者只保证对单一records的至少一次(at-least-once)处理，这意味着未提交的records _可以_ 被消费者再次处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that even numbers are added to the list, and odd numbers remove an element from the list.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在这里偶数被添加到列表中，而到奇数时列表将删除一个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that for production use the `transactional.id` must be unique across all application instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，要在生产环境使用，必须确保 `transactional.id` 在所有应用实例中是唯一的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in Reactive Messaging, the execution of processing methods, is already serialized, unless `@Blocking(ordered = false)` is used.
If `withTransaction` can be called concurrently, for example from a REST endpoint, it is recommended to limit the concurrency of the execution.
This can be done using the `@Bulkhead` annotation from link:https://quarkus.io/guides/smallrye-fault-tolerance[_Microprofile Fault Tolerance_].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在 Reactive Messaging 中，处理方法的执行已经被序列化，除非使用了 `@Blocking(ordered = false)` 。 如果可以同时调用 `withTransaction` ，例如从 REST 节点，建议限制执行的并发性。 这可以使用后面链接中的 `@Bulkhead` 注释来完成：link:https://quarkus.io/guides/smallrye-fault-tolerance[_Microprofile Fault Tolerance_]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in Reactive Messaging, the execution of processing methods, is already serialized, unless `@Blocking(ordered = false)` is used.  If `withTransaction` can be called concurrently, for example from a REST endpoint, it is recommended to limit the concurrency of the execution.  This can be done using the `@Bulkhead` annotation from link:https://quarkus.io/guides/smallrye-fault-tolerance[_Microprofile Fault Tolerance_].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在 Reactive Messaging 中，处理方法的执行已经被序列化，除非使用了 `@Blocking(ordered = false)` 。 如果可以同时调用 `withTransaction` ，例如从 REST 节点，建议限制执行的并发性。 这可以使用后面链接中的 `@Bulkhead` 注释来完成：link:https://quarkus.io/guides/smallrye-fault-tolerance[_Microprofile Fault Tolerance_]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that metrics appear lazily, you often won't see any data for your endpoint until
something tries to access it, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，metric是延迟出现的，您通常不会看到您的节点的任何数据，直到有请求试图访问它，等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that metrics appear lazily, you often won't see any data for your endpoint until something tries to access it, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，metric是延迟出现的，您通常不会看到您的节点的任何数据，直到有请求试图访问它，等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that some Quarkus extensions are wrapping Vert.x clients and manage them for you.
That's the case for the reactive data sources, Redis, mail...
That's not the case with the Web Client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，部分 Quarkus 扩展正在封装 Vert.x 客户端并为您管理它们。如响应式数据源、Redis、邮件等...  但Web 客户端，并不在此行列之内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that some Quarkus extensions are wrapping Vert.x clients and manage them for you.  That's the case for the reactive data sources, Redis, mail...  That's not the case with the Web Client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，部分 Quarkus 扩展正在封装 Vert.x 客户端并为您管理它们。如响应式数据源、Redis、邮件等...  但Web 客户端，并不在此行列之内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the Kafka advertised address is automatically configured with the chosen port.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，Kafka的广告地址(advertised address)会自动配置为所选择的端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the Kafka channels in SmallRye Reactive messaging are automatically configured with the chosen port.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，SmallRye响应式消息中的Kafka通道会自动使用所选的端口进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the OpenID Connect Provider externally accessible token and other endpoints may have different HTTP(S) URLs compared to the URLs auto-discovered or configured relative to `quarkus.oidc.auth-server-url` internal URL. For example, if your SPA acquires a token from an external token endpoint address and sends it to Quarkus as a Bearer token then an issuer verification failure may be reported by the endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，OpenID Connect Provider 外部可访问令牌和其他端点可能具有不同的 HTTP（S） URL，与相对于 `quarkus.oidc.auth-server-url` 内部 URL 自动发现或配置的 URL 相比。例如，如果您的 SPA 从外部令牌端点地址获取令牌并将其作为持有者令牌发送到 Quarkus，则端点可能会报告颁发者验证失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the `acks` attribute has a huge impact on the record acknowledgement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `acks` 属性对记录的确认有巨大影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the `generate` method returns a `Multi&lt;Double&gt;`, which implements the Reactive Streams `Publisher` interface.
This publisher will be used by the framework to generate messages and send them to the configured Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `generate` 方法返回了一个 `Multi&lt;Double&gt;` ，它实现了Reactive Streams `Publisher` 接口。Quarkus框架会使用这个发布者生成消息，并将其发送到您配置的Kafka topic中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the `generate` method returns a `Multi&lt;Double&gt;`, which implements the Reactive Streams `Publisher` interface.  This publisher will be used by the framework to generate messages and send them to the configured Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `generate` 方法返回了一个 `Multi&lt;Double&gt;` ，它实现了Reactive Streams `Publisher` 接口。Quarkus框架会使用这个发布者生成消息，并将其发送到您配置的Kafka topic中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the `quarkus-test-oidc-server` extension includes a signing RSA private key file in a `JSON Web Key` (`JWK`) format and points to it with a `smallrye.jwt.sign.key.location` configuration property. It allows to use a no argument `sign()` operation to sign the token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `quarkus-test-oidc-server` 扩展包括一个 `JSON Web Key` ( `JWK` ) 格式的签名 RSA 私钥文件，并通过 `smallrye.jwt.sign.key.location` 配置属性指向它。它允许使用一个无参数的 `sign()` 操作来签署令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the method returns the specific type of `MeterRegistry` as a `@Singleton`. Use MicroProfile Config
to inject any configuration attributes you need to configure the registry. Most Micrometer registry extensions,
like `quarkus-micrometer-registry-statsd`, define a producer for registry-specific configuration objects
that are integrated with the Quarkus configuration model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，该方法返回了一个特定类型的 `MeterRegistry` 的 `@Singleton` 。使用MicroProfile Config来注入任何您需要更改registry的配置属性。大多数Micrometer registry扩展，如 `quarkus-micrometer-registry-statsd` ，为registry特定的配置对象定义了一个用于与Quarkus配置模型集成的生产者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the method returns the specific type of `MeterRegistry` as a `@Singleton`. Use MicroProfile Config to inject any configuration attributes you need to configure the registry. Most Micrometer registry extensions, like `quarkus-micrometer-registry-statsd`, define a producer for registry-specific configuration objects that are integrated with the Quarkus configuration model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，该方法返回了一个特定类型的 `MeterRegistry` 的 `@Singleton` 。使用MicroProfile Config来注入任何您需要更改registry的配置属性。大多数Micrometer registry扩展，如 `quarkus-micrometer-registry-statsd` ，为registry特定的配置对象定义了一个用于与Quarkus配置模型集成的生产者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the rebalance listener methods are called from the Kafka polling thread and **will** block the caller thread until completion.
That’s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，再平衡(rebalance)监听器方法是在Kafka轮询线程中被调用的，并且 *会* 阻塞调用者线程直到完成。这是因为再平衡协议(rebalance protocol)有同步屏障，而在再平衡监听器中的异步代码可能会在同步屏障之后执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the rebalance listener methods are called from the Kafka polling thread and **will** block the caller thread until completion.  That’s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，再平衡(rebalance)监听器方法是在Kafka轮询线程中被调用的，并且 *会* 阻塞调用者线程直到完成。这是因为再平衡协议(rebalance protocol)有同步屏障，而在再平衡监听器中的异步代码可能会在同步屏障之后执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the successful processing of the incoming record batch will commit the latest offsets for each partition received inside the batch.
The configured commit strategy will be applied for these records only.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，对于接收到的记录批次的成功处理会提交所收到批次内每个分区的最新偏移量。所配置的提交策略将只应用于这些记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the successful processing of the incoming record batch will commit the latest offsets for each partition received inside the batch.  The configured commit strategy will be applied for these records only.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，对于接收到的记录批次的成功处理会提交所收到批次内每个分区的最新偏移量。所配置的提交策略将只应用于这些记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the
objects to provide the behaviour you require.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，这里并不依赖Mockito，您可以使用任何您喜欢的mocking库，甚至可以手动覆盖对象以提供您需要的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the objects to provide the behaviour you require.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，这里并不依赖Mockito，您可以使用任何您喜欢的mocking库，甚至可以手动覆盖对象以提供您需要的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that these features use the mapper managed by the `quarkus-jackson` extension.
Refer to xref:rest-json.adoc#json[Jackson configuration] to customize the mapping.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，这些功能使用由 `quarkus-jackson` 扩展管理的映射器。请参考 link:rest-json.html#json[Jackson的配置] 来自定义映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that these features use the mapper managed by the `quarkus-jackson` extension.  Refer to xref:rest-json.adoc#json[Jackson configuration] to customize the mapping.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，这些功能使用由 `quarkus-jackson` 扩展管理的映射器。请参考 link:rest-json.html#json[Jackson的配置] 来自定义映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that this configuration is a build time configuration, the property expression will be resolved at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，这个配置是构建时的配置，属性表达将在构建时被解析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that to achieve this, an _admin connection_ is required.
You can adjust the timeout for topic verification calls to the broker using the `health-topic-verification-timeout` configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，要实现这一点， 一个_管理员连接_是必须存在的 。您可以使用 `health-topic-verification-timeout` 来调整对broker的topic验证调用的超时时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that to achieve this, an _admin connection_ is required.  You can adjust the timeout for topic verification calls to the broker using the `health-topic-verification-timeout` configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，要实现这一点， 一个_管理员连接_是必须存在的 。您可以使用 `health-topic-verification-timeout` 来调整对broker的topic验证调用的超时时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we did not define any annotation such as `@RolesAllowed` to explicitly enforce access to a resource.
The extension will be responsible to map the URIs of the protected resources you have in Keycloak and evaluate the permissions accordingly, granting or denying access depending on the permissions that will be granted by Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，我们没有定义任何注解，如 `@RolesAllowed` ，以明确地执行对资源的访问。扩展将负责映射在Keycloak中的受保护资源的URI，并相应地评估权限，然后根据由Keycloak授予的权限来授予或拒绝访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we did not define any annotation such as `@RolesAllowed` to explicitly enforce access to a resource.  The extension will be responsible to map the URIs of the protected resources you have in Keycloak and evaluate the permissions accordingly, granting or denying access depending on the permissions that will be granted by Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，我们没有定义任何注解，如 `@RolesAllowed` ，以明确地执行对资源的访问。扩展将负责映射在Keycloak中的受保护资源的URI，并相应地评估权限，然后根据由Keycloak授予的权限来授予或拒绝访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we differentiate two contexts where the solution applied might be different:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，我们区分了两种情况，适用的解决方案可能是不同的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that while having retries in a reliable system is a best practice, the `max.in.flight.requests.per.connection` parameter defaults to `5`, meaning that the order of the messages is not guaranteed.
If the message order is a must for your use case, setting `max.in.flight.requests.per.connection` to `1` will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，虽然在对一个可靠的系统来说拥有重试机制是一种最佳实践，但 `max.in.flight.requests.per.connection` 参数默认为 `5` 将会意味着消息的顺序不会被保证。如果消息的顺序对您来说是必须保证的，将 `max.in.flight.requests.per.connection` 设置为 `1` 将确保一次只发送一批消息，但代价是限制生产者的吞吐量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that while having retries in a reliable system is a best practice, the `max.in.flight.requests.per.connection` parameter defaults to `5`, meaning that the order of the messages is not guaranteed.  If the message order is a must for your use case, setting `max.in.flight.requests.per.connection` to `1` will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，虽然在对一个可靠的系统来说拥有重试机制是一种最佳实践，但 `max.in.flight.requests.per.connection` 参数默认为 `5` 将会意味着消息的顺序不会被保证。如果消息的顺序对您来说是必须保证的，将 `max.in.flight.requests.per.connection` 设置为 `1` 将确保一次只发送一批消息，但代价是限制生产者的吞吐量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you can reference nested properties using the `.` (dot) separator as in `{x.factor}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，你可以使用 `.` (点)分隔符来引用嵌套的属性，如 `{x.factor}` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you can't access the injected `JsonWebToken` in the public methods if the token verification has not been done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，如果没有进行令牌验证，你就不能在公共方法中使用注入的 `JsonWebToken` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you need to be extremely careful here as anything in `META-INF/resources` will be exposed as static web resources.
So this directory is not a shortcut for "let's automatically include these resources in the native executable" and should only be used for static web resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，你在这里需要非常小心，因为 `META-INF/resources` 中的任何东西都会作为静态网络资源暴露出来。所以这个目录不是 "让我们自动把这些资源包含在本地可执行文件中 "的捷径，而应该只用于静态网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you need to be extremely careful here as anything in `META-INF/resources` will be exposed as static web resources.  So this directory is not a shortcut for "let's automatically include these resources in the native executable" and should only be used for static web resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，你在这里需要非常小心，因为 `META-INF/resources` 中的任何东西都会作为静态网络资源暴露出来。所以这个目录不是 "让我们自动把这些资源包含在本地可执行文件中 "的捷径，而应该只用于静态网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that, depending on how many resources you have in Keycloak the time taken to fetch them may impact your application startup time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，基于您在Keycloak中的资源数量，获取这些资源的时间可能会影响您的应用程序的启动时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the addition of `-kotlin` on the end.  Generally you'll only need this version but if your project will be using
both Java and Kotlin code, you can safely include both artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意最后添加了 `-kotlin` 。通常你只需要这个版本，但如果你的项目将同时使用 Java 和 Kotlin 代码，你可以安全地包含这两个工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the addition of `-kotlin` on the end.  Generally you'll only need this version but if your project will be using both Java and Kotlin code, you can safely include both artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意最后添加了 `-kotlin` 。通常你只需要这个版本，但如果你的项目将同时使用 Java 和 Kotlin 代码，你可以安全地包含这两个工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the addition of `-kotlin` on the end. Generally you'll only need this version but if your project will be using
both Java and Kotlin code, you can safely include both artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意最后添加了 `-kotlin` 。通常你只需要这个版本，但如果你的项目将同时使用 Java 和 Kotlin 代码，你可以安全地包含这两个工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the addition of `-kotlin` on the end. Generally you'll only need this version but if your project will be using both Java and Kotlin code, you can safely include both artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意最后添加了 `-kotlin` 。通常你只需要这个版本，但如果你的项目将同时使用 Java 和 Kotlin 代码，你可以安全地包含这两个工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the usage of an `Emitter&lt;Record&lt;K, V&gt;&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>声明 `Emitter&lt;Record&lt;K, V&gt;&gt;` 的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note we don't need to specify a path here, as `/hello` is the default for this test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意我们不需要在此指定路径，因为 `/hello` 是这个测试的默认路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note you can also use the injected `JsonWebToken` to access the individual claims in which case setting `@RequestScoped` is not necessary.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，你也可以使用注入的 `JsonWebToken` 来访问各个声明(claims)，在这种情况下，设置 `@RequestScoped` 是没有必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: If you want to use the `AuthzClient` directly make sure to set `quarkus.keycloak.policy-enforcer.enable=true` otherwise there is no Bean available for injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意：如果您想直接使用 `AuthzClient` ，请确保设置 `quarkus.keycloak.policy-enforcer.enable=true` ，否则将没有Bean可供注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy.
One important thing to note is that having a default constructor is required by the JSON serialization layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这非常的简单。需要注意的一件事是， JSON 序列化层需要具有默认构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这非常的简单。需要注意的一件事是， JSON 序列化层需要具有默认构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing needed in IntelliJ IDEA because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在IntelliJ中不需要任何改动，因为IDE会从 `pom.xml` 中的surefire插件配置中选择 `systemPropertyVariables` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing spectacular here.
On each received quote, it updates the page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里没有什么特别之处。对于每一个收到的报价，它都会更新页面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing spectacular here.  On each received quote, it updates the page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里没有什么特别之处。对于每一个收到的报价，它都会更新页面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that there is no tracing specific code included in the application. By default, requests sent to this
endpoint will be traced without any required code changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，应用程序中没有包含任何关于追踪的代码。默认情况下，不需要修改任何必要的代码就可以实现对发送到这个节点的请求进行追踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that there is no tracing specific code included in the application. By default, requests sent to this endpoint will be traced without any required code changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，应用程序中没有包含任何关于追踪的代码。默认情况下，不需要修改任何必要的代码就可以实现对发送到这个节点的请求进行追踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `second` segment).
The syntax is as follows: `quarkus.redis.[optional name.][redis configuration property]`.
If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在第二个配置项中有额外的一段（ `second` 段）。具体语法： `quarkus.redis.[可选的配置名称][Redis配置属性名]` 。如果省略名称，则为默认客户端的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `second` segment).  The syntax is as follows: `quarkus.redis.[optional name.][redis configuration property]`.  If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在第二个配置项中有额外的一段（ `second` 段）。具体语法： `quarkus.redis.[可选的配置名称][Redis配置属性名]` 。如果省略名称，则为默认客户端的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `users` and `inventory` segments).
The syntax is as follows: `quarkus.mongodb.[optional name.][mongo connection property]`.
If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意在键中有一个额外的位（ `users` 和 `inventory` 段）。语法如下： `quarkus.mongodb.[optional name.][mongo connection property]` 。如果省略了名称，则配置默认的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `users` and `inventory` segments).  The syntax is as follows: `quarkus.mongodb.[optional name.][mongo connection property]`.  If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意在键中有一个额外的位（ `users` 和 `inventory` 段）。语法如下： `quarkus.mongodb.[optional name.][mongo connection property]` 。如果省略了名称，则配置默认的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key.
The syntax is as follows: `quarkus.flyway.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，键中有一个额外的位。语法如下： `quarkus.flyway.[optional name.][datasource property]` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key.  The syntax is as follows: `quarkus.flyway.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，键中有一个额外的位。语法如下： `quarkus.flyway.[optional name.][datasource property]` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Available</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现已可用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now browse to http://localhost:4000
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在用浏览器访问 http://localhost:4000
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.mongodb.FruitService` that will be the business layer of our application and store/load the fruits from the mongoDB database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在创建一个 `org.acme.mongodb.FruitService` ，它将是我们应用程序的业务层，并从mongoDB数据库 store/load fruits。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now generate the token again and run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在再次生成令牌并运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to display our list of legumes.
In the `src/main/resources/META-INF/resources` directory, add a `legumes.html` file with the content from this
{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来显示我们的legumes列表。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `legumes.html` 文件，其中包含这个{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to display our list of legumes.  In the `src/main/resources/META-INF/resources` directory, add a `legumes.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来显示我们的legumes列表。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `legumes.html` 文件，其中包含这个{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.
Quarkus automatically serves static resources located under the `META-INF/resources` directory.
In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来与我们的 `FruitResource` 进行交互。Quarkus会自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含这个 {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.
Quarkus automatically serves static resources located under the `META-INF/resources` directory.
In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来与我们的 `FruitResource` 进行交互。Quarkus自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含这个{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来与我们的 `FruitResource` 进行交互。Quarkus会自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含这个 {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来与我们的 `FruitResource` 进行交互。Quarkus自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含这个{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a suffix for a greeting for which we'll set a default value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们为greeting 添加一个后缀，我们将为其设置一个默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's assume that we have the following tests:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们假设有以下测试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's consume the quote request and give out a price.
Inside the `processor` project, locate the `src/main/java/org/acme/amqp/processor/QuoteProcessor.java` file and add the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们来消费报价请求，并给出一个价格。在 `processor` 项目中，找到 `src/main/java/org/acme/amqp/processor/QuoteProcessor.java` 文件，并添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's consume the quote request and give out a price.  Inside the `processor` project, locate the `src/main/java/org/acme/amqp/processor/QuoteProcessor.java` file and add the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们来消费报价请求，并给出一个价格。在 `processor` 项目中，找到 `src/main/java/org/acme/amqp/processor/QuoteProcessor.java` 文件，并添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's create a `LegumeResource` REST service with only one method which returns the list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们创建一个 `LegumeResource` REST服务，它只有一个返回legumes类列表的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's use this to make a secured request to the /secured/roles-allowed endpoint. Make sure you have the Quarkus server still running in dev mode, and then run the following command, making sure to use your version of the generated JWT from the previous step:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们用它来向/secured/roles-allowed端点发出一个安全请求。确保你的Quarkus服务器仍然运行在开发模式下，然后运行以下命令，确保使用你在上一步中生成的JWT：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now modify `GreetingResource` to start using the `GreetingProperties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，修改 `GreetingResource` 以使用 `GreetingProperties` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the REST endpoint is running, we can access it using a command line tool like curl:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，REST端点正在运行，我们可以使用curl这样的命令行工具来访问它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that we can generate a JWT to access our secured REST endpoints, let's see what more we can do with the `JsonWebToken`
interface and the JWT claims. The `org.eclipse.microprofile.jwt.JsonWebToken` interface extends the `java.security.Principal`
interface, and is in fact the type of the object that is returned by the `javax.ws.rs.core.SecurityContext#getUserPrincipal()` call we
used previously. This means that code that does not use CDI but does have access to the REST container `SecurityContext` can get
hold of the caller `JsonWebToken` interface by casting the `SecurityContext#getUserPrincipal()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们可以生成一个JWT来访问我们的安全REST端点，让我们看看我们还能用 `JsonWebToken` 接口和JWT请求做什么。 `org.eclipse.microprofile.jwt.JsonWebToken` 接口扩展了 `java.security.Principal` 接口，事实上，它是我们之前使用的 `javax.ws.rs.core.SecurityContext#getUserPrincipal()` 调用返回的对象的类型。这意味着不使用CDI但可以访问REST容器 `SecurityContext` 的代码，可以通过转换 `SecurityContext#getUserPrincipal()` 来得到调用者 `JsonWebToken` 的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that we can generate a JWT to access our secured REST endpoints, let's see what more we can do with the `JsonWebToken` interface and the JWT claims. The `org.eclipse.microprofile.jwt.JsonWebToken` interface extends the `java.security.Principal` interface, and is in fact the type of the object that is returned by the `javax.ws.rs.core.SecurityContext#getUserPrincipal()` call we used previously. This means that code that does not use CDI but does have access to the REST container `SecurityContext` can get hold of the caller `JsonWebToken` interface by casting the `SecurityContext#getUserPrincipal()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们可以生成一个JWT来访问我们的安全REST端点，让我们看看我们还能用 `JsonWebToken` 接口和JWT请求做什么。 `org.eclipse.microprofile.jwt.JsonWebToken` 接口扩展了 `java.security.Principal` 接口，事实上，它是我们之前使用的 `javax.ws.rs.core.SecurityContext#getUserPrincipal()` 调用返回的对象的类型。这意味着不使用CDI但可以访问REST容器 `SecurityContext` 的代码，可以通过转换 `SecurityContext#getUserPrincipal()` 来得到调用者 `JsonWebToken` 的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now using your favorite editor or IDE, update `ReactiveGreetingResource.kt` and change the `hello` method to the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在使用您喜欢的编辑器或IDE，更新 `ReactiveGreetingResource.kt` ，并将 `hello` 方法改为如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. If using `application.properties` to configure the tracer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们准备运行我们的应用程序。如果使用 `application.properties` 来配置tracer：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. Use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们准备运行我们的应用程序。使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们已经准备好运行我们的应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we can generate a JWT to use with `TokenSecuredResource` endpoint. To do this, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们可以生成一个JWT，然后与 `TokenSecuredResource` 端点一起使用。要做到这一点，运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have defined our profile we need to include it on our test class.
We do this by annotating the test class with `@TestProfile(MockGreetingProfile.class)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们已经定义了我们自己的profile，我们需要在我们的测试类中引入它。我们通过在测试类中注解 `@TestProfile(MockGreetingProfile.class)` 来做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have defined our profile we need to include it on our test class.  We do this by annotating the test class with `@TestProfile(MockGreetingProfile.class)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们已经定义了我们自己的profile，我们需要在我们的测试类中引入它。我们通过在测试类中注解 `@TestProfile(MockGreetingProfile.class)` 来做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have three properties in our `GreetingProperties` class.
While `name` could be considered more of a runtime property (and maybe could be passed as an HTTP query parameter in the future), `text` and `suffix` are used to define a message template.
Let's group these two properties in a separate inner class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，在我们的 `GreetingProperties` 类中有三个属性。虽然 `name` 可以更多地被认为是运行时属性（也许在将来可以被作为HTTP查询参数进行传递），而 `text` 和 `suffix` 被用于定义一个消息模板。让我们将这两个属性作为一组放在一个独立的内部类中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have three properties in our `GreetingProperties` class.  While `name` could be considered more of a runtime property (and maybe could be passed as an HTTP query parameter in the future), `text` and `suffix` are used to define a message template.  Let's group these two properties in a separate inner class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，在我们的 `GreetingProperties` 类中有三个属性。虽然 `name` 可以更多地被认为是运行时属性（也许在将来可以被作为HTTP查询参数进行传递），而 `text` 和 `suffix` 被用于定义一个消息模板。让我们将这两个属性作为一组放在一个独立的内部类中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run the native build all these files will be included within `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，当你运行原生构建时，所有这些文件都将包含在 `function.zip` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can start your application and Quarkus will run the Flyway's
migrate method according to your config.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在可以启动你的应用程序，Quarkus会根据你的配置来运行Flyway的迁移方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can start your application and Quarkus will run the Flyway's migrate method according to your config.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在可以启动你的应用程序，Quarkus会根据你的配置来运行Flyway的迁移方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can use the AWS console to view and test your new lambda function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在你可以使用AWS控制台来查看和测试你的新lambda函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, create the `org.acme.mongodb.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，创建 `org.acme.mongodb.FruitResource` 类，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, create the `org.acme.rest.json.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，创建 `org.acme.rest.json.FruitResource` 类，如下所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, in your code, you can create an instance of `WebClient`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，在你的代码中，你可以创建一个 `WebClient` 的实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们创建 _entity_。创建 `org.acme.reactive.crud.Fruit` 类具有以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments/first` should return the following result:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，运行命令 `curl http://localhost:8080/increments/first` 应返回以下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments` should return an empty list `[]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，运行命令 `curl http://localhost:8080/increments` 应该返回一个空列表 `[]` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, start the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，使用以下命令启动应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we need the other side: the component receiving the name and replying.
Create the `src/main/java/org/acme/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，我们需要另一侧: 接收姓名并回复的组件。
使用以下内容创建 `src/main/java/org/acme/GreetingService.java` 文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we need the other side: the component receiving the name and replying.
Create the `src/main/java/org/acme/GreetingService.java` file with the following content:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，我们需要另一侧: 接收姓名并回复的组件。
使用以下内容创建 `src/main/java/org/acme/GreetingService.java` 文件:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a JSON-B serialized representation of your `Fruit` data object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，您的Kafka消息将包含 `Fruit` 数据对象的JSON-B序列化格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a Jackson serialized representation of your `Fruit` data object.
In this case, the `deserializer` configuration is not necessary as the &lt;&lt;serialization-autodetection&gt;&gt; is enabled by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，您的Kafka消息将包含 `Fruit` 数据对象的Jackson序列化格式。在这种情况下，`deserializer` 的配置不是必须的，因为 link:#serialization-autodetection[[序列化自动侦测]] 是默认启用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a Jackson serialized representation of your `Fruit` data object.  In this case, the `deserializer` configuration is not necessary as the &lt;&lt;serialization-autodetection&gt;&gt; is enabled by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，您的Kafka消息将包含 `Fruit` 数据对象的Jackson序列化格式。在这种情况下，`deserializer` 的配置不是必须的，因为 link:#serialization-autodetection[[序列化自动侦测]] 是默认启用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth authentication works for both JVM and native modes. Since SSL in not enabled by default in native mode, `quarkus.ssl.native=true` must be added to support JaasClientOauthLoginCallbackHandler, which uses SSL. (See the xref:native-and-ssl.adoc[Using SSL with Native Executables] guide for more details.)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth认证在JVM和原生模式下都有效。由于SSL在原生模式下默认不启用，所以必须添加 `quarkus.ssl.native=true` ，以支持JaasClientOauthLoginCallbackHandler。它使用了SSL。(更多细节请参见《 link:native-and-ssl.html[在原生可执行文件中使用SSL] 》指南)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth2 authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth2 认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OIDC `service` application needs to know OpenID Connect provider's token, `JsonWebKey` (JWK) set and possibly `UserInfo` and introspection endpoint addresses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OIDC `service` 应用程序需要知道OpenID Connect提供者的令牌、 `JsonWebKey` (JWK)集以及可能的 `UserInfo` 和自省端点地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OIDC topic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OIDC专题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可观察性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observe the console to verify that the following messages has been displayed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>观察控制台，检查是否显示了以下信息:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Often one obtains a JWT from an identity manager like https://www.keycloak.org/[Keycloak], but for this quickstart we will generate our own using the JWT generation API provided by `smallrye-jwt` (see xref:security-jwt-build.adoc[Generate JWT tokens with SmallRye JWT] for more information).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常情况下，人们会从身份管理服务器（如 link:https://www.keycloak.org/[Keycloak] ）那里获得JWT，但在这个快速入门中，我们将使用 `smallrye-jwt` 提供的JWT生成API来生成我们自己的JWT（更多信息 link:smallrye-jwt-build.html[见用SmallRye JWT生成JWT令牌] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>噢，是的！我们在Quarkus "初始" 团队之外编写了相当多的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oidc Provider Client Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OIDC供应商客户认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux you can enable the following socket options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Linux上，你可以启用以下socket选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Linux上，你将需要GCC，以及glibc和zlib头文件。常见发行版的例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MacOS Sierra and above you can enable the following socket options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在MacOS Sierra及以上版本，你可以启用以下socket选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will have to go through the Control Panel to set your environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上，您将不得不通过控制面板来设置你的环境变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上，你将需要安装 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++构建工具]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _出站_  channels 上，您可以通过将 `compression.type` 设置为 `snappy` 来启用Snappy压缩：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `Uni` 上，你也可以使用 `subscribeAsCompletionStage()` 来产生一个 `CompletionStage` 。 `CompletionStage` 会获得由 `Uni` 发出的条目或失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On a post request, generate a random UUID and send it to the AMQP queue using the emitter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在post请求中，生成一个随机的UUID，并使用emitter将其发送给AMQP队列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS (not supported by Mandrel), point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在macOS上（Mandrel不支持），将该变量指向 `Home` 子目录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS, point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在macOS中，将变量指向 `Home` 子目录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the other side, the reactive model relies on non-blocking I/Os and a different execution model.
Non-blocking I/O provides an efficient way to deal with concurrent I/O.
A minimal amount of threads called I/O threads, can handle many concurrent I/O.
With such a model, request processing is not delegated to a worker thread but uses these I/O threads directly.It saves memory and CPU as there is no need to create worker threads to handle the requests.
It also improves the concurrency as it removes the constraint on the number of threads.
Finally, it also improves response time as it reduces the number of thread switches.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一方面，响应式模型依赖于非阻塞 I/O和不同的执行模型。非阻塞I/O提供了一种处理并发I/O的有效方法。最小数量的线程称为I/O线程，可以处理许多并发I/O。使用这样的模型，请求处理不会委托给工作线程，而是直接使用这些I/O线程。它节省了内存和CPU，因为不需要创建工作线程来处理请求。它还改善了并发性，因为它消除了对线程数量的限制。最后，它还改善了响应时间，因为它减少了线程开关的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the other side, the reactive model relies on non-blocking I/Os and a different execution model.  Non-blocking I/O provides an efficient way to deal with concurrent I/O.  A minimal amount of threads called I/O threads, can handle many concurrent I/O.  With such a model, request processing is not delegated to a worker thread but uses these I/O threads directly.It saves memory and CPU as there is no need to create worker threads to handle the requests.  It also improves the concurrency as it removes the constraint on the number of threads.  Finally, it also improves response time as it reduces the number of thread switches.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一方面，响应式模型依赖于非阻塞 I/O和不同的执行模型。非阻塞I/O提供了一种处理并发I/O的有效方法。最小数量的线程称为I/O线程，可以处理许多并发I/O。使用这样的模型，请求处理不会委托给工作线程，而是直接使用这些I/O线程。它节省了内存和CPU，因为不需要创建工作线程来处理请求。它还改善了并发性，因为它消除了对线程数量的限制。最后，它还改善了响应时间，因为它减少了线程开关的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once added to your project, you can map _channels_ to AMQP addresses by configuring the `connector` attribute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦添加到你的项目中，你就可以通过配置 `connector` 属性将 _channels_ 映射到AMQP地址:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.
You will find the import of the Quarkus BOM, allowing you to omit the version of the different Quarkus dependencies.
In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦生成，请看 `pom.xml` 。你会发现Quarkus BOM的导入，允许你省略不同Quarkus依赖的版本。此外，你可以看到 `quarkus-maven-plugin` ，负责应用程序的打包，也提供开发模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version of the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦生成，请看 `pom.xml` 。你会发现Quarkus BOM的导入，允许你省略不同Quarkus依赖的版本。此外，你可以看到 `quarkus-maven-plugin` ，负责应用程序的打包，也提供开发模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once packaged, run `docker compose up --build`.
The UI is exposed on http://localhost:8080/quotes.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦打包完成，请运行 `docker compose up --build` 。UI在 http://localhost:8080/quotes.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once packaged, run `docker compose up --build`.  The UI is exposed on http://localhost:8080/quotes.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦打包完成，请运行 `docker compose up --build` 。UI在 http://localhost:8080/quotes.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行后，通过打开 http://localhost:8080/hello/greeting/neo 检查您是否得到了预期的问候信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once selected, click on "Generate your application", download the zip file, unzip it and open the code in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选中后，单击 "Generate your application"，下载压缩文件，解压缩并在您喜欢的IDE中打开代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once started, you can request the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦启动，你可以发送请求到提供服务的端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the bearer JWT token's signature has been verified and its `expires at` (`exp`) claim has been checked, the `iss` (`issuer`) claim value is verified next.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦无记名JWT令牌的签名被验证，其 `expires at` ( `exp` )声明会被检查，接下来也会验证 `iss` ( `issuer` )声明的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the build is finished, you can run the executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建完成后，可以用以下命令运行可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the file is read, the content is stored in an in-memory buffer.  We transform this buffer into a String.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦文件被读取，其内容就被存储在一个内存缓冲区内。我们将这个缓冲区的内容转换为一个字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the persist operation completes, we send the entity to Kafka. The `send` method returns a `Uni&lt;Void&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦持久化操作完成，我们就把实体发送到Kafka。 `send` 方法会返回一个 `Uni&lt;Void&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the reply is received by the sender, the content is written to the HTTP response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦发送方收到回复，会将内容写入 HTTP 响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once we have the Redis server running, we need to configure the Redis connection properties.
This is done in the `application.properties` configuration file. Edit it to the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行Redis服务后，我们需要在 `application.properties` 配置文件中配置Redis连接属性，增加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once we have the Redis server running, we need to configure the Redis connection properties.  This is done in the `application.properties` configuration file. Edit it to the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行Redis服务后，我们需要在 `application.properties` 配置文件中配置Redis连接属性，增加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have written your entity, here are the most common operations you will be able to perform:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写实体后，可以执行以下最常见的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have written your repository, here are the most common operations you will be able to perform:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写存储库后，您可以执行以下最常见的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the core features of Vert.x is the https://vertx.io/docs/vertx-core/java/#event_bus[event bus].
It provides a message-based backbone to your application.
So, you can have components interacting using asynchronous message passing, and so decouple your components.
You can send a message to a single consumer, or dispatch to multiple consumers, or implement a request-reply interaction, where you send a message (request) and expect a response.
This is what we are going to use in this section.
Our `VertxResource` will send a message containing a name to the `greetings` address.
Another component will receive the message and produce the "hello $name" response.
The `VertxResource` will receive the response and return it as the HTTP response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 的核心特点之一是 https://vertx.io/docs/vertx-core/java/#event_bus[事件总线]。它为你的应用程序提供了基于消息的主干。因此，你可以使用异步消息传递的方式在组件之间进行交互，并且将你的组件解耦。您可以向单个消费者发送消息，或分派给多个消费者，亦或是实现请求-响应的交互，在其中发送消息（请求）并期许响应。这是我们将在本节中使用的内容。我们的 `VertxResource`  将向问候地址发送一条包含姓名的消息。另一个组件将会接收到这条消息并生成 "hello $name" 的响应。 `VertxResource` 将收到响应并将其作为 HTTP 响应进行返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the core features of Vert.x is the https://vertx.io/docs/vertx-core/java/#event_bus[event bus].  It provides a message-based backbone to your application.  So, you can have components interacting using asynchronous message passing, and so decouple your components.  You can send a message to a single consumer, or dispatch to multiple consumers, or implement a request-reply interaction, where you send a message (request) and expect a response.  This is what we are going to use in this section.  Our `VertxResource` will send a message containing a name to the `greetings` address.  Another component will receive the message and produce the "hello $name" response.  The `VertxResource` will receive the response and return it as the HTTP response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 的核心特点之一是 https://vertx.io/docs/vertx-core/java/#event_bus[事件总线]。它为你的应用程序提供了基于消息的主干。因此，你可以使用异步消息传递的方式在组件之间进行交互，并且将你的组件解耦。您可以向单个消费者发送消息，或分派给多个消费者，亦或是实现请求-响应的交互，在其中发送消息（请求）并期许响应。这是我们将在本节中使用的内容。我们的 `VertxResource`  将向问候地址发送一条包含姓名的消息。另一个组件将会接收到这条消息并生成 "hello $name" 的响应。 `VertxResource` 将收到响应并将其作为 HTTP 响应进行返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的主要目标之一是易于扩展和构建一个充满活力的生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of these annotations is the `@BsonDiscriminator` annotation that allows to storage multiple Java types in a single MongoDB collection by adding
a discriminator field inside the document. It can be useful when working with abstract types or interfaces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其中一个注解是 `@BsonDiscriminator` ，它允许通过在文档中添加一个判别字段来在单个MongoDB集合中存储多个Java类型。在处理抽象类型或接口时，它可能很有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of these annotations is the `@BsonDiscriminator` annotation that allows to storage multiple Java types in a single MongoDB collection by adding a discriminator field inside the document. It can be useful when working with abstract types or interfaces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其中一个注解是 `@BsonDiscriminator` ，它允许通过在文档中添加一个判别字段来在单个MongoDB集合中存储多个Java类型。在处理抽象类型或接口时，它可能很有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing to note about the create command for native is that the `aws lambda create-function`
call must set a specific environment variable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于原生的创建命令，需要注意的一点是， `aws lambda create-function` 调用必须设置一个特定的环境变量：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing to note about the create command for native is that the `aws lambda create-function` call must set a specific environment variable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于原生的创建命令，需要注意的一点是， `aws lambda create-function` 调用必须设置一个特定的环境变量：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing to note is that the live reload feature is not available when making changes to both Java and Kotlin source that have dependencies on each other. We hope to alleviate this limitation in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一点需要注意的是，当对相互有依赖关系的Java和Kotlin源代码进行修改时，实时重载功能是不可用的。我们希望在未来能缓解这一限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open Source Utterly and Absolutely</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全和绝对地开放源代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/index.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在您的浏览器中打开 `http://localhost:8080/index.html`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/quotes.html` in your browser and request some quotes by clicking the button.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的浏览器中打开 `http://localhost:8080/quotes.html` ，点击按钮来请求一些报价。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a browser to http://localhost:8080/legumes.html and you will see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开浏览器访问 http://localhost:8080/legumes.html ，你会看到我们的legumes列表内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a xref:dev-ui.adoc[Dev UI] available at http://localhost:8080/q/dev[/q/dev] and click on a `Provider: Keycloak` link in an `OpenID Connect` `Dev UI` card.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开 link:http://localhost:8080/q/dev[/q/dev] 提供的 link:dev-ui.html[开发用户界面] ，点击 `OpenID Connect` `Dev UI` 卡片中的 `Provider: Keycloak` 链接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open another terminal and run the `curl http://localhost:8080/increments` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开另一个终端，运行 `curl http://localhost:8080/increments` 命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open http://localhost:8080/fruits to invoke this method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开 http://localhost:8080/fruits 调用这个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open src/main/resources/application.properties and add the following line to enable SSL in your native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开src/main/resources/application.properties，并在你的原生镜像中添加以下行来启用SSL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the two projects in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你喜欢的IDE中打开这两个项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open your browser to http://localhost:8080/greeting.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的浏览器中打开 http://localhost:8080/greeting 网页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open your favorite terminal and use JBang to install the Quarkus CLI. You do not need to have Java installed first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开您喜欢的终端并使用JBang安装Quarkus CLI。您不需要首先安装Java。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenID Connect (OIDC) Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect（OIDC）开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenID Connect (OIDC) is an identity layer that works on top of the OAuth 2.0 protocol. OIDC enables client applications to verify the identity of a user based on the authentication performed by the OIDC provider and to retrieve basic information about that user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect（OIDC）是一个身份层，它工作在OAuth 2.0协议之上。OIDC使客户端应用程序能够根据OIDC提供者进行的认证来验证用户的身份，并获取用户的基本信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenID Connect authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect 认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenID Connect client and filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect客户端和过滤器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenTelemetry Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry参考配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenTelemetry propagates cross-cutting concerns through https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] that will share an underlying `Context` for storing state and accesing
data across the lifespan of a distributed transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry通过 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] 来传播横切关注点(cross-cutting concerns)，这些 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] 将共享一个底层 `Context` ，用于在分布式事务的生命周期内存储状态和访问数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenTelemetry propagates cross-cutting concerns through https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] that will share an underlying `Context` for storing state and accesing data across the lifespan of a distributed transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry通过 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] 来传播横切关注点(cross-cutting concerns)，这些 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] 将共享一个底层 `Context` ，用于在分布式事务的生命周期内存储状态和访问数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Opinionated</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有态度的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional gRPC headers commonly used for authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可选的gRPC消息头，通常用于认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional values</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可选值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally Mandrel or GraalVM installed and xref:building-native-image.adoc#configuring-graalvm[configured appropriately] if you want to build a native executable (or Docker if you use a native container build)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想构建原生可执行程序，可以选择安装Mandrel或者GraalVM，并xref:building-native-image.adoc#configuring-graalvm[正确配置](或者使用Docker在容器中进行构建)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally get &lt;a href="https://www.graalvm.org/" target="_blank"&gt;GraalVM&lt;/a&gt; {{ site.data.versions.graalvm }} for native compilation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可选择获取&lt;a href="https://www.graalvm.org/" target="_blank"&gt;GraalVM&lt;/a&gt; {{ site.data.version.graalvm }}进行原生编译</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally the xref:cli-tooling.adoc[Quarkus CLI] if you want to use it</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你愿意的话，还可以选择使用xref:cli-tooling.adoc[Quarkus CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, use the `@MongoEntity` annotation to specify the name of the collection, the name of the database or the name of the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以选择使用 `@MongoEntity` 注解来指定集合的名称、数据库的名称或客户端的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or add `quarkus-vertx` into your dependencies manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者手动将 `quarkus-vertx` 添加到依赖项中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or by name using a `Map`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者使用 `Map` ，按名字来命名：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or have the listener’s name be the same as the group id:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者令监听器的名字与消费者组的ID相同：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or in `application.yml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者在 `application.yml` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or just add the following dependency to your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者只需在你的项目中添加以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or start `gdb` with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或这样运行 `gdb` 命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or take a look into the World of Warcraft Auctions - Batch Application. It downloads the World of Warcraft Auction House data and provides statistics about items prices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者看看《魔兽世界》的拍卖 - 批处理应用。它下载魔兽世界拍卖行的数据并提供物品价格的统计数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or using the convenience class `Parameters` either as is or to build a `Map`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者使用方便的类 `Parameters` ，既可以是原样，也可以是建立一个 `Map` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, if you packaged your application as native executable, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，如果你将你的应用打包为原生可执行文件，使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, you can also install the CLI with SDKMAN!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，您也可以用SDKMAN安装CLI！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, you can retrieve the Message&lt;Double&gt;:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，你可以检索Message&lt;Double&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oracle Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Oracle客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other resources should be declared explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其他资源应明确声明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other than method signatures returning a Reactive Stream `Publisher` (`Multi` being an implementation of `Publisher`), outgoing method can also return single message.
In this case the producer will use this method as generator to create an infinite stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了返回Reactive Stream `Publisher` ( `Multi` 实现了 `Publisher` )的方法签名外，发送方法也可以返回单个消息。在这种情况下，生产者将使用该方法作为生成器来创建一个无限的流(infinite stream)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other than method signatures returning a Reactive Stream `Publisher` (`Multi` being an implementation of `Publisher`), outgoing method can also return single message.  In this case the producer will use this method as generator to create an infinite stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了返回Reactive Stream `Publisher` ( `Multi` 实现了 `Publisher` )的方法签名外，发送方法也可以返回单个消息。在这种情况下，生产者将使用该方法作为生成器来创建一个无限的流(infinite stream)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our dependency injection solution is based on CDI. You can use JAX-RS annotations to define the REST endpoints. You can use JPA annotations to map your persistent entities and JTA annotations to declare the transaction boundaries. You can use Eclipse MicroProfile to configure and monitor your application. You can use Vert.x, Apache Camel and we support much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的依赖注入方案是基于CDI的。可以使用JAX-RS注解定义REST端点。您可以使用JPA注解来映射持久实体，使用JTA注解来声明事务边界。可以使用Eclipse MicroProfile配置和监视应用程序。你可以使用Vert.x, Apache Camel，我们还支持更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our monthly newsletters bring together articles, videos and perspectives from across the Quarkus community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的每月通讯汇集了来自整个Quarkus社区的文章、视频和观点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outbound Metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出站元数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outgoing Attributes of the 'smallrye-kafka' connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>'smallrye-kafka' 连接器的传出属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outgoing channel configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传出通道配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outgoing channel configuration (writing to Kafka)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出站 channel 配置(写入Kafka)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overrides the `@Dependent` scope declared on the `@Mock` stereotype.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对 `@Mock` stereotype上声明的 `@Dependent` 范围的覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PEM key format support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持Pem密钥格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package and run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包并运行该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and Running the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包和运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序打包和运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and running in JVM mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包，并在JVM模式下运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and running the application does not change either.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包和运行应用程序也不会改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging of the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序打包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the native executable in a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将原生可执行文件打包到一个容器中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Paging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分页</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Panache allows you to write your MongoDB entities like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache允许你像这样写你的MongoDB实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Panache provides direct support for database locking with your entity/repository, using `findById(Object, LockModeType)` or `find().withLock(LockModeType)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache支持在实体类/Repository类中直接使用数据库的锁，可使用 `findById(Object, LockModeType)` 或 `find().withLock(LockModeType)` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parse and Verify JsonWebToken with JWTParser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用JWTParser解析和验证JsonWebToken</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Path to TLS trusted certificate which may need to be configured if the keys have to be fetched over `HTTPS`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果需要通过 `HTTPS` 获取密钥，则需要配置 TLS 信任证书的路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Path to the claim containing the groups. It starts from the top level JSON object and can contain multiple segments where each segment represents a JSON object name only, example: `realm/groups`. This property can be used if a token has no 'groups' claim but has the groups set in a different claim. Use double quotes with the namespace qualified claims.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到包含组的声明的路径。它从顶级的JSON对象开始，可以包含多个段，每个段只代表一个JSON对象的名称，例如： `realm/groups` 。如果一个标记没有 `groups` 的声明，但在一个不同的声明中设置了组，就可以使用这个属性。在命名空间限定的声明上使用双引号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Path to the claim containing the subject name. It starts from the top level JSON object and can contain multiple segments where each segment represents a JSON object name only, example: `realms/subject`. This property can be used if a token has no 'sub' claim but has the subject set in a different claim. Use double quotes with the namespace qualified claims.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含subject名称的声明的路径。它从顶级的JSON对象开始，可以包含多个段，每个段只代表一个JSON对象名称，例如： `realms/subject` 。如果一个标记没有 `sub` 声明，但在一个不同的声明里设置了subject，则可以使用这个属性。在命名空间限定的声明上使用双引号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Path-specific authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特定路径认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Payload可以被封装在 `org.eclipse.microprofile.reactive.messaging.Message`，以便对写入的记录有更多的控制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Permission paths and http root path</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>权限路径和http根路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Permission sets can also specify paths and methods as a comma separated list. If a path ends with `*` then it is considered
to be a wildcard match and will match all sub paths, otherwise it is an exact match and will only match that specific path:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>权限集也可以用逗号分隔的列表来指定路径和方法。如果一个路径以 `*` 结尾，那么它被认为是通配符匹配，将匹配所有的子路径，否则它是精确匹配，只匹配这个特定路径：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Permission sets can also specify paths and methods as a comma separated list. If a path ends with `*` then it is considered to be a wildcard match and will match all sub paths, otherwise it is an exact match and will only match that specific path:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>权限集也可以用逗号分隔的列表来指定路径和方法。如果一个路径以 `*` 结尾，那么它被认为是通配符匹配，将匹配所有的子路径，否则它是精确匹配，只匹配这个特定路径：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Permissions are defined in config using permission sets. These are arbitrarily named permission grouping. Each permission
set must specify a policy that is used to control access. There are three built-in policies: `deny`, `permit` and `authenticated`,
which respectively permits all, denies all and only allows authenticated users.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>权限是在配置中使用权限集来定义。他们是任意命名的权限分组。每个权限集必须指定一个用于控制访问的策略。有三种内置策略。 `deny` , `permit` 和 `authenticated` ，分别是允许所有、拒绝所有和只允许认证的用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Permissions are defined in config using permission sets. These are arbitrarily named permission grouping. Each permission set must specify a policy that is used to control access. There are three built-in policies: `deny`, `permit` and `authenticated`, which respectively permits all, denies all and only allows authenticated users.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>权限是在配置中使用权限集来定义。他们是任意命名的权限分组。每个权限集必须指定一个用于控制访问的策略。有三种内置策略。 `deny` , `permit` 和 `authenticated` ，分别是允许所有、拒绝所有和只允许认证的用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Permissions can be disabled at build time with an `enabled` property for each declared permission, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>权限可以在构建时通过每个声明权限的 `enabled` 属性来禁用，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persist the entity. It returns a `Uni&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持久化该实体对象。它会返回一个 `Uni&lt;Fruit&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persist the received `fruit` object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持久化接收到的 `fruit` 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persisting Kafka messages with Hibernate Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Hibernate Reactive持久化Kafka消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persisting Kafka messages with Hibernate with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Hibernate与Panache来持久化Kafka消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Picocli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>平台</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please also see the &lt;&lt;add-smallrye-jwt, How to Add SmallRye JWT directly&gt;&gt; section about using `JWTParser` without the `HTTP` support provided by `quarkus-smallrye-jwt`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也请参见 link:#add-smallrye-jwt[如何直接添加SmallRye JWT] 部分，关于在没有 `quarkus-smallrye-jwt` 提供的 `HTTP` 支持的情况下使用 `JWTParser` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please also see the &lt;&lt;integration-testing-keycloak-devservices, Dev Services for Keycloak&gt;&gt; section below about writing the integration tests which depend on `Dev Services for Keycloak`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于编写依赖 `Keycloak开发服务` 的集成测试，也请参见下面的 link:#integration-testing-keycloak-devservices[Keycloak开发服务] 部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please enable `io.quarkus.oidc.runtime.OidcProvider` `TRACE` level logging to see more details about the token verification errors:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请启用 `io.quarkus.oidc.runtime.OidcProvider` `TRACE` 级日志，以查看有关令牌验证错误的更多细节：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please enable `io.quarkus.oidc.runtime.OidcRecorder` `TRACE` level logging to see more details about the OidcProvider client initialization errors:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请启用 `io.quarkus.oidc.runtime.OidcRecorder` `TRACE` 级日志，以查看关于OidcProvider客户端初始化错误的更多细节：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please enable `io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator` `TRACE` level logging to see more details about the token verification or decryption errors:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请启用 `io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator` `TRACE` 级日志，以查看有关令牌验证或解密错误的更多细节：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please experiment with the default cache implementation or register a custom one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请尝试使用默认的缓存实现或注册一个自定义的缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that it's using the `MutinyRedis` class which does asynchronous calls to Redis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，上述代码使用 `MutinyRedis` 类异步调用Redis命令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the Spring support in Quarkus does not start a Spring Application Context nor are any Spring infrastructure classes run.
Spring classes and annotations are only used for reading metadata and / or are used as user code method return types or parameter types.
What that means for end users, is that adding arbitrary Spring libraries will not have any effect. Moreover Spring infrastructure
classes (like `org.springframework.beans.factory.config.BeanPostProcessor` for example) will not be executed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，Quarkus中的Spring支持并不会启动Spring应用上下文，也不会运行任何Spring基础结构类。Spring类和注解仅用于读取元数据和 / 或作为用户代码的方法返回类型或参数类型。对于最终用户来说，这意味着添加任意Spring库都不会对程序有任何影响。此外，Spring基础类（例如 `org.springframework.beans.factory.config.BeanPostProcessor` ）将不会被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the Spring support in Quarkus does not start a Spring Application Context nor are any Spring infrastructure classes run.  Spring classes and annotations are only used for reading metadata and / or are used as user code method return types or parameter types.  What that means for end users, is that adding arbitrary Spring libraries will not have any effect. Moreover Spring infrastructure classes (like `org.springframework.beans.factory.config.BeanPostProcessor` for example) will not be executed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，Quarkus中的Spring支持并不会启动Spring应用上下文，也不会运行任何Spring基础结构类。Spring类和注解仅用于读取元数据和 / 或作为用户代码的方法返回类型或参数类型。对于最终用户来说，这意味着添加任意Spring库都不会对程序有任何影响。此外，Spring基础类（例如 `org.springframework.beans.factory.config.BeanPostProcessor` ）将不会被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.
It is highly recommended to use the floating tag,
so that your builder image remains up-to-date and secure.
If you absolutely must, you may hard-code to a specific tag
(see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags),
but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，上述命令指向的是一个浮动标签。我们强烈建议你使用浮动标签，这样你的构建器镜像就能保持最新和安全。如果你一定要硬编码到一个特定的标签（参见 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[这里] 的可用标签），但要注意，你不会得到安全更新，而且这不被支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.  It is highly recommended to use the floating tag, so that your builder image remains up-to-date and secure.  If you absolutely must, you may hard-code to a specific tag (see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags), but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，上述命令指向的是一个浮动标签。我们强烈建议你使用浮动标签，这样你的构建器镜像就能保持最新和安全。如果你一定要硬编码到一个特定的标签（参见 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[这里] 的可用标签），但要注意，你不会得到安全更新，而且这不被支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please read [CONTRIBUTING.md](https://github.com/quarkusio/quarkusio.github.io/blob/master/CONTRIBUTING.md) for details on our code of conduct, and the process for submitting pull requests to us.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参考 [CONTRIBUTING.md](https://github.com/quarkusio/quarkusio.github.io/blob/master/CONTRIBUTING.md) 关于我们的行为准则的细节，以及提交合并请求给我们的过程。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please read the xref:security-openid-connect-multitenancy.adoc[Using OpenID Connect Multi-Tenancy] guide how to support multiple tenants.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请阅读 xref:security-openid-connect-multitenancy.adoc[使用 OpenID Connect 多租户] ，来了解如何支持多租户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please read the xref:security-openid-connect-web-authentication.adoc[Using OpenID Connect to Protect Web Applications] guide if you need to authenticate and authorize the users using OpenID Connect Authorization Code Flow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要使用OpenID Connect授权码模式(Authorization Code Flow)来对用户进行认证和授权，请阅读 xref:security-openid-connect-web-authentication.adoc[使用OpenID Connect保护Web应用程序] 指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please refer to the appropriate section depending on your context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请根据你的情况，参考适当的章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please report any security issues you find in Quarkus to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请将您在Quarkus中发现的任何安全问题报告给：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see also &lt;&lt;redis-reference.adoc#custom_redis_commands,How to use custom Redis Commands&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参考 &lt;&lt;redis-reference.adoc#custom_redis_commands,如何使用自定义Redis命令&gt;&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:https://download.eclipse.org/microprofile/microprofile-jwt-auth-1.2/microprofile-jwt-auth-spec-1.2.html#_cdi_injection_requirements[MP JWT CDI Injection Requirements] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参阅 link:https://download.eclipse.org/microprofile/microprofile-jwt-auth-1.2/microprofile-jwt-auth-spec-1.2.html#_cdi_injection_requirements[MP JWT CDI注入要求] 以了解更多细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:native-and-ssl#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息请参见 link:native-and-ssl#working-with-containers[我们的使用SSL与原生可执行文件指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see xref:native-and-ssl.adoc#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息请参见 xref:native-and-ssl.adoc#working-with-containers[我们的使用SSL与原生可执行文件指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see xref:security-openid-connect-client-reference.adoc#token-propagation[Token Propagation] section about the Bearer access token propagation to the downstream services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于承载访问令牌向下游服务的传播，请参见 link:security-openid-connect-client.html#token-propagation[令牌] 传播部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see xref:security-openid-connect-client.adoc#token-propagation[Token Propagation] section about the Bearer access token propagation to the downstream services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于不记名(Bearer)访问令牌向下游服务的传播，请参见 link:security-openid-connect-client.html#token-propagation[令牌传播] 部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] for more information about the way it is initialized and configured.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参阅 link:security-openid-connect-dev-services.html[Keycloak开发服务] ，来了解更多关于它的初始化和配置方式的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQL 客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prepare the REST test endpoint, set `application.properties`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>准备好REST测试端点，设置 `application.properties` ，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先决条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites for Mandrel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel先决条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites for Oracle GraalVM CE/EE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Oracle GraalVM CE/EE 的前提条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Principal Class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>主体类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proactive Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>主动认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proactive authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>主动认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Processing Messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Processing quote requests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理报价请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生产者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制作一个原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制作一个原生可执行文件可能会导致一些问题，因此，针对在原生文件中运行的应用程序运行一些测试也是一个好主意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file. The reasoning is explained in the link:getting-started-testing#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制作一个原生可执行文件可能会导致一些问题，因此，建议针对以原生可执行文件运行的应用程序运行一些测试。具体原因在 link:getting-started-testing#quarkus-integration-test[测试指南] 中有详细解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Profiles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatic Approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编程实现方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically decide to set the transaction for rollback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以编程方式决定将该事务设置为回滚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Homepage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目主页</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Loom is coming to the JDK soon and proposes a virtual thread-based model.
The Quarkus architecture is ready to support Loom as soon as it's become globally available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Loom项目很快就会加入到JDK中，它提出了一个基于虚拟线程的模型。一旦在全局范围内可用，Quarkus架构就可以支持Loom。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Loom is coming to the JDK soon and proposes a virtual thread-based model.  The Quarkus architecture is ready to support Loom as soon as it's become globally available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Loom项目很快就会加入到JDK中，它提出了一个基于虚拟线程的模型。一旦在全局范围内可用，Quarkus架构就可以支持Loom。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Reactor converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目 Reactor 转换器在以下依赖项中可用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Projection can be done for both PanacheQL and native queries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对PanacheQL和原生查询都可以进行映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Propagate incoming record key to the outgoing record

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否将传入的记录键添加到传出的记录中

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Propagating Record Key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传播记录键</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Propagators</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Propagators</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties with default values can be configured in a configuration file just like any other property.
However, the default value will be used if the property was not defined in a configuration file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>具有默认值的属性可以像其他属性一样在配置文件中被配置。然而，如果该属性没有在配置文件中被定义，则将使用默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties with default values can be configured in a configuration file just like any other property.  However, the default value will be used if the property was not defined in a configuration file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>具有默认值的属性可以像其他属性一样在配置文件中被配置。然而，如果该属性没有在配置文件中被定义，则将使用默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties with optional values are the middle-ground between standard and properties with default values.
While a missing property in a configuration file will not cause your application to fail, it will nevertheless not have a value set.
We use `java.util.Optional` type to define such properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>具有可选值的属性处于标准属性和具有默认值属性之间的中间地带。尽管在配置文件中缺少一个属性不会导致你的应用程序启动失败，但它还是没有被设置一个值。我们使用 `java.util.Optional` 类型来定义这种属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties with optional values are the middle-ground between standard and properties with default values.  While a missing property in a configuration file will not cause your application to fail, it will nevertheless not have a value set.  We use `java.util.Optional` type to define such properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>具有可选值的属性处于标准属性和具有默认值属性之间的中间地带。尽管在配置文件中缺少一个属性不会导致你的应用程序启动失败，但它还是没有被设置一个值。我们使用 `java.util.Optional` 类型来定义这种属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property Nam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Property Nam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proven Java for the Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>经过验证的云计算Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provide users with initial code for extensions when generating Quarkus applications on code.quarkus.io and all the Quarkus tooling. This guide explains how to create and configure a Codestart for an extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当用户在 code.quarkus.io 和所有Quarkus工具上生成Quarkus应用程序时，为扩展提供初始代码。本指南解释如何为扩展创建和配置Codestart。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provided by JBeret project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由JBeret项目组提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provided by the JBeret Project Team</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由JBeret项目组提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provider Endpoint configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供者端点配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing Redis Hosts Programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以编程方式设定Redis主机</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Public Key Cryptography Standards #8 (PKCS#8) PEM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>公钥密码学标准#8（PKCS#8） PEM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Public Keys may be formatted in any of the following formats, specified in order of
precedence:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>公钥可以采用以下任何一种格式，按优先顺序排列：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Public Keys may be formatted in any of the following formats, specified in order of precedence:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>公钥可以采用以下任何一种格式，按优先顺序排列：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Publications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pull Requests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>合并请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS 2.0 IS HERE!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QUARKUS 2.0来了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS GUIDES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QUARKUS指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Building a Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - 构建一个原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Getting started with Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - 响应式入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Supersonic Subatomic Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - 超音速 亚原子 Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Using our Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - 使用我们的工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 continues the mission of making Java the preferred framework for Kubernetes-native development with new developer tools and improved performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2.0继续致力于通过新的开发工具和改进的性能，使Java成为kubernetes原生开发的首选框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 feature icons</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2.0特征图标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Base Runtime Image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus运行时基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Build Time Principle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus构建时原则</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Chat Options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus聊天选项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Code Snippets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus代码片段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus DI解决方案是基于 [Java的上下文和依赖注入 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) 规范。本指南解释了CDI的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Development</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 开发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Extension Registry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus扩展仓库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Extension for Apache Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Kafka Quarkus扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Extension for Spring Scheduling API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus对SpringSpring Scheduling API 的扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Knative事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus GitHub URL common base prefix.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus GitHub URL的通用基础前缀。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Insights Podcast</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Insights 播客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus JBeret Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus JBeret扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Kafka extension supports
xref:deploying-to-kubernetes.adoc[Service Binding Specification for Kubernetes].
You can enable this by adding the `quarkus-kubernetes-service-binding` extension to your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Kafka扩展支持 link:deploying-to-kubernetes.html[Kubernetes服务绑定规范] 。您可以通过添加 `quarkus-kubernetes-service-binding` 扩展来启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Kafka extension supports xref:deploying-to-kubernetes.adoc[Service Binding Specification for Kubernetes].  You can enable this by adding the `quarkus-kubernetes-service-binding` extension to your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Kafka扩展支持 link:deploying-to-kubernetes.html[Kubernetes服务绑定规范] 。您可以通过添加 `quarkus-kubernetes-service-binding` 扩展来启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Micro Image?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么是Quarkus微镜像？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Micrometer extensions are structured similarly to Micrometer itself: `quarkus-micrometer` provides core
micrometer support and runtime integration and other Quarkus and Quarkiverse extensions bring in additional
dependencies and requirements to support specific monitoring systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Micrometer扩展的结构与Micrometer本身类似： `quarkus-micrometer` 提供核心Micrometer支持和运行时集成，其他Quarkus和Quarkiverse扩展提供额外的依赖和需求，以支持相应的监控系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Micrometer extensions are structured similarly to Micrometer itself: `quarkus-micrometer` provides core micrometer support and runtime integration and other Quarkus and Quarkiverse extensions bring in additional dependencies and requirements to support specific monitoring systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Micrometer扩展的结构与Micrometer本身类似： `quarkus-micrometer` 提供核心Micrometer支持和运行时集成，其他Quarkus和Quarkiverse扩展提供额外的依赖和需求，以支持相应的监控系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Newsletter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 新闻</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus OpenID Connect `quarkus-oidc` extension also supports Bearer Token Authorization and uses `smallrye-jwt` to represent the bearer tokens as `JsonWebToken`, please read the xref:security-openid-connect.adoc[Using OpenID Connect to Protect Service Applications] guide for more information.
OpenID Connect extension has to be used if the Quarkus application needs to authenticate the users using OIDC Authorization Code Flow, please read xref:security-openid-connect-web-authentication.adoc[Using OpenID Connect to Protect Web Applications] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus OpenID Connect `quarkus-oidc` 扩展也支持不记名令牌验证(Bearer Token Authorization)，并使用 `smallrye-jwt` 把不记名令牌(bearer token)呈现为 `JsonWebToken` , 请阅读 link:security-openid-connect.html[使用 OpenID Connect 来保护服务应用程序] 指南来了解更多信息。如果Quarkus应用程序需要使用OIDC授权码模式(Authorization Code Flow)来对用户进行认证，就必须使用OpenID Connect扩展，请阅读《 link:security-openid-connect-web-authentication.html[使用OpenID Connect保护Web应用程序] 》指南了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Reactive Architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus响应式架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security customization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security 定制化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security is a framework that provides the architecture, multiple authentication and authorization mechanisms, and other tools for you to build secure and production-quality Java applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security是一个框架，它提供了架构、多种认证和授权机制以及其他工具，用来为开发者提供构建达到生产级别安全性质量保证的Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security is highly customizable. You can customize the following core security components of Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security是高度可定制的。您可以定制Quarkus的以下核心安全组件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security overview</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus安全概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security provides a RESTEasy Reactive filter that can protect your applications against a https://owasp.org/www-community/attacks/csrf[Cross-Site Request Forgery] attack.
For more information, see xref:security-csrf-prevention.adoc[Cross-Site Request Forgery Prevention].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security提供的RESTEasy Reactive过滤器可以保护您的应用程序免遭 link:https://owasp.org/www-community/attacks/csrf[跨站请求伪造] 攻击。请阅读《 link:security-csrf-prevention.html[跨站请求伪造预防] 指南》以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security provides a RESTEasy Reactive filter that can protect your applications against a https://owasp.org/www-community/attacks/csrf[Cross-Site Request Forgery] attack.  For more information, see xref:security-csrf-prevention.adoc[Cross-Site Request Forgery Prevention].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security提供的RESTEasy Reactive过滤器可以保护您的应用程序免遭 link:https://owasp.org/www-community/attacks/csrf[跨站请求伪造] 攻击。请阅读《 link:security-csrf-prevention.html[跨站请求伪造预防] 指南》以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security 测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security uses `HttpAuthenticationMechanism` to extract the authentication credentials from the HTTP request and delegates them to `IdentityProvider` to convert the credentials to `SecurityIdentity`.
For example, the credentials can come from the `Authorization` header, client HTTPS certificates, or cookies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security使用 `HttpAuthenticationMechanism` 从HTTP请求中提取认证凭证，并委托给 `IdentityProvider` 来完成这些凭证到 `SecurityIdentity` 的转换。例如，凭证可能来自于HTTP `Authorization` 头、客户端HTTPS证书或cookies。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security uses `HttpAuthenticationMechanism` to extract the authentication credentials from the HTTP request and delegates them to `IdentityProvider` to convert the credentials to `SecurityIdentity`.  For example, the credentials can come from the `Authorization` header, client HTTPS certificates, or cookies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security使用 `HttpAuthenticationMechanism` 从HTTP请求中提取认证凭证，并委托给 `IdentityProvider` 来完成这些凭证到 `SecurityIdentity` 的转换。例如，凭证可能来自于HTTP `Authorization` 头、客户端HTTPS证书或cookies。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Tools in your favorite IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你最喜欢的IDE中使用Quarkus工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus URL for git clone referenced by the documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文档所引用的git clone的Quarkus URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus URL to main blob source tree; used for referencing source files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指向主blob源树的Quarkus URL；用于引用源文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus URL to main source archive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指向主源存档的Quarkus URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus URL to main source tree root; used for referencing directories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指向主源树根的Quarkus URL；用于引用目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus URL to set of container images delivered for Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指向提供给Quarkus的容器镜像集的Quarkus URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus URL to the issues page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指向问题页的Quarkus URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Version</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus World Tour</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus世界巡演</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus aids you on your journey to reactive.  Quarkus is based on a &lt;a href="https://quarkus.io/version/main/guides/quarkus-reactive-architecture"&gt;reactive core&lt;/a&gt; allowing your application to mix reactive and imperative components.  As an example, you can implement reactive HTTP endpoint using the &lt;a href="https://quarkus.io/guides/resteasy-reactive"&gt;RESTEasy Reactive extension&lt;/a&gt; as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus可以帮助您实现响应式的旅程。Quarkus基于&lt;a href="https://quarkus.io/version/main/guides/quarkus-reactive-architecture"&gt;响应式核心&lt;/a&gt;，允许您的应用程序混合响应式和指令式组件。例如，您可以使用&lt;a href="https://quarkus.io/guides/resteasy-reactive"&gt;RESTEasy 响应式扩展&lt;/a&gt;实现响应式HTTP端点，具体如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run,
so no additional configuration should be required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus还提供了RestAssured集成用以在测试运行前更新RestAssured使用的默认端口，因而不需要额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run, so no additional configuration should be required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus还提供了RestAssured集成用以在测试运行前更新RestAssured使用的默认端口，因而不需要额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] so, if you prefer JSON-B over Jackson, you can create a project relying on the RESTEasy Reactive JSON-B extension instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus也支持 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] ，因此，如果你喜欢JSON-B而不是Jackson，你可以创建一个依赖RESTEasy Reactive JSON-B扩展的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports role-based access control (RBAC).
For more information about RBAC and other authorization options in Quarkus, see xref:security-authorization.adoc[Security authorization].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus也支持基于角色的访问控制（RBAC）。关于RBAC和Quarkus中其他授权选项的更多信息，请参见 link:security-authorization.html[安全授权] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports role-based access control (RBAC).  For more information about RBAC and other authorization options in Quarkus, see xref:security-authorization.adoc[Security authorization].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus也支持基于角色的访问控制（RBAC）。关于RBAC和Quarkus中其他授权选项的更多信息，请参见 link:security-authorization.html[安全授权] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序被设计为在容器中运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序针对低内存使用和快速启动时间进行了优化。</seg>
      </tuv>
    </tu>
  <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications can access and use the Vert.x APIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序能够访问和使用Vert.x APIs。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus autodetects batch types for incoming channels and sets batch configuration automatically.
You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batch` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自动检测incoming channels 的批处理类型并自动设置批处理配置。您可以用 `mp.messaging.incoming.$channel.batch` 配置批处理模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus autodetects batch types for incoming channels and sets batch configuration automatically.  You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batch` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自动检测incoming channels 的批处理类型并自动设置批处理配置。您可以用 `mp.messaging.incoming.$channel.batch` 配置批处理模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus automatically generates serializers and deserializers for channels where:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下情况下，Quarkus会自动为 channels 生成序列化器和反序列化器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus automatically includes the resources present in `META-INF/resources` (the web resources) but, outside of this directory, you are on your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自动包括存在于 `META-INF/resources` (网络资源）的资源，但是，在这个目录之外，你就得靠自己了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus can compress the produced native executable using UPX.
More details on xref:./upx.adoc[UPX Compression documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus可以使用UPX压缩产生的原生可执行文件。更多细节见 xref:./upx.adoc[UPX压缩文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus can compress the produced native executable using UPX.  More details on xref:./upx.adoc[UPX Compression documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus可以使用UPX压缩产生的原生可执行文件。更多细节见 xref:./upx.adoc[UPX压缩文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带一个事务管理器，并使用它来协调和暴露事务给你的应用程序。每个处理持久性的扩展都会与它集成。而且你将通过CDI明确地与事务进行交互。本指南将指导你完成这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带一个事务管理器，并使用它来协调和暴露事务给你的应用程序。每个处理持久性的扩展都会与它集成。而且你将通过CDI明确地与事务进行交互。本指南将指导你完成这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.  Each extension dealing with persistence will integrate with it for you.  And you will explicitly interact with transactions via CDI.  This guide will walk you through all that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带一个事务管理器，并使用它来协调和暴露事务给你的应用程序。每个处理持久性的扩展都会与它集成。而且你将通过CDI明确地与事务进行交互。本指南将指导你完成这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application. In addition there are plugins and extensions to all major IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个工具链，支持开发人员从实时重新加载一直到部署Kubernetes应用程序。此外，所有主流IDE都有插件和扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.
You can use Maven or Gradle as build tool.
And we offer a CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带的工具链可以在各个开发阶段帮助你。你可以使用Maven或Gradle作为构建工具。我们还提供了一个方便使用的CLI（即将推出）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.  You can use Maven or Gradle as build tool.  And we offer a CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带的工具链可以在各个开发阶段帮助你。你可以使用Maven或Gradle作为构建工具。我们还提供了一个方便使用的CLI（即将推出）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with built-in security to allow for Role-Based Access Control (link:https://en.wikipedia.org/wiki/Role-based_access_control[RBAC])
based on the common security annotations `@RolesAllowed`, `@DenyAll`, `@PermitAll` on REST endpoints and CDI beans.
An example of an endpoint that makes use of both JAX-RS and Common Security annotations to describe and secure its endpoints is given in &lt;&lt;subject-example&gt;&gt;. Quarkus also provides
the `io.quarkus.security.Authenticated` annotation that will permit any authenticated user to access the resource
(equivalent to `@RolesAllowed("**")`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 具有内置的安全性，允许在 REST 节点和 CDI Bean 上使用基于通用安全注解 `@RolesAllowed` , `@DenyAll` , `@PermitAll` 的基于角色的访问控制 link:https://en.wikipedia.org/wiki/Role-based_access_control[（RBAC] ）。在 link:#subject-example[[subject-example]] 中给出了一个同时使用 JAX-RS 和通用安全注解来描述和保护其节点的例子。Quarkus 还提供了 `io.quarkus.security.Authenticated` 注解，它将允许任何经过认证的用户访问该资源（相当于 `@RolesAllowed("**")` ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with built-in security to allow for Role-Based Access Control (link:https://en.wikipedia.org/wiki/Role-based_access_control[RBAC])  based on the common security annotations `@RolesAllowed`, `@DenyAll`, `@PermitAll` on REST endpoints and CDI beans.  An example of an endpoint that makes use of both JAX-RS and Common Security annotations to describe and secure its endpoints is given in &lt;&lt;subject-example&gt;&gt;. Quarkus also provides the `io.quarkus.security.Authenticated` annotation that will permit any authenticated user to access the resource (equivalent to `@RolesAllowed("**")`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 具有内置的安全性，允许在 REST 节点和 CDI Bean 上使用基于通用安全注解 `@RolesAllowed` , `@DenyAll` , `@PermitAll` 的基于角色的访问控制 link:https://en.wikipedia.org/wiki/Role-based_access_control[（RBAC] ）。在 link:#subject-example[[subject-example]] 中给出了一个同时使用 JAX-RS 和通用安全注解来描述和保护其节点的例子。Quarkus 还提供了 `io.quarkus.security.Authenticated` 注解，它将允许任何经过认证的用户访问该资源（相当于 `@RolesAllowed("**")` ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus currently only supports a subset of the functionalities that Spring @Scheduled provides with more features being planned.
Currently, the `fixedDelay` and `fixedDelayString` parameters are not supported, in other words, `@Scheduled` methods are always executed independently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus目前只支持Spring @Scheduled所提供功能的一个子集，更多的功能正在计划当中。目前暂不支持 `fixedDelay` 和 `fixedDelayString` 参数，换句话说， `@Scheduled` 方法总是被独立地执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus currently only supports a subset of the functionalities that Spring @Scheduled provides with more features being planned.  Currently, the `fixedDelay` and `fixedDelayString` parameters are not supported, in other words, `@Scheduled` methods are always executed independently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus目前只支持Spring @Scheduled所提供功能的一个子集，更多的功能正在计划当中。目前暂不支持 `fixedDelay` 和 `fixedDelayString` 参数，换句话说， `@Scheduled` 方法总是被独立地执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does that for you automatically by analyzing the REST methods at build time
and that's why we didn't need any reflection registration in the first part of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过在构建时分析REST方法自动为你执行此操，这就是为什么我们在本指南的第一部分不需要任何反射注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does that for you automatically by analyzing the REST methods at build time and that's why we didn't need any reflection registration in the first part of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过在构建时分析REST方法自动为你执行此操，这就是为什么我们在本指南的第一部分不需要任何反射注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus exposes all Kafka related application properties, prefixed with `kafka.` or `KAFKA_` inside a configuration map with `default-kafka-broker` name.
This configuration is used to establish the connection with the Kafka broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus公开了所有与Kafka相关的应用属性，这些属性使用 `default-kafka-broker` 名称加 `kafka.` 或 `KAFKA_` 的前缀 。这个配置被用来建立与Kafka broker的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus exposes all Kafka related application properties, prefixed with `kafka.` or `KAFKA_` inside a configuration map with `default-kafka-broker` name.  This configuration is used to establish the connection with the Kafka broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus公开了所有与Kafka相关的应用属性，这些属性使用 `default-kafka-broker` 名称加 `kafka.` 或 `KAFKA_` 的前缀 。这个配置被用来建立与Kafka broker的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions optimize your applications by pushing as much work as possible to the build operation. This guide explains the rationale of Quarkus extensions and guides you through authoring your own extensions.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus扩展通过将尽可能多的工作推给构建操作来优化你的应用程序。本指南解释了Quarkus扩展的基本原理，并指导你编写你自己的扩展。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus focuses on the simplest and most useful way to use a given feature, trimming it to its most useful essence. This includes upfront analysis on how to best use a feature and guiding you in what we think is the best way to do things.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus专注于使用给定特性最简单和最有用的方法，将其裁剪到最有用的本质。这包括关于如何最好地使用一个功能的前期分析，以及指导您我们认为最好的做事方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus generates a UUID that changes between two executions (including in dev mode).
So, you are sure no other consumer uses it, and you receive a new unique group id every time your application starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus生成的UUID在两次执行之间会发生变化(包括在dev模式下)。因此，您可以确定没有其他消费者使用它，而且每次您的应用程序启动时都会收到一个新的唯一的组ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus generates a UUID that changes between two executions (including in dev mode).  So, you are sure no other consumer uses it, and you receive a new unique group id every time your application starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus生成的UUID在两次执行之间会发生变化(包括在dev模式下)。因此，您可以确定没有其他消费者使用它，而且每次您的应用程序启动时都会收到一个新的唯一的组ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.
The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use,
Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus对每个网关API都有一个不同的扩展。HTTP网关API是在 `quarkus-amazon-lambda-http` 扩展中实现的。REST网关API是在 `quarkus-amazon-lambda-rest` 扩展中实现的。如果你对使用哪种网关产品感到困惑，亚马逊有一个 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[很好的指南] 来帮助你做这个决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus对每个网关API都有一个不同的扩展。HTTP网关API是在 `quarkus-amazon-lambda-http` 扩展中实现的。REST网关API是在 `quarkus-amazon-lambda-rest` 扩展中实现的。如果你对使用哪种网关产品感到困惑，亚马逊有一个 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[很好的指南] 来帮助你做这个决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has an integrated pluggable web security layer. If security is enabled all HTTP requests will have a permission
check performed to make sure they are allowed to continue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus有一个内置的可插拔的web安全层。如果安全功能被启用，所有的HTTP请求将会进行权限检查，以确保它们被允许继续操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has an integrated pluggable web security layer. If security is enabled all HTTP requests will have a permission check performed to make sure they are allowed to continue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus有一个内置的可插拔的web安全层。如果安全功能被启用，所有的HTTP请求将会进行权限检查，以确保它们被允许继续操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been designed with this new world in mind and provides first-class support for these different paradigms. That does not mean you cannot build monoliths with Quarkus; you can do it smoothly. On the contrary, it means that the Quarkus development model morphs to adapt itself to the type of application you are developing, monolith, microservice, reactive, event-driven, functions…</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的设计考虑到了这个新的世界，并为这些不同的范式提供了一流的支持。这并不意味着你不能用Quarkus建立单体；你可以顺利地做到这一点。反而这意味着Quarkus的开发模型会变化，来适应您正在开发的应用程序的类型，单片机、微服务、响应式、事件驱动、无服务......</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been honored to receive multiple awards and recognition. We feel these are an affirmation of the great work being done by our dedicated community. We’ve started a trophy case to share the kudos with everyone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus有幸获得多个奖项和认可。我们认为这些都是对我们的社区所做的伟大工作的肯定。我们设立了奖杯陈列柜，与大家分享荣誉。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in capabilities to deal with JSON AMQP messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus有内置的功能来处理JSON AMQP消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in capabilities to deal with JSON Kafka messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus有内置的能力来处理JSON格式的Kafka消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in support for JSON serialization and deserialization based on Jackson.
It will also &lt;&lt;serialization-generation, generate&gt;&gt; the serializer and deserializer for you, so you do not have to configure anything.
When generation is disabled, you can use the provided `ObjectMapperSerializer` and `ObjectMapperDeserializer` as explained below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus内置了对基于Jackson的JSON序列化和反序列化的支持。它也会为您 link:#serialization-generation[生成] 序列化器和反序列化器，所以您不需要配置任何东西。当生成器被禁用时，您可以提供 `ObjectMapperSerializer` 和 `ObjectMapperDeserializer` ，如下所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in support for JSON serialization and deserialization based on Jackson.  It will also &lt;&lt;serialization-generation, generate&gt;&gt; the serializer and deserializer for you, so you do not have to configure anything.  When generation is disabled, you can use the provided `ObjectMapperSerializer` and `ObjectMapperDeserializer` as explained below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus内置了对基于Jackson的JSON序列化和反序列化的支持。它也会为您 link:#serialization-generation[生成] 序列化器和反序列化器，所以您不需要配置任何东西。当生成器被禁用时，您可以提供 `ObjectMapperSerializer` 和 `ObjectMapperDeserializer` ，如下所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has more Spring compatibility features. See the following guides for more details:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus拥有更多的Spring兼容特性。获取更多细节请参阅以下指南:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.
As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus在构建时大量使用 link:https://github.com/wildfly/jandex[Jandex] ，以发现各种类或注解。其中一个应用就是可以发现并识别CDI Bean。因此，如果没有在构建时正确设置，大多数Quarkus扩展将无法正常工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus在构建时大量使用 link:https://github.com/wildfly/jandex[Jandex] ，以发现各种类或注解。其中一个应用就是可以发现并识别CDI Bean。因此，如果没有在构建时正确设置，大多数Quarkus扩展将无法正常工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes an extension that allows developers to use Kubernetes ConfigMaps and Secrets as a configuration source, without having to mount them into the Pod running the Quarkus application or make any other modifications to their Kubernetes Deployment (or Openshift DeploymentConfig) &lt;a href="{{site.baseurl}}/guides/kubernetes-config"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus包含一个扩展，允许开发者使用Kubernetes ConfigMaps和Secrets作为配置源，而无需将它们挂载到运行Quarkus应用的Pod中，也无需对Kubernetes的部署(或Openshift DeploymentConfig)进行任何修改。&lt;a href="{{site.baseurl}}/guides/kubernetes-config"&gt;阅读指南了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus information resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus信息资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is a _Reactive_ framework.
Since the beginning, _Reactive_ has been an essential tenet of the Quarkus architecture.
It includes many reactive features and offers a broad ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个 _Reactive_ 框架。 从一开始，_Reactive_ 就一直是Quarkus架构的基本原则。 它包括许多反应式功能，并提供广泛的生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is a _Reactive_ framework.  Since the beginning, _Reactive_ has been an essential tenet of the Quarkus architecture.  It includes many reactive features and offers a broad ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个 _Reactive_ 框架。 从一开始，_Reactive_ 就一直是Quarkus架构的基本原则。 它包括许多反应式功能，并提供广泛的生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License version 2.0&lt;/a&gt;. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and contributors are welcome. Let’s join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个在&lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache许可证2.0版&lt;/a&gt;下许可的开源项目。首先，它是一个开放的社区，在这里，贡献、想法和讨论都是公开进行的，并且欢迎贡献者。让我们携手共建Java应用的未来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个使用https://www.apache.org/licenses/LICENSE-2.0[Apache License 2.0版]授权的开源项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an ecosystem made from many extensions and many libraries (like Eclipse Vert.x, Hibernate, Apache Camel and more), most of them not under the direct responsibility of the Quarkus team. If you find a security bug possibly rooted in one of these libraries, you can either disclose to them directly or disclose them to the Quarkus team (following this process) and we will responsibly disclose the issue to the respective extension or library maintainer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个由许多扩展和许多库组成的生态系统（如Eclipse Vert.x, Hibernate, Apache Camel等），其中大多数都不是由Quarkus团队直接负责的。如果您发现一个安全漏洞可能根植于这些库中的一个，您可以直接向他们披露，也可以向Quarkus团队披露（遵循此过程），我们将负责地向相应的扩展或库维护人员披露问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an open ecosystem and we hope to see all the extensions people need to write their apps. We are working as we speak to allow an extension to be published in separate repos and separate GAVs and thus published in Maven repos independently of Quarkus core. This will greatly simplify the publication process. Expect news soon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个开放的生态系统，我们希望看到人们编写应用程序所需的所有扩展。我们正在工作，正如我们所说，允许一个扩展在单独的repo和单独的GAV中发布，从而在Maven repo中独立于Quarkus核心发布。这将大大简化发布过程，期待很快有新消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is designed to seamlessly combine the familiar imperative style code and the non-blocking, reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的设计是为了在开发应用程序时将熟悉的指令式和非阻塞的响应式代码无缝结合起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is not just about being great for writing Web Applications or Micro-Services. We’re focusing on more than the feature set: we make sure that every feature works well, simply, with little to no configuration, in the most intuitive way possible. It should be trivial to develop simple things, and easy to develop the more complex ones.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus不仅仅是为编写网络应用程序或微服务提供良好的条件。我们关注的不仅仅是功能集：我们要确保每个功能都能很好地工作，简单地工作，几乎不需要配置，以最直观的方式进行。开发简单的东西应该是微不足道的，而开发更复杂的东西应该是容易的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is not limited to HTTP.  You can use &lt;a href="https://quarkus.io/guides/grpc-getting-started"&gt;gRPC&lt;/a&gt; or &lt;a href="https://quarkus.io/guides/smallrye-graphql"&gt;GraphQL&lt;/a&gt;, two prominent alternatives in the microservice space.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus并不局限于HTTP。您可以使用&lt;a href="https://quarkus.io/guides/grpc-getting-started"&gt;gRPC&lt;/a&gt;或&lt;a href="https://quarkus.io/guides/smallrye-graphql"&gt;GraphQL&lt;/a&gt;，这是微服务领域的两个突出的替代方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus发布在Maven Central中，请查看 link:/extensions[扩展]，只需将它们导入到 `pom.xml`中就可以获得Quarkus。我们建议您通过我们的 link:/get-started[入门指南]开始您的Quarkus体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是响应式的。如果您仔细观察，就会发现一个为Quarkus应用程序提供动力的响应式引擎。这个引擎就是Eclipse Vert.x (https://vertx.io)。所有网络I/O都通过非阻塞和响应性的 Vert.x 引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is stable?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus稳定吗?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus lambdas can be deployed using the Amazon Java Runtime, or you can build a native executable and use
Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus lambdas可以使用Amazon Java Runtime进行部署，如果你想要更小的内存占用和更快的冷启动启动时间，你也可以构建一个本地可执行文件，并使用Amazon的Custom Runtime。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus lambdas can be deployed using the Amazon Java Runtime, or you can build a native executable and use Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus lambdas可以使用Amazon Java Runtime进行部署，如果你想要更小的内存占用和更快的冷启动启动时间，你也可以构建一个本地可执行文件，并使用Amazon的Custom Runtime。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus leverages SmallRye Health, an implementation of the MicroProfile Health specification. This allows applications to provide information about their state to external viewers in a Kubernetes environment where automated processes must be able to determine whether the application should be discarded or restarted. &lt;a href="{{site.baseurl}}/guides/microprofile-health"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus利用SmallRye Health，这是MicroProfile Health规范的一个实现。这允许应用程序在Kubernetes环境中向外部查看者提供有关其状态的信息，在这种环境中，自动化流程必须能够确定应用程序是否应该被丢弃或重新启动。 &lt;a href="{site.baseurl}}/guides/microprofile-health"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes it easy to deploy microservice applications to Kubernetes without having to understand the intricacies of the underlying Kubernetes framework. Extensions are available for Kubernetes, and Kubernetes distributions, to facilitate this process with only a minimal amount of configuration variables needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus使得在Kubernetes上部署微服务应用变得容易，而不需要了解Kubernetes底层框架的复杂性。Kubernetes和Kubernetes发行版都有相应的扩展，以促进这个过程，只需要最小的配置变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes registration of reflection in an extension a breeze by using `ReflectiveClassBuildItem`, thus eliminating the need for a JSON configuration file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过使用 `ReflectiveClassBuildItem` ，使得在扩展中注册反射变得轻而易举，从而消除了对JSON配置文件的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now has extensions for DynamoDB, S3, SNS and SQS (more coming).
Please check link:{amazon-services-guide}[those guides] on how to use the various AWS Services with Quarkus, as opposed to wiring manually like below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus现在有DynamoDB、S3、SNS和SQS的扩展（还会有更多）。请查看 link:{amazon-services-guide}[那些指南] 关于如何使用带有Quarkus的各种AWS服务 ，而不是像下面这样手动连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now has extensions for DynamoDB, S3, SNS and SQS (more coming).  Please check link:{amazon-services-guide}[those guides] on how to use the various AWS Services with Quarkus, as opposed to wiring manually like below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus现在有DynamoDB、S3、SNS和SQS的扩展（还会有更多）。请查看 link:{amazon-services-guide}[那些指南] 关于如何使用带有Quarkus的各种AWS服务 ，而不是像下面这样手动连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers the possibility to use YAML in addition to the standard Java Properties file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了标准的 Java Properties 文件之外，Quarkus 还提供了使用 YAML 的能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers unequaled performance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了无与伦比的性能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus only implements a subset of the CDI features and comes with non-standard features and specific APIS, you can learn more about it in the xref:cdi-reference.adoc[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus只实现了CDI功能的一个子集，并且带有非标准的功能和特定的APIS，你可以在 link:cdi-reference.html[Contexts和依赖注入指南] 中了解更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus performs some magic when it is capable of inferring the serialized types from the REST methods.
When you have the following REST method, Quarkus determines that `Fruit` will be serialized:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Quarkus能够从REST方法中推断出序列化的类型时，它会发挥一些作用。当你有以下的REST方法时，Quarkus确定 `Fruit` 将被序列化：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus performs some magic when it is capable of inferring the serialized types from the REST methods.  When you have the following REST method, Quarkus determines that `Fruit` will be serialized:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Quarkus能够从REST方法中推断出序列化的类型时，它会发挥一些作用。当你有以下的REST方法时，Quarkus确定 `Fruit` 将被序列化：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of hundreds of best-of-breed libraries that you love and use. All wired on a standard backbone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个内聚的、使用起来有趣的全栈框架，它利用了您所喜爱和使用的数百个最佳组合库，都将其连接在一个标准主干上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of over fifty best-of-breed libraries that you love and use. All wired on a standard backbone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个有凝聚力的、有趣的、全栈式的框架，它利用了各类不断增长的50多个你喜欢和使用的最好的库。所有这些都在一个标准的主干上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a compatibility layer for Spring Cloud Config in the form of the spring-cloud-config-client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus以spring-cloud-config-client扩展的形式为Spring Cloud Config提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a distroless base image that you can use in your `Dockerfile`.
You only need to copy your application, and you are done:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个无发行版的基础镜像，可以用于你的 `Dockerfile` 。你只需要复制你的应用程序，就可以了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a distroless base image that you can use in your `Dockerfile`.  You only need to copy your application, and you are done:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个无发行版的基础镜像，可以用于你的 `Dockerfile` 。你只需要复制你的应用程序，就可以了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` which starts a mock Kubernetes API server),
but it is common to create custom implementations to address specific application needs.
Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[here]),
or starting a mock HTTP server using https://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here]).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一些开箱即用的 `QuarkusTestResourceLifecycleManager` （见 `io.quarkus.test.h2.H2DatabaseTestResource` ，它启动了一个H2数据库；或 `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` ，它启动了一个模拟的Kubernetes API服务器），但创建自定义的实现来满足特定的应用需求也是很常见的。常见的情况包括使用 link:https://www.testcontainers.org/[Testcontainers] 启动docker容器（例子 link:https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[见这里] ），或使用 link:http://wiremock.org/[Wiremock] 启动一个模拟的HTTP服务器（例子 link:https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[见这里] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[here]), or starting a mock HTTP server using https://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here]).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一些开箱即用的 `QuarkusTestResourceLifecycleManager` （见 `io.quarkus.test.h2.H2DatabaseTestResource` ，它启动了一个H2数据库；或 `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` ，它启动了一个模拟的Kubernetes API服务器），但创建自定义的实现来满足特定的应用需求也是很常见的。常见的情况包括使用 link:https://www.testcontainers.org/[Testcontainers] 启动docker容器（例子 link:https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[见这里] ），或使用 link:http://wiremock.org/[Wiremock] 启动一个模拟的HTTP服务器（例子 link:https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[见这里] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides comprehensive HashiCorp Vault support.
For more information, see the link:{vault-guide}[Quarkus and HashiCorp Vault] documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了非常全面的HashiCorp Vault支持，请参见 link:{vault-guide}[Quarkus和HashiCorp Vault] 文档以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides comprehensive HashiCorp Vault support.  For more information, see the link:{vault-guide}[Quarkus and HashiCorp Vault] documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了非常全面的HashiCorp Vault支持，请参见 link:{vault-guide}[Quarkus和HashiCorp Vault] 文档以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides developers the tools and capabilities to troubleshoot distributed microservices applications in Kubernetes including tracing and debugging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为开发者提供了工具和能力，以解决Kubernetes中分布式微服务应用程序的故障，包括跟踪和调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Flyway as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将会介绍Quarkus为使用Flyway提供了哪些一流的支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Kotlin as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为使用Kotlin提供了一流的支持，本指南将对此进行讲解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus使用Mutiny模型提供了许多响应式API。在本节中，我们将看到如何使用响应式PostgreSQL驱动程序以一种非阻塞和响应式的方式与数据库交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides mutual TLS (mTLS) authentication so that you can authenticate users based on their X.509 certificates.
For more information, see xref:security-built-in-authentication.adoc#mutual-tls[mutual TLS authentication].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了TLS互认证，这样您就可以根据用户的X.509证书进行认证。更多信息请参见 link:security-built-in-authentication.html#mutual-tls[TLS互认证] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides mutual TLS (mTLS) authentication so that you can authenticate users based on their X.509 certificates.  For more information, see xref:security-built-in-authentication.adoc#mutual-tls[mutual TLS authentication].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了TLS互认证，这样您就可以根据用户的X.509证书进行认证。更多信息请参见 link:security-built-in-authentication.html#mutual-tls[TLS互认证] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides other ways to serve static files. This is an example made for the guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了其他方式来处理静态文件。这是专为该指南制作的一个例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides several health checks for Kafka.
These checks are used in combination with the `quarkus-smallrye-health` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为Kafka提供了几种健康检查方式。这些方式需要与 `quarkus-smallrye-health` 扩展结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为Kafka提供了几种健康检查方式。这些方式需要与 `quarkus-smallrye-health` 扩展结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for Apache Kafka through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.
Based on Eclipse MicroProfile Reactive Messaging specification 2.0, it proposes a flexible programming model bridging CDI and event-driven.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过 link:https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] 框架为Apache Kafka提供支持。基于Eclipse MicroProfile Reactive Messaging 2.0 规范，框架提供了一种灵活的基于CDI和事件驱动的编程模型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for Apache Kafka through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.  Based on Eclipse MicroProfile Reactive Messaging specification 2.0, it proposes a flexible programming model bridging CDI and event-driven.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过 link:https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] 框架为Apache Kafka提供支持。基于Eclipse MicroProfile Reactive Messaging 2.0 规范，框架提供了一种灵活的基于CDI和事件驱动的编程模型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for live reloading changes made to source code. This support is also available to Kotlin, meaning that developers can update their Kotlin source
code and immediately see their changes reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了对源代码的实时重载修改的支持。这种支持也适用于Kotlin，这意味着开发者可以更新他们的Kotlin源代码，并立即看到代码更改带来的反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for live reloading changes made to source code. This support is also available to Kotlin, meaning that developers can update their Kotlin source code and immediately see their changes reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了对源代码的实时重载修改的支持。这种支持也适用于Kotlin，这意味着开发者可以更新他们的Kotlin源代码，并立即看到代码更改带来的反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides the `quay.io/quarkus/quarkus-distroless-image:1.0` image.
It contains the required packages to run a native executable and is only **9Mb**.
Just add your application on top of this image, and you will get a tiny container image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了 `quay.io/quarkus/quarkus-distroless-image:1.0` 镜像。它包含了运行原生可执行文件所需的软件包，并且只有 *9Mb* 。只要在这个镜像上添加你的应用程序，你就会得到一个很小的容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides the `quay.io/quarkus/quarkus-distroless-image:1.0` image.  It contains the required packages to run a native executable and is only **9Mb**.  Just add your application on top of this image, and you will get a tiny container image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了 `quay.io/quarkus/quarkus-distroless-image:1.0` 镜像。它包含了运行原生可执行文件所需的软件包，并且只有 *9Mb* 。只要在这个镜像上添加你的应用程序，你就会得到一个很小的容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides the ability to limit test execution to tests with specific  `@TestProfile` annotations.
This works by leveraging the `tags` method of `QuarkusTestProfile` in conjunction with the `quarkus.test.profile.tags` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了将测试限制在具有特定 `@TestProfile` 注释的测试中执行的能力。这是通过联合利用 `QuarkusTestProfile` 的 `tags` 方法和 `quarkus.test.profile.tags` 系统属性来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides the ability to limit test execution to tests with specific `@TestProfile` annotations.  This works by leveraging the `tags` method of `QuarkusTestProfile` in conjunction with the `quarkus.test.profile.tags` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了将测试限制在具有特定 `@TestProfile` 注释的测试中执行的能力。这是通过联合利用 `QuarkusTestProfile` 的 `tags` 方法和 `quarkus.test.profile.tags` 系统属性来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides various configuration knobs under the `quarkus.spring-cloud-config` root. For the purposes of this guide, our Quarkus application is going to be configured in `application.properties` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus在 `quarkus.spring-cloud-config` 根路径下提供了多种配置选项。就该指南而言，我们的Quarkus应用程序将在 `application.properties` 中配置以下内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus should automatically discover this implementation and use it instead of the default implementation
discussed earlier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应该自动发现这个实现并使用它，而不是前面讨论的默认实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应该自动发现这个实现并使用它，而不是前面讨论的默认实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus simplifies things by allowing extensions authors to simply register a `RuntimeInitializedClassBuildItem`. A simple example of doing so could be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过允许扩展作者简单地注册一个 `RuntimeInitializedClassBuildItem` 来简化操作。这样做的一个简单例子是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus specific configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的特定配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus starts a AMQP broker automatically, configures the application and shares the broker instance between different applications.
See xref:amqp-dev-services.adoc[Dev Services for AMQP] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus会自动启动一个AMQP代理，配置应用程序，并在不同的应用程序之间共享代理实例。要了解更多的细节，请参阅 xref:amqp-dev-services.adoc[AMQP的开发服务] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus starts a AMQP broker automatically, configures the application and shares the broker instance between different applications.  See xref:amqp-dev-services.adoc[Dev Services for AMQP] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus会自动启动一个AMQP代理，配置应用程序，并在不同的应用程序之间共享代理实例。要了解更多的细节，请参阅 xref:amqp-dev-services.adoc[AMQP的开发服务] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports Continuous testing, but this is covered by the xref:continuous-testing.adoc[Continuous Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持持续测试，但这是 link:continuous-testing.html[持续测试指南] 所讨论的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports a feature called Dev Services that allows you to create various datasources without any config.
What that means practically, is that if you have docker running and have not configured `quarkus.redis.hosts`,
Quarkus will automatically start a Redis container when running tests or dev-mode, and automatically configure the connection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持一项叫做Dev Services的功能，籍此，无需进行任何配置即可创建各种数据源。这意味着，如果你运行着docker服务，但没有配置 `quarkus.redis.hosts` ，Quarkus会在运行测试或dev模式时自动启动一个Redis容器，并自动配置连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports a feature called Dev Services that allows you to create various datasources without any config.  What that means practically, is that if you have docker running and have not configured `quarkus.redis.hosts`, Quarkus will automatically start a Redis container when running tests or dev-mode, and automatically configure the connection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持一项叫做Dev Services的功能，籍此，无需进行任何配置即可创建各种数据源。这意味着，如果你运行着docker服务，但没有配置 `quarkus.redis.hosts` ，Quarkus会在运行测试或dev模式时自动启动一个Redis容器，并自动配置连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports a feature called Dev Services that allows you to create various datasources without any config. In the case of MongoDB this support extends to the default MongoDB connection.
What that means practically, is that if you have not configured `quarkus.mongodb.connection-string` Quarkus will automatically start a MongoDB container when running tests or dev-mode,
and automatically configure the connection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持一种叫做Dev Services的功能，它允许你在没有任何配置的情况下创建各种数据源。在MongoDB的情况下，这种支持延伸到默认的MongoDB连接。也就是说，如果你没有配置 `quarkus.mongodb.connection-string` ，Quarkus会在运行测试或开发模式时自动启动一个MongoDB容器，并自动配置连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports a feature called Dev Services that allows you to create various datasources without any config. In the case of MongoDB this support extends to the default MongoDB connection.  What that means practically, is that if you have not configured `quarkus.mongodb.connection-string` Quarkus will automatically start a MongoDB container when running tests or dev-mode, and automatically configure the connection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持一种叫做Dev Services的功能，它允许你在没有任何配置的情况下创建各种数据源。在MongoDB的情况下，这种支持延伸到默认的MongoDB连接。也就是说，如果你没有配置 `quarkus.mongodb.connection-string` ，Quarkus会在运行测试或开发模式时自动启动一个MongoDB容器，并自动配置连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports both the  `yml` and `yaml` file extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus同时支持 `yml` 和 `yaml` 文件扩展名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports both the `yml` and `yaml` file extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus同时支持 `yml` 和 `yaml` 文件扩展名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[JUnit 5] tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持 link:https://junit.org/junit5/[JUnit 5] 测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports multiple authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持多种认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to
mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持使用两种不同的方法来mock对象。您可以使用CDI alternatives来mock出所有测试类的Bean，也可以使用 `QuarkusMock` 来mock出每个测试类的Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持使用两种不同的方法来mock对象。您可以使用CDI alternatives来mock出所有测试类的Bean，也可以使用 `QuarkusMock` 来mock出每个测试类的Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of property expressions in the `application.properties` file so to externalize the configuration of the tasks you should store the properties in the `application.properties` file and use the
`fixedRateString`, `initialDelayString` params respectively.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持在 `application.properties` 文件中使用属性表达式，因此为了使任务的配置外部化，你应该在 `application.properties` 文件中，分别使用 `fixedRateString` , `initialDelayString` 参数存储属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of property expressions in the `application.properties` file so to externalize the configuration of the tasks you should store the properties in the `application.properties` file and use the `fixedRateString`, `initialDelayString` params respectively.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持在 `application.properties` 文件中使用属性表达式，因此为了使任务的配置外部化，你应该在 `application.properties` 文件中，分别使用 `fixedRateString` , `initialDelayString` 参数存储属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in
Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting
service directly without using HTTP:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持这种方式。它允许使用 `@Inject` 注解来将CDI Bean注入您的测试中（事实上，Quarkus中的测试是完整的CDI Bean，所以您可以使用所有的CDI功能）。让我们创建一个简单的测试，直接测试greeting服务，而非使用HTTP：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting service directly without using HTTP:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持这种方式。它允许使用 `@Inject` 注解来将CDI Bean注入您的测试中（事实上，Quarkus中的测试是完整的CDI Bean，所以您可以使用所有的CDI功能）。让我们创建一个简单的测试，直接测试greeting服务，而非使用HTTP：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus tailors your application for GraalVM and HotSpot. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes. We use a technique we call compile time boot.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为GraalVM和HotSpot定制你的应用程序。令人惊讶的快速启动时间，令人难以置信的低RSS内存（不仅仅是堆的大小！），在Kubernetes等容器协调平台中提供近乎即时的扩展和高密度的内存利用。我们使用一种我们称之为编译时启动的技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus takes care of registering the `CodecProvider` for you as a CDI bean of `@Singleton` scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus负责为你注册 `CodecProvider` ，作为 `@Singleton` 范围的CDI bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus utilizes &lt;a href="https://opentracing.io/" target="_blank"&gt;OpenTracing&lt;/a&gt; which is a vendor-agnostic API to help developers easily instrument tracing into their codebase. Distributed tracing helps pinpoint where failures occur and what causes poor performance. &lt;a href="{{site.baseurl}}/guides/opentracing"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 利用&lt;a href="https://opentracing.io/" target="_blank"&gt;OpenTracing&lt;/a&gt;，这是一个与供应商无关的 API，可帮助开发人员轻松地将跟踪功能纳入其代码库。分布式跟踪有助于确定故障发生的位置以及导致性能不佳的原因。 &lt;a href="{{site.baseurl}}/guides/opentracing"&gt;阅读该指南以了解更多详情&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus utilizes the &lt;a href="https://micrometer.io/" target="_blank"&gt;Micrometer&lt;/a&gt; metrics library for runtime and application metrics. It provides a simple facade for the most popular monitoring systems to instrument your JVM-based application code without vendor lock-in. Application-specific and built-in metrics can be exposed using Micrometer. &lt;a href="{{site.baseurl}}/guides/micrometer#support-for-the-microprofile-metrics-api"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus利用&lt;a href="https://micrometer.io/" target="_blank"&gt;Micrometer&lt;/a&gt;度量库来实现运行时和应用程序的度量。它为最流行的监控系统提供了一个简单的接口，以便在不锁定供应商的情况下对基于JVM的应用程序代码进行检测。&lt;a href="{{site.baseurl}}/guides/micrometer#support-for-the-microprofile-metrics-api"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was built from the ground up for Kubernetes making it easy to deploy applications without having to understand all of the complexities of the platform. Quarkus allows developers to automatically generate Kubernetes resources including building and deploying container images without having to manually create YAML files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是为Kubernetes建立的，使其能够轻松部署应用程序，而无需了解该平台的所有复杂性。Quarkus允许开发者自动生成Kubernetes资源，包括构建和部署容器镜像，而无需手动创建YAML文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was created to enable Java developers to create applications for a modern, cloud-native world. Quarkus is a Kubernetes-native Java framework tailored for GraalVM and HotSpot, crafted from best-of-breed Java libraries and standards. The goal is to make Java the leading platform in Kubernetes and serverless environments while offering developers a framework to address a wider range of distributed application architectures.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的创建是为了使Java开发人员能够为现代的、云原生的世界创建应用程序。Quarkus是一个为GraalVM和HotSpot定制的Kubernetes原生Java框架，由最佳的Java库和标准精心打造。其目标是使Java成为Kubernetes和无服务器环境的领先平台，同时为开发者提供一个框架，以解决更广泛的分布式应用架构问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus will automatically register all the classes annotated with `@BsonDiscriminator` with the POJO codec.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 将使用 POJO codec自动注册所有使用 `@BsonDiscriminator` 的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus's Collaborative Community Forum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的合作社区论坛</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus's integration with lambdas also supports Quarkus's Live Coding development cycle.  You an
bring up your Quarkus lambda project in dev or test mode and code on your project live.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus与lambdas的集成也支持Quarkus的Live Coding开发周期。你可以在开发或测试模式下启动你的Quarkus lambda项目，并在项目中实时编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus.io Website Based on Jekyll</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus.io网站基于Jekyll</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query debugging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询调试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query parameters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询参数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query projection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询映射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询映射可以使用 `find()` 方法返回的 `PanacheQuery` 对象上的 `project(Class)` 方法来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickly Bootstrap Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>快速引导您的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickstart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>快速入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickstarts URL common base prefix.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quickstarts URL 通用基础前缀。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickstarts URL for git clone referenced by the documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文档所引用的git clone的Quickstarts URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickstarts URL to main blob source tree; used for referencing source files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指向主blob源树的Quickstarts URL；用于引用源文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickstarts URL to main source archive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指向主源存档的Quickstarts URL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickstarts URL to main source tree root; used for referencing directories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指向主源树根的Quickstarts URL；用于引用目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid
the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice
to install as little software as possible).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很多时候，人们只需要为他们的Quarkus应用程序创建一个原生Linux可执行文件（例如，为了在容器化环境中运行），并希望避免安装适当的GraalVM版本来完成这项麻烦任务（例如，在CI环境中，通常的做法是尽可能少地安装软件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice to install as little software as possible).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很多时候，人们只需要为他们的Quarkus应用程序创建一个原生Linux可执行文件（例如，为了在容器化环境中运行），并希望避免安装适当的GraalVM版本来完成这项麻烦任务（例如，在CI环境中，通常的做法是尽可能少地安装软件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qute Reference Guide</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Qute 参考指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Endpoint V1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST Endpoint V1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Endpoint V2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST Endpoint V2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST `quarkus-amazon-lambda-rest` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive and its Jackson support to handle JSON payloads</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive和其Jackson支持来处理JSON有效载荷</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is naturally integrated with Mutiny.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive与Mutiny集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive to serve HTTP requests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive为HTTP请求提供服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTassured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTassured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RSA Private Key PEM Content</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RSA私钥PEM格式的内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RSA Public Key PEM Content</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RSA公钥PEM格式内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RabbitMQ Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RabbitMQ客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RabbitMQ Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RabbitMQ 开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RabbitMQ Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RabbitMQ参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Re-augment a Quarkus Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重新增强Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive API for Hibernate ORM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM的响应式API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Entities and Repositories</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式实体和存储库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive JAX-RS resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式 JAX-RS 资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging AMQP 1.0 Connector Reference Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息AMQP 1.0连接器参考文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging _startup_ and _readiness_ checks offer two strategies.
The default strategy verifies that an active connection is established with the broker.
This approach is not intrusive as it's based on built-in Kafka client metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息传递的 _启动_ 和 _就绪_ 检查提供了两种策略。默认策略是确认是否与broker建立了活动连接。这种方法不具有侵入性，因为它基于内置的Kafka客户端指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging _startup_ and _readiness_ checks offer two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in Kafka client metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息传递的 _启动_ 和 _就绪_ 检查提供了两种策略。默认策略是确认是否与broker建立了活动连接。这种方法不具有侵入性，因为它基于内置的Kafka客户端指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging invokes user's methods on an I/O thread.
Thus, by default, the methods must not block.
As described in &lt;&lt;blocking-processing&gt;&gt;, you need to add the `@Blocking` annotation on the method if this method will block the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式流会在I/O线程上调用用户的方法。因此在默认情况下，这些方法不能阻塞。正如 link:#blocking-processing[[阻塞处理]] 中所述，如果这个方法会阻塞调用者线程，那么您需要在方法上添加 `@Blocking` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging invokes user's methods on an I/O thread.  Thus, by default, the methods must not block.  As described in &lt;&lt;blocking-processing&gt;&gt;, you need to add the `@Blocking` annotation on the method if this method will block the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式流会在I/O线程上调用用户的方法。因此在默认情况下，这些方法不能阻塞。正如 link:#blocking-processing[[阻塞处理]] 中所述，如果这个方法会阻塞调用者线程，那么您需要在方法上添加 `@Blocking` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging invokes your method on an I/O thread.
See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.
But, you often need to combine Reactive Messaging with blocking processing such as database interactions.
For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Messaging会在一个I/O线程中调用您的方法。关于这个话题的更多细节，请看  xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation]  。但是您可能需要经常将Reactive Messaging 与阻塞式处理相结合使用，比如与数据库通信。为此，您需要使用 `@Blocking` 注解来表该明处理是 _阻塞的_ ，并且不在调用者线程中运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging invokes your method on an I/O thread.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.  But, you often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息在一个I/O线程上调用你的方法。关于这个话题的更多详情，请参阅 link:quarkus-reactive-architecture.html[Quarkus响应式架构文档] 。但是，你经常需要将响应式消息与阻塞处理结合起来，比如数据库交互。为此，你需要使用 `@Blocking` 注释，来表示处理是 _blocking_ ，不应该在调用者线程上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive MongoDB Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式MongoDB客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Panache Entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式Panache实体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式SQL客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive developers may wonder why we can't return a stream of fruits directly.
It tends to be a bad idea when dealing with a database.
Relational databases do not handle streaming well.
It’s a problem of protocols not designed for this use case.
So, to stream rows from the database, you need to keep a connection (and sometimes a transaction) open until all the rows are consumed.
If you have slow consumers, you break the golden rule of databases: don’t hold connections for too long.
Indeed, the number of connections is rather low, and having consumers keeping them for too long will dramatically reduce the concurrency of your application.
So, when possible, use a `Uni&lt;List&lt;T&gt;&gt;` and load the content.
If you have a large set of results, implement pagination.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式程序开发者可能会想为什么我们不能直接返回水果流。在处理数据库时，这往往不是一个好主意。关系数据库不能很好地处理流。这是协议不是为这个用例设计的问题。因此，要从数据库流输出行，您需要保持一个连接（有时是一个事务）打开，直到所有行都被消耗掉。如果您的用户很慢，那么您就违反了数据库的黄金法则：不要保持连接太长时间。实际上，可用连接的数量相当少，并且让使用者保持这些连接太长时间将极大地降低应用程序的并发性。所以，如果可能的话，使用 `Uni&lt;List&lt;T&gt;&gt;` 并加载内容。如果有大量结果，则实现分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive developers may wonder why we can't return a stream of fruits directly.  It tends to be a bad idea when dealing with a database.  Relational databases do not handle streaming well.  It’s a problem of protocols not designed for this use case.  So, to stream rows from the database, you need to keep a connection (and sometimes a transaction) open until all the rows are consumed.  If you have slow consumers, you break the golden rule of databases: don’t hold connections for too long.  Indeed, the number of connections is rather low, and having consumers keeping them for too long will dramatically reduce the concurrency of your application.  So, when possible, use a `Uni&lt;List&lt;T&gt;&gt;` and load the content.  If you have a large set of results, implement pagination.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式程序开发者可能会想为什么我们不能直接返回水果流。在处理数据库时，这往往不是一个好主意。关系数据库不能很好地处理流。这是协议不是为这个用例设计的问题。因此，要从数据库流输出行，您需要保持一个连接（有时是一个事务）打开，直到所有行都被消耗掉。如果您的用户很慢，那么您就违反了数据库的黄金法则：不要保持连接太长时间。实际上，可用连接的数量相当少，并且让使用者保持这些连接太长时间将极大地降低应用程序的并发性。所以，如果可能的话，使用 `Uni&lt;List&lt;T&gt;&gt;` 并加载内容。如果有大量结果，则实现分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应性扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read about the community plans for the future. Here is &lt;a href="https://github.com/orgs/quarkusio/projects/5"&gt;our current roadmap&lt;/a&gt;. This is driven by the community, come and tell us what &lt;i&gt;your&lt;/i&gt; needs are.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>阅读有关社区未来的计划。这里是&lt;a href="https://github.com/orgs/quarkusio/projects/5"&gt;我们目前的路线图&lt;/a&gt;。这是由社区推动的，来告诉我们&lt;i&gt;你&lt;/i&gt;的需求是什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read only deployment environments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>只读部署环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read the xref:opentracing.adoc[OpenTracing] guide, for how to configure OpenTracing and how to use the Jaeger tracer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>阅读 link:opentracing.html[OpenTracing] 指南，了解如何配置OpenTracing以及如何使用Jaeger追踪器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading a file and storing the content in memory works for small files, but not big ones.
In this section, we will see how you can use Vert.x streaming capability.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>读取文件并将内容存储在内存中适用于小文件，但不适用于大文件。在本节中，我们将带领你了解如何使用 Vert.x 流功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading a file and storing the content in memory works for small files, but not big ones.  In this section, we will see how you can use Vert.x streaming capability.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>读取文件并将内容存储在内存中适用于小文件，但不适用于大文件。在本节中，我们将带领你了解如何使用 Vert.x 流功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading properties from Spring Cloud Config Server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 Spring Cloud 配置服务器中读取配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Recap of HTTP based Testing in JVM mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对JVM模式中基于HTTP的测试的回顾</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receive the messages sent to the `greeting` address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收发送到 `greeting` 地址的信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receives the Vert.x instance as a constructor parameter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收Vert.x实例作为构造函数的参数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receiving AMQP messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收AMQP消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receiving Cloud Events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收云事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receiving Kafka Records in Batches</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批量接收Kafka记录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receiving messages from Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收来自Kafka的消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receiving quotes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收报价</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reciprocally, multiple producers on the same channel can be merged by setting `mp.messaging.incoming.$channel.merge=true`.
On the `@Incoming` methods, you can control how multiple channels are merged using the `@Merge` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相应地，同一 channel 上的多个生产者可以通过设置 `mp.messaging.incoming.$channel.merge=true` 来进行合并。在 `@Incoming` 方法上，您可以使用 `@Merge` 来控制多个 channels 的合并方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reciprocally, multiple producers on the same channel can be merged by setting `mp.messaging.incoming.$channel.merge=true`.  On the `@Incoming` methods, you can control how multiple channels are merged using the `@Merge` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相应地，同一 channel 上的多个生产者可以通过设置 `mp.messaging.incoming.$channel.merge=true` 来进行合并。在 `@Incoming` 方法上，您可以使用 `@Merge` 来控制多个 channels 的合并方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Recommended GraalVM version to use.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>推荐使用的GraalVM版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Red Hat Build of Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>红帽的Quarkus构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Red Hat OpenShift Streams for Apache Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>红帽OpenShift Streams for Apache Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redis Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redis Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redis Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redpanda is a Kafka compatible event streaming platform.
Because it provides a faster startup time dev services defaults to `vectorized/redpanda` images.
You can select any version from https://hub.docker.com/r/vectorized/redpanda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redpanda是一个兼容Kafka的事件流平台。因为它在dev服务默的 `vectorized/redpanda` 镜像中提供了更快的启动时间。您可以从 https://hub.docker.com/r/vectorized/redpanda  中选择任何版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reduction in Reflection Usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>减少反射的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference Guide</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>参考指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference guide for SmallRye Reactive Messaging and AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye响应式消息传递和AMQP的参考指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference guide for SmallRye Reactive Messaging and RabbitMQ.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye响应式消息传递和RabbitMQ的参考指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>References</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>参考文献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Refreshing `JsonWebKey` set for verifying JWT tokens</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>刷新 `JsonWebKey` 集以验证JWT tokens</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>登记反射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register the output of the step executing `./mvnw ...` command (i.e. directory `target/native-image`) as a build artifact,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将执行 `./mvnw …​` 命令的步骤的输出（即目录 `target/native-image` ）注册为构建工件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register the output of the step executing the `native-image ...` command (i.e. files matching `target/*runner`) as build artifact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将执行 `native-image …​` 命令的步骤的输出（即匹配 `target/*runner` 的文件）注册为构建工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering for reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>登记反射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Relax the validation of the verification keys, setting this property to `true` will allow public RSA keys with the length less than 2048 bit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>放宽密钥验证，将此属性设置为 `true` ，将允许长度小于2048比特的公共RSA密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Releasing your Quarkus applications with JReleaser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用JReleaser发布你的Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, at the beginning of the guide,  we added the `smallrye-mutiny-vertx-web-client` dependency to our `pom.xml` file.
It's now time to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请记住，在本指南的开头，我们将 `smallrye-mutiny-vertx-web-client` 作为依赖项添加到了我们的 pom.xml 文件中。现在，是时候使用它了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, at the beginning of the guide, we added the `smallrye-mutiny-vertx-web-client` dependency to our `pom.xml` file.  It's now time to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请记住，在本指南的开头，我们将 `smallrye-mutiny-vertx-web-client` 作为依赖项添加到了我们的 pom.xml 文件中。现在，是时候使用它了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote Development</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>远程开发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the `src/main/resources/application.properties` and create a `src/main/resources/application.yaml` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>删除 `src/main/resources/application.properties` ，并创建一个 `src/main/resources/application.yaml` 文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace `&lt;YOUR.EVENTHUBS.CONNECTION.STRING&gt;` with the connection string for your Event Hubs namespace.
For instructions on getting the connection string, see https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Get an Event Hubs connection string].
The result would be something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用您的Event Hubs命名空间的连接字符串替换 `&lt;YOUR.EVENTHUBS.CONNECTION.STRING&gt;` 。有关获取连接字符串的说明，请参阅 link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[获取Event Hubs连接字符串] 。结果会类似这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace `&lt;YOUR.EVENTHUBS.CONNECTION.STRING&gt;` with the connection string for your Event Hubs namespace.  For instructions on getting the connection string, see https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Get an Event Hubs connection string].  The result would be something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用您的Event Hubs命名空间的连接字符串替换 `&lt;YOUR.EVENTHUBS.CONNECTION.STRING&gt;` 。有关获取连接字符串的说明，请参阅 link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[获取Event Hubs连接字符串] 。结果会类似这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replying to messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>回复信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Report a Vulnerability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>报告漏洞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reporting security issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>报告安全问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Represent token as `Principal``</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将token表示为 `Principal``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Require this artifact in the step executing the `native-image ...` command, and</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在执行 `native-image …​` 命令的步骤中需要这个工件，并且</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requires Bearer JWT verification</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要进行Bearer JWT验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requires Bearer opaque token verification</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要进行不透明Bearer token验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different from the behavior using
`quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.
In general, client code will automatically handle this encoding but in certain custom situations, you should be aware
you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对二进制类型的响应将会使用base64自动编码。这与使用 `quarkus:dev` 的行为不同，后者将返回原始字节。亚马逊的API有额外的限制，要求base64编码。一般来说，客户端代码会自动处理这种编码，但在某些自定义情况下，你应该知道你可能需要手动管理这种编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different from the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对二进制类型的响应将会使用base64自动编码。这与使用 `quarkus:dev` 的行为不同，后者将返回原始字节。亚马逊的API有额外的限制，要求base64编码。一般来说，客户端代码会自动处理这种编码，但在某些自定义情况下，你应该知道你可能需要手动管理这种编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve a new increment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询增量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检索传入 channel ( `orders` ) - 该 channel 必须在测试资源中被切换到内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the outgoing channel (`beverages`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检索传出 channel  ( `beverages` ) - 该 channel 必须在测试资源中被切换到内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrying message dispatch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重试消息的发送</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrying processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重试处理(Retrying processing)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the stream (_Reactive Stream_)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>返回流 (_Reactive Stream_) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Review automatically generated metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>审查自动生成的metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roadmap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>路线图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roughly 15 minutes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大概15分钟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roughly {prerequisites-time}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大概{prerequisites-time}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run &lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode"&gt;dev mode&lt;/a&gt; remotely with changes to local files immediately available in a containerize environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行远程 &lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode"&gt;开发者模式&lt;/a&gt; 可以在容器化环境中立即对本地文件进行更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run `act -s GITHUB_TOKEN=&lt;GITHUB_TOKEN&gt;`, where *&lt;GITHUB_TOKEN&gt;* needs to be replaced with a token that allows you to push to the https://github.com/quarkusio/quarkusio.github.io repository.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行 `act -s GITHUB_TOKEN=&lt;GITHUB_TOKEN&gt;`，其中 *&lt;GITHUB_TOKEN&gt;* 需要替换为允许您推送到 https://github.com/quarkusio/quarkusio.github.io repository 的令牌。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the Getting Started Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行 "入门 "应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application as a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以本地可执行文件的方式运行该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application in dev mode with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下运行该应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令运行应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令运行该应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.
The `event` parameter takes any JSON file, in this case the sample `payload.json`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行下面的SAM CLI命令来本地测试你的lambda函数，传递合适的SAM `模板` 。 `event` 参数使用任何JSON文件，在本例中是样本 `payload.json` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.  The `event` parameter takes any JSON file, in this case the sample `payload.json`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行下面的SAM CLI命令来本地测试你的lambda函数，传递合适的SAM `模板` 。 `event` 参数使用任何JSON文件，在本例中是样本 `payload.json` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the tests to verify that application still functions correctly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行测试以验证应用程序是否仍能正常运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the tests to verify the change.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行该测试以验证更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run this script in your CLI:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的CLI中运行这个脚本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Runner jar Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Runner jar的例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以本机可执行文件运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running `@QuarkusTest` from an IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从IDE中运行 `@QuarkusTest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running a MongoDB Database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行MongoDB数据库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running in JVM or Native mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在JVM或本地模式下运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/mongodb-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行它就像执行 `./target/mongodb-quickstart-1.0.0-SNAPSHOT-runner` 一样简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行它就像执行 `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner` 一样简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running specific tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行特定的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the Application in Dev mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the Application in JVM mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在JVM模式下运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the Application in Native Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本地模式下运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the above command should return the result below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行上述命令应返回以下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the build process in a container is also possible:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个容器中运行构建过程也是可能的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running this command, should return the following result:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行这个命令应返回以下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RxJava 2 converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RxJava 2转换器有以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUBATOMIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>亚原子&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUPERSONIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>超音速&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SameSite cookies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SameSite cookies</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Gradle:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Gradle构建的Docker文件例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Maven:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Maven构建的Docker文件例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample JWT Generation Output</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JWT生成输出样本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample multistage Dockerfile for building an image from `scratch`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下是基于 `scratch` 镜像，使用Dockerfile多阶段构建镜像的例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sampler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>采样器(Sampler)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将此文件保存在 `src/main/docker/Dockerfile.multistage` ，因为它不包括在开始快速入门中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Scheduler 参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Clustered Tasks with Quartz</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Quartz调度集群任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Periodic Tasks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安排周期性任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Schema Migration with Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Flyway进行模式迁移</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Schema Migration with Liquibase</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Liquibase进行模式迁移</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scratch image support is experimental.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Scratch镜像的支持是试验性的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scratch images should not be used in production without rigorous testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在没有经过严格测试的情况下，不应该在生产中使用Scratch镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第二是cacerts，证书库。你可能还需要定期获取更新的副本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second: Locking in a find().</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第二：通过find()方法使用数据库锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secret engines</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>秘密引擎</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SecretKey support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持SecretKey</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secrets engines are components that store, generate, or encrypt data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>秘密引擎是存储、生成或加密数据的组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secure connections with SSL/TLS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用SSL/TLS的安全连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secure serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secure your web endpoints with authorizations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用授权来保护你的网络端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Customization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全定制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Overview</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SecurityIdentity roles can be mapped from the verified JWT access tokens as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全身份(SecurityIdentity)角色可以从经过验证的JWT访问令牌中映射出来，具体如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See &lt;&lt;keycloak-dev-mode, Running the Application in Dev mode&gt;&gt; section above about testing your application in a dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于在开发模式下测试您的应用程序，请参见上面 link:#keycloak-dev-mode[在开发模式下运行应用程序] 一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See current increments keys</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查看当前增量键的列表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:https://quarkus.io/blog/path-resolution-in-quarkus/[Path Resolution in Quarkus] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息见 link:https://quarkus.io/blog/path-resolution-in-quarkus/[Quarkus中的路径解析] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the equivalent methods from the imperative example with the reactive variant:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参阅带有响应变形的命令式示例中的等效方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:container-image[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节见 link:container-image[容器镜像指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the xref:container-image.adoc[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节见 xref:container-image.adoc[容器镜像指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于这个话题的更多细节，请看 link:quarkus-reactive-architecture.html[Quarkus响应式架构文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the xref:security-openid-connect.adoc[Using OpenID Connect to Protect Service Applications] guide for more information about `Bearer Token` authentication mechanism. It is important to realize that it is the `Bearer Token` authentication mechanism which does the authentication and creates a security identity - while the `quarkus-keycloak-authorization` extension is responsible for applying a Keycloak Authorization Policy to this identity based on the current request path and other policy settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于 `Bearer Token` 认证机制的更多信息，请参见 link:security-openid-connect.html[使用OpenID Connect保护服务应用] 指南。重要的是，是 `Bearer Token` 认证机制来进行认证并创建一个安全身份 - 同时 `quarkus-keycloak-authorization` 扩展负责根据当前的请求路径和其他策略设置对该身份来应用Keycloak授权策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See xref:security-jwt-build.adoc[Generate JWT tokens with SmallRye JWT] and learn how to generate the encrypted or inner-signed and then encrypted tokens fast.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参阅 link:smallrye-jwt-build.html[使用SmallRye JWT生成JWT令牌] ，了解如何快速生成加密的或内部签名然后加密的令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Selected Filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选定的筛选</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send a message to the address `greeting`. Message payload is `name`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送消息到地址 `greeting` 。消息的有效载荷是 `name` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send back the current counter value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>返回当前计数器的值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send the managed instance to Kafka. Make sure we wait for the message to complete before closing the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将管理的实例发送到Kafka。确保我们在事务关闭之前等待消息的完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send the message to Kafka, the `send` method returns a `CompletionStage`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将消息发送到Kafka后， `send` 方法会返回一个 `CompletionStage`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending AMQP messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送AMQP消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Cloud Events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送云事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Emails using SMTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用SMTP发送邮件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending a payload returns a `CompletionStage`, completed when the message is acked. If the message transmission fails, the `CompletionStage` is completed exceptionally with the reason of the nack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送一个payload会返回一个 `CompletionStage` ，并且它会在消息被确认时完成。如果消息传输失败， `CompletionStage` 会以异常结束，并且包含未被确认的原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending and publishing messages use the Vert.x event bus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送和发布消息使用Vert.x事件总线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>向Kafka发送消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages with @Emitter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用@Emitter发送消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending quote request</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送报价请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Separating Java and native image compilation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java和原生镜像分开编译</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Separator for splitting a string which may contain multiple group values. It will only be used if the `smallrye.jwt.path.groups` property points to a custom claim whose value is a string. The default value is a single space because a standard OAuth2 `scope` claim may contain a space separated sequence.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分隔符，用于分割一个可能包含多个组值的字符串。只有当 `smallrye.jwt.path.groups` 属性指向一个值为字符串的自定义声明时，它才会被使用。默认值是一个单一的空格，因为一个标准的OAuth2 `scope` 声明可能包含一个空格分隔的序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serializer/deserializer autodetection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化/反串行器自动侦测</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serializing via JSON-B</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过JSON-B进行序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serializing via Jackson</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过Jackson进行序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.oidc.authentication.user-info-required=true` if a UserInfo JSON object from the OIDC userinfo endpoint has to be requested.
A request will be sent to the OpenID Provider UserInfo endpoint and  an `io.quarkus.oidc.UserInfo` (a simple `javax.json.JsonObject` wrapper) object will be created.
`io.quarkus.oidc.UserInfo` can be either injected or accessed as a SecurityIdentity `userinfo` attribute.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果要从OIDC userinfo端点请求UserInfo JSON对象，那么要设置 `quarkus.oidc.authentication.user-info-required=true` 。一个请求将被发送到OpenID Provider UserInfo端点，并将创建一个 `io.quarkus.oidc.UserInfo` （一个简单的 `javax.json.JsonObject` 包装器）对象。 `io.quarkus.oidc.UserInfo` 可以被注入或作为SecurityIdentity `userinfo` 属性访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.oidc.authentication.user-info-required=true` if a UserInfo JSON object from the OIDC userinfo endpoint has to be requested.  A request will be sent to the OpenID Provider UserInfo endpoint and an `io.quarkus.oidc.UserInfo` (a simple `javax.json.JsonObject` wrapper) object will be created.  `io.quarkus.oidc.UserInfo` can be either injected or accessed as a SecurityIdentity `userinfo` attribute.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果要从OIDC userinfo端点请求UserInfo JSON对象，那么要设置 `quarkus.oidc.authentication.user-info-required=true` 。一个请求将被发送到OpenID Provider UserInfo端点，并将创建一个 `io.quarkus.oidc.UserInfo` （一个简单的 `javax.json.JsonObject` 包装器）对象。 `io.quarkus.oidc.UserInfo` 可以被注入或作为SecurityIdentity `userinfo` 属性访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set durable to false</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将durable设为false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set of trusted hostnames. If the keys have to be fetched over `HTTPS` and `smallrye.jwt.client.tls.trust-all` is set to `false` then this property can be used to configure the trusted hostnames.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受信任的主机名的集合。如果钥匙必须通过 `HTTPS` 获得，并且 `smallrye.jwt.client.tls.trust-all` 被设置为 `false` ，那么这个属性可以用来配置可信的主机名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the `owasp-dependency-check-plugin.version` value to `7.1.1` or later.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其中 `owasp-dependency-check-plugin.version` 应该设置为 `7.1.1` 或更高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the codec to use to receive the message</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置用于接收信息的编解码器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the name of the codec to use to send the message</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置用于发送消息的编解码器的名称</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set this property if another header such as `Cookie` is used to pass the token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用另一个header（如 `Cookie` ）来传递令牌，则设置此属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set this property if another header such as `Cookie` is used to pass the token. This property is deprecated - use 'mp.jwt.token.header'.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用另一个header，如 `Cookie` ，来传递令牌，则设置此属性。此属性已被废弃—请使用 `mp.jwt.token.header` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set this property to `true` for `Authorization` header be checked even if the `smallrye.jwt.token.header` is set to `Cookie` but no cookie with a `smallrye.jwt.token.cookie` name exists.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果将此属性设置为 `true` ，`Authorization` header也会被检查，即使 `smallrye.jwt.token.header` 被设置为 `Cookie` ，但又不存在名称为 `smallrye.jwt.token.cookie` 的cookie。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set this property to a specific key format such as `PEM_KEY`, `PEM_CERTIFICATE`, `JWK` or `JWK_BASE64URL` to optimize the way the verification key is loaded.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将此属性设置为特定的密钥格式，如 `PEM_KEY` , `PEM_CERTIFICATE` , `JWK` 或 `JWK_BASE64URL` ，以优化验证密钥的加载方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting it up</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置它</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the consumer rebalance listener’s name takes precedence over using the group id.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，设置消费者再平衡监听器的名称的方式要比使用组ID的方式优先被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置端口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up and configuring Hibernate ORM with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Hibernate ORM中配置Panache </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up and configuring Hibernate Reactive with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Hibernate Reactive中配置Panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up and configuring MongoDB with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Panache 设置和配置 MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up support for Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立对Flyway的支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Share in our excitement when the project receives &lt;a href="{{site.baseurl}}/awards"&gt;awards and recognition&lt;/a&gt; for all of the hard work done by the community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为社区所做的所有辛勤工作，当项目获得&lt;a href="{{site.baseurl}}/awards"&gt;奖项和认可&lt;/a&gt;时，分享我们的兴奋之情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shared broker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>共享的broker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shared registry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>共享的注册表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shared server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>服务共享</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.
You can disable the sharing with `quarkus.amqp.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下，默认启用共享，但在测试模式下禁用共享。你可以使用 `quarkus.amqp.devservices.shared=false` 来禁用共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.
You can disable the sharing with `quarkus.apicurio-registry.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下，默认启用共享，但在测试模式下默认禁用共享。你可以使用 `quarkus.apicurio-registry.devservices.shared=false` 来禁用共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.
You can disable the sharing with `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下，共享是默认启用的，但在测试模式下是禁用的。您可以用 `quarkus.kafka.devservices.shared=false` 停用共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.
You can disable the sharing with `quarkus.redis.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在dev模式下默认启用服务共享，而在测试模式下默认禁用。也可以使用 `quarkus.redis.devservices.shared=false` 配置禁用服务共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.amqp.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下，默认启用共享，但在测试模式下禁用共享。你可以使用 `quarkus.amqp.devservices.shared=false` 来禁用共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.apicurio-registry.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下，默认启用共享，但在测试模式下默认禁用共享。你可以使用 `quarkus.apicurio-registry.devservices.shared=false` 来禁用共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下，共享是默认启用的，但在测试模式下是禁用的。您可以用 `quarkus.kafka.devservices.shared=false` 停用共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.redis.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在dev模式下默认启用服务共享，而在测试模式下默认禁用。也可以使用 `quarkus.redis.devservices.shared=false` 配置禁用服务共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Short informative videos that highlight unique technical points and instructions on how to get the most out of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简短的信息视频突出了独特的技术要点和关于如何最大限度地利用Quarkus的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Signature algorithm. Set it to `ES256` to support the Elliptic Curve signature algorithm.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>签名算法。将其设置为 `ES256` ，以支持椭圆曲线签名算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Signature algorithm. This property should only be used for setting a required symmetric algorithm such as `HS256`. It is deprecated for setting asymmetric algorithms such as `ES256` - use 'mp.jwt.verify.publickey.algorithm' instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>签名算法。此属性只能用于设置所需的对称算法，如 `HS256` 。对于设置非对称算法，如已被弃用的 `ES256` - 请使用 `mp.jwt.verify.publickey.algorithm` 代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to the Maven configuration, when using Gradle, the following modifications are required when Kotlin is selected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Maven的配置类似，在使用Gradle时，如果选择了Kotlin，则需要做以下修改：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to the previous example, multiple instances of an application can subscribe to a single consumer group, configured via `mp.messaging.incoming.$channel.group.id` property, or left default to the application name.
This in turn will divide partitions of the topic among application instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与前面的例子类似，一个应用程序的多个实例可以订阅同一个消费者组。这种方式可以通过 `mp.messaging.incoming.$channel.group.id` 进行配置，或默认为应用程序的名称。这种方式会在应用程序实例之间分配topic的分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to the previous example, multiple instances of an application can subscribe to a single consumer group, configured via `mp.messaging.incoming.$channel.group.id` property, or left default to the application name.  This in turn will divide partitions of the topic among application instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与前面的例子类似，一个应用程序的多个实例可以订阅同一个消费者组。这种方式可以通过 `mp.messaging.incoming.$channel.group.id` 进行配置，或默认为应用程序的名称。这种方式会在应用程序实例之间分配topic的分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly for Gradle projects, you also just have to add the `quarkus-amazon-lambda` dependency.  The extension automatically generates everything you might need
for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同样，对于Gradle项目，你也只需添加 `quarkus-amazon-lambda` 依赖项。该扩展会为你的lambda部署自动生成可能需要的一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, if you declare</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同样地，如果您声明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple SAM Local Principal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简单的SAM本地主体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate ORM with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化的Hibernate ORM与Panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate ORM with Panache and Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Panache和Kotlin简化Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate Reactive with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化的Hibernate 响应式与Panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified MongoDB with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache简化MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified MongoDB with Panache and Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Panache和Kotlin简化MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified queries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化查询</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified reactive ORM layer based on Hibernate Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于Hibernate 响应式的简化响应式ORM层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplify command line applications creation with the Picocli extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Picocli扩展简化了命令行应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplifying MongoDB Client usage using BSON codec</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用BSON编解码器简化MongoDB客户端的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplifying MongoDB with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Panache简化MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simulate Amazon Lambda Deployment with SAM CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用SAM CLI模拟Amazon Lambda部署</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the `mockableBean2` mock has not been configured, it will return the default Mockito response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于 `mockableBean2` mock还没有被配置，它将返回默认的Mockito响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们将 `greetingService` 配置为一个mock，那么在使用了 `GreetingService` Bean的 `GreetingResource` 中，我们得到的是mock的响应，而不是正常的 `GreetingService` Bean的响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we’re not limited to standards we can go beyond and extend your possibilities. Of course, Quarkus is not a passive consumer. Our goal is to improve and innovate the technologies we use and contribute back to the open source projects and standards we rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们不受标准的限制，我们可以超越并扩展您的可能性。当然，Quarkus不是一个被动的消费者。我们的目标是改进和创新我们所使用的技术，并为我们所依赖的开源项目和标准做出贡献。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single Page Application (SPA) typically uses `XMLHttpRequest`(XHR) and the JavaScript utility code provided by the OpenID Connect provider to acquire a bearer token and use it
to access Quarkus `service` applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>单页应用程序（SPA）通常使用 `XMLHttpRequest` （XHR）和OpenID Connect提供商提供的Java Script实用程序代码来获取不记名令牌，并使用它来访问Quarkus `service` 应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single Page Application (SPA) typically uses `XMLHttpRequest`(XHR) and the JavaScript utility code provided by the OpenID Connect provider to acquire a bearer token and use it to access Quarkus `service` applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>单页应用程序（SPA）通常使用 `XMLHttpRequest` （XHR）和OpenID Connect提供商提供的Java Script实用程序代码来获取不记名令牌，并使用它来访问Quarkus `service` 应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single Page Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>单页应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single-step Deployments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>单步执行部署</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Size</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大小</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skip to &lt;&lt;#container-runtime,this section&gt;&gt; to continue with the guide for Mandrel, and follow the Mandrel-specific instructions in that section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>跳转到 &lt;&lt;#container-runtime,this section&gt;&gt; 继续指导Mandrel，并遵循该节中特定于Mandrel的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye JWT authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye JWT authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye JWT provides more properties which can be used to customize the token processing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye JWT提供了更多的属性，可以用来定制令牌的处理:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging - Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Reactive Messaging - Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So calling the endpoint produces something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所以调用端点会产生如下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot,
then all tests will run, then Quarkus will shut down at the end. This makes for a very fast testing experience however
it is a bit limited as you can't test different configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，在我们所有的例子中，我们只为所有的测试启动Quarkus一次。在第一个测试运行之前，Quarkus会启动，然后所有测试都会在这次启动中运行，最后Quarkus会关闭。这使得测试体验非常快，但是它有一点局限性，因为您无法测试不同的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot, then all tests will run, then Quarkus will shut down at the end. This makes for a very fast testing experience however it is a bit limited as you can't test different configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，在我们所有的例子中，我们只为所有的测试启动Quarkus一次。在第一个测试运行之前，Quarkus会启动，然后所有测试都会在这次启动中运行，最后Quarkus会关闭。这使得测试体验非常快，但是它有一点局限性，因为您无法测试不同的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit
testing and test our beans directly?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们只涉及了通过HTTP节点测试应用程序的集成式测试，但如果我们想做单元测试并直接测试我们的Bean又该怎么办？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit testing and test our beans directly?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们只涉及了通过HTTP节点测试应用程序的集成式测试，但如果我们想做单元测试并直接测试我们的Bean又该怎么办？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we have used the Vert.x Core API.
Vert.x offers much more.
It provides a vast ecosystem.
In this section, we will see how you can use the Vert.x Web Client, a reactive HTTP client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们已经使用了 Vert.x 核心 API。 Vert.x 提供的不仅仅是这些。它提供了一个广阔的生态系统。在本节中，我们将会带你了解如何使用 Vert.x Web 客户端 - 一个响应式 HTTP 客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we have used the Vert.x Core API.  Vert.x offers much more.  It provides a vast ecosystem.  In this section, we will see how you can use the Vert.x Web Client, a reactive HTTP client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们已经使用了 Vert.x 核心 API。 Vert.x 提供的不仅仅是这些。它提供了一个广阔的生态系统。在本节中，我们将会带你了解如何使用 Vert.x Web 客户端 - 一个响应式 HTTP 客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们只返回一个异步结果。在本节中，我们使用传输多个条目的流来扩展应用程序。这些数据流可以来自Kafka或任何其他数据源，但为了简单起见，我们只生成周期性的问候消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么如果你有一个API返回 Reactor 类型 (`Mono`, `Flux`)，你可以创建 `Unis` 和 `Multis` 如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，如果你有一个返回RxJava 2类型 (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`) 的API，你可以创建 `Unis` 和 `Multis` ，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So now let's actually secure something. Take a look at the new endpoint method `helloRolesAllowed` in the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所以，现在让我们真正让一些东西变得安全。看看下面的新端点方法 `helloRolesAllowed` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So use SockJS, you need to configure the bridge, especially the addresses that will be used to communicate:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，使用SockJS，你需要配置桥梁，特别是将用于通信的地址：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，当你访问应用程序的 `/q/health/ready` 端点时，可获得有关于连接验证状态的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/metrics` endpoint of your application you will have information about the connection pool status.
When using xref:smallrye-metrics.adoc[SmallRye Metrics], connection pool metrics will be available under the `vendor` scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，当你访问你的应用程序的 `/q/metrics` 端点时，你将得到有关连接池状态的信息。当使用 link:smallrye-metrics.html[SmallRye Metrics] 时，连接池指标将在 `vendor` 范围内可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/metrics` endpoint of your application you will have information about the connection pool status.  When using xref:smallrye-metrics.adoc[SmallRye Metrics], connection pool metrics will be available under the `vendor` scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，当你访问你的应用程序的 `/q/metrics` 端点时，你将得到有关连接池状态的信息。当使用 link:smallrye-metrics.html[SmallRye Metrics] 时，连接池指标将在 `vendor` 范围内可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, first, let's extend our `VertxResource` class with the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，首先，让我们使用以下代码来扩展我们的 `VertxResource` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, unlike the imperative model, where I/O blocks the execution, reactive switches to a continuation-based design, where the I/O threads are released, and continuation invoked when the I/Os complete.
As a result, the I/O thread can handle multiple concurrent requests, improving the overall concurrency of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，与I/O阻塞执行的指令式模型不同，响应式切换到基于延续的设计，其中I/O线程被释放，而延续在I/O完成时被调用。因此，I/O线程可以处理多个并发请求，从而提高应用程序的整体并发性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, unlike the imperative model, where I/O blocks the execution, reactive switches to a continuation-based design, where the I/O threads are released, and continuation invoked when the I/Os complete.  As a result, the I/O thread can handle multiple concurrent requests, improving the overall concurrency of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，与I/O阻塞执行的指令式模型不同，响应式切换到基于延续的设计，其中I/O线程被释放，而延续在I/O完成时被调用。因此，I/O线程可以处理多个并发请求，从而提高应用程序的整体并发性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, with the reactive execution model, the requests are processed using I/O threads.
But that's not all.
An I/O thread can handle multiple concurrent requests.
How? Here is the trick and one of the most significant differences between reactive and imperative.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，使用响应式执行模型，请求是使用I/O线程处理的。但这还不是全部。一个I/O线程可以处理多个并发请求。如何实现？这是一个技巧，也是响应式和指令式之间最重要的区别之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, with the reactive execution model, the requests are processed using I/O threads.  But that's not all.  An I/O thread can handle multiple concurrent requests.  How? Here is the trick and one of the most significant differences between reactive and imperative.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，使用响应式执行模型，请求是使用I/O线程处理的。但这还不是全部。一个I/O线程可以处理多个并发请求。如何实现？这是一个技巧，也是响应式和指令式之间最重要的区别之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, you should have the following files in your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，你的项目中应该包含以下文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SockJS negotiates the communication channel between the Quarkus application and the browser.
If WebSockets are supported, it uses them; otherwise, it degrades to SSE, long polling, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SockJS负责协商Quarkus应用程序和浏览器之间的通信渠道。如果支持WebSockets，它就使用它们；否则，它就退化为SSE、long polling等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SockJS negotiates the communication channel between the Quarkus application and the browser.  If WebSockets are supported, it uses them; otherwise, it degrades to SSE, long polling, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SockJS负责协商Quarkus应用程序和浏览器之间的通信渠道。如果支持WebSockets，它就使用它们；否则，它就退化为SSE、long polling等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution 1: using the active record pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案1：使用active record（活动记录）模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution 2: using the repository pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案2：使用资源库模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solutions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solving this issue requires adding the `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` option and to provide a dynamic proxy configuration file.
You can find all the information about the format of this file in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md#manual-configuration[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决这个问题需要添加 `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` 选项，并提供一个动态代理配置文件。你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md#manual-configuration[GraalVM文档]中找到关于这个文件格式的所有信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solving this issue requires adding the `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` option and to provide a dynamic proxy configuration file.  You can find all the information about the format of this file in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md#manual-configuration[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决这个问题需要添加 `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` 选项，并提供一个动态代理配置文件。你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md#manual-configuration[GraalVM文档]中找到关于这个文件格式的所有信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some Quarkus extensions will require additional code to ensure traces are propagated to subsequent execution.
These sections will outline what is necessary to propagate traces across process boundaries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些Quarkus扩展需要额外的代码来确保traces被传播到后续执行中。以下章节将展示跨越进程边界传播traces的必要条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some Quarkus extensions will require additional code to ensure traces are propagated to subsequent execution.  These sections will outline what is necessary to propagate traces across process boundaries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些Quarkus扩展需要额外的代码来确保traces被传播到后续执行中。以下章节将展示跨越进程边界传播traces的必要条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some consumer client properties are configured to sensible default values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些消费者客户端属性被配置为相对合理的默认值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some environment cuts the SSE connection when there is not enough activity.
The workaround consists of sending _ping_ messages (or empty objects) periodically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当没有足够的活跃度时，一些环境会切断SSE的连接。替代方法则是定期发送 _ping_ 消息(或空对象)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some environment cuts the SSE connection when there is not enough activity.  The workaround consists of sending _ping_ messages (or empty objects) periodically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当没有足够的活跃度时，一些环境会切断SSE的连接。替代方法则是定期发送 _ping_ 消息(或空对象)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions, for example, `OIDC`, `OAuth2`, and `SmallRye JWT` have inline `IdentityProvider` implementations specific to the supported authentication flow.
For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些扩展如 `OIDC` 、 `OAuth2` 以及 `SmallRye JWT` 有内联的 `IdentityProvider` 实现来针对支持的认证流程的。例如， `quarkus-oidc` 使用它自己的 `IdentityProvider` 来将token转换为 `SecurityIdentity` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions, for example, `OIDC`, `OAuth2`, and `SmallRye JWT` have inline `IdentityProvider` implementations specific to the supported authentication flow.  For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些扩展如 `OIDC` 、 `OAuth2` 以及 `SmallRye JWT` 有内联的 `IdentityProvider` 实现来针对支持的认证流程的。例如， `quarkus-oidc` 使用它自己的 `IdentityProvider` 来将token转换为 `SecurityIdentity` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some familiarity with the Spring Web extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对Spring Web扩展有一定的熟悉程度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some previous releases of GraalVM included the `native-image` tool by default.  This is no longer the case; it must be installed as a second step after GraalVM itself is installed. Note: there is an outstanding issue xref:graal-and-catalina[using GraalVM with macOS Catalina].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM以前的一些版本默认包括 `native-image` 工具。现在已经不是这样了，它必须在安装完GraalVM本身后作为第二步来安装。注意：一个已知的问题 xref:graal-and-catalina[在MacOS Catalina上使用GraalVM]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some producer client properties are configured to sensible default values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些生产者客户端属性被配置为合理的默认值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some properties have aliases which can be configured globally:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些属性拥有可以进行全局配置的别名：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some use cases will require custom configuration of OpenTelemetry.
These sections will outline what is necessary to properly configure it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些情况下需要对OpenTelemetry进行自定义配置。以下章节将展示如何对一些必要的属性进行正确配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some use cases will require custom configuration of OpenTelemetry.  These sections will outline what is necessary to properly configure it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些情况下需要对OpenTelemetry进行自定义配置。以下章节将展示如何对一些必要的属性进行正确配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some vendor-specific protocols need a custom ID Generator, you can override the default one by creating a producer.
The OpenTelemetry extension will detect the `IdGenerator` CDI bean and will use it when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些供应商特定协议需要一个自定义的ID生成器，您可以通过创建一个自定义生成器来覆盖默认的ID。OpenTelemetry扩展将检测 `IdGenerator` CDI Bean，并在配置tracer生成器时使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some vendor-specific protocols need a custom ID Generator, you can override the default one by creating a producer.  The OpenTelemetry extension will detect the `IdGenerator` CDI bean and will use it when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些供应商特定协议需要一个自定义的ID生成器，您可以通过创建一个自定义生成器来覆盖默认的ID。OpenTelemetry扩展将检测 `IdGenerator` CDI Bean，并在配置tracer生成器时使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it is desirable to select the destination of a message dynamically.
In this case, you should not configure the address inside your application configuration file, but instead, use the outbound metadata to set the address.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时，需要动态选择消息的目的地。在这种情况下，你不应该在你的应用程序配置文件中配置地址，而应该使用出站元数据来设置地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it is desirable to select the destination of a message dynamically.  In this case, you should not configure the address inside your application configuration file, but instead, use the outbound metadata to set the address.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时，需要动态选择消息的目的地。在这种情况下，你不应该在你的应用程序配置文件中配置地址，而应该使用出站元数据来设置地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito documentation] for more details on Spy partial mocks.
In either of those situations a Spy of the object is preferable.
Using `@InjectSpy`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时在测试时您只需要验证某个逻辑路径，或者您只想对某一个方法的响应进行stub，同时仍保持执行Spied clone上的其他方法。关于Spy部分mock的更多细节，请参见 link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito文档] 。在这两种情况下，推荐使用针对对象的Spy。使用 `@InjectSpy` ，前面的例子可以写成这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito documentation] for more details on Spy partial mocks.  In either of those situations a Spy of the object is preferable.  Using `@InjectSpy`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时在测试时您只需要验证某个逻辑路径，或者您只想对某一个方法的响应进行stub，同时仍保持执行Spied clone上的其他方法。关于Spy部分mock的更多细节，请参见 link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito文档] 。在这两种情况下，推荐使用针对对象的Spy。使用 `@InjectSpy` ，前面的例子可以写成这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you need more than just handling messages one by one.  You can also express your message processing logic using reactive programming as illustrated in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时你需要的不仅仅是逐一处理消息。你也可以使用响应式编程来表达消息处理逻辑，如下面的片段所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just
an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one
project and use configuration or an environment variable to pick the handler you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但有时，你可能会有几个共享代码的相关lambdas，创建多个maven模块是你不想做的开销。 `quarkus-amazon-lambda` 扩展允许你在一个项目中捆绑多个lambdas，并使用配置或环境变量来选择你要部署的处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one project and use configuration or an environment variable to pick the handler you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但有时，你可能会有几个共享代码的相关lambdas，创建多个maven模块是你不想做的开销。 `quarkus-amazon-lambda` 扩展允许你在一个项目中捆绑多个lambdas，并使用配置或环境变量来选择你要部署的处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you need to have an imperative way of sending messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时，您需要使用命令式的方式来发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sorting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>排序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>源代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code,
are not added to the source cache by default.
To include those, make sure you invoke `mvn dependency:sources` first.
This step is required in order to pull the sources for these dependencies,
and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第三方jar依赖的源，包括Quarkus源代码，默认情况下不会被添加到源缓存中。要包括这些，请确保你先调用 `mvn dependency:sources` 。这一步是必须的，以便拉出这些依赖的源代码，并将其包含在源代码缓存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code, are not added to the source cache by default.  To include those, make sure you invoke `mvn dependency:sources` first.  This step is required in order to pull the sources for these dependencies, and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第三方jar依赖的源，包括Quarkus源代码，默认情况下不会被添加到源缓存中。要包括这些，请确保你先调用 `mvn dependency:sources` 。这一步是必须的，以便拉出这些依赖的源代码，并将其包含在源代码缓存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the commit strategy to apply when a message produced from a record is acknowledged. Values can be `latest`, `ignore` or `throttled`. If `enable.auto.commit` is true then the default is `ignore` otherwise it is `throttled`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>记录产生的消息被确认时的提交策略。值可以是 `latest` , `ignore` 或 `throttled` 。如果 `enable.auto.commit` 为真，则默认为 `ignore` ，否则为 `throttled` 

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the failure strategy to apply when a message produced from a record is acknowledged negatively (nack). Values can be `fail` (default), `ignore`, or `dead-letter-queue`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当记录产生的消息未被确认（nack）时要应用的失败策略。值可以是 `fail` （默认）， `ignore` ，或 `dead-letter-queue` 

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the failure strategy to apply when a message produced from an AMQP message is nacked. Accepted values are `fail` (default), `accept`, `release`, `reject`, `modified-failed`, `modified-failed-undeliverable-here`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当从AMQP消息中产生的消息为不被认可时，指定要应用的失败策略。可接受的值是 `fail` （默认）， `accept` ， `release` ， `reject` ， `modified-failed` ， `modified-failed-undeliverable-here` 

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Boot `@ConfigurationProperties` has a few limitations. For instance, `Map` injection is not
supported. Consider using xref:config-mappings.adoc[Mapping configuration to objects].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Boot `@ConfigurationProperties` 有一些限制。例如，不支持 `Map` 注入。你可以考虑使用 link:config-mappings.html[将配置映射到对象] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Boot `@ConfigurationProperties` has a few limitations. For instance, `Map` injection is not supported. Consider using xref:config-mappings.adoc[Mapping configuration to objects].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Boot `@ConfigurationProperties` 有一些限制。例如，不支持 `Map` 注入。你可以考虑使用 link:config-mappings.html[将配置映射到对象] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Cloud Config Client Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Cloud 配置客户端参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST simplifies the creation of CRUD applications based on our Spring Data compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Data REST简化了基于我们Spring Data兼容层的CRUD应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>稳定版</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stack Overflow</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stack Overflow</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stand up a Config Server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立一个配置服务器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start AMQP automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动AMQP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Apache Kafka automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Apache Kafka。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Apicurio Registry automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Apicurio仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Elasticsearch automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Elasticsearch。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Keycloak or other providers automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Keycloak或其他提供者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Kogito automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Kogito。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start RabbitMQ automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动 RabbitMQ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Redis automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Redis。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start by adding the following dependencies to your test project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先在你的测试项目中添加以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start the OpenTelemetry Collector and Jaeger system via the following `docker-compose.yml` file that you can launch via `docker-compose up -d`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过 `docker-compose up -d` 命令和下面的 `docker-compose.yml` 文件来启动OpenTelemetry Collector和Jaeger系统：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start with adding the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先要添加以下依赖关系：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start your application in dev mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下启动您的应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting and Configuring the Keycloak Server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动和配置Keycloak服务器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting and stopping transactions: defining your boundaries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始和停止事务：确定你的事务边界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting services before the Quarkus application starts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus应用程序启动之前启动服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting the Redis server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动Redis服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1,
debug symbols for native executables can be generated for Linux environments
(Windows support is still under development, macOS is not supported).
These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Oracle GraalVM 20.2或Mandrel 20.1开始，可以为Linux环境生成原生可执行文件的调试符号（Windows支持仍在开发中，不支持macOS）。这些符号可用于用工具调试原生可执行文件，如 `gdb` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Oracle GraalVM 20.2或Mandrel 20.1开始，可以为Linux环境生成本地可执行文件的调试符号（Windows支持仍在开发中）。这些符号可用于用工具调试本地可执行文件，如 `gdb` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development, macOS is not supported).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Oracle GraalVM 20.2或Mandrel 20.1开始，可以为Linux环境生成原生可执行文件的调试符号（Windows支持仍在开发中，不支持macOS）。这些符号可用于用工具调试原生可执行文件，如 `gdb` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Status</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;1&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;1&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;2&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;2&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;3&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;3&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;4&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;4&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Store the managed Vert.x instance into a field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将被管理的Vert.x实例存储到一个字段当中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stork Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stork 参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Streaming Kafka topics as server-sent events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Kafka topic作为服务器发送的事件流化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Streaming a Kafka topic as server-sent events (SSE) is straightforward:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Kafka topic作为服务器发送的事件(Server-sent events, SSE)进行流化非常直白:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Streamlined code for the 80% common usages, flexible for the 20%</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化80%的常用代码，灵活处理剩余的20%</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strimzi provides container images and Operators for running Apache Kafka on Kubernetes.
While Strimzi is optimized for Kubernetes, the images work perfectly in classic container environments.
Strimzi container images run "genuine" Kafka broker on JVM, which is slower to start.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Strimzi为在Kubernetes上运行Apache Kafka提供了容器镜像和Operator。虽然Strimzi针对Kubernetes进行了优化，但这些镜像在经典的容器环境中也能完美运行。Strimzi容器镜像在JVM上运行 "真实的 "Kafka broker，其启动速度较慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SubjectExposingResource Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SubjectExposingResource示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subpath permissions always win against the root path permissions as explained above in the `deny1` versus `permit1` permission example.
Here is another example showing a subpath permission allowing a public resource access with the root path permission requiring the authorization:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>子路径权限总是赢过根路径权限，正如上面 `deny1` 与 `permit1` 权限的例子所解释的那样。下面是另一个例子，显示了子路径权限允许公共资源访问，而根路径权限需要授权：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subpath permissions always win against the root path permissions as explained above in the `deny1` versus `permit1` permission example.  Here is another example showing a subpath permission allowing a public resource access with the root path permission requiring the authorization:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>子路径权限总是赢过根路径权限，正如上面 `deny1` 与 `permit1` 权限的例子所解释的那样。下面是另一个例子，显示了子路径权限允许公共资源访问，而根路径权限需要授权：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subscribe to the &lt;a href="{{site.baseurl}}/newsletter"&gt;monthly newsletter&lt;/a&gt; to have choice Quarkus content from across our community delivered to your inbox.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>订阅&lt;a href="{{site.baseurl}}/newsletter"&gt;每月通讯&lt;/a&gt;，将来自我们整个社区的Quarkus精选内容发送到您的收件箱。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Success! We now have:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>成功了!我们现在有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a callback implementation has to be registered as a "service provider" as defined by `java.util.ServiceLoader`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种回调实现必须作为java "服务提供者(service provider) "注册，从而被 `java.util.ServiceLoader` 来加载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a multi-stage build can be achieved as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样的多阶段构建可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summaries and Timers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Summaries 和 Timers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supersonic Subatomic Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>超音速 亚原子 Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support for the MicroProfile Metrics API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Metrics API支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for JAX-RS Resource Methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为JAX-RS Resource方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for REST Client interface methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为REST客户端接口方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for Reactive messaging methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供对响应式信息传递方法的支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for scheduler methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为调度器方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for the declarative annotation-based API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对基于声明性注解的API提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Injection Scopes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持的注射范围</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Public Key Formats</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持的公钥格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Versions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受支持版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native compilation in C</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持C语言的原生编译</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in a Quarkus extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus扩展中支持原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in a Quarkus extension is even easier as Quarkus provides a lot of tools to simplify all this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus扩展中支持本机更容易，因为Quarkus提供了很多工具来简化这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in your application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的应用程序中支持原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch back to a `Uni&lt;Void&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>切换并返回 `Uni&lt;Void&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the incoming channel `orders` (expecting messages from Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将传入 channel  `orders` (等待来自Kafka的消息)切换到内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the outgoing channel `beverages` (writing messages to Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将出站 channel `beverages`(向Kafka写消息)切换到内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the working directory to `/work`, which we have mounted in &lt;1&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将工作目录切换到 `/work` ，我们已经在&lt;1&gt;中挂载了这个目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tag the image using your ECR registry information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用你的ECR注册信息给镜像打上标签</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take the code from the following listing and place into `security-jwt-quickstart/src/test/java/org/acme/security/jwt/GenerateToken.java`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从以下列表中拷贝代码，并将其放入 `security-jwt-quickstart/src/test/java/org/acme/security/jwt/GenerateToken.java` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templating with Qute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Qute进行模板设计</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test resources are global, even if they are defined on a test class or custom profile, which means they will all be activated for all tests, even though we do
remove duplicates. If you want to only enable a test resource on a single test class or test profile, you can use `@QuarkusTestResource(restrictToAnnotatedClass = true)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试资源是全局性的，即使它们被定义在一个测试类或自定义profile上，这意味着它们将全部被激活从而用于所有的测试，尽管我们删除了重复的测试。如果您只想针对一个测试类或测试profile启用某一个测试资源，您可以使用 `@QuarkusTestResource(restrictToAnnotatedClass = true)` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test resources are global, even if they are defined on a test class or custom profile, which means they will all be activated for all tests, even though we do remove duplicates. If you want to only enable a test resource on a single test class or test profile, you can use `@QuarkusTestResource(restrictToAnnotatedClass = true)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试资源是全局性的，即使它们被定义在一个测试类或自定义profile上，这意味着它们将全部被激活从而用于所有的测试，尽管我们删除了重复的测试。如果您只想针对一个测试类或测试profile启用某一个测试资源，您可以使用 `@QuarkusTestResource(restrictToAnnotatedClass = true)` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test the security of your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试你的Quarkus应用程序的安全性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TestHTTPResource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TestHTTPResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TestSecurity annotation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TestSecurity 注解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Different Profiles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试不同的Profiles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试你的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a Kafka application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试一个Kafka应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a reactive application is similar to testing a non-reactive one: use the HTTP endpoint and verify the HTTP responses.
The fact that the application is reactive does not change anything.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试响应式应用程序与测试非响应式应用程序类似：使用HTTP端点并验证HTTP响应。应用程序是响应式的这一事实并没有改变任何事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a reactive application is similar to testing a non-reactive one: use the HTTP endpoint and verify the HTTP responses.  The fact that the application is reactive does not change anything.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试响应式应用程序与测试非响应式应用程序类似：使用HTTP端点并验证HTTP响应。应用程序是响应式的这一事实并没有改变任何事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a specific endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试特定的节点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing an existing native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试一个现有的原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing and Running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试和运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing helpers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试助手</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing in JVM mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在JVM模式下测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing in native mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本地模式下测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing using a Kafka broker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kafka broker的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing with the SAM CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用SAM CLI进行测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing without a broker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>无broker的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing your `quarkus-oidc` `service` application with `OidcWiremockTestResource` provides the best coverage as even the communication channel is tested against the Wiremock HTTP stubs.
`OidcWiremockTestResource` will be enhanced going forward to support more complex Bearer token test scenarios.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用 `OidcWiremockTestResource` 测试你的 `quarkus-oidc` `service` 应用程序，可以提供最好的覆盖率，因为即使是通信通道也是针对Wiremock HTTP存根(stubs) 进行测试的。 `OidcWiremockTestResource` 将在未来得到加强，以支持更复杂的不记名令牌测试场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing your `quarkus-oidc` `service` application with `OidcWiremockTestResource` provides the best coverage as even the communication channel is tested against the Wiremock HTTP stubs.  `OidcWiremockTestResource` will be enhanced going forward to support more complex Bearer token test scenarios.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用 `OidcWiremockTestResource` 测试你的 `quarkus-oidc` `service` 应用程序，可以提供最好的覆盖率，因为即使是通信通道也是针对Wiremock HTTP存根(stubs) 进行测试的。 `OidcWiremockTestResource` 将在未来得到加强，以支持更复杂的不记名令牌测试场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tests and Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试与事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks goes to these wonderful people:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>感谢这些优秀的人：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , you can compose asynchronous operations and complete the result when everything is done without blocking the I/O threads.  This greatly improves resource consumption and elasticity.  Most Quarkus APIs are available in both imperative and reactive.  As example, you can use the reactive version of the REST Client:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用&lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny 响应式API&lt;/a&gt;，你可以组成异步操作，并在不阻塞I/O线程的情况下达成一切结果。这大大改善了资源消耗和弹性。大多数Quarkus API都可以使用指令式和响应式两种方式。例如，你可以使用REST客户端的响应式版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments.  Quarkus provides Funqy, an approach to writing functions that are deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative Events (Cloud Events). It is also usable as a standalone service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于其出色的启动时间和较低的内存使用，您可以使用Quarkus实现在无服务器环境中使用的功能。Quarkus提供了Funqy，一种编写可部署到各种FaaS环境中的函数的方法，如AWS Lambda、Azure函数、Knative和Knative事件(云事件)。它也可以作为一个独立的服务使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all there is to it: with Panache, Hibernate ORM has never looked so trim and neat.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上就是它的全部内容：有了Panache，Hibernate ORM看起来变得如此轻量和整洁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all there is to it: with Panache, Hibernate Reactive has never looked so trim and neat.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上就是它的全部内容：有了Panache，Hibernate Reactive看起来变得如此轻量和整洁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all there is to it: with Panache, MongoDB has never looked so trim and neat.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这就是它的全部内容：有了Panache，MongoDB看起来从未如此简洁</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第3行定义数据源。最后一行将在应用程序中用于指示在应用程序初始化时是否插入一些条目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;a href="https://groups.google.com/d/forum/quarkus-dev" target="_blank"&gt;quarkus-dev Google Groups&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以访问 &lt;a href="https://groups.google.com/d/forum/quarkus-dev" target="_blank"&gt;quarkus-dev Google Groups&lt;/a&gt;讨论组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;code&gt;@Incoming&lt;/code&gt; and &lt;code&gt;@Outgoing&lt;/code&gt; annotations are part of &lt;a href="https://www.smallrye.io/smallrye-reactive-messaging"&gt;Reactive Messaging&lt;/a&gt;.  They are used to express from which &lt;em&gt;channel&lt;/em&gt; you are consuming and to which &lt;em&gt;channel&lt;/em&gt; you are sending.  Thanks to Reactive Messaging you can consume and send messages from and to different brokers and transports such as HTTP, Kafka, or &lt;a href="http://camel.apache.org"&gt;Apache Camel&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;@Incoming&lt;/code&gt; 和 &lt;code&gt;@Outgoing&lt;/code&gt; 注解是&lt;a href="https://www.smallrye.io/smallrye-reactive-messaging"&gt;响应式消息&lt;/a&gt;的一部分。它们用于表达您从哪个&lt;em&gt;channel&lt;/em&gt;消费，以及向哪个&lt;em&gt;channel&lt;/em&gt;发送。由于响应式消息传递，您可以从不同的代理和传输工具（如HTTP、Kafka或&lt;a href="http://camel.apache.org"&gt;Apache Camel&lt;/a&gt;）消费和发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP address. If not set, the channel name is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP地址。如果没有设置，则使用通道名称

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector allows Quarkus applications to send and receive messages using the AMQP 1.0 protocol.
More details about the protocol can be found in http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html[the AMQP 1.0 specification].
It's important to note that AMQP 1.0 and AMQP 0.9.1 (implemented by RabbitMQ) are incompatible.
Check &lt;&lt;using-rabbitmq,Using RabbitMQ&gt;&gt; to get more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器允许Quarkus应用程序使用AMQP 1.0协议来发送和接收消息。关于该协议的更多详情可以在 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html[AMQP 1.0规范] 中找到。值得注意的是，AMQP 1.0 和 AMQP 0.9.1（由 RabbitMQ 实现）是不兼容的。请查看 link:#using-rabbitmq[使用 RabbitMQ] 以了解更多详情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector allows Quarkus applications to send and receive messages using the AMQP 1.0 protocol.  More details about the protocol can be found in http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html[the AMQP 1.0 specification].  It's important to note that AMQP 1.0 and AMQP 0.9.1 (implemented by RabbitMQ) are incompatible.  Check &lt;&lt;using-rabbitmq,Using RabbitMQ&gt;&gt; to get more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器允许Quarkus应用程序使用AMQP 1.0协议来发送和接收消息。关于该协议的更多详情可以在 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html[AMQP 1.0规范] 中找到。值得注意的是，AMQP 1.0 和 AMQP 0.9.1（由 RabbitMQ 实现）是不兼容的。请查看 link:#using-rabbitmq[使用 RabbitMQ] 以了解更多详情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector connects to AMQP 1.0 brokers such as Apache ActiveMQ or Artemis.
To configure the location and credentials of the broker, add the following properties in the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器连接到AMQP 1.0代理，如Apache ActiveMQ或Artemis。要配置代理的位置和凭证，请在 `application.properties` 中添加以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector connects to AMQP 1.0 brokers such as Apache ActiveMQ or Artemis.  To configure the location and credentials of the broker, add the following properties in the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器连接到AMQP 1.0代理，如Apache ActiveMQ或Artemis。要配置代理的位置和凭证，请在 `application.properties` 中添加以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector supports https://cloudevents.io/[Cloud Events].
The connector sends the outbound record as Cloud Events if:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器支持 link:https://cloudevents.io/[云事件] 。连接器会将出站记录作为云事件发送，如果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector supports https://cloudevents.io/[Cloud Events].
When the connector detects a _structured_ or _binary_ Cloud Events, it adds a  `IncomingCloudEventMetadata&lt;T&gt;` into the metadata of the `Message`.
`IncomingCloudEventMetadata` contains accessors to the mandatory and optional Cloud Event attributes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器支持 link:https://cloudevents.io/[云事件] 。当连接器检测到一个 _structured_ 或 _binary_ 云事件时，它会向 `Message` 的元数据中添加一个 `IncomingCloudEventMetadata&lt;T&gt;` 。 `IncomingCloudEventMetadata` 包含对强制和可选云事件属性的访问器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector supports https://cloudevents.io/[Cloud Events].  The connector sends the outbound record as Cloud Events if:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器支持 link:https://cloudevents.io/[云事件] 。连接器会将出站记录作为云事件发送，如果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector supports https://cloudevents.io/[Cloud Events].  When the connector detects a _structured_ or _binary_ Cloud Events, it adds a `IncomingCloudEventMetadata&lt;T&gt;` into the metadata of the `Message`.  `IncomingCloudEventMetadata` contains accessors to the mandatory and optional Cloud Event attributes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接器支持 link:https://cloudevents.io/[云事件] 。当连接器检测到一个 _structured_ 或 _binary_ 云事件时，它会向 `Message` 的元数据中添加一个 `IncomingCloudEventMetadata&lt;T&gt;` 。 `IncomingCloudEventMetadata` 包含对强制和可选云事件属性的访问器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP container id

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP容器的id

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.
After you have built your Maven project, execute this command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS SAM CLI允许你在模拟的Lambda环境中的笔记本电脑上，本地运行你的lambda。这需要安装Docker。在构建了Maven项目后，执行这个命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS SAM CLI允许你在模拟的Lambda环境中的笔记本电脑上，本地运行你的lambda。这需要安装Docker。在构建了Maven项目后，执行这个命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch API and Runtime will be available out of the box. Please refer to the &lt;a href="#"&gt;Batch documentation&lt;/a&gt;, or the &lt;a href="#"&gt;JBeret documentation&lt;/a&gt; to learn about Batch Applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API和运行时将是开箱即用的。请参考&lt;a href=""&gt;批处理文档&lt;/a&gt;，或&lt;a href=""&gt;JBeret文档&lt;/a&gt;以了解批处理应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch API requires the @BatchProperty annotation to inject the specific configuration from the batch definition file. Instead, you can use the @ConfigProperty annotation, which is used to inject configuration properties in Quarkus using the MicroProfile Config API and keep consistency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API需要@BatchProperty注解来注入批处理定义文件中的特定配置。或者，你可以使用@ConfigProperty注解，它被用来在Quarkus中使用MicroProfile配置API注入配置属性，并保持一致性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch APIs JobOperator and JobRepository are available as CDI beans, so they can be injected directly into any code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API的JobOperator和JobRepository可以作为CDI Bean使用，所以它们可以直接注入到任何代码中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI name of the handler class must match the value specified within the `quarkus.lambda.handler` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理程序类的CDI名称必须与 `quarkus.lambda.handler` 属性中指定的值匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>云事件模式（ `structured` 或 `binary` （默认））。表示如何在发出的记录中写入云事件

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Converter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>转换器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CostCollector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>成本收集器（The CostCollector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Event Hub connection string given by Azure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由Azure提供的Event Hub连接字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTML page</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTML页面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTTP method receives the payload and returns a `CompletionStage` completed when the message is written to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP方法接会接收payload，并在消息被写入Kafka时返回一个 `CompletionStage`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTTP method receiving the payload returns a `Uni&lt;Void&gt;`. The HTTP response is written when the operation completes (the entity is persisted and written to Kafka).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收payload的HTTP方法返回一个 `Uni&lt;Void&gt;` 。当操作完成后，会返回HTTP响应(实体被持久化并被写入Kafka)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret Quarkus extension supports the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret Quarkus扩展支持以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret REST API, provides REST resources to several operations around the Batch API: starting and stopping jobs, querying the status of a job, schedule a job, and many more. The extension includes a REST client to simplify the REST API calls:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret REST API，为围绕Batch API的几个操作提供REST资源：启动和停止作业、查询作业状态、安排作业等等。该扩展包括一个REST客户端来简化REST API的调用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret REST is integrated as separate extension that can be easily added to the target project with the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret REST被集成为独立的扩展，可以通过以下依赖关系轻松地添加到目标项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret Scheduler is integrated out of the box in this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个扩展中，JBeret Scheduler是开箱即用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JPA `IdentityProvider` creates a `SecurityIdentity` instance, which is used during user authentication to verify and authorize access requests making your Quarkus application secure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JPA `IdentityProvider` 创建了一个 `SecurityIdentity` 实例，在用户认证过程中，它被用来验证和授权访问请求以保证您的Quarkus应用程序安全。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JWT string is the Base64 URL encoded string that has 3 parts separated by '.' characters.
First part - JWT headers, second part - JWT claims, third part - JWT signature.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JWT字符串是Base64 URL编码的字符串，有3个部分，由'.'字符分隔。第一部分 - JWT头，第二部分 - JWT要求，第三部分 - JWT签名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JWT string is the Base64 URL encoded string that has 3 parts separated by '.' characters.  First part - JWT headers, second part - JWT claims, third part - JWT signature.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JWT字符串是Base64 URL编码的字符串，有3个部分，由'.'字符分隔。第一部分 - JWT头，第二部分 - JWT要求，第三部分 - JWT签名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JobScheduler does not support persistent schedules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JobScheduler不支持持久化调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector disables the Kafka auto commit when it is not explicitly enabled. This behavior differs from the traditional Kafka consumer.
If high throughput is important for you, and you are not limited by the downstream, we recommend to either:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka connector没有明确启用时，它将禁用Kafka自动提交。这与传统的Kafka消费者不同。如果高吞吐量对您来说很重要而且您不受下游的限制，我们建议要么：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector disables the Kafka auto commit when it is not explicitly enabled. This behavior differs from the traditional Kafka consumer.  If high throughput is important for you, and you are not limited by the downstream, we recommend to either:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka connector没有明确启用时，它将禁用Kafka自动提交。这与传统的Kafka消费者不同。如果高吞吐量对您来说很重要而且您不受下游的限制，我们建议要么：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector supports three strategies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka connector支持三种策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka outbound connector handles back-pressure, monitoring the number of in-flight messages waiting to be written to the Kafka broker.
The number of in-flight messages is configured using the `max-inflight-messages` attribute and defaults to 1024.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的出站connector负责处理背压，并且会监测等待写入Kafka broker中的in-flight的消息数量。in-flight的消息的数量是通过 `max-inflight-messages` 配置的，默认为1024。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka outbound connector handles back-pressure, monitoring the number of in-flight messages waiting to be written to the Kafka broker.  The number of in-flight messages is configured using the `max-inflight-messages` attribute and defaults to 1024.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的出站connector负责处理背压，并且会监测等待写入Kafka broker中的in-flight的消息数量。in-flight的消息的数量是通过 `max-inflight-messages` 配置的，默认为1024。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kotlin plugin is activated, which implicitly adds `sourceDirectory` and `testSourceDirectory` build properties to point to Kotlin sources (`src/main/kotlin` and `src/test/kotlin` respectively)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin插件被激活，它隐含地添加了 `sourceDirectory` 和 `testSourceDirectory` 构建属性，以指向Kotlin代码(分别是 `src/main/kotlin` 和 `src/test/kotlin` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kotlin plugin version needs to be specified.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要指定Kotlin插件的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MP Metrics API compatibility layer will be moved to a different extension in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MP Metrics API 的兼容层会在将来迁移至另外的扩展中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MicroProfile Config specification defines configuration keys as an arbitrary `.`-delimited string. However,
structured formats like YAML only support a subset of the possible configuration namespace. For example, consider the
two configuration properties `quarkus.http.cors` and `quarkus.http.cors.methods`. One property is the prefix of another,
so it may not be immediately evident how to specify both keys in your YAML configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Config 规范将配置键定义为任意的 `.` - 分隔字符串。然而，像 YAML 这样的结构化格式可能只支持配置命名空间的一个子集。例如，考虑有两个配置属性 `quarkus.http.cors` 和 `quarkus.http.cors.methods` 的情况。一个属性是另一个属性的前缀，因此如何在 YAML 配置中指定这两个键可能不是很明确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MicroProfile Config specification defines configuration keys as an arbitrary `.`-delimited string. However, structured formats like YAML only support a subset of the possible configuration namespace. For example, consider the two configuration properties `quarkus.http.cors` and `quarkus.http.cors.methods`. One property is the prefix of another, so it may not be immediately evident how to specify both keys in your YAML configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Config 规范将配置键定义为任意的 `.` - 分隔字符串。然而，像 YAML 这样的结构化格式可能只支持配置命名空间的一个子集。例如，考虑有两个配置属性 `quarkus.http.cors` 和 `quarkus.http.cors.methods` 的情况。一个属性是另一个属性的前缀，因此如何在 YAML 配置中指定这两个键可能不是很明确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Micrometer extension automatically times HTTP server requests. Following Prometheus naming conventions for
timers, look for `http_server_requests_seconds_count`, `http_server_requests_seconds_sum`, and
`http_server_requests_seconds_max`. Dimensional labels have been added for the requested uri, the HTTP method
(GET, POST, etc.), the status code (200, 302, 404, etc.), and a more general outcome field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer扩展会自动为HTTP服务器请求计时。按照Prometheus对timers的命名惯例，查找 `http_server_requests_seconds_count` , `http_server_requests_seconds_sum` , 和 `http_server_requests_seconds_max` 。维度标签已经被添加到请求的URI、HTTP方法（GET、POST等）、状态代码（200、302、404等）和一个更通用的结果字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Micrometer extension automatically times HTTP server requests. Following Prometheus naming conventions for timers, look for `http_server_requests_seconds_count`, `http_server_requests_seconds_sum`, and `http_server_requests_seconds_max`. Dimensional labels have been added for the requested uri, the HTTP method (GET, POST, etc.), the status code (200, 302, 404, etc.), and a more general outcome field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer扩展会自动为HTTP服务器请求计时。按照Prometheus对timers的命名惯例，查找 `http_server_requests_seconds_count` , `http_server_requests_seconds_sum` , 和 `http_server_requests_seconds_max` 。维度标签已经被添加到请求的URI、HTTP方法（GET、POST等）、状态代码（200、302、404等）和一个更通用的结果字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting
the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At
`x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在打包之前，必须首先初始化 Microsoft Native Tools for Visual Studio。你可以通过启动与Visual Studio Build Tools 一起安装的 `x64 Native Tools Command Prompt` 来做到这一点。在 `x64 Native Tools Command Prompt` ，你可以导航到你的项目文件夹并运行 `mvnw package -Pnative` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At `x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在打包之前，必须首先初始化 Microsoft Native Tools for Visual Studio。你可以通过启动与Visual Studio Build Tools 一起安装的 `x64 Native Tools Command Prompt` 来做到这一点。在 `x64 Native Tools Command Prompt` ，你可以导航到你的项目文件夹并运行 `mvnw package -Pnative` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MongoDB reactive client uses Mutiny reactive types.
If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB的响应式客户端使用Mutiny响应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MongoDB reactive client uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB的响应式客户端使用Mutiny响应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny version of the Vert.x APIs also offers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny 版本的 Vert.x API 还提供：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The NVD CPE team updates the list regularly, but if you encounter a false positive, report the details by creating an issue in the link:https://github.com/quarkusio/quarkus/issues/2611[quarkusio] repository.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>NVD CPE团队会定期更新列表，但如果您遇到一个异常，请在 link:https://github.com/quarkusio/quarkus/issues/2611[quarkusio] 仓库中创建一个issue来报告细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenID Connect extension allows you to define the adapter configuration using the `application.properties` file which should be located at the `src/main/resources` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect扩展允许您使用 `application.properties` 来定义适配器配置，该文件应位于 `src/main/resources` 目录下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenTelemetry extension will use by default a random https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#id-generators[ID Generator]
when creating the trace and span identifier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry扩展将默认使用一个随机的 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#id-generators[ID发生器] 来创建trace和span标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenTelemetry extension will use by default a random https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#id-generators[ID Generator] when creating the trace and span identifier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry扩展将默认使用一个随机的 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#id-generators[ID发生器] 来创建trace和span标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The POJO Codec</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POJO编解码器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The POJO Codec have enhanced generic support via `PropertyCodecProvider`,
Quarkus will automatically register any `PropertyCodecProvider` with the POJO Codec (these classes are automatically made CDI beans of `@Singleton` scope).
When building native executables and using generic types, you might need to register the type arguments for reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POJO Codec通过 `PropertyCodecProvider` 增强了对泛型的支持，Quarkus会自动在POJO Codec中注册任何 `PropertyCodecProvider` （这些类会自动成为 `@Singleton` 范围的CDI bean）。当构建本地可执行文件和使用用泛型类型时，你可能需要用反射来注册类型参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The POJO Codec have enhanced generic support via `PropertyCodecProvider`, Quarkus will automatically register any `PropertyCodecProvider` with the POJO Codec (these classes are automatically made CDI beans of `@Singleton` scope).  When building native executables and using generic types, you might need to register the type arguments for reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POJO Codec通过 `PropertyCodecProvider` 增强了对泛型的支持，Quarkus会自动在POJO Codec中注册任何 `PropertyCodecProvider` （这些类会自动成为 `@Singleton` 范围的CDI bean）。当构建本地可执行文件和使用用泛型类型时，你可能需要用反射来注册类型参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The PojoCodecProvider: easy object to BSON document conversion.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PojoCodecProvider：简单的object（对象）到 BSON 文档的转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus JBeret Extension adds support for JSR-352 Batch Applications for the Java Platform. JBeret is an implementation of the JSR-352.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus JBeret Extension增加了对Java平台的JSR-352批处理应用的支持。JBeret是JSR-352的一个实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Micro Image is a small container image providing the right set of dependencies to run your native application.
It is based on https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro].
This base image has been tailored to work perfectly in containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 微镜像是一个小型的容器镜像，为运行你的原生应用程序提供了正确的依赖性集合。它是基于 https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro] 的。这个基础镜像已经被定制为在容器中完美运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Micro Image is a small container image providing the right set of dependencies to run your native application.  It is based on https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro].  This base image has been tailored to work perfectly in containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 微镜像是一个小型的容器镜像，为运行你的原生应用程序提供了正确的依赖性集合。它是基于 https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro] 的。这个基础镜像已经被定制为在容器中完美运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus `quarkus-oidc` extension provides a reactive, interoperable, multitenant-enabled OIDC adapter that supports Bearer Token and Authorization Code Flow authentication mechanisms.
The Bearer Token mechanism extracts the token from the HTTP Authorization header.
The Authorization Code Flow mechanism redirects the user to an OIDC provider to authenticate the identity of the user.
After the user is redirected back to Quarkus, the mechanism completes the authentication process by exchanging the provided code that was granted for the ID, access, and refresh tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` 扩展提供了一个响应式的、可互操作的、支持多租户的OIDC适配器，以支持 `Bearer Token` 和 `Authorization Code Flow` 认证机制。`Bearer Token` 机制从HTTP header中提取token。 `Authorization Code Flow` 机制将用户重定向到OIDC提供者来认证用户身份，并在用户被重定向回Quarkus后，通过将提供的代码授权与ID、访问和刷新token进行交换来完成认证过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus `quarkus-oidc` extension provides a reactive, interoperable, multitenant-enabled OIDC adapter that supports Bearer Token and Authorization Code Flow authentication mechanisms.  The Bearer Token mechanism extracts the token from the HTTP Authorization header.  The Authorization Code Flow mechanism redirects the user to an OIDC provider to authenticate the identity of the user.  After the user is redirected back to Quarkus, the mechanism completes the authentication process by exchanging the provided code that was granted for the ID, access, and refresh tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` 扩展提供了一个响应式的、可互操作的、支持多租户的OIDC适配器，以支持 `Bearer Token` 和 `Authorization Code Flow` 认证机制。`Bearer Token` 机制从HTTP header中提取token。 `Authorization Code Flow` 机制将用户重定向到OIDC提供者来认证用户身份，并在用户被重定向回Quarkus后，通过将提供的代码授权与ID、访问和刷新token进行交换来完成认证过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community publishes thoughtful how-to videos to help you get started. Check them out on &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;YouTube&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus社区发布了周到的操作视频，以帮助您开始使用。请在&lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;YouTube&lt;/a&gt;上查看它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus团队和社区非常重视所有的安全漏洞。你可以在这里找到关于我们的政策和安全披露的指导方针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quote object</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quote对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Reactive Messaging AMQP connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息AMQP连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis extension allows you to configure multiple clients.
Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis扩展允许你配置多个客户端。使用多个客户端与使用一个客户端的方式相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis extension allows you to configure multiple clients.  Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis扩展允许你配置多个客户端。使用多个客户端与使用一个客户端的方式相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The SockJS bridge provided by Vert.x allows browser applications and Quarkus applications to communicate using the event bus.
It connects both sides.
So, both sides can send messages received on the other side.
It supports the three delivery mechanisms.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x提供的SockJS桥允许浏览器应用程序和Quarkus应用程序使用事件总线进行通信。它连接了双方。所以，双方都可以发送在另一方收到的消息。它支持三种传递机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The SockJS bridge provided by Vert.x allows browser applications and Quarkus applications to communicate using the event bus.  It connects both sides.  So, both sides can send messages received on the other side.  It supports the three delivery mechanisms.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x提供的SockJS桥允许浏览器应用程序和Quarkus应用程序使用事件总线进行通信。它连接了双方。所以，双方都可以发送在另一方收到的消息。它支持三种传递机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The UBI minimal image is bigger than the micro one mentioned above.
It contains more utilities such as the `microdnf` package manager.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UBI最小镜像比上面提到的微镜像要大。它包含更多的实用程序，如 `microdnf` 软件包管理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The UBI minimal image is bigger than the micro one mentioned above.  It contains more utilities such as the `microdnf` package manager.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UBI最小镜像比上面提到的微镜像要大。它包含更多的实用程序，如 `microdnf` 软件包管理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL can now be updated during the deployment or at launch time using system properties or environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在可以在部署期间或在启动时使用系统属性或环境变量更新URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Web客户端是从 `io.vertx.mutiny.ext.web.client.WebClient` 创建的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The YAML configuration also support profile aware files. In this case, properties for a specific profile may reside in
an `application-{profile}.yaml` named file. The previous example may be expressed as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML 配置还支持环境配置文件的感知。在这种情况下，特定环境下的配置文件的属性可以书写在一个名为 `application-{profile}.yaml` 的文件中。前面的例子也可以表示为:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The YAML configuration also support profile aware files. In this case, properties for a specific profile may reside in an `application-{profile}.yaml` named file. The previous example may be expressed as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML 配置还支持环境配置文件的感知。在这种情况下，特定环境下的配置文件的属性可以书写在一个名为 `application-{profile}.yaml` 的文件中。前面的例子也可以表示为:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The YAML format also supports xref:config-reference.adoc#expressions[expressions], using the same format as Java
Properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML格式同时也支持 link:config-reference.html#expressions[表达式] ，使用与Java Properties相同的格式:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The YAML format also supports xref:config-reference.adoc#expressions[expressions], using the same format as Java Properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML格式同时也支持 link:config-reference.html#expressions[表达式] ，使用与Java Properties相同的格式:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_活跃性_ 检查可以捕获与Kafka通信过程中发生的任何不可恢复的故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _readiness_ check verifies that the Kafka connector is ready to consume/produce messages to the configured Kafka topics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_就绪_ 检查确保Kafka 连接器是否准备好针对配置的Kafka topic消费或生产消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _return_ value of a method annotated with `@ConsumeEvent` is used to respond to the incoming message.
For instance, in the following snippet, the returned `String` is the response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用 `@ConsumeEvent` 注解的方法的 _返回值_ 被用来响应传入的消息。例如，在下面的代码片段中，返回的 是 `String` 类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _return_ value of a method annotated with `@ConsumeEvent` is used to respond to the incoming message.  For instance, in the following snippet, the returned `String` is the response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用 `@ConsumeEvent` 注解的方法的 _返回值_ 被用来响应传入的消息。例如，在下面的代码片段中，返回的 是 `String` 类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _startup_ check verifies that the communication with Kafka cluster is established.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_启动_ 检查确保与Kafka集群的通信是否建立。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%prod` 前缀表示该属性只在应用程序运行在生产模式下时生效(而不是在开发或测试模式)。更多细节请参考 xref:config-reference.adoc#profiles[Profile documentation]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `-Dquarkus.native.container-build=true` instructs Quarkus to build Linux 64bits native executables, who can run inside containers.
Then, run the system using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`-Dquarkus.native.container-build=true` 指示Quarkus构建可以在容器中运行的64位Linux本地可执行文件。然后，使用以下命令运行系统：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `-Dquarkus.native.container-build=true` instructs Quarkus to build Linux 64bits native executables, who can run inside containers.  Then, run the system using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`-Dquarkus.native.container-build=true` 指示Quarkus构建可以在容器中运行的64位Linux本地可执行文件。然后，使用以下命令运行系统：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `.onItem().transform(...)` can be replaced with `.map(...)`.
`map` is a shortcut.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.onItem().transform(...)`  可以用 `.map(...)` 取代。`map` 是它的快捷方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `.onItem().transform(...)` can be replaced with `.map(...)`.  `map` is a shortcut.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.onItem().transform(...)`  可以用 `.map(...)` 取代。`map` 是它的快捷方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) and only users granted with the `admin` role can access it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/admin` 节点受到RBAC（基于角色的访问控制）的保护，只有被授予 `admin` 角色的用户才能访问它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) where only users granted with the `admin` role can access. At this endpoint, we use the `@RolesAllowed` annotation to declaratively enforce the access constraint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>端点 `/api/admin` 受到RBAC（基于角色的访问控制）的保护，只有被授予 `admin` 角色的用户可以访问。在这个端点，我们使用 `@RolesAllowed` 注解来声明性地执行访问限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/users/me` endpoint can be accessed by any user with a valid token.
As a response, it returns a JSON document with details about the user where these details are obtained from the information carried on the token.
This endpoint is protected with RBAC (Role-Based Access Control) and only users granted with the `user` role can access this endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/users/me` 节点可由任何拥有有效token的用户访问。作为响应，它返回一个JSON文档，其中包含关于用户的详细信息，这些详细信息是从token上的信息中获得的。这个节点受到RBAC（基于角色的访问控制）的保护，只有被授予 `user` 角色的用户才能访问这个节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/users/me` endpoint can be accessed by any user with a valid token.  As a response, it returns a JSON document with details about the user where these details are obtained from the information carried on the token.  This endpoint is protected with RBAC (Role-Based Access Control) and only users granted with the `user` role can access this endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/users/me` 节点可由任何拥有有效token的用户访问。作为响应，它返回一个JSON文档，其中包含关于用户的详细信息，这些详细信息是从token上的信息中获得的。这个节点受到RBAC（基于角色的访问控制）的保护，只有被授予 `user` 角色的用户才能访问这个节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/users/me` endpoint can be accessed by any user with a valid token. As a response, it returns a JSON document with details about the user where these details are obtained from the information carried on the token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>端点 `/api/users/me` 可由任何拥有有效令牌的用户访问。作为响应，它返回一个JSON文档，其中包含关于用户的细节，这些细节是从令牌上携带的信息获得的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/subject/denied` endpoint disallows any access regardless of whether the call is authenticated by specifying the `@DenyAll` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/subject/denied` 节点使用了 `@DenyAll` 注解，所以不允许任何访问，即使访问是认证过的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/subject/unsecured` endpoint allows for unauthenticated access by specifying the `@PermitAll` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/subject/unsecured` 节点通过使用 `@PermitAll` 注解来允许未认证的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@BsonId` annotation is used instead of `@BsonProperty("_id")` for brevity's sake, but use of either is valid.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了简洁起见，使用了 `@BsonId` 注解，而不是 `@BsonProperty("_id")` ，但使用其中任何一种都是有效的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@ConsumeEvent` annotation can be configured to set the address:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以配置 `@ConsumeEvent` 注解设置地址：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@MongoEntity` annotation allows configuring:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@MongoEntity` 注解允许根据以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@NonBlocking` annotation is only required with SmallRye Fault Tolerance 5.1.0 and earlier.
Starting with SmallRye Fault Tolerance 5.2.0 (available since Quarkus 2.1.0.Final), it is not necessary.
See https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Tolerance documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@NonBlocking` 注解仅在SmallRye Fault Tolerance 5.1.0及之前版本中需要。从SmallRye Fault Tolerance 5.2.0开始(Quarkus 2.1.0.Final开始)，它就不再必须了。更多信息请参见link:https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye 容错文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@NonBlocking` annotation is only required with SmallRye Fault Tolerance 5.1.0 and earlier.  Starting with SmallRye Fault Tolerance 5.2.0 (available since Quarkus 2.1.0.Final), it is not necessary.  See https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Tolerance documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@NonBlocking` 注解仅在SmallRye Fault Tolerance 5.1.0及之前版本中需要。从SmallRye Fault Tolerance 5.2.0开始(Quarkus 2.1.0.Final开始)，它就不再必须了。更多信息请参见link:https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye 容错文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@ReactiveTransactional` annotation will also work for testing.
This means that changes done during the test will be propagated to the database.
If you want any changes made to be rolled back at the end of
the test you can use the `io.quarkus.test.TestReactiveTransaction` annotation.
This will run the test method in a transaction, but roll it back once the test method is
complete to revert any database changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ReactiveTransactional` 注解也可用于测试。这意味着在测试期间所做数据变更将被持久化到数据库中。如果你想在测试结束时回滚所有数据库变更，可以使用 `io.quarkus.test.TestReactiveTransaction` 注解。加入这个注解后将在一个事务中运行测试方法，当测试方法完成，就会回滚事务，以恢复所有数据库的变更。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@ReactiveTransactional` annotation will also work for testing.  This means that changes done during the test will be propagated to the database.  If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestReactiveTransaction` annotation.  This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ReactiveTransactional` 注解也可用于测试。这意味着在测试期间所做数据变更将被持久化到数据库中。如果你想在测试结束时回滚所有数据库变更，可以使用 `io.quarkus.test.TestReactiveTransaction` 注解。加入这个注解后将在一个事务中运行测试方法，当测试方法完成，就会回滚事务，以恢复所有数据库的变更。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterForReflection` annotation instructs Quarkus to include the class (including fields and methods) when building the native executable.
This will be useful later when we run the applications as native executables inside containers.
Without, the native compilation would remove the fields and methods during the dead-code elimination phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterForReflection` 注释指示Quarkus在构建本地可执行文件时包含类（包括字段和方法）。这在以后我们在容器中作为本地可执行文件运行应用程序时将会很有用。如果没有这个注释，本地编译会在死代码清除阶段删除这些字段和方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterForReflection` annotation instructs Quarkus to include the class (including fields and methods) when building the native executable.  This will be useful later when we run the applications as native executables inside containers.  Without, the native compilation would remove the fields and methods during the dead-code elimination phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterForReflection` 注释指示Quarkus在构建本地可执行文件时包含类（包括字段和方法）。这在以后我们在容器中作为本地可执行文件运行应用程序时将会很有用。如果没有这个注释，本地编译会在死代码清除阶段删除这些字段和方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterForReflection` annotation instructs Quarkus to keep the class and its members during the native compilation.
More details about the `@RegisterForReflection` annotation can be found on the xref:writing-native-applications-tips.adoc#registerForReflection[native application tips] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterForReflection` 注解用于指导Quarkus在native编译过程中保留该类和其成员。关于 `@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips.html#registerForReflection[native应用程序提示] 页面找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterForReflection` annotation instructs Quarkus to keep the class and its members during the native compilation. More details about the `@RegisterForReflection` annotation can be found on  the xref:writing-native-applications-tips.adoc#registerForReflection[native application tips] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterForReflection` 注解用于指导Quarkus在native编译过程中保留该类和其成员。关于 `@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips.html#registerForReflection[native应用程序提示] 页面找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterForReflection` annotation instructs Quarkus to keep the class and its members during the native compilation. More details about the `@RegisterForReflection` annotation can be found on the xref:writing-native-applications-tips.adoc#registerForReflection[native application tips] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterForReflection` 注解用于指导Quarkus在native编译过程中保留该类和其成员。关于 `@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips.html#registerForReflection[native应用程序提示] 页面找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterRestClient` 在运行时注册了rest-client的实现，并且由于bean需要保证使用了一个正常的scope，您必须使用 `@ApplicationScoped` 来注释您的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@TransactionConfiguration` annotation allows to set a timeout property, in seconds, that applies to transactions created within the annotated method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@TransactionConfiguration` 注解允许设置一个超时属性，以秒为单位，适用于在注解方法中创建的事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Emitter` 的配置方式与 其他被 `@Incoming` 和 `@Outgoing` 使用的流配置相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `EventBus` object provides methods to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`EventBus` 对象提供了以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Fruit` objects will be automatically serialized/deserialized by https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] or https://github.com/FasterXML/jackson[Jackson],
depending on the extension you chose when initializing the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Fruit` 对象将被 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] 或 link:https://github.com/FasterXML/jackson[Jackson] 自动序列化/反序列化，这取决于你在初始化项目时选择的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Fruit` objects will be automatically serialized/deserialized by https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] or https://github.com/FasterXML/jackson[Jackson], depending on the extension you chose when initializing the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Fruit` 对象将被 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] 或 link:https://github.com/FasterXML/jackson[Jackson] 自动序列化/反序列化，这取决于你在初始化项目时选择的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GreetingService` bean will be injected into the test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GreetingService` bean将被注入到测试类中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `HttpAuthenticationMechanism` interface is the main entry mechanism for securing HTTP applications in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`HttpAuthenticationMechanism` 接口是Quarkus 保护HTTP 程序安全的主要入口机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `JsonWebToken` interface defines methods for accessing claims in the underlying JWT.
It provides accessors for common claims that are required by the {mp-jwt} specification as well as arbitrary claims that may exist in the JWT.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `JsonWebToken` 接口定义了用于访问底层JWT中的声明(claims)的方法。它为{mp-jwt}规范所要求的共同声明(common claims)以及JWT中可能存在的任何的声明提供访问器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `JsonWebToken` interface defines methods for accessing claims in the underlying JWT. It provides accessors for common
claims that are required by the {mp-jwt} specification as well as arbitrary claims that may exist in the JWT.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `JsonWebToken` 接口定义了用于访问底层JWT中的声明(claims)的方法。它为{mp-jwt}规范所要求的共同声明(common claims)以及JWT中可能存在的任何的声明提供访问器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `JsonWebToken` interface defines methods for accessing claims in the underlying JWT. It provides accessors for common claims that are required by the {mp-jwt} specification as well as arbitrary claims that may exist in the JWT.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `JsonWebToken` 接口定义了用于访问底层JWT中的声明(claims)的方法。它为{mp-jwt}规范所要求的共同声明(common claims)以及JWT中可能存在的任何的声明提供访问器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KafkaClientService` is an experimental API and can change in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KafkaClientService` 是一个实验性的API，在未来可能会发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KafkaTransactions#withTransactionAndAck` method acks and nacks the message but will *not* return a failing `Uni`.
Nacked messages will be handled by the failure strategy of the incoming channel, (see &lt;&lt;error-handling&gt;&gt;).
Configuring `failure-strategy=ignore` simply resets the Kafka consumer to the last committed offsets and resumes the consumption from there.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KafkaTransactions#withTransactionAndAck` 方法确认和确认消息，但 *不会* 返回失败的 `Uni` 。 Nacked 消息将由传入通道的故障策略处理，（参见&lt;&lt;error-handling&gt;&gt;）。 配置 `failure-strategy=ignore` 只是将 Kafka 消费者重置为最后提交的偏移量并从那里恢复消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KafkaTransactions#withTransactionAndAck` method acks and nacks the message but will *not* return a failing `Uni`.  Nacked messages will be handled by the failure strategy of the incoming channel, (see &lt;&lt;error-handling&gt;&gt;).  Configuring `failure-strategy=ignore` simply resets the Kafka consumer to the last committed offsets and resumes the consumption from there.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KafkaTransactions#withTransactionAndAck` 方法确认和确认消息，但 *不会* 返回失败的 `Uni` 。 Nacked 消息将由传入通道的故障策略处理，（参见&lt;&lt;error-handling&gt;&gt;）。 配置 `failure-strategy=ignore` 只是将 Kafka 消费者重置为最后提交的偏移量并从那里恢复消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KafkaTransactions` custom emitter provides a way to apply exactly-once processing to an incoming Kafka message inside a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KafkaTransactions` 定制emitter可以提供一种对事务中传入的 Kafka 消息进行一次性处理的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KubernetesServerTestResource` class has to implement the
`QuarkusTestResourceConfigurableLifecycleManager` interface in order to be configured using the previous annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KubernetesServerTestResource` 类必须实现 `QuarkusTestResourceConfigurableLifecycleManager` 接口，以便使用前面的注解进行配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KubernetesServerTestResource` class has to implement the `QuarkusTestResourceConfigurableLifecycleManager` interface in order to be configured using the previous annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KubernetesServerTestResource` 类必须实现 `QuarkusTestResourceConfigurableLifecycleManager` 接口，以便使用前面的注解进行配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually.
We'll explore different acknowledgment strategies in &lt;&lt;commit-strategies&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Message` 类型允许consuming methond访问接收到消息的metadata并手动进行确认。我们将在 &lt;&lt;commit-strategies&gt;&gt;中探讨不同的确认策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually.  We'll explore different acknowledgment strategies in &lt;&lt;commit-strategies&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Message` 类型允许consuming methond访问接收到消息的metadata并手动进行确认。我们将在 &lt;&lt;commit-strategies&gt;&gt;中探讨不同的确认策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `PanacheQuery` type has many other methods to deal with paging and returning streams.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PanacheQuery` 类型有许多其他方法来处理分页和返回流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Price` instances are automatically encoded to JSON by the connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Price` 实例被连接器自动编码为JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Quote` class will be used in both `producer` and `processor` projects.
For the sake of simplicity we will duplicate the class.
In both projects, create the `src/main/java/org/acme/amqp/model/Quote.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Quote` 类将用在 `producer` 和 `processor` 项目中。为了简单起见，我们将重复这个类。在两个项目中，创建 `src/main/java/org/acme/amqp/model/Quote.java` 文件，其内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Quote` class will be used in both `producer` and `processor` projects.  For the sake of simplicity we will duplicate the class.  In both projects, create the `src/main/java/org/acme/amqp/model/Quote.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Quote` 类将用在 `producer` 和 `processor` 项目中。为了简单起见，我们将重复这个类。在两个项目中，创建 `src/main/java/org/acme/amqp/model/Quote.java` 文件，其内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingService` 类包含一个生成 `Uni` 的简单方法。虽然在这个例子中，产生的条目是立即发出的，你可以想象任何异步API产生一个 `Uni`。我们将在本指南的后面讨论这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `RedisClient` and `ReactiveRedisClient` provide factory methods to create clients programmatically.
The client to be created are configured using the usual &lt;&lt;config-reference,Redis configuration&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisClient` 和 `ReactiveRedisClient` 提供工厂方法，以便用编程方式创建客户端。这样可以创建出使用常规 link:#config-reference[Redis配置] 的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `RedisClient` and `ReactiveRedisClient` provide factory methods to create clients programmatically.  The client to be created are configured using the usual &lt;&lt;config-reference,Redis configuration&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisClient` 和 `ReactiveRedisClient` 提供工厂方法，以便用编程方式创建客户端。这样可以创建出使用常规 link:#config-reference[Redis配置] 的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `RedisHostsProvider` programmatically provides redis hosts.
This allows for configuration of properties like redis connection password coming from other sources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisHostsProvider` 接口支持以编程方式设定Redis主机。这个机制支持了从其他来源获取Redis连接属性进行配置，如Redis连接密码等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `RedisHostsProvider` programmatically provides redis hosts.  This allows for configuration of properties like redis connection password coming from other sources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisHostsProvider` 接口支持以编程方式设定Redis主机。这个机制支持了从其他来源获取Redis连接属性进行配置，如Redis连接密码等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `RedisHostsProvider` programmatically provides redis hosts. This allows for configuration of properties like redis connection password coming from other sources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisHostsProvider` 接口支持以编程方式设定Redis主机。这个机制支持了从其他来源获取Redis连接属性进行配置，如Redis连接密码等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Sort` class has plenty of methods for adding columns and specifying sort direction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Sort` 类有很多方法用于添加列和指定排序方向。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Uni` returned from the `KafkaTransactions#withTransaction` will yield a failure if the transaction fails and is aborted.
The application can choose to handle the error case, but if a failing `Uni` is returned from the `@Incoming` method, the incoming channel will effectively fail and stop the reactive stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果事务失败并被中止，则从 KafkaTransactions#withTransaction 返回的 `Uni` 将产生失败。 应用程序可以选择处理错误情况，但如果从 `@Incoming` 方法返回失败的 `Uni` ，则传入通道将有效地失败并停止响应流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Uni` returned from the `KafkaTransactions#withTransaction` will yield a failure if the transaction fails and is aborted.  The application can choose to handle the error case, but if a failing `Uni` is returned from the `@Incoming` method, the incoming channel will effectively fail and stop the reactive stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果事务失败并被中止，则从 KafkaTransactions#withTransaction 返回的 `Uni` 将产生失败。 应用程序可以选择处理错误情况，但如果从 `@Incoming` 方法返回失败的 `Uni` ，则传入通道将有效地失败并停止响应流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Value` attribute is the root URL for your lambda. Copy it to your browser and add `hello` at the end.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Value` 属性是你的lambda的根URL。把它复制到你的浏览器，并在末尾添加 `hello` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `application.yaml` file may also be placed in `config/application.yaml` to specialize the runtime configuration. The
file has to be present in the root of the working directoryrelative to the Quarkus application runner:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.yaml` 文件也可以放在 `config/application.yaml` 中，以专门实现运行时的配置。该文件必须存在于相对Quarkus应用运行程序的工作目录的根目录中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `application.yaml` file may also be placed in `config/application.yaml` to specialize the runtime configuration. The file has to be present in the root of the working directoryrelative to the Quarkus application runner:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.yaml` 文件也可以放在 `config/application.yaml` 中，以专门实现运行时的配置。该文件必须存在于相对Quarkus应用运行程序的工作目录的根目录中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `b3`, `b3multi`, `jaeger` and `ottrace` propagators will need the https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/trace-propagators[trace-propagators]
extension to be added as a dependency to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`b3` , `b3multi` , `jaeger` 和 `ottrace` propatagors 需要将 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/trace-propagators[trace-propagators] 扩展作为一个依赖添加到您的项目中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `b3`, `b3multi`, `jaeger` and `ottrace` propagators will need the https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/trace-propagators[trace-propagators] extension to be added as a dependency to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`b3` , `b3multi` , `jaeger` 和 `ottrace` propatagors 需要将 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/trace-propagators[trace-propagators] 扩展作为一个依赖添加到您的项目中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `birthday` claim. It can be considered to be a sensitive claim, so you may want to consider encrypting the claims, see xref:security-jwt-build.adoc[Generate JWT tokens with SmallRye JWT].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `birthday` 声明(claim)，它可以被认为是一个敏感的声明，所以你可能要考虑对这些声明进行加密， link:smallrye-jwt-build.html[见用SmallRye JWT生成JWT令牌] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`channel-name` 片段必须与 `@Incoming` 和 `@Outgoing` 注解中设定的值相匹配:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `create` method allows adding a new fruit to the database:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`create` 方法允许向数据库中添加新水果记录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `default-kafka-broker` configuration map contains all application properties prefixed with `kafka.` or `KAFKA_`.
For more configuration options check out &lt;&lt;kafka-configuration-resolution&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`default-kafka-broker` 配置map包含所有以 `kafka.` 或 `KAFKA_` 为前缀的应用属性。更多的配置选项，请查看 link:#kafka-configuration-resolution[[kafka配置方案]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `default-kafka-broker` configuration map contains all application properties prefixed with `kafka.` or `KAFKA_`.  For more configuration options check out &lt;&lt;kafka-configuration-resolution&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`default-kafka-broker` 配置map包含所有以 `kafka.` 或 `KAFKA_` 为前缀的应用属性。更多的配置选项，请查看 link:#kafka-configuration-resolution[[kafka配置方案]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `get()` method allows retrieving the current value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`get()` 方法允许检索当前值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `group` claim provides the groups and top-level roles associated with the JWT bearer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `group` 声明(claim)提供了与JWT bearer相关的group和最高级别的role。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `http://localhost:8080/api/admin` endpoint can only be accessed by users with the `admin` role.
If you try to access this endpoint with the previously issued access token, you should get a `403` response from the server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该 `http://localhost:8080/api/admin` 端点只能由具有 `admin` 角色的用户访问。如果你试图用先前发布的访问令牌访问这个端点，你应该会从服务器上得到一个 `403` 的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `http://localhost:8080/api/admin` endpoint can only be accessed by users with the `admin` role.  If you try to access this endpoint with the previously issued access token, you should get a `403` response from the server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;a href="http://localhost:8080/api/admin" class="bare"&gt;http://localhost:8080/api/admin&lt;/a&gt;` 节点只能由具有 `admin` 角色的用户访问。如果您试图用先前发放的access token访问这个节点，您将会得到一个 `403` 的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `http://localhost:8080/api/admin` endpoint can only be accessed by users with the `admin` role. If you try to access this endpoint with the
 previously issued access token, you should get a `403` response
 from the server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该 `http://localhost:8080/api/admin` 端点只能由具有 `admin` 角色的用户访问。如果你试图用先前发布的访问令牌访问这个端点，你应该会从服务器上得到一个 `403` 的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `http://localhost:8080/api/admin` endpoint can only be accessed by users with the `admin` role. If you try to access this endpoint with the
 previously issued access token, you should get a `403` response
 from the server.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该 `http://localhost:8080/api/admin` 端点只能由具有 `admin` 角色的用户访问。如果你试图用先前发布的访问令牌访问这个端点，你应该会从服务器上得到一个 `403` 的响应。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `init` method receives an `Instance&lt;MyVerticle&gt;`.
Then, you pass a supplier to the `deployVerticle` method.
The supplier is just calling the `get()` method.
Thanks to the `@Dependent` scope, it returns a new instance on every call.
Finally, you pass the desired number of instances to the `DeploymentOptions`, such as two in the previous example.
It will call the supplier twice, which will create two instances of your verticle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`init` 方法接收一个 `Instance&lt;MyVerticle&gt;` 。然后，你将提供者传递给 `deployVerticle` 方法。该提供者只是在调用 `get()` 方法。由于 `@Dependent` 范围，它每次调用都会返回一个新的实例。最后，你向 `DeploymentOptions` 传递所需的实例数量，比如在前面的例子中是两个。它将调用提供者两次，这将为你的verticle创建两个实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `init` method receives an `Instance&lt;MyVerticle&gt;`.  Then, you pass a supplier to the `deployVerticle` method.  The supplier is just calling the `get()` method.  Thanks to the `@Dependent` scope, it returns a new instance on every call.  Finally, you pass the desired number of instances to the `DeploymentOptions`, such as two in the previous example.  It will call the supplier twice, which will create two instances of your verticle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`init` 方法接收一个 `Instance&lt;MyVerticle&gt;` 。然后，你将提供者传递给 `deployVerticle` 方法。该提供者只是在调用 `get()` 方法。由于 `@Dependent` 范围，它每次调用都会返回一个新的实例。最后，你向 `DeploymentOptions` 传递所需的实例数量，比如在前面的例子中是两个。它将调用提供者两次，这将为你的verticle创建两个实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.mongodb.ReactiveMongoClient` client is deprecated and will be removed in the future.
It is recommended to switch to the `io.quarkus.mongodb.reactive.ReactiveMongoClient` client providing the `Mutiny` API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.mongodb.ReactiveMongoClient` 客户端已被废弃，并将在未来被删除。建议切换到提供 `Mutiny` API的 `io.quarkus.mongodb.reactive.ReactiveMongoClient` 客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.mongodb.ReactiveMongoClient` client is deprecated and will be removed in the future.  It is recommended to switch to the `io.quarkus.mongodb.reactive.ReactiveMongoClient` client providing the `Mutiny` API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.mongodb.ReactiveMongoClient` 客户端已被废弃，并将在未来被删除。建议切换到提供 `Mutiny` API的 `io.quarkus.mongodb.reactive.ReactiveMongoClient` 客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped
bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class,
while if you use this in a test method the mock will only take effect for the duration of the current test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.QuarkusMock` 类可以被用来临时mock任何正常scope的bean。如果您在 `@BeforeAll` 方法中使用这个方法，mock将对当前类的所有测试生效，而如果您在测试方法中使用这个方法，mock将只在当前测试方法范围内生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class, while if you use this in a test method the mock will only take effect for the duration of the current test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.QuarkusMock` 类可以被用来临时mock任何正常scope的bean。如果您在 `@BeforeAll` 方法中使用这个方法，mock将对当前类的所有测试生效，而如果您在测试方法中使用这个方法，mock将只在当前测试方法范围内生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.annotations.Emitter` , `io.smallrye.reactive.messaging.annotations.Channel` 和 `io.smallrye.reactive.messaging.annotations.OnOverflow` 类现在已被废弃，并被替换为：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `iss` claim is the issuer of the JWT. This needs to match the server side `mp.jwt.verify.issuer`.
in order for the token to be accepted as valid.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `iss` 声明(claim)是JWT的发行者。这需要与服务器端的 `mp.jwt.verify.issuer` 符合。一遍使令牌被接受为有效的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `iss` claim is the issuer of the JWT. This needs to match the server side `mp.jwt.verify.issuer`.  in order for the token to be accepted as valid.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `iss` 声明(claim)是JWT的发行者。这需要与服务器端的 `mp.jwt.verify.issuer` 符合。一遍使令牌被接受为有效的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `kotlin-maven-plugin` is configured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin-maven-plugin` ，其配置如下。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `kotlin-stdlib-jdk8` is also added as a dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin-stdlib-jdk8` 也作为依赖被添加进来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `mapTo` method uses the Quarkus Jackson mapper. Check xref:rest-json.adoc#json[this guide] to learn more about the mapper configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mapTo` 方法使用Quarkus Jackson 映射器。请查看 link:rest-json.html#json[本指南] 以了解更多关于映射器的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `mockableBean1` is configured here for every test method of the class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mockableBean1` 被mockito配置并可以为类的每个测试方法所用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `mp.jwt.verify.publickey` config property allows the Public Key text itself to be supplied as a string.  The Public Key will be parsed from the supplied string in the order defined in section &lt;&lt;Supported Public Key Formats&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `mp.jwt.verify.publickey` 配置属性允许将公钥文本本身作为一个字符串提供。公钥将按照 &lt;&lt;支持的公钥格式&gt;&gt; 一节中所定义的顺序，从提供的字符串中解析出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `ownerName` DTO constructor's parameter will be loaded from the `owner.name` HQL property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DTO构造器的 `ownerName` 参数将从 `owner.name` HQL属性加载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `pom.xml` file contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` 文件包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `process` method is called for every AMQP message from the `quote-requests` queue, and will send a `Quote` object to the `quotes` queue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`process` 方法被 `quote-requests` 队列中的每一个AMQP消息调用，并将 `Quote` 对象发送给 `quotes` 队列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension allows you to use Quarkus to build your AWS Lambdas.
Your lambdas can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-amazon-lambda` 扩展允许你使用Quarkus来构建你的AWS Lambdas。你的Lambdas可以根据需要使用来自CDI或Spring的注入注解，以及其他Quarkus设施。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension allows you to use Quarkus to build your AWS Lambdas.  Your lambdas can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-amazon-lambda` 扩展允许你使用Quarkus来构建你的AWS Lambdas。你的Lambdas可以根据需要使用来自CDI或Spring的注入注解，以及其他Quarkus设施。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler` interface.
It must find a class in your project that implements this interface or it will throw a build time failure.
If it finds more than one handler class, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-amazon-lambda` 扩展会为直接实现亚马逊 `RequestHandler&lt;?, ?&gt;` 或 `RequestStreamHandler` 接口的类扫描你的项目。它必须在你的项目中找到一个实现该接口的类，否则它将抛出一个构建时间失败。如果它发现一个以上的处理程序类，也会抛出一个构建时间异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler` interface.  It must find a class in your project that implements this interface or it will throw a build time failure.  If it finds more than one handler class, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-amazon-lambda` 扩展会为直接实现亚马逊 `RequestHandler&lt;?, ?&gt;` 或 `RequestStreamHandler` 接口的类扫描你的项目。它必须在你的项目中找到一个实现该接口的类，否则它将抛出一个构建时间失败。如果它发现一个以上的处理程序类，也会抛出一个构建时间异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-keycloak-authorization` extension is based on `quarkus-oidc` and provides a policy enforcer that enforces access to protected resources based on permissions managed by Keycloak and currently can only be used with the Quarkus xref:security-openid-connect.adoc[OIDC service applications].
It provides a flexible and dynamic authorization capability based on Resource-Based Access Control.
In other words, instead of explicitly enforcing access based on some specific access control mechanism (e.g.: RBAC), you just check whether a request is allowed to access a resource based on its name, identifier or URI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-keycloak-authorization` 扩展基于 `quarkus-oidc` ，并提供了一个策略实施者(policy enforcer)来根据Keycloak管理的权限去实施对受保护资源的访问。它目前只能与Quarkus link:security-openid-connect.html[OIDC服务应用] 一起使用。它提供了一个基于资源访问控制的灵活和动态的授权能力。换句话说，您不需要明确地根据一些特定的访问控制机制（例如：RBAC）来执行访问，而只需要根据资源的名称、标识或URI来检查一个请求是否被允许访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-kotlin` artifact is added to the dependencies. This artifact provides support for Kotlin in the live reload mode (more about this later on)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-kotlin` 会被添加到依赖项中。这个依赖提供了对实时重载模式下的Kotlin的支持（后面会有更多关于这个的介绍）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-oidc-client-filter` extension requires the `quarkus-oidc-client` extension and provides JAX-RS `OidcClientRequestFilter`, which sets the access token acquired by `OidcClient` as the `Bearer` scheme value of the HTTP `Authorization` header.
This filter can be registered with MP RestClient implementations injected into the current Quarkus endpoint, but it is not related to the authentication requirements of this service endpoint.
For example, it can be a public endpoint, or it can be protected with mTLS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-client-filter` 扩展依赖于 `quarkus-oidc-client` 扩展，并提供 JAX-RS `OidcClientRequestFilter` ，它将由 `OidcClient` 获得的访问token设置为 HTTP `Authorization` 头的 `Bearer` scheme值。这个过滤器可以与注入当前 Quarkus 节点的 MP RestClient 实现一起被注册，但它与这个服务节点的认证要求无关。例如，它可以是一个公共节点，也可以用mTLS保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-oidc-client-filter` extension requires the `quarkus-oidc-client` extension and provides JAX-RS `OidcClientRequestFilter`, which sets the access token acquired by `OidcClient` as the `Bearer` scheme value of the HTTP `Authorization` header.  This filter can be registered with MP RestClient implementations injected into the current Quarkus endpoint, but it is not related to the authentication requirements of this service endpoint.  For example, it can be a public endpoint, or it can be protected with mTLS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-client-filter` 扩展依赖于 `quarkus-oidc-client` 扩展，并提供 JAX-RS `OidcClientRequestFilter` ，它将由 `OidcClient` 获得的访问token设置为 HTTP `Authorization` 头的 `Bearer` scheme值。这个过滤器可以与注入当前 Quarkus 节点的 MP RestClient 实现一起被注册，但它与这个服务节点的认证要求无关。例如，它可以是一个公共节点，也可以用mTLS保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-oidc-client` extension provides `OidcClient` for acquiring and refreshing access tokens from OpenID Connect and OAuth2 providers that support the following token grants:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-client` 扩展提供 `OidcClient` ，用于从支持以下token授权的OpenID Connect和OAuth2提供者那里获取和刷新访问token：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-oidc-token-propagation` extension requires the `quarkus-oidc` extension and provides JAX-RS `TokenCredentialRequestFilter`, which sets the OpenID Connect Bearer or Authorization Code Flow access token as the `Bearer` scheme value of the HTTP `Authorization` header.
This filter can be registered with MP RestClient implementations injected into the current Quarkus endpoint, which in turn must be protected by using the Quarkus OpenID Connect adapter.
This filter can be used to propagate the access token to the downstream services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-token-propagation` 扩展依赖于 `quarkus-oidc` 扩展，并提供 JAX-RS  `TokenCredentialRequestFilter` ，它将 OpenID Connect Bearer 或 Authorization Code Flow 访问token设置为 HTTP `Authorization` 头的 `Bearer` scheme值。这个过滤器可以与注入当前 Quarkus 节点的 MP RestClient 实现一起被注册，并且Quarkus节点本身必须用Quarkus OpenID Connect适配器来保护。这个过滤器可以用来将访问token传播到下游服务中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-oidc-token-propagation` extension requires the `quarkus-oidc` extension and provides JAX-RS `TokenCredentialRequestFilter`, which sets the OpenID Connect Bearer or Authorization Code Flow access token as the `Bearer` scheme value of the HTTP `Authorization` header.  This filter can be registered with MP RestClient implementations injected into the current Quarkus endpoint, which in turn must be protected by using the Quarkus OpenID Connect adapter.  This filter can be used to propagate the access token to the downstream services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-token-propagation` 扩展依赖于 `quarkus-oidc` 扩展，并提供 JAX-RS  `TokenCredentialRequestFilter` ，它将 OpenID Connect Bearer 或 Authorization Code Flow 访问token设置为 HTTP `Authorization` 头的 `Bearer` scheme值。这个过滤器可以与注入当前 Quarkus 节点的 MP RestClient 实现一起被注册，并且Quarkus节点本身必须用Quarkus OpenID Connect适配器来保护。这个过滤器可以用来将访问token传播到下游服务中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-smallrye-jwt` extension provides a MicroProfile JSON Web Token (JWT) 1.2.1 implementation and multiple options to verify signed and encrypted `JWT` tokens and represents them as `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` 提供Microprofile JWT 1.2.1的实现和更多的选项来验证签名和加密的 `JWT` token，并将其表示为 `org.eclipse.microprofile.jwt.JsonWebToken`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.http.root-path` configuration property is used to change the xref:http-reference.adoc#context-path[http endpoint context path].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.root-path` 配置项被用于改变 link:http-reference.html#context-path[http节点上下文路径] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.lambda.handler` property tells Quarkus which lambda handler to deploy. This can be overridden
with an environment variable too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.lambda.handler` 属性告诉Quarkus要部署哪个lambda处理程序。这也可以用一个环境变量来覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.lambda.handler` property tells Quarkus which lambda handler to deploy. This can be overridden with an environment variable too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.lambda.handler` 属性告诉Quarkus要部署哪个lambda处理程序。这也可以用一个环境变量来覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.mongodb.database` property will be used by MongoDB with Panache to determine the name of the database where your entities will be persisted (if not overridden by `@MongoEntity`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB将使用 `quarkus.mongodb.database` 属性和Panache来确定实体将持久化的数据库的名称。（如果没有被 `@MongoEntity` 重写）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quote-requests` channel is going to be managed as a AMQP queue, as that's the only connector on the classpath.
If not indicated otherwise, like in this example, Quarkus uses the channel name as AMQP queue name.
So, in this example, the application sends messages to the `quote-requests` queue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quote-requests` 通道将被作为一个AMQP队列来管理，因为这是classpath上唯一的连接器。如果没有另行说明，如本例中所示，Quarkus将使用通道名称作为AMQP队列名称。因此，在本例中，应用程序将消息发送给 `quote-requests` 队列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quote-requests` channel is going to be managed as a AMQP queue, as that's the only connector on the classpath.  If not indicated otherwise, like in this example, Quarkus uses the channel name as AMQP queue name.  So, in this example, the application sends messages to the `quote-requests` queue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quote-requests` 通道将被作为一个AMQP队列来管理，因为这是classpath上唯一的连接器。如果没有另行说明，如本例中所示，Quarkus将使用通道名称作为AMQP队列名称。因此，在本例中，应用程序将消息发送给 `quote-requests` 队列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are
going to craft your own custom `sam.yaml` deployment files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.yaml` 语法已经超出了本文档的范围。有几件事情必须强调，以防你要制作你自己的自定义 `sam.yaml` 部署文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.yaml` 语法已经超出了本文档的范围。有几件事情必须强调，以防你要制作你自己的自定义 `sam.yaml` 部署文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `send` method writes records to Kafka inside the transaction, without waiting for send receipt from the broker.
Messages pending to be written to Kafka will be buffered, and flushed before committing the transaction.
It is therefore recommended configuring the `@OnOverflow` `bufferSize` in order to fit enough messages, for example the `max.poll.records`, maximum amount of records returned in a batch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`send` 方法将记录通过事务写入 Kafka，而无需等待来自代理的发送回执。 等待写入 Kafka 的消息将被缓冲，并在提交事务之前刷新。 因此，建议配置 `@OnOverflow` `bufferSize` 以适应足够的消息，例如 `max.poll.records`，即批处理中返回的最大记录数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `send` method writes records to Kafka inside the transaction, without waiting for send receipt from the broker.  Messages pending to be written to Kafka will be buffered, and flushed before committing the transaction.  It is therefore recommended configuring the `@OnOverflow` `bufferSize` in order to fit enough messages, for example the `max.poll.records`, maximum amount of records returned in a batch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`send` 方法将记录通过事务写入 Kafka，而无需等待来自代理的发送回执。 等待写入 Kafka 的消息将被缓冲，并在提交事务之前刷新。 因此，建议配置 `@OnOverflow` `bufferSize` 以适应足够的消息，例如 `max.poll.records`，即批处理中返回的最大记录数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `settings.json` placed in the root of your project directory or in the workspace will need the following workaround in your test configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在您的项目根目录或工作区的 `settings.json` 文件中，针对测试配置添加以下配置项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `stream` methods require a transaction to work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`stream` 方法的运行需要事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `stream` methods require a transaction to work. +
As they perform I/O operations, they should be closed via the `close()` method or via a try-with-resource to close the underlying `ResultSet`.
If not, you will see warnings from Agroal that will close the underlying `ResultSet` for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`stream` 方法的运行需要事务。+ 由于这些stream开头的方法会执行I/O操作，所以应该通过 `close()` 方法或try-with-resource来关闭底层的 `ResultSet` 。否则你会看到来自Agroal的警告，它会为你关闭底层的 `ResultSet` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `stream` methods require a transaction to work. + As they perform I/O operations, they should be closed via the `close()` method or via a try-with-resource to close the underlying `ResultSet`.  If not, you will see warnings from Agroal that will close the underlying `ResultSet` for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`stream` 方法的运行需要事务。+ 由于这些stream开头的方法会执行I/O操作，所以应该通过 `close()` 方法或try-with-resource来关闭底层的 `ResultSet` 。否则你会看到来自Agroal的警告，它会为你关闭底层的 `ResultSet` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `target/manage.sh` script is for managing your lambda using the AWS Lambda Java runtime.  This script is provided only for
your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed
to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`target/manage.sh` 脚本是用于使用AWS Lambda Java runtime管理你的lambda。此脚本只是为了方便你而提供。如果你想了解执行哪些aws命令来创建、删除和更新你的lambdas，请检查 `manage.sh` 脚本的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `target/manage.sh` script is for managing your lambda using the AWS Lambda Java runtime.  This script is provided only for your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`target/manage.sh` 脚本是用于使用AWS Lambda Java runtime管理你的lambda。此脚本只是为了方便你而提供。如果你想了解执行哪些aws命令来创建、删除和更新你的lambdas，请检查 `manage.sh` 脚本的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `upn` claim is defined by the {mp-jwt} spec as preferred claim to use for the
`Principal` seen via the container security APIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `upn` 声明(claim)被{mp-jwt}规范定义为首选声明，用做为被container security APIs所能见的 `Principal` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `upn` claim is defined by the {mp-jwt} spec as preferred claim to use for the `Principal` seen via the container security APIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 `upn` 声明(claim)被{mp-jwt}规范定义为首选声明，用做为被container security APIs所能见的 `Principal` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `xray` propagator will need the https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/aws[aws] extension to be added as a dependency to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`xray` propagator需要将 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/aws[aws] 扩展作为依赖添加到您的项目中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above command should return  `["first"]` indicating that we have only one increment thus far.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面的命令应该返回 `["first"]` ，表明到目前为止我们只有一个增量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above command should return `["first"]` indicating that we have only one increment thus far.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面的命令应该返回 `["first"]` ，表明到目前为止我们只有一个增量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above creates a `Metadata` object we can add to the `Message` being produced,
which retrieves the OpenTelemetry `Context` to extract the current span for propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上代码创建了一个 `Metadata` 对象，我们可以将该对象添加到生成的 `Message` 中，并且该对象可以获取OpenTelemetry的 `Context` 来抽取当前的span用以传播。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above creates a `Metadata` object we can add to the `Message` being produced, which retrieves the OpenTelemetry `Context` to extract the current span for propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上代码创建了一个 `Metadata` 对象，我们可以将该对象添加到生成的 `Message` 中，并且该对象可以获取OpenTelemetry的 `Context` 来抽取当前的span用以传播。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above example shows a few different ways the API can be used. The first method simply calls begin, does some work and commits it.
This created transaction is tied to the CDI request scope, so if it is still active when the request scope is destroyed then it will
be automatically rolled back. This removes the need to explicitly catch exceptions and call `rollback`, and acts as a safety net
against inadvertent transaction leaks, however it does mean that this can only be used when the request scope is active. The second
example in the method calls begin with a timeout option, and then rolls back the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面的例子显示了几种不同的API使用方法。第一个方法是简单地调用begin，做一些工作并提交。这个创建的事务是与CDI请求范围相联系的，所以如果它在请求范围被破坏时仍处于活动状态，那么它将被自动回滚。这样就不需要明确地捕捉异常和调用 `rollback` ，并作为一个安全措施来防止无意中的事务泄露，然而这也意味着这只能在请求范围处于活动状态时使用。方法调用中的第二个例子以一个超时选项开始，然后回滚事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above example simulates sending a Cognito principal with an HTTP request to your HTTP Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面的例子模拟向你的HTTP Lambda发送一个带有HTTP请求的Cognito 主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above sequence of commands should update the https://github.com/vert-x3/vertx-redis-client/blob/master/src/main/java/io/vertx/redis/client/Command.java[`Command.java`] file, so it includes all the possible commands supported by a particular Redis version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上的几行命令会更新 link:https://github.com/vert-x3/vertx-redis-client/blob/master/src/main/java/io/vertx/redis/client/Command.java[`Command.java`] 文件，使其包含指定版本的 Redis 的所有支持的命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The all-open Kotlin plugin tells the compiler not to mark as final, those classes with the annotations highlighted (customize as required)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>all-open Kotlin插件告诉编译器不要把那些有注解的类标记为final类（可以按需自定义） </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The all-open configuration required, as per Maven guide above</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>按照上面的Maven指南，需要配置all-open插件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The amount of milliseconds waiting for a graceful shutdown of the Kafka producer

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>等待Kafka生产者平滑关闭的毫秒数

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南中构建的应用程序非常简单：用户可以使用一个表单在列表中添加元素并更新列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application can also run as a native executable.
But, first, we need to instruct Quarkus to enable _ssl_ (if the remote API uses HTTPS).
Open the `src/main/resources/application.properties` and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该应用程序也可以作为一个本地可执行文件运行。但是，首先，我们需要指示Quarkus启用 _ssl_ （如果远程API使用HTTPS）。打开 `src/main/resources/application.properties` ，并添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application can also run as a native executable.  But, first, we need to instruct Quarkus to enable _ssl_ (if the remote API uses HTTPS).  Open the `src/main/resources/application.properties` and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该应用程序也可以作为一个本地可执行文件运行。但是，首先，我们需要指示Quarkus启用 _ssl_ （如果远程API使用HTTPS）。打开 `src/main/resources/application.properties` ，并添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is packaged using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该应用程序是用以下方式打包的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is using bearer token authorization and the first thing to do is obtain an access token from the Keycloak Server in
order to access the application resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该应用程序使用bearer token授权，首先要做的是从Keycloak服务器获得一个访问token，以便访问应用程序资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is using bearer token authorization and the first thing to do is obtain an access token from the Keycloak Server in order to access the application resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该应用程序使用bearer token授权，首先要做的是从Keycloak服务器获得一个访问token，以便访问应用程序资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The associated configuration would be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相关的配置如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The back-pressure is handled by AMQP _credits_.
The outbound connector only requests the amount of allowed credits.
When the amount of credits reaches 0, it waits (in a non-blocking fashion) until the broker grants more credits to the AMQP sender.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>背压力是由AMQP _credits_ 来处理的。出站连接器只请求允许的信用额度。当信用额度达到0时，它就会等待（以非阻塞方式），直到代理授予AMQP发送者更多的信用额度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The back-pressure is handled by AMQP _credits_.  The outbound connector only requests the amount of allowed credits.  When the amount of credits reaches 0, it waits (in a non-blocking fashion) until the broker grants more credits to the AMQP sender.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>背压力是由AMQP _credits_ 来处理的。出站连接器只请求允许的信用额度。当信用额度达到0时，它就会等待（以非阻塞方式），直到代理授予AMQP发送者更多的信用额度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bearer token is issued by a Keycloak Server and represents the subject to which the token was issued for.
For being an OAuth 2.0 Authorization Server, the token also references the client acting on behalf of the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不记名令牌是由Keycloak服务器颁发的，并代表令牌发放对象的主体。对于OAuth 2.0授权服务器来说，该令牌还引用了代表用户的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bearer token is issued by a Keycloak Server and represents the subject to which the token was issued for.  For being an OAuth 2.0 Authorization Server, the token also references the client acting on behalf of the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bearer token是由Keycloak服务器发放的，而且代表了该token的发放对象。对于作为OAuth 2.0授权服务器，该token还可以表示代表用户的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bearer token is issued by a Keycloak Server and represents the subject to which the token was issued for. For being an OAuth 2.0 Authorization Server, the token also references the client acting on behalf of the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不记名令牌是由Keycloak服务器颁发的，并代表令牌发放对象的主体。对于OAuth 2.0授权服务器来说，该令牌还引用了代表用户的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The below code snippet shows how we can create dynamic clients using the configurations in &lt;&lt;multiple-clients-configuration&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的代码片段显示了我们如何使用 link:#multiple-clients-configuration[[多个Redis客户端]] 中的配置创建动态客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bootstrap of a reactive application using RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RESTEasy Reactive 的响应式应用程序的引导</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The broker hostname

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代理的主机名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The broker port

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代理端口

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The browser must use the `vertx-eventbus` JavaScript library to consume the message:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览器必须使用 `vertx-eventbus` JavaScript库来消费该信：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The central idea behind Quarkus is to do at build-time what traditional frameworks do at runtime: configuration parsing, classpath scanning, feature toggle based on classloading, and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的中心思想是在构建时做传统框架在运行时做的事情：配置解析、classpath扫描、基于classloading的功能切换，等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is a bit more involved.
To write to a database, we need a transaction, therefore we use `Panache.withTransaction` to obtain one (asynchronously) and proceed to call the `persist` method.
The `persist` method returns a `Uni` that emits the result of the insertion of the fruit in the database.
Once the insertion completes (which plays the role of the continuation), we create a `201 CREATED` HTTP response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这代码要更复杂一些。想要写入数据库，我们需要一个事务。因此我们使用 `Panache.withTransaction` 来获取一个（异步），然后调用 `persist` 方法。 `persist` 方法返回一个 发出`fruit`插入到数据库中结果的`Uni`。一旦插入完成（它起到延续的作用），我们就会创建一个 `201 CREATED` 的HTTP响应。RESTEasy Reactive会自动将请求体读取为JSON并创建 `Fruit` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is a bit more involved.
To write to a database, we need a transaction.
So we use `Panache.withTransaction` to get one (asynchronously) and call the `persist` method when we receive the transaction.
The `persist` method is also returning a `Uni`.
This `Uni` emits the result of the insertion of the fruit in the database.
Once the insertion completes (and that's our continuation), we create a `201 CREATED` response.
RESTEasy Reactive automatically reads the request body as JSON and creates the `Fruit` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码稍微复杂一些。要写入数据库，我们需要一个事务。所以我们用 `Panache.withTransaction` 来获取一个（异步），并在接收到事务时调用 `persist` 方法。 `persist` 方法也返回一个 `Uni`。这个 `Uni` 发出水果插入数据库的结果。一旦插入完成（这就是我们的延续），我们创建一个 `201 CREATED` 响应。RESTEasy Reactive会自动将请求体读取为JSON并创建 `Fruit` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is a bit more involved.  To write to a database, we need a transaction.  So we use `Panache.withTransaction` to get one (asynchronously) and call the `persist` method when we receive the transaction.  The `persist` method is also returning a `Uni`.  This `Uni` emits the result of the insertion of the fruit in the database.  Once the insertion completes (and that's our continuation), we create a `201 CREATED` response.  RESTEasy Reactive automatically reads the request body as JSON and creates the `Fruit` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码稍微复杂一些。要写入数据库，我们需要一个事务。所以我们用 `Panache.withTransaction` 来获取一个（异步），并在接收到事务时调用 `persist` 方法。 `persist` 方法也返回一个 `Uni`。这个 `Uni` 发出水果插入数据库的结果。一旦插入完成（这就是我们的延续），我们创建一个 `201 CREATED` 响应。RESTEasy Reactive会自动将请求体读取为JSON并创建 `Fruit` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is pretty straightforward. Every day at 10:15am, the counter is incremented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码非常简单明了。每天上午10点15分，计数器递增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序开发的代码在 link:getting-started[入门指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the xref:getting-started.adoc[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 xref:getting-started.adoc[入门指南] 中开发的应用程序代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The combination of Quarkus and Kubernetes provides an ideal environment for creating scalable, fast, and lightweight applications. Quarkus significantly increases developer productivity with tooling, pre-built integrations, application services, and more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus和Kubernetes的组合为创建可伸缩、快速和轻量级的应用程序提供了理想的环境。Quarkus通过工具、预构建集成、应用程序服务等显著提高了开发人员的生产率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>社区将修复最新的major.minor版本安全漏洞，发布于 https://quarkus.io/get-started/。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The companion object holds all the methods not related to a specific instance allowing for general management and
querying bound to a specific type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>companion object持有所有与特定实例无关的方法，允许进行一般管理和与特定类型绑定的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The companion object holds all the methods not related to a specific instance allowing for general management and querying bound to a specific type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>companion object持有所有与特定实例无关的方法，允许进行一般管理和与特定类型绑定的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完整的例子可以参考 `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The completed greeter application from the xref:getting-started.adoc[Getting Started Guide]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>来自 link:getting-started.html[《入门指南》]  的完整的greeter应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration is based on the official https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_filter[Keycloak Policy Enforcer Configuration]. If you are looking for more details about the different configuration options, please take a look at this documentation,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下配置基于官方文档 link:https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_filter[Keycloak Policy Enforcer Configuration]。如果您想要查看不同配置选项的更多细节，请参看该文档,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置键的结构如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration of the created Kafka broker can be customized using `@ResourceArg`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Kafka broker的配置可以通过使用 `@ResourceArg` 来自定义，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connection string, given on the admin console, such as `demo-c--bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在管理控制台所给出的连接字符串，例如 `demo-c—​bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connection timeout in milliseconds

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接超时以毫秒为单位

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector converts incoming AMQP Messages into Reactive Messaging `Message&lt;T&gt;` instances.
`T` depends on the _body_ of the received AMQP Message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器将传入的AMQP消息转换为响应式消息 `Message&lt;T&gt;` 实例。 `T` 取决于收到的AMQP消息的 _body_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector converts incoming AMQP Messages into Reactive Messaging `Message&lt;T&gt;` instances.  `T` depends on the _body_ of the received AMQP Message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器将传入的AMQP消息转换为响应式消息 `Message&lt;T&gt;` 实例。 `T` 取决于收到的AMQP消息的 _body_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector only sends that amount of messages concurrently.
No other messages will be sent until at least one in-flight message gets acknowledged by the broker.
Then, the connector writes a new message to Kafka when one of the broker’s in-flight messages get acknowledged.
Be sure to configure Kafka’s `batch.size` and `linger.ms` accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Connector只会并行发送指定数量的消息。在至少一个in-flight的消息被broker确认之前，其他消息都不会被发送。然后，当broker中有in-flight的消息得到确认时，connector才会向Kafka写入一个新的消息。请确保相应地配置Kafka的 `batch.size` 和 `linger.ms` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector only sends that amount of messages concurrently.  No other messages will be sent until at least one in-flight message gets acknowledged by the broker.  Then, the connector writes a new message to Kafka when one of the broker’s in-flight messages get acknowledged.  Be sure to configure Kafka’s `batch.size` and `linger.ms` accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Connector只会并行发送指定数量的消息。在至少一个in-flight的消息被broker确认之前，其他消息都不会被发送。然后，当broker中有in-flight的消息得到确认时，connector才会向Kafka写入一个新的消息。请确保相应地配置Kafka的 `batch.size` 和 `linger.ms` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector uses the Vert.x AMQP client underneath.
More details about this client can be found in the https://vertx.io/docs/vertx-amqp-client/java/[Vert.x website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器在下面使用Vert.x AMQP客户端。关于这个客户端的更多详情，请参阅 link:https://vertx.io/docs/vertx-amqp-client/java/[Vert.x网站] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector uses the Vert.x AMQP client underneath.  More details about this client can be found in the https://vertx.io/docs/vertx-amqp-client/java/[Vert.x website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器在下面使用Vert.x AMQP客户端。关于这个客户端的更多详情，请参阅 link:https://vertx.io/docs/vertx-amqp-client/java/[Vert.x网站] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed / populated Kafka topic. If neither this property nor the `topics` properties are set, the channel name is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>被消费/生产消息的Kafka主题。如果这个属性和 `topics` 属性都没有设置，则使用通道名称。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed `KafkaRecordBatch` message is passed to the `KafkaTransactions#withTransactionAndAck` in order to handle the offset commits and message acks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费的 `KafkaRecordBatch` 消息被传递给 `KafkaTransactions#withTransactionAndAck` ，以处理偏移提交和消息确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumer `client.id` is configured according to the number of clients to create using `mp.messaging.incoming.[channel].partitions` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者 `client.id` 会根据使用 `mp.messaging.incoming.[channel].partitions` 属性创建的客户端数量进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container running the resource to test against, for example PostgreSQL via Testcontainers, is assigned an IP address from the container's network.
Use the container's "public" IP from its network and the "unmapped" port number to connect to the service.
The Testcontainers library usually return connection strings without respecting the container network, so additional code is needed to provide Quarkus the "correct" connection string using the container's IP on the container network and the _unmapped_ port number.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行要测试资源的容器，例如通过Testcontainers启用的PostgreSQL，会从容器的网络中分配到一个IP地址。使用容器网络中的 "公共 "IP和 "未映射 "的端口号来连接到服务。Testcontainers库通常在不遵从容器网络规则的情况下返回连接字符串，所以需要额外的代码来为Quarkus提供 "正确的 "连接字符串，以使用容器网络中的IP和 _未映射_ 的端口号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container running the resource to test against, for example PostgreSQL via Testcontainers, is assigned an IP address from the container's network.  Use the container's "public" IP from its network and the "unmapped" port number to connect to the service.  The Testcontainers library usually return connection strings without respecting the container network, so additional code is needed to provide Quarkus the "correct" connection string using the container's IP on the container network and the _unmapped_ port number.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行要测试资源的容器，例如通过Testcontainers启用的PostgreSQL，会从容器的网络中分配到一个IP地址。使用容器网络中的 "公共 "IP和 "未映射 "的端口号来连接到服务。Testcontainers库通常在不遵从容器网络规则的情况下返回连接字符串，所以需要额外的代码来为Quarkus提供 "正确的 "连接字符串，以使用容器网络中的IP和 _未映射_ 的端口号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The core foundation of every good open source project is open discussion and collaboration. Quarkus is committed to this belief. We've enabled GitHub Discussions so the community can have open communication. This gives a focal point for the community to ask and answer questions regarding the project. This means all of that great knowledge can be shared and is discoverable. Additionally, other conversations about the Quarkus Community can be had there as well. Come collaborate with us.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每个好的开源项目的核心基础是公开讨论和合作。Quarkus致力于这一信念。我们已经启用了GitHub讨论，以便社区能够进行公开交流。这为社区提供了一个焦点，以提出和回答关于项目的问题。这意味着所有这些伟大的知识都可以被分享和发现。此外，关于Quarkus社区的其他对话也可以在这里进行。来与我们合作吧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding deserializer class needs to be subclassed.
So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对应的反序列化器类也需要被子类化。因此，让我们创建一个 `FruitDeserializer` 来继承 `ObjectMapperDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding deserializer class needs to be subclassed.
So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相应的反序列化器类需要被子类化。因此，让我们创建一个 `FruitDeserializer` 来继承 `JsonbDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对应的反序列化器类也需要被子类化。因此，让我们创建一个 `FruitDeserializer` 来继承 `ObjectMapperDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相应的反序列化器类需要被子类化。因此，让我们创建一个 `FruitDeserializer` 来继承 `JsonbDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cost of making up to 2 remote calls per every incoming bearer or code flow access token can sometimes be problematic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每一个传入的不记名流(bearer flow)或授权码流(code flow)访问令牌要进行多达2次的远程呼叫，其开销有时会是个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The current tenant's discovered link:https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata[OpenID Connect Configuration Metadata] is represented by `io.quarkus.oidc.OidcConfigurationMetadata` and can be either injected or accessed as a `SecurityIdentity` `configuration-metadata` attribute.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当前租户发现的 link:https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata[OpenID Connect配置元数据] 由 `io.quarkus.oidc.OidcConfigurationMetadata` 表示，可以作为 `SecurityIdentity` `configuration-metadata` 属性注入或访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The current version of the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目的当前版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default behaviour of Jackson can be restored by setting `quarkus.jackson.write-dates-as-timestamps=true`
in your `application.properties`. If you want to change the format for a single field, you can use the
`@JsonFormat` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jackson的默认行为可以通过在你的 `application.properties` 中设置 `quarkus.jackson.write-dates-as-timestamps=true` 来设置。如果你想改变单个字段的默认行为，你可以使用 `@JsonFormat` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default behaviour of Jackson can be restored by setting `quarkus.jackson.write-dates-as-timestamps=true` in your `application.properties`. If you want to change the format for a single field, you can use the `@JsonFormat` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jackson的默认行为可以通过在你的 `application.properties` 中设置 `quarkus.jackson.write-dates-as-timestamps=true` 来设置。如果你想改变单个字段的默认行为，你可以使用 `@JsonFormat` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default cache uses a token as a key and each entry can have `TokenIntrospection` and/or `UserInfo`. It will only keep up to a `max-size` number of entries. If the cache is full when a new entry is to be added then an attempt will be made to find a space for it by removing a single expired entry. Additionally, the cleanup timer, if activated, will periodically check for the expired entries and remove them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认的缓存使用一个令牌作为密钥，每个条目可以有 `TokenIntrospection` 和/或 `UserInfo` 。它只保留最多数量的条目 `max-size` 。如果要添加一个新的条目时，缓存已经满了，那么将试图通过删除一个过期的条目来为它找到一个空间。此外，清理计时器，如果被激活，将定期检查过期的条目并将其删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default implementation allows you to define permissions using config in `application.properties`. An example
config is shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认实现允许您使用 `application.properties` 中的配置来定义权限。下面是一个配置的例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default implementation allows you to define permissions using config in `application.properties`. An example config is shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认实现允许您使用 `application.properties` 中的配置来定义权限。下面是一个配置的例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default support for AWS security only maps the principal name to Quarkus security
APIs and does nothing to map claims or roles or permissions.  You have full control on
how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using
implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider`
interface.  By implementing this interface, you can do things like define role mappings for your principal
or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对AWS安全的默认支持只是将主体名称映射到Quarkus安全API，并没有对声明、角色或权限进行映射。你可以使用 `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` 接口的实现来完全控制lambda HTTP事件中的安全元数据是如何被映射到Quarkus安全API的。通过实现这个接口，你可以做一些事情，比如为你的主体定义角色映射，或者发布由IAM或Cognito或你自定义的Lambda安全集成提供的额外的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have full control on how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对AWS安全的默认支持只是将主体名称映射到Quarkus安全API，并没有对声明、角色或权限进行映射。你可以使用 `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` 接口的实现来完全控制lambda HTTP事件中的安全元数据是如何被映射到Quarkus安全API的。通过实现这个接口，你可以做一些事情，比如为你的主体定义角色映射，或者发布由IAM或Cognito或你自定义的Lambda安全集成提供的额外的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default tenant's `OidcConfigurationMetadata` is injected if the endpoint is public.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果端点是公开的，则默认租户的 `OidcConfigurationMetadata` 会被注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value is 60 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认值是60秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deserializer classname used to deserialize the record's key

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于反序列化记录的键值的反序列化器的类名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deserializer classname used to deserialize the record's value

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于反序列化记录的值的反序列化器的类名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The difference between RESTEasy, RESTEasy Reactive and Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy、RESTEasy Reactive 和 Reactive Routes 之间的区别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to create a new Quarkus project is to open a terminal and run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个新的Quarkus项目最简单的方法是打开终端并运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to define your transaction boundaries is to use the `@Transactional` annotation on your entry method (`javax.transaction.Transactional`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义你的事务边界的最简单的方法是在你的入口方法上使用 `@Transactional` 注释( `javax.transaction.Transactional` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to register a class for reflection is to use the `@RegisterForReflection` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为反射注册一个类的最简单方法是使用 `@RegisterForReflection` 注解：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements are stored in MongoDB.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些元素被存储在MongoDB中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements used via reflection are not part of the call tree so they are dead code eliminated (if not called directly in other cases).
To include these elements in your native executable, you need to register them for reflection explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过反射使用的元素不是调用树的一部分，所以它们是被消除的死代码（如果不是在其他情况下直接调用）。要在你的本地可执行文件中包含这些元素，你需要为反射明确地注册它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements used via reflection are not part of the call tree so they are dead code eliminated (if not called directly in other cases).  To include these elements in your native executable, you need to register them for reflection explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过反射使用的元素不是调用树的一部分，所以它们是被消除的死代码（如果不是在其他情况下直接调用）。要在你的本地可执行文件中包含这些元素，你需要为反射明确地注册它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The endpoint obtains the user principal from the JAX-RS `SecurityContext`. This will be non-null for a secured endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该节点通过 JAX-RS `SecurityContext` 获取用户principal。对于受保护节点它将永不为null。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The endpoint returns a `CompletionStage` indicating the asynchronous nature of the method.
The `emitter.send` method returns a `CompletionStage&lt;Void&gt;` .
The returned future is completed when the message has been written to Kafka.
If the writing fails, the returned `CompletionStage` is completed exceptionally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点会返回一个 `CompletionStage` ，表明该方法是异步的。 `emitter.send` 方法返回一个 `CompletionStage&lt;Void&gt;` 。当消息被写入Kafka时，返回的Future就被认为i完成了。如果写入失败，返回的 `CompletionStage` 会抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The endpoint returns a `CompletionStage` indicating the asynchronous nature of the method.  The `emitter.send` method returns a `CompletionStage&lt;Void&gt;` .  The returned future is completed when the message has been written to Kafka.  If the writing fails, the returned `CompletionStage` is completed exceptionally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点会返回一个 `CompletionStage` ，表明该方法是异步的。 `emitter.send` 方法返回一个 `CompletionStage&lt;Void&gt;` 。当消息被写入Kafka时，返回的Future就被认为i完成了。如果写入失败，返回的 `CompletionStage` 会抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The endpoint sends the passed payload (from a `POST` HTTP request) to the emitter.
The emitter's channel is mapped to a Kafka topic in the `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点将已传递的payload(来自 `POST` HTTP请求)发送给emitter。emitter的 channel 被映射到 `application.properties` 文件中指定的一个Kafka topic：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The endpoint sends the passed payload (from a `POST` HTTP request) to the emitter.  The emitter's channel is mapped to a Kafka topic in the `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点将已传递的payload(来自 `POST` HTTP请求)发送给emitter。emitter的 channel 被映射到 `application.properties` 文件中指定的一个Kafka topic：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The environment executing step `1` only needs Java and Maven (or Gradle) installed, while the environment executing step `3` only needs a GraalVM installation (including the `native-image` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>执行步骤 `1` 的环境只需要安装Java和Maven（或Gradle），而执行步骤 `3` 的环境只需要安装GralVM（包括 `native-image` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example above obtains an access token for user `alice`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面的命令为用户 `alice` 获取了一个访问token。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example lambda takes input passed in via the `--payload` switch which points to a json file
in the root directory of the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个lambda示例接受通过 `--payload` 开关传入的输入，该开关指向项目根目录中的一个json文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example lambda takes input passed in via the `--payload` switch which points to a json file in the root directory of the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个lambda示例接受通过 `--payload` 开关传入的输入，该开关指向项目根目录中的一个json文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable built with `-Dquarkus-profile=test` is not suitable for production deployment.
It contains your test resources files and settings. Once the testing is done, the executable would have to be built again,
using the default, `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `-Dquarkus-profile=test` 构建的可执行文件不适合生产部署。它包含您的测试资源文件和设置。一旦测试完成，就必须使用默认的 `prod` 配置文件再次构建可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable built with `-Dquarkus-profile=test` is not suitable for production deployment.  It contains your test resources files and settings. Once the testing is done, the executable would have to be built again, using the default, `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `-Dquarkus-profile=test` 构建的可执行文件不适合生产部署。它包含您的测试资源文件和设置。一旦测试完成，就必须使用默认的 `prod` 配置文件再次构建可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension generates an example script within `target/bootstrap-example.sh`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展会在 `target/bootstrap-example.sh` 中生成了一个示例脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension includes `kafka-clients` version 3.1.0 as a transitive dependency and is compatible with Kafka brokers version 2.x.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该扩展包括 `kafka-clients` 3.1.0版本的传递依赖，而且与Kafka broker 2.x版本兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final order of business is to make the configuration file known to the `native-image` executable by adding the proper configuration to `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一项工作是通过向 `application.properties`添加适当的配置，使配置文件为 `native-image` 可执行文件所知：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first application, the `producer`, will let the user request some quotes over an HTTP endpoint.
For each quote request, a random identifier is generated and returned to the user, to put the quote request on _pending_.
At the same time the generated request id is sent over the `quote-requests` queue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一个应用程序 `producer` ，将让用户通过一个HTTP端点请求一些报价。对于每一个报价请求，都会生成一个随机标识符，并返回给用户，以便将报价请求放在 _pending_ 上。同时，生成的请求ID通过 `quote-requests` 队列被发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first application, the `producer`, will let the user request some quotes over an HTTP endpoint.  For each quote request, a random identifier is generated and returned to the user, to put the quote request on _pending_.  At the same time the generated request id is sent over the `quote-requests` queue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一个应用程序 `producer` ，将让用户通过一个HTTP端点请求一些报价。对于每一个报价请求，都会生成一个随机标识符，并返回给用户，以便将报价请求放在 _pending_ 上。同时，生成的请求ID通过 `quote-requests` 队列被发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first approach is by providing the properties within the `src/main/resources/application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一种方法是通过在 `src/main/resources/application.properties` 文件内提供配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first stage builds the native executable using Maven or Gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一阶段使用Maven或Gradle构建原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to configure and start the https://opentelemetry.io/docs/collector/[OpenTelemetry Collector] to receive, process and export telemetry data to https://www.jaegertracing.io/[Jaeger] that will display the captured traces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一步是配置和启动 link:https://opentelemetry.io/docs/collector/[OpenTelemetry Collector] ，以接收、处理和输出勘测数据到 link:https://www.jaegertracing.io/[Jaeger] 来显示捕获的traces。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for pure Java lambda deployments require a specific handler class.
Do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先需要注意的是，对于纯Java lambda部署，需要一个特定的处理程序类。不要改变Lambda处理程序的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先需要注意的是，对于纯Java lambda部署，需要一个特定的处理程序类。不要改变Lambda处理程序的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following IDEs have support for the community developed Quarkus Tools:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下IDE支持社区开发的Quarkus工具：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following attributes are configured using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下属性通过该方式进行配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following code provides an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下代码提供了一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following configuration example demonstrates how you can enforce a single selectable authentication mechanism for a given request path:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下配置示例演示了如何强制要求对一个给定的请求路径选择一个认证机制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example creates a topic named `test` with 3 partitions, and a second topic named `messages` with 2 partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子创建了一个名为 `test` ，有3个分区的主题，以及另一个名为 `messages` ，有2个分区的主题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example customizes the line format used for StatsD:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子自定义了用于StatsD的行格式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example demonstrates how to receive a payload, store it in the database using Hibernate Reactive with Panache, and send the persisted entity to Kafka:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子演示了如何接收一个payload，使用Hibernate Reactive with Panache将其存储在数据库中，并将持久化的实体发送到Kafka：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example illustrates the use with PostgreSQL, but the approach is applicable to all containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子展示了在PostgreSQL上的使用，但这个方法也适用于所有的容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example includes a batch of Kafka records inside a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下示例包括在事务中进行 Kafka 记录的批处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following examples are for the active record pattern, but the same can be used with repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子是针对Active Record模式的，但同样可以应用于Repository模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following extensions provide support for Kotlin Coroutines by allowing the use of Kotlin's `suspend` keyword on method signatures.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下扩展通过允许在方法签名上使用Kotlin的 `suspend` 关键字，为Kotlin Coroutines提供支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following links provide background on the general conventions and Asciidoc syntax.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下链接提供了关于一般约定和Asciidoc语法的背景信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following semantics are supported:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持以下语义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following snippet provides an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下代码段提供了一个示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following snippets provide examples of YAML configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下代码段提供了YAML配置的示例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table lists the most used libraries from the Vert.x ecosystem.
To access these APIs, add the indicated extension or dependency to your project.
Refer to the associated documentation to learn how to use them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下表列出了Vert.x生态系统中最常用的库。要访问这些API，请在你的项目中添加指定的扩展或依赖性。请参考相关文档，了解如何使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table lists the most used libraries from the Vert.x ecosystem.  To access these APIs, add the indicated extension or dependency to your project.  Refer to the associated documentation to learn how to use them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下表列出了Vert.x生态系统中最常用的库。要访问这些API，请在你的项目中添加指定的扩展或依赖性。请参考相关文档，了解如何使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table provides a summary of the options for each authentication mechanism:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下表提供了每种认证机制的选项摘要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following variables externalize key information that can change over time, and so references
to such information should be done by using the variable inside of {} curly brackets. The
complete list of externalized variables for use is given in the following table:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下变量外部化了可能随时间而变化的关键信息，因此对这些信息的引用应该通过使用大括号{}中的变量来完成。下表给出了可使用的外部化变量的完整列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following variables externalize key information that can change over time, and so references to such information should be done by using the variable inside of {} curly brackets. The complete list of externalized variables for use is given in the following table:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下变量外部化了可能随时间而变化的关键信息，因此对这些信息的引用应该通过使用大括号{}中的变量来完成。下表给出了可使用的外部化变量的完整列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The format for durations uses the standard `java.time.Duration` format.
You can learn more about it in the link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持续时间的格式使用标准的 `java.time.Duration` 格式您可以在 https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc] 中了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The format for durations uses the standard `java.time.Duration` format.  You can learn more about it in the link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持续时间的格式使用标准的 `java.time.Duration` 格式您可以在 https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc] 中了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The framework verifies that the producer/consumer chain is complete,
meaning that if the application writes messages into an in-memory channel (using a method with only `@Outgoing`, or an `Emitter`),
it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus框架会验证生产者/消费者链是否完整，这意味着如果应用程序将消息写入内存channel(仅使用 `@Outgoing` 修饰符方法，或 `Emitter` )，它也必须从应用程序内部消费消息(仅 `@Incoming` 修饰符方法 ，或使用不受管理的流)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The framework verifies that the producer/consumer chain is complete, meaning that if the application writes messages into an in-memory channel (using a method with only `@Outgoing`, or an `Emitter`), it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus框架会验证生产者/消费者链是否完整，这意味着如果应用程序将消息写入内存channel(仅使用 `@Outgoing` 修饰符方法，或 `Emitter` )，它也必须从应用程序内部消费消息(仅 `@Incoming` 修饰符方法 ，或使用不受管理的流)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full flavor of GraalVM to use e.g. `19.3.1-java11`. Make sure to use a `java11` version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用的GraalVM的完整版本，如“19.3.1-java11”。请确保使用 `java11` 版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full set of types supported by the serializer/deserializer autodetection is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化器/反序列化器自动侦测所支持的全部类型有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function given to the `withTransaction` method receives a `TransactionalEmitter` for producing records, and returns a `Uni` that provides the result of the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传入 `withTransaction` 方法的函数参数会使用 `TransactionalEmitter` 来产生记录，并返回 `Uni` 做为事务结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated `pom.xml` contains the following modifications compared to its counterpart when Kotlin is not selected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与不选择Kotlin时的对应内容相比，这次生成的 `pom.xml` 包含以下修改：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.
Edit the `src/test/java/org/acme/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目包含一个简单的测试。编辑 `src/test/java/org/acme/GreetingResourceTest.java` ，以匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目包含一个简单的测试。编辑 `src/test/java/org/acme/GreetingResourceTest.java` ，以匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project has three lambdas within it.  Two that implement the `RequestHandler&lt;?, ?&gt;` interface, and one that implements the `RequestStreamHandler` interface. One that is used and two that are unused.  If you open up
`src/main/resources/application.properties` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目里有三个lambdas。两个实现 `RequestHandler&lt;?, ?&gt;` 接口，一个实现 `RequestStreamHandler` 接口。使用了一个，另两个未使用。如果你打开 `src/main/resources/application.properties` ，你会看到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project has three lambdas within it.  Two that implement the `RequestHandler&lt;?, ?&gt;` interface, and one that implements the `RequestStreamHandler` interface. One that is used and two that are unused.  If you open up `src/main/resources/application.properties` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目里有三个lambdas。两个实现 `RequestHandler&lt;?, ?&gt;` 接口，一个实现 `RequestStreamHandler` 接口。使用了一个，另两个未使用。如果你打开 `src/main/resources/application.properties` ，你会看到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.
On common Linux distributions you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.debug` 文件的生成取决于 `objcopy` 。在常见的Linux发行版上，你将需要安装 `binutils` 包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions and macOS you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.debug` 文件的生成取决于 `objcopy` 。在常见的Linux发行版和macOS上，你将需要安装 `binutils` 包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.debug` 文件的生成取决于 `objcopy` 。在常见的Linux发行版上，你将需要安装 `binutils` 包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The handler is called with details of the deserialization, including the action represented as `Uni&lt;T&gt;`.
On the deserialization `Uni` failure strategies like retry, providing a fallback value or applying timeout can be implemented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个handler在被调用提供反序列化的细节，包括以 `Uni&lt;T&gt;` 所表示的操作(action)。在 `Uni` 提供的反序列化错误处理策略中，可以实现例如重试，提供回调(fallback)值或超时处理等等方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The handler is called with details of the deserialization, including the action represented as `Uni&lt;T&gt;`.  On the deserialization `Uni` failure strategies like retry, providing a fallback value or applying timeout can be implemented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个handler在被调用提供反序列化的细节，包括以 `Uni&lt;T&gt;` 所表示的操作(action)。在 `Uni` 提供的反序列化错误处理策略中，可以实现例如重试，提供回调(fallback)值或超时处理等等方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The handler is called with details of the serialization, including the action represented as `Uni&lt;byte[]&gt;`.
Note that the method must await on the result and return the serialized byte array.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理器被调用，并被提供序列化的细节，包括以 `Uni&lt;byte[]&gt;` 表示的操作。注意，该方法必须对在结果处进行等待，并返回序列化后的字节数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The handler is called with details of the serialization, including the action represented as `Uni&lt;byte[]&gt;`.  Note that the method must await on the result and return the serialized byte array.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理器被调用，并被提供序列化的细节，包括以 `Uni&lt;byte[]&gt;` 表示的操作。注意，该方法必须对在结果处进行等待，并返回序列化后的字节数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The host provider can be used to configure the redis client like shown below</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisHostsProvider` 可用于配置Redis客户端，如下图所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html[AMQP Type System] defines the supported types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html[AMQP类型系统] 定义了支持的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]
allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires
https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose
to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] 允许你在模拟的Lambda环境中在你的笔记本电脑上本地运行lambdas。这需要安装 link:https://www.docker.com/products/docker-desktop[docker] 。如果你选择使用它，这是一个可选的方法。否则，Quarkus的JUnit集成应该足以满足你的大部分需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] 允许你在模拟的Lambda环境中在你的笔记本电脑上本地运行lambdas。这需要安装 link:https://www.docker.com/products/docker-desktop[docker] 。如果你选择使用它，这是一个可选的方法。否则，Quarkus的JUnit集成应该足以满足你的大部分需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/jdbc/library[JDBC instrumentation] will add a span for each JDBC queries done by your application, to enable it, add the following dependency to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过link:https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/jdbc/library[JDBC instrumentation] 可以为您的应用程序的每个JDBC查询添加一个span。要启用它，请在您的构建文件中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://tools.ietf.org/html/rfc7519[JWT specification] defines various levels of security of JWTs that one can use.
The {mp-jwt} specification requires that JWTs that are signed with the RSA-256 signature algorithm. This in
turn requires an RSA public key pair.
On the REST endpoint server side, you need to configure the location of the RSA public
key to use to verify the JWT sent along with requests.
The `mp.jwt.verify.publickey.location=publicKey.pem` setting configured
previously expects that the public key is available on the classpath as `publicKey.pem`.
To accomplish this, copy the following content to a `security-jwt-quickstart/src/main/resources/publicKey.pem` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 link:https://tools.ietf.org/html/rfc7519[JWT规范] 定义了人们可以使用的JWTs的各种安全级别。{mp-jwt}规范要求JWTs用RSA-256签名算法进行签名。这反过来又需要一个RSA公钥对。在REST终端服务器端，你需要配置RSA公钥的位置，用来验证与请求一起发送的JWT。之前配置的 `mp.jwt.verify.publickey.location=publicKey.pem` ，意思是公钥要能在classpath上作为 `publicKey.pem` 文件能找到。为了达到这个目的，请将以下内容复制到 `security-jwt-quickstart/src/main/resources/publicKey.pem` 文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://tools.ietf.org/html/rfc7519[JWT specification] defines various levels of security of JWTs that one can use.
The {mp-jwt} specification requires that JWTs that are signed with the RSA-256 signature algorithm. This in
turn requires an RSA public key pair. On the REST endpoint server side, you need to configure the location of the RSA public
key to use to verify the JWT sent along with requests. The `mp.jwt.verify.publickey.location=publicKey.pem` setting configured
previously expects that the public key is available on the classpath as `publicKey.pem`. To accomplish this, copy the following
content to a `security-jwt-quickstart/src/main/resources/publicKey.pem` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 link:https://tools.ietf.org/html/rfc7519[JWT规范] 定义了人们可以使用的JWTs的各种安全级别。{mp-jwt}规范要求JWTs用RSA-256签名算法进行签名。这反过来又需要一个RSA公钥对。在REST终端服务器端，你需要配置RSA公钥的位置，用来验证与请求一起发送的JWT。之前配置的 `mp.jwt.verify.publickey.location=publicKey.pem` ，意思是公钥要能在classpath上作为 `publicKey.pem` 文件能找到。为了达到这个目的，请将以下内容复制到 `security-jwt-quickstart/src/main/resources/publicKey.pem` 文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://tools.ietf.org/html/rfc7519[JWT specification] defines various levels of security of JWTs that one can use.  The {mp-jwt} specification requires that JWTs that are signed with the RSA-256 signature algorithm. This in turn requires an RSA public key pair. On the REST endpoint server side, you need to configure the location of the RSA public key to use to verify the JWT sent along with requests. The `mp.jwt.verify.publickey.location=publicKey.pem` setting configured previously expects that the public key is available on the classpath as `publicKey.pem`. To accomplish this, copy the following content to a `security-jwt-quickstart/src/main/resources/publicKey.pem` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 link:https://tools.ietf.org/html/rfc7519[JWT规范] 定义了人们可以使用的JWTs的各种安全级别。{mp-jwt}规范要求JWTs用RSA-256签名算法进行签名。这反过来又需要一个RSA公钥对。在REST终端服务器端，你需要配置RSA公钥的位置，用来验证与请求一起发送的JWT。之前配置的 `mp.jwt.verify.publickey.location=publicKey.pem` ，意思是公钥要能在classpath上作为 `publicKey.pem` 文件能找到。为了达到这个目的，请将以下内容复制到 `security-jwt-quickstart/src/main/resources/publicKey.pem` 文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.
Quarkus provides a default codec for local delivery.
So you can exchange objects as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x事件总线] 使用编解码器来 _序列化_ 和 _反序列化_ 对象。Quarkus为本地交付提供了一个默认的编解码器。所以你可以按以下方式交换对象：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default codec for local delivery.  So you can exchange objects as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x事件总线] 使用编解码器来 _序列化_ 和 _反序列化_ 对象。Quarkus为本地交付提供了一个默认的编解码器。所以你可以按以下方式交换对象：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitService` to list/add new fruits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现起来非常简单，你只需要使用JAX-RS注解来定义你的端点，并使用 `FruitService` 来list/add新的fruits。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现起来相当简单，你只需要使用JAX-RS注解来定义你的节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation of the `project(Class)` method uses the constructor's parameter names to build the select clause of the query,
so the compiler must be configured to store parameter names inside the compiled class.
This is enabled by default if you are using the Quarkus Maven archetype. If you are not using it, add the property `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `project(Class)` 方法的实现中，使用构造函数的参数名来构建查询的select子句，所以编译器必须配置为在编译的类中保留参数名。如果是使用Quarkus Maven archetype创建的项目，该功能默认是启用的。如果你没有使用，请在你的 `pom.xml` 中添加该属性 `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation of the `project(Class)` method uses the constructor's parameter names to build the select clause of the query,
so the compiler must be configured to store parameter names inside the compiled class.
This is enabled by default if you are using the Quarkus Maven archetype. If you are not using it, add the property `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` to your pom.xml.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `project(Class)` 方法的实现中，使用构造函数的参数名来构建查询的select子句，所以编译器必须配置为在编译的类中保留参数名。如果是使用Quarkus Maven archetype创建的项目，该功能默认是启用的。如果你没有使用，请在你的 `pom.xml` 中添加该属性 `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation of the `project(Class)` method uses the constructor's parameter names to build the select clause of the query, so the compiler must be configured to store parameter names inside the compiled class.  This is enabled by default if you are using the Quarkus Maven archetype. If you are not using it, add the property `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `project(Class)` 方法的实现中，使用构造函数的参数名来构建查询的select子句，所以编译器必须配置为在编译的类中保留参数名。如果是使用Quarkus Maven archetype创建的项目，该功能默认是启用的。如果你没有使用，请在你的 `pom.xml` 中添加该属性 `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation of the `project(Class)` method uses the constructor's parameter names to build the select clause of the query, so the compiler must be configured to store parameter names inside the compiled class.  This is enabled by default if you are using the Quarkus Maven archetype. If you are not using it, add the property `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` to your pom.xml.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `project(Class)` 方法的实现中，使用构造函数的参数名来构建查询的select子句，所以编译器必须配置为在编译的类中保留参数名。如果是使用Quarkus Maven archetype创建的项目，该功能默认是启用的。如果你没有使用，请在你的 `pom.xml` 中添加该属性 `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The important thing to note is the use of the https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] Kotlin compiler plugin.
In order to understand why this plugin is needed, first we need to note that by default all the classes generated from the Kotlin compiler are marked as `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注意的是，这里使用了 link:https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] 的Kotlin编译器插件。为了理解为什么需要这个插件，首先我们需要注意：在默认情况下，所有从Kotlin编译器生成的类都被标记为 `final` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The important thing to note is the use of the https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] Kotlin compiler plugin.  In order to understand why this plugin is needed, first we need to note that by default all the classes generated from the Kotlin compiler are marked as `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注意的是，这里使用了 link:https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] 的Kotlin编译器插件。为了理解为什么需要这个插件，首先我们需要注意：在默认情况下，所有从Kotlin编译器生成的类都被标记为 `final` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The incoming messages are acknowledged only once the processing completes successfully.
So, it commits the offset after the successful processing.
If the processing still fails, even after all retries, the message is _nacked_ and the failure strategy is applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传入的消息只有在处理成功完成后才会被确认。所以，它在处理成功后会提交偏移量。如果在所有的重试后处理仍然失败， 消息就会被标记为 _未确认(nacked)_ ，然后触发失败策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The incoming messages are acknowledged only once the processing completes successfully.  So, it commits the offset after the successful processing.  If the processing still fails, even after all retries, the message is _nacked_ and the failure strategy is applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传入的消息只有在处理成功完成后才会被确认。所以，它在处理成功后会提交偏移量。如果在所有的重试后处理仍然失败， 消息就会被标记为 _未确认(nacked)_ ，然后触发失败策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The incoming method can also receive `Message&lt;List&lt;Payload&gt;&gt;`, `KafkaRecordBatch&lt;Key, Payload&gt;` `ConsumerRecords&lt;Key, Payload&gt;` types.
They give access to record details such as offset or timestamp:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收方法也可以接收 `Message&lt;List&lt;Payload&gt;&gt;` , `KafkaRecordBatch&lt;Key, Payload&gt;` `ConsumerRecords&lt;Key, Payload&gt;` 等类型。这些类型可以访问记录的细节，如偏移量或时间戳：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The incoming method can also receive `Message&lt;List&lt;Payload&gt;&gt;`, `KafkaRecordBatch&lt;Key, Payload&gt;` `ConsumerRecords&lt;Key, Payload&gt;` types.  They give access to record details such as offset or timestamp:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收方法也可以接收 `Message&lt;List&lt;Payload&gt;&gt;` , `KafkaRecordBatch&lt;Key, Payload&gt;` `ConsumerRecords&lt;Key, Payload&gt;` 等类型。这些类型可以访问记录的细节，如偏移量或时间戳：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入的 Vert.x 实例是 `io.vertx.mutiny.core.Vertx` 类型，它是 Vert.x 的 Mutiny 变量；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance provides a set of APIs you can use.
The one we are going to use in this section is the Vert.x File System.
It provides a non-blocking API to access files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>被注入的Vert.x实例提供了一组你可以使用的API。我们在本节中要使用的是Vert.x文件系统。它提供了一个非阻塞的API来访问文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance provides a set of APIs you can use.  The one we are going to use in this section is the Vert.x File System.  It provides a non-blocking API to access files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>被注入的Vert.x实例提供了一组你可以使用的API。我们在本节中要使用的是Vert.x文件系统。它提供了一个非阻塞的API来访问文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instructions here are exactly as above with one change:  you'll need to add `native` as the first parameter to the
`manage.sh` script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里的说明与上面的完全一样，但有一个变化：你需要将 `native` 作为第一个参数添加到 `manage.sh` 脚本中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instructions here are exactly as above with one change: you'll need to add `native` as the first parameter to the `manage.sh` script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里的说明与上面的完全一样，但有一个变化：你需要将 `native` 作为第一个参数添加到 `manage.sh` 脚本中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instrumentation documented in this section has been tested with Quarkus and works in both standard and native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本节中用到的植入方式已经过Quarkus测试，并且在标准和本地模式下都能工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part starts when running the application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有趣的部分是在将应用程序作为本机可执行文件运行时开始的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interval in second between two reconnection attempts

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>两次尝试重新连接之间的间隔（秒）

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The kafka username (the client id from the service account)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的用户名(来自service account的客户端ID)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The key that will be used as the Redis key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将被用作Redis的Key</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The lambda can also be invoked locally with the SAM CLI like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个lambda也可以使用SAM CLI在本地调用，如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last extension is the reactive database driver for PostgreSQL.
Hibernate Reactive uses that driver to interact with the database without blocking the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一个扩展是PostgreSQL的响应式数据库驱动程序。Hibernate响应式使用该驱动程序与数据库交互，而不会阻塞调用线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last extension is the reactive database driver for PostgreSQL.  Hibernate Reactive uses that driver to interact with the database without blocking the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一个扩展是PostgreSQL的响应式数据库驱动程序。Hibernate响应式使用该驱动程序与数据库交互，而不会阻塞调用线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last option is to the use the link:https://kotlinlang.org/docs/reference/compiler-plugins.html#no-arg-compiler-plugin[no-arg] compiler plugin.
This plugin is configured with a list of annotations, and the end result is the generation of no-args constructor for each class annotated with them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一个选项是使用 link:https://kotlinlang.org/docs/reference/compiler-plugins.html#no-arg-compiler-plugin[无arg（参数）] 编译器插件。这个插件是用一个注释列表来配置的，最终的结果是为每个有注释的类生成无args（参数）构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last option is to the use the link:https://kotlinlang.org/docs/reference/compiler-plugins.html#no-arg-compiler-plugin[no-arg] compiler plugin.  This plugin is configured with a list of annotations, and the end result is the generation of no-args constructor for each class annotated with them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一个选项是使用 link:https://kotlinlang.org/docs/reference/compiler-plugins.html#no-arg-compiler-plugin[无arg（参数）] 编译器插件。这个插件是用一个注释列表来配置的，最终的结果是为每个有注释的类生成无args（参数）构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The legacy client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>旧客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The less easy way is to inject a `UserTransaction` and use the various transaction demarcation methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不太容易的方法是注入一个 `UserTransaction` ，并使用各种事务处理方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO Codec] provides a set of annotations that enable the customization of
the way a POJO is mapped to a MongoDB collection and this codec is initialized automatically by Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO编解码器] 提供了一组注解，可以自定义POJO映射到MongoDB集合的方式，该编解码器由Quarkus自动初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO Codec] provides a set of annotations that enable the customization of the way a POJO is mapped to a MongoDB collection and this codec is initialized automatically by Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO编解码器] 提供了一组注解，可以自定义POJO映射到MongoDB集合的方式，该编解码器由Quarkus自动初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The listener is invoked every time the consumer topic/partition assignment changes.
For example, when the application starts, it invokes the `partitionsAssigned` callback with the initial set of topics/partitions associated with the consumer.
If, later, this set changes, it calls the `partitionsRevoked` and `partitionsAssigned` callbacks again, so you can implement custom logic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>监听器会在消费者的topic/分区分配发生变化时启动。例如，当应用程序启动时，它会调用 `partitionsAssigned`  回调并传入与消费者相关的初始topic/分区集合 。如果后来这个集合发生变化，它会再次调用 `partitionsRevoked` 和 `partitionsAssigned` 回调，所以您可以自行实现对应的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The listener is invoked every time the consumer topic/partition assignment changes.  For example, when the application starts, it invokes the `partitionsAssigned` callback with the initial set of topics/partitions associated with the consumer.  If, later, this set changes, it calls the `partitionsRevoked` and `partitionsAssigned` callbacks again, so you can implement custom logic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>监听器会在消费者的topic/分区分配发生变化时启动。例如，当应用程序启动时，它会调用 `partitionsAssigned`  回调并传入与消费者相关的初始topic/分区集合 。如果后来这个集合发生变化，它会再次调用 `partitionsRevoked` 和 `partitionsAssigned` 回调，所以您可以自行实现对应的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The location of the getting started page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入门页面的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The location of the project GitHub organization.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目github组织的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The location of the project home page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目主页的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main property to configure is the URL to access to MongoDB, almost all configuration can be included in the connection URI so we advise you to do so, you can find more information in the MongoDB documentation: https://docs.mongodb.com/manual/reference/connection-string/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要配置的主要属性是访问MongoDB的URL，几乎所有的配置都可以包含在连接URI中，所以我们建议你这样做，你可以在MongoDB文档中找到更多信息 https://docs.mongodb.com/manual/reference/connection-string/ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The max delay (in seconds) between 2 reconnects

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>两次重新连接之间的最大延迟（秒）

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The max number of seconds to wait to determine if the connection with the broker is still established for the readiness check. After that threshold, the check is considered as failed.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>等待的最大秒数，以确定用于就绪检查的与代理的连接是否仍在建立。在该阈值之后，检查被认为是失败的。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of messages to be written to Kafka concurrently. It limits the number of messages waiting to be written and acknowledged by the broker. You can set this attribute to `0` remove the limit

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并发写入Kafka的消息的最大数量。它限制了等待被写入和被broker确认的消息的数量。你设置为： `0` 以解除该限制

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of reconnection before failing. -1 means infinite retry

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>失败前的最大重连次数。-1表示无限重试

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of seconds that a JWT may be issued for use. Effectively, the difference between the expiration date of the JWT and the issued at date must not exceed this value. Setting this property to a non-positive value relaxes the requirement for the token to have a valid 'iat' (issued at) claim.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JWT可能被发布使用的最大秒数。实际上，JWT的到期日和签发日期之间的差异不得超过这个值。将此属性设置为非正值，可以取消对令牌具有有效的 `iat`（签发日期）声明的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter is the message body. If the method returns _something_, it's the message response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>方法参数是消息主体。如果该方法返回 _something_ ，那就是消息的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method receives each Fruit. Note that you would need a deserializer to reconstruct the Fruit instances from the Kafka records.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方法接收每个Fruit对象。注意，您需要一个反序列化器来从Kafka记录中重建Fruit实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method receives the fruit instance to persist. It returns a `CompletionStage` which is used for the transaction demarcation. The transaction is committed when the return `CompletionStage` completes. In our case, it's when the message is written to Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方法接收要持久化的fruit实例。它返回了一个 `CompletionStage` ，用于事务分界。当返回的 `CompletionStage` 完成时，事务即会提交。在我们的例子中，这种情况就是消息被写入Kafka的时候。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The micrometer extension will make a best effort at representing URIs containing path parameters in templated form.
Using examples from above, a request to `http://localhost:8080/example/prime/7919` should appear as an attribute of
`http_server_requests_seconds_*` metrics with a value of `uri=/example/prime/{number}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer扩展将尽最大努力以模板的形式表示包含路径参数的URI。使用上面的例子，一个对 `&lt;a href="http://localhost:8080/example/prime/7919" class="bare"&gt;http://localhost:8080/example/prime/7919&lt;/a&gt;` 的请求应该作为 `http_server_requests_seconds_*` metrics 的一个属性出现，其值为 `uri=/example/prime/{number}` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The micrometer extension will make a best effort at representing URIs containing path parameters in templated form.  Using examples from above, a request to `http://localhost:8080/example/prime/7919` should appear as an attribute of `http_server_requests_seconds_*` metrics with a value of `uri=/example/prime/{number}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer扩展将尽最大努力以模板的形式表示包含路径参数的URI。使用上面的例子，一个对 `&lt;a href="http://localhost:8080/example/prime/7919" class="bare"&gt;http://localhost:8080/example/prime/7919&lt;/a&gt;` 的请求应该作为 `http_server_requests_seconds_*` metrics 的一个属性出现，其值为 `uri=/example/prime/{number}` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The minimum amount of data the server should return for a fetch request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>针对一个获取请求，服务器所应该返回的最小数据量。默认设置为1个字节，意味着在等待数据到达的同时，一旦有一个字节的数据可用，那么获取请求就会被响应，或者直至获取请求超时。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mock event server is also started for `@NativeImageTest` and `@QuarkusIntegrationTest` tests so will work
with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也会为 `@NativeImageTest` 和 `@QuarkusIntegrationTest` 测试启动模拟事件服务器，因此其也会与本地二进制文件一起工作。所有这些都为SAM CLI本地测试提供了类似的功能，而没有Docker的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mock event server is also started for `@NativeImageTest` and `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也会为 `@NativeImageTest` 和 `@QuarkusIntegrationTest` 测试启动模拟事件服务器，因此其也会与本地二进制文件一起工作。所有这些都为SAM CLI本地测试提供了类似的功能，而没有Docker的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most important attributes are listed in the tables below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下表格中列出了最重要的属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The multiple reactive facets of Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的多响应式方面特征</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the AMQP Client Option bean used to customize the AMQP client configuration

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于定制AMQP客户端配置的AMQP客户端选项bean的名称

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the link. If not set, the channel name is used.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>链接的名称。如果没有设置，则使用通道名称。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing keys are delegated to this handler which may retry or provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler` 的bean的名称。如果被设置，那么在反序列化键时发生的反序列化失败将被委托给这个处理程序，它可以重试或提供一个回退值。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing values are delegated to this handler which may retry or provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler` 的bean的名称。如果被设置，那么在反序列化值时发生的反序列化失败将被委托给这个处理程序，它可以重试或提供一个回退值。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener`. If set, this rebalance listener is applied to the consumer.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 的bean的名称。如果被设置，那么这个再均衡监听器就会应用到消费者上。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler`. If set, serialization failure happening when serializing keys are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler` 的bean的名称。如果被设置，那么在序列化键时发生的序列化失败将被委托给这个处理程序，它会重试或提供一个回退值。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler`. If set, serialization failure happening when serializing values are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler` 的bean的名称。如果被设置，那么在序列化值时发生的序列化失败将被委托给这个处理程序，它会重试或提供一个回退值。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们应用程序的原生可执行文件将包含应用程序代码、所需的库、Java API和一个缩小版的虚拟机。较小的虚拟机基础提高了应用程序的启动时间和最小的磁盘占用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable must be referenced as `runner` if you include a custom `bootstrap` script.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你包含一个自定义的 `bootstrap` 脚本，那么本地可执行文件必须被引用为 `runner` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable requires some additional steps to enable client SSL that S3 and other AWS libraries need.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地可执行文件需要一些额外的步骤来启用S3和其他AWS库需要的客户端SSL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native image can also be locally tested using the `sam.native.yaml` template:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地镜像也可以使用  `sam.native.yaml`  模板进行本地测试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新的 `Emitter.send` 方法会返回一个 `CompletionStage` ，并且它会在产生的消息被确认时完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier may be configured via the property `quarkus.transaction-manager.node-name`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点名称标识符可以通过属性 `quarkus.transaction-manager.node-name` 进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier needs to be unique per transaction manager deployment.
And the node identifier needs to be stable over the transaction manager restarts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点名称标识符需要在每个事务管理器部署中是唯一的。而且节点标识符需要在事务管理器重新启动时保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier needs to be unique per transaction manager deployment.  And the node identifier needs to be stable over the transaction manager restarts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点名称标识符需要在每个事务管理器部署中是唯一的。而且节点标识符需要在事务管理器重新启动时保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier plays a crucial part in the identification of a transaction.
The node name identifier is forged into the transaction id when the transaction is created.
Based on the node name identifier, the transaction manager is capable of recognizing the XA transaction
counterparts created in database or JMS broker. The identifier makes possible for the transaction manager
to roll back the transaction counterparts during recovery.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点名称标识符在交易的识别中起着至关重要的作用。当交易被创建时，节点名称标识符被做为成交易ID的一部分。基于节点名称标识符，事务管理器能够识别在数据库或JMS代理中创建的XA事务对应物。该标识符使事务管理器有可能在恢复期间回滚事务对应方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier plays a crucial part in the identification of a transaction.  The node name identifier is forged into the transaction id when the transaction is created.  Based on the node name identifier, the transaction manager is capable of recognizing the XA transaction counterparts created in database or JMS broker. The identifier makes possible for the transaction manager to roll back the transaction counterparts during recovery.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点名称标识符在交易的识别中起着至关重要的作用。当交易被创建时，节点名称标识符被做为成交易ID的一部分。基于节点名称标识符，事务管理器能够识别在数据库或JMS代理中创建的XA事务对应物。该标识符使事务管理器有可能在恢复期间回滚事务对应方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. Accepted values are: 0, 1, all

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生产者要求领导者认为一个请求完成之前收到的确认的数量。这控制了发送记录的延续性。可接受的值是：0, 1, all

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The number of partitions to be consumed concurrently. The connector creates the specified amount of Kafka consumers. It should match the number of partition of the targeted topic

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并发消费的分区的数量。连接器会创建指定数量的Kafka消费者。它应该与目标主题的分区数量相匹配

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The number of reconnection attempts

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尝试重新连接的次数

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our https://quarkus.io/community/#discussions[mailing list] to discuss your ideas and get help. And you can start reading our https://quarkus.io/guides/writing-extensions[Writing extensions guide] as well or more simply get inspiration from the https://github.com/quarkusio/quarkus/tree/main/extensions[existing ones].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当前的一个限制是，扩展必须同时在OpenJDK和GraalVM本机可执行文件中工作。这是我们给Quarkus用户的保证(他们应用程序的交叉编译)。我们有一个成熟度模型来改进扩展，使其完全 "Quarked" ，并从Quarkus中受益，所有这些都是在增量步骤中完成的。请登录我们的 https://quarkus.io/community/#discussions[邮件列表] 讨论您的想法并获得帮助。你也可以开始阅读我们的 https://quarkus.io/guides/writing-extensions[编写扩展指南]，或者更简单地从 https://github.com/quarkusio/quarkus/tree/main/extensions[现有的扩展] 中获得灵感。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与前面代码片段唯一的区别是生成的类型和指示每个事件类型的 `@RestSseElementType` 注解。由于 `@Produces` 注解定义了 `SERVER_SENT_EVENTS`，JAX-RS需要它知道每个（嵌套）事件的内容类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The page will provide a form to add costs, and an info of the current sum of costs.  The page periodically updates the sum by requesting the current sum from `/cost-collector`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该页面将提供一个表格用以添加成本，以及展示当前成本总和的信息。 该页面通过请求 `/cost-collector` 来定期更新当前成本的总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameter of the `process` method is the incoming message payload, whereas the return value will be used as the outgoing message payload.
Previously mentioned signatures for parameter and return types are also supported, such as `Message&lt;T&gt;`, `Record&lt;K, V&gt;`, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`process` 方法的参数是传入的消息的payload，而返回值将被用作传出的消息的payload。之前提到的参数和返回类型的签名也被支持，如 `Message&lt;T&gt;` ， `Record&lt;K, V&gt;` 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameter of the `process` method is the incoming message payload, whereas the return value will be used as the outgoing message payload.  Previously mentioned signatures for parameter and return types are also supported, such as `Message&lt;T&gt;`, `Record&lt;K, V&gt;`, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`process` 方法的参数是传入的消息的payload，而返回值将被用作传出的消息的payload。之前提到的参数和返回类型的签名也被支持，如 `Message&lt;T&gt;` ， `Record&lt;K, V&gt;` 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters passed to the application are described in the datasource guide.
There are other ways to configure the application - please check the xref:config-reference.adoc#configuration-sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数据源指南中描述了这些传递给应用程序的参数。还有其他方法可以配置应用程序——请查看 xref:config-reference.adoc#configuration_sources[配置指南]来了解各种可能性（例如`env`变量，`.env`文件等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters passed to the application are described in the datasource guide.
There are other ways to configure the application - please check the xref:config-reference.adoc#configuration_sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传递给应用程序的参数在数据源指南中进行了描述。还有其他配置应用程序的方法 - 请查看 xref:config-reference.adoc#configuration_sources[配置指南]来概览各种可能性（例如env变量，.env文件等等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters passed to the application are described in the datasource guide.  There are other ways to configure the application - please check the link:config-reference#configuration_sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传递给应用程序的参数在数据源指南中进行了描述。还有其他配置应用程序的方法 - 请查看 link:config-reference#configuration_sources[配置指南]来概览各种可能性（例如env变量，.env文件等等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters passed to the application are described in the datasource guide.  There are other ways to configure the application - please check the xref:config-reference.adoc#configuration-sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数据源指南中描述了这些传递给应用程序的参数。还有其他方法可以配置应用程序——请查看 xref:config-reference.adoc#configuration_sources[配置指南]来了解各种可能性（例如`env`变量，`.env`文件等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The password used to authenticate to the broker

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于对代理进行身份验证的密码

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The patterns are valid Java regexps.
Here we include all the XML files and JSON files into the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些模式都是有效的Java重组函数。在这里，我们将所有的XML文件和JSON文件纳入原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The patterns are valid Java regexps.  Here we include all the XML files and JSON files into the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些模式都是有效的Java重组函数。在这里，我们将所有的XML文件和JSON文件纳入原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The payload is converted to JSON (using a Json Mapper). The result is wrapped into AMQP Data using a **binary** content. The `content-type` is set to `application/json`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有效载荷被转换为JSON（使用Json Mapper）。结果被包装成使用 *二进制* 内容的AMQP数据。 `content-type` 被设置为 `application/json` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The period (in milliseconds) between two attempts to retrieve the credits granted by the broker. This time is used when the sender run out of credits.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>两次尝试检索代理授予的信用额度之间的时间段（以毫秒为单位）。当发送者用完信用额度的时候使用这个时间。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The polling timeout in milliseconds. When polling records, the poll will wait at most that duration before returning records. Default is 1000ms

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以毫秒为单位的轮询超时时间。当轮询记录时，轮询将在返回记录之前最多等待该时间段。默认是1000ms

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The port is `9093`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该端口为 `9093` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The prerequisites vary slightly depending on whether you are using Oracle GraalVM CE/EE or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前提条件依据您使用的是Oracle GraalVM CE/EE还是Mandrel略有不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses Mutiny reactive types.
If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的例子使用了Mutiny响应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的例子使用了Mutiny响应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的示例使用了Quarkus提供的_service_。同样，你也可以直接使用Vert.x客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous examples use synchronous processing.
Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的例子使用了同步处理。异步处理也可以通过返回一个 `io.smallrye.mutiny.Uni` 或一个 `java.util.concurrent.CompletionStage` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous examples use synchronous processing.  Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的例子使用了同步处理。异步处理也可以通过返回一个 `io.smallrye.mutiny.Uni` 或一个 `java.util.concurrent.CompletionStage` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven or Gradle, but it requires you to have created the native executable first.
In addition, this native executable must be a Linux 64 bits executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上一节向你展示了如何使用Maven或Gradle构建原生可执行文件，但这需要你先创建原生可执行文件。此外，这个原生可执行文件必须是Linux 64位可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven or Gradle, but it requires you to have created the native executable first.  In addition, this native executable must be a Linux 64 bits executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上一节向你展示了如何使用Maven或Gradle构建原生可执行文件，但这需要你先创建原生可执行文件。此外，这个原生可执行文件必须是Linux 64位可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven, but implicitly required that the proper GraalVM version be installed on the building machine (be it your local machine or your CI/CD infrastructure).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上一节向您展示了如何使用Maven构建原生可执行文件，但隐式地要求在构建机器上安装适当的GraalVM版本(无论是您的本地机器还是CI/CD基础设施)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The process for Gradle is analogous.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle的过程是类似的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.
However, it's not an issue as we are going to copy it to a container.
The project generation has provided a `Dockerfile.native-micro` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>产生的可执行文件将是一个64位的Linux可执行文件，所以取决于您的操作系统，它可能不再能够运行。然而，这不是一个问题，因为我们要把它复制到一个容器中。生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native-micro` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>产生的可执行文件将是一个64位的Linux可执行文件，所以取决于您的操作系统，它可能不再能够运行。然而，这不是一个问题，因为我们要把它复制到一个容器中。生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64-bit Linux executable, so depending on your operating system it may no longer be runnable.
However, it's not an issue as we are going to copy it to a container.
The project generation has provided a `Dockerfile.native-micro` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>产生的可执行文件将是一个64位的Linux可执行文件，所以如果您的操作系统不支持，它可能不能运行。但由于我们会把它复制到容器中，所以这不是一个问题。自动生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native-micro` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64-bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native-micro` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>产生的可执行文件将是一个64位的Linux可执行文件，所以如果您的操作系统不支持，它可能不能运行。但由于我们会把它复制到容器中，所以这不是一个问题。自动生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native-micro` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project generation has also provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目也在 `src/main/docker` 目录中提供了一个 `Dockerfile.native` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project should also contain a simple test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该项目还应该包含一个简单的测试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to
instantiate the projection DTO instead of using the entity class. This class must have a matching constructor with all the class attributes as parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>投影类必须是有效的Java Bean，并且拥有一个包含所有属性的构造方法，这个构造函数用于实例化投影DTO，而不是使用实体类。投影类必须有一个包含所有的类属性作为参数的构造方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to
instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>投影类必须是有效的Java Bean，并且拥有一个包含所有属性的构造方法，这个构造方法用于实例化投影DTO，而不是使用实体类。这个构造方法必须是唯一的构造方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to instantiate the projection DTO instead of using the entity class. This class must have a matching constructor with all the class attributes as parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>投影类必须是有效的Java Bean，并且拥有一个包含所有属性的构造方法，这个构造函数用于实例化投影DTO，而不是使用实体类。投影类必须有一个包含所有的类属性作为参数的构造方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>投影类必须是有效的Java Bean，并且拥有一个包含所有属性的构造方法，这个构造方法用于实例化投影DTO，而不是使用实体类。这个构造方法必须是唯一的构造方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties are shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些属性显示如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided `Dockerfiles` use https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI] (Universal Base Image) as parent image.  This base image has been tailored to work perfectly in containers.  The `Dockerfiles` use the https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version] of the base image to reduce the size of the produced image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供的 `Dockerfiles` 使用 https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI]（通用基础镜像）作为父镜像。这个基础镜像经过量身定做，可以在容器中完美工作。 `Dockerfiles` 使用基础镜像的 https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version]来减小生成镜像的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive API of the MongoDB with Panache uses Mutiny reactive types.
If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache的MongoDB的反应式API使用Mutiny反应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive API of the MongoDB with Panache uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache的MongoDB的反应式API使用Mutiny反应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive variant of the `Person` class will be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Person` 类的响应式变形将是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason for this is that the local build driver invoked through `-Dquarkus.native.container-build=true` uses volume mounts to make the JAR available in the build container, but volume mounts do not work with remote daemons. The remote container build driver copies the necessary files instead of mounting them. Note that even though the remote driver also works with local daemons, the local driver should be preferred in the local case because mounting is usually more performant than copying.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原因是通过 `-Dquarkus.native.container-build=true` 调用的本地构建驱动程序使用卷挂载来使 JAR 在构建容器中可用，但卷挂载对远程守护程序不起作用。远程容器构建驱动程序复制必要的文件，而不是挂载它们。请注意，即使远程驱动程序也能与本地守护进程一起工作，但在本地情况下，本地驱动程序应该是首选，因为挂载通常比复制性能更高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason of this restriction is that `@QuarkusTest` starts a Quarkus server for the whole lifetime of the tests execution run,
thus preventing the other tests to start their own Quarkus server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个限制的原因是 `@QuarkusTest` 会在测试执行的整个生命周期内启动一个Quarkus服务器，从而防止其他测试启动自己的Quarkus服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason of this restriction is that `@QuarkusTest` starts a Quarkus server for the whole lifetime of the tests execution run, thus preventing the other tests to start their own Quarkus server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个限制的原因是 `@QuarkusTest` 会在测试执行的整个生命周期内启动一个Quarkus服务器，从而防止其他测试启动自己的Quarkus服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The record written on the dead letter queue contains a set of additional headers about the original record:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有写入dead letter queue中的记录将包含一组关于原始记录的附加headers：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reply we build up makes use of the caller name, the `isSecure()` and `getAuthenticationScheme()` states of the request `SecurityContext`, and whether a non-null `JsonWebToken` was injected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当我们建立的回复时使用调用者的名字，和 `isSecure()` 和 `getAuthenticationScheme()` 这两个 `SecurityContext` 的状态，以及是否注入了非空的 `JsonWebToken` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The repository type to store JBeret and Job data. A jdbc type requires a JDBC datasource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>存储JBeret和Job数据的存储库类型。jdbc类型需要JDBC数据源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request is received by the `greeting` method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该请求由 `greeting` 方法接收</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response indicates that, in addition to the English page, there are a German and a French page about Quarkus on wikipedia.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该响应表明，除了英文页面，维基百科上还有关于 Quarkus 的德文和法文页面。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response indicates that, in addition to the English page, there are a German and a French page about Quarkus on wikipedia.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该响应表明，除了英文页面，维基百科上还有关于 Quarkus 的德文和法文页面。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the documentation show usages based on the active record pattern only,
but keep in mind that they can be performed with the repository pattern as well.
The repository pattern examples have been omitted for brevity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其余的文档只展示了基于活动记录模式的用法，但请记住，这些用法也可以用资源库模式来执行。为了简洁起见，已省略存储库模式示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the documentation show usages based on the active record pattern only, but keep in mind that they can be performed with the repository pattern as well.  The repository pattern examples have been omitted for brevity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其余的文档只展示了基于活动记录模式的用法，但请记住，这些用法也可以用资源库模式来执行。为了简洁起见，已省略存储库模式示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result should be: `Hello world` as it is the value obtained from the Spring Cloud Config server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>结果应该是： `Hello world` ，因为这是从Spring Cloud 配置服务器(Config Server)上获取的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same query facility exists for the reactive types, but the `stream()` methods act differently: they return a `Multi` (which implement  a reactive stream `Publisher`) instead of a `Stream`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应类型存在相同的查询工具，但 `stream()` 方法的作用不同：它们返回一个 `Multi` （实现了反应式流 `Publisher` ），而不是 `Stream` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same query facility exists for the reactive types, but the `stream()` methods act differently: they return a `Multi` (which implement a reactive stream `Publisher`) instead of a `Stream`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应类型存在相同的查询工具，但 `stream()` 方法的作用不同：它们返回一个 `Multi` （实现了反应式流 `Publisher` ），而不是 `Stream` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second application, the `processor`, in turn, will read from the `quote-requests` queue put a random price to the quote, and send it to a queue named `quotes`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反过来，第二个应用程序 `processor` ，将读取 `quote-requests` 队列，将一个随机价格放入报价，并将其发送给一个名为 `quotes` 的队列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second example shows the use of lambda scoped transactions, the first just runs a `Runnable` within a transaction, the second,
runs `Callable` with some specific options. In particular the `exceptionHandler` method can be used to control if the transaction
is rolled back or not on exception, and the `semantic` method controls the behaviour if an existing transaction is already started.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第二个例子展示了lambda范围内事务的使用，第一个例子只是在一个事务中运行 `Runnable` ，第二个例子，运行 `Callable` ，并带有一些特定的选项。特别是 `exceptionHandler` 方法可以用来控制事务是否在异常情况下回滚，而 `semantic` 方法可以控制现有事务已经开始时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second stage is a minimal image copying the produced native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第二阶段是复制产生了原生可执行文件的最小镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The serializer classname used to serialize the payload

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于序列化payload的序列化器的类名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The serializer classname used to serialize the record's key

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用来序列化记录的键的序列化器类名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `amqp-quickstart` {quickstarts-tree-url}/amqp-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案位于 `amqp-quickstart` {quickstarts-tree-url}/amqp-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `getting-started` 目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` {quickstarts-tree-url}/getting-started[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `getting-started` {quickstarts-tree-url}/getting-started[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `hibernate-orm-panache-quickstart` {quickstarts-tree-url}/hibernate-orm-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `hibernate-orm-panache-quickstart` {quickstarts-tree-url}/hibernate-orm-panache-quickstart[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `hibernate-reactive-panache-quickstart` {quickstarts-tree-url}/hibernate-reactive-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `hibernate-reactive-panache-quickstart` {quickstarts-tree-url}/hibernate-reactive-panache-quickstart[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `mongodb-panache-quickstart` {quickstarts-tree-url}/mongodb-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `mongodb-panache-quickstart` {quickstarts-tree-url}/mongodb-panache-quickstart[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `opentelemetry-quickstart` {quickstarts-tree-url}/opentelemetry-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `opentelemetry-quickstart` {quickstarts-tree-url}/opentelemetry-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jwt-quickstart` {quickstarts-tree-url}/security-jwt-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `security-jwt-quickstart` {quickstarts-tree-url}/security-jwt-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-keycloak-authorization-quickstart` {quickstarts-tree-url}/security-keycloak-authorization-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方案位于 `security-keycloak-authorization-quickstart` {quickstarts-tree-url}/security-keycloak-authorization-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-openid-connect-quickstart` {quickstarts-tree-url}/security-openid-connect-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `security-openid-connect-quickstart` {quickstarts-tree-url}/security-openid-connect-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `spring-boot-properties-quickstart` {quickstarts-tree-url}/spring-boot-properties-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `spring-boot-properties-quickstart` {quickstarts-tree-url}/spring-boot-properties-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `spring-scheduled-quickstart` {quickstarts-tree-url}/spring-scheduled-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `spring-scheduled-quickstart` {quickstarts-tree-url}/spring-scheduled-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `vertx-quickstart` {quickstarts-tree-url}/vertx-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `vertx-quickstart` {quickstarts-tree-url}/vertx-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution repository located in the `security-jwt-quickstart` {quickstarts-tree-url}/security-jwt-quickstart[directory] contains all the versions we have
worked through in this quickstart guide as well as some additional endpoints that illustrate subresources with injection
of ``JsonWebToken``s and their claims into those using the CDI APIs. We suggest that you check out the quickstart solutions and
explore the `security-jwt-quickstart` directory to learn more about the {extension-name} extension features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>位于 `security-jwt-quickstart` {quickstarts-tree-url}/security-jwt-quickstart[目录]中的解决方案库包含了我们在本快速入门指南中研究过的所有版本，以及一些额外的端点，用以说明将 `JsonWebToken` 及其声明注入到那些使用CDI APIs的子资源。我们建议你查看快速入门解决方案并探索 `security-jwt-quickstart` 目录，以了解更多关于{extension-name}扩展功能的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution repository located in the `security-jwt-quickstart` {quickstarts-tree-url}/security-jwt-quickstart[directory] contains all the versions we have worked through in this quickstart guide as well as some additional endpoints that illustrate subresources with injection of ``JsonWebToken``s and their claims into those using the CDI APIs. We suggest that you check out the quickstart solutions and explore the `security-jwt-quickstart` directory to learn more about the {extension-name} extension features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>位于 `security-jwt-quickstart` {quickstarts-tree-url}/security-jwt-quickstart[目录]中的解决方案库包含了我们在本快速入门指南中研究过的所有版本，以及一些额外的端点，用以说明将 `JsonWebToken` 及其声明注入到那些使用CDI APIs的子资源。我们建议你查看快速入门解决方案并探索 `security-jwt-quickstart` 目录，以了解更多关于{extension-name}扩展功能的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案位于 `getting-started-reactive` 和 `getting-started-reactive-crud` 目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source cache is located in the `target/sources` folder.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>源缓存位于 `target/sources` 文件夹中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code for the `/api/admin` endpoint is also very simple. The main difference here is that we are using a `@RolesAllowed` annotation to make sure that only users granted with the `admin` role can access the endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>端点 `/api/admin` 的源代码也非常简单。这里的主要区别是，我们使用 `@RolesAllowed` 注解来确保只有被授予 `admin` 角色的用户才能访问该端点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code for the `/api/admin` endpoint is also very simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/admin` 节点的源代码也非常简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code is hosted on &lt;a href="https://github.com/quarkusio/quarkus"&gt;GitHub&lt;/a&gt;. If you need to report a bug or request a new feature, look for a similar one on our &lt;a href="https://github.com/quarkusio/quarkus/issues"&gt;GitHub issue tracker&lt;/a&gt;. If you don’t find any, &lt;a href="https://github.com/quarkusio/quarkus/issues/new/choose"&gt;create a new issue&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>源代码被托管在&lt;a href="https://github.com/quarkusio/quarkus"&gt;GitHub&lt;/a&gt;。如果您需要报告一个错误或要求一个新功能，请在我们的&lt;a href="https://github.com/quarkusio/quarkus/issues"&gt;GitHub问题跟踪&lt;/a&gt;上寻找类似的问题。如果您没有找到，&lt;a href="https://github.com/quarkusio/quarkus/issues/new/choose"&gt;创建一个新问题&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The strategy is selected using the `failure-strategy` attribute.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>失败策略通过 `failure-strategy` 属性来设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the
https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to
https://camel.apache.org/camel-quarkus/latest/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus上对Apache Camel的支持由 https://github.com/apache/camel-quarkus[Apache Camel Quarkus 项目] 提供。 有关更多信息，请参阅 https://camel.apache.org/camel-quarkus/latest/[他们的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to https://camel.apache.org/camel-quarkus/latest/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus上对Apache Camel的支持由 https://github.com/apache/camel-quarkus[Apache Camel Quarkus 项目] 提供。 有关更多信息，请参阅 https://camel.apache.org/camel-quarkus/latest/[他们的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for multiple persistence units is described in detail in xref:hibernate-orm.adoc#multiple-persistence-units[the Hibernate ORM guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 link:hibernate-orm.html#multiple-persistence-units[Hibernate ORM指南] 中对多个持久化单元的支持有详细描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The table below gives an overview of the current IDEs with links and a high-level overview of their features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下表给出了当前支持的集成开发环境的概述，并附有链接和其功能概述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The target partition id. -1 to let the client determine the partition

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目标分区的ID。设置为-1可以客户端自行确定分区

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system
property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试端口可以通过 `quarkus.http.test-port` 配置属性来控制。Quarkus还创建了一个名为 `test.url` 的系统属性，在不能使用注入的情况下被设置为基本测试URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试端口可以通过 `quarkus.http.test-port` 配置属性来控制。Quarkus还创建了一个名为 `test.url` 的系统属性，在不能使用注入的情况下被设置为基本测试URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The time-to-live of the sent AMQP messages. 0 to disable the TTL

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送的AMQP消息的生存时间。0表示禁用TTL

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The total bytes of memory the producer can use to buffer records waiting to be sent to the server.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生产者可用于缓冲等待发送至服务器的记录的总字节数。

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transaction context is propagated to all calls nested in the `@Transactional` method as you would expect (in this example `childDAO.addToGiftList()` and `santaDAO.addToSantaTodoList()`).
The transaction will commit unless a runtime exception crosses the method boundary.
You can override whether an exception forces the rollback or not by using `@Transactional(dontRollbackOn=SomeException.class)` (or `rollbackOn`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如你所期望的那样，事务上下文被传播并嵌套在 `@Transactional` 方法中的所有调用（在这个例子中 `childDAO.addToGiftList()` 和 `santaDAO.addToSantaTodoList()` ）。除非有运行时异常穿越方法边界，否则事务将会提交。你可以通过使用 `@Transactional(dontRollbackOn=SomeException.class)` （或 `rollbackOn` ）来覆盖异常是否强制回滚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transaction context is propagated to all calls nested in the `@Transactional` method as you would expect (in this example `childDAO.addToGiftList()` and `santaDAO.addToSantaTodoList()`).  The transaction will commit unless a runtime exception crosses the method boundary.  You can override whether an exception forces the rollback or not by using `@Transactional(dontRollbackOn=SomeException.class)` (or `rollbackOn`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如你所期望的那样，事务上下文被传播并嵌套在 `@Transactional` 方法中的所有调用（在这个例子中 `childDAO.addToGiftList()` 和 `santaDAO.addToSantaTodoList()` ）。除非有运行时异常穿越方法边界，否则事务将会提交。你可以通过使用 `@Transactional(dontRollbackOn=SomeException.class)` （或 `rollbackOn` ）来覆盖异常是否强制回滚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use of multiple MongoDB clients enables multi-tenancy for MongoDB by allowing to connect to multiple MongoDB clusters. +
If you want to connect to multiple databases inside the same cluster,
multiple clients are **not** necessary as a single client is able to access all databases in the same cluster
(like a JDBC connection is able to access to multiple schemas inside the same database).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个 MongoDB 客户端的使用通过允许连接到多个 MongoDB 集群来实现 MongoDB 的多租户。+ 如果你想连接同一集群内的多个数据库，则 **不** 需要使用多个客户端，因为单个客户端能够访问同一集群内的所有数据库（就像JDBC连接能够访问同一数据库内的多个模式）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use of multiple MongoDB clients enables multi-tenancy for MongoDB by allowing to connect to multiple MongoDB clusters. + If you want to connect to multiple databases inside the same cluster, multiple clients are **not** necessary as a single client is able to access all databases in the same cluster (like a JDBC connection is able to access to multiple schemas inside the same database).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个 MongoDB 客户端的使用通过允许连接到多个 MongoDB 集群来实现 MongoDB 的多租户。+ 如果你想连接同一集群内的多个数据库，则 **不** 需要使用多个客户端，因为单个客户端能够访问同一集群内的所有数据库（就像JDBC连接能够访问同一数据库内的多个模式）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The username is the `$ConnectionString` string.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用户名是 `$ConnectionString` 字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The username used to authenticate to the broker

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于对代理进行身份验证的用户名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The value held by the Redis key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis的Key所持有的值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values from this file override any values from the regular `application.yaml` file if exists.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果存在的话，此文件中的值将覆盖常规 `application.yaml` 文件中的任何值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The website deployment is automatically performed by GitHub Actions (when commits are pushed to the `develop` branch).
If for some reason you need to deploy from your local machine, follow these instructions:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网站部署由GitHub Actions自动执行(当提交被推送到 `develop` 分支时)。
如果由于某些原因需要从本地机器进行部署，请遵循以下说明：

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The workaround is a bit more complex as besides sending the fruits coming from Kafka, we need to send pings periodically.
To achieve this we merge the stream coming from Kafka and a periodic stream emitting `{}` every 10 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该替代方法有点复杂，因为除了发送来自Kafka的fruit实例，我们还需要定期发送ping。为了实现这一点，我们合并了来自Kafka的数据流和一个每10秒发送一个 `{}` 的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The workaround is a bit more complex as besides sending the fruits coming from Kafka, we need to send pings periodically.  To achieve this we merge the stream coming from Kafka and a periodic stream emitting `{}` every 10 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该替代方法有点复杂，因为除了发送来自Kafka的fruit实例，我们还需要定期发送ping。为了实现这一点，我们合并了来自Kafka的数据流和一个每10秒发送一个 `{}` 的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The xref:mongodb-panache.adoc[MongoDB with Panache] extension facilitates the usage of MongoDB by providing active record style entities (and repositories) like you have in xref:hibernate-orm-panache.adoc[Hibernate ORM with Panache] and focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mongodb-panache.html[MongoDB with Panache] 扩展通过提供活动记录样式实体（和存储库）来促进 MongoDB 的使用，就像您在 link:hibernate-orm-panache.html[Hibernate ORM with Panache] 中所拥有的一样，并关注让你的实体在 Quarkus 中编写变得简单而有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then add the relevant configuration properties in `{config-file}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后在 `{config-file}` 中添加相关的配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then check that the endpoint returns `hello quarkus` as expected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后检查端点是否按预期返回 `hello quarkus` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then execute the following sequence:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后执行以下命令序列：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then run it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then try the following sequence and look for `example_list_size` in the plain text output:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后尝试以下命令并在文本输出中找出 `example_list_size` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then use `@QuarkusTestResource` to configure the Kafka Companion in tests, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后使用 `@QuarkusTestResource` 在测试中配置Kafka Companion，比如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then visit the http://localhost:16686[Jaeger UI] to see the tracing information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后访问 link:http://localhost:16686[Jaeger界面] 来查看追踪信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need to create a `CodecProvider` to link this `Codec` to the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后你需要创建一个 `CodecProvider` 来把这个 `Codec` 链接到 `Fruit` 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a Quarkus Test Resource as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，按以下方法创建Quarkus测试资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，用以下方法创建本地可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, deploy the verticle instances with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，用以下方法部署verticle实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, deploy your verticle as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，按以下方式部署你的verticle：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, edit the `ReactiveGreetingResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，编辑 `ReactiveGreetingResource` 类，以匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, if you didn't delete the generated native executable, you can build the docker image with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，如果你没有删除生成的原生可执行文件，可以用以下方法构建docker镜像：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, in a terminal, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，在终端中，运行以下命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, in the `VertxResource` file add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，在 `VertxResource` 文件中添加以下方法:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, invoke the endpoint using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，使用以下命令请求该端点:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, invoke the endpoint using:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，使用以下命令请求该端点:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, launch the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，使用以下命令启动应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，让我们配置数据源。打开 `src/main/resources/application.properties` 并添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，让我们在 `FruitResource` 中使用这个 `Fruit` 类。编辑 `FruitResource` 类，匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/GreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，打开 `src/test/java/org/acme/quickstart/GreetingResourceIT.java` 。它包含了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，打开 `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java` 。它包含了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we need to start a Redis instance (if you do not have one already) using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果还没有Redis服务实例，我们需要使用以下命令启动一个Redis实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you can configure the Quarkus application to connect to the broker as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，您可以配置Quarkus应用程序以连接到broker，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you can create the following resource to create/read/update/delete your Person entity:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，你可以创建以下资源来create/read/update/delete你的Person实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you can reconstruct the instance using the `mapTo` method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，你可以使用 `mapTo` 方法重新构建该实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, your application can generate messages and publish them to the `prices-out` channel.
It can use `double` payloads as in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，您的程序可以生成消息并将其发布到 `prices-out` channel。它可以使用 `double` payloads，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, your application can generate messages and publish them to the `prices-out` channel.  It can use `double` payloads as in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，您的程序可以生成消息并将其发布到 `prices-out` channel。它可以使用 `double` payloads，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 `@Blocking` annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有2种 `@Blocking` 注解：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 important points:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有两点很重要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few steps to get your lambda running on AWS.  The generated maven project contains a helpful script to
create, update, delete, and invoke your lambdas for pure Java and native deployments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有几个步骤可以让lambda在AWS上运行。生成的maven项目包含一个有用的脚本，来为纯Java和原生部署创建、更新、删除和调用你的lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few steps to get your lambda running on AWS.  The generated maven project contains a helpful script to create, update, delete, and invoke your lambdas for pure Java and native deployments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有几个步骤可以让lambda在AWS上运行。生成的maven项目包含一个有用的脚本，来为纯Java和原生部署创建、更新、删除和调用你的lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.
These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有很多不同的配置选项可以影响原生可执行文件的生成方式。这些都是在 `application.properties` ，与其他配置属性相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有很多不同的配置选项可以影响原生可执行文件的生成方式。这些都是在 `application.properties` ，与其他配置属性相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are always new users trying to get started quickly. Share your experience with everyone by writing a Quickstart and submitting it for peer review.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>总有一些新用户试图快速入门。通过撰写 "快速入门 "并提交给同行评审，与大家分享你的经验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases where the initialization of certain classes is done in a static block needs to be postponed to runtime.
Typically omitting such configuration would result in a runtime exception like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些情况下，某些类的初始化是在静态块中完成的，需要推迟到运行时。通常情况下，省略这样的配置会导致运行时的异常，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases where the initialization of certain classes is done in a static block needs to be postponed to runtime.  Typically omitting such configuration would result in a runtime exception like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些情况下，某些类的初始化是在静态块中完成的，需要推迟到运行时。通常情况下，省略这样的配置会导致运行时的异常，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are heaps of helpful &lt;a href="{{site.baseurl}}/publications"&gt;articles and blog posts&lt;/a&gt; out there presenting interesting use-cases and examples of Quarkus in action.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有很多有用的&lt;a href="{{site.baseurl}}/publications"&gt;文章和博文&lt;/a&gt;，介绍了Quarkus的有趣用例和实际应用的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several other ways your application can consume incoming messages:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您的应用程序还可以通过另外集中方式来消费接收到的消息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus实现响应式应用程序有几种方法。在本指南中，我们将使用RESTEasy Reactive，一个受益于Quarkus Reactive引擎的RESTEasy的实现。默认情况下，它调用I/O线程上的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are three configuration settings that alter the RBAC Deny behavior:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有三个配置项可以改变RBAC拒绝行为：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are times you may want to set a specific system properties or other arguments when lambda invokes
your native quarkus lambda deployment.  If you include a `bootstrap` script file within
`zip.native`, the quarkus extension will automatically rename the executable to `runner` within
`function.zip` and set the unix mode of the `bootstrap` script to executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些时候你可能想在lambda调用你的原生quarkus lambda部署时设置特定的系统属性或其他参数。如果你在 `zip.native` 中包含一个 `bootstrap` 脚本文件，quarkus 扩展会在 `function.zip` 中自动将可执行文件重命名为 `runner` ，并将 `bootstrap` 脚本的 unix 模式设置为可执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are times you may want to set a specific system properties or other arguments when lambda invokes your native quarkus lambda deployment.  If you include a `bootstrap` script file within `zip.native`, the quarkus extension will automatically rename the executable to `runner` within `function.zip` and set the unix mode of the `bootstrap` script to executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些时候你可能想在lambda调用你的原生quarkus lambda部署时设置特定的系统属性或其他参数。如果你在 `zip.native` 中包含一个 `bootstrap` 脚本文件，quarkus 扩展会在 `function.zip` 中自动将可执行文件重命名为 `runner` ，并将 `bootstrap` 脚本的 unix 模式设置为可执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two different ways to fix this type of issues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有两种不同的方法来解决这种类型的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to configure the OTLP gRPC Exporter within the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有两种方法可以在应用程序中配置OTLP gRPC exporter。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个Mutiny 版本的Vert.x的API。这个API被分为几个可以独立导入的工件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `JsonbSerializer` that can be used to serialize all data objects via JSON-B.
You may create an empty subclass if you want to use &lt;&lt;serialization-autodetection&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个现有的 `JsonbSerializer` ，可以通过JSON-B来序列化所有的数据对象。如果您想使用 link:#serialization-autodetection[[序列化自动侦测]] ，您可以创建一个空的子类类继承它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `JsonbSerializer` that can be used to serialize all data objects via JSON-B.  You may create an empty subclass if you want to use &lt;&lt;serialization-autodetection&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个现有的 `JsonbSerializer` ，可以通过JSON-B来序列化所有的数据对象。如果您想使用 link:#serialization-autodetection[[序列化自动侦测]] ，您可以创建一个空的子类类继承它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `ObjectMapperSerializer` that can be used to serialize all data objects via Jackson.
You may create an empty subclass if you want to use &lt;&lt;serialization-autodetection&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个现有的 `ObjectMapperSerializer` ，可以用来通过Jackson来序列化所有的数据对象。如果您想使用 link:#serialization-autodetection[[自动侦测序列化]] ，您可以创建一个空的子类来继承该类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `ObjectMapperSerializer` that can be used to serialize all data objects via Jackson.  You may create an empty subclass if you want to use &lt;&lt;serialization-autodetection&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个现有的 `ObjectMapperSerializer` ，可以用来通过Jackson来序列化所有的数据对象。如果您想使用 link:#serialization-autodetection[[自动侦测序列化]] ，您可以创建一个空的子类来继承该类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension
(if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploying an AWS Gateway REST API).
These extensions automatically generate everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了包含 `quarkus-amazon-lambda-http` 扩展（如果你要部署AWS Gateway HTTP API）或 `quarkus-amazon-lambda-rest` 扩展（如果你要部署AWS Gateway REST API）外，POM没有什么特别之处。这些扩展会自动生成你的lambda部署可能需要的一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploying an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了包含 `quarkus-amazon-lambda-http` 扩展（如果你要部署AWS Gateway HTTP API）或 `quarkus-amazon-lambda-rest` 扩展（如果你要部署AWS Gateway REST API）外，POM没有什么特别之处。这些扩展会自动生成你的lambda部署可能需要的一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda` extension
as a dependency.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了将 `quarkus-amazon-lambda` 扩展作为一个依赖项之外，POM并没有什么特别之处。该扩展会为你的lambda部署自动生成可能需要的一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda` extension as a dependency.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了将 `quarkus-amazon-lambda` 扩展作为一个依赖项之外，POM并没有什么特别之处。该扩展会为你的lambda部署自动生成可能需要的一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is only one thing to remember: if you use `Response` and Quarkus can't determine the beans that are serialized, you need to annotate them with `@RegisterForReflection`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>只有一件事要记住：如果您使用 `Response` 并且 Quarkus 无法确定被序列化的 bean，则需要使用 `@RegisterForReflection` 注解它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, if you want to use a data class as an entity class, you need a way to make Kotlin generate an empty constructor.
To do so, you need to provide default values for all the fields of your classes.
The following sentence from the Kotlin documentation explains it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，如果你想使用一个数据类作为实体类，你需要一种方法来使Kotlin生成一个空的构造函数。要做到这一点，你需要为你的类的所有字段提供默认值。下面这句话来自Kotlin文档的解释：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, if you want to use a data class as an entity class, you need a way to make Kotlin generate an empty constructor.  To do so, you need to provide default values for all the fields of your classes.  The following sentence from the Kotlin documentation explains it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，如果你想使用一个数据类作为实体类，你需要一种方法来使Kotlin生成一个空的构造函数。要做到这一点，你需要为你的类的所有字段提供默认值。下面这句话来自Kotlin文档的解释：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are normal Quarkus config properties, so if you always want to build in a container
it is recommended you add these to your `application.properties` in order to avoid specifying them every time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些是标准的Quarkus配置属性，所以如果你总是想在容器中构建，建议你把这些添加到你的 `application.properties` ，以避免每次都指定它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are normal Quarkus config properties, so if you always want to build in a container it is recommended you add these to your `application.properties` in order to avoid specifying them every time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些是标准的Quarkus配置属性，所以如果你总是想在容器中构建，建议你把这些添加到你的 `application.properties` ，以避免每次都指定它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These endpoints are protected and can only be accessed if a client is sending a bearer token along with the request, which must be valid (e.g.: signature, expiration and audience) and trusted by the microservice.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些节点是受保护的，只有当客户端将一个bearer token与请求一起发送时才能被访问，而且该token必须是有效的（例如：签名、过期时间和受众），并且要得到微服务的信任。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These instructions will get you a copy of the Quarkus.io website up and running on your local machine for development and testing purposes.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些指令会给你一份Quarkus.io网站的副本，启动并运行在本地机器上，用于开发和测试。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These properties can be set through Java's `-D` command line parameter or
on `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些属性可以通过 Java 的 `-D` 命令行参数或在 `application.properties` 上设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These properties can be set through Java's `-D` command line parameter or on `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些属性可以通过 Java 的 `-D` 命令行参数或在 `application.properties` 上设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These tests use http://rest-assured.io/[RestAssured], but feel free to use your favorite library.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些测试使用 link:http://rest-assured.io/[RestAssured] ，但也可以随意使用你最喜欢的库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These types differ from the Java types mentioned in those tutorials.  For Kotlin support, all the Panache
types will be found in the `io.quarkus.mongodb.panache.kotlin` package.  This subpackage allows for the distinction
between the Java and Kotlin variants and allows for both to be used unambiguously in a single project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些类型与那些教程中提到的Java类型不同。对于Kotlin支持，所有的Panache类型将在 `io.quarkus.mongodb.panache.kotlin` 包中都可以找到。这个子包允许区分Java和Kotlin变体，并允许在一个项目中明确地使用这两种类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These types differ from the Java types mentioned in those tutorials.  For Kotlin support, all the Panache types will be found in the `io.quarkus.mongodb.panache.kotlin` package.  This subpackage allows for the distinction between the Java and Kotlin variants and allows for both to be used unambiguously in a single project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些类型与那些教程中提到的Java类型不同。对于Kotlin支持，所有的Panache类型将在 `io.quarkus.mongodb.panache.kotlin` 包中都可以找到。这个子包允许区分Java和Kotlin变体，并允许在一个项目中明确地使用这两种类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They have the same effect.
Thus, you can use both.
The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.
The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它们效果相同。因此，您可以随意使用。第一个提供了更精细的配置，比如worker pool以及是否保留顺序。第二种，同其他的Quarkus Reactive功能类似，使用默认的worker pool并且保留了顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They have the same effect.  Thus, you can use both.  The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.  The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它们具有同样的效果。因此，两者都可以使用。第一个提供了更精细的调优，如使用的工作池以及它是否保留顺序。第二种，也与Quarkus的其他响应式特性一起使用，使用默认的工作池并保留顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以将Quarkus扩展视为您的项目依赖项。扩展可以配置、引导并将框架或技术集成到您的Quarkus应用程序中。它们还做了所有繁重的工作，为GraalVM提供正确的信息，以便应用程序本地编译。这将允许第三方项目轻松地利用我们所做的工作，使其更容易瞄准GraalVM。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 _entity_ 包含一些字段和方法，用于从数据库中查找、更新和删除行。当检索到结果时，所生成的项被异步触发，这些方法返回 `Unis` 或 `Multis` 。注意，响应式PostgreSQL客户端已经提供了 `Uni` 和 `Multi` 实例。因此，您只需将来自数据库的结果转换为 _business-friendly_ 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This `/subject/secured` endpoint requires an authenticated user that has been granted the role "Tester" through the use of the `@RolesAllowed("Tester")` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/subject/secured` 节点需要一个经过认证的用户，该用户通过使用 `@RolesAllowed("Tester")` 注解被授予 "Tester "的角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows your reactive methods to keep on working on the transaction asynchronously until their
work is really done, and not just until the reactive method returns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这允许你的响应式方法以异步方式继续在事务上工作，直到他们的工作真正完成，而不仅仅是当响应式方法返回时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows your reactive methods to keep on working on the transaction asynchronously until their work is really done, and not just until the reactive method returns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这允许你的响应式方法以异步方式继续在事务上工作，直到他们的工作真正完成，而不仅仅是当响应式方法返回时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该注解允许您将URL直接注入为Quarkus实例，注解的值将是URL的路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation defines your transaction boundaries and will wrap this call within a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个注解定义了你的事务边界，并将把这个调用包含在一个事务中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation may only be placed on the top level method delineating the transaction.
Annotated nested methods once a transaction has started will throw an exception.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个注释只能放在划定事务的顶层方法上。一旦事务开始，被注解的嵌套方法将抛出一个异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation may only be placed on the top level method delineating the transaction.  Annotated nested methods once a transaction has started will throw an exception.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个注释只能放在划定事务的顶层方法上。一旦事务开始，被注解的嵌套方法将抛出一个异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application is interacting with a PostgreSQL database, so you need one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个应用程序与一个PostgreSQL数据库交互，所以你需要一个：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种方法只适用于JVM测试。它不能用于原生测试(因为原生模式不支持注入)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach provides a more limited coverage compared to the Wiremock approach - for example, the remote communication code is not covered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Wiremock方法相比，这种方法提供了更有限的覆盖范围--例如，远程通信代码没有被覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This auto-attachment can be disabled using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以用以下方法禁用这种auto-attachment功能：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean receives the name and returns the greeting message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个Bean接收名字并返回响应信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.mongodb.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以通过在 `application.properties` 中将 `quarkus.mongodb.health.enabled` 属性设置为 `false` 来禁用此行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.redis.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以通过在 `application.properties` 中设置 `quarkus.redis.health.enabled` 属性为 `false` 来禁用这个连接健康检查。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This call to obtain the user principal will return null if the caller is unauthenticated, non-null if the caller is authenticated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果调用者未认证，这个获取用户principal的调用会返回null, 否则不会为null。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be achieved by setting to DEBUG the following log category inside your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这可以通过在你的 `application.properties` ，将以下日志类别设置为DEBUG来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class represents `Fruits`.
It's a straightforward entity with a single field (`name`).
Note that it uses `io.quarkus.hibernate.reactive.panache.PanacheEntity`, the reactive variant of `PanacheEntity`.
So, behind the scenes, Hibernate uses the execution model we described above.
It interacts with the database without blocking the thread.
In addition, this reactive `PanacheEntity` proposes a reactive API.
We will use this API to implement the REST endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个类代表 `Fruits`。它是一个简单的实体，只有一个字段 (`name`)。注意，它使用的是 `io.quarkus.hibernate.reactive.panache.PanacheEntity`，是 `PanacheEntity` 的响应式类库。因此，Hibernate在幕后使用我们前面描述的执行模型。它与数据库交互而不阻塞线程。此外，这个响应式的 `PanacheEntity` 提出了一个响应式API。我们将使用这个API来实现REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class represents `Fruits`.  It's a straightforward entity with a single field (`name`).  Note that it uses `io.quarkus.hibernate.reactive.panache.PanacheEntity`, the reactive variant of `PanacheEntity`.  So, behind the scenes, Hibernate uses the execution model we described above.  It interacts with the database without blocking the thread.  In addition, this reactive `PanacheEntity` proposes a reactive API.  We will use this API to implement the REST endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个类代表 `Fruits`。它是一个简单的实体，只有一个字段 (`name`)。注意，它使用的是 `io.quarkus.hibernate.reactive.panache.PanacheEntity`，是 `PanacheEntity` 的响应式类库。因此，Hibernate在幕后使用我们前面描述的执行模型。它与数据库交互而不阻塞线程。此外，这个响应式的 `PanacheEntity` 提出了一个响应式API。我们将使用这个API来实现REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This code configures the SockJS bridge to send all the messages targeting the `ticks` address to the connected browsers.
More detailled explanations about the configuration can be found on https://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge[the Vert.x SockJS Bridge documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这段代码配置了SockJS桥接器，以将所有针对 `ticks` 地址的信息发送到所连接的浏览器。更详细的配置说明可以在 https://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge[Vert.x SockJS Bridge文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This code configures the SockJS bridge to send all the messages targeting the `ticks` address to the connected browsers.  More detailled explanations about the configuration can be found on https://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge[the Vert.x SockJS Bridge documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这段代码配置了SockJS桥接器，以将所有针对 `ticks` 地址的信息发送到所连接的浏览器。更详细的配置说明可以在 https://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge[Vert.x SockJS Bridge文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command creates the project structure and select the two Quarkus extensions we will be using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个命令会创建项目结构，并选择我们将要使用的两个Quarkus扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project with the `spring-scheduled` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个包含 `spring-scheduled` 扩展项的Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and HTTP connector extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven项目，导入Reactive Messaging和HTTP 连接扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `oidc` extension
which is an implementation of OIDC for Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个Maven项目，导入了 `oidc` 扩展，这个扩展是Quarkus的OIDC实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `oidc` extension which is an implementation of OIDC for Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个Maven项目，导入了 `oidc` 扩展，这个扩展是Quarkus的OIDC实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, that imports the `micrometer-registry-prometheus` extension as a dependency.
This extension will load the core `micrometer` extension as well as additional library dependencies required to support
prometheus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven项目，将 `micrometer-registry-prometheus` 扩展作为一个依赖导入。该扩展将加载核心的 `micrometer` 扩展，以及支持Prometheus所需的其他依赖项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, that imports the `micrometer-registry-prometheus` extension as a dependency.
This extension will load the core `micrometer` extension as well as additional library dependencies required to support prometheus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven项目，将 `micrometer-registry-prometheus` 扩展作为一个依赖导入。该扩展将加载核心的 `micrometer` 扩展，以及支持Prometheus所需的其他依赖项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, that imports the `micrometer-registry-prometheus` extension as a dependency.  This extension will load the core `micrometer` extension as well as additional library dependencies required to support prometheus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven项目，将 `micrometer-registry-prometheus` 扩展作为一个依赖导入。该扩展将加载核心的 `micrometer` 扩展，以及支持Prometheus所需的其他依赖项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy Reactive Jackson and MongoDB Client extensions.
After this, the `quarkus-mongodb-client` extension has been added to your build file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个导入RESTEasy Reactive Jackson和MongoDB客户端扩展的Maven结构。在此之后， `quarkus-mongodb-client` 扩展已被添加到您的构建文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy Reactive Jackson and MongoDB Client extensions.  After this, the `quarkus-mongodb-client` extension has been added to your build file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个导入RESTEasy Reactive Jackson和MongoDB客户端扩展的Maven结构。在此之后， `quarkus-mongodb-client` 扩展已被添加到您的构建文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy Reactive Jackson and MongoDB with Panache extensions.
After this, the `quarkus-mongodb-panache` extension has been added to your build file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven结构，导入RESTEasy Reactive Jackson和MongoDB with Panache扩展。在此之后， `quarkus-mongodb-panache` 扩展已被添加到您的构建文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy Reactive Jackson and MongoDB with Panache extensions.  After this, the `quarkus-mongodb-panache` extension has been added to your build file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven结构，导入RESTEasy Reactive Jackson和MongoDB with Panache扩展。在此之后， `quarkus-mongodb-panache` 扩展已被添加到您的构建文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a new project importing the RESTEasy Reactive/JAX-RS and https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] extensions,
and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个导入RESTEasy Reactive/JAX-RS和 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] 扩展的新项目，特别是添加了以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a new project importing the RESTEasy Reactive/JAX-RS and https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个导入RESTEasy Reactive/JAX-RS和 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] 扩展的新项目，特别是添加了以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a new project importing the RESTEasy Reactive/JAX-RS and https://github.com/FasterXML/jackson[Jackson] extensions,
and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个导入RESTEasy Reactive/JAX-RS和 link:https://github.com/FasterXML/jackson[Jackson] 扩展的新项目，特别是添加了以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a new project importing the RESTEasy Reactive/JAX-RS and https://github.com/FasterXML/jackson[Jackson] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个导入RESTEasy Reactive/JAX-RS和 link:https://github.com/FasterXML/jackson[Jackson] 扩展的新项目，特别是添加了以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a new project, importing the Redis extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令可生成一个新项目，并导入Redis扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a project and imports the `spring-boot-properties` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个项目并导入了 `spring-boot-properties` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a project which imports the `spring-cloud-config-client` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个已导入 `spring-cloud-config-client` 扩展的项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a project, importing the `keycloak-authorization` extension which is an implementation of a Keycloak Adapter for Quarkus applications and provides all the necessary capabilities to integrate with a Keycloak Server and perform bearer token authorization.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个项目并导入 `keycloak-authorization` 扩展，该扩展是一个用于Quarkus应用程序的Keycloak适配器的实现，并提供所有必要的功能来与Keycloak服务器集成并执行bearer token授权。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project and imports the `quarkus-opentelemetry-exporter-otlp` extension,
which includes the OpenTelemetry support,
and a gRPC span exporter for https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md[OTLP].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成Maven项目并导入 `quarkus-opentelemetry-exporter-otlp` 扩展，其中包括OpenTelemetry支持，以及 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md[OTLP] 的gRPC span exporter。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project and imports the `smallrye-jwt` extension, which includes the {mp-jwt} support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成Maven项目并导入 `smallrye-jwt` 扩展，其中包括{mp-jwt}支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will start a Redis instance to execute the tests. Thus your Redis containers need to be stopped.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下命令将启动一个Redis实例以执行测试。因此，需要停掉你的Redis容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configuration can be global (as above), or set in the channel configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个配置可以是全局的(如上)，也可以在 channel 配置中设置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configuration is equivalent to the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该配置相当于以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configuration will only impact resources served from the fixed/static URL `/public`, which may not match your application resources if `quarkus.http.root-path` has been set to something other than `/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此配置将只影响从固定/静态URL `/public` 提供的资源，如果 `quarkus.http.root-path` 被设置为其他的 `/` ，那么它可能与您的应用程序资源不匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This connector is for AMQP 1.0. RabbitMQ implements AMQP 0.9.1.
RabbitMQ does not provide AMQP 1.0 by default, but there is a plugin for it.
To use RabbitMQ with this connector, enable and configure the AMQP 1.0 plugin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此连接器用于 AMQP 1.0. RabbitMQ 实现 AMQP 0.9.1。RabbitMQ 默认不提供 AMQP 1.0，但有一个插件。要将此连接器与RabbitMQ一起使用，请启用并配置 AMQP 1.0 插件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This connector is for AMQP 1.0. RabbitMQ implements AMQP 0.9.1.  RabbitMQ does not provide AMQP 1.0 by default, but there is a plugin for it.  To use RabbitMQ with this connector, enable and configure the AMQP 1.0 plugin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此连接器用于 AMQP 1.0. RabbitMQ 实现 AMQP 0.9.1。RabbitMQ 默认不提供 AMQP 1.0，但有一个插件。要将此连接器与RabbitMQ一起使用，请启用并配置 AMQP 1.0 插件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This constructor will be used by Hibernate, and it must have a matching constructor with all the class attributes as parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate会用到这个构造方法，它必须有一个匹配的构造函数，所有的类属性都是参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This constructor will be used by Hibernate, it must be the only constructor in your class and have all the class attributes as parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate会用到这个构造方法，它必须是类中唯一的构造函数，并且包含所有类属性作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This currently does not support the `@ApplicationPath()` annotation to set the JAX-RS context path. Use the
`quarkus.resteasy.path` config value instead if you want a custom context path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目前不支持使用 `@ApplicationPath()` 注解来设置 JAX-RS 上下文路径。如果您想要一个自定义的上下文路径，请使用 `quarkus.resteasy.path` 代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This currently does not support the `@ApplicationPath()` annotation to set the JAX-RS context path. Use the `quarkus.resteasy.path` config value instead if you want a custom context path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目前不支持使用 `@ApplicationPath()` 注解来设置 JAX-RS 上下文路径。如果您想要一个自定义的上下文路径，请使用 `quarkus.resteasy.path` 代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This defines a role based policy that allows users with the `user` and `admin` roles. This is referenced by later rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义了一个基于角色的策略来授权给具有 `user` 和 `admin` 角色的用户。该配置会被后面的规则所引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This definition is very important as we will have to use it in the service.
Once we have this `Command` we can start to update the redis-client extension by:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要在服务中使用这个Redis命令，因此这个定义非常重要。有了这个 `Command` 定义后，我们就可以开始更新redis-client扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the Vert.x Web Client, which we will be using to implement the `/web` endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该依赖项提供了Vert.x Web客户端，我们将用它来实现 `/web` 端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the callback handler required to handle the OAuth workflow.
Then, in the `application.properties`, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个依赖提供了处理OAuth工作流所需的回调处理器。然后，在 `application.properties` ，添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个依赖提供了处理OAuth工作流所需的回调处理器。然后，在 `application.properties` ，添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This documentation does not cover all the details of the connector.
Refer to the https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging website] for further details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本文档并没有涵盖连接器的所有细节。请参考 link:https://smallrye.io/smallrye-reactive-messaging[SmallRye 响应式消息网站] ，来了解更多细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This documentation does not cover all the details of the connector.  Refer to the https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging website] for further details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本文档并没有涵盖连接器的所有细节。请参考 link:https://smallrye.io/smallrye-reactive-messaging[SmallRye 响应式消息网站] ，来了解更多细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint handles HTTP `GET` request on path `/lorem` (so the full path will be `vertx/lorem`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该端点处理路径 `/lorem` 上的 HTTP `GET` 请求（因此完整路径是 `vertx/lorem` ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个端点将项目以JSON数组的形式发送给客户端。消息的名称和数量用路径参数进行参数化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This environment variable resolves some incompatibilities between Quarkus and the Amazon Lambda Custom Runtime environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个环境变量解决了Quarkus和Amazon Lambda Custom Runtime环境之间的一些不兼容问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This example corresponds to the following instructions in the Micrometer documentation:
https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个例子对应于Micrometer文档中的以下说明 https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This example corresponds to the following instructions in the Micrometer documentation: https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个例子对应于Micrometer文档中的以下说明 https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This explain the specifics of using Hibernate ORM with Panache in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将解释在Kotlin项目中使用Hibernate ORM与Panache的具体细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is developed by a third party and is part of the Quarkus Platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此扩展程序由第三方开发，是 Quarkus 平台的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension utilizes SmallRye Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此扩展利用 SmallRye 响应式消息来构建数据流应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This feature is considered experimental and is likely to change in future versions of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个功能是实验性的，在未来的Quarkus版本中可能会有变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This feature is handy when using third-party libraries using object mapping features (such as Jackson or GSON):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在运用使用对象映射功能的第三方库（如Jackson或GSON）时，这个功能很方便：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This generation can be disabled using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以用以下方法禁用这种生成机制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide also covers the testing of the endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南还包括对终端的测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide assumes you already have the completed application from the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南假设您已经准备好了 `getting-started` 目录中的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide contains various tips and tricks for getting around problems that might arise when attempting to run Java applications as native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包含各种提示和技巧，以解决在尝试以原生可执行文件形式运行Java应用程序时可能出现的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.
It provides an application exhibiting a swift startup time and consuming less memory.
However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何为应用程序创建原生(二进制)可执行文件。它提供了一个具备快速启动时间和消耗更少内存的应用程序。然而，还有更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.  It provides an application exhibiting a swift startup time and consuming less memory.  However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何为应用程序创建原生(二进制)可执行文件。它提供了一个具备快速启动时间和消耗更少内存的应用程序。然而，还有更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.
However, there is much more.
We recommend continuing the journey with the xref:building-native-image.adoc[building a native executable guide], where you learn about creating a native executable and packaging it in a container.
If you are interested in reactive, we recommend the xref:getting-started-reactive.adoc[Getting Started with Reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了使用 Quarkus 创建应用程序的内容。 然而，下面还有更多内容。 我们建议您继续学习 xref:building-native-image.adoc[构建本地可执行文件指南]，您可以在其中了解如何创建本地可执行文件并将其打包到容器中。 如果您对响应式感兴趣，我们推荐 xref:getting-started-reactive.adoc[响应式入门指南]，您可以在其中了解如何使用 Quarkus 实现响应式应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the xref:building-native-image.adoc[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the xref:getting-started-reactive.adoc[Getting Started with Reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了使用 Quarkus 创建应用程序的内容。 然而，下面还有更多内容。 我们建议您继续学习 xref:building-native-image.adoc[构建本地可执行文件指南]，您可以在其中了解如何创建本地可执行文件并将其打包到容器中。 如果您对响应式感兴趣，我们推荐 xref:getting-started-reactive.adoc[响应式入门指南]，您可以在其中了解如何使用 Quarkus 实现响应式应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Kubernetes上部署一个原生应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在OpenShift上部署一个原生应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP BigQuery in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP BigQuery。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Bigtable in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Bigtable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Firestore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Firestore。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP PubSub in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP PubSub。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Secret Manager in Quarkus to consume configuration properties directly or via your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用GCP Secret Manager直接或通过 `application.properties` 来使用配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Spanner in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Spanner。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation in your REST services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在REST服务中使用Hibernate验证器/Bean验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use MongoDB in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用MongoDB。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use a Redis datastore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Redis数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use an Elasticsearch cluster using the low level or high level REST clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何使用低级或高级的REST客户端来使用Elasticsearch集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use multiple GCP services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何使用多种GCP服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the AWS Systems Manager in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用AWS系统管理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon DynamoDB database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Amazon DynamoDB数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Identity and Access Management in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊身份和访问管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Key Management Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用亚马逊密钥管理服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon S3 cloud storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Amazon S3云存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Email Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊简单电子邮件服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Notification Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊简单通知服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Queue Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Quarkus中使用Amazon Simple Queue Service。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Apache Cassandra NoSQL database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Apache Cassandra NoSQL数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Flyway extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何使用Flyway扩展来管理你的模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Liquibase extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何使用Liquibase扩展来管理你的模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Neo4j graph database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用Neo4j图数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Reactive SQL Clients in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Quarkus中使用响应式SQL客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the systems integration with Apache Camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括与Apache Camel的系统集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了在Kotlin项目中使用活动记录和存储库的MongoDB的用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了MongoDB使用活动记录和存储库的用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了以下内容：
* Gradle配置 
* 创建新项目 
* 处理扩展 
* 开发模式 
* 调试 
* 在你的IDE中导入 
* 构建原生可执行文件 
* 构建容器友好型可执行文件 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了以下内容：
* Maven配置
* 创建新项目
* 处理扩展
* 开发模式 
* 调试
* 在IDE中导入 
* 构建原生可执行文件 
* 构建容器友好型可执行文件
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括：
* 在JVM模式下的测试
* 在原生模式下的测试
* 将资源注入测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use Quarkus OpenID Connect (OIDC) Extension to protect your JAX-RS applications using Bearer Token Authorization where Bearer Tokens are issued by OpenID Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org[Keycloak].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用Quarkus OpenID Connect (OIDC)扩展来保护你的JAX-RS应用程序，使用不记名令牌授权(Bearer Tokens)，其中不记名令牌是由OpenID Connect和OAuth 2.0兼容的授权服务器（如 link:https://www.keycloak.org[Keycloak] ）颁发的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use reactive routes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用响应式路由。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the Fabric8 Kubernetes client to interact with your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用Fabric8 Kubernetes客户端与你的Kubernetes集群互动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect extension to protect your Quarkus JAX-RS service application using Bearer Token Authorization where the tokens are issued by OpenID Connect Providers such as Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用OpenID Connect扩展来保护你的Quarkus JAX-RS服务应用程序，使用Bearer令牌授权，其中令牌由OpenID Connect提供者（如Keycloak）出具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect extension to protect your Quarkus JAX-RS web application using the Authorization Code Flow and OpenID Connect Providers such as Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用OpenID Connect扩展来保护你的Quarkus JAX-RS网络应用程序，使用授权代码流和OpenID Connect提供者，如Keycloak。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your OpenID Connect application can support multi-tenancy so that you can serve multiple tenants from a single application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的OpenID Connect应用程序如何支持多租户，这样你就可以从一个应用程序中为多个租户提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize a bearer token access to protected resources using https://www.keycloak.org/docs/latest/authorization_services/index.html[Keycloak Authorization Services].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了如何在您的Quarkus应用程序中使用 link:https://www.keycloak.org/docs/latest/authorization_services/index.html[Keycloak授权服务] 来授权不记名token(bearer token)访问受保护的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize access to protected resources using Keycloak Authorization Services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用Keycloak授权服务来授权访问受保护的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can collect metrics using the Micrometer extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用Micrometer扩展来收集指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can connect to a Redis server using the Redis Client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何将你的Quarkus应用通过Redis客户端扩展连接到Redis服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use JMS messaging with AMQP 1.0 using Apache Qpid JMS, or using Apache ActiveMQ Artemis JMS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用AMQP 1.0的Apache Qpid JMS，或使用Apache ActiveMQ Artemis JMS进行JMS信息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Kogito to add business automation
to power it up with business processes and rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用Kogito来添加业务自动化，从而为其提供业务流程和规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Kogito to add business automation to power it up with business processes and rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用Kogito来添加业务自动化，从而为其提供业务流程和规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use WebAuthn authentication instead of
passwords.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用WebAuthn认证来代替密码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use WebAuthn authentication instead of passwords.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用WebAuthn认证来代替密码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a .properties file to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用.properties文件来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a LDAP directory to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用LDAP目录来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用数据库来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce HTTP messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye响应式消息传递来消费和提供HTTP消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce messages via WebSockets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的Quarkus应用程序如何利用SmallRye响应式消息通过WebSockets来消费和产生消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with AMQP 1.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用SmallRye Reactive Messaging来与AMQP 1.0进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye响应式消息传递与AMQP进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的Quarkus应用程序如何利用SmallRye响应式消息传递与Apache Kafka进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with RabbitMQ.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的 Quarkus 应用程序如何利用 SmallRye响应式消息传递与RabbitMQ进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用如何利用Apache Kafka Streams API来实现基于Apache Kafka的流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Micrometer metrics library for runtime and
application metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了您的Quarkus应用程序如何利用Micrometer metrics库测量运行时和应用程序metrics。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Micrometer metrics library for runtime and application metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了您的Quarkus应用程序如何利用Micrometer metrics库测量运行时和应用程序metrics。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye容错扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Fault Tolerance specification through the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何通过SmallRye容错扩展来利用SmallRye容错规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Health extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了您的Quarkus应用程序如何利用SmallRye Health扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Metrics extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye Metrics扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide describes the asciidoc format and conventions that Quarkus has adopted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南描述了Quarkus采用的asciidoc格式和约定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Amazon Lambda HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Amazon Lambda绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Azure Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Azure Functions HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Google Cloud Platform Functions HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Google Cloud Platform Functions绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Knative Events binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Knative Events绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains basics of the Funqy framework, a simple portable cross-provider cloud function API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy框架的基础知识，这是一个简单的可移植的跨供应商的云功能API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how a Quarkus application can leverage the well known Spring Scheduled annotation to configure and schedule tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南解释了Quarkus应用程序如何利用众所周知的Spring Scheduled注解来配置和安排任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how different beans can interact using the event bus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了不同的Bean如何使用事件总线进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to best measure the footprint of a Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何最好地测量Quarkus应用程序的占用空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to cache expensive method calls of your CDI beans using simple annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用简单的注解来缓存CDI Bean中昂贵的方法调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to centralize your logs with Logstash or Fluentd using the Graylog Extended Log Format (GELF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Graylog扩展日志格式（GELF）用Logstash或Fluentd集中管理你的日志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to configure Quarkus to authenticate against well-known OpenID Connect providers such as GitHub, Google, Microsoft, Apple...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何配置Quarkus来验证著名的OpenID Connect提供者，如GitHub、谷歌、微软、苹果...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to consume gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中消费gRPC服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何将Quarkus应用程序部署到谷歌云。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Microsoft Azure Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何将Quarkus应用程序部署到Microsoft Azure云中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to implement gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中实现gRPC服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage SmallRye GraphQL Client to consume GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何利用SmallRye GraphQL客户端来消费GraphQL服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage SmallRye GraphQL to implement GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何利用SmallRye GraphQL来实现GraphQL服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to measure the test coverage of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何测量你的Quarkus应用程序的测试覆盖率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to migrate an application from RESTEasy Classic to RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将一个应用从RESTEasy 指令式迁移到RESTEasy 响应式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to start using gRPC in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中开始使用gRPC。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Blaze-Persistence to simplify your data and DTO layers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Blaze-Persistence来简化你的数据和DTO层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Kotlin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Kotlin。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use OpenID Connect and OAuth2 Client and Filters to acquire, refresh and propagate access tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用OpenID Connect和OAuth2客户端和过滤器来获取、刷新和传播访问令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Sentry to monitor your application and be notified when exceptions occur.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Sentry来监控你的应用程序，并在发生异常时得到通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Vert.x in Quarkus to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在Quarkus中使用Vert.x来构建响应式应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用OpenAPI扩展来生成OpenAPI描述符，并获得一个Swagger UI前端来测试你的REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy REST Client in order to interact with REST APIs (JSON and other) with very little effort.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用RESTEasy REST客户端，以便用很少的精力与REST API（JSON和其他）进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy REST Client to send multipart REST requests, typically to upload documents.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍如何使用RESTEasy REST客户端发送多部分REST请求，通常是为了上传文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy Reactive REST Client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用RESTEasy Reactive REST客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can access Git repositories with JGit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何用JGit访问Git仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Amazon Lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何部署基于Quarkus的Amazon Lambdas。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何部署基于Quarkus的Google Cloud Functions。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as a Google Cloud Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Google Cloud Function。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Amazon Lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Azure Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Azure Function。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault for "encryption as a service".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用HashiCorp Vault进行 "加密即服务"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault to securely store your credentials in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用HashiCorp Vault在Quarkus中安全地存储您的凭证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from Consul.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何在运行时从Consul读取配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from the https://cloud.spring.io/spring-cloud-config[Spring Cloud Config Server].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南阐述了你的Quarkus应用程序如何在运行时从 link:https://cloud.spring.io/spring-cloud-config[Spring Cloud Config Server] 中读取配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OAuth2 tokens to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OAuth2令牌来提供对JAX-RS端点的安全访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTelemetry to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OpenTelemetry来为交互式Web应用程序提供分布式跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for
interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OpenTracing来为交互式网络应用程序提供分布式跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OpenTracing来为交互式网络应用程序提供分布式跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize https://github.com/smallrye/smallrye-jwt/[SmallRye JWT]
to verify https://tools.ietf.org/html/rfc7519[JSON Web Token]s, represent them as MicroProfile JWT `org.eclipse.microprofile.jwt.JsonWebToken`
and provide secured access to the Quarkus HTTP endpoints using Bearer Token Authorization and https://en.wikipedia.org/wiki/Role-based_access_control[Role-Based Access Control].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南旨在阐述如何在你的Quarkus应用程序中使用 https://github.com/smallrye/smallrye-jwt/[SmallRye JWT]来验证 https://tools.ietf.org/html/rfc7519[JSON Web Token]，并将它们呈现为MicroProfile JWT 的 `org.eclipse.microprofile.jwt.JsonWebToken` ，然后使用不记名令牌验证(Bearer Token Authorization)和 https://en.wikipedia.org/wiki/Role-based_access_control[基于角色的访问控制]来保证对Quarkus HTTP端点的安全访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize https://github.com/smallrye/smallrye-jwt/[SmallRye JWT] to verify https://tools.ietf.org/html/rfc7519[JSON Web Token]s, represent them as MicroProfile JWT `org.eclipse.microprofile.jwt.JsonWebToken` and provide secured access to the Quarkus HTTP endpoints using Bearer Token Authorization and https://en.wikipedia.org/wiki/Role-based_access_control[Role-Based Access Control].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南旨在阐述如何在你的Quarkus应用程序中使用 https://github.com/smallrye/smallrye-jwt/[SmallRye JWT]来验证 https://tools.ietf.org/html/rfc7519[JSON Web Token]，并将它们呈现为MicroProfile JWT 的 `org.eclipse.microprofile.jwt.JsonWebToken` ，然后使用不记名令牌验证(Bearer Token Authorization)和 https://en.wikipedia.org/wiki/Role-based_access_control[基于角色的访问控制]来保证对Quarkus HTTP端点的安全访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize https://opentelemetry.io/[OpenTelemetry] to provide
distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的Quarkus应用程序如何利用 link:https://opentelemetry.io/[OpenTelemetry] 来为交互式Web应用提供分布式跟踪服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize https://opentelemetry.io/[OpenTelemetry] to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的Quarkus应用程序如何利用 link:https://opentelemetry.io/[OpenTelemetry] 来为交互式Web应用提供分布式跟踪服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize web sockets to create interactive web applications. Because it’s the canonical web socket application, we are going to create a simple chat application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用网络套接字来创建交互式网络应用。因为它是典型的网络套接字应用程序，我们将创建一个简单的聊天应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can build, sign and/or encrypt JWT tokens with a fluent and configurable SmallRye JWT Build API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的应用程序如何利用流畅且可配置的SmallRye JWT构建API构建、签署和/或加密JWT令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can utilize SmallRye JWT to verify JWT tokens and provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的应用程序如何利用SmallRye JWT来验证JWT令牌并为JAX-RS端点提供安全访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains logging and how to configure it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了日志记录以及如何配置它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains the various methods supported by Quarkus to authenticate to your Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Quarkus支持的各种方法来验证您的Vault。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with AMQP 1.0 using Quarkus.
It utilizes https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了如何使用Quarkus与AMQP 1.0进行交互。它使用 link:https://smallrye.io/smallrye-reactive-messaging[SmallRye响应式消息]来构建数据流应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with AMQP 1.0 using Quarkus.  It utilizes https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了如何使用Quarkus与AMQP 1.0进行交互。它使用 link:https://smallrye.io/smallrye-reactive-messaging[SmallRye响应式消息]来构建数据流应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with Kafka using Quarkus.
It utilizes SmallRye Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南已经展示了如何使用Quarkus与Kafka进行交互。它利用SmallRye Reactive Messaging来构建数据流应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南已经展示了如何使用Quarkus与Kafka进行交互。它利用SmallRye Reactive Messaging来构建数据流应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide introduced how you can use Vert.x APIs from a Quarkus application.
It's just a brief overview.
If you want to know more, check the xref:vertx-reference.adoc[reference guide about Vert.x in Quarkus].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在 Quarkus 应用程序中使用 Vert.x API。这只是一个简短的概述。如果你想了解更多信息，请查看 xref:vertx-reference.adoc[Quarkus 中有关 Vert.x 的参考指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide introduced how you can use Vert.x APIs from a Quarkus application.  It's just a brief overview.  If you want to know more, check the xref:vertx-reference.adoc[reference guide about Vert.x in Quarkus].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在 Quarkus 应用程序中使用 Vert.x API。这只是一个简短的概述。如果你想了解更多信息，请查看 xref:vertx-reference.adoc[Quarkus 中有关 Vert.x 的参考指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a brief introduction to some reactive features offered by Quarkus.
Quarkus is a reactive framework, and so offers a lot of reactive features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南简要介绍了Quarkus提供的一些响应式特性。Quarkus是一个响应式框架，因此提供了许多响应式特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a brief introduction to some reactive features offered by Quarkus.  Quarkus is a reactive framework, and so offers a lot of reactive features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南简要介绍了Quarkus提供的一些响应式特性。Quarkus是一个响应式框架，因此提供了许多响应式特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南收集了一些提示，帮助你解决将应用程序编译为原生可执行文件时遇到的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是关于Quarkus响应式的介绍。Quarkus 的许多特性已经具有了响应式风格。下面列出了一些例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is not an in-depth article about what _Reactive_ is and how Quarkus enables reactive architectures.
If you want to read more about these topics, refer to the xref:quarkus-reactive-architecture.adoc[Reactive Architecture guide], which provides an overview of the Quarkus reactive ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南不是一篇关于 _Reactive_ 是什么以及Quarkus如何实现响应式架构的深入文章。 如果你想阅读更多关于这些主题的信息，请参考 xref:quarkus-reactive-architecture.adoc[响应式架构指南]，它提供了Quarkus响应式生态系统的概述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is not an in-depth article about what _Reactive_ is and how Quarkus enables reactive architectures.  If you want to read more about these topics, refer to the xref:quarkus-reactive-architecture.adoc[Reactive Architecture guide], which provides an overview of the Quarkus reactive ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南不是一篇关于 _Reactive_ 是什么以及Quarkus如何实现响应式架构的深入文章。 如果你想阅读更多关于这些主题的信息，请参考 xref:quarkus-reactive-architecture.adoc[响应式架构指南]，它提供了Quarkus响应式生态系统的概述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the companion from the xref:amqp.adoc[Getting Started with AMQP 1.0].
It explains in more details the configuration and usage of the AMQP connector for reactive messaging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是 xref:amqp.adoc[AMQP 1.0入门]的配套指南。它更详细地解释了响应式消息AMQP连接器的配置和使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the companion from the xref:amqp.adoc[Getting Started with AMQP 1.0].  It explains in more details the configuration and usage of the AMQP connector for reactive messaging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是 xref:amqp.adoc[AMQP 1.0入门]的配套指南。它更详细地解释了响应式消息AMQP连接器的配置和使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the companion to the xref:vertx.adoc[Using Eclipse Vert.x API from a Quarkus Application] guide.
It provides more advanced details about the usage and the configuration of the Vert.x instance used by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是《 link:vertx.html[从Quarkus应用程序中使用Eclipse Vert.x API] 》指南的补充。它提供了关于Quarkus使用的Vert.x实例的使用和配置的更多高级细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the companion to the xref:vertx.adoc[Using Eclipse Vert.x API from a Quarkus Application] guide.  It provides more advanced details about the usage and the configuration of the Vert.x instance used by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是《 link:vertx.html[从Quarkus应用程序中使用Eclipse Vert.x API] 》指南的补充。它提供了关于Quarkus使用的Vert.x实例的使用和配置的更多高级细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the entry point for everything security in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是Quarkus中一切安全问题的入口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide presents how you can build a Quarkus application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南介绍如何使用以下方法构建 Quarkus 应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide provides an in-depth look on Apache Kafka and SmallRye Reactive Messaging framework.
For a quick start take a look at xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南深入介绍了Apache Kafka和SmallRye Reactive Messaging框架。要想快速入门，请参考 xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide provides an in-depth look on Apache Kafka and SmallRye Reactive Messaging framework.  For a quick start take a look at xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南深入介绍了Apache Kafka和SmallRye Reactive Messaging框架。要想快速入门，请参考 xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南以 link:getting-started[入门指南]中开发的应用程序作为输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将 xref:getting-started.adoc[入门指南]中开发的应用程序作为输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide uses the Mutiny API.
If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive, reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南使用Mutiny API。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的、响应式的编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide uses the Mutiny API.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive, reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南使用Mutiny API。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的、响应式的编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a Maven archetype.  Later on, it walks through the structure
of the project so you can adapt any existing projects you have to use Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将引导您通过Maven原型生成一个Java项目示例。随后，还将介绍项目的结构，以便您能够调整现有的项目以使用Amazon Lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a Maven archetype.  Later on, it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将引导您通过Maven原型生成一个Java项目示例。随后，还将介绍项目的结构，以便您能够调整现有的项目以使用Amazon Lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a maven archetype and deploying it to AWS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将指导你通过一个maven原型生成一个Java项目的例子，并将其部署到AWS。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将引导你完成用OptaPlanner的约束解决人工智能（AI）创建Quarkus应用程序的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will help you with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将帮助您：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of LRA to coordinate activities across services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了使用LRA来协调跨服务的活动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of Software Transactional Memory (STM).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了软件事务性内存（STM）的使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides explains how to use the Vault credentials provider or implement your own custom one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Vault凭证提供者或实现你自己的自定义凭证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This handler is a bridge between the lambda runtime and the Quarkus HTTP framework you are using (JAX-RS, Servlet, etc.)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个处理程序是lambda运行时和你正在使用的Quarkus HTTP框架（JAX-RS、Servlet等）之间的桥梁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This implies that you no longer need to install a JVM on your
production environment, as the runtime technology is included in
the produced binary, and optimized to run with minimal resource overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这意味着您不再需要在您的生产环境中安装JVM，因为运行时技术包含在生产的二进制文件中，并以最小的资源开销优化运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This implies that you no longer need to install a JVM on your production environment, as the runtime technology is included in
the produced binary, and optimized to run with minimal resource overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这意味着您不再需要在您的生产环境中安装JVM，因为运行时技术包含在生产的二进制文件中，并以最小的资源开销优化运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This implies that you no longer need to install a JVM on your production environment, as the runtime technology is included in the produced binary, and optimized to run with minimal resource overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这意味着您不再需要在您的生产环境中安装JVM，因为运行时技术包含在生产的二进制文件中，并以最小的资源开销优化运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This index is created by default on the project on which Quarkus is configured for, thanks to our Maven and Gradle plugins.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过使用Maven和Gradle插件，这个索引在Quarkus的项目上的默认配置是自动创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instance is retrieved and used to configure the client used by the connector.
You need to indicate the name of the client using the `client-options-name` attribute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个实例被检索，并用于配置连接器使用的客户端。你需要使用 `client-options-name` 属性指定客户端的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instance is retrieved and used to configure the client used by the connector.  You need to indicate the name of the client using the `client-options-name` attribute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个实例被检索，并用于配置连接器使用的客户端。你需要使用 `client-options-name` 属性指定客户端的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这指示 failsafe-maven-plugin 运行集成测试，并指出生成的原生可执行文件的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instructs the failsafe-maven-plugin to run integration-test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将通知failsafe-maven-plugin去运行继承测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.
Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是文件和网站中首选术语的集合。为了保持一致性，请保持在这些术语范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是文件和网站中首选术语的集合。为了保持一致性，请保持在这些术语范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a good example of how to integrate a Kafka consumer with another downstream,
in this example exposing it as a Server-Sent Events endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个例子很好的展示了如何将Kafka consumer与另一个downstream进行集成。在这个例子中，我们将这个downstream暴露为一个服务端事件节点(Server-Sent Events endpoint)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a good example of how to integrate a Kafka consumer with another downstream, in this example exposing it as a Server-Sent Events endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个例子很好的展示了如何将Kafka consumer与另一个downstream进行集成。在这个例子中，我们将这个downstream暴露为一个服务端事件节点(Server-Sent Events endpoint)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a permission set that references the previously defined policy. `roles1` is an arbitrary name, you can call the permission sets whatever you want.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个引用之前定义的策略的权限集。 `roles1` 是一个任意的名字，您可以随意的命名该权限集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a very common case as JSON libraries typically use reflection to serialize the objects to JSON:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常常见的情况，因为JSON库通常使用反射来将对象序列化为JSON：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a very simple example using RBAC policies to govern access to your resources.
However, Keycloak supports other types of policies that you can use to perform even more fine-grained access control.
By using this example, you'll see that your application is completely decoupled from your authorization policies with enforcement being purely based on the accessed resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该示例非常简单，它使用RBAC策略来管理对您的资源的访问。但是，Keycloak也支持其他类型的策略，您可以用这些策略来执行更细粒度的访问控制。通过这个例子，您会发现您的应用程序与授权策略完全解耦，授权策略的执行完全基于所访问的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a very simple example using RBAC policies to govern access to your resources.  However, Keycloak supports other types of policies that you can use to perform even more fine-grained access control.  By using this example, you'll see that your application is completely decoupled from your authorization policies with enforcement being purely based on the accessed resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该示例非常简单，它使用RBAC策略来管理对您的资源的访问。但是，Keycloak也支持其他类型的策略，您可以用这些策略来执行更细粒度的访问控制。通过这个例子，您会发现您的应用程序与授权策略完全解耦，授权策略的执行完全基于所访问的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an introduction to writing JSON REST services with Quarkus.
A more detailed guide about RESTEasy Reactive is available xref:resteasy-reactive.adoc[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个关于用Quarkus编写JSON REST服务的介绍。 link:resteasy-reactive.html[这里] 有关于RESTEasy Reactive的更详细的指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an introduction to writing JSON REST services with Quarkus.  A more detailed guide about RESTEasy Reactive is available xref:resteasy-reactive.adoc[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个关于用Quarkus编写JSON REST服务的介绍。 link:resteasy-reactive.html[这里] 有关于RESTEasy Reactive的更详细的指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is considered an advanced option and should only be performed if you fully understand the consequences of changing the scope of the bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个高级选项，只有在您完全了解改变Bean scope的后果时才可以执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is covered in the xref:building-native-image.adoc[Native Executable Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这在《 link:building-native-image.html[本地可执行文件指南》] 中有所涉及。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is described in a dedicated guide: xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这部分在一个专门的指南中有所描述。 link:kafka-schema-registry-avro.html[使用Apache Kafka与Schema Registry和Avro协同工作] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is described in a dedicated guide: xref:kafka-streams.adoc[Using Apache Kafka Streams].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这部分在专门的指南中有所描述：link:kafka-streams.html[使用Apache Kafka流] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is helpful for both Java developers who are used to working with the imperative model and don’t want to switch things up, and those working with a cloud-native/reactive approach. The Quarkus development model can adapt itself to whatever app you’re developing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这对于那些习惯于使用指令式模型并且不想改变的Java开发人员，以及那些使用原生云/响应式方法的开发人员都是有帮助的。Quarkus开发模型可以适应您正在开发的任何应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is needed if you are not using xref:redis-dev-services.adoc[Dev Services for Redis]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在不使用 link:redis-dev-services.html[Dev Services for Redis] 的情况下需要配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is solved by using a `null` key (represented by `~`) for any YAML property which is a prefix of another one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这可以通过为任意YAML属性使用 `null` 键（以 `~` 为代表）来解决，该属性是另一个属性的前缀:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the default behavior of an application subscribing to a Kafka topic: Each Kafka connector will create a single consumer thread and place it inside a single consumer group.
Consumer group id defaults to the application name as set by the `quarkus.application.name` configuration property.
It can also be set using the `kafka.group.id` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个应用程序订阅Kafka topic的默认方式：每个Kafka Connector将创建一个独立的消费者线程，并将其置于一个单独的消费者组内。消费者组id默认为 `quarkus.application.name` 所设定的应用程序名称。它也可以使用 `kafka.group.id` 来设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the default behavior of an application subscribing to a Kafka topic: Each Kafka connector will create a single consumer thread and place it inside a single consumer group.  Consumer group id defaults to the application name as set by the `quarkus.application.name` configuration property.  It can also be set using the `kafka.group.id` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个应用程序订阅Kafka topic的默认方式：每个Kafka Connector将创建一个独立的消费者线程，并将其置于一个单独的消费者组内。消费者组id默认为 `quarkus.application.name` 所设定的应用程序名称。它也可以使用 `kafka.group.id` 来设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the default semantic.
If an existing transaction is already associated with the current thread then the transaction is suspended, and
resumed once
the current transaction is complete.
A new transaction is started after the existing transaction is suspended, and follows all the normal lifecycle rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是默认的语义。如果一个现有的事务已经与当前线程相关联，那么该事务将被暂停，并在当前事务完成后恢复。一个新的事务在现有事务被暂停后开始，并遵循所有正常的生命周期规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful as it removes the need to store sensitive data in application.properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样可以避免在application.properties中存储敏感数据，很实用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful to create a client dynamically in a non-CDI bean e.g a xref:hibernate-orm-panache.adoc[Panache entity].
Or to create a different client when running in pub/sub mode. This mode requires two different connections
because once a connection invokes a subscriber mode then it cannot be used for running other commands
than the command to leave that mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这对于在非CDI bean中动态地创建客户端非常有用，例如在 link:hibernate-orm-panache.html[Panache 实体类] 中使用Redis客户端，或者在pub/sub模式下运行时创建一个不同的客户端。这种模式需要两个不同的客户端连接，因为如果某个连接使用了订阅者模式，那么它就不能用于运行其他命令，直到退出订阅者模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This leads us to our next section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将我们引向下一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically
every scope except `@Singleton` and `@Dependent`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方法可以用于任何正常scope的CDI Bean（例如： `@ApplicationScoped` , `@RequestScoped` 等，基本上是除了 `@Singleton` 和 `@Dependent` 以外的scope ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically every scope except `@Singleton` and `@Dependent`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方法可以用于任何正常scope的CDI Bean（例如： `@ApplicationScoped` , `@RequestScoped` 等，基本上是除了 `@Singleton` 和 `@Dependent` 以外的scope ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method returns a `Response` and not a list of `Legume`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方法返回一个 `Response` ，而不是一个 `Legume` 列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This multi-stage Docker build copies the Maven wrapper from the host machine.
The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.
It avoids having to create a base image with Maven and Gradle.
To provision the Maven Wrapper in your project, use: `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.0:wrapper`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种多阶段Docker构建从主机上复制Maven包装器。Maven包装器（或Gradle包装器）是提供特定版本Maven/Gradle的一种便捷方式。它避免了用Maven和Gradle创建一个基础镜像。要在项目中配置Maven包装器，请使用： `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.0:wrapper` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This multi-stage Docker build copies the Maven wrapper from the host machine.  The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.  It avoids having to create a base image with Maven and Gradle.  To provision the Maven Wrapper in your project, use: `mvn -N io.takari:maven:0.7.7:wrapper`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种多阶段Docker构建从主机上复制Maven包装器。Maven包装器（或Gradle包装器）是提供特定版本Maven/Gradle的一种便捷方式。它避免了用Maven和Gradle创建一个基础镜像。要在项目中配置Maven包装器，请使用： `mvn -N io.takari:maven:0.7.7:wrapper`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This new endpoint will be located at /secured/roles-allowed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个新的endpoint将位于/secured/roles-allowed</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This permission references the built-in `deny` policy for `/forbidden`.
This is an exact path match as it does not end with `*`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个权限引用了内置的 `deny` 策略来作用于 `/forbidden` 。这是一个精确的路径匹配，因为它没有以 `*` 结尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This permission references the built-in `deny` policy for `/forbidden`.  This is an exact path match as it does not end with `*`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个权限引用了内置的 `deny` 策略来作用于 `/forbidden` 。这是一个精确的路径匹配，因为它没有以 `*` 结尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This permission references the built-in `deny` policy for `/forbidden`. This is an exact path match as it does not end with `*`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个权限引用了内置的 `deny` 策略来作用于 `/forbidden` 。这是一个精确的路径匹配，因为它没有以 `*` 结尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This permission references the default `permit` built-in policy to allow `GET` methods to `/public`. This is actually a no-op in this example, as this request would have been allowed anyway.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个权限引用了默认的 `permit` 内置策略，允许 `GET` 方法访问 `/public` 。在这个例子中，这实际上是一个空操作，因为这个请求无论如何都会被允许。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This procedure was formerly accomplished using the `@NativeImageTest` annotation. `@NativeImageTest` is considered deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing
capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个过程以前是用 `@NativeImageTest` 注释来完成的。 `@NativeImageTest` 正考虑被废弃掉，请采用 `@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 xref:getting-started-testing.adoc#quarkus-integration-test[测试指南] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This procedure was formerly accomplished using the `@NativeImageTest` annotation. `@NativeImageTest` is considered deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个过程以前是用 `@NativeImageTest` 注释来完成的。 `@NativeImageTest` 正考虑被废弃掉，请采用 `@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 xref:getting-started-testing.adoc#quarkus-integration-test[测试指南] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This project follows the &lt;a href="#"&gt;all-contributors&lt;/a&gt; specification. Contributions of any kind welcome!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本项目遵循&lt;a href="#"&gt;所有贡献者&lt;/a&gt;规范。欢迎任何形式的贡献!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property can be used to customize a `KeyStore` provider if `mp.jwt.verify.publickey.location` or `mp.jwt.decrypt.key.location` points to a `KeyStore` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `mp.jwt.verify.publickey.location` 或 `mp.jwt.decrypt.key.location` 指向一个 `KeyStore` 文件，该属性可用于定制一个 `KeyStore` 提供者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property can be used to customize a keystore type if either `mp.jwt.verify.publickey.location` or mp.jwt.decrypt.key.location` points to a `KeyStore` file. If it is not set then the file name will be checked to determine the keystore type before defaulting to `JKS`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `mp.jwt.verify.publickey.location` 或 `mp.jwt.decrypt.key.location` 指向一个 `KeyStore` 文件，这个属性可以用来定制一个密钥库类型。如果没有设置，那么文件名将被检查以确定密钥库类型，默认为 `JKS` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property can be used to set a default groups claim value when the current token has no standard or custom groups claim available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当当前令牌没有可用的标准或自定义的组声明时，此属性可用于设置默认组声明值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property can be used to set a default sub claim value when the current token has no standard or custom `sub` claim available. Effectively this property can be used to customize `java.security.Principal` name if no `upn` or `preferred_username` or `sub` claim is set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当当前令牌没有可用的标准或自定义 `sub` 声明时，此属性可用于设置默认的sub声明值。如果没有设置 `upn` 或 `preferred_username` 或 `sub` 声明，该属性可有效地用于自定义 `java.security.Principal` 名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property has to be set to identify a private decryption key if `mp.jwt.decrypt.key.location` points to a `KeyStore` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `mp.jwt.decrypt.key.location` 指向 `KeyStore` 文件，则必须将此属性设置为标识专用解密密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property has to be set to identify a public verification key which will be extracted from `KeyStore` from a matching certificate if `mp.jwt.verify.publickey.location` points to a `KeyStore` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个属性必须被设置，以确定一个公共验证密钥，如果 `mp.jwt.verify.publickey.location` 指向 `KeyStore` 文件，该密钥将从所匹配的证书中的 `KeyStore` 中提取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property is required if the `service` application is expected to introspect the tokens remotely - which is always the case for the opaque tokens.
This property is optional if the local Json Web Key token verification only is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `service` 应用程序被期望是远程自省令牌--对于不透明的令牌来说总是这样，那么这个属性是必需的。如果只使用本地Json Web Key令牌验证，那么该属性是可选的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property is required if the `service` application is expected to introspect the tokens remotely - which is always the case for the opaque tokens.  This property is optional if the local Json Web Key token verification only is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `service` 应用程序被期望是远程自省令牌--对于不透明的令牌来说总是这样，那么这个属性是必需的。如果只使用本地Json Web Key令牌验证，那么该属性是可选的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property may be set if a private decryption key's password in `KeyStore` is different to `smallrye.jwt.keystore.password` when `mp.jwt.decrypt.key.location` points to a `KeyStore` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `mp.jwt.decrypt.key.location` 指向 `KeyStore` 文件时，并且 `KeyStore` 中的专用解密密钥的密码与 `smallrye.jwt.keystore.password` 不同，则可以设置此属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南展示了如何在您的Quarkus应用程序中利用SmallRye Reactive Messaging与Apache Kafka进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains how to develop command line applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南解释了如何用Quarkus开发命令行应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains in more details the configuration and usage of the Quarkus Mailer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南更详细地解释了Quarkus Mailer的配置和使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide provides advanced details about the usage and the configuration of the Vert.x instance used by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南提供了关于Quarkus使用的Vert.x实例的使用和配置的高级细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide provides an in-depth look on Apache Kafka and Smallrye Reactive Messaging framework.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南深入介绍了Apache Kafka和Smallrye响应式消息传递框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource creates a `WebClient` and, upon request, uses this client to invoke a remote HTTP API.
Depending on the result, the response is forwarded as received, or it creates a JSON object wrapping the error.
The `WebClient` is asynchronous (and non-blocking), to the endpoint returns a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该资源创建了一个 `WebClient` ，并在请求时使用该客户端来调用远程HTTP API。根据结果，响应被转发，或者创建一个包含错误的 JSON 对象。 `WebClient` 是异步的（和非阻塞的），端点返回一个 `Uni` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource creates a `WebClient` and, upon request, uses this client to invoke a remote HTTP API.  Depending on the result, the response is forwarded as received, or it creates a JSON object wrapping the error.  The `WebClient` is asynchronous (and non-blocking), to the endpoint returns a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该资源创建了一个 `WebClient` ，并在请求时使用该客户端来调用远程HTTP API。根据结果，响应被转发，或者创建一个包含错误的 JSON 对象。 `WebClient` 是异步的（和非阻塞的），端点返回一个 `Uni` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个资源根据 `Fruit` 类产生的结果返回 `Uni` 和 `Multi` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This response is sent back using the reply mechanism</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用回复机制发回此响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This same demo can be compiled into native code: no modifications required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个同样的演示可以被编译成本地代码：不需要任何修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This secret key JWK will also need to be referred to with `smallrye.jwt.verify.key.location`.
`smallrye.jwt.verify.algorithm` should be set to `HS256`/`HS384`/`HS512`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个密匙JWK也需要用 `smallrye.jwt.verify.key.location` 。 `smallrye.jwt.verify.algorithm` 应该设置为 `HS256` / `HS384` / `HS512` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This secret key JWK will also need to be referred to with `smallrye.jwt.verify.key.location`.  `smallrye.jwt.verify.algorithm` should be set to `HS256`/`HS384`/`HS512`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个密匙JWK也需要用 `smallrye.jwt.verify.key.location` 。 `smallrye.jwt.verify.algorithm` 应该设置为 `HS256` / `HS384` / `HS512` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section explains how to connect to notorious Kafka Cloud Services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本节解释了如何连接到臭名昭著的Kafka云服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section gives an example using the Vert.x `WebClient` in the context of a RESTEasy Reactive application.
As indicated in the table above, add the following dependency to your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本节给出一个在RESTEasy Reactive应用程序中使用Vert.x `WebClient` 的例子。如上表所示，在你的项目中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section gives an example using the Vert.x `WebClient` in the context of a RESTEasy Reactive application.  As indicated in the table above, add the following dependency to your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本节给出一个在RESTEasy Reactive应用程序中使用Vert.x `WebClient` 的例子。如上表所示，在你的项目中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This technology is considered {extension-status}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这项技术被认为是{extension-status}。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells RESTAssured to prefix all requests with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将使RESTAssured在所有请求之前加上 `/hello` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before
the test is run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该测试使用HTTP来直接测试我们的REST节点。当运行测试时，应用程序将在测试运行前被启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before the test is run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该测试使用HTTP来直接测试我们的REST节点。当运行测试时，应用程序将在测试运行前被启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time, we return a Multi as we want to stream the chunks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这一次，我们返回一个Multi类型的对象，因为我们想要流式地处理这些块</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time, you can see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这一次，你可以看到我们的legumes列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This website is licensed under the [Creative Commons Attribution 3.0](https://creativecommons.org/licenses/by/3.0/).
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本网站是根据 [知识共享署名许可协议 3.0](https://creativecommons.org/licenses/by/3.0/) 维护。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将在你的 `pom.xml` 中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这会将以下内容添加到你的构建文件中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you
can pass `-Dsuspend` on the command line. If you don't want the debugger at all you can use `-Ddebug=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这也将在端口 `5005` 上监听调试器。如果你想在运行前等待调试器的连接，你可以在命令行中传递 `-Dsuspend` 。如果你根本不想要调试器，你可以使用 `-Ddebug=false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you can pass `-Dsuspend` on the command line. If you don't want the debugger at all you can use `-Ddebug=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这也将在端口 `5005` 上监听调试器。如果你想在运行前等待调试器的连接，你可以在命令行中传递 `-Dsuspend` 。如果你根本不想要调试器，你可以使用 `-Ddebug=false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile and package your code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将对你的代码进行编译和打包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.
Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also
available with this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将编译代码并运行生成的项目中包含的单元测试。单元测试和其他的Java项目一样，不需要运行在Amazon上。Quarkus开发模式也可以通过这个扩展来提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将编译代码并运行生成的项目中包含的单元测试。单元测试和其他的Java项目一样，不需要运行在Amazon上。Quarkus开发模式也可以通过这个扩展来提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will only work on platforms that support &lt;&lt;native-transport&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这仅适用于支持 link:#native-transport[[native-transport]] 的平台。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will only work when the entity extends `PanacheMongoEntityBase` and not `PanacheMongoEntity`, as the ID field also needs to be included in the constructor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这只有在实体继承了 `PanacheMongoEntityBase` ，而不是 `PanacheMongoEntity` ，这样才会起作用，因为ID字段也需要被包含在构造函数中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will start a Docker container that mimics Amazon's Lambda's deployment environment. Once the environment
is started you can invoke the example lambda in your browser by going to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将启动一个模仿亚马逊的Lambda部署环境的Docker容器。一旦环境启动了，你就可以在你的浏览器中调用lambda示例，方法是去：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will start a Docker container that mimics Amazon's Lambda's deployment environment. Once the environment is started you can invoke the example lambda in your browser by going to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将启动一个模仿亚马逊的Lambda部署环境的Docker容器。一旦环境启动了，你就可以在你的浏览器中调用lambda示例，方法是去：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works equally well when the JSON content is a request body or is wrapped in a `Uni`, `Multi`, `CompletionStage` or `Publisher`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当JSON内容是一个请求体或被包裹在一个 `Uni` , `Multi` , `CompletionStage` 或 `Publisher` 中时，这同样适用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the `all-open` Kotlin compiler plugin allows us to configure the compiler to *not* mark as `final` classes that have certain annotations. In the snippet above,
we have specified that classes annotated with `javax.ws.rs.Path` should not be `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此， `all-open` Kotlin编译器插件允许我们对编译器进行配置，使其 *不* 将有某些注解的类标记为 `final` 。在上面的片段中，我们已经指定了带有 `javax.ws.rs.Path` 注解的类不应该是 `final` 的 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the `all-open` Kotlin compiler plugin allows us to configure the compiler to *not* mark as `final` classes that have certain annotations. In the snippet above, we have specified that classes annotated with `javax.ws.rs.Path` should not be `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此， `all-open` Kotlin编译器插件允许我们对编译器进行配置，使其 *不* 将有某些注解的类标记为 `final` 。在上面的片段中，我们已经指定了带有 `javax.ws.rs.Path` 注解的类不应该是 `final` 的 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Timers and distribution summaries in Micrometer are very similar. Both allow you to record an observed value, which
will be aggregated with other recorded values and stored as a sum. Micrometer also increments a counter to indicate the
number of measurements that have been recorded and tracks the maximum observed value (within a decaying interval).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer中的Timers和distribution summaries非常相似。两者都允许您记录这样一种观察值，它将与其他记录值汇总并作为一个总和来被记录。Micrometer也会使用一个counter来表示已经记录的测量值的个数，并且跟踪最大的观察值（在一个衰减的区间内）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Timers and distribution summaries in Micrometer are very similar. Both allow you to record an observed value, which will be aggregated with other recorded values and stored as a sum. Micrometer also increments a counter to indicate the number of measurements that have been recorded and tracks the maximum observed value (within a decaying interval).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer中的Timers和distribution summaries非常相似。两者都允许您记录这样一种观察值，它将与其他记录值汇总并作为一个总和来被记录。Micrometer也会使用一个counter来表示已经记录的测量值的个数，并且跟踪最大的观察值（在一个衰减的区间内）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tips for writing native applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写原生应用程序的提示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To access the managed Vert.x instance, add the `quarkus-vertx` extension to your project.
Note that this dependency may already be installed (as a transitive dependency).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要访问管理的Vert.x实例，请在你的项目中添加 `quarkus-vertx` 扩展。注意，这个依赖可能已经安装了（作为一个过渡性依赖）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To access the managed Vert.x instance, add the `quarkus-vertx` extension to your project.  Note that this dependency may already be installed (as a transitive dependency).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要访问管理的Vert.x实例，请在你的项目中添加 `quarkus-vertx` 扩展。注意，这个依赖可能已经安装了（作为一个过渡性依赖）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To achieve this you need to specify a compatible container type to receive all the data:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了达到这一点，您需要指定一个兼容的容器类型来接收所有数据：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add the OWASP Dependency check plugin to your Quarkus Maven project, add the following XML configuration to the `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要在Quarkus Maven项目中添加OWASP依赖性检查插件，请在 `pom.xml` 文件中添加以下XML配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To alleviate this restriction, the `@QuarkusTest` annotation defines a JUnit 5 `@Tag`: `io.quarkus.test.junit.QuarkusTest`.
You can use this tag to isolate the `@QuarkusTest` test in a specific execution run, for example with the Maven Surefire Plugin:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为缓解这一限制， `@QuarkusTest` 注解定义了一个 JUnit 5 的 `@Tag` : `io.quarkus.test.junit.QuarkusTest` 。您可以使用该标记在特定的执行中隔离 `@QuarkusTest` 测试，例如使用Maven Surefire插件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To alleviate this restriction, the `@QuarkusTest` annotation defines a JUnit 5 `@Tag`: `io.quarkus.test.junit.QuarkusTest`.  You can use this tag to isolate the `@QuarkusTest` test in a specific execution run, for example with the Maven Surefire Plugin:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为缓解这一限制， `@QuarkusTest` 注解定义了一个 JUnit 5 的 `@Tag` : `io.quarkus.test.junit.QuarkusTest` 。您可以使用该标记在特定的执行中隔离 `@QuarkusTest` 测试，例如使用Maven Surefire插件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To allow your Quarkus application to use that secret, add the following line to the `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了允许您的Quarkus应用程序使用该secret，请在 `application.properties` 文件中添加下面一行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be able to set the address per message, the connector is using an _anonymous sender_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了能够按消息设置地址，连接器使用了一个 _anonymous sender_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand the contrast, we need to explain the difference between the reactive and imperative execution models.
It's essential to comprehend that _Reactive_ is not just a different execution model, but that distinction is necessary to understand this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了更好地理解这种对比，我们需要解释响应式执行模型和指令式执行模型之间的区别。理解 _Reactive_ 不仅仅是一种不同的执行模型是必要的，而且这一区别对于理解本指南是必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand the contrast, we need to explain the difference between the reactive and imperative execution models.  It's essential to comprehend that _Reactive_ is not just a different execution model, but that distinction is necessary to understand this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了更好地理解这种对比，我们需要解释响应式执行模型和指令式执行模型之间的区别。理解 _Reactive_ 不仅仅是一种不同的执行模型是必要的，而且这一区别对于理解本指南是必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand, let's detail how the HTTP request/response has been handled:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了更好地理解，让我们详细介绍一下HTTP request/response 是如何被处理的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide using Mandrel, you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用Mandrel完成本指南，你需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide, you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要完成这个指南，你需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the inbound connector to use the provided listener, we either set the consumer rebalance listener’s identifier:
`mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如要配置inbound connector使用所提供的监听器，我们可以通过消费者再平衡监听器的标识符 `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer` 来设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the inbound connector to use the provided listener, we either set the consumer rebalance listener’s identifier: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如要配置inbound connector使用所提供的监听器，我们可以通过消费者再平衡监听器的标识符 `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer` 来设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the protected routes using the `@RolesAllowed` annotation or the `application.properties` file, check the xref:security-openid-connect.adoc[Using OpenID Connect Adapter to Protect JAX-RS Applications] and xref:security-authorization.adoc[Security Authorization] guides. For more details, check the xref:security.adoc[Security guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用 `@RolesAllowed` 注解或 `application.properties` 文件配置受保护的路由，请查看《 link:security-openid-connect.html[使用 OpenID 连接适配器保护 JAX-RS 应用程序] 》和《 link:security-authorization.html[安全授权] 》指南。更多细节，请查看 link:security.html[安全指南]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To connect to Azure Event Hub, using the Kafka protocol with TLS, you need the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用带有TLS的Kafka协议连接到Azure Event Hub的话，您需要以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To consume `Fruit` instances stored on a Kafka topic, and persist them into a database, you can use the following approach:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了消费存储在Kafka topic上的 `Fruit` 实例，并将其持久化到数据库中，您可以使用以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To control the RESTassured base path (i.e. the default path that serves as the root for every
request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can
be applied at the class or method level. To test out greeting resource we would do:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了控制RESTassured基础路径（即作为每个请求根路径的默认路径），您可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注解。可以在类或方法层面上使用。为了测试greeting资源类，我们可以这样做：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To control the RESTassured base path (i.e. the default path that serves as the root for every request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can be applied at the class or method level. To test out greeting resource we would do:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了控制RESTassured基础路径（即作为每个请求根路径的默认路径），您可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注解。可以在类或方法层面上使用。为了测试greeting资源类，我们可以这样做：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To conveniently interact with the application, let's create a simple web page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了方便地与应用程序交互，让我们创建一个简单的网页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `--gradle` or `--gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Grade项目，请添加 `--gradle` 或者 `--gradle-kotlin-dsl` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `-DbuildTool=gradle` or `-DbuildTool=gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Grade项目，请添加 `-DbuildTool=gradle` 或者 `-DbuildTool=gradle-kotlin-dsl` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create the _processor_ project, from the same directory, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要创建 _processor_ 项目，请在同一目录下运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create the _producer_ project, in a terminal run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要创建 _producer_ 项目，请在终端中运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a Panache entity, simply extend `PanacheEntity`, annotate it with `@Entity` and add your
columns as public fields:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要定义一个Panache实体类，只需继承 `PanacheEntity` ，增加 `@Entity` 注解，并将数据库列作为公共字段添加到实体类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a Panache entity, simply extend `PanacheEntity`, annotate it with `@Entity` and add your columns as public fields:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要定义一个Panache实体类，只需继承 `PanacheEntity` ，增加 `@Entity` 注解，并将数据库列作为公共字段添加到实体类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a Panache entity, simply extend `PanacheMongoEntity` and add your columns as public fields.
You can add the `@MongoEntity` annotation to your entity if you need to customize the name of the collection, the database, or the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要定义一个Panache实体，只需扩展 `PanacheMongoEntity` ，并添加你的列作为公共字段。如果你需要自定义集合、数据库或客户端的名称，你可以向你的实体添加 `@MongoEntity` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a Panache entity, simply extend `PanacheMongoEntity` and add your columns as public fields.  You can add the `@MongoEntity` annotation to your entity if you need to customize the name of the collection, the database, or the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要定义一个Panache实体，只需扩展 `PanacheMongoEntity` ，并添加你的列作为公共字段。如果你需要自定义集合、数据库或客户端的名称，你可以向你的实体添加 `@MongoEntity` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy a native executable, you must build it with GraalVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要部署一个本地可执行文件，你必须用GraalVM构建它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy multiple instances of your verticle, use the `@Dependent` scope instead of `@ApplicationScoped`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要部署 Verticle 的多个实例，请使用 `@Dependent` 范围而不是 `@ApplicationScoped` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy to AWS Lambda:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要部署到AWS Lambda：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy verticles, use the `deployVerticle` method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要部署verticles，使用 `deployVerticle` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To detect less severe issues, adjust the value of `failBuildOnCVSS` to suppress the false positives, as demonstrated in the following code sample:
[source,xml]
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以通过调整 `failBuildOnCVSS` 值来减弱false positives，从而来检测相对不是很严重的问题，如以下代码所示 ： 
[source,xml]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable health reporting, set the `health-enabled` attribute for the channel to false.
On the inbound side (receiving messages from AMQP), the check verifies that the receiver is attached to the broker.
On the outbound side (sending records to AMQP), the check verifies that the sender is attached to the broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要禁用健康报告，请将通道的 `health-enabled` 属性设为false。在入站端（接收来自AMQP的消息），检查会验证接收者是否连接到代理。在出站端（向AMQP发送记录），检查会验证发送者是否连接到代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable health reporting, set the `health-enabled` attribute for the channel to false.  On the inbound side (receiving messages from AMQP), the check verifies that the receiver is attached to the broker.  On the outbound side (sending records to AMQP), the check verifies that the sender is attached to the broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要禁用健康报告，请将通道的 `health-enabled` 属性设为false。在入站端（接收来自AMQP的消息），检查会验证接收者是否连接到代理。在出站端（向AMQP发送记录），检查会验证发送者是否连接到代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, first create a directory `src/main/zip.native/` with your build.  Next create a shell script file called `bootstrap`
within `src/main/zip.native/`, like below. An example is create automatically in your build folder (target or build), called `bootstrap-example.sh`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要做到这一点，首先使用你的构建创建一个目录 `src/main/zip.native/` 。接下来在 `src/main/zip.native/` 中创建一个名为 `bootstrap` 的shell脚本文件，如下所示。例如，在你的构建文件夹（target或 build）中自动创建一个名为 `bootstrap-example.sh` 的文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, first create a directory `src/main/zip.native/` with your build.  Next create a shell script file called `bootstrap` within `src/main/zip.native/`, like below. An example is create automatically in your build folder (target or build), called `bootstrap-example.sh`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要做到这一点，首先使用你的构建创建一个目录 `src/main/zip.native/` 。接下来在 `src/main/zip.native/` 中创建一个名为 `bootstrap` 的shell脚本文件，如下所示。例如，在你的构建文件夹（target或 build）中自动创建一个名为 `bootstrap-example.sh` 的文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, we will need to setup JSON serialization with Jackson or JSON-B.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要做到这一点，我们需要用Jackson或JSON-B来设置JSON序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ease the containerization of native executables, Quarkus provides a base image providing the requirements to run these executables.
The `quarkus-micro-image:1.0` image is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了简化本地可执行文件的容器化步骤，Quarkus提供了一个包含运行这些可执行文件依赖的基础镜像。 `quarkus-micro-image:1.0` 镜像是:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable YAML configuration, add the `quarkus-config-yaml` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要启用YAML配置，添加以下 `quarkus-config-yaml` 扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable the alternative DNS resolver, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要启用备用 DNS 解析器，请使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable this security feature, add this to your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要启用这一安全特性，请将此添加到你的 `application.properties` 文件中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ensure full-compability with `native-image`, it is recommended to apply the Jackson `@field:JsonProperty("fieldName")` annotation, and set a nullable default, as illustrated below. You can automate the generation of Kotlin data classes for your sample JSON using Intellij plugins (such as JSON to Kotlin Class), and easily enable the Jackson annotation and select nullable parameters as part of the auto-code generation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了确保与 `native-image` 的完全兼容性，建议使用Jackson `@field:JsonProperty("fieldName")` 注解，并设置一个空默认值，如下图所示。您可以使用Intellij插件（如JSON to Kotlin Class）为您的样例JSON自动生成Kotlin数据类，并轻松启用Jackson注解和选择并选择可为空的参数，作为自动代码生成的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To extract the required ssl, you must start up a Docker container in the background, and attach to that container to copy the artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要提取所需的ssl，你必须在后台启动一个Docker容器，并附加到该容器来复制工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols,
add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.
You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要生成调试符号，在生成原生可执行文件时添加 `-Dquarkus.native.debug.enabled=true` 标志。你将在原生可执行文件旁边的 `.debug` 文件中找到原生可执行文件的调试符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols, add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.  You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要生成调试符号，在生成原生可执行文件时添加 `-Dquarkus.native.debug.enabled=true` 标志。你将在原生可执行文件旁边的 `.debug` 文件中找到原生可执行文件的调试符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously
run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously
a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了解决这个问题，Quarkus支持测试profile。如果一个测试有一个与之前运行的测试不同的profile，那么Quarkus将被停止，并在运行对应的测试之前使用新的profile启动。这显然会有些许变慢，因为它在测试时间上增加了一个停止/启动周期，但同时也提供了很大的灵活性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了解决这个问题，Quarkus支持测试profile。如果一个测试有一个与之前运行的测试不同的profile，那么Quarkus将被停止，并在运行对应的测试之前使用新的profile启动。这显然会有些许变慢，因为它在测试时间上增加了一个停止/启动周期，但同时也提供了很大的灵活性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get started using MongoDB with Panache with Kotlin, you can, generally, follow the steps laid out in the Java tutorial.  The biggest
change to configuring your project is the Quarkus artifact to include.  You can, of course, keep the Java version if you
need but if all you need are the Kotlin APIs then include the following dependency instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要开始使用带有 Kotlin 的 Panache 的 MongoDB，您通常可以按照 Java 教程中列出的步骤进行操作。配置项目的最大变化是要包含的 Quarkus 工件。当然，如果需要，您可以保留 Java 版本，但如果您只需要 Kotlin API，那么请包含以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get started using MongoDB with Panache with Kotlin, you can, generally, follow the steps laid out in the Java tutorial.  The biggest change to configuring your project is the Quarkus artifact to include.  You can, of course, keep the Java version if you need but if all you need are the Kotlin APIs then include the following dependency instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要开始使用带有 Kotlin 的 Panache 的 MongoDB，您通常可以按照 Java 教程中列出的步骤进行操作。配置项目的最大变化是要包含的 Quarkus 工件。当然，如果需要，您可以保留 Java 版本，但如果您只需要 Kotlin API，那么请包含以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get started:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起步：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To illustrate that converting messages and passing them through works, let's add an endpoint that will receive the outgoing costs and sum them up.  This is a usual JAX-RS endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了说明转换消息和传递消息是可行的，让我们添加一个端点来接收传出成本并将它们相加。 这是一个常见的 JAX-RS 端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了实现一个测试profile，我们需要实现 `io.quarkus.test.junit.QuarkusTestProfile` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement this process, you need the following approach:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了实现这一过程，您需要采取以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To improve user experience, Quarkus registers the three Jackson https://github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you don't need to do it manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了提高用户体验，Quarkus注册了三个Jackson link:https://github.com/FasterXML/jackson-modules-java8[Java 8模块] ，所以你不需要手动操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To include more resources in the native executable, the easiest way is to use the `quarkus.native.resources.includes` configuration property,
and its counterpart to exclude resources `quarkus.native.resources.excludes`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要在原生可执行文件中包含更多的资源，最简单的方法是使用 `quarkus.native.resources.includes` 配置属性，及其对应的排除资源 `quarkus.native.resources.excludes`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To include more resources in the native executable, the easiest way is to use the `quarkus.native.resources.includes` configuration property, and its counterpart to exclude resources `quarkus.native.resources.excludes`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要在本地可执行文件中包含更多的资源，最简单的方法是使用 `quarkus.native.resources.includes` 配置属性，及其对应的排除资源 `quarkus.native.resources.excludes`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To increment a value, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要增加键的值，请运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要让Quarkus在_worker_线程上调用这个方法，请使用 `io.smallrye.common.annotation.Blocking` 注释它。你可以在一个方法、类上使用 ' @Blocking '，或者在整个应用中通过注释一个 `Application` 类来启用它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn more about the usage of the Vert.x Mutiny API, refer to https://smallrye.io/smallrye-mutiny-vertx-bindings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要了解更多关于Vert.x Mutiny API的用法，请参考 https://smallrye.io/smallrye-mutiny-vertx-bindings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To let a user easily try out the service, we will implement an HTTP resource summing up the costs (`CostCollector`), and a simple web page to add new costs and watch the sum.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了让用户轻松试用该服务，我们将实现一个 HTTP 资源来汇总成本 ( `CostCollector` )，以及一个简单的网页来添加新的成本并查看总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the test pass, we also need to update `ReactiveGreetingResourceTest.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了使测试通过，我们还需要像这样更新 `ReactiveGreetingResourceTest.kt` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make your Quarkus application accessible to another application running on a different domain, you need to configure cross-origin resource sharing (CORS).
For more information about the CORS filter that is provided by Quarkus, see the xref:http-reference.adoc#cors-filter[HTTP reference] information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您打算让您的Quarkus应用程序可以被运行在不同区域的另一个应用程序访问，您将需要配置CORS（Cross-Origin资源共享）。请阅读 link:http-reference.html#cors-filter[TTP reference] 以了解更多关于Quarkus所提供的CORS过滤器信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make your Quarkus application accessible to another application running on a different domain, you need to configure cross-origin resource sharing (CORS).  For more information about the CORS filter that is provided by Quarkus, see the xref:http-reference.adoc#cors-filter[HTTP reference] information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您打算让您的Quarkus应用程序可以被运行在不同区域的另一个应用程序访问，您将需要配置CORS（Cross-Origin资源共享）。请阅读 link:http-reference.html#cors-filter[TTP reference] 以了解更多关于Quarkus所提供的CORS过滤器信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To mirror the AWS Lambda environment as closely as possible in a dev environment,
the Quarkus Amazon Lambda extension boots up a mock AWS Lambda event server in Quarkus Dev and Test mode.
This mock event server simulates a true AWS Lambda environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了在开发环境中尽可能地反映AWS Lambda环境，Quarkus Amazon Lambda扩展在Quarkus 开发和测试模式下启动了一个模拟的AWS Lambda事件服务器。这个模拟的事件服务器模拟了一个真正的AWS Lambda环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To mirror the AWS Lambda environment as closely as possible in a dev environment, the Quarkus Amazon Lambda extension boots up a mock AWS Lambda event server in Quarkus Dev and Test mode.  This mock event server simulates a true AWS Lambda environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了在开发环境中尽可能地反映AWS Lambda环境，Quarkus Amazon Lambda扩展在Quarkus 开发和测试模式下启动了一个模拟的AWS Lambda事件服务器。这个模拟的事件服务器模拟了一个真正的AWS Lambda环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To persist objects received from Kafka into a database, you can use Hibernate Reactive with Panache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了将从Kafka收到的对象持久化到数据库中，您可以结合使用Hibernate Reactive与Panache。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To persist objects received from Kafka into a database, you can use Hibernate with Panache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了将从Kafka接收到的对象持久化到数据库中，您可以结合使用Hibernate与Panache。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To receive messages from RabbitMQ:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要接收来自 RabbitMQ 的消息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To reduce the amount of log written by the Kafka client, Quarkus sets the level of the following log categories to `WARNING`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了减少Kafka客户端的日志量，Quarkus将以下日志类别的级别设置为 `WARNING`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To reduce the amount of times Quarkus needs to restart, `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer`
is registered as a global `ClassOrderer` as described in the
link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5 User Guide].
The behavior of this `ClassOrderer` is configurable via `junit-platform.properties` (see the source code or javadoc for more details).
It can also be disabled entirely by setting another `ClassOrderer` that is provided by JUnit 5 or even your own custom one. +
Please note that as of JUnit 5.8.2 link:https://github.com/junit-team/junit5/issues/2794[only a single `junit-platform.properties` is picked up and a warning is logged if more than one is found].
If you encounter such warnings, you can get rid of them by removing the Quarkus-supplied `junit-platform.properties` from the classpath via an exclusion:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了减少Quarkus需要重启的次数， `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` 被注册为全局 `ClassOrderer` ，如 link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5用户指南] 中所述。这个orderer的行为可以通过 `junit-platform.properties` （更多细节见源代码或javadoc）来配置。它也可以通过配置另一个由JUnit 5所提供的ClassOrderer，甚至是您自己的自定义Orderer来完全禁用。+ 请注意，从JUnit 5.8.2开始 link:https://github.com/junit-team/junit5/issues/2794[只能有一个 `junit-platform.properties` 被使用，如果超过一个就会有警告记录] 。如果您遇到这样的警告，您可以通过从classpath中移除Quarkus提供的 `junit-platform.properties` 来删除它们：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To reduce the amount of times Quarkus needs to restart, `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` is registered as a global `ClassOrderer` as described in the link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5 User Guide].  The behavior of this `ClassOrderer` is configurable via `junit-platform.properties` (see the source code or javadoc for more details).  It can also be disabled entirely by setting another `ClassOrderer` that is provided by JUnit 5 or even your own custom one. + Please note that as of JUnit 5.8.2 link:https://github.com/junit-team/junit5/issues/2794[only a single `junit-platform.properties` is picked up and a warning is logged if more than one is found].  If you encounter such warnings, you can get rid of them by removing the Quarkus-supplied `junit-platform.properties` from the classpath via an exclusion:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了减少Quarkus需要重启的次数， `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` 被注册为全局 `ClassOrderer` ，如 link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5用户指南] 中所述。这个orderer的行为可以通过 `junit-platform.properties` （更多细节见源代码或javadoc）来配置。它也可以通过配置另一个由JUnit 5所提供的ClassOrderer，甚至是您自己的自定义Orderer来完全禁用。+ 请注意，从JUnit 5.8.2开始 link:https://github.com/junit-team/junit5/issues/2794[只能有一个 `junit-platform.properties` 被使用，如果超过一个就会有警告记录] 。如果您遇到这样的警告，您可以通过从classpath中移除Quarkus提供的 `junit-platform.properties` 来删除它们：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To register a class for reflection, one would need to create a Quarkus processor class and add a build step that registers reflection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要为反射注册一个类，需要创建一个Quarkus处理器类并添加一个注册反射的构建步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To register meters, you need a reference to a `MeterRegistry`, which is configured and maintained by the Micrometer
extension. The `MeterRegistry` can be injected into your application as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要注册meters，您需要一个对 `MeterRegistry` 的引用，该引用由Micrometer扩展配置和维护。 `MeterRegistry` 可以按以下方式注入到您的应用程序中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To register meters, you need a reference to a `MeterRegistry`, which is configured and maintained by the Micrometer extension. The `MeterRegistry` can be injected into your application as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要注册meters，您需要一个对 `MeterRegistry` 的引用，该引用由Micrometer扩展配置和维护。 `MeterRegistry` 可以按以下方式注入到您的应用程序中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To retrieve an increment using its key, we will have to run the below command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用指定的键查询增量，我们须运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run the application in a dev mode, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要在开发模式下运行应用程序，请使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run the application in dev mode, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要在开发模式下运行应用程序，请使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run the application, don’t forget to start a database and provide the configuration to your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要运行应用程序，不要忘记启动数据库并为应用程序提供配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run your applications as native, first we need to build the native executables:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要以本地方式运行你的应用程序，我们首先需要构建本地可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To schedule a Job execution, please refer to the quarkus.jberet.job.”job-name”.cron and quarkus.jberet.job.”job-name”.params.”param-key” configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要安排工作的执行，请参考quarkus.jberet.job.”job-name”.cron和quarkus.jberet.job.”job-name”.params.”param-key”配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `GreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要看到 `GreetingResourceIT` 面向原生可执行文件运行，使用 `./mvnw verify -Pnative` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `NativeGreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要查看针对原生可执行文件运行 `NativeGreetingResourceIT` ，请用 `./mvnw verify -Pnative`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `usage` statement, and validate AWS configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要查看  `用法`  声明，并验证AWS配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the list of current increments keys, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要查看当前增量键的列表，请运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see this feature in action, first execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要体验到这个功能的作用，首先要执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To send messages to Kafka from an HTTP endpoint, inject an `Emitter` (or a `MutinyEmitter`) in your endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要从HTTP节点向Kafka发送消息，可以在您的节点中注入一个 `Emitter` (或一个 `MutinyEmitter` )：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To send messages to RabbitMQ:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要向 RabbitMQ 发送消息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To send to Kafka entities managed by Hibernate Reactive, we recommend using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了将Hibernate Reactive管理的实体发送到Kafka，建议使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To stand up the Config Server required for this guide, please follow the instructions outlined https://github.com/spring-guides/gs-centralized-configuration#stand-up-a-config-server[here].
The end result of that process is a running Config Server that will provide the `Hello world` value for a configuration property named `message` when the application querying the server is named `a-bootiful-client`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立该指南所需的 配置服务器 (Config Server)，请遵循 link:https://github.com/spring-guides/gs-centralized-configuration#stand-up-a-config-server[这里] 的说明。该过程的最终目的是创建一个正在运行的且应用程序查询名为 `a-bootiful-client` 的服务器时，会为名为 `message` 的配置属性提供值为 `Hello world` 的配置服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To stand up the Config Server required for this guide, please follow the instructions outlined https://github.com/spring-guides/gs-centralized-configuration#stand-up-a-config-server[here].  The end result of that process is a running Config Server that will provide the `Hello world` value for a configuration property named `message` when the application querying the server is named `a-bootiful-client`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立该指南所需的 配置服务器 (Config Server)，请遵循 link:https://github.com/spring-guides/gs-centralized-configuration#stand-up-a-config-server[这里] 的说明。该过程的最终目的是创建一个正在运行的且应用程序查询名为 `a-bootiful-client` 的服务器时，会为名为 `message` 的配置属性提供值为 `Hello world` 的配置服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start a Keycloak Server you can use Docker and just run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要启动Keycloak服务器，您可以使用Docker服务，且只需运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start a MongoDB database for your unit tests, Quarkus provides two `QuarkusTestResourceLifecycleManager` that relies on link:https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[Flapdoodle embedded MongoDB].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了给你的单元测试启动MongoDB数据库，Quarkus提供了两个 `QuarkusTestResourceLifecycleManager` 依赖于 link:https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[Flapdoodle嵌入式MongoDB] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.
The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为此，Quarkus提供了一个非常方便的方法，通过利用容器运行时（如Docker或podman）来创建一个原生Linux可执行文件。完成这项任务的最简单方法是执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.  The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为此，Quarkus提供了一个非常方便的方法，通过利用容器运行时（如Docker或podman）来创建一个原生Linux可执行文件。完成这项任务的最简单方法是执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Alexa with Quarkus native, you need to use the https://github.com/quarkiverse/quarkus-amazon-alexa[Quarkus Amazon Alexa extension hosted at the Quarkiverse Hub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用带有Quarkus原生的Alexa ，你需要使用link:https://github.com/quarkiverse/quarkus-amazon-alexa[托管在Quarkiverse Hub上的Quarkus Amazon Alexa扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Mandrel instead of GraalVM CE, update the `FROM` clause to: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build`.
`$TAG` can be found on the https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel Images Tags page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用Mandrel而不是GraalVM CE，请将 `FROM` 子句更新为: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build` 。 `$TAG` 可以在 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel镜像标签页]上找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Mandrel instead of GraalVM CE, update the `FROM` clause to: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build`.  `$TAG` can be found on the https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel Images Tags page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用Mandrel而不是GraalVM CE，请将 `FROM` 子句更新为: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build` 。 `$TAG` 可以在 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel镜像标签页]上找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use a `MULTICAST` queue, you need to provide the _FQQN_ (fully-qualified queue name) instead of just the name of the queue:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用 `MULTICAST` 队列，你需要提供 _FQQN_ （完全限定队列名称），而不仅仅是队列的名称:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use an existing queue, you need to configure the `address`, `container-id` and, optionally, the `link-name` attributes.
For example, if you have an Apache Artemis broker configured with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用一个现有的队列，你需要配置 `address` , `container-id` 及可选的 `link-name` 属性。例如，如果你有一个Apache Artemis代理，使用以下方式配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use an existing queue, you need to configure the `address`, `container-id` and, optionally, the `link-name` attributes.  For example, if you have an Apache Artemis broker configured with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用一个现有的队列，你需要配置 `address` , `container-id` 及可选的 `link-name` 属性。例如，如果你有一个Apache Artemis代理，使用以下方式配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the connector, you need to add the `quarkus-smallrye-reactive-messaging-amqp` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了使用连接器，你需要添加 `quarkus-smallrye-reactive-messaging-amqp` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the extension, add the dependency to the target project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用该扩展，请将该依赖性添加到目标项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use them with MongoDB with Panache you need to annotate the method that starts the transaction with the `@Transactional` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要将它们与带有 Panache 的 MongoDB 一起使用，你需要在相应的方法上使用 `@Transactional` 注解启动事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use them, you need to add the `io.quarkus:quarkus-test-mongodb` dependency to your pom.xml.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用它们，你需要在你的pom.xml中添加 `io.quarkus:quarkus-test-mongodb` 依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this base image, use the following `Dockerfile`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用该基础镜像，使用以下 `Dockerfile`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (for key or value deserializers).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用这个故障处理的handler，Bean必须使用 `@Identifier` 限定符来暴露，并且connector配置必须指定属性 `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (对于键或值的反序列化器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (for key or value serializers).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用该故障处理，Bean必须用 `@Identifier` 限定符修饰，并且connector的配置必须指定属性 `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (对于键或值序列化器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.
Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.
This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.
For example if I have the following service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用这个方法，只需用 `src/test/java` 目录中的一个类来覆盖您想mock的Bean，并在Bean上加上 `@Alternative` 和 `@Priority(1)` 注解。另外，也可以使用 `io.quarkus.test.Mock` stereotype注释。这个内置的stereotype声明了 `@Alternative` 、 `@Priority(1)` 和 `@Dependent` 。例如，如果我有以下的服务：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.  Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.  This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.  For example if I have the following service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用这个方法，只需用 `src/test/java` 目录中的一个类来覆盖您想mock的Bean，并在Bean上加上 `@Alternative` 和 `@Priority(1)` 注解。另外，也可以使用 `io.quarkus.test.Mock` stereotype注释。这个内置的stereotype声明了 `@Alternative` 、 `@Priority(1)` 和 `@Dependent` 。例如，如果我有以下的服务：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys,
and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.
A usage statement will be printed to guide you accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了验证你的设置，是否安装了AWS CLI，是否为AWS访问密钥执行了aws configure，是否设置了 `LAMBDA_ROLE_ARN` 环境变量（如上所述），请执行不带任何参数的 `manage.sh` 。将会打印出一个使用说明，来对你进行相应的指导。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys, and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.  A usage statement will be printed to guide you accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了验证你的设置，是否安装了AWS CLI，是否为AWS访问密钥执行了aws configure，是否设置了 `LAMBDA_ROLE_ARN` 环境变量（如上所述），请执行不带任何参数的 `manage.sh` 。将会打印出一个使用说明，来对你进行相应的指导。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To view metrics, execute `curl localhost:8080/q/metrics/`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要查看metrics，请执行 `curl localhost:8080/q/metrics/`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To visually see the chunks in the response, we append a separator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了直观地看到响应中的分块，我们添加了一个分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write a blog:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写博客：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today’s users embrace applications with milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput, and elasticity. However, these features are nearly impossible to achieve using yesterday’s software architecture without a considerable investment in resources, infrastructure, and tooling. The world changed, and having dozens of servers, long response times (&amp;gt; 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今天的用户接受具有几毫秒响应时间、100%正常运行时间、更低延迟、推送数据而不是拉动、更高的吞吐量和弹性的应用程序。然而，如果不对资源、基础设施和工具进行大量投资，使用昨天的软件架构几乎不可能实现这些功能。世界变了，拥有几十台服务器、较长的响应时间（&gt;500毫秒）、因维护或瀑布式的故障而导致的停机时间，并不能满足预期的用户体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Claims And SecurityIdentity Roles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>令牌声明(Token Claims)和安全身份角色(SecurityIdentity Roles)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Decryption</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>令牌解密</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Introspection and UserInfo Cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Token自省和UserInfo缓存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>令牌传播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Verification And Introspection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代币验证(Token Verification)和自省(Introspection)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Verification And Introspection </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代币验证(Token Verification)和自省(Introspection)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Total Builds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>总构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>跟踪</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing &amp; Debugging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追踪和调试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing with AWS XRay and GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用AWS XRay和GraalVM进行追踪</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional EE patterns advise to split entity definition (the model) from the operations you can do on them
(DAOs, Repositories), but really that requires a split between the state and its operations even though
we would never do something like that for regular objects in the Object Oriented architecture, where state and methods
are in the same class. Moreover, this requires two classes per entity, and requires injection of the DAO or Repository
where you need to do entity operations, which breaks your edit flow and requires you to get out of the code you're
writing to set up an injection point before coming back to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的EE模式建议将实体定义（模型）与它可以进行的操作（DAO、Repository）分开，但实际上这需要将实体状态及其操作分开；但在面向对象的架构里我们不会对普通对象这样做，因为普通对象的状态和方法在同一个类中。此外，这样需要每个实体对应两个类，并且要在需要进行实体操作的地方注入DAO或Repository，这就破坏了你的开发流程，需要你从正在编写的代码中跳出来，建立一个注入点，然后再回来使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional EE patterns advise to split entity definition (the model) from the operations you can do on them
(DAOs, Repositories), but really that requires an unnatural split between the state and its operations even though
we would never do something like that for regular objects in the Object Oriented architecture, where state and methods
are in the same class. Moreover, this requires two classes per entity, and requires injection of the DAO or Repository
where you need to do entity operations, which breaks your edit flow and requires you to get out of the code you're
writing to set up an injection point before coming back to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的EE模式建议将实体定义（模型）与你可以对其进行的操作（DAO、Repositories）分开，但实际上这需要在状态和其操作之间进行不自然的分割，尽管在面向对象的架构中，我们永远不会对普通对象做这样的事情，因为状态和方法是在同一个类中。此外，这需要每个实体有两个类，并且需要在你需要进行实体操作的地方注入DAO或Repository，这就破坏了你的编辑流程，需要你从正在编写的代码中跳出来，建立一个注入点，然后再回来使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional EE patterns advise to split entity definition (the model) from the operations you can do on them
(DAOs, Repositories), but really that requires an unnatural split between the state and its operations even though
we would never do something like that for regular objects in the Object Oriented architecture, where state and methods are in the same class. Moreover, this requires two classes per entity, and requires injection of the DAO or Repository where you need to do entity operations, which breaks your edit flow and requires you to get out of the code you're writing to set up an injection point before coming back to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的EE模式建议将实体定义（模型）与你可以对其进行的操作（DAO、Repositories）分开，但实际上这需要在状态和其操作之间进行不自然的分割，尽管在面向对象的架构中，我们永远不会对普通对象做这样的事情，因为状态和方法是在同一个类中。此外，这需要每个实体有两个类，并且需要在你需要进行实体操作的地方注入DAO或Repository，这就破坏了你的编辑流程，需要你从正在编写的代码中跳出来，建立一个注入点，然后再回来使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional EE patterns advise to split entity definition (the model) from the operations you can do on them (DAOs, Repositories), but really that requires an unnatural split between the state and its operations even though we would never do something like that for regular objects in the Object Oriented architecture, where state and methods are in the same class. Moreover, this requires two classes per entity, and requires injection of the DAO or Repository where you need to do entity operations, which breaks your edit flow and requires you to get out of the code you're writing to set up an injection point before coming back to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的EE模式建议将实体定义（模型）与你可以对其进行的操作（DAO、Repositories）分开，但实际上这需要在状态和其操作之间进行不自然的分割，尽管在面向对象的架构中，我们永远不会对普通对象做这样的事情，因为状态和方法是在同一个类中。此外，这需要每个实体有两个类，并且需要在你需要进行实体操作的地方注入DAO或Repository，这就破坏了你的编辑流程，需要你从正在编写的代码中跳出来，建立一个注入点，然后再回来使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional Java stacks were engineered for monolithic applications with long startup times and large memory requirements in a world where the cloud, containers, and Kubernetes did not exist. Java frameworks needed to evolve to meet the needs of this new world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的Java堆栈是为单体应用设计的，启动时间长，内存需求大，而当时还没有云、容器和Kubernetes的存在。Java框架需要发展以满足这个新世界的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction support inside MongoDB with Panache is still experimental.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache的MongoDB内部的事务支持仍处于试验阶段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction-aware consumers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务感知型消费者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transactions are not supported for Reactive Entities and Repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式实体和存储库不支持事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Trigger the inclusion on additional extensions based on certain conditions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于特定条件触发包含附加扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Trust all the hostnames. If the keys have to be fetched over `HTTPS` and this property is set to `true` then all the hostnames are trusted by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>信任所有的主机名。如果钥匙必须通过 `HTTPS` 获得，并且该属性被设置为 `true` ，那么所有的主机名都被默认信任。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UBI images can be used without any limitations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UBI镜像可以不受任何限制地使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>URI templates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>URI模板</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>URL of our chat.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们聊天的URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>USAGE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Understanding the Platform concept</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>理解平台概念</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unified Config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unified configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unifies Imperative and Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一指令式和响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unifies imperative and reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一指令式和响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the `ConsumerRebalanceListener` from Apache Kafka, the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` methods pass the Kafka Consumer and the set of topics/partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Apache Kafka的 `ConsumerRebalanceListener` 不同， `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 的方法会传递Kafka消费者和topic/分区集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the previous example using the _payloads_ directly, you can also use `Message` directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与之前直接使用 _有效载荷_ 的例子不同，你也可以直接使用 `Message` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike with _classic_ Hibernate, you can't use `@Transactional`.
Instead, we use `Panache.withTransaction` and persist our entity.
The `map` is used to return a `Uni&lt;Void&gt;` and not a `Uni&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与 _常规的_ Hibernate不同，您无法使用 `@Transactional` 注解。相反，可以使用 `Panache.withTransaction` ，并持久化实体实例。`map` 用来返回一个 `Uni&lt;Void&gt;` 实例，而不是一个 `Uni&lt;Fruit&gt;` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike with _classic_ Hibernate, you can't use `@Transactional`.  Instead, we use `Panache.withTransaction` and persist our entity.  The `map` is used to return a `Uni&lt;Void&gt;` and not a `Uni&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与 _常规的_ Hibernate不同，您无法使用 `@Transactional` 注解。相反，可以使用 `Panache.withTransaction` ，并持久化实体实例。`map` 用来返回一个 `Uni&lt;Void&gt;` 实例，而不是一个 `Uni&lt;Fruit&gt;` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unsupported Spring Scheduled functionalities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不支持的Spring Scheduled功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更改 `oauth.client.id` ， `oauth.client.secret` 和 `oauth.token.endpoint.uri` 值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the application configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新该应用程序的配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] interface, i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] 接口，即：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] interface, i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] 接口，即：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/ReactiveRedisClientImpl.java[`ReactiveRedisClientImpl`], i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/ReactiveRedisClientImpl.java[`ReactiveRedisClientImpl`] ，即：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisClientImpl.java[`RedisClientImpl`], i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisClientImpl.java[`RedisClientImpl`] ，即：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Apache Kafka, Avro serialized records, and connect to a schema registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka，Avro序列化记录，并连接到一个模式注册中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ConfigMaps as a configuration source for your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用ConfigMaps作为Quarkus应用程序的配置源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Ctrl-C to stop the Quarkus server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Ctrl-C来停止Quarkus服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add DRL files with rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来添加带有规则的DRL文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add business automation and power it up with DMN decision support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来增加业务自动化，并通过DMN决策支持为其提供动力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add business automation to power it up with predictions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来添加业务自动化，为其提供预测的动力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot的 `@ConfigurationProperties` ，代替MicroProfile配置注解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `KafkaCompanion` to create producer task which writes 10 records to 'orders' topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `KafkaCompanion` 来创建生产者任务，用于向 'orders' topic写入10条记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `Uni` when you have a single result.
Use `Multi` when you have multiple items that may be emitted asynchronously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你有一个单一的结果时，使用 `Uni` 。当你有多个可能被异步发射的项目时，使用 `Multi` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `Uni` when you have a single result.  Use `Multi` when you have multiple items that may be emitted asynchronously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你有一个单一的结果时，使用 `Uni` 。当你有多个可能被异步发射的项目时，使用 `Multi` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `mp.jwt.verify.publickey.algorithm` to customize the verification algorithm (default is `RS256`), for example, set it to `ES256` when working with the EC keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `mp.jwt.verify.publickey.algorithm` 来定制验证算法（默认为 `RS256` ），例如，在使用EC密钥时，将其设置为 `ES256` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a custom `@Produces` method to create and configure a customized `MeterRegistry` if you need to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果需要的话，请使用自定义的 `@Produces` 方法来创建和配置一个自定义的 `MeterRegistry` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.
The executable is retrieved by the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里使用另一个测试runner来通过本地文件在测试之前启动应用。该执行文件通过  _Failsafe Maven Plugin_ 来获取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.
The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用另一个测试运行器，在测试前从原生文件启动应用程序。使用 _Failsafe Maven Plugin_ 中配置的 `native.image.path` 系统属性检索该可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.  The executable is retrieved by the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里使用另一个测试runner来通过本地文件在测试之前启动应用。该执行文件通过  _Failsafe Maven Plugin_ 来获取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.  The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用另一个测试运行器，在测试前从原生文件启动应用程序。使用 _Failsafe Maven Plugin_ 中配置的 `native.image.path` 系统属性检索该可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use bundler to fetch all required gems in their respective versions
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用bundler获取各自版本中所需的所有gems
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use mutable jars to rebuild your application with different build time configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用易变的jars来重建具有不同构建时间配置的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用平台特定的安装工具，如 https://github.com/graalvm/homebrew-tap[homebrew]，https://sdkman.io/jdks#Oracle[sdkman]，或 https://github.com/ScoopInstaller/Java[scoop]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://sdkman.io/jdks#Oracle[sdkman], https://github.com/graalvm/homebrew-tap[homebrew], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用特定平台的安装工具，如 https://sdkman.io/jdks#Oracle[sdkman] 、https://github.com/graalvm/homebrew-tap[homebrew] 或 https://github.com/ScoopInstaller/Java[scoop] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use public fields. Get rid of dumb getter and setters. Hibernate ORM w/o Panache also doesn't require you to use getters and setters,
but Panache will additionally generate all getters and setters that are missing, and rewrite every access to these fields to use the accessor methods. This way you can still
write _useful_ accessors when you need them, which will be used even though your entity users still use field accesses. This implies that from the Hibernate perspective you're using accessors via getters and setters even while it looks like field accessors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用public字段，抛开愚蠢的getter和setter方法。Hibernate ORM Panache不要求你使用getter和setter方法，但Panache会额外生成所有缺失的getter和setter方法，并将所有对这些字段的访问重写为getter/setter方法的调用。这样，当你需要的时候，仍可以编写 _有用的_ 访问器，即使实体类的调用者仍然使用字段访问，实际也会使用这些访问器。这意味着从Hibernate的角度来看，你正在通过getter和setter方法使用访问器，即使代码看起来像字段访问器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use public fields. Get rid of dumb getter and setters. Hibernate ORM w/o Panache also doesn't require you to use getters and setters, but Panache will additionally generate all getters and setters that are missing, and rewrite every access to these fields to use the accessor methods. This way you can still write _useful_ accessors when you need them, which will be used even though your entity users still use field accesses. This implies that from the Hibernate perspective you're using accessors via getters and setters even while it looks like field accessors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用public字段，抛开愚蠢的getter和setter方法。Hibernate ORM Panache不要求你使用getter和setter方法，但Panache会额外生成所有缺失的getter和setter方法，并将所有对这些字段的访问重写为getter/setter方法的调用。这样，当你需要的时候，仍可以编写 _有用的_ 访问器，即使实体类的调用者仍然使用字段访问，实际也会使用这些访问器。这意味着从Hibernate的角度来看，你正在通过getter和setter方法使用访问器，即使代码看起来像字段访问器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use public fields. Get rid of dumb getter and setters. Under the hood, we will generate all getters and setters
that are missing, and rewrite every access to these fields to use the accessor methods. This way you can still
write _useful_ accessors when you need them, which will be used even though your entity users still use field accesses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用公共字段。摆脱繁琐的getter和setters。在后台，我们将生成所有缺失的getter和setter，并重写对这些字段的每个访问，以使用访问器方法。这样，当你需要时，你仍然可以写出 _有用的_ 访问器，即使你的实体用户仍然使用字段访问，也会被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use public fields. Get rid of dumb getter and setters. Under the hood, we will generate all getters and setters that are missing, and rewrite every access to these fields to use the accessor methods. This way you can still write _useful_ accessors when you need them, which will be used even though your entity users still use field accesses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用公共字段。摆脱繁琐的getter和setters。在后台，我们将生成所有缺失的getter和setter，并重写对这些字段的每个访问，以使用访问器方法。这样，当你需要时，你仍然可以写出 _有用的_ 访问器，即使你的实体用户仍然使用字段访问，也会被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the &lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;Discussions&lt;/a&gt; section on our GitHub project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用我们GitHub项目上的&lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;讨论&lt;/a&gt;部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Flyway instance directly</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>直接使用Flyway实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Quarkus CLI to create, build, run, and manage extensions for Quarkus projects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus CLI来创建、构建、运行和管理Quarkus项目的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Spring `@Scheduled` annotation with a cron-like expression to instruct Quarkus to schedule this method run.  In this example we're scheduling a task to be executed at 10:15am every day.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用一个带有类似于cron表达式的Spring `@Scheduled` 注解来指示Quarkus安排这个方法的运行。在这个例子里，我们将会安排一个每天上午10:15都会被执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `invoke` command to invoke your function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `invoke` 命令来调用你的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `quarkus.micrometer.binder.http-server.match-patterns` property if the correct URL can not be determined.
This property accepts a comma-separated list defining an association between a simple regex match pattern and a replacement
string.
For example, setting
`quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` would use the value
`/example/{jellybeans}` for the uri attribute any time the requested uri matches `/example/prime/[0-9]+`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果不能确定正确的URL，请使用 `quarkus.micrometer.binder.http-server.match-patterns` 属性。这个属性使用一个逗号分隔的列表来定义一个简单的正则匹配模式和对应的替换字符串之间的关联。例如，设置成 `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` ，则可以请求的URI与 `/example/prime/[0-9]+` 匹配时为URI属性使用 `/example/{jellybeans}` 的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `quarkus.micrometer.binder.http-server.match-patterns` property if the correct URL can not be determined. This
property accepts a comma-separated list defining an association between a simple regex match pattern and a replacement
string. For example, setting
`quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` would use the value
`/example/{jellybeans}` for the uri attribute any time the requested uri matches `/example/prime/[0-9]+`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果不能确定正确的URL，请使用 `quarkus.micrometer.binder.http-server.match-patterns` 属性。这个属性使用一个逗号分隔的列表来定义一个简单的正则匹配模式和对应的替换字符串之间的关联。例如，设置成 `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` ，则可以请求的URI与 `/example/prime/[0-9]+` 匹配时为URI属性使用 `/example/{jellybeans}` 的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `quarkus.micrometer.binder.http-server.match-patterns` property if the correct URL can not be determined. This property accepts a comma-separated list defining an association between a simple regex match pattern and a replacement string. For example, setting `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` would use the value `/example/{jellybeans}` for the uri attribute any time the requested uri matches `/example/prime/[0-9]+`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果不能确定正确的URL，请使用 `quarkus.micrometer.binder.http-server.match-patterns` 属性。这个属性使用一个逗号分隔的列表来定义一个简单的正则匹配模式和对应的替换字符串之间的关联。例如，设置成 `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` ，则可以请求的URI与 `/example/prime/[0-9]+` 匹配时为URI属性使用 `/example/{jellybeans}` 的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` docker image introduced in &lt;&lt;#multistage-docker,Using a multi-stage Docker build&gt;&gt; to build the native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 &lt;&lt;#multistage-docker,Using a multi-stage Docker build&gt;&gt; 中介绍的 `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` docker镜像来构建原生镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `received` method on `beverages` channel to check the messages produced by the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `beverages`  channel 上使用 `received` 方法来检查应用程序产生的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `send` method to send a message to the `orders` channel.
The application will process this message and send a message to `beverages` channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `send` 方法向 `orders`  channel 发送一个消息。应用程序将处理这个消息并向 `beverages`  channel 发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `send` method to send a message to the `orders` channel.  The application will process this message and send a message to `beverages` channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `send` 方法向 `orders`  channel 发送一个消息。应用程序将处理这个消息并向 `beverages`  channel 发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the command below, to delete an increment given its key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用下面的命令，删除一个键的增量：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令递归删除GraalVM安装目录上的 `com.apple.quarantine` 扩展属性，作为一种解决方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the following information to help you to decide which authentication mechanism to use to secure your Quarkus applications:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下信息来帮助您决定使用哪种认证机制来保护您的Quarkus应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any "Run as JUnit" configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用这个JRE定义作为您的Quarkus项目的目标运行时，该运行时将被用于所有 "作为JUnit运行(Run as JUnit) "的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User Info</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用户信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User info support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持UserInfo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can even provide their own `ObjectMapper` bean if they so choose.
If this is done, it is very important to manually inject and apply all `io.quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that produces `ObjectMapper`.
Failure to do so will prevent Jackson specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用户选择的话，他们甚至可以提供自己的 `ObjectMapper` bean。如果这样做，在产生 `ObjectMapper` 的CDI生产者中，手动注入和应用所有 `io.quarkus.jackson.ObjectMapperCustomizer` Bean是非常重要的。如果不这样做，就会阻止各种扩展所提供的Jackson特定的自定义功能被应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can even provide their own `ObjectMapper` bean if they so choose.  If this is done, it is very important to manually inject and apply all `io.quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that produces `ObjectMapper`.  Failure to do so will prevent Jackson specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用户选择的话，他们甚至可以提供自己的 `ObjectMapper` bean。如果这样做，在产生 `ObjectMapper` 的CDI生产者中，手动注入和应用所有 `io.quarkus.jackson.ObjectMapperCustomizer` Bean是非常重要的。如果不这样做，就会阻止各种扩展所提供的Jackson特定的自定义功能被应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uses GraalVM 21.+</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用GraalVM 21.+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using @ApplicationScoped Beans as Verticle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用@ApplicationScoped Beans作为Verticle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AI to optimize a schedule with OptaPlanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用人工智能来优化OptaPlanner的日程安排</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AMQP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用AMQP与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Apache Kafka Streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka Streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Apache Kafka with Schema Registry and Avro</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka与模式仓库和Avro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Blaze-Persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Blaze-Persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using CompletionStages or Publisher API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用CompletionStages或Publisher API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Eclipse Vert.x API from a Quarkus Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus应用程序中使用Eclipse Vert.x API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用容错技术</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HTTP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用HTTP与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HTTPS or SSL/TLS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用HTTPS或SSL/TLS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HashiCorp Vault with Databases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在数据库中使用HashiCorp Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HashiCorp Vault’s PKI Secret Engine</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用HashiCorp Vault的PKI加密引擎</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用健康检查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate ORM and JPA</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Hibernate ORM和JPA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Hibernate响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate Reactive with Panache to interact with a database in a reactive fashion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 Hibernate Reactive 与 Panache 结合使用，以响应式方式与数据库进行交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Infinispan Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Infinispan客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using JMS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using JWT RBAC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JWT RBAC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Keycloak to centralize authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Keycloak进行集中授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito DMN support to add decision automation capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito DMN支持为应用程序添加决策自动化功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add business automation capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加业务自动化功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add prediction capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加预测功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add rule engine capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加规则引擎功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using LRA (Long Running Actions)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用LRA（长期运行的活动）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using MeterFilter to configure metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用MeterFilter来配置metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OAuth2 RBAC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OAuth2 RBAC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenAPI and Swagger UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenAPI和Swagger UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) Multi-Tenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）多租户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) and Keycloak to Centralize Authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID连接（OIDC）与Keycloak来做集中式授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) and Keycloak to Centralize Authorizations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）和Keycloak来集中授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) and OAuth2 Client and Filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）和OAuth2客户端和过滤器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) to Protect Service Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）来保护服务应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) to Protect Service Applications using Bearer Token Authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用OpenID Connect（OIDC）来保护使用不记名令牌授权的服务应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) to Protect Web Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）来保护网络应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenTelemetry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenTelemetry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenTracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenTracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Property Expressions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用属性表达式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Quarkus reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus响应式API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RESTEasy Reactive to implement HTTP API while enforcing the reactive principle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RESTEasy Reactive 实现 HTTP API，同时强制执行响应式原则</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RabbitMQ</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用RabbitMQ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RabbitMQ with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用RabbitMQ与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式 API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式路由</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Response</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RxJava or Reactor APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RxJava 或 Reactor API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using SSL With Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在原生可执行文件中使用SSL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Schema Registry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Schema注册表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with .properties File</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用.properties文件的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with JDBC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JDBC的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with JPA</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JPA的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with LDAP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用LDAP的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with WebAuthn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebAuthn的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Sentry to Monitor your Logs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Sentry来监控你的日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Snappy for message compression</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Snappy进行消息压缩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Software Transactional Memory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用软件事务性内存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Spies instead of Mocks with `@InjectSpy`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `@InjectSpy` 用Spies来代替Mocks</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Spring Boot's ConfigurationProperties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot的ConfigurationProperties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions in Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus中使用事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault Transit Secret Engine</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vault Transit保密引擎</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x Core API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x核心API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x JSON</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x JSON</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Vert.x 客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x stream capability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x流的功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using WebSockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebSockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using WebSockets with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebSockets与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@BsonProperty` is not needed to define custom column mappings, as the mappings from the entity class will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@BsonProperty` ，不需要定义自定义列映射，因为将使用来自实体类的映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@DisabledOnIntegrationTest` will also disable the test in all integration test instances, including
testing the application in JVM mode, in a container image, and native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@DisabledOnIntegrationTest` 还将禁用所有集成测试实例中的测试，包括在JVM模式、容器镜像和原生镜像中测试应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@DisabledOnIntegrationTest` will also disable the test in all integration test instances, including testing the application in JVM mode, in a container image, and native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@DisabledOnIntegrationTest` 还将禁用所有集成测试实例中的测试，包括在JVM模式、容器镜像和原生镜像中测试应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock` with `@RestClient`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@InjectMock` 与 `@RestClient`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@InjectMock` ，前面的例子可以写成下面形式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@Inject` will get you a CDI proxy to the mock instance you install, which is not suitable for passing to methods such as `Mockito.verify`
which want the mock instance itself. So if you need to call methods such as `verify` you need to hang on to the mock instance in your test, or use `@InjectMock`
as shown below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@Inject` ，您会得到一个对您安装的mock实例的CDI代理，它并不适合传递给诸如 `Mockito.verify` 这样的方法，这些方法会需要mock实例本身。因此，如果您需要调用诸如 `verify` 这样的方法，您需要在您的测试中挂载mock实例，或者使用 `@InjectMock` ，如下所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@Inject` will get you a CDI proxy to the mock instance you install, which is not suitable for passing to methods such as `Mockito.verify` which want the mock instance itself. So if you need to call methods such as `verify` you need to hang on to the mock instance in your test, or use `@InjectMock` as shown below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@Inject` ，您会得到一个对您安装的mock实例的CDI代理，它并不适合传递给诸如 `Mockito.verify` 这样的方法，这些方法会需要mock实例本身。因此，如果您需要调用诸如 `verify` 这样的方法，您需要在您的测试中挂载mock实例，或者使用 `@InjectMock` ，如下所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@QuarkusIntegrationTest`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用@QuarkusIntegrationTest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a Distroless base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用无发行版基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用一个配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a distroless base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用无发行版基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a multi-stage Docker build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用多阶段的Docker构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a range instead of pages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用range而不是pages</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a scratch base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Scratch基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using annotations is limited, as you can't dynamically assign meaningful tag values.
Also note that many methods, e.g. REST endpoint methods or Vert.x Routes, are counted and timed by the micrometer extension out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注解是被限制的，因为您不能动态地分配有意义的标签值。还要注意的是，许多方法的计数和计时，例如REST节点方法或Vert.x Routes，Micrometer扩展都支持开箱即用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using annotations is limited, as you can't dynamically assign meaningful tag values. Also note that many methods, e.g.
REST endpoint methods or Vert.x Routes, are counted and timed by the micrometer extension out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注解是被限制的，因为您不能动态地分配有意义的标签值。还要注意的是，许多方法的计数和计时，例如REST节点方法或Vert.x Routes，Micrometer扩展都支持开箱即用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using annotations is limited, as you can't dynamically assign meaningful tag values. Also note that many methods, e.g.  REST endpoint methods or Vert.x Routes, are counted and timed by the micrometer extension out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注解是被限制的，因为您不能动态地分配有意义的标签值。还要注意的是，许多方法的计数和计时，例如REST节点方法或Vert.x Routes，Micrometer扩展都支持开箱即用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using codecs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用编解码器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注入法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using mongo+srv:// urls</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用mongo+srv:// urls</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using multiple verticles instances</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用多个verticles的实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using other Registry implementations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用其他Registry实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using our Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用我们的工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式数据库访问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a construct means that a `--initialize-at-run-time` option will automatically be added to the `native-image` command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用这样的结构意味着 `--initialize-at-run-time` 选项将被自动添加到 `native-image` 命令行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a construct means that a `-H:DynamicProxyConfigurationResources` option will automatically be added to the `native-image` command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用这样的结构意味着 `-H:DynamicProxyConfigurationResources` 选项将被自动添加到 `native-image` 命令行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the @RegisterForReflection annotation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用@RegisterForReflection注解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the AWS Java SDK v2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用AWS Java SDK v2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Flyway object</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Flyway对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the JsonWebToken and Claim Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JsonWebToken和声明(claim)注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Kubernetes Client to Interact with a Kubernetes Cluster</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kubernetes客户端与Kubernetes集群互动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the MongoDB Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用MongoDB客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Cloud Config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Cloud Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring DI API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring DI API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Data JPA API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Data JPA API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Scheduled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Security API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Security API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Web API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Web API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Kubernetes extension, developers can perform or automate a single-step deployment using Jib, Docker, and Source-to-Image (S2i) including the creation of DeploymentConfig to trigger automatic redeployments. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Kubernetes扩展，开发人员可以使用Jib、Docker和Source-to-Image（S2i）执行或自动进行单步部署，包括创建DeploymentConfig以触发自动重新部署。 &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;阅读指南了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus OIDC extension, both Bearer Token and Authorization Code Flow mechanisms use &lt;&lt;smallrye-jwt, SmallRye JWT&gt;&gt; to represent JWT tokens as MicroProfile JWT `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `Quarkus OIDC` 扩展， `Bearer` 和 `Authorization Code Flow` 认证机制都使用 link:#smallrye-jwt[SmallRye JWT] 来将Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken` 表示为JWTtoken。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用REST客户端（包括JSON）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client with Multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Multipart的REST客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the RESTEasy Classic REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用RESTEasy Classic REST客户端（包括JSON）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Redis Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the `Emitter` you are sending messages from your imperative code to reactive messaging.
These messages are stored in a queue until they are sent.
If the Kafka producer client can't keep up with messages trying to be sent over to Kafka, this queue can become a memory hog and you may even run out of memory.
You can use `@OnOverflow` to configure back-pressure strategy.
It lets you configure the size of the queue (default is 256) and the strategy to apply when the buffer size is reached. Available strategies are `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` and `NONE`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `Emitter` 的话您会以命令式代码的方式发送消息到响应式消息中(reactive messaging)。这些消息被存储在一个队列中，直到它们被发送。如果Kafka生产者client无法跟上发送到Kafka的消息节奏，这个队列就会成为一个内存占用者，甚至会耗尽内存。您可以使用 `@OnOverflow` 来配置背压策略。它可以让您配置队列的大小(默认是256)和达到缓冲区上限时要应用的策略。可用的策略有 `DROP` , `LATEST` , `FAIL` , `BUFFER` , `UNBOUNDED_BUFFER` 和 `NONE` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the `Emitter` you are sending messages from your imperative code to reactive messaging.  These messages are stored in a queue until they are sent.  If the Kafka producer client can't keep up with messages trying to be sent over to Kafka, this queue can become a memory hog and you may even run out of memory.  You can use `@OnOverflow` to configure back-pressure strategy.  It lets you configure the size of the queue (default is 256) and the strategy to apply when the buffer size is reached. Available strategies are `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` and `NONE`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `Emitter` 的话您会以命令式代码的方式发送消息到响应式消息中(reactive messaging)。这些消息被存储在一个队列中，直到它们被发送。如果Kafka生产者client无法跟上发送到Kafka的消息节奏，这个队列就会成为一个内存占用者，甚至会耗尽内存。您可以使用 `@OnOverflow` 来配置背压策略。它可以让您配置队列的大小(默认是256)和达到缓冲区上限时要应用的策略。可用的策略有 `DROP` , `LATEST` , `FAIL` , `BUFFER` , `UNBOUNDED_BUFFER` 和 `NONE` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the `health-topic-verification-enabled=true` attribute, _startup_ probe uses an _admin client_ to check for the list of topics.
Whereas the _readiness_ probe for an incoming channel checks that at least one partition is assigned for consumption,
and for an outgoing channel checks that the topic used by the producer exist in the broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `health-topic-verification-enabled=true` 属性， _启动_ 探针使用一个 _管理客户端_ 来检查topic列表。而传入 channel 的 _就绪_ 探针将检查是否至少有一个分区被分配用于消费，而传出 channel 则检查生产者使用的topic是否存在于broker中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the `health-topic-verification-enabled=true` attribute, _startup_ probe uses an _admin client_ to check for the list of topics.  Whereas the _readiness_ probe for an incoming channel checks that at least one partition is assigned for consumption, and for an outgoing channel checks that the topic used by the producer exist in the broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `health-topic-verification-enabled=true` 属性， _启动_ 探针使用一个 _管理客户端_ 来检查topic列表。而传入 channel 的 _就绪_ 探针将检查是否至少有一个分区被分配用于消费，而传出 channel 则检查生产者使用的topic是否存在于broker中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the active record pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Active Record模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the active-record pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用active-record模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用此基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the container-image extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用容器-镜像扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the repository pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用资源库模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using unique consumer groups</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用单一的消费者组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using verticles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用verticles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] is recommended for the integration testing against Keycloak.
`Dev Services for Keycloak` will launch and initialize a test container: it will create a `quarkus` realm, a `quarkus-app` client (`secret` secret) and add `alice` (`admin` and `user` roles) and `bob` (`user` role) users, where all of these properties can be customized.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建议使用 link:security-openid-connect-dev-services.html[Keycloak开发服务] 进行针对Keycloak的集成测试。 `Keycloak开发服务` 将启动和初始化一个测试容器：它将创建一个 `quarkus` 领域，一个 `quarkus-app` 客户端（ `secret` 秘密）并添加 `alice` （ `admin` 和 `user` 角色）和 `bob` （ `user` 角色）用户，其中所有这些属性都可以被定制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] is recommended for the integration testing against Keycloak.  `Dev Services for Keycloak` will launch and initialize a test container: it will create a `quarkus` realm, a `quarkus-app` client (`secret` secret) and add `alice` (`admin` and `user` roles) and `bob` (`user` role) users, where all of these properties can be customized.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建议使用 link:security-openid-connect-dev-services.html[Keycloak开发服务] 进行针对Keycloak的集成测试。 `Keycloak开发服务` 将启动和初始化一个测试容器：它将创建一个 `quarkus` 领域，一个 `quarkus-app` 客户端（ `secret` 秘密）并添加 `alice` （ `admin` 和 `user` 角色）和 `bob` （ `user` 角色）用户，其中所有这些属性都可以被定制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VSCode "run with" configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>VSCode "run with "配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation with Hibernate Validator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Hibernate验证器进行验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Valu</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Valu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variables for Use in Documents</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文件中使用的变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Verify Maven is using the Java you expect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>验证Maven是否使用了你期望的Java版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Verify that Maven is using the Java version you expect.
If you have multiple JDKs installed, make sure Maven is using the expected one.
You can verify which JDK Maven uses by running `mvn --version.`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>验证Maven正在使用您期望的Java版本。如果安装了多个JDK，请确保Maven使用的是适当的版本。你可以通过运行 `mvn --version` 来验证Maven使用的是哪个JDK</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Verify that Maven is using the Java version you expect.  If you have multiple JDKs installed, make sure Maven is using the expected one.  You can verify which JDK Maven uses by running `mvn --version.`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>验证Maven正在使用您期望的Java版本。如果安装了多个JDK，请确保Maven使用的是适当的版本。你可以通过运行 `mvn --version` 来验证Maven使用的是哪个JDK</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version {graalvm-version} is required. Using the community edition is enough.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>版本 {graalvm-version} 是必需的。使用社区版就可以了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x APIs often rely on JSON.
Vert.x provides two convenient classes to manipulate JSON document: `io.vertx.core.json.JsonObject` and `io.vertx.core.json.JsonArray`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x的API经常依赖JSON。Vert.x提供了两个方便的类来操作JSON文档： `io.vertx.core.json.JsonObject` 和 `io.vertx.core.json.JsonArray` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x APIs often rely on JSON.  Vert.x provides two convenient classes to manipulate JSON document: `io.vertx.core.json.JsonObject` and `io.vertx.core.json.JsonArray`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x的API经常依赖JSON。Vert.x提供了两个方便的类来操作JSON文档： `io.vertx.core.json.JsonObject` 和 `io.vertx.core.json.JsonArray` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x Reference Guide</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x参考指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x comes with a built-in https://vertx.io/docs/vertx-core/java/#event_bus[event bus] that you can use from your Quarkus application.
So, your application components (CDI beans, resources...) can interact using asynchronous events, thus promoting loose-coupling.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x有一个内置的 link:https://vertx.io/docs/vertx-core/java/#event_bus[事件总线] ，你可以从你的Quarkus应用程序中使用。因此，你的应用程序组件（CDI Bean、resources......）可以使用异步事件进行交互，从而促进松散耦合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x comes with a built-in https://vertx.io/docs/vertx-core/java/#event_bus[event bus] that you can use from your Quarkus application.  So, your application components (CDI beans, resources...) can interact using asynchronous events, thus promoting loose-coupling.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x有一个内置的 link:https://vertx.io/docs/vertx-core/java/#event_bus[事件总线] ，你可以从你的Quarkus应用程序中使用。因此，你的应用程序组件（CDI Bean、resources......）可以使用异步事件进行交互，从而促进松散耦合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x is capable of using https://netty.io/wiki/native-transports.html[Netty's native transports], which offers
performance improvements on specific platforms.To enable them, you must include the appropriate dependency for your
platform. It's usually a good idea to have both to keep your application platform agnostic. Netty is smart enough
to use the correct one, that includes none at all on unsupported platforms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x能够使用 https://netty.io/wiki/native-transports.html[Netty的本地传输] ，在特定的平台上提供性能改进。要启用它们，你必须为你的平台包含适当的依赖。通常，为了保持你的应用程序与平台无关，这是个好主意。Netty很聪明，会使用正确的依赖，包括在不支持的平台上根本不使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x is capable of using https://netty.io/wiki/native-transports.html[Netty's native transports], which offers performance improvements on specific platforms.To enable them, you must include the appropriate dependency for your platform. It's usually a good idea to have both to keep your application platform agnostic. Netty is smart enough to use the correct one, that includes none at all on unsupported platforms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x能够使用 https://netty.io/wiki/native-transports.html[Netty的本地传输] ，在特定的平台上提供性能改进。要启用它们，你必须为你的平台包含适当的依赖。通常，为了保持你的应用程序与平台无关，这是个好主意。Netty很聪明，会使用正确的依赖，包括在不支持的平台上根本不使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very similarly, Quarkus allows extensions authors to register a `NativeImageProxyDefinitionBuildItem`. An example of doing so is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非常相似的是，Quarkus允许扩展作者注册一个 `NativeImageProxyDefinitionBuildItem` 。这样做的一个例子是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Video podcast hosted by Quarkus Developers about things moving in and around Quarkus ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由Quarkus开发者主办的关于在Quarkus生态系统内和周边事物的视频播客。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying
a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define
a `LAMBDA_ROLE_ARN` environment variable in your profile or console window,  Alternatively, you can edit
the `manage.sh` script that is generated by the build and put the role value directly there:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查看使用AWS CLI部署lambda的 link:https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[入门指南] 。具体来说，确保你已经创建了一个 `Execution Role` 。你需要在你的配置文件或控制台窗口中定义一个 `LAMBDA_ROLE_ARN` 环境变量，或者，你可以编辑由构建生成的 `manage.sh` 脚本，并把角色值直接放在那里：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define a `LAMBDA_ROLE_ARN` environment variable in your profile or console window, Alternatively, you can edit the `manage.sh` script that is generated by the build and put the role value directly there:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查看使用AWS CLI部署lambda的 link:https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[入门指南] 。具体来说，确保你已经创建了一个 `Execution Role` 。你需要在你的配置文件或控制台窗口中定义一个 `LAMBDA_ROLE_ARN` 环境变量，或者，你可以编辑由构建生成的 `manage.sh` 脚本，并把角色值直接放在那里：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visual Studio Code extension to install using the marketplace</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Visual Studio Code插件市场安装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visualize and configure extensions as well as access to application logs and testing components</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可视化和配置扩展，以及访问应用程序日志和测试组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Want to have your extension added to the Quarkiverse?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>想让您的扩展功能加入到Quarkiverse中吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also handle some basic date type transformations: all fields of type `Date`, `LocalDate`, `LocalDateTime` or `Instant` will be mapped to the
link:https://docs.mongodb.com/manual/reference/bson-types/#date[BSON Date] using the `ISODate` type (UTC datetime).
The MongoDB POJO codec doesn't support `ZonedDateTime` and `OffsetDateTime` so you should convert them prior usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还处理一些基本的日期类型转换：所有类型为 `Date` , `LocalDate` , `LocalDateTime` 或 `Instant` 的字段都将使用 `ISODate` 类型（UTC日期时间）映射到 link:https://docs.mongodb.com/manual/reference/bson-types/#date[BSON Date] 。MongoDB的POJO编解码器不支持 `ZonedDateTime` 和 `OffsetDateTime` ，因此你应该在使用前转换它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also handle some basic date type transformations: all fields of type `Date`, `LocalDate`, `LocalDateTime` or `Instant` will be mapped to the link:https://docs.mongodb.com/manual/reference/bson-types/#date[BSON Date] using the `ISODate` type (UTC datetime).  The MongoDB POJO codec doesn't support `ZonedDateTime` and `OffsetDateTime` so you should convert them prior usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还处理一些基本的日期类型转换：所有类型为 `Date` , `LocalDate` , `LocalDateTime` 或 `Instant` 的字段都将使用 `ISODate` 类型（UTC日期时间）映射到 link:https://docs.mongodb.com/manual/reference/bson-types/#date[BSON Date] 。MongoDB的POJO编解码器不支持 `ZonedDateTime` 和 `OffsetDateTime` ，因此你应该在使用前转换它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the tests. Edit the `CountResourceTest` class to match:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，我们还需要更新测试。如下编辑 `CountResourceTest` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration
from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还设置了 `java.util.logging.manager` 系统属性，以确保测试使用正确的日志管理器。同时设置 `maven.home` 属性，以确保 `${maven.home}/conf/settings.xml` 的自定义配置被设置（如果有的话）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还设置了 `java.util.logging.manager` 系统属性，以确保测试使用正确的日志管理器。同时设置 `maven.home` 属性，以确保 `${maven.home}/conf/settings.xml` 的自定义配置被设置（如果有的话）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging` system property to make sure tests will use the correct log manager and `maven.home` to ensure that custom configuration
from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还设置了 `java.util.logging` 系统属性，以确保测试将使用正确的日志管理器和 `maven.home` ，以确保应用 `${maven.home}/conf/settings.xml` 的自定义配置（如果有的话）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging` system property to make sure tests will use the correct log manager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还设置了 `java.util.logging` 系统属性，以确保测试将使用正确的日志管理器和 `maven.home` ，以确保应用 `${maven.home}/conf/settings.xml` 的自定义配置（如果有的话）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also update the `ReactiveGreetingResource.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还要这样更新 `ReactiveGreetingResource.kt` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to build a simple application exposing four HTTP endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将构建一个简单应用程序 它包含四个暴露出的端点:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to create an `IncrementService` class which will play the role of a Redis client.
With this class, we'll be able to perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将创建一个 `IncrementService` 类，它将扮演Redis客户端的角色。这个类能够执行 `SET` , `GET` , `DELET` , `KEYS` 和 `INCRBY` 等Redis命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to create an `IncrementService` class which will play the role of a Redis client.  With this class, we'll be able to perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将创建一个 `IncrementService` 类，它将扮演Redis客户端的角色。这个类能够执行 `SET` , `GET` , `DELET` , `KEYS` 和 `INCRBY` 等Redis命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to model our increments using the `Increment` POJO.
Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将使用 `Increment` POJO来模拟递增操作。创建 `src/main/java/org/acme/redis/Increment.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to model our increments using the `Increment` POJO.  Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将使用 `Increment` POJO来模拟递增操作。创建 `src/main/java/org/acme/redis/Increment.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are including the public key as a resource in the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将公钥作为一种资源纳入本地可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are setting public key location to point to a classpath publicKey.pem location. We will add this key in part B, &lt;&lt;Adding a Public Key&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们设置公钥位置以指向classpath publicKey.pem所在位置。我们将在B部分中 &lt;&lt;添加公钥&gt;&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are setting the issuer to the URL string `https://example.com/issuer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将发行者issuer设置为URL字符串 `https://example.com/issuer` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using `curl -w "\n"` in this example to avoid your terminal printing a '%' or put both result and next command prompt on the same line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们在这个例子中使用 `curl -w "\n"` ，以避免你的终端打印出'%'或把结果和下一个命令提示符放在同一行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are verifying that we get the mocked response from the Spy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们正在验证从Spy那里得到了mock响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can also generate Server-Sent Event responses by returning a `Multi`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们也可以通过返回一个 `Multi` 来生成服务器发送的事件响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can register `Legume` for reflection manually by adding the `@RegisterForReflection` annotation on our `Legume` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们可以通过在我们的 `Legume` 类上添加 `@RegisterForReflection` 注解来手动注册 `Legume` 进行反射：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create the first increment, with the key `first` and an initial value of `10`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们创建第一个增量，键为 `first` ，初始值为 `10` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don't include the legacy MongoDB client by default. It contains the now retired MongoDB Java API (DB, DBCollection,... )
and the `com.mongodb.MongoClient` that is now superseded by `com.mongodb.client.MongoClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们默认不包括旧版的MongoDB客户端。它包含现已废弃的MongoDB Java API（DB、DBCollection......）以及现已被 `com.mongodb.client.MongoClient` 所取代的 `com.mongodb.MongoClient` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don't include the legacy MongoDB client by default. It contains the now retired MongoDB Java API (DB, DBCollection,... )  and the `com.mongodb.MongoClient` that is now superseded by `com.mongodb.client.MongoClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们默认不包括旧版的MongoDB客户端。它包含现已废弃的MongoDB Java API（DB、DBCollection......）以及现已被 `com.mongodb.client.MongoClient` 所取代的 `com.mongodb.MongoClient` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don’t want you to spend hours learning new technologies. Instead, the Quarkus programming model builds on top of proven standards. Be it official standards such as Eclipse MicroProfile or leading frameworks in a specific domain such as Eclipse Vert.x.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们不希望你花时间学习新技术。相反，Quarkus编程模型构建在经过验证的标准之上。无论是官方标准(如Eclipse MicroProfile)还是特定领域的领先框架(如Eclipse Vert.x)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We extend our previous tests as a convenience, but you can also implement your tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了方便起见，我们扩展了之前的测试，但您也可以实现您自己的测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We extend our previous tests, but you can also implement your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们扩展了之前的测试，但您也可以实现自己的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We get the expected JSON array.
RESTEasy Reactive automatically maps the list into a JSON Array, except if instructed otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们得到了预期的JSON数组。RESTEasy Reactive自动将列表映射到JSON数组，除非另有指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We get the expected JSON array.  RESTEasy Reactive automatically maps the list into a JSON Array, except if instructed otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们得到了预期的JSON数组。RESTEasy Reactive自动将列表映射到JSON数组，除非另有指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a lot of documentation. Be sure to check our &lt;a href="{{site.baseurl}}/get-started/"&gt;Getting started page&lt;/a&gt;, and all our &lt;a href="{{site.baseurl}}/guides/"&gt;guides&lt;/a&gt;. Also check out our &lt;a href="{{site.baseurl}}/faq/"&gt;FAQ section&lt;/a&gt; and &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips Playlist&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们有大量的文档。请务必查看我们的&lt;a href="{{site.baseurl}}/get-started/"&gt;入门页面&lt;/a&gt;，以及我们所有的&lt;a href="{{site.baseurl}}/guides/"&gt;指南&lt;/a&gt;。还可以查看我们的&lt;a href="{{site.baseurl}}/faq/"&gt;FAQ部分&lt;/a&gt;和&lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips 播放列表&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have not provided any JWT in our request, so we would not expect that there is any security state seen by the endpoint,
and the response is consistent with that:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们在请求中没有提供任何JWT，所以我们不会期望有任何安全状态被终端看到，而响应也与此一致：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have not provided any JWT in our request, so we would not expect that there is any security state seen by the endpoint, and
the response is consistent with that:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们在请求中没有提供任何JWT，所以我们不会期望有任何安全状态被终端看到，而响应也与此一致：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have not provided any JWT in our request, so we would not expect that there is any security state seen by the endpoint, and the response is consistent with that:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们在请求中没有提供任何JWT，所以我们不会期望有任何安全状态被终端看到，而响应也与此一致：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need a consumer listening on the `greeting` address.
This consumer can be in the same class or another bean such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要一个消费者监听 `greeting` 地址。这个消费者可以在同一个类中，也可以是另一个Bean，比如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need a consumer listening on the `greeting` address.  This consumer can be in the same class or another bean such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要一个消费者监听 `greeting` 地址。这个消费者可以在同一个类中，也可以是另一个Bean，比如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the HTTP connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要配置HTTP连接器。这是在 `application.properties` 文件中完成的。 键的结构如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to write the entity into the database in a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要在一个事务中把实体写进数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We open the file using the `open` method. It returns a `Uni&lt;AsyncFile&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用 `open` 方法打开该文件。它返回一个 `Uni&lt;AsyncFile&gt;` 类型的对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We pre-boot as many of the frameworks as possible during the native compilation of a Quarkus application. It means that the resulting native executable has already run most of the startup code and serialized the result into the executable: even faster startup!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus应用程序的原生编译过程中，我们尽可能多地对框架进行预启动。这意味着产生的原生可执行文件已经运行了大部分的启动代码，并将结果序列化到可执行文件中：启动速度更快！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the link:deploying-to-kubernetes[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议继续阅读 link:deploying-to-kubernetes[部署到Kubernetes和OpenShift]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the xref:deploying-to-kubernetes.adoc[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议继续阅读 xref:deploying-to-kubernetes.adoc[部署到Kubernetes和OpenShift]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions from &lt;&lt;bootstrapping-the-project,Bootstrapping project&gt;&gt; and onwards to create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照从 link:#bootstrapping-the-project[构建项目] 开始的指示，一步一步地创建应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the following sections and create the application step by step.
However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照下一节的说明逐步创建应用程序。然而，你也可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the following sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照下一节的说明逐步创建应用程序。然而，你也可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create applications step by step.
However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照下面章节中的说明，一步一步地创建应用程序。但是，你可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create applications step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照下面章节中的说明，一步一步地创建应用程序。但是，你可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the
application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step
by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照下面几节的说明逐步创建应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can skip right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地创建应用程序。不过，您可以直接跳到已完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.
You can skip right to the solution if you prefer. Either:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地创建应用程序。您也可以直接跳到解决方案。或者：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can skip right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地创建应用程序。不过，您可以直接跳到已完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  You can skip right to the solution if you prefer. Either:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地创建应用程序。您也可以直接跳到解决方案。或者：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地打包应用。不过您还可以直接进入完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend using the Mutiny variant as it integrates with the other reactive APIs provided by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们推荐使用Mutiny变体，因为它可以与Quarkus提供的其他响应式API集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We see that the value of the `first` key is now `37` which is exactly the result of `10 + 27`, quick maths.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们看到，现在 `first` 键的值是 `37` ，这正是 `10 + 27` 的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用 `installMockForInstance` 以取代注入的bean，它在整个测试方法的持续时间内生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could
just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as
this allows native image tests to also be run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用profile是因为，你很快就会看到，打包原生可执行文件需要 _few_ 分钟。你可以在命令行中把 -Dquarkus.package.type=native 作为一个属性，但是最好是使用一个profile，因为这可以使原生镜像测试也被运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as this allows native image tests to also be run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用profile是因为，你很快就会看到，打包原生可执行文件需要 _few_ 分钟。你可以在命令行中把 -Dquarkus.package.type=native 作为一个属性，但是最好是使用一个profile，因为这可以使原生镜像测试也被运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use constructor injection to receive the managed Vert.x instance. Field injection works too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用构造函数注入的方式来接收被管理的Vert.x实例。当然 字段注入也被允许。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use public fields here, but you can use private fields and getters/setters if you prefer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里我们使用public的字段，你也可以使用private字段和对应的getter/setter方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the Vert.x file system API to read the created file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用Vert.x文件系统API来读取创建的文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will create a simple test to ensure that this is being served correctly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将创建一个简单的测试以确保这个文件被正确的加载：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will use a `smallrye.jwt.sign.key.location` property to point to this private signing key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将使用一个 `smallrye.jwt.sign.key.location` 属性来指向这个私人签名钥匙。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll be using the Quarkus Redis Client extension to connect to our Redis Server. The extension is implemented on top of the https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis Client],
providing an asynchronous and non-blocking way to connect to Redis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将使用Quarkus Redis客户端扩展来连接到Redis服务。该扩展是在 link:https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis客户端] 的基础上实现的，提供了一种异步和非阻塞的方式来连接Redis服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll be using the Quarkus Redis Client extension to connect to our Redis Server. The extension is implemented on top of the https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis Client], providing an asynchronous and non-blocking way to connect to Redis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将使用Quarkus Redis客户端扩展来连接到Redis服务。该扩展是在 link:https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis客户端] 的基础上实现的，提供了一种异步和非阻塞的方式来连接Redis服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网络</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Web Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Web客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WebAuthn authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>WebAuthn认证机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Weekly Builds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每周构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What Makes Quarkus Different?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是什么让Quarkus与众不同？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么是扩展状态?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does having a working C developer environment mean?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拥有一个C语言工作开发者环境意味着什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does it mean to be a Kubernetes-native framework?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为一个Kubernetes原生框架意味着什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Quarkus?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is a Quarkus extension?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么是Quarkus扩展?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用什么许可证？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What to do when there is no initial offset in Kafka.Accepted values are earliest, latest and none

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka没有初始偏移量时的处理策略。可接受的值是earliest, latest 和 none

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What we mean by "Supersonic Subatomic Java".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"超音速亚原子Java"是什么意思。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What we're doing in Panache is allow you to write your Hibernate Reactive entities like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache允许这样编写Hibernate Reactive实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What we're doing in Panache is to allow you to write your Hibernate ORM entities like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache允许这样编写Hibernate ORM实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下一步做什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Kafka broker receives a record, its acknowledgement can take time depending on the configuration.
Also, it stores in-memory the records that cannot be written.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka broker收到一条记录时，它的确认可能需要时间，这取决于配置。此外，它还会在内存中存储不能写入的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Kafka broker receives a record, its acknowledgement can take time depending on the configuration.  Also, it stores in-memory the records that cannot be written.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka broker收到一条记录时，它的确认可能需要时间，这取决于配置。此外，它还会在内存中存储不能写入的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Quarkus was designed, we didn’t focus only on containers but also on deploying Quarkus applications on container orchestrators such as Kubernetes. Quarkus build-time processing also generates the Kubernetes metadata, so your application is ready to be deployed on Kubernetes. Runtime capabilities such as health checks and metrics are exposed out of the box. Quarkus collects all the required metadata at build time to create the Kubernetes deployment descriptor and produce a container image. A single command line can deploy your application onto your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在设计Quarkus时，我们不仅关注容器，还关注将Quarkus应用程序部署到容器协调器(如Kubernetes)上。Quarkus构建时处理还会生成Kubernetes元数据，这样就可以将应用程序部署到Kubernetes上了。运行时功能(如健康检查和指标)是开箱即用的。Quarkus在构建时收集所有必需的元数据，以创建Kubernetes部署描述符并生成容器镜像。一个命令行就可以将应用程序部署到Kubernetes集群上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `@QuarkusIntegrationTest` results in launching a container (because the application was built with `quarkus.container-image.build` set to `true`), the container is launched on a predictable container network. This facilitates writing integration tests that need to launch services to support the application.
This means that `@QuarkusIntegrationTest` works out of the box with containers launched via xref:dev-services.adoc[Dev Services], but it also means that it enables using &lt;&lt;quarkus-test-resource,QuarkusTestLifecycleManager&gt;&gt; resources that launch additional containers.
This can be achieved by having your `QuarkusTestLifecycleManager` implement `io.quarkus.test.common.DevServicesContext.ContextAware`. A simple example could be the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `@QuarkusIntegrationTest` 启动一个容器时（因为应用程序在构建时将 `quarkus.container-image.build` 设置为 `true` ），该容器会在一个可预测的容器网络上启动。这有利于编写需要启动服务以支持应用程序的集成测试。这意味着 `@QuarkusIntegrationTest` 能够与通过 link:dev-services.html[Dev Services] 启动的容器一起开箱即用，但这也意味着它能够使用 link:#quarkus-test-resource[QuarkusTestLifecycleManager] 资源来启动额外的容器。这可以通过让您的 `QuarkusTestLifecycleManager` 实现 `io.quarkus.test.common.DevServicesContext.ContextAware` 来获得。一个简单的例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `@QuarkusIntegrationTest` results in launching a container (because the application was built with `quarkus.container-image.build` set to `true`), the container is launched on a predictable container network. This facilitates writing integration tests that need to launch services to support the application.  This means that `@QuarkusIntegrationTest` works out of the box with containers launched via xref:dev-services.adoc[Dev Services], but it also means that it enables using &lt;&lt;quarkus-test-resource,QuarkusTestLifecycleManager&gt;&gt; resources that launch additional containers.  This can be achieved by having your `QuarkusTestLifecycleManager` implement `io.quarkus.test.common.DevServicesContext.ContextAware`. A simple example could be the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `@QuarkusIntegrationTest` 启动一个容器时（因为应用程序在构建时将 `quarkus.container-image.build` 设置为 `true` ），该容器会在一个可预测的容器网络上启动。这有利于编写需要启动服务以支持应用程序的集成测试。这意味着 `@QuarkusIntegrationTest` 能够与通过 link:dev-services.html[Dev Services] 启动的容器一起开箱即用，但这也意味着它能够使用 link:#quarkus-test-resource[QuarkusTestLifecycleManager] 资源来启动额外的容器。这可以通过让您的 `QuarkusTestLifecycleManager` 实现 `io.quarkus.test.common.DevServicesContext.ContextAware` 来获得。一个简单的例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `objcopy` is not available debug symbols are embedded in the executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当被嵌入到可执行文件中的 `objcopy` 调试符号不可用时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `partitions` is greater than 1, this attribute allows configuring how many records are requested by each consumers every time.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `partitions` 大于1时，这个属性配置每个消费者每次允许请求多少条记录。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-resteasy-reactive-jackson` or `quarkus-resteasy-reactive-jsonb`, Quarkus will use the `application/json` media type
by default for most return values, unless the media type is explicitly set via
`@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream`
respectively).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当安装了一个JSON扩展，如 `quarkus-resteasy-reactive-jackson` 或 `quarkus-resteasy-reactive-jsonb` ，Quarkus将对大多数返回值默认使用 `application/json` 媒体类型，除非通过 `@Produces` 或 `@Consumes` 注解明确设置媒体类型（对于众所周知的类型有一些例外，如 `String` 和 `File` ，它们分别默认为 `text/plain` 和 `application/octet-stream` ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-resteasy-reactive-jackson` or `quarkus-resteasy-reactive-jsonb`, Quarkus will use the `application/json` media type by default for most return values, unless the media type is explicitly set via `@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream` respectively).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当安装了一个JSON扩展，如 `quarkus-resteasy-reactive-jackson` 或 `quarkus-resteasy-reactive-jsonb` ，Quarkus将对大多数返回值默认使用 `application/json` 媒体类型，除非通过 `@Produces` 或 `@Consumes` 注解明确设置媒体类型（对于众所周知的类型有一些例外，如 `String` 和 `File` ，它们分别默认为 `text/plain` 和 `application/octet-stream` ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a Reactive Messaging Message associated with an AMQP Message is acknowledged, it informs the broker that the message has been http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[accepted].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当与AMQP消息关联的响应式消息被确认时，它会通知代理该消息已被 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[接受] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a deserialization failure occurs, you can intercept it and provide a failure strategy.
To achieve this, you need to create a bean implementing `DeserializationFailureHandler&lt;T&gt;` interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当反序列化失败发生时，您可以对其进行拦截并提供一个失败处理策略。为了实现这一点，您需要创建一个实现 `DeserializationFailureHandler&lt;T&gt;` 接口的bean：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a deserialization failure occurs, you can intercept it and provide a failure strategy.  To achieve this, you need to create a bean implementing `DeserializationFailureHandler&lt;T&gt;` interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当反序列化失败发生时，您可以对其进行拦截并提供一个失败处理策略。为了实现这一点，您需要创建一个实现 `DeserializationFailureHandler&lt;T&gt;` 接口的bean：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a message produced from a Kafka record is acknowledged, the connector invokes a commit strategy.
These strategies decide when the consumer offset for a specific topic/partition is committed.
Committing an offset indicates that all previous records have been processed.
It is also the position where the application would restart the processing after a crash recovery or a restart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当一条由Kafka记录产生的消息被确认时，connector将会调用一个提交策略。这些策略决定了特定topic/分区(topic/partition)的消费者偏移将在何时被提交。提交一个偏移量(offset)表明所有之前的记录已经被处理了。它也是应用程序从崩溃中恢复后或重启后重新开始处理的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a message produced from a Kafka record is acknowledged, the connector invokes a commit strategy.  These strategies decide when the consumer offset for a specific topic/partition is committed.  Committing an offset indicates that all previous records have been processed.  It is also the position where the application would restart the processing after a crash recovery or a restart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当一条由Kafka记录产生的消息被确认时，connector将会调用一个提交策略。这些策略决定了特定topic/分区(topic/partition)的消费者偏移将在何时被提交。提交一个偏移量(offset)表明所有之前的记录已经被处理了。它也是应用程序从崩溃中恢复后或重启后重新开始处理的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When adding `kotlin` to the extensions list, the Maven plugin will generate a project that is properly
configured to work with Kotlin. Furthermore  the `org.acme.ReactiveGreetingResource` class is implemented as Kotlin source code (as is the case with the generated tests).
The addition of `resteasy-reactive-jackson` in the extension list results in importing the RESTEasy Reactive and Jackson extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `kotlin` 添加到扩展列表后，Maven插件将生成一个经过正确配置的项目，以便与Kotlin一起工作。此外， `org.acme.ReactiveGreetingResource` 类会通过kotlin代码来进行实现（与生成的测试一样）。在扩展列表中添加 `resteasy-reactive-jackson` ，就会导入RESTEasy Reactive和Jackson扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building a native executable, GraalVM operates with a closed world assumption.
It analyzes the call tree and removes all the classes/methods/fields that are not used directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在构建本地可执行文件时，GraalVM以封闭世界的假设进行操作。它分析调用树并删除所有不直接使用的类/方法/字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building a native executable, GraalVM operates with a closed world assumption.  It analyzes the call tree and removes all the classes/methods/fields that are not used directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在构建本地可执行文件时，GraalVM以封闭世界的假设进行操作。它分析调用树并删除所有不直接使用的类/方法/字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When consuming messages with `@Channel`, the application code is responsible for the subscription.
In the example above, the RESTEasy Reactive endpoint handles that for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `@Channel` 消费消息时，代码需要负责消息订阅。在上面的例子中，RESTEasy Reactive endpoint 已负责为您处理了这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When consuming messages with `@Channel`, the application code is responsible for the subscription.  In the example above, the RESTEasy Reactive endpoint handles that for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `@Channel` 消费消息时，代码需要负责消息订阅。在上面的例子中，RESTEasy Reactive endpoint 已负责为您处理了这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When creating a custom `QuarkusTestResourceLifecycleManager` that needs to inject the something into the test class, the `inject` methods can be used.
If for example you have a test like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当创建一个自定义的 `QuarkusTestResourceLifecycleManager` 来将某些资源注入到测试类时，可以使用 `inject` 方法。例如，如果您有一个像下面这样的测试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When creating a custom `QuarkusTestResourceLifecycleManager` that needs to inject the something into the test class, the `inject` methods can be used.  If for example you have a test like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当创建一个自定义的 `QuarkusTestResourceLifecycleManager` 来将某些资源注入到测试类时，可以使用 `inject` 方法。例如，如果您有一个像下面这样的测试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When executing an HTTP GET request against `http://localhost:8080/hello`, you see a JSON message with the value `hello` as its `message` field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当执行一个对 `http://localhost:8080/hello`  的HTTP GET请求时，您会看到一个JSON消息，其 `message` 字段的值是 `hello` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it comes to writing Hibernate ORM entities, there are a number of annoying things that users have grown used to
reluctantly deal with, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写Hibernate ORM实体类时，用户已经习惯了被迫处理许多烦人的事情，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it comes to writing Hibernate ORM entities, there are a number of annoying things that users have grown used to reluctantly deal with, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写Hibernate ORM实体类时，用户已经习惯了被迫处理许多烦人的事情，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it comes to writing Hibernate Reactive entities, there are a number of annoying things that users have grown used to
reluctantly deal with, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写Hibernate Reactive实体类时，用户已经习惯了被迫处理许多烦人的事情，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it comes to writing Hibernate Reactive entities, there are a number of annoying things that users have grown used to reluctantly deal with, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写Hibernate Reactive实体类时，用户已经习惯了被迫处理许多烦人的事情，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it comes to writing MongoDB entities, there are a number of annoying things that users have grown used to
reluctantly deal with, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写MongoDB实体时，用户已经习惯了不情愿地处理许多烦人的事情，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it comes to writing MongoDB entities, there are a number of annoying things that users have grown used to reluctantly deal with, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写MongoDB实体时，用户已经习惯了不情愿地处理许多烦人的事情，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes or packages need to be specified via the `quarkus.native.additional-build-args` configuration property, the `,` symbol needs to be escaped.
An example of this is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当需要通过 `quarkus.native.additional-build-args` 配置属性指定多个类或包时，需要对 `,` 符号进行转义。这方面的一个例子如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes or packages need to be specified via the `quarkus.native.additional-build-args` configuration property, the `,` symbol needs to be escaped.  An example of this is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当需要通过 `quarkus.native.additional-build-args` 配置属性指定多个类或包时，需要对 `,` 符号进行转义。这方面的一个例子如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When no deserialization failure handler is set and a deserialization failure happens, report the failure and mark the application as unhealthy. If set to `false` and a deserialization failure happens, a `null` value is forwarded.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当没有设置反序列化失败处理程序而反序列化失败发生时，报告该失败并将应用程序标记为不健康。如果设置为 `false` 并且发生了反序列化失败，会发送一个 `null` 。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When not running in dev or test mode, you will need to start your AMQP broker.
You can follow the instructions from the https://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Apache ActiveMQ Artemis website] or create a `docker-compose.yaml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当不在开发或测试模式下运行时，你需要启动你的AMQP代理。你可以按照 link:https://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Apache ActiveMQ Artemis网站]中的说明，或者使用以下内容创建一个 `docker-compose.yaml` 文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When not running in dev or test mode, you will need to start your AMQP broker.  You can follow the instructions from the https://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Apache ActiveMQ Artemis website] or create a `docker-compose.yaml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当不在开发或测试模式下运行时，你需要启动你的AMQP代理。你可以按照 link:https://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Apache ActiveMQ Artemis网站]中的说明，或者使用以下内容创建一个 `docker-compose.yaml` 文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When processing a request requires interacting with a remote service, like an HTTP API or a database, it does not block the execution while waiting for the response.
Instead, it schedules the I/O operation and attaches a continuation, i.e., the request processing remaining code.
This continuation can be passed as a callback (a function invoked with the I/O outcome), or use more advanced constructs such as reactive programming or co-routines.
Regardless of how the continuation is expressed, the essential aspect is the release of the I/O thread and, as a consequence, the fact that this thread can be used to process another request.
When the scheduled I/O completes, the I/O thread executes the continuation, and the processing of the pending request continues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当处理请求需要与远程服务(如HTTP API或数据库)交互时，它不会在等待响应时阻塞执行。相反，它调度I/O操作并附加一个延续，即请求处理剩余的代码。这种延续可以作为回调传递 (与I/O结果一起调用的函数)，或者使用更高级的结构，诸如响应式编程或协同程序。不管延续是如何表示的，最基本的方面是释放I/O线程，因此，这个线程可以用来处理另一个请求。当计划的I/O完成时，I/O线程执行延续，并继续处理挂起的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When processing a request requires interacting with a remote service, like an HTTP API or a database, it does not block the execution while waiting for the response.  Instead, it schedules the I/O operation and attaches a continuation, i.e., the request processing remaining code.  This continuation can be passed as a callback (a function invoked with the I/O outcome), or use more advanced constructs such as reactive programming or co-routines.  Regardless of how the continuation is expressed, the essential aspect is the release of the I/O thread and, as a consequence, the fact that this thread can be used to process another request.  When the scheduled I/O completes, the I/O thread executes the continuation, and the processing of the pending request continues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当处理请求需要与远程服务(如HTTP API或数据库)交互时，它不会在等待响应时阻塞执行。相反，它调度I/O操作并附加一个延续，即请求处理剩余的代码。这种延续可以作为回调传递 (与I/O结果一起调用的函数)，或者使用更高级的结构，诸如响应式编程或协同程序。不管延续是如何表示的，最基本的方面是释放I/O线程，因此，这个线程可以用来处理另一个请求。当计划的I/O完成时，I/O线程执行延续，并继续处理挂起的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When processing messages, you can propagate incoming record key to the outgoing record.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在处理信息时，您可以将传入的记录键发送给传出的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in appropriately configured Kubernetes clusters, Kafka extension will pull its Kafka broker connection configuration from the service binding available inside the cluster, without the need for user configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当在正确配置的Kubernetes集群中运行时，Kafka扩展将从集群内部可用的服务绑定中获取Kafka broker连接配置，而不需要用户来配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running tests this way, the only things that actually run natively are you application endpoints, which
you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code
that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当以这种方式运行测试时，唯一真正在本地运行的是你的应用程序端点，你只能通过HTTP调用来测试。你的测试代码实际上并不在本地运行，所以如果你测试的代码不调用你的HTTP端点，把它们作为本地测试的一部分运行可能不是一个好主意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running tests this way, the only things that actually run natively are you application endpoints, which you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当以这种方式运行测试时，唯一真正在本地运行的是你的应用程序端点，你只能通过HTTP调用来测试。你的测试代码实际上并不在本地运行，所以如果你测试的代码不调用你的HTTP端点，把它们作为本地测试的一部分运行可能不是一个好主意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running the production version of the application, the MongoDB connection need to be configured as normal, so if you want to include a production database config in your
`application.properties` and continue to use Dev Services we recommend that you use the `%prod.` profile to define your MongoDB settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当运行应用程序的生产版本时，MongoDB连接需要正常配置，如果您希望在 `application.properties` 中包含生产数据库配置并继续使用开发服务，我们建议你使用 `%prod.` 配置文件来定义你的MongoDB设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running the production version of the application, the MongoDB connection need to be configured as normal, so if you want to include a production database config in your `application.properties` and continue to use Dev Services we recommend that you use the `%prod.` profile to define your MongoDB settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当运行应用程序的生产版本时，MongoDB连接需要正常配置，如果您希望在 `application.properties` 中包含生产数据库配置并继续使用开发服务，我们建议你使用 `%prod.` 配置文件来定义你的MongoDB设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running the production version of the application, the Redis connection need to be configured as normal,
so if you want to include a production database config in your `application.properties` and continue to use Dev Services
we recommend that you use the `%prod.` profile to define your Redis settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行应用程序的生产版本需要正常配置Redis连接，所以如果你想在 `application.properties` 中定义生产的数据库配置，同时继续使用Dev Services，我们建议你使用 `%prod.` profile来定义你的Redis设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running the production version of the application, the Redis connection need to be configured as normal, so if you want to include a production database config in your `application.properties` and continue to use Dev Services we recommend that you use the `%prod.` profile to define your Redis settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行应用程序的生产版本需要正常配置Redis连接，所以如果你想在 `application.properties` 中定义生产的数据库配置，同时继续使用Dev Services，我们建议你使用 `%prod.` profile来定义你的Redis设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending `Messages`, you can add an instance of `OutgoingAmqpMetadata` to influence how the message is going to be sent to AMQP.
For example, you can configure the subjects, properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当发送 `Messages` 时，你可以添加一个 `OutgoingAmqpMetadata` 的实例来影响消息是如何被发送到AMQP的。例如，你可以配置主题、属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending `Messages`, you can add an instance of `OutgoingAmqpMetadata` to influence how the message is going to be sent to AMQP.  For example, you can configure the subjects, properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当发送 `Messages` 时，你可以添加一个 `OutgoingAmqpMetadata` 的实例来影响消息是如何被发送到AMQP的。例如，你可以配置主题、属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending a `Message&lt;T&gt;`, the connector converts the message into an AMQP Message.
The payload is converted to the AMQP Message _body_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当发送一个 `Message&lt;T&gt;` 时，连接器将消息转换为AMQP消息。有效载荷被转换为AMQP消息 _body_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending a `Message&lt;T&gt;`, the connector converts the message into an AMQP Message.  The payload is converted to the AMQP Message _body_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当发送一个 `Message&lt;T&gt;` 时，连接器将消息转换为AMQP消息。有效载荷被转换为AMQP消息 _body_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When should you use a Gauge? Only if you can't use something else. Never gauge something you can count. Gauges can be
less straight-forward to use than counters. If what you are measuring can be counted (because the value always
increments), use a counter instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么时候应该使用Gauge？只有在您无法使用其他测量值的时候。不要对您可以计算的东西使用gauge。Gauges的使用可能没有counters那么直白。如果您要测量的东西可以计数（因为数值总是递增的），就用counter代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When should you use a Gauge? Only if you can't use something else. Never gauge something you can count. Gauges can be less straight-forward to use than counters. If what you are measuring can be counted (because the value always increments), use a counter instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么时候应该使用Gauge？只有在您无法使用其他测量值的时候。不要对您可以计算的东西使用gauge。Gauges的使用可能没有counters那么直白。如果您要测量的东西可以计数（因为数值总是递增的），就用counter代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When should you use a counter? Only if you are doing something that can not be either timed (or summarized).
Counters only record a count, which may be all that is needed. However, if you want to understand more about how a
value is changing, a timer (when the base unit of measurement is time) or a distribution summary might be
more appropriate.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么什么时候使用counter呢？只有当您正在做的事情不能被计时(timed）（或总结summarized）的时候。counter只记录一个计数值，而这个值可能就是所需的全部。但是，如果您想更多地了解一个值是如何变化的，那么timer（当基本的测量单位是时间时）或distribution summary可能更合适。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When should you use a counter? Only if you are doing something that can not be either timed (or summarized).  Counters only record a count, which may be all that is needed. However, if you want to understand more about how a value is changing, a timer (when the base unit of measurement is time) or a distribution summary might be more appropriate.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么什么时候使用counter呢？只有当您正在做的事情不能被计时(timed）（或总结summarized）的时候。counter只记录一个计数值，而这个值可能就是所需的全部。但是，如果您想更多地了解一个值是如何变化的，那么timer（当基本的测量单位是时间时）或distribution summary可能更合适。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When testing Quarkus security, ensure that  your `IdentityProvider` is already set with usernames, passwords, and roles in `application.properties`.
For more information about testing Quarkus Security, see xref:security-testing.adoc#configuring-user-information[Configuring user information].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当测试Quarkus Security的时候，请确保您已经在 `application.properties` 设置了 `IdentityProvider` 以及对应的用户名、密码以及角色。请参见 link:security-testing.html#configuring-user-information[设置用户信息] 以了解更多关于测试Quarkus Security的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When testing Quarkus security, ensure that your `IdentityProvider` is already set with usernames, passwords, and roles in `application.properties`.  For more information about testing Quarkus Security, see xref:security-testing.adoc#configuring-user-information[Configuring user information].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当测试Quarkus Security的时候，请确保您已经在 `application.properties` 设置了 `IdentityProvider` 以及对应的用户名、密码以及角色。请参见 link:security-testing.html#configuring-user-information[设置用户信息] 以了解更多关于测试Quarkus Security的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the Kafka producer receives an error from the server, if it is a transient, recoverable error, the client will retry sending the batch of messages.
This behavior is controlled by `retries` and `retry.backoff.ms` parameters.
In addition to this, SmallRye Reactive Messaging will retry individual messages on recoverable errors, depending on the `retries` and `delivery.timeout.ms` parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka生产者收到来自服务器的错误时，如果它是一个暂时的、可恢复的错误，那么客户端将重试发送这批消息。这种行为是由 `retries` 和 `retry.backoff.ms` 参数控制的。除此之外，SmallRye Reactive Messaging还会在可恢复的错误中重试单个消息，这取决于 `retries` 和 `delivery.timeout.ms` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the Kafka producer receives an error from the server, if it is a transient, recoverable error, the client will retry sending the batch of messages.  This behavior is controlled by `retries` and `retry.backoff.ms` parameters.  In addition to this, SmallRye Reactive Messaging will retry individual messages on recoverable errors, depending on the `retries` and `delivery.timeout.ms` parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka生产者收到来自服务器的错误时，如果它是一个暂时的、可恢复的错误，那么客户端将重试发送这批消息。这种行为是由 `retries` 和 `retry.backoff.ms` 参数控制的。除此之外，SmallRye Reactive Messaging还会在可恢复的错误中重试单个消息，这取决于 `retries` 和 `delivery.timeout.ms` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates on which topic the record is sent. Defaults is `dead-letter-topic-$channel`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `failure-strategy` 被设置为 `dead-letter-queue` ，用来指明记录会发送到哪个主题的。默认值是 `dead-letter-topic-$channel` 

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates the key serializer to use. If not set the serializer associated to the key deserializer is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `failure-strategy` 被设置为 `dead-letter-queue` 时，表示要使用的键值的序列化器。如果没有设置则使用与键值反序列化器相关的序列化器

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates the value serializer to use. If not set the serializer associated to the value deserializer is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `failure-strategy` 被设置为 `dead-letter-queue` ，表示要使用的值的序列化器。如果没有设置，则使用与值反序列化器相关的序列化器n

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the file is opened, we retrieve a `Multi` which will contain the chunks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当文件被打开时，我们获得到一个 `Multi` ，它包含了块的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当测试停止时，清除 `InMemoryConnector` (丢弃所有接收和发送的信息)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When topics/partitions are assigned or revoked from a consumer, it pauses the message delivery and resumes once the rebalance completes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当topic/分区被从消费者那里分配或撤销时，它会暂停消息传递， 然后在重平衡完成后立即恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Flyway together with Hibernate ORM, you can use the Dev UI to generate the initial schema creation script.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Flyway与Hibernate ORM一起使用时，你可以使用Dev UI来生成初始表创建脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Kotlin data classes with `native-image` you may experience serialization errors that do not occur with the `JVM` version, despite the Kotlin Jackson Module being registered. This is especially so if you have a more complex JSON hierarchy, where an issue on a lower node causes a serialization failure. The error message displayed is a catch-all and typically displays an issue with the root object, which may not necessarily be the case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用Kotlin数据类与 `native-image`  时，尽管Kotlin Jackson模块已被注册，但您可能会遇到JVM版本中不会出现的序列化错误。特别是如果您有一个更复杂的JSON层次结构，低层节点上的问题导致序列化失败。显示的错误消息是一条全面的错误消息，其通常会显示根对象引发了这个问题，但情况可能并非如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Kubernetes, it is recommended to set the client id and secret in a Kubernetes secret:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用Kubernetes时，建议在Kubernetes secret中设置客户端ID和secret：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Maven, we could use the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Maven时，我们可以使用以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Panache, things are simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache时，事情很简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080`
as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will
be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用Quarkus开发模式时，只需对 `http://localhost:8080` 调用HTTP请求，就像通常测试REST端点时所做的那样。这个请求将访问模拟事件服务器，并将被转换为API Gateway json消息，被Quarkus Lambda Poll循环所消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用Quarkus开发模式时，只需对 `http://localhost:8080` 调用HTTP请求，就像通常测试REST端点时所做的那样。这个请求将访问模拟事件服务器，并将被转换为API Gateway json消息，被Quarkus Lambda Poll循环所消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.
You can override this setting with the `quarkus.http.test-timeout` property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当在您的测试中使用REST Assured时，连接和响应超时默认设置为30秒。可以通过 `quarkus.http.test-timeout` 属性覆盖该设置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.  You can override this setting with the `quarkus.http.test-timeout` property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当在您的测试中使用REST Assured时，连接和响应超时默认设置为30秒。可以通过 `quarkus.http.test-timeout` 属性覆盖该设置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides _startup_, _liveness_ and _readiness_ checks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用响应式消息传递和Kafka 连接器时，每个配置的 channel (传入或传出)都会提供 _启动_ 、 _活跃度(liveness)_ 和 _就绪_ 检查。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you can get the exact same convenient methods as wit the active record pattern, injected in your Repository,
by making them implements `PanacheMongoRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 Repositories 时，你可以得到与主动记录模式完全相同的方便方法，注入到你的 Repository 中，通过使它们实现 `PanacheMongoRepository` 接口 ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you can get the exact same convenient methods as wit the active record pattern, injected in your Repository, by making them implements `PanacheMongoRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 Repositories 时，你可以得到与主动记录模式完全相同的方便方法，注入到你的 Repository 中，通过使它们实现 `PanacheMongoRepository` 接口 ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository,
by making them implement `PanacheMongoRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 Repositories 时，你可以得到与活动记录模式完全相同的方便方法，注入到你的 Repository 中，通过它们实现 `PanacheMongoRepository` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository,
by making them implements `PanacheRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Repository 模式时，通过实现 `PanacheRepository` 接口，你可以使用与Active Record模式下完全相同的便捷方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository, by making them implement `PanacheMongoRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 Repositories 时，你可以得到与活动记录模式完全相同的方便方法，注入到你的 Repository 中，通过它们实现 `PanacheMongoRepository` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository, by making them implements `PanacheRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Repository 模式时，通过实现 `PanacheRepository` 接口，你可以使用与Active Record模式下完全相同的便捷方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using SmallRye Reactive Messaging with Kafka (`io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), Quarkus can often automatically detect the correct serializer and deserializer class.
This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用SmallRye Reactive Messaging with Kafka ( `io.quarkus:quarkus-smallrye-reactive-messaging-kafka` )时，Quarkus通常可以自动检测可用的序列化器和反序列化器类。这种自动检测是基于 `@Incoming` 和 `@Outgoing` 方法的声明，以及注入的 `@Channel` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using SmallRye Reactive Messaging with Kafka (`io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), Quarkus can often automatically detect the correct serializer and deserializer class.  This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用SmallRye Reactive Messaging with Kafka ( `io.quarkus:quarkus-smallrye-reactive-messaging-kafka` )时，Quarkus通常可以自动检测可用的序列化器和反序列化器类。这种自动检测是基于 `@Incoming` 和 `@Outgoing` 方法的声明，以及注入的 `@Channel` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@ApplicationScoped`, you will get a single instance for your verticle.
Having multiple instances of verticles can be helpful to share the load among them.
Each of them will be associated with a different I/O thread (Vert.x event loop).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `@ApplicationScoped` ，你将为你的verticle获得一个实例。拥有多个verticles的实例可以帮助他们分担负载。它们中的每一个都将与不同的I/O线程相关联（Vert.x事件循环）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@ApplicationScoped`, you will get a single instance for your verticle.  Having multiple instances of verticles can be helpful to share the load among them.  Each of them will be associated with a different I/O thread (Vert.x event loop).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `@ApplicationScoped` ，你将为你的verticle获得一个实例。拥有多个verticles的实例可以帮助他们分担负载。它们中的每一个都将与不同的I/O线程相关联（Vert.x事件循环）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@Blocking`, it ignores the value of the `blocking` attribute of `@ConsumeEvent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `@Blocking` ，它忽略了 `blocking` 属性的值 `@ConsumeEvent` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `ObjectId`, MongoDB will automatically provide a value for you, but if you use a custom field type,
you need to provide the value by yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `ObjectId` ，MongoDB会自动为你提供一个值，但如果你使用一个自定义字段类型，你需要自己提供一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `ObjectId`, MongoDB will automatically provide a value for you, but if you use a custom field type, you need to provide the value by yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `ObjectId` ，MongoDB会自动为你提供一个值，但如果你使用一个自定义字段类型，你需要自己提供一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).
However, as a container may not use the same _executable_ format as the one produced by your operating system,
we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in &lt;&lt;#container-runtime,this section&gt;&gt;):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用本地GraalVM安装时，原生可执行文件的目标是您的本地操作系统（Linux、macOS、Windows等）。然而，由于容器可能不使用与操作系统相同的 _executable_ 格式，我们将指示Maven构建通过利用容器运行时（ 如 &lt;&lt;#container-runtime,this section&gt;&gt; 所述）来生成可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).  However, as a container may not use the same _executable_ format as the one produced by your operating system, we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in &lt;&lt;#container-runtime,this section&gt;&gt;):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用本地GraalVM安装时，原生可执行文件的目标是您的本地操作系统（Linux、macOS、Windows等）。然而，由于容器可能不使用与操作系统相同的 _executable_ 格式，我们将指示Maven构建通过利用容器运行时（ 如 &lt;&lt;#container-runtime,this section&gt;&gt; 所述）来生成可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using exactly-once processing, consumed message offset commits are handled by the transaction and therefore the application should not commit offsets through other means.
The consumer should have `enable.auto.commit=false` (the default) and set explicitly `commit-strategy=ignore`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用（exactly-once）精确一次处理时，消耗的消息偏移量提交由事务处理，因此应用程序不应通过其他方式提交偏移量。 消费者应该有 `enable.auto.commit=false` （默认）并明确设置 `commit-strategy=ignore` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using exactly-once processing, consumed message offset commits are handled by the transaction and therefore the application should not commit offsets through other means.  The consumer should have `enable.auto.commit=false` (the default) and set explicitly `commit-strategy=ignore`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用（exactly-once）精确一次处理时，消耗的消息偏移量提交由事务处理，因此应用程序不应通过其他方式提交偏移量。 消费者应该有 `enable.auto.commit=false` （默认）并明确设置 `commit-strategy=ignore` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, each `MongoClient`, you can select the client to inject using the `io.quarkus.mongodb.MongoClientName` qualifier.
Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用多个客户端时，每个 `MongoClient` ，你可以使用 `io.quarkus.mongodb.MongoClientName` 修饰语选择要注入的客户端。使用上述属性来配置三个不同的客户端，你也可以按以下方式来注入每个客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, each `MongoClient`, you can select the client to inject using the `io.quarkus.mongodb.MongoClientName` qualifier.  Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用多个客户端时，每个 `MongoClient` ，你可以使用 `io.quarkus.mongodb.MongoClientName` 修饰语选择要注入的客户端。使用上述属性来配置三个不同的客户端，你也可以按以下方式来注入每个客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, you can select the client to inject using the `io.quarkus.redis.client.RedisClientName` qualifier.
Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用多个客户端时，可以使用 `io.quarkus.redis.client.RedisClientName` 注解，来选择要注入的客户端。使用上述属性来配置三个不同的客户端后，可以按以下方式来注入每个客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, you can select the client to inject using the `io.quarkus.redis.client.RedisClientName` qualifier.  Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用多个客户端时，可以使用 `io.quarkus.redis.client.RedisClientName` 注解，来选择要注入的客户端。使用上述属性来配置三个不同的客户端后，可以按以下方式来注入每个客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native executables with GraalVM, all classes that will be used with reflection need to be registered.
The good news is that Quarkus does that work for you most of the time.
So far, we haven't registered any class, not even `Fruit`, for reflection usage and everything is working fine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用GraalVM的本地可执行文件时，需要注册所有将与反射一起使用的类。好消息是，Quarkus在大多数时候都会为你做这项工作。到目前为止，我们还没有注册任何类，甚至没有注册 `Fruit` ，并且一切正常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native executables with GraalVM, all classes that will be used with reflection need to be registered.  The good news is that Quarkus does that work for you most of the time.  So far, we haven't registered any class, not even `Fruit`, for reflection usage and everything is working fine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用GraalVM的本地可执行文件时，需要注册所有将与反射一起使用的类。好消息是，Quarkus在大多数时候都会为你做这项工作。到目前为止，我们还没有注册任何类，甚至没有注册 `Fruit` ，并且一切正常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native-image, the use of http (or https) protocol(s) must be declared</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用native-image时，必须声明使用http（或https）协议</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the SmallRye Reactive Messaging extension for Kafka,
we are able to propagate the span into the Kafka Record with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 SmallRye Reactive Messaging  的 Kafka 扩展时，我们可以向Kafka记录中传播span，通过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the SmallRye Reactive Messaging extension for Kafka, we are able to propagate the span into the Kafka Record with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 SmallRye Reactive Messaging  的 Kafka 扩展时，我们可以向Kafka记录中传播span，通过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the `quarkus-kafka-client` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.
This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).
It requires an _admin connection_ with the Kafka broker, and it is disabled by default.
If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `quarkus-kafka-client` 扩展时，您可以通过在您的 `application.properties` 配置文件中将 `quarkus.kafka.health.enabled` 属性设置为 `true` 来启用 _就绪_ 健康检查。该检查会报告与 _默认的_ Kafka Broker(使用 `kafka.bootstrap.servers` 配置)的交互状态。它需要一个与Kafka Broker的 _管理员连接_ ，并且默认是禁用的。如果启用，当您访问您应用程序的 `/q/health/ready` 节点时，您将获得关于连接验证状态的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the `quarkus-kafka-client` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  It requires an _admin connection_ with the Kafka broker, and it is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `quarkus-kafka-client` 扩展时，您可以通过在您的 `application.properties` 配置文件中将 `quarkus.kafka.health.enabled` 属性设置为 `true` 来启用 _就绪_ 健康检查。该检查会报告与 _默认的_ Kafka Broker(使用 `kafka.bootstrap.servers` 配置)的交互状态。它需要一个与Kafka Broker的 _管理员连接_ ，并且默认是禁用的。如果启用，当您访问您应用程序的 `/q/health/ready` 节点时，您将获得关于连接验证状态的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the repository pattern, you can define your entities as regular JPA entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Repository模式时，可以将实体类定义为普通的JPA实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the repository pattern, you can define your entities as regular POJO.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用存储库模式时，你可以将你的实体定义为普通的POJO。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When working with the `quarkus-kubernetes` extension and have Kotlin classes bound to CustomResource definitions (like you do for building operators), you need to be aware that the underlying Fabric8 Kubernetes Client uses its own static Jackson `ObjectMapper` s, which can be configured as follows with the `KotlinModule`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `quarkus-kubernetes` 扩展并让Kotlin类绑定到CustomResource定义时（就像您在构建operator时一样），您需要注意底层的Fabric8 Kubernetes客户端使用它自己的静态Jackson `ObjectMapper` 对象，您可以这样为其配置 `KotlinModule` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have multiple connectors, you would need to indicate which connector you want to use in the application configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你有多个连接器时，你需要在应用程序配置中指出你想要使用哪个连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is
forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP
request that can be consumed by any HTTP framework Quarkus supports (JAX-RS, servlet, Reactive Routes).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你在API网关上调用一个HTTP请求时，网关会把这个HTTP请求转换成一个JSON事件文档，并转发给Quarkus Lambda。Quarkus Lambda解析这个json，并将其转换为HTTP请求的内部表示，这样它就可以被Quarkus支持的任何HTTP框架（JAX-RS、servlet、Reactive Routes）所消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (JAX-RS, servlet, Reactive Routes).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你在API网关上调用一个HTTP请求时，网关会把这个HTTP请求转换成一个JSON事件文档，并转发给Quarkus Lambda。Quarkus Lambda解析这个json，并将其转换为HTTP请求的内部表示，这样它就可以被Quarkus支持的任何HTTP框架（JAX-RS、servlet、Reactive Routes）所消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now execute an HTTP GET request against `http://localhost:8080/hello`, you should see a JSON message with the value `hi` as its `message` field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当您现在执行一个对 `http://localhost:8080/hello` 的HTTP GET请求时，您应该会看到一个JSON消息，其 `message` 字段的值是 `hi` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use query parameters, be careful that PanacheQL queries will refer to the Object parameters name but native queries will refer to MongoDB field names.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你使用查询参数时，要注意PanacheQL查询将参考Object参数名称，但本地查询将参考MongoDB字段名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you're done playing with the `dev` mode" you can run it as a standard Java application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当您尝试完毕 `开发` 模式后，您可以把它作为一个标准的Java应用程序运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我在哪儿能获得到?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether AMQP subscription is durable

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP订阅是否是durable

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether OpenTelemetry is enabled or not. The default is `true`, but shown here to indicate how it can be disabled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry是否已启用。默认是 `true` ，但放在这里是用来展示如何禁用它</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether health reporting is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>健康报告是否被启用（默认启用）或禁用

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not a graceful shutdown should be attempted when the application terminates.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当应用程序终止时，是否应该尝试平滑关闭。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not the connection to the broker is re-attempted in case of failure

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在失败的情况下，是否重新尝试与broker的连接

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not the connector should insert automatically the `time` attribute into the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `time` attribute itself

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器是否应将 `time` 属性自动添加到发出的云事件中。要求 `cloud-events` 被设置为 `true` 。如果消息本身没有配置 `time` 属性，则使用此值

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether readiness health reporting is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否启用（默认启用）或禁用就绪情况报告

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether sent AMQP messages are marked durable

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送的AMQP消息是否被标记为durable

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the AMQP connection uses SSL/TLS

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQP连接是否使用了SSL/TLS

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the Kafka records are consumed in batch. The channel injection point must consume a compatible type, such as `List&lt;Payload&gt;` or `KafkaRecordBatch&lt;Payload&gt;`.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否启用Kafka记录的批处理。通道的注入点必须消费一个兼容的类型，例如 `List&lt;Payload&gt;` 或 `KafkaRecordBatch&lt;Payload&gt;`.

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the Kafka records should be dispatched to multiple consumer

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka记录是否会被派发给多个消费者

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the client waits for Kafka to acknowledge the written record before acknowledging the message

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在确认消息之前，客户端是否会等待Kafka确认写入的记录

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the connector should allow multiple upstreams

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器是否可以允许多个上游(upstream)

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the connector should insert automatically the `time` attribute into the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `time` attribute itself

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器是否应将 `time` 属性自动插入到传出的云事件中。要求将 `cloud-events` 设为 `true` 。如果消息本身没有配置 `time` 属性，则使用此值

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the connector should use an anonymous sender. Default value is `true` if the broker supports it, `false` otherwise. If not supported, it is not possible to dynamically change the destination address.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器是否应使用匿名发送者。如果代理支持，则默认值为 `true` ，否则为 `false` 。如果不支持，则无法动态更改目的地地址。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the polling must be paused when the application does not request items and resume when it does. This allows implementing back-pressure based on the application capacity. Note that polling is not stopped, but will not retrieve any records when paused.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当应用程序不请求记录时，轮询是否必须被暂停，或应用程序开始请求记录时轮询是否要恢复。该属性允许实现基于应用容量的背压。需要注意轮询不会停止，但当暂停时不会获取任何记录。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the received AMQP messages must be acknowledged when received

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>收到的AMQP消息是否必须在收到时被确认
类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the received AMQP messages must be dispatched to multiple _subscribers_

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>收到的AMQP消息是否必须派发给多个 _subscribers_ 

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the startup and readiness check should verify that topics exist on the broker. Default to false. Enabling it requires an admin client connection.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动和就绪检查是否要验证broker上存在主题。默认为false。启用它需要一个管理员客户端连接。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether tracing is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否启用（默认启用）或禁用tracing

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Oracle GraalVM is available for both Java 8 and Java 11 (Mandrel only supports Java 11), Quarkus only works with the Java 11 version.  If you use the Oracle distribution, make sure to install the Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Oracle GraalVM在Java 8和Java 11上都可以使用(Mandrel只支持Java 11)，而Quarkus只支持Java 11版本。如果您使用Oracle发行版，请确保安装Java 11版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run
tests while having the application running in parallel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然Quarkus默认会监听端口 `8080` ，但当运行测试时，它会默认设为 `8081` 。这允许您在运行测试的同时让应用程序并行运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run tests while having the application running in parallel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然Quarkus默认会监听端口 `8080` ，但当运行测试时，它会默认设为 `8081` 。这允许您在运行测试的同时让应用程序并行运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While a normal message emitter would support concurrent calls to `send` methods and consequently queues outgoing messages to be written to Kafka,
a `KafkaTransactions` emitter only supports one transaction at a time.
A transaction is considered in progress from the call to the `withTransaction` until the returned `Uni` results in success or failure.
While a transaction is in progress, subsequent calls to the `withTransaction`, including nested ones inside the given function, will throw `IllegalStateException`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然普通的消息emitter支持并发调用 `send` 方法并将要写入 Kafka 的传出消息顺序排队，但 `KafkaTransactions` emitter每次只支持一个事务。 从调用 `withTransaction` 直到返回的 `Uni` 导致成功或失败，事务被视为正在进行中。 当事务正在进行时，对 `withTransaction` 的后续调用，包括给定函数内的嵌套调用，都将抛出 `IllegalStateException` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While a normal message emitter would support concurrent calls to `send` methods and consequently queues outgoing messages to be written to Kafka, a `KafkaTransactions` emitter only supports one transaction at a time.  A transaction is considered in progress from the call to the `withTransaction` until the returned `Uni` results in success or failure.  While a transaction is in progress, subsequent calls to the `withTransaction`, including nested ones inside the given function, will throw `IllegalStateException`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然普通的消息emitter支持并发调用 `send` 方法并将要写入 Kafka 的传出消息顺序排队，但 `KafkaTransactions` emitter每次只支持一个事务。 从调用 `withTransaction` 直到返回的 `Uni` 导致成功或失败，事务被视为正在进行中。 当事务正在进行时，对 `withTransaction` 的后续调用，包括给定函数内的嵌套调用，都将抛出 `IllegalStateException` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has
         to run tests in a custom classloader which JUnit is not aware of.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然可以使用JUnit Jupiter回调接口，如 `BeforeEachCallback` ，但您可能会遇到类加载问题，因为Quarkus必须在一个JUnit无法感知的自定义类加载器中运行测试。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然可以使用_traditional_ RESTEasy，但需要添加 `quarkus-resteasy-mutiny` 扩展，该方法仍然会在 _worker_ 线程上调用。因此，虽然它将使用响应式编程，但仍然需要工作线程，这与目的不符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While named "reactive", RESTEasy Reactive supports equally well both traditional blocking patterns and reactive patterns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然名为 "响应式"，但RESTEasy Reactive同样支持传统的阻塞模式和响应式模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While running in Quarkus Dev Mode, you can feed events to it by doing an HTTP POST to `http://localhost:8080`.
The mock event server will receive the events and your lambda will be invoked.  You can perform live coding on your lambda
and changes will automatically be recompiled and available the next invocation you make.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当在Quarkus开发模式下运行时，你可以对  `&lt;a href="http://localhost:8080" class="bare"&gt;http://localhost:8080&lt;/a&gt;`  执行HTTP POST来向它提供事件。模拟事件服务器将接收事件，你的lambda将被调用。你可以在你的lambda上执行实时编码，所做的修改将自动被重新编译，并在下次调用时可用。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While running in Quarkus Dev Mode, you can feed events to it by doing an HTTP POST to `http://localhost:8080`.  The mock event server will receive the events and your lambda will be invoked.  You can perform live coding on your lambda and changes will automatically be recompiled and available the next invocation you make.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当在Quarkus开发模式下运行时，你可以对  `&lt;a href="http://localhost:8080" class="bare"&gt;http://localhost:8080&lt;/a&gt;`  执行HTTP POST来向它提供事件。模拟事件服务器将接收事件，你的lambda将被调用。你可以在你的lambda上执行实时编码，所做的修改将自动被重新编译，并在下次调用时可用。下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While users are encouraged to use xref:scheduler.adoc#standard-scheduling[regular Quarkus scheduler], Quarkus provides a compatibility layer for Spring Scheduled in the form of the `spring-scheduled` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励用户使用 link:scheduler.html#standard-scheduling[常规 Quarkus调度器] ，但Quarkus以 `spring-scheduled` 扩展的形式为Spring Scheduled提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While using the `throttled` commit-strategy, specify the max age in milliseconds that an unprocessed message can be before the connector is marked as unhealthy. Setting this attribute to 0 disables this monitoring.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在使用 `throttled` 提交策略时，指定未处理的消息在连接器被标记为不健康之前的可存续的最大时间（毫秒）。将此属性设置为0可以禁用该监控。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While we recommend you to follow the step-by-step instructions, you can find the final solution on https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-reactive-panache-quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们建议您按照步骤操作，但您可以在 https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-reactive-panache-quickstart上找到最终的解决方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While writing native application you'll need to define proxy classes at image build time by specifying the list of interfaces that they implement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写本地应用程序时，你需要在图像构建时通过指定它们实现的接口列表来定义代理类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the spring-di extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用CDI注解进行注入，但Quarkus以spring-di扩展的形式为Spring依赖注入提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use Hibernate ORM with Panache for your data layer, Quarkus provides a compatibility layer for Spring Data JPA in the form of the spring-data-jpa extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Hibernate ORM与Panache作为你的数据层，但Quarkus以spring-data-jpa扩展的形式为Spring Data JPA提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use JAX-RS annotations for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the spring-web extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用JAX-RS注解来定义REST端点，但Quarkus以spring-web扩展的形式为Spring Web提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Cache extension for your application-level caching, Quarkus provides a compatibility layer for Spring Cache in the form of the spring-cache extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Cache扩展来进行应用级缓存，但Quarkus以spring-cache扩展的形式为Spring Cache提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Quarkus security layer to secure your applications, Quarkus provides a compatibility layer for Spring Security in the form of the spring-security extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Quarkus安全层来保护你的应用程序，但Quarkus以spring-security扩展的形式为Spring Security提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Scheduler or Quartz extensions to schedule tasks, Quarkus provides a compatibility layer for Spring Scheduled in the form of the spring-scheduled extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Scheduler或Quartz扩展来安排任务，但Quarkus以spring-scheduled扩展的形式为Spring Scheduled提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are in your build file, add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的构建文件中，添加以下依赖项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you can use the Vert.x API to register consumers, Quarkus comes with declarative support.
To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然你可以使用Vert.x的API来注册消费者，但Quarkus带有声明性支持。要消费事件，请使用 `io.quarkus.vertx.ConsumeEvent` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you can use the Vert.x API to register consumers, Quarkus comes with declarative support.  To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然你可以使用Vert.x的API来注册消费者，但Quarkus带有声明性支持。要消费事件，请使用 `io.quarkus.vertx.ConsumeEvent` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why always having a transaction manager?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为什么总是有一个事务处理器？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why do you prefer JTA vs Hibernate's transaction management API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为什么相对Hibernate 的事务管理 API你更推荐JTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为什么要遵循这个过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will the Quarkus team accept my extension?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus团队会接受我的扩展吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wiremock</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Wiremock</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With &lt;a href="https://code.quarkus.io/"&gt;code.quarkus.io&lt;/a&gt;, in a few clicks, you can bootstrap your Quarkus application and discover its extension ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 &lt;a href="https://code.quarkus.io/"&gt;code.quarkus.io&lt;/a&gt;链接, 只需几次单击就可以引导您的Quarkus应用程序并发现其扩展生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Funqy, a function is just:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy函数就像是这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With JSON serialization correctly configured, you can also use `Publisher&lt;Fruit&gt;` and `Emitter&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在正确配置了JSON序列化后，您也可以使用 `Publisher&lt;Fruit&gt;` 和 `Emitter&lt;Fruit&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Panache, the &lt;code&gt;Element&lt;/code&gt; class would be as simple as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了Panache，&lt;code&gt;Element&lt;/code&gt;类就会像这样简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Panache, we took an opinionated approach to tackle all these problems:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过Panache，我们采取了一种有主见的方法来解决所有这些问题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API]
or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (JAX-RS),
Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过Quarkus，您可以使用 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] 或 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API] 将您喜欢的Java HTTP框架部署为Amazon Lambda。这意味着你可以将用RESTEasy Reactive（JAX-RS）、Undertow（servlet）、Reactive Routes、 link:funqy-http.html[Funqy HTTP] 或任何其他Quarkus HTTP框架编写的微服务部署为AWS Lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过Quarkus，您可以使用 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] 或 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API] 将您喜欢的Java HTTP框架部署为Amazon Lambda。这意味着你可以将用RESTEasy Reactive（JAX-RS）、Undertow（servlet）、Reactive Routes、 link:funqy-http.html[Funqy HTTP] 或任何其他Quarkus HTTP框架编写的微服务部署为AWS Lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance
of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus，不需要创建一个 `Application` 类。它支持这么做，但不是必须的。此外，只有一个资源的实例被创建，而不是每个请求一个。你可以使用不同的 `*Scoped` 注解（ `ApplicationScoped` , `RequestScoped` , 等等）来配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus，不需要创建一个 `Application` 类。它支持这么做，但不是必须的。此外，只有一个资源的实例被创建，而不是每个请求一个。你可以使用不同的 `*Scoped` 注解（ `ApplicationScoped` , `RequestScoped` , 等等）来配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, you can easily configure a datasource, or several if need be.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus，你可以很容易地配置一个数据源，如果需要的话，也可以配置若干个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With `quarkus.flyway.migrate-at-start=true`, as in the example
above, Quarkus will execute the Flyway migration as part of the
xref:lifecycle.adoc[application startup].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上例所述，通过设置 `quarkus.flyway.migrate-at-start=true` Quarkus将在 xref:lifecycle.adoc[应用启动] 的时候通过Flyway进行迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With `quarkus.flyway.migrate-at-start=true`, as in the example above, Quarkus will execute the Flyway migration as part of the xref:lifecycle.adoc[application startup].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上例所述，通过设置 `quarkus.flyway.migrate-at-start=true` Quarkus将在 xref:lifecycle.adoc[应用启动] 的时候通过Flyway进行迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With in-memory channels we were able to test application code processing messages without starting a Kafka broker.
Note that different in-memory channels are independent, and switching channel connector to in-memory does not simulate message delivery between channels configured to the same Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了内存 channels ，我们就可以测试应用程序代码的消息方法，而无需启动Kafka broker。请注意，不同的内存 channel 是独立的，将 channel 连接器切换到内存中并不能模拟配置到同一Kafka topic的 channel 之间的消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With in-memory channels we were able to test application code processing messages without starting a Kafka broker.  Note that different in-memory channels are independent, and switching channel connector to in-memory does not simulate message delivery between channels configured to the same Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了内存 channels ，我们就可以测试应用程序代码的消息方法，而无需启动Kafka broker。请注意，不同的内存 channel 是独立的，将 channel 连接器切换到内存中并不能模拟配置到同一Kafka topic的 channel 之间的消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With injected JWT parser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注入的JWT Parser</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With minimal integration, it is possible to leverage the AWS Java SDK v2,
which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过最小的整合，可以利用AWS Java SDK v2，其可以用来调用诸如SQS、SNS、S3和DynamoDB等服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With minimal integration, it is possible to leverage the AWS Java SDK v2, which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过最小的整合，可以利用AWS Java SDK v2，其可以用来调用诸如SQS、SNS、S3和DynamoDB等服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the OpenTelemetry Collector, Jaeger system and application running, you can make a request to the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在OpenTelemetry Collector、Jaeger系统和应用程序运行的情况下，您可以向指定的节点发出请求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the `Emitter` API, you can also encapsulate the outgoing payload inside `Message&lt;T&gt;`. As with the previous examples, `Message` lets you handle the ack/nack cases differently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `Emitter` API，您也可以将要发送的payload封装在 `Message&lt;T&gt;` 中 。与前面的例子一样， `Message` 让您以不同的方式处理确认/拒绝(ack/nack)的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the active record pattern: put all your entity logic in static methods in your entity class and don't create DAOs.
Your entity superclass comes with lots of super useful static methods, and you can add your own in your entity class.
Users can just start using your entity `Person` by typing `Person.` and getting completion for all the operations in a single place.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用活动记录模式：把你所有的实体逻辑放在实体类的静态方法中，不要创建DAO。你的实体超类带有很多超级有用的静态方法，你也可以在你的实体类中添加你自己的静态方法。用户可以通过输入 `Person.` ，开始使用你的实体 `Person` ，并在一个地方获得所有操作的完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the active record pattern: put all your entity logic in static methods in your entity class and don't create DAOs.  Your entity superclass comes with lots of super useful static methods, and you can add your own in your entity class.  Users can just start using your entity `Person` by typing `Person.` and getting completion for all the operations in a single place.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用活动记录模式：把你所有的实体逻辑放在实体类的静态方法中，不要创建DAO。你的实体超类带有很多超级有用的静态方法，你也可以在你的实体类中添加你自己的静态方法。用户可以通过输入 `Person.` ，开始使用你的实体 `Person` ，并在一个地方获得所有操作的完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the aforementioned example in your `application.properties`, your Hibernate ORM managed database will be populated with test
data both during the JVM mode test run and during the native mode test run. The production
executable will contain only the `version.txt` resource, no superfluous test data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面提到的 `application.properties` 例子中。在JVM模式测试运行期间和原生模式测试运行期间，Hibernate ORM管理的数据库将填充测试数据。生产可执行文件将只包含 `version.txt` 资源，没有多余的测试数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the aforementioned example in your `application.properties`, your Hibernate ORM managed database will be populated with test data both during the JVM mode test run and during the native mode test run. The production executable will contain only the `version.txt` resource, no superfluous test data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面提到的 `application.properties` 例子中。在JVM模式测试运行期间和原生模式测试运行期间，Hibernate ORM管理的数据库将填充测试数据。生产可执行文件将只包含 `version.txt` 资源，没有多余的测试数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the event bus, you send _messages_ to _virtual addresses_.
The event bus offers three types of delivery mechanisms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过事件总线，你可以向 _virtual addresses_ 发送 _messages_。事件总线提供三种类型的传递机制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the event bus, you send _messages_ to _virtual addresses_.  The event bus offers three types of delivery mechanisms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过事件总线，你可以向 _virtual addresses_ 发送 _messages_。事件总线提供三种类型的传递机制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With these changes in place the `/hello` endpoint will reply with a JSON object instead of a simple String.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>经过这些更改， `/hello` 端点将用一个JSON对象而不是一个简单的字符串来响应请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this extension, you can retrieve the managed instance of Vert.x using either field or constructor injection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过这个扩展，你可以使用字段或构造函数注入检索Vert.x的托管实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this in mind, let's see how we can develop a CRUD application with Quarkus, which will use the I/O thread to handle the HTTP requests, interact with a database, process the result, and write the HTTP response; in other words: a reactive CRUD application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>考虑到这一点，让我们看看如何使用Quarkus开发一个CRUD应用程序，它将使用I/O线程处理HTTP请求，与数据库交互，处理结果，并编写HTTP响应，换句话说：一个响应式CRUD应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this in place, every HTTP request on `/bus/quarkus` sends a message to the event bus, waits for a reply, and when this one arrives, writes the HTTP response:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了这个， `/bus/quarkus` 上的每个HTTP请求都会向事件总线发送一个消息，等待回复，当这个回复到来时，就会写入HTTP响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, we can start implementing the endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了这些，我们就可以开始实现端点了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without configuration, Flyway is set up for every datasource using the default settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在没有配置的情况下，Flyway对每个数据源都是使用默认设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wizards w/code.quarkus.io</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>向导 code.quarkus.io</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with HashiCorp Vault’s Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与HashiCorp Vault的认证合作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with Kotlin Data classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kotlin Data classes工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module project or external modules</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与多模块项目或外部模块一起工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Works with Quarkus 1.1.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>适用于 Quarkus 1.1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡演</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour - Abstracts and Support materials.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡回-摘要和支持材料。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour - Sound Check... Getting Started with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡回-试音…从Quarkus开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour 2021</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年世界巡演</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour 2021 - Abstracts and Support materials.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年世界巡演-摘要和支持材料。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour 2021 - Sound Check... Getting Started with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年世界巡演-试音…从Quarkus开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write Acknowledgement</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写确认</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write New Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写新的扩展程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write QuickStart Guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写快速入门指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing JSON REST Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写JSON REST服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Native Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写原生应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing REST JSON Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST JSON服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing REST Services Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST服务参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple CRUD Applications with Spring Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Spring Data编写简单的CRUD应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple REST CRUD Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写简单的REST CRUD服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Your Own Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写您自己的扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a Codestart for an extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为扩展编写Codestart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a JAX-RS resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写一个JAX-RS资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a Profile</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写Profile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a blog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写博客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing entities managed by Hibernate Reactive to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Hibernate Reactive管理的实体写入Kafka中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing entities managed by Hibernate to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Hibernate管理的实体写入Kafka中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing to Kafka from an HTTP endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从HTTP节点写消息到Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wrong. +
First off, just disable the transaction by marking your transaction boundary with `@Transactional(NOT_SUPPORTED)` (or `NEVER` or `SUPPORTS` depending on the semantic you want). +
Second, it's again fairy tale that not using transaction is faster.
The answer is, it depends on your DB and how many SQL SELECTs you are making.
No transaction means the DB does have a single operation transaction context anyways. +
Third, when you do several SELECTs, it's better to wrap them in a single transaction because they will all be consistent with one another.
Say your DB represents your car dashboard, you can see the number of kilometers remaining and the fuel gauge level.
By reading it in one transaction, they will be consistent.
If you read one and the other from two different transactions, then they can be inconsistent.
It can be more dramatic if you read data related to rights and access management for example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>错误。 + 首先，只要用 `@Transactional(NOT_SUPPORTED)` （或 `NEVER` 或 `SUPPORTS` ，取决于你想要的语义）标记你的事务边界，就可以禁用事务。 + 其次，不使用事务会更快，这又是另一个故事。答案是，这取决于你的数据库和你正在进行的SQL SELECT的数量。不使用事务意味着无论如何，数据库确实有一个单一的操作事务环境。 + 第三，当你做几个SELECT时，最好把它们包在一个事务中，因为它们都会保持一致性。假设你的数据库代表你的汽车仪表盘，你可以看到剩余的公里数和油表水平。通过在一个事务中读取它，它们将是一致的。如果你从两个不同的事务中读取一个和另一个，那么它们可能是不一致的。再例如，如果你读取与权限和访问管理有关的数据，结果可能会更加戏剧化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wrong. + First off, just disable the transaction by marking your transaction boundary with `@Transactional(NOT_SUPPORTED)` (or `NEVER` or `SUPPORTS` depending on the semantic you want). + Second, it's again fairy tale that not using transaction is faster.  The answer is, it depends on your DB and how many SQL SELECTs you are making.  No transaction means the DB does have a single operation transaction context anyways. + Third, when you do several SELECTs, it's better to wrap them in a single transaction because they will all be consistent with one another.  Say your DB represents your car dashboard, you can see the number of kilometers remaining and the fuel gauge level.  By reading it in one transaction, they will be consistent.  If you read one and the other from two different transactions, then they can be inconsistent.  It can be more dramatic if you read data related to rights and access management for example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>错误。 + 首先，只要用 `@Transactional(NOT_SUPPORTED)` （或 `NEVER` 或 `SUPPORTS` ，取决于你想要的语义）标记你的事务边界，就可以禁用事务。 + 其次，不使用事务会更快，这又是另一个故事。答案是，这取决于你的数据库和你正在进行的SQL SELECT的数量。不使用事务意味着无论如何，数据库确实有一个单一的操作事务环境。 + 第三，当你做几个SELECT时，最好把它们包在一个事务中，因为它们都会保持一致性。假设你的数据库代表你的汽车仪表盘，你可以看到剩余的公里数和油表水平。通过在一个事务中读取它，它们将是一致的。如果你从两个不同的事务中读取一个和另一个，那么它们可能是不一致的。再例如，如果你读取与权限和访问管理有关的数据，结果可能会更加戏剧化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XCode provides the required dependencies on macOS:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>XCode在macOS上提供了必要的依赖性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YAML Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YAML `null` keys are not included in the assembly of the configuration property name, allowing them to be used
in any level for disambiguating configuration keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML `null` 键不被包含在配置属性名称的程序集中，允许在任意级别使用它们来消除配置键的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YAML `null` keys are not included in the assembly of the configuration property name, allowing them to be used in any level for disambiguating configuration keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML `null` 键不被包含在配置属性名称的程序集中，允许在任意级别使用它们来消除配置键的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YAML as a Configuration Source.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML 作为配置源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yep, it works in your Quarkus application, in your IDE, in your tests, because all of these are Quarkus applications.
JTA has some bad press for some people.
I don't know why.
Let's just say that this is not your grandpa's JTA implementation.
What we have is perfectly embeddable and lean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是的，它在你的Quarkus应用程序中，在你的IDE中，在你的测试中都可以使用，因为这些都是Quarkus应用程序。JTA对一些人来说有一些不好的影响。我不知道为什么。我们只能说，这不是老旧的JTA实现。我们所拥有的是完美的可嵌入的和精简的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yep, it works in your Quarkus application, in your IDE, in your tests, because all of these are Quarkus applications.  JTA has some bad press for some people.  I don't know why.  Let's just say that this is not your grandpa's JTA implementation.  What we have is perfectly embeddable and lean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是的，它在你的Quarkus应用程序中，在你的IDE中，在你的测试中都可以使用，因为这些都是Quarkus应用程序。JTA对一些人来说有一些不好的影响。我不知道为什么。我们只能说，这不是老旧的JTA实现。我们所拥有的是完美的可嵌入的和精简的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, we consider Quarkus stable. Remember 95% of the features Quarkus apps use are provided by the ecosystem like Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy, etc. These libraries are rock solid :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是的，我们认为Quarkus是稳定的。请记住，Quarkus应用程序使用的95%的特性都是由Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy等生态系统提供的。这些库是坚如磐石的 :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can `create` your function using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用以下命令 `创建` 你的函数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add a https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] cookie property to any of the cookies set by a Quarkus endpoint.
For more information, see xref:http-reference.adoc#same-site-cookie[SameSite cookies].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在Quarkus终端设置的任何cookie中添加 link:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] cookie属性的信息，请参见 link:http-reference.html#same-site-cookie[SameSite] 以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add a https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] cookie property to any of the cookies set by a Quarkus endpoint.  For more information, see xref:http-reference.adoc#same-site-cookie[SameSite cookies].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在Quarkus终端设置的任何cookie中添加 link:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] cookie属性的信息，请参见 link:http-reference.html#same-site-cookie[SameSite] 以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add attributes by setting the `resource-attributes` tracer config that is described in the &lt;&lt;configuration-reference&gt;&gt;.
Since this property can be overridden at runtime, the OpenTelemetry extension will pick up its value following the order of precedence that
is described in the xref:config-reference.adoc#configuration_sources[Quarkus Configuration Reference].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过设置 link:#configuration-reference[[参考设置]] 中的 `resource-attributes` tracer 配置来添加属性。由于这个属性可以在运行时被覆盖，OpenTelemetry扩展将按照 link:config-reference.html#configuration_sources[Quarkus参考配置] 中描述的优先顺序来获取其值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add attributes by setting the `resource-attributes` tracer config that is described in the &lt;&lt;configuration-reference&gt;&gt;.  Since this property can be overridden at runtime, the OpenTelemetry extension will pick up its value following the order of precedence that is described in the xref:config-reference.adoc#configuration_sources[Quarkus Configuration Reference].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过设置 link:#configuration-reference[[参考设置]] 中的 `resource-attributes` tracer 配置来添加属性。由于这个属性可以在运行时被覆盖，OpenTelemetry扩展将按照 link:config-reference.html#configuration_sources[Quarkus参考配置] 中描述的优先顺序来获取其值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add the `smallrye-reactive-messaging-kafka` extensions to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过在您的项目根目录下运行以下命令来将 `smallrye-reactive-messaging-kafka` 扩展添加到您的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add the extension to your project using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用以下方法将扩展添加到你的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also build the native executable using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以用以下方法构建原生(native)可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您还可以在 http://smallrye.io/smallrye-reactive-utils/apidocs/ 上查看可用的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以使用 `createFrom().publisher(Publisher)` 从 `Publisher` 的实例中创建 `Unis` 和 `Multis` 。你可以使用 `toMulti` 将 `Uni` 转换为 `Publisher` 。事实上， `Multi` 实现了 `Publisher`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create a native executable from this application without making any
source code changes. A native executable removes the dependency on the JVM:
everything needed to run the application on the target platform is included in
the executable, allowing the application to run with minimal resource overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>无需对源代码做任何修改，就可以将应用程序构建为一个本地可执行文件。本地可执行文件消除了对JVM的依赖，它包含了在目标平台上运行应用程序所需的一切，使应用程序能够以最小的资源开销运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create a native executable from this application without making any source code changes. A native executable removes the dependency on the JVM: everything needed to run the application on the target platform is included in the executable, allowing the application to run with minimal resource overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>无需对源代码做任何修改，就可以将应用程序构建为一个本地可执行文件。本地可执行文件消除了对JVM的依赖，它包含了在目标平台上运行应用程序所需的一切，使应用程序能够以最小的资源开销运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also generate the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以通过以下命令生成本地可执行文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also get the Kafka configuration injected to your application and create Kafka producer, consumer and admin clients directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以把Kafka配置注入到您的应用程序中来直接创建Kafka生产者，消费者以及管理客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also just add the following dependency into your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以直接将以下依赖添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also package the application in a container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>还可以将应用程序打包在容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#consumerconfigs[Kafka consumer].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以传递底层 link:https://kafka.apache.org/documentation/#consumerconfigs[Kafka消费者] 支持的任何属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#producerconfigs[Kafka producer].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以传递底层 link:https://kafka.apache.org/documentation/#producerconfigs[Kafka生产者] 支持的任何属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also programmatically ask for a transaction to be marked for rollback.
Inject a `TransactionManager` for this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以使用编程方式要求一个事务被标记为回滚。为此需要注入 `TransactionManager` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also programmatically ask for a transaction to be marked for rollback.  Inject a `TransactionManager` for this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以使用编程方式要求一个事务被标记为回滚。为此需要注入 `TransactionManager` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide duration values starting with a number.
In this case, if the value consists only of a number, the converter treats the value as seconds.
Otherwise, `PT` is implicitly prepended to the value to obtain a standard `java.time.Duration` format.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您还可以提供以数字开头的持续时间值。 在这种情况下，如果该值仅包含一个数字，则转换器将该值视为秒。 否则，`PT` 会隐式添加到值的前面，以获得标准的`java.time.Duration` 格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide duration values starting with a number.  In this case, if the value consists only of a number, the converter treats the value as seconds.  Otherwise, `PT` is implicitly prepended to the value to obtain a standard `java.time.Duration` format.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您还可以提供以数字开头的持续时间值。 在这种情况下，如果该值仅包含一个数字，则转换器将该值视为秒。 否则，`PT` 会隐式添加到值的前面，以获得标准的 `java.time.Duration` 格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also remove the limit of in-flight messages by setting `max-inflight-messages` to `0`.
However, note that the Kafka producer may block if the number of requests reaches `max.in.flight.requests.per.connection`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以通过将 `max-inflight-messages` 设置为 `0` 来取消in-flight消息的限制。但请注意，如果请求数量达到 `max.in.flight.requests.per.connection` 指定的值，Kafka生产者可能会阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also remove the limit of in-flight messages by setting `max-inflight-messages` to `0`.  However, note that the Kafka producer may block if the number of requests reaches `max.in.flight.requests.per.connection`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以通过将 `max-inflight-messages` 设置为 `0` 来取消in-flight消息的限制。但请注意，如果请求数量达到 `max.in.flight.requests.per.connection` 指定的值，Kafka生产者可能会阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also return a `Uni&lt;T&gt;` or a `CompletionStage&lt;T&gt;` to handle asynchronous reply:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以返回一个 `Uni&lt;T&gt;` 或一个 `CompletionStage&lt;T&gt;` 来处理异步回复：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run the test from your IDE directly (be sure you stopped the application first).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以直接从你的IDE中运行测试（要确保你先停止了应用程序）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into Reactor types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以将 `Unis` 和 `Multis` 转换为 Reactor 类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into RxJava types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以将 `Unis` 和 `Multis` 转换成 RxJava 类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use a local inlined public key for testing your `quarkus-oidc` `service` applications:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以使用一个本地内嵌的公钥来测试你的 `quarkus-oidc` `service` 应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use it to customize the way the token is verified or decrypted. For example, one can supply a local `SecretKey`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以用它来定制令牌的验证或解密方式。例如，可以提供一个本地 `SecretKey` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also write your queries in plain
link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以用普通的 link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL] 编写查询语句：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also write your queries in plain link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以用普通的 link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL] 编写查询语句：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can apply asynchronous stream processing by consuming and returning reactive stream `Multi&lt;T&gt;` type:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过消费和返回响应式流 `Multi&lt;T&gt;` 类型来应用异步流处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用常用命令构建本机可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用以下命令构建本机可执行文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can combine Reactive Messaging with https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance], and retry processing if it failed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以将Reactive Messaging与 link:https://github.com/smallrye/smallrye-fault-tolerance[SmallRye 容错]结合起来，如果失败的话可以进行重试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the AMQP address using the `address` attribute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `address` 属性配置AMQP地址：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Dev Services for Kafka to create topics once the broker is started.
Topics are created with given number of partitions and 1 replica.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以配置Kafka开发服务来在broker启动后创建主题。主题以给定的分区数量以及1个副本创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Dev Services for Kafka to create topics once the broker is started.  Topics are created with given number of partitions and 1 replica.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以配置Kafka开发服务来在broker启动后创建主题。主题以给定的分区数量以及1个副本创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Vert.x instance from the `application.properties` file.
The following table lists the supported properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以从 `application.properties` 文件中配置Vert.x实例。下表列出了支持的属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Vert.x instance from the `application.properties` file.  The following table lists the supported properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以从 `application.properties` 文件中配置Vert.x实例。下表列出了支持的属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the `bootstrap.servers` for each channel using `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` property.
Default is `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` 属性为每个 channel 配置 `bootstrap.servers` 。默认是 `kafka.bootstrap.servers` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the `bootstrap.servers` for each channel using `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` property.  Default is `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` 属性为每个 channel 配置 `bootstrap.servers` 。默认是 `kafka.bootstrap.servers` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the default transaction timeout, the timeout that applies to all transactions managed by the transaction manager, via the property `quarkus.transaction-manager.default-transaction-timeout`, specified as a duration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过属性 `quarkus.transaction-manager.default-transaction-timeout` 来配置默认的事务超时，即适用于由事务管理器管理的所有事务的超时，指定为一个持续时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the delay, the number of retries, the jitter, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以对延迟，重试次数以及抖动(jitter)等处理方式进行设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过 `quarkus.http.test-port` 和 `quarkus.http.test-ssl-port` 来配置用于HTTP和HTTPS测试的端口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure timeout for Kafka admin client calls used in topic creation using `quarkus.kafka.devservices.topic-partitions-timeout`, it defaults to 2 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过 `quarkus.kafka.devservices.topic-partitions-timeout` 来配置在主题创建中所使用的Kafka管理员客户端调用的超时时间，默认为2秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can control whether and how the transaction is started with parameters on `@Transactional`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过 `@Transactional` 上的参数来控制是否以及如何启动事务：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can customize the underlying client configuration by producing an instance of `AmqpClientOptions` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过产生一个 `AmqpClientOptions` 的实例来定制底层的客户端配置，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your entity as regular POJO.
You can add the `@MongoEntity` annotation to your entity if you need to customize the name of the collection, the database, or the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以将你的实体定义为普通的POJO。如果你需要自定义集合、数据库或客户端的名称，你可以给你的实体添加 `@MongoEntity` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your entity as regular POJO.  You can add the `@MongoEntity` annotation to your entity if you need to customize the name of the collection, the database, or the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以将你的实体定义为普通的POJO。如果你需要自定义集合、数据库或客户端的名称，你可以给你的实体添加 `@MongoEntity` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy _verticles_ in Quarkus.
It supports:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在Quarkus中部署 _verticles_ 。它支持：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy _verticles_ in Quarkus.  It supports:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在Quarkus中部署 _verticles_ 。它支持：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller
memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以将你的Lambda部署为一个纯Java jar，或者你可以将你的项目编译为一个原生镜像，并以较少的内存占用和启动时间来部署。我们的集成还可以生成SAM部署文件，这些文件可以被 link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[亚马逊的SAM框架] 来使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以将你的Lambda部署为一个纯Java jar，或者你可以将你的项目编译为一个原生镜像，并以较少的内存占用和启动时间来部署。我们的集成还可以生成SAM部署文件，这些文件可以被 link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[亚马逊的SAM框架] 来使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can detect the vulnerabilities at the application build time with an NVD feed by using the Maven link:https://jeremylong.github.io/DependencyCheck/dependency-check-maven/[OWASP Dependency check plugin].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过使用Maven link:https://jeremylong.github.io/DependencyCheck/dependency-check-maven/[OWASP依赖性检查插件] 在应用构建时用NVD feed来检测漏洞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable measurement of HTTP endpoints using the `quarkus.micrometer.binder.http-server.ignore-patterns`
property.
This property accepts a comma-separated list of simple regex match patterns identifying URI paths that should
be ignored.
For example, setting `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` will
ignore a request to `http://localhost:8080/example/prime/7919`.
A request to `http://localhost:8080/example/gauge/7919`
would still be measured.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `quarkus.micrometer.binder.http-server.ignore-patterns` 属性禁用对HTTP节点的测量。这个属性接受一个用逗号分隔的简单正则表达式匹配的列表来识别应被忽略的URI路径。例如， `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` 会忽略对 `&lt;a href="http://localhost:8080/example/prime/7919" class="bare"&gt;http://localhost:8080/example/prime/7919&lt;/a&gt;` 请求的监测。而一个对 `&lt;a href="http://localhost:8080/example/gauge/7919" class="bare"&gt;http://localhost:8080/example/gauge/7919&lt;/a&gt;` 的请求仍会被监测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable measurement of HTTP endpoints using the `quarkus.micrometer.binder.http-server.ignore-patterns`
property. This property accepts a comma-separated list of simple regex match patterns identifying URI paths that should
be ignored. For example, setting `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` will
ignore a request to `http://localhost:8080/example/prime/7919`. A request to `http://localhost:8080/example/gauge/7919`
would still be measured.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `quarkus.micrometer.binder.http-server.ignore-patterns` 属性禁用对HTTP节点的测量。这个属性接受一个用逗号分隔的简单正则表达式匹配的列表来识别应被忽略的URI路径。例如， `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` 会忽略对 `&lt;a href="http://localhost:8080/example/prime/7919" class="bare"&gt;http://localhost:8080/example/prime/7919&lt;/a&gt;` 请求的监测。而一个对 `&lt;a href="http://localhost:8080/example/gauge/7919" class="bare"&gt;http://localhost:8080/example/gauge/7919&lt;/a&gt;` 的请求仍会被监测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable measurement of HTTP endpoints using the `quarkus.micrometer.binder.http-server.ignore-patterns` property. This property accepts a comma-separated list of simple regex match patterns identifying URI paths that should be ignored. For example, setting `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` will ignore a request to `http://localhost:8080/example/prime/7919`. A request to `http://localhost:8080/example/gauge/7919` would still be measured.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `quarkus.micrometer.binder.http-server.ignore-patterns` 属性禁用对HTTP节点的测量。这个属性接受一个用逗号分隔的简单正则表达式匹配的列表来识别应被忽略的URI路径。例如， `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` 会忽略对 `&lt;a href="http://localhost:8080/example/prime/7919" class="bare"&gt;http://localhost:8080/example/prime/7919&lt;/a&gt;` 请求的监测。而一个对 `&lt;a href="http://localhost:8080/example/gauge/7919" class="bare"&gt;http://localhost:8080/example/gauge/7919&lt;/a&gt;` 的请求仍会被监测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do this with `io.quarkus.test.common.DevServicesContext`, which can be injected directly into any `@QuarkusTest`
or `@QuarkusIntegrationTest`. All you need to do is define a field of type `DevServicesContext` and it will be automatically
injected. Using this you can retrieve any properties that have been set. Generally this is used to directly connect to a
resource from the test itself, e.g. to connect to kafka to send messages to the application under test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `io.quarkus.test.common.DevServicesContext` 来达到目的，它可以直接注入到任何 `@QuarkusTest` 或 `@QuarkusIntegrationTest` 中。您所需要做的就是定义一个类型为 `DevServicesContext` 的字段，然后它就会自动被注入。使用该方法，您可以检索到任何已经设置的属性。一般来说，这被用来直接连接到测试本身的资源，例如，连接到kafka来发送消息到被测试的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do this with `io.quarkus.test.common.DevServicesContext`, which can be injected directly into any `@QuarkusTest` or `@QuarkusIntegrationTest`. All you need to do is define a field of type `DevServicesContext` and it will be automatically injected. Using this you can retrieve any properties that have been set. Generally this is used to directly connect to a resource from the test itself, e.g. to connect to kafka to send messages to the application under test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `io.quarkus.test.common.DevServicesContext` 来达到目的，它可以直接注入到任何 `@QuarkusTest` 或 `@QuarkusIntegrationTest` 中。您所需要做的就是定义一个类型为 `DevServicesContext` 的字段，然后它就会自动被注入。使用该方法，您可以检索到任何已经设置的属性。一般来说，这被用来直接连接到测试本身的资源，例如，连接到kafka来发送消息到被测试的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about all this in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[GraalVM的文档]中找到更多关于这一切的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about how to configure the native image building process in the &lt;&lt;configuration-reference&gt;&gt; section below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在下面的 &lt;&lt;configuration-reference&gt;&gt; 部分找到关于如何配置原生镜像构建过程的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this feature in the xref:hibernate-orm.adoc#flyway[Hibernate ORM guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在xref:hibernate-orm.adoc#flyway[Hibernate ORM guide]找到更多相关信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this topic in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[GraalVM文档]中找到更多关于这个主题的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on https://code.quarkus.io[code.quarkus.io] or in the extension link:/guides/[guides].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在 https://code.quarkus.io[code.quarkus.io] 或在扩展 link:/guides/[手册]中找到扩展状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get a better understanding on how to use this extension in the Quarkus Guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在Quarkus指南中更好地了解如何使用这个扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to https://code.quarkus.io/[code.quarkus.io] to see if a particular extension is _stable_ (default) or _preview_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以访问 https://code.quarkus.io/[code.quarkus.io] 查看特定扩展是否为 _stable_ (默认) or _preview_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can have your projection class extends from another class. In this case, the parent class also needs to have use `@ProjectionFor` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以让你的映射类从另一个类继承。在这种情况下，父类也需要有使用 `@ProjectionFor` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject an `executor` if you use the Context Propagation extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Context Propagation扩展，你可以注入一个 `executor` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject either the:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以这样注入：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now interact with your REST service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在你可以与你的REST服务进行交互：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can of course create a native image using the instructions of the xref:building-native-image.adoc[Building a native executable guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当然，你也可以使用 link:building-native-image.html[构建本地可执行文件指南] 的说明来创建一个本地镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the configuration by adding the following lines to the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过在 `application.properties` 中添加以下属性来覆盖配配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable *runs* with during the test using the `quarkus.test.native-image-profile` property.
Either by adding it to `application.properties` or by appending it to the command line:
`./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.
Your `%test.` prefixed properties will be used at the test runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以在可执行文件 *运行* 测试期间覆盖配置文件的 `quarkus.test.native-image-profile` 属性。可以添加到 `application.properties` ，或将其附加到命令行，如： `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`。您的 `%test.` 前缀属性将在测试运行时使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable *runs* with during the test using the `quarkus.test.native-image-profile` property.  Either by adding it to `application.properties` or by appending it to the command line: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  Your `%test.` prefixed properties will be used at the test runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以在可执行文件 *运行* 测试期间覆盖配置文件的 `quarkus.test.native-image-profile` 属性。可以添加到 `application.properties` ，或将其附加到命令行，如： `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`。您的 `%test.` 前缀属性将在测试运行时使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable is *built* with and *runs* with using the `quarkus-profile=test` property, e.g.
`./mvnw clean verify -Pnative -Dquarkus-profile=test`. This might come handy if there are test specific resources to be processed,
such as importing test data into the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以使用 `quarkus-profile=test` 属性覆盖可执行文件 *built* 和 *runs* 的配置文件。例如 `./mvnw clean verify -Pnative -Dquarkus-profile=test`。如果要处理特定于测试的资源，例如将测试数据导入数据库，那么这可能会很方便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable is *built* with and *runs* with using the `quarkus-profile=test` property, e.g.  `./mvnw clean verify -Pnative -Dquarkus-profile=test`. This might come handy if there are test specific resources to be processed, such as importing test data into the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以使用 `quarkus-profile=test` 属性覆盖可执行文件 *built* 和 *runs* 的配置文件。例如 `./mvnw clean verify -Pnative -Dquarkus-profile=test`。如果要处理特定于测试的资源，例如将测试数据导入数据库，那么这可能会很方便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can pass query parameters by index (1-based) as shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过索引（从1开始）传递查询参数，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can pass query parameters, for both native and PanacheQL queries, by index (1-based) as shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于原生和PanacheQL查询，你可以通过索引（基于1）传递查询参数，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.
Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `&lt;quarkus.native.additional-build-args&gt;` 属性为 `native-image` 命令提供自定义选项。多个选项可以用逗号隔开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.  Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `&lt;quarkus.native.additional-build-args&gt;` 属性为 `native-image` 命令提供自定义选项。多个选项可以用逗号隔开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put all your JPA column annotations on the public fields. If you need a field to not be persisted, use the
`@Transient` annotation on it. If you need to write accessors, you can:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些公共字段可以添加任何JPA列注解。如果你不想持久化某个字段，给它增加 `@Transient` 注解即可。如果你需要编写访问器，可以：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put all your JPA column annotations on the public fields. If you need a field to not be persisted, use the `@Transient` annotation on it. If you need to write accessors, you can:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些公共字段可以添加任何JPA列注解。如果你不想持久化某个字段，给它增加 `@Transient` 注解即可。如果你需要编写访问器，可以：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI images on:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在这里阅读更多关于UBI镜像的内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI on:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在以下网站阅读更多关于UBI的信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can receive it using a `JsonObject`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `JsonObject` 接收它</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can reference a named query instead of a (simplified) HQL query by prefixing its name with the '#' character. You can also use named queries for count, update and delete queries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了上述的简化HQL查询以外，你还可以定义一个命名查询，然后通过'#'字符加命名来（在HQL中）引用它。在计数、更新和删除查询中也可以使用命名查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can restore the default behavior of Jackson by setting `quarkus.jackson.fail-on-unknown-properties=true` in your `application.properties`
or on a per class basis via `@JsonIgnoreProperties(ignoreUnknown = false)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过在你的 `application.properties` ，或者通过 `@JsonIgnoreProperties(ignoreUnknown = false)` ，在每个类的基础上设置 `quarkus.jackson.fail-on-unknown-properties=true` ，恢复Jackson的默认行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can restore the default behavior of Jackson by setting `quarkus.jackson.fail-on-unknown-properties=true` in your `application.properties` or on a per class basis via `@JsonIgnoreProperties(ignoreUnknown = false)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过在你的 `application.properties` ，或者通过 `@JsonIgnoreProperties(ignoreUnknown = false)` ，在每个类的基础上设置 `quarkus.jackson.fail-on-unknown-properties=true` ，恢复Jackson的默认行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return _reactive types_ to handle asynchronous processing.
Quarkus recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write reactive and asynchronous code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以返回 _响应式类型_ 来处理异步处理。Quarkus推荐使用 link:https://smallrye.io/smallrye-mutiny[Mutiny] 来编写响应式和异步代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return _reactive types_ to handle asynchronous processing.  Quarkus recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write reactive and asynchronous code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以返回 _响应式类型_ 来处理异步处理。Quarkus推荐使用 link:https://smallrye.io/smallrye-mutiny[Mutiny] 来编写响应式和异步代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application as a conventional jar file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以将应用打包为一个传统的jar文件，然后运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.
However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用Quarkus Maven插件生成的JAR在容器中运行该应用程序。然而，在本节中我们将重点讨论使用生成的原生可执行文件创建一个容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.  However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用Quarkus Maven插件生成的JAR在容器中运行该应用程序。然而，在本节中我们将重点讨论使用生成的原生可执行文件创建一个容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用以下方式运行该应用程序。 `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run these using Maven:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用Maven来运行这些：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the result using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用以下命令看到结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can set a https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#built-in-samplers[built-in sampler]
simply by setting the desired sampler config described in the &lt;&lt;configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过设置 link:#configuration-reference[[参考配置]] 中提到的必要的采样器配置来简单地设置一个 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#built-in-samplers[内置采样器]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can set a https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#built-in-samplers[built-in sampler] simply by setting the desired sampler config described in the &lt;&lt;configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过设置 link:#configuration-reference[[参考配置]] 中提到的必要的采样器配置来简单地设置一个 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#built-in-samplers[内置采样器]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify your own ID strategy by extending `PanacheEntityBase` instead of `PanacheEntity`. Then
you just declare whatever ID you want as a public field:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过继承 `PanacheEntityBase` ，而非 `PanacheEntity` ，来指定你自己的ID策略。然后只要把你想要的ID字段声明为public字段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify your own ID strategy by extending `PanacheEntityBase` instead of `PanacheEntity`. Then you just declare whatever ID you want as a public field:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过继承 `PanacheEntityBase` ，而非 `PanacheEntity` ，来指定你自己的ID策略。然后只要把你想要的ID字段声明为public字段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify your own ID strategy by extending `PanacheMongoEntityBase` instead of `PanacheMongoEntity`. Then
you just declare whatever ID you want as a public field by annotating it by `@BsonId`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过继承 `PanacheMongoEntityBase` ，而不是 `PanacheMongoEntity` ，来指定你自己的ID策略。然后你只要通过 `@BsonId` ，将你想要的任何ID声明为一个公共字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify your own ID strategy by extending `PanacheMongoEntityBase` instead of `PanacheMongoEntity`. Then you just declare whatever ID you want as a public field by annotating it by `@BsonId`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过继承 `PanacheMongoEntityBase` ，而不是 `PanacheMongoEntity` ，来指定你自己的ID策略。然后你只要通过 `@BsonId` ，将你想要的任何ID声明为一个公共字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can test the application launched in JVM or Native modes with `curl`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以用 `curl` 测试在JVM或Native模式下启动的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path
will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will
be appended to the end of the endpoint path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注释来指定节点路径，该路径会从提供的节点中提取。如果您还为 `TestHTTPResource` 节点指定了另外的值，它将被附加到节点路径后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will be appended to the end of the endpoint path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注释来指定节点路径，该路径会从提供的节点中提取。如果您还为 `TestHTTPResource` 节点指定了另外的值，它将被附加到节点路径后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then build a native executable with the usual command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后你可以用常用的命令构建一个本地可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then point your browser to `http://localhost:8080/fruits.html` and use your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后你可以使用的浏览器访问 `&lt;a href="http://localhost:8080/fruits.html" class="bare"&gt;http://localhost:8080/fruits.html&lt;/a&gt;` 来使用你的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then test the executable locally with sam local</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后你可以使用sam local在本地测试可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the
`update` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在你认为合适的时候更新Java代码。一旦你重建了，你可以通过执行 `update` 命令来重新部署你的lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the `update` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在你认为合适的时候更新Java代码。一旦你重建了，你可以通过执行 `update` 命令来重新部署你的lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `@TestSecurity` and `@OidcSecurity` annotations for testing the `service` application endpoint code which depends on the injected `JsonWebToken` as well as `UserInfo` and `OidcConfigurationMetadata`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `@TestSecurity` 和 `@OidcSecurity` 注解来测试 `service` 应用程序端点代码，该代码依赖于注入的 `JsonWebToken` 以及 `UserInfo` 和 `OidcConfigurationMetadata` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Uni` and `Response` to return asynchronous HTTP responses: `Uni&lt;Response&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `Uni` 和 `Response` 返回异步 HTTP 响应：`Uni&lt;Response&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a configuration file to register classes for reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用一个配置文件来为反射注册类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在函数中使用任何Quarkus特性，并受益于快速启动和低内存利用率。使用Quarkus，您无需改变编程语言就可以拥抱这个新世界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use it to restrict which fields will be returned by the database,
the ID field will always be returned, but it's not mandatory to include it inside the projection class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用它来限制哪些字段将被数据库返回，ID字段将始终被返回，但并不强制要求在映射类中包含它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use it to restrict which fields will be returned by the database, the ID field will always be returned, but it's not mandatory to include it inside the projection class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用它来限制哪些字段将被数据库返回，ID字段将始终被返回，但并不强制要求在映射类中包含它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use it to restrict which fields will be returned by the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用投影限制数据库返回哪些字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use public fields or private fields with getters/setters.
If you don't want to manage the ID by yourself, you can make your entity extends `PanacheMongoEntity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用公共字段或带有getters/setters的私有字段。如果你不想自己管理ID，你可以让你的实体继承 `PanacheMongoEntity` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use public fields or private fields with getters/setters.  If you don't want to manage the ID by yourself, you can make your entity extends `PanacheMongoEntity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用公共字段或带有getters/setters的私有字段。如果你不想自己管理ID，你可以让你的实体继承 `PanacheMongoEntity` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use static methods on `QuarkusTransaction` to define transaction boundaries. This provides two different options,
a functional approach that allows you to run a lambda within the scope of a transaction, or by using explicit `begin`,
`commit` and `rollback` methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `QuarkusTransaction` 上的静态方法来定义事务边界。这提供了两种不同的选择，一种是允许你在事务范围内运行lambda的函数式方法，或者通过使用显式的 `begin` 、 `commit` 和 `rollback` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use static methods on `QuarkusTransaction` to define transaction boundaries. This provides two different options, a functional approach that allows you to run a lambda within the scope of a transaction, or by using explicit `begin`, `commit` and `rollback` methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `QuarkusTransaction` 上的静态方法来定义事务边界。这提供了两种不同的选择，一种是允许你在事务范围内运行lambda的函数式方法，或者通过使用显式的 `begin` 、 `commit` 和 `rollback` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use that generated UUID as the consumer group as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用生成的UUID作为消费者组id，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the JPA entity manager directly.  Panache proposes an alternative removing boilerplate and exposing an active record and repository models.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以直接使用JPA实体管理器。Panache提出了一个替代方案，去掉了模板，暴露了一个活跃的记录和存储库模型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the MongoDB client in a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在一个本地可执行文件中使用MongoDB客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the following command as usual:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以像往常一样使用以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the generated pair of keys instead of the keys used in this quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用生成的这对密钥，而不是本快速入门中使用的密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the same approach as described in the xref:security-openid-connect.adoc#integration-testing[OpenID Connect Bearer Token Integration testing] `Local Public Key` section but only change the `application.properties` to use MP JWT configuration properties instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用与 link:security-openid-connect.html#integration-testing.adoc[OpenID Connect承载令牌集成测试] `Local Public Key` 部分所述的相同方法，只需改变 `application.properties` ，使用MP JWT配置属性代替：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your
test makes to the database will be persistent. If you want any changes made to be rolled back at the end of
the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a
transaction, but roll it back once the test method is complete to revert any database changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在测试中使用标准的Quarkus `@Transactional` 注解，但这意味着您的测试对数据库的改变将是持久的。如果您想在测试结束时回滚所做的任何改变，您可以使用 `io.quarkus.test.TestTransaction` 注释。这将在一个事务中运行测试方法，但一旦测试方法完成，事务就会回滚从而以恢复所有数据库变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your test makes to the database will be persistent. If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在测试中使用标准的Quarkus `@Transactional` 注解，但这意味着您的测试对数据库的改变将是持久的。如果您想在测试结束时回滚所做的任何改变，您可以使用 `io.quarkus.test.TestTransaction` 注释。这将在一个事务中运行测试方法，但一旦测试方法完成，事务就会回滚从而以恢复所有数据库变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use them if you want, but we also support what we call **PanacheQL** that can be seen as a subset of link:https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm#BNBTG[JPQL] (or link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL]) and allows you to easily express a query.
MongoDB with Panache will then map it to a MongoDB native query.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你愿意，你可以使用它们，但我们也支持所谓的 **PanacheQL** ，它可以被看作是 link:https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm#BNBTG[JPQL] （或 link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL] ）的一个子集，并允许你轻松地表达一个查询。使用Panache的MongoDB会将其映射为MongoDB的原生查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use them if you want, but we also support what we call **PanacheQL** that can be seen as a subset of link:https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm#BNBTG[JPQL] (or link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL]) and allows you to easily express a query.  MongoDB with Panache will then map it to a MongoDB native query.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你愿意，你可以使用它们，但我们也支持所谓的 **PanacheQL** ，它可以被看作是 link:https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm#BNBTG[JPQL] （或 link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL] ）的一个子集，并允许你轻松地表达一个查询。使用Panache的MongoDB会将其映射为MongoDB的原生查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can verify ID and access JWT tokens by using the refreshable JSON Web Key (JWK) set or you can introspect them remotely.
However, opaque (binary) tokens can only be introspected remotely.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用可刷新的 `JWK` 密钥集验证ID和访问 `JWT` token。但JWT和不透明（二进制）token都可以被远程自省(introspect)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can verify ID and access JWT tokens by using the refreshable JSON Web Key (JWK) set or you can introspect them remotely.  However, opaque (binary) tokens can only be introspected remotely.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用可刷新的 `JWK` 密钥集验证ID和访问 `JWT` token。但JWT和不透明（二进制）token都可以被远程自省(introspect)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can write your mocking test like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以像这样写你的模拟测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot combine the `quarkus-oidc` `Bearer` and `smallrye-jwt` authentication mechanisms because both mechanisms attempt to verify the token extracted from the HTTP `Authorization Bearer` scheme.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但结合 `quarkus-oidc` `Bearer` 和 `smallrye-jwt` 认证机制是不允许的，因为两者都试图验证从HTTP `Authorization Bearer` scheme中提取的token。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot mix ranges and pages: if you use a range, all methods that depend on having a current page will throw an `UnsupportedOperationException`;
you can switch back to paging using `page(Page)` or `page(int, int)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不能混合使用ranges和pages：如果你使用range，所有依赖于拥有当前页面的方法将抛出一个 `UnsupportedOperationException` ；你可以使用 `page(Page)` 或 `page(int, int)` 切换回分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot mix ranges and pages: if you use a range, all methods that depend on having a current page will throw an `UnsupportedOperationException`; you can switch back to paging using `page(Page)` or `page(int, int)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不能混合使用ranges和pages：如果你使用range，所有依赖于拥有当前页面的方法将抛出一个 `UnsupportedOperationException` ；你可以使用 `page(Page)` 或 `page(int, int)` 切换回分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot use `@Transactional` with Hibernate Reactive for your transactions: you must use `@ReactiveTransactional`,
and your annotated method must return a `Uni` to be non-blocking. Otherwise it needs be called from a non-`VertxThread` thread
and will become blocking.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Hibernate Reactive中，不能对事务使用 `@Transactional` 注解，必须使用 `@ReactiveTransactional` ，而且被注解的方法必须返回一个 `Uni` ，才能保证方法是非阻塞的。否则，Quarkus会用一个非 `VertxThread` 的线程调用这个方法，并使它阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot use `@Transactional` with Hibernate Reactive for your transactions: you must use `@ReactiveTransactional`, and your annotated method must return a `Uni` to be non-blocking. Otherwise it needs be called from a non-`VertxThread` thread and will become blocking.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Hibernate Reactive中，不能对事务使用 `@Transactional` 注解，必须使用 `@ReactiveTransactional` ，而且被注解的方法必须返回一个 `Uni` ，才能保证方法是非阻塞的。否则，Quarkus会用一个非 `VertxThread` 的线程调用这个方法，并使它阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot use `UserTransaction` in a method having a transaction started by a `@Transactional` call.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不能在一个由 `@Transactional` 控制事务启动的方法中使用 `UserTransaction` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You create an Hibernate entity instance from this payload,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您从这个payload中创建一个Hibernate实体对象,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to inject the `vertx` instance; instead, leverage the protected field from `AbstractVerticle`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不需要注入 `vertx` 实例；相反，你可以利用 `AbstractVerticle` 的受保护字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to reply to received messages.
Typically, for a _fire and forget_ interaction, the messages are consumed, and the sender does not need to know about it.
To implement this pattern, your consumer method returns `void`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不需要回复收到的消息。通常情况下，对于 _fire 和 forget_ 交互来说，消息被消耗掉了，发送者不需要知道这件事。为了实现这种模式，你的消费者方法返回 `void` 类型 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to reply to received messages.  Typically, for a _fire and forget_ interaction, the messages are consumed, and the sender does not need to know about it.  To implement this pattern, your consumer method returns `void`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不需要回复收到的消息。通常情况下，对于 _fire 和 forget_ 交互来说，消息被消耗掉了，发送者不需要知道这件事。为了实现这种模式，你的消费者方法返回 `void` 类型 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't need to worry about setting it up most of the time as extensions needing it will simply add it as a dependency.
Hibernate ORM for example will include the transaction manager and set it up properly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在大多数情况下，你不需要担心设置它，因为需要它的扩展会简单地把它作为一个依赖项加入。例如，Hibernate ORM将包括事务管理器并对其进行正确设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't need to worry about setting it up most of the time as extensions needing it will simply add it as a dependency.  Hibernate ORM for example will include the transaction manager and set it up properly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在大多数情况下，你不需要担心设置它，因为需要它的扩展会简单地把它作为一个依赖项加入。例如，Hibernate ORM将包括事务管理器并对其进行正确设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have found nowhere.&lt;br/&gt;The pathway to normal space&lt;br/&gt;is found in the nav.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>没有找到您要访问的资源。&lt;br/&gt;请通过导航栏返回到正常空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have noticed how much more compact and readable the code is compared to using the MongoDB API?
Does this look interesting? Read on!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你是否注意到与使用MongoDB API相比，代码更加紧凑和可读？这看起来是不是很有趣？请继续阅读!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have noticed how much more compact and readable the code is compared to using the MongoDB API? Does this look interesting? Read on!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你是否注意到与使用MongoDB API相比，代码更加紧凑和可读？这看起来是不是很有趣？请继续阅读!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have noticed how much more compact and readable the code is?
Does this look interesting? Read on!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你有注意到代码的紧凑性和可读性大大提高了吗？看起来很有趣吧？请继续阅读!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have noticed how much more compact and readable the code is? Does this look interesting? Read on!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你有注意到代码的紧凑性和可读性大大提高了吗？看起来很有趣吧？请继续阅读!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You inject the channel representing the Kafka topic in your HTTP endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您在您的HTTP节点中注入代表Kafka topic的 channel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You just need to run both applications using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你只需使用以下命令运行这两个应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能需要添加 `import org.jboss.resteasy.reactive.RestSseElementType;` 语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to configure the `link-name` attribute, if the queue name is not the channel name:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果队列名称不是通道名称，你可能需要配置 `link-name` 属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may want to build the native executable directly in a container without having a final container containing the build tools.
That approach is possible with a multi-stage Docker build:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能想直接在一个容器中构建原生可执行文件，而不需要一个包含构建工具的最终容器。这种方法可以通过多阶段的Docker构建来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may want to build the native executable directly in a container without having a final container containing the build tools.  That approach is possible with a multi-stage Docker build:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能想直接在一个容器中构建原生可执行文件，而不需要一个包含构建工具的最终容器。这种方法可以通过多阶段的Docker构建来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能想知道响应流 (https://www.reactive-streams.org/)。  `Multi` 实现了响应流 `Publisher`，因此实现了响应流回压机制。  `Uni` 没有实现 `Publisher` ，因为' Uni '的订阅足以表明你对结果感兴趣。由于响应流的订阅/请求仪式更加复杂，所以它再次考虑了更简单、更流畅的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might need to add it as a dependency explicitly if you are using transactions directly without Hibernate ORM for example.
Add the following to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不使用Hibernate ORM而直接使用事务，你可能需要明确地将其作为一个依赖项加入，例如。在你的构建文件中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might need to add it as a dependency explicitly if you are using transactions directly without Hibernate ORM for example.  Add the following to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不使用Hibernate ORM而直接使用事务，你可能需要明确地将其作为一个依赖项加入，例如。在你的构建文件中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must also force your AWS service client for SQS, SNS, S3 et al, to use the URL Connection client,
which connects to AWS services over HTTPS, hence the inclusion of the SSL enabled property, as described in the &lt;&lt;https&gt;&gt; section above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你还必须强制你的SQS、SNS、S3等AWS服务客户端使用URL Connection客户端，其通过HTTPS连接到AWS服务，因此包含启用了SSL的属性，如上面 link:#https[[https]] 部分中所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must also force your AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS, hence the inclusion of the SSL enabled property, as described in the &lt;&lt;https&gt;&gt; section above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你还必须强制你的SQS、SNS、S3等AWS服务客户端使用URL Connection客户端，其通过HTTPS连接到AWS服务，因此包含启用了SSL的属性，如上面 link:#https[[https]] 部分中所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java" target="_blank"&gt;an IDE&lt;/a&gt; like &lt;a href="https://www.jetbrains.com/idea/download/"&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href="https://www.eclipse.org/downloads/"&gt;Eclipse&lt;/a&gt;, &lt;a href="https://code.visualstudio.com/Download"&gt;VSCode&lt;/a&gt; or even &lt;a href="https://spacevim.org/use-vim-as-a-java-ide/"&gt;Vim&lt;/a&gt; or &lt;a href="http://spacemacs.org"&gt;Emacs&lt;/a&gt;!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java" target="_blank"&gt;一个IDE&lt;/a&gt;，比如&lt;a href="https://www.jetbrains.com/idea/download/"&gt;IntelliJ IDEA&lt;/a&gt;，&lt;a href="https://www.eclipse.org/downloads/"&gt;Eclipse&lt;/a&gt;、&lt;a href="https://code.visualstudio.com/Download"&gt;VSCode&lt;/a&gt;或者至少有一个&lt;a href="https://spacevim.org/use-vim-as-a-java-ide/"&gt;Vim&lt;/a&gt;、&lt;a href="http://spacemacs.org"&gt;Emacs&lt;/a&gt;文本编辑器！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.versions.maven }}&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.version.maven }}&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.versions.maven }}&lt;/a&gt; or &lt;a href="https://gradle.org/" target="_blank"&gt;Gradle&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.version.maven }}&lt;/a&gt;或&lt;a href="https://gradle.org/" target="_blank"&gt;Gradle&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need a &lt;a href="https://adoptopenjdk.net" target="_blank"&gt;a JDK {{ site.data.versions.jdk }}&lt;/a&gt; (any distribution)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要一个&lt;a href="https://adoptopenjdk.net" target="_blank"&gt;JDK {{ site.data.version.jdk }}&lt;/a&gt;（任意发行版）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need a deserializer that can create a `Fruit` from the record.
This can be done using a Jackson deserializer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要一个能从记录中创建 `Fruit` 实例的反序列化器。可以使用Jackson的反序列化器来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要一个能从记录中创建 `Fruit` 实例的反序列化器。可以使用Jackson的反序列化器来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need clustering support for your scheduled tasks? This guide explains how to use the Quartz extension for that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的计划任务需要集群支持？本指南解释了如何使用Quartz扩展来实现这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你需要以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to use the JAAS `PlainLoginModule`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要使用JAAS `PlainLoginModule` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops. This guide explains how to be notified when an application stops or starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你经常需要在应用程序启动时执行自定义动作，在应用程序停止时清理一切。本指南解释了如何在应用程序停止或启动时获得通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You persist that entity into a database,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您将该实体持久化到数据库中,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You receive an HTTP request with a payload,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您收到一个带有payload的HTTP请求,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You return that channel as a `Publisher` or a `Multi` from the HTTP method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您将该 channel 作为一个 `Publisher` 或 `Multi` 从HTTP方法中返回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You send the entity to a Kafka topic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您把实体发送到一个Kafka topic中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should be able to access your Keycloak Server at http://localhost:8180[localhost:8180].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你应该能够通过 http://localhost:8180[localhost:8180] 访问你的Keycloak服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should be able to access your Keycloak Server at https://localhost:8543[localhost:8543].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在您应该可以在 link:https://localhost:8543[localhost:8543] 访问您的Keycloak服务器了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should get the expected `Hello bob` message back.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你应该会收到预期的 `Hello bob` 消息。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should get the expected `Hello bob` message back.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你应该会收到预期的 `Hello bob` 消息。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您不应该在您的代码中直接调用被标记了 `@Incoming` 和/或 `@Outgoing` 注解的方法。它们会被框架调用。如果在用户代码中调用将不会得到预期的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should only use `list` and `stream` methods if your collection contains small enough data sets. For larger data
sets you can use the `find` method equivalents, which return a `PanacheQuery` on which you can do paging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的集合包含足够小的数据集，你应该只使用 `list` 和 `stream` 方法。对于较大的数据集，你可以使用 `find` 方法来替代，它返回一个 `PanacheQuery` ，你可以对其进行分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should only use `list` and `stream` methods if your collection contains small enough data sets. For larger data sets you can use the `find` method equivalents, which return a `PanacheQuery` on which you can do paging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的集合包含足够小的数据集，你应该只使用 `list` 和 `stream` 方法。对于较大的数据集，你可以使用 `find` 方法来替代，它返回一个 `PanacheQuery` ，你可以对其进行分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should only use `list` and `stream` methods if your table contains small enough data sets. For larger data
sets you can use the `find` method equivalents, which return a `PanacheQuery` on which you can do paging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的表数据量很小，你应该只用到 `list` 和 `stream` 方法。对于较大的数据集，你可以使用对应的 `find` 方法，它返回一个 `PanacheQuery` ，可以对其进行分页查询操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should only use `list` and `stream` methods if your table contains small enough data sets. For larger data sets you can use the `find` method equivalents, which return a `PanacheQuery` on which you can do paging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的表数据量很小，你应该只用到 `list` 和 `stream` 方法。对于较大的数据集，你可以使用对应的 `find` 方法，它返回一个 `PanacheQuery` ，可以对其进行分页查询操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should only use the `list` methods if your table contains small enough data sets. For larger data
sets you can use the `find` method equivalents, which return a `PanacheQuery` on which you can do paging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的表数据量很小，你应该只用到 `list` 方法。对于较大的数据集，你可以使用对应的 `find` 方法，它返回一个 `PanacheQuery` ，可以对其进行分页查询操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should only use the `list` methods if your table contains small enough data sets. For larger data sets you can use the `find` method equivalents, which return a `PanacheQuery` on which you can do paging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的表数据量很小，你应该只用到 `list` 方法。对于较大的数据集，你可以使用对应的 `find` 方法，它返回一个 `PanacheQuery` ，可以对其进行分页查询操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see the content of the file printed in the console.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你应该会在控制台中看到打印的文件内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will also have to explicitly configure Vert.x to use the native transport.
In `application.properties` add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你还必须明确地配置Vert.x来使用本地传输。在 `application.properties` 中添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will also have to explicitly configure Vert.x to use the native transport.  In `application.properties` add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你还必须明确地配置Vert.x来使用本地传输。在 `application.properties` 中添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will also have to explicitly configure Vert.x to use the native transport. In `application.properties` add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你还必须明确地配置Vert.x来使用本地传输。在 `application.properties` 中添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will be allowed to use the following annotations to customize this mapping:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你将被允许使用以下注解来自定义这种映射：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will be asked to log in into a `Single Page Application` provided by `OpenID Connect Dev UI`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您将被要求登录到由 `OpenID Connect Dev UI` 提供的 `Single Page Application` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will have access to the same functionalities of the _imperative_ variant inside the reactive one: bson annotations, custom ID, PanacheQL, ...
But the methods on your entities or repositories will all return reactive types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 _imperative_ 变形中使用同样的功能：Bson注释、自定义ID、PanacheQL......但是你的实体或资源库上的方法将全部返回响应式类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will have access to the same functionalities of the _imperative_ variant inside the reactive one: bson annotations, custom ID, PanacheQL, ...  But the methods on your entities or repositories will all return reactive types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 _imperative_ 变形中使用同样的功能：Bson注释、自定义ID、PanacheQL......但是你的实体或资源库上的方法将全部返回响应式类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will then need to specify your own provider to configure and initialize the
MeterRegistry, as discussed in the next section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，您将需要指定自定义的provider来配置和初始化MeterRegistry，我们将在下一节讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will then need to specify your own provider to configure and initialize the MeterRegistry, as discussed in the next section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，您将需要指定自定义的provider来配置和初始化MeterRegistry，我们将在下一节讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your REST method then looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的 REST 方法如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your application may have additional requirements.
For example, if you have an application that requires `libfreetype.so`, you need to copy the native libraries to the container.
In this case, you need to use a multi-stage `dockerfile` to copy the required libraries:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的应用程序可能有其他的额外要求。例如，如果你有一个依赖于 `libfreetype.so` 的应用程序，你需要将本地库拷贝到容器当中。在这种情况下，你需要使用一个多阶段的 `dockerfile` 来拷贝所需要的依赖库:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your application may have additional requirements.  For example, if you have an application that requires `libfreetype.so`, you need to copy the native libraries to the container.  In this case, you need to use a multi-stage `dockerfile` to copy the required libraries:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的应用程序可能有其他的额外要求。例如，如果你有一个依赖于 `libfreetype.so` 的应用程序，你需要将本地库拷贝到容器当中。在这种情况下，你需要使用一个多阶段的 `dockerfile` 来拷贝所需要的依赖库:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your decision to choose whether to use opaque or JWT token format will be driven by architectural considerations.
Opaque tokens tend to be much shorter than JWT tokens but need most of the token-associated state to be maintained in the provider database.
Opaque tokens are effectively database pointers.
JWT tokens are significantly longer than the opaque tokens but the providers are effectively delegating storing most of the token-associated state to the client by storing it as the token claims and either signing or encrypting them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，选择使用不透明 token 还是JWT token 格式通常是由架构考虑驱动的。不透明 token 通常比JWT token 短得多，但它们需要在提供者的数据库中维护大部分的 token 相关状态。不透明 token 实际上就是数据库指针。JWT token 比不透明 token 要长得多，但提供者通过将大部分 token 相关状态存储为 token 声明并对其进行签名或加密从而有效地将其委托给客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your decision to choose whether to use opaque or JWT token format will be driven by architectural considerations.  Opaque tokens tend to be much shorter than JWT tokens but need most of the token-associated state to be maintained in the provider database.  Opaque tokens are effectively database pointers.  JWT tokens are significantly longer than the opaque tokens but the providers are effectively delegating storing most of the token-associated state to the client by storing it as the token claims and either signing or encrypting them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，选择使用不透明 token 还是JWT token 格式通常是由架构考虑驱动的。不透明 token 通常比JWT token 短得多，但它们需要在提供者的数据库中维护大部分的 token 相关状态。不透明 token 实际上就是数据库指针。JWT token 比不透明 token 要长得多，但提供者通过将大部分 token 相关状态存储为 token 声明并对其进行签名或加密从而有效地将其委托给客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your endpoints can return `Uni` or `Multi` instances:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的节点可以返回 `Uni` 或 `Multi` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your final archive will look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的最终档案将看起来像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your help is more than welcome! Don’t hesitate to join the crowd.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们非常欢迎您的帮助！不要犹豫，加入我们大家吧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your implemented provider must be a CDI bean.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您实现的提供者必须是一个CDI bean。这里是一个例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Zero config, live reload in the blink of an eye</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>零配置，瞬间重新加载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*address*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*address*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*auto-acknowledgement*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*auto-acknowledgement*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*broadcast*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*broadcast*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*client-options-name*#

[.no-hyphens]#_(amqp-client-options-name)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*client-options-name*#

[.no-hyphens]#_(amqp-client-options-name)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*cloud-events*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-data-content-type*#

[.no-hyphens]#_(cloud-events-default-data-content-type)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*cloud-events-data-content-type*#

[.no-hyphens]#_(cloud-events-default-data-content-type)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-data-schema*#

[.no-hyphens]#_(cloud-events-default-data-schema)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*cloud-events-data-schema*#

[.no-hyphens]#_(cloud-events-default-data-schema)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-insert-timestamp*#

[.no-hyphens]#_(cloud-events-default-timestamp)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*cloud-events-insert-timestamp*#

[.no-hyphens]#_(cloud-events-default-timestamp)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-mode*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*cloud-events-mode*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-source*#

[.no-hyphens]#_(cloud-events-default-source)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*cloud-events-source*#

[.no-hyphens]#_(cloud-events-default-source)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-subject*#

[.no-hyphens]#_(cloud-events-default-subject)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*cloud-events-subject*#

[.no-hyphens]#_(cloud-events-default-subject)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-type*#

[.no-hyphens]#_(cloud-events-default-type)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*cloud-events-type*#

[.no-hyphens]#_(cloud-events-default-type)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*connect-timeout*#

[.no-hyphens]#_(amqp-connect-timeout)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*connect-timeout*#

[.no-hyphens]#_(amqp-connect-timeout)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*container-id*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*container-id*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*credit-retrieval-period*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*credit-retrieval-period*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*durable*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*durable*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*failure-strategy*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*failure-strategy*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*health-timeout*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*health-timeout*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*host*#

[.no-hyphens]#_(amqp-host)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*host*#

[.no-hyphens]#_(amqp-host)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*link-name*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*link-name*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*merge*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*merge*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*password*#

[.no-hyphens]#_(amqp-password)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*password*#

[.no-hyphens]#_(amqp-password)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*port*#

[.no-hyphens]#_(amqp-port)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*port*#

[.no-hyphens]#_(amqp-port)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*reconnect-attempts*#

[.no-hyphens]#_(amqp-reconnect-attempts)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*reconnect-attempts*#

[.no-hyphens]#_(amqp-reconnect-attempts)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*reconnect-interval*#

[.no-hyphens]#_(amqp-reconnect-interval)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*reconnect-interval*#

[.no-hyphens]#_(amqp-reconnect-interval)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*sni-server-name*#

[.no-hyphens]#_(amqp-sni-server-name)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*sni-server-name*#

[.no-hyphens]#_(amqp-sni-server-name)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*tracing-enabled*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*tracing-enabled*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*ttl*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*ttl*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*use-anonymous-sender*#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*use-anonymous-sender*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*use-ssl*#

[.no-hyphens]#_(amqp-use-ssl)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*use-ssl*#

[.no-hyphens]#_(amqp-use-ssl)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*username*#

[.no-hyphens]#_(amqp-username)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*username*#

[.no-hyphens]#_(amqp-username)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*virtual-host*#

[.no-hyphens]#_(amqp-virtual-host)_#</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[.no-hyphens]#*virtual-host*#

[.no-hyphens]#_(amqp-virtual-host)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Jekyll static site generator docs](https://jekyllrb.com/docs/).
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[Jekyll 静态站点生成器文档](https://jekyllrb.com/docs/).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[NOTE]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[注意]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{graalvm-flavor}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{graalvm-flavor}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{graalvm-version}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{graalvm-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-archive-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-archive-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-base-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-base-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-blob-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-blob-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-chat-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-chat-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-clone-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-clone-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-home-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-hom-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-images-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-images-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-issues-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-issues-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-mailing-list-index}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-mailing-list-index}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-mailing-list-subscription-email}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-mailing-list-subscription-email}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-org-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-org-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-site-getting-started}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-site-getting-started}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-tree-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-tree-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quarkus-version}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quarkus-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quickstarts-archive-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quickstarts-archive-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quickstarts-base-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quickstarts-base-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quickstarts-blob-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quickstarts-blob-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quickstarts-clone-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quickstarts-clone-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{quickstarts-tree-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\{quickstarts-tree-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_For more information about how to install the Quarkus CLI and use it, please refer to xref:cli-tooling.adoc[the Quarkus CLI guide]._</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_关于如何安装并使用Quarkus CLI并的更多信息，请参考xref:cli-tooling.adoc[Quarkus CLI指南]。_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> _Mutiny_ verticle - 扩展的Java类 `io.smallrye.mutiny.vertx.core.AbstractVerticle` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Please test this carefully on compilation to native images and fallback to Java-compatible Jackson bindings if you experience problems._</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_请在编译到native-image时仔细测试，如果遇到问题，请退回到与Java兼容的Jackson binding。_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Reactive_ is a set of principles to build robust, efficient, and concurrent applications and systems.
These principles let you handle more load than traditional approaches while using the resources (CPU and memory) more efficiently while also reacting to failures gracefully.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_Reactive_ 是一组用于构建健壮、高效且并发的应用程序和系统的原则。 这些原则使您可以处理比传统方法更多的负载，同时更有效地使用资源（CPU 和内存），同时还可以优雅地对故障做出反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Reactive_ is a set of principles to build robust, efficient, and concurrent applications and systems.  These principles let you handle more load than traditional approaches while using the resources (CPU and memory) more efficiently while also reacting to failures gracefully.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_Reactive_ 是一组用于构建健壮、高效且并发的应用程序和系统的原则。 这些原则使您可以处理比传统方法更多的负载，同时更有效地使用资源（CPU 和内存），同时还可以优雅地对故障做出反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>__On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified (see Constructors).__</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>__在JVM上，如果生成的类需要有一个无参数的构造函数，就必须为所有属性指定默认值（见构造函数）。__</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_bare_ verticle - 延伸的Java类 `io.vertx.core.AbstractVerticle` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_deprecated_ - During the readiness health check, the connector connects to the broker and retrieves the list of topics. This attribute specifies the maximum duration (in ms) for the retrieval. If exceeded, the channel is considered not-ready. Deprecated: Use 'health-topic-verification-timeout' instead.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_已废弃_ - 在就绪状态健康检查期间，连接器会连接到broker并获取主题列表。这个属性指定了获取操作的最大耗时（ms）。如果超时，通道会被认为是没有就绪的。已废弃：使用'health-topic-verification-timeout'代替。

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_deprecated_ - Whether the readiness check should verify that topics exist on the broker. Default to false. Enabling it requires an admin connection. Deprecated: Use 'health-topic-verification-enabled' instead.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_已废弃_ - 就绪检查是否应该验证broker上是否存在主题。默认为false。启用它需要一个管理员连接。已废弃：请使用 'health-topic-verification-enabled' 代替。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/vertx/book` returns the content from a large file (a book)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/vertx/book` 返回一个大文件的内容（一本书）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/vertx/hello` uses the Vert.x event bus to produce the response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/vertx/hello` 使用Vert.x事件总线来生成响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/vertx/lorem` returns the content from a small file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/vertx/lorem` 返回一个小文件的内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/vertx/web` uses the Vert.x Web Client to retrieve data from Wikipedia</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/vertx/web` 使用Vert.x Web客户端从维基百科中检索数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`0`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`0`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`0` will result in the use of a random port (assigned by the operating system).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置为 `0` 则会使用随机端口（由操作系统分配）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`1000`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`1000` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`100`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`100` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`10`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`10` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`2000`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`2000` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`3`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`3` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`5672`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`5672` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;T&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;query&gt;` will expand to `delete from EntityName where &lt;query&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;query&gt;` 语句会被扩展为： `delete from EntityName where &lt;query&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;query&gt;` will expand to `from EntityName where &lt;query&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;query&gt;` 语句会被扩展为： `from EntityName where &lt;query&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;query&gt;` will expand to `{&lt;query&gt;}` where we will map the PanacheQL query to MongoDB native query form. We support the following operators that will be mapped to the corresponding MongoDB operators: 'and', 'or' ( mixing 'and' and 'or' is not currently supported), '=', '&gt;', '&gt;=', '&lt;', '&lt;=', '!=', 'is null', 'is not null', and 'like' that is mapped to the MongoDB `$regex` operator (both String and JavaScript patterns are supported).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;query&gt;` 将扩展到 ，在这里我们将把PanacheQL查询映射到MongoDB原生查询形式。我们支持以下运算符，它们将被映射为相应的MongoDB运算符：'and'、 'or'（目前不支持 'and' 和 'or'一起使用）、'='、'&gt;'、'&gt;='、 '&lt;'、'&lt;='、'!='、'is null'、'is not null' 和 'like' 映射到 MongoDB `regex` 运算符（支持字符串和 JavaScript 模式）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;singleColumnName&gt;` (and single parameter) which will expand to `delete from EntityName where &lt;singleColumnName&gt; = ?`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `&lt;singleColumnName&gt;` (带单个参数）语句会被扩展为： `delete from EntityName where &lt;singleColumnName&gt; = ?` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;singleColumnName&gt;` (and single parameter) which will expand to `from EntityName where &lt;singleColumnName&gt; = ?`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;singleColumnName&gt;` (带单个参数）语句会被扩展为： `from EntityName where &lt;singleColumnName&gt; = ?` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;singlePropertyName&gt;` (and single parameter) which will expand to `{'singleColumnName': '?1'}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;singlePropertyName&gt;` (和单一参数），这将扩展为 `{'singleColumnName': '?1'}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;singlePropertyName&gt;` (and single parameter) which will expand to the update document `{'$set' : {'singleColumnName': '?1'}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;singlePropertyName&gt;` (和单一参数），这将扩展到更新文档 `{'$set' : {'singleColumnName': '?1'}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;suppress until="2022-01-01Z"&gt;...&lt;/suppress&gt;`
You can adjust the expiry date if you need to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;suppress until="2022-01-01Z"&gt;...&lt;/suppress&gt;`
如果需要您可以调整过期时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;suppress until="2022-01-01Z"&gt;...&lt;/suppress&gt;`
You can adjust the expiry date if you need to.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;suppress until="2022-01-01Z"&gt;...&lt;/suppress&gt;`
如果需要您可以调整过期时间。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;suppress until="2022-01-01Z"&gt;...&lt;/suppress&gt;` You can adjust the expiry date if you need to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;suppress until="2022-01-01Z"&gt;...&lt;/suppress&gt;`
如果需要您可以调整过期时间。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped`, `@Singleton` and `@RequestScoped` outer bean injection scopes are all supported when an `org.eclipse.microprofile.jwt.JsonWebToken` is injected, with the `@RequestScoped` scoping for `JsonWebToken` enforced to ensure the current token is represented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里 `@ApplicationScoped` , `@Singleton` 和 `@RequestScoped` 外层Bean注入作用域在注入 `org.eclipse.microprofile.jwt.JsonWebToken` 时都是被支持的， `@RequestScoped` 作用域对 `JsonWebToken` 强制执行，以确保当前令牌被呈现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@BsonId`: allows you to customize the ID field, see &lt;&lt;custom-ids,Custom IDs&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@BsonId` ：允许你自定义ID字段，见 link:#custom-ids[自定义ID] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@BsonIgnore`: ignore a field during the serialization.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@BsonIgnore` ：在序列化过程中忽略一个字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@BsonProperty`: customize the serialized name of the field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@BsonProperty` ：自定义字段的序列化名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@InjectKafkaCompanion` injects the `KafkaCompanion` instance, configured to access the Kafka broker created for tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@InjectKafkaCompanion` 注入了 `KafkaCompanion` 实例，并被配置为可访问为测试目的而创建的Kafka broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@InjectMock` results in a mock being and is available in test methods of the test class (other test classes are *not* affected by this)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@InjectMock` 可以生成一个mock并使其在测试类的所有测试方法中可用（其他测试 类*不受* 此影响）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusIntegrationTest` should be used to launch and test the artifact produced by the Quarkus build, and supports testing a jar (of whichever type), a native image or container image.
Put simply, this means that if the result of a Quarkus build (`mvn package` or `gradle build`) is a jar, that jar will be launched as `java -jar ...` and tests run against it.
If instead a native image was built, then the application is launched as `./application ...` and again the tests run against the running application.
Finally, if a container image was created during the build (by including the `quarkus-container-image-jib` or `quarkus-container-image-docker` extensions and having the
`quarkus.container-image.build=true` property configured), then a container is created and run (this requires the `docker` executable being present).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusIntegrationTest` 应该被用来启动和测试由Quarkus构建产生的物件，而且支持测试一个jar（无论哪种类型），一个本地镜像或容器镜像。简单地说，这意味着如果Quarkus构建（ `mvn package` 或者 `gradle build`）的结果是一个jar，这个jar将以 `java -jar ...` 方式启动 ，并针对它运行测试。如果构建的是一个本地镜像，那么应用程序将以 `./application ...` 方式启动，并再次针对运行中的应用程序进行测试。最后，如果在构建过程中创建了一个容器镜像（通过引入 `quarkus-container-image-jib` 或 `quarkus-container-image-docker` 扩展并使用了 `quarkus.container-image.build=true` 属性），那么将创建并运行一个容器（这需要 `docker` 可执行文件的存在）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusIntegrationTest` should be used to launch and test the artifact produced by the Quarkus build, and supports testing a jar (of whichever type), a native image or container image.  Put simply, this means that if the result of a Quarkus build (`mvn package` or `gradle build`) is a jar, that jar will be launched as `java -jar ...` and tests run against it.  If instead a native image was built, then the application is launched as `./application ...` and again the tests run against the running application.  Finally, if a container image was created during the build (by including the `quarkus-container-image-jib` or `quarkus-container-image-docker` extensions and having the `quarkus.container-image.build=true` property configured), then a container is created and run (this requires the `docker` executable being present).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusIntegrationTest` 应该被用来启动和测试由Quarkus构建产生的物件，而且支持测试一个jar（无论哪种类型），一个本地镜像或容器镜像。简单地说，这意味着如果Quarkus构建（ `mvn package` 或者 `gradle build`）的结果是一个jar，这个jar将以 `java -jar ...` 方式启动 ，并针对它运行测试。如果构建的是一个本地镜像，那么应用程序将以 `./application ...` 方式启动，并再次针对运行中的应用程序进行测试。最后，如果在构建过程中创建了一个容器镜像（通过引入 `quarkus-container-image-jib` 或 `quarkus-container-image-docker` 扩展并使用了 `quarkus.container-image.build=true` 属性），那么将创建并运行一个容器（这需要 `docker` 可执行文件的存在）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusIntegrationTest` supports executing tests against an already running instance of the application. This can be achieved by setting the
`quarkus.http.test-host` system property when running the tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusIntegrationTest` 支持对已经在运行的应用程序实例执行测试。这可以通过在运行测试时设置 `quarkus.http.test-host` 属性来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusIntegrationTest` supports executing tests against an already running instance of the application. This can be achieved by setting the `quarkus.http.test-host` system property when running the tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusIntegrationTest` 支持对已经在运行的应用程序实例执行测试。这可以通过在运行测试时设置 `quarkus.http.test-host` 属性来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusTest` has support for hang detection to help diagnose any unexpected hangs. If no progress is made for a specified
time (i.e. no JUnit callbacks are invoked) then Quarkus will print a stack trace to the console to help diagnose the hang.
The default value for this timeout is 10 minutes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusTest` 支持挂起侦测，以帮助诊断任何意外的挂起。如果在指定的时间内没有进展（即没有调用JUnit回调），那么Quarkus将打印一个堆栈跟踪到控制台以帮助诊断挂起。这个超时的默认值是10分钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusTest` has support for hang detection to help diagnose any unexpected hangs. If no progress is made for a specified time (i.e. no JUnit callbacks are invoked) then Quarkus will print a stack trace to the console to help diagnose the hang.  The default value for this timeout is 10 minutes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusTest` 支持挂起侦测，以帮助诊断任何意外的挂起。如果在指定的时间内没有进展（即没有调用JUnit回调），那么Quarkus将打印一个堆栈跟踪到控制台以帮助诊断挂起。这个超时的默认值是10分钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@RestStreamElementType(MediaType.APPLICATION_JSON)` tells RESTEasy Reactive to serialize the object in JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RestStreamElementType(MediaType.APPLICATION_JSON)` 告诉RESTEasy Reactive将对象序列化为JSON格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(MANDATORY)`: fails if no transaction was started ; works within the existing transaction otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(MANDATORY)` ：如果没有启动任何事务，则失败；否则在现有事务中工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(NEVER)`: if a transaction was started, raises an exception ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(NEVER)` :如果一个事务被启动，引发一个异常；否则在没有事务的情况下工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(NOT_SUPPORTED)`: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(NOT_SUPPORTED)` 暂停事务：如果一个事务已经开始，则暂停事务，并在方法的边界内不使用事务；否则不使用事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRED)` (default): starts a transaction if none was started, stays with the existing one otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(REQUIRED)` (默认）：如果当前没有事务，则启动一个事务，否则保持现有的事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRES_NEW)`: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(REQUIRES_NEW)` ：如果当前没有事务，则启动一个事务；如果已经启动了一个事务，则暂停该事务，并从该方法的边界开始重新启动一个新事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(SUPPORTS)`: if a transaction was started, joins it ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(SUPPORTS)` :如果一个事务已经开始，则加入它；否则在没有事务的情况下工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.
That includes REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional` 可以用来在方法层或类层控制任何CDI bean的事务边界，以确保每个方法都是事务性的。这包括REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.  That includes REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional` 可以用来在方法层或类层控制任何CDI bean的事务边界，以确保每个方法都是事务性的。这包括REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ANY`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ANY`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Authorization`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Authorization`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bearer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Bearer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`CompletionStage` (from the JDK)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CompletionStage` (来自JDK)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ConsumerRecord` is provided by the underlying Kafka client and can be injected directly to the consumer method.
Another simpler approach consists in using `Record`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ConsumerRecord` 由底层Kafka client提供，并且可以直接注入到consumer method中。另一种更简单的方法是使用  `Record`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ConsumerRecord` is provided by the underlying Kafka client and can be injected directly to the consumer method.  Another simpler approach consists in using `Record`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ConsumerRecord` 由底层Kafka client提供，并且可以直接注入到consumer method中。另一种更简单的方法是使用  `Record`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Cron expression configured in application.properties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Cron expression configured in application.properties` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Cron expression hardcoded`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Cron expression hardcoded` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`CustomResource` would be activated on a `@QuarkusIntegrationTest` using `@QuarkusTestResource` as is described in the corresponding section of this doc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CustomResource` 将在 `@QuarkusIntegrationTest` 上通过使用 `@QuarkusTestResource` 激活，就如本文档对应部分所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Fixed Rate expression configured in application.properties` These messages indicate that the executions of methods annotated with `@Scheduled` have been triggered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Fixed Rate expression configured in application.properties` 这些消息表明使用 `@Scheduled` 注解标注的方法执行都已经被触发了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Fixed Rate expression`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Fixed Rate expression` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` converts the authentication credentials provided by `HttpAuthenticationMechanism` to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`IdentityProvider` 将 `HttpAuthenticationMechanism` 提供的认证凭证转换为 `SecurityIdentity` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` verifies the authentication credentials and maps them to `SecurityIdentity`, which has the username, roles, original authentication credentials, and other attributes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`IdentityProvider` 会验证认证凭证并将其映射到 `SecurityIdentity` ，其中包含用户名、角色、原始认证凭证和其他属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Instant` or `UUID`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Instant` 或 `UUID` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`JsonObject` can be used to map an object into its JSON representation and build an object from a JSON document:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`JsonObject` 可用于将一个对象映射到其JSON表示中，并从JSON文档中建立一个对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`KeycloakTestResourceLifecycleManager` registers `alice` and `admin` users. The user `alice` has the `user` role only by default - it can be customized with a `keycloak.token.user-roles` system property. The user `admin` has the `user` and `admin` roles by default - it can be customized with a `keycloak.token.admin-roles` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KeycloakTestResourceLifecycleManager` 注册 `alice` 和 `admin` 用户。默认情况下，用户 `alice` 仅具有 `user` 角色 - 可以使用 `keycloak.token.user-roles` 系统属性对其进行自定义。默认情况下，用户 `admin` 具有 `用户` 和 `admin` 角色 - 可以使用 `keycloak.token.admin-roles` 系统属性对其进行自定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`List`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`List` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ObjectId` can be difficult to use if you want to expose its value in your REST service.
So we created Jackson and JSON-B providers to serialize/deserialize them as a `String` which are automatically registered if your project depends on either the RESTEasy Reactive Jackson extension or the RESTEasy Reactive JSON-B extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想在 REST 服务中公开它的值，则 `ObjectId` 可能很难使用。因此，我们创建了 Jackson 和 JSON-B 提供程序，将它们序列化为 `String` ，如果您的项目依赖于 RESTEasy Reactive Jackson 扩展或 RESTEasy Reactive JSON-B 扩展，则会自动注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ObjectId` can be difficult to use if you want to expose its value in your REST service.  So we created Jackson and JSON-B providers to serialize/deserialize them as a `String` which are automatically registered if your project depends on either the RESTEasy Reactive Jackson extension or the RESTEasy Reactive JSON-B extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想在 REST 服务中公开它的值，则 `ObjectId` 可能很难使用。因此，我们创建了 Jackson 和 JSON-B 提供程序，将它们序列化为 `String` ，如果您的项目依赖于 RESTEasy Reactive Jackson 扩展或 RESTEasy Reactive JSON-B 扩展，则会自动注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`OidcWiremockTestResource` does not work with `@QuarkusIntegrationTest` against Docker containers, because the Wiremock server is running in the JVM running the test, which cannot be accessed from the Docker container running the Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OidcWiremockTestResource` 不适用于针对Docker容器的 `@QuarkusIntegrationTest` ，因为Wiremock服务器在运行测试的JVM中运行，无法被在Docker容器中运行的Quarkus应用程序访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`OutgoingKafkaRecordMetadata` allows to set metadata attributes of the Kafka record, such as `key`, `topic`, `partition` or `timestamp`.
One use case is to dynamically select the destination topic of a message.
In this case, instead of configuring the topic inside your application configuration file, you need to use the outgoing metadata to set the name of the topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OutgoingKafkaRecordMetadata` 允许您设置Kafka记录的元数据属性，如 `key` ， `topic` ， `partition` 或 `timestamp` 。一种场景是动态地选择消息的目标topic。在这种情况下，您需要使用出站元数据(outgoing metadata)来设置topic名称，而不是在配置文件中配置topic。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`OutgoingKafkaRecordMetadata` allows to set metadata attributes of the Kafka record, such as `key`, `topic`, `partition` or `timestamp`.  One use case is to dynamically select the destination topic of a message.  In this case, instead of configuring the topic inside your application configuration file, you need to use the outgoing metadata to set the name of the topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OutgoingKafkaRecordMetadata` 允许您设置Kafka记录的元数据属性，如 `key` ， `topic` ， `partition` 或 `timestamp` 。一种场景是动态地选择消息的目标topic。在这种情况下，您需要使用出站元数据(outgoing metadata)来设置topic名称，而不是在配置文件中配置topic。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`PanacheQuery` also allows range-based queries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PanacheQuery` 也允许基于范围的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Publisher` (from Reactive-Streams)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Publisher` (来自Reactive-Streams)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`QuarkusTestResourceLifecycleManager` implementations can also implement `ContextAware` to get access to these properties,
which allows you to set up the resource before Quarkus starts (e.g. configure a KeyCloak instance, add data to a database etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusTestResourceLifecycleManager` 实现也可以实现 `ContextAware` 接口，以获得对这些属性的访问，这允许您在Quarkus启动之前来配置资源（例如，配置一个KeyCloak实例，向数据库添加数据等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`QuarkusTestResourceLifecycleManager` implementations can also implement `ContextAware` to get access to these properties, which allows you to set up the resource before Quarkus starts (e.g. configure a KeyCloak instance, add data to a database etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusTestResourceLifecycleManager` 实现也可以实现 `ContextAware` 接口，以获得对这些属性的访问，这允许您在Quarkus启动之前来配置资源（例如，配置一个KeyCloak实例，向数据库添加数据等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`REQUIRED` or `NOT_SUPPORTED` are probably the most useful ones.
This is how you decide whether a method is to be running within or outside a transaction.
Make sure to check the JavaDoc for the precise semantic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`REQUIRED` 或 `NOT_SUPPORTED` 可能是最有用的。它们决定一个方法是在事务内还是事务外运行。请确保查看JavaDoc以了解准确的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`REQUIRED` or `NOT_SUPPORTED` are probably the most useful ones.  This is how you decide whether a method is to be running within or outside a transaction.  Make sure to check the JavaDoc for the precise semantic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`REQUIRED` 或 `NOT_SUPPORTED` 可能是最有用的。它们决定一个方法是在事务内还是事务外运行。请确保查看JavaDoc以了解准确的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`RS256`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RS256`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ReactiveGreetingResource.kt` looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingResource.kt` 看起来像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Record` is a simple wrapper around key and payload of the incoming Kafka record.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Record` 提供了对接收到的Kafka record中key和payload的简单的包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`T`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`T` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`accept` - this strategy marks the AMQP message as _accepted_. The processing continues ignoring the failure.
Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[accepted delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`accept` - 这个策略将AMQP消息标记为 _accepted_ 。处理会继续进忽略失败的情况。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[接受交付状态的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`accept` - this strategy marks the AMQP message as _accepted_. The processing continues ignoring the failure.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[accepted delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`accept` - 这个策略将AMQP消息标记为 _accepted_ 。处理会继续进忽略失败的情况。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[接受交付状态的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`amount &gt; ?1 and firstname != ?2` will be mapped to `{'amount': {'$gt': ?1}, 'firstname': {'$ne': ?2}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`amount &gt; ?1 and firstname != ?2` 将被映射到 `{'amount': {'$gt': ?1}, 'firstname': {'$ne': ?2}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`andAwait` 方法，例如 `sendAndAwait`。 `andAwait` 表示调用方线程被阻塞，直到结果可用。注意不要用这种方式阻塞事件循环/ IO线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`andForget` 方法，如 `writeAndForget`。 `andForget` 可用于返回 `Uni` 的方法。  `andForget` 表示你不需要结果的 `Uni` 来表示操作的成功或失败。但是请记住，如果您不订阅，操作将不会被触发。  `andForget` 为您管理这个和管理订阅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`announcement` used for general announcement with some impact.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`announcement` 用于具有一定影响的一般公告。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`binary`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`binary` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`bootstrap-example.sh` - example bootstrap script for native deployments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `bootstrap-example.sh` - 用于原生部署的bootstrap脚本示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`byte[]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`byte[]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`cacerts` must be added to `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必须将 `cacerts` 添加到 `function.zip` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`client-credentials`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`client-credentials`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`dead-letter-queue.key.serializer`: the serializer used to write the record key on the dead letter queue. By default, it deduces the serializer from the key deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dead-letter-queue.key.serializer` 该序列化器用来对记录到dead letter queue中的record key进行序列化。默认情况下，该序列化器会从key的反序列化器反推出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`dead-letter-queue.topic`: the topic to use to write the records not processed correctly, default is `dead-letter-topic-$channel`, with `$channel` being the name of the channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dead-letter-queue.topic` : 该topic用来保存未被正确处理的记录，默认为 `dead-letter-topic-$channel` ， `$channel` 是channel的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`dead-letter-queue.value.serializer`: the serializer used to write the record value on the dead letter queue. By default, it deduces the serializer from the value deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dead-letter-queue.value.serializer` :该序列化器用来对记录到dead letter queue中的record value进行序列化。默认情况下，该序列化器会从value的反序列化器反推出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`dead-letter-queue`: the offset of the record that has not been processed correctly is committed, but the record is written to a Kafka dead letter topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dead-letter-queue` ：未被正确处理的记录的偏移量会被提交，但该记录会被写入Kafka的dead letter topic。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`development-tips` used for blogs with tips to develop using Quarkus or Quarkus itself. 
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`development-tips` 用于带有使用Quarkus或Quarkus本身开发提示的博客。 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`double` and `java.lang.Double`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`double` 和 `java.lang.Double`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`emailhash` you can get by running `echo -n your@email.org | md5sum` on Linux or `echo -n your@email.org | md5` on macOS using an email you have registered from the [Gravatar service](https://gravatar.com),
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用您已经在 [Gravatar service](https://gravatar.com) 注册的电子邮件，在Linux运行 `echo -n your@email.org | md5sum` 或在macOS运行 `echo -n your@email.org | md5` 获得`emailhash` 。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`extension` used for blogs related to a specific extension.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`extension` 用于与特定扩展相关的博客。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fail` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail` - fail the application; no more AMQP messages will be processed (default).
The AMQP message is marked as rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fail` - 使应用失败；不再处理AMQP消息（默认）。AMQP消息被标记为拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail` - fail the application; no more AMQP messages will be processed (default).  The AMQP message is marked as rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fail` - 使应用失败；不再处理AMQP消息（默认）。AMQP消息被标记为拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail`: fail the application, no more records will be processed (default strategy). The offset of the record that has not been processed correctly is not committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fail` ：直接使程序失败，不再处理更多的记录(默认策略)。未被正确处理的记录的偏移量不会被提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`false`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`false` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`firstname = :firstname, status = :status` will be mapped to the update document `{'$set' : {'firstname': :firstname, 'status': :status}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`firstname = :firstname, status = :status` 将被映射到更新文档中 `{'$set' : {'firstname': :firstname, 'status': :status}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`firstname = ?1 and status = ?2` will be mapped to `{'firstname': ?1, 'status': ?2}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`firstname = ?1 and status = ?2` 将被映射到 `{'firstname': ?1, 'status': ?2}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`firstname = ?1, status = ?2` will be mapped to the update document `{'$set' : {'firstname': ?1, 'status': ?2}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`firstname = ?1, status = ?2` 将被映射到更新文档中 `{'$set' : {'firstname': ?1, 'status': ?2}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`float` and `java.lang.Float`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`float` 和 `java.lang.Float`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`from EntityName ...` which will expand to `delete from EntityName ...`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`from EntityName ...​` 语句会被扩展为： `delete from EntityName ...​` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`from EntityName ...` which will expand to `update from EntityName ...`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`from EntityName ...​` 语句会被扩展为： `update from EntityName ...​` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`function.zip` - lambda deployment file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`function.zip` - lambda部署文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it's the regular
artifact produced by the Maven build - it is *not* the runnable jar;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - 它只包含项目的类和资源，是Maven构建时产生的常规组件——它是不可运行的jar。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it's the regular artifact produced by the Maven build - it is *not* the runnable jar;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - 它只包含项目的类和资源，是Maven构建时产生的常规组件——它是不可运行的jar。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ignore` performs no commit. This strategy is the default strategy when the consumer is explicitly configured with `enable.auto.commit` to true.
It delegates the offset commit to the underlying Kafka client.
When `enable.auto.commit` is `true` this strategy **DOES NOT** guarantee at-least-once delivery.
SmallRye Reactive Messaging processes records asynchronously, so offsets may be committed for records that have been polled but not yet processed.
In case of a failure, only records that were not committed yet will be re-processed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ignore` 不执行任何提交。当消费者的 `enable.auto.commit` 属性被明确配置为true时，该策略将是默认策略。它将偏移量的提交委托给底层Kafka client负责。当 `enable.auto.commit` 为true的时候 ，该策略 *不* 保证至少会有一次提交。SmallRye Reactive Messaging是异步处理记录的，所以那些已经被轮询但尚未处理的record的偏移量有可能会被提交。如果提交失败，只有那些尚未被提交的record才会被重新处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ignore` performs no commit. This strategy is the default strategy when the consumer is explicitly configured with `enable.auto.commit` to true.  It delegates the offset commit to the underlying Kafka client.  When `enable.auto.commit` is `true` this strategy **DOES NOT** guarantee at-least-once delivery.  SmallRye Reactive Messaging processes records asynchronously, so offsets may be committed for records that have been polled but not yet processed.  In case of a failure, only records that were not committed yet will be re-processed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ignore` 不执行任何提交。当消费者的 `enable.auto.commit` 属性被明确配置为true时，该策略将是默认策略。它将偏移量的提交委托给底层Kafka client负责。当 `enable.auto.commit` 为true的时候 ，该策略 *不* 保证至少会有一次提交。SmallRye Reactive Messaging是异步处理记录的，所以那些已经被轮询但尚未处理的record的偏移量有可能会被提交。如果提交失败，只有那些尚未被提交的record才会被重新处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ignore`: the failure is logged, but the processing continue. The offset of the record that has not been processed correctly is committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ignore` ：记录失败的日志，但消息处理将继续进行。没有被正确处理的记录的偏移量会被提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`incoming-costs` -&gt; a source that receives costs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`incoming-costs` → 接收成本的来源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`int` and `java.lang.Integer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`int` 和 `java.lang.Integer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterTestExecutionCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeTestExecutionCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.mongodb.MongoReplicaSetTestResource` will start a replicaset with two instances, one on port 27017 and the other on port 27018.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.mongodb.MongoReplicaSetTestResource` 将启动一个有两个实例的复制集，一个在27017端口，另一个在27018端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.mongodb.MongoTestResource` will start a single instance on port 27017.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.mongodb.MongoTestResource` 将在27017端口启动一个单一的实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-mailer` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-mailer` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-reactive-db2-client` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-reactive-db2-client` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-reactive-mssql-client` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-reactive-mssql-client` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-reactive-mysql-client` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-reactive-mysql-client` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-reactive-oracle-client` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-reactive-oracle-client` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-reactive-pg-client` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-reactive-pg-client` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-redis-client` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-redis-client` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-smallrye-reactive-messaging-amqp` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-smallrye-reactive-messaging-amqp` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-smallrye-reactive-messaging-kafka` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-smallrye-reactive-messaging-kafka` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-smallrye-reactive-messaging-mqtt` (extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-smallrye-reactive-messaging-mqtt` (扩展)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.jwt.auth.principal.DefaultJWTCallerPrincipalFactory` is used by default to parse and verify JWT tokens and convert them to `JsonWebToken` principals.
It uses `MP JWT` and `smallrye-jwt` properties listed in the `Configuration` section to verify and customize JWT tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.jwt.auth.principal.DefaultJWTCallerPrincipalFactory` 默认用于解析和验证JWT令牌，并将其转换为 `JsonWebToken`。它使用 `MP JWT` `smallrye-jwt` 这些在 `Configuration` 中列出的属性来验证和定制JWT令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.jwt.auth.principal.DefaultJWTCallerPrincipalFactory` is used by default to parse and verify JWT tokens and convert them to `JsonWebToken` principals.  It uses `MP JWT` and `smallrye-jwt` properties listed in the `Configuration` section to verify and customize JWT tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.jwt.auth.principal.DefaultJWTCallerPrincipalFactory` 默认用于解析和验证JWT令牌，并将其转换为 `JsonWebToken`。它使用 `MP JWT` `smallrye-jwt` 这些在 `Configuration` 中列出的属性来验证和定制JWT令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.mutiny.Multi` - 用于多条目(回压)流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.mutiny.Uni` - 用于提供0或1结果的异步操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-circuit-breaker` (external dependency)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-circuit-breaker` (外部依赖性)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client` (external dependency)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client` (外部依赖性)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client` (external dependency)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client` (外部依赖性)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-web-client` (external dependency)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-web-client` (外部依赖性)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.Vertx` instance exposing the _bare_ Vert.x API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.Vertx` 暴露了 _bare_ Vert.x API的实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.buffer.Buffer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.buffer.Buffer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.json.JsonArray`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.json.JsonArray`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.json.JsonObject`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.json.JsonObject`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.mutiny.core.Vertx` instance exposing the _Mutiny_ API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.mutiny.core.Vertx` 暴露 _Mutiny_ API的实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.mutiny.core.buffer.Buffer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.mutiny.core.buffer.Buffer` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.lang.String`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.lang.String`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.nio.ByteBuffer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.nio.ByteBuffer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.UUID`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.UUID`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.logging.manager` (see xref:logging.adoc[Logging Guide])</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.logging.manager` (见 link:logging.html[日志指南] )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`lastname is not null` will be mapped to `{'lastname':{'$exists': true}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`lastname is not null` 将被映射到 `{'lastname':{'$exists': true}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`lastname like ?1` will be mapped to `{'lastname': {'$regex': ?1}}`. Be careful that this will be link:https://docs.mongodb.com/manual/reference/operator/query/regex/#op._S_regex[MongoDB regex] support and not SQL like pattern.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`lastname like ?1` 将被映射到 `{'lastname': {'$regex': ?1}}` 。注意 link:https://docs.mongodb.com/manual/reference/operator/query/regex/#op._S_regex[MongoDB的regex] 支持，而不是类似SQL模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`latest` commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).
This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.
This strategy should not be used in high load environment, as offset commit is expensive. However, it reduces the risk of duplicates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`latest` 一旦关联消息被确认，Kafka消费者就会提交所接收到的record偏移量(前提是当前偏移量高于之前提交的偏移量)。如果channel在不执行任何异步处理的情况下处理消息的话，这种策略能保证至少一次提交。这种策略不推荐在高负载环境中使用，因为偏移量的提交很昂贵。但是它减少了消息重复提交的风险。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`latest` commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).  This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.  This strategy should not be used in high load environment, as offset commit is expensive. However, it reduces the risk of duplicates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`latest` 一旦关联消息被确认，Kafka消费者就会提交所接收到的record偏移量(前提是当前偏移量高于之前提交的偏移量)。如果channel在不执行任何异步处理的情况下处理消息的话，这种策略能保证至少一次提交。这种策略不推荐在高负载环境中使用，因为偏移量的提交很昂贵。但是它减少了消息重复提交的风险。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`libsunec.so` must be added to `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必须将 `libsunec.so` 添加到 `function.zip` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`localhost`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`localhost` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`long` and `java.lang.Long`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`long` 和 `java.lang.Long`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`manage.sh` - wrapper around aws lambda cli calls</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`manage.sh` - aws lambda cli调用的包装器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`manage.sh` 支持四种操作： `create`， `delete`， `update` 和 `invoke` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`manage.sh` supports four operation: `create`, `delete`, `update`, and `invoke`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`manage.sh` 支持四种操作： `create`， `delete`， `update` 和 `invoke` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`maven.home` (only if there are any custom settings in `${maven.home}/conf/settings.xml`, see xref:maven-tooling.adoc[Maven Guide])</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`maven.home` (仅当 `${maven.home}/conf/settings.xml` 中有自定义设置时，见link:maven-tooling.html[Maven指南] )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`maven.settings` (以备在测试中使用自定义的 `settings.xml` 文件)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`modified-failed-undeliverable-here` - this strategy marks the AMQP message as _modified_ and indicates that it failed (with the `delivery-failed` attribute). It also indicates that the application cannot process the message, meaning that the broker will not attempt to redeliver the message to this node. The processing continues with the next message.
Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[modified delivery state documentation]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`modified-failed-undeliverable-here` - 这个策略将AMQP消息标记为 _modified_ ，并指出它失败了（使用 `delivery-failed` 属性）。它还表示应用程序不能处理该消息，这意味着代理不会试图将该消息重新交付给这个节点。继续处理下一条消息。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[修改后的交付状态的文档]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`modified-failed-undeliverable-here` - this strategy marks the AMQP message as _modified_ and indicates that it failed (with the `delivery-failed` attribute). It also indicates that the application cannot process the message, meaning that the broker will not attempt to redeliver the message to this node. The processing continues with the next message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[modified delivery state documentation]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`modified-failed-undeliverable-here` - 这个策略将AMQP消息标记为 _modified_ ，并指出它失败了（使用 `delivery-failed` 属性）。它还表示应用程序不能处理该消息，这意味着代理不会试图将该消息重新交付给这个节点。继续处理下一条消息。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[修改后的交付状态的文档]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`modified-failed` - this strategy marks the AMQP
message as _modified_ and indicates that it failed (with the `delivery-failed` attribute). The processing continues with the next message, but the broker may attempt to redeliver the message.
Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[modified delivery state documentation]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`modified-failed` - 这个策略将AMQP消息标记为 _modified_ ，并指出它失败了（使用 `delivery-failed` 属性）。继续处理下一条消息，但代理可能会尝试重新交付该消息。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[修改后的交付状态的文档]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`modified-failed` - this strategy marks the AMQP message as _modified_ and indicates that it failed (with the `delivery-failed` attribute). The processing continues with the next message, but the broker may attempt to redeliver the message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[modified delivery state documentation]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`modified-failed` - 这个策略将AMQP消息标记为 _modified_ ，并指出它失败了（使用 `delivery-failed` 属性）。继续处理下一条消息，但代理可能会尝试重新交付该消息。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[修改后的交付状态的文档]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mongo+srv://` urls are supported out of the box in JVM mode.
However, in native, the default DNS resolver, provided by the MongoDB client, uses JNDI and does not work in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mongo+srv://` urls在JVM模式下支持开箱即用。然而，在本地模式下，MongoDB客户端提供的默认DNS解析器使用的是JNDI，在本地模式下无法工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mongo+srv://` urls are supported out of the box in JVM mode.  However, in native, the default DNS resolver, provided by the MongoDB client, uses JNDI and does not work in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mongo+srv://` urls在JVM模式下支持开箱即用。然而，在本地模式下，MongoDB客户端提供的默认DNS解析器使用的是JNDI，在本地模式下无法工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.{property}=value`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.{property}=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.connector.smallrye-kafka.apicurio.registry.url` is configured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.connector.smallrye-kafka.apicurio.registry.url` 已配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.connector.smallrye-kafka.schema.registry.url` is configured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.connector.smallrye-kafka.schema.registry.url` 已配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`order by ...` which will expand to `from EntityName order by ...`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`order by ...` 语句会被扩展为： `from EntityName order by ...` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.clients`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.clients`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.common.metrics`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.common.metrics`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.common.utils.Bytes`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.common.utils.Bytes`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.common.utils`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.common.utils`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`outgoing-costs` -&gt; a sink that receives converted costs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`outgoing-costs` → 接收转换成本的接收器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`password`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`password`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`publish` a message to a specific address - all consumers receive the messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`publish` 向一个特定的地址发送消息--所有的消费者都会收到这些消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-elytron-security-oauth2` provides an alternative to the `quarkus-oidc` Bearer Token authentication mechanism. `quarkus-elytron-security-oauth2` is based on `Elytron` and is primarily intended for introspecting opaque tokens remotely.
For more information, see xref:security-oauth2.adoc[Using OAuth2].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-elytron-security-oauth2` 提供了一个替代 `quarkus-oidc` Bearer Token认证机制的方法。它基于 `Elytron` 并且主要是为了对不透明的token进行远程自我检查。更多信息请参见 link:security-oauth2.html[使用OAuth2] 指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-elytron-security-oauth2` provides an alternative to the `quarkus-oidc` Bearer Token authentication mechanism. `quarkus-elytron-security-oauth2` is based on `Elytron` and is primarily intended for introspecting opaque tokens remotely.  For more information, see xref:security-oauth2.adoc[Using OAuth2].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-elytron-security-oauth2` 提供了一个替代 `quarkus-oidc` Bearer Token认证机制的方法。它基于 `Elytron` 并且主要是为了对不透明的token进行远程自我检查。更多信息请参见 link:security-oauth2.html[使用OAuth2] 指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.
`rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically
sets the correct URL so no configuration is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-junit5` 是测试所必需的，因为它提供 `@QuarkusTest` 注解来控制测试框架。而 `rest-assured` 不是必需的，但它是测试HTTP节点的一种便捷方式，我们还集成对自动设置正确URL的支持，因此不需要配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.  `rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically sets the correct URL so no configuration is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-junit5` 是测试所必需的，因为它提供 `@QuarkusTest` 注解来控制测试框架。而 `rest-assured` 不是必需的，但它是测试HTTP节点的一种便捷方式，我们还集成对自动设置正确URL的支持，因此不需要配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` and `quarkus-smallrye-jwt` support the injecting of JWT and opaque tokens into the endpoint code.
Injected JWT tokens provide more information about the user. All extensions can have the tokens injected as `Principal`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` 和 `quarkus-smallrye-jwt` 支持将JWT和不透明的token都注入到节点代码中。注入的JWT token可以提供更丰富的用户信息。所有的扩展都可以将 token 以 `Principal` 的形式注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` and `quarkus-smallrye-jwt` support the injecting of JWT and opaque tokens into the endpoint code.  Injected JWT tokens provide more information about the user. All extensions can have the tokens injected as `Principal`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` 和 `quarkus-smallrye-jwt` 支持将JWT和不透明的token都注入到节点代码中。注入的JWT token可以提供更丰富的用户信息。所有的扩展都可以将 token 以 `Principal` 的形式注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` provides `quarkus.oidc.TokenIntrospectionCache` and `quarkus.oidc.UserInfoCache` interfaces which can be used to implement `@ApplicationScoped` cache implementation which can be used to store and retrieve `quarkus.oidc.TokenIntrospection` and/or `quarkus.oidc.UserInfo` objects, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` 提供 `quarkus.oidc.TokenIntrospectionCache` 和 `quarkus.oidc.UserInfoCache` 接口，可用于实现 `@ApplicationScoped` 缓存实现，可用于存储和检索 `quarkus.oidc.TokenIntrospection` 和/或 `quarkus.oidc.UserInfo` 对象，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` requires an OpenID Connect provider such as Keycloak, which can be used to verify the Bearer tokens or authenticate the end users with the Authorization Code flow.
In both cases, `quarkus-oidc` requires a connection to the specified OpenID Connect provider.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` 扩展需要一个OpenID Connect提供者，如Keycloak，用以验证Bearer tokens或用Authorization Code flow验证终端用户。在这两种情况下 `quarkus-oidc` 需要连接到这个OpenID Connect提供者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` requires an OpenID Connect provider such as Keycloak, which can be used to verify the Bearer tokens or authenticate the end users with the Authorization Code flow.  In both cases, `quarkus-oidc` requires a connection to the specified OpenID Connect provider.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` 扩展需要一个OpenID Connect提供者，如Keycloak，用以验证Bearer tokens或用Authorization Code flow验证终端用户。在这两种情况下 `quarkus-oidc` 需要连接到这个OpenID Connect提供者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-release` used for Quarkus release blogs
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-release` 用于Quarkus发布博客
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-rest-client-reactive`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-rest-client-reactive`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-resteasy-reactive`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-resteasy-reactive`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-scheduler`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-scheduler`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-fault-tolerance`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-fault-tolerance`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` handles locally signed, inner-signed-and-encrypted, and encrypted tokens.
While `quarkus-oidc` and `quarkus-elytron-security-oauth2` can also verify such tokens but treats them as opaque tokens and verifies them through remote introspection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` 不仅可以在本地处理有签名的 token ，而且还可以处理内部签名并加密(inner-signed-and-encrypted)和单纯加密的 token 。事实上， `quarkus-oidc` 和 `quarkus-elytron-security-oauth2` 也可以验证这样的 token ，但只能把它们当作不透明的 token ，并通过远程自查来验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` handles locally signed, inner-signed-and-encrypted, and encrypted tokens.  While `quarkus-oidc` and `quarkus-elytron-security-oauth2` can also verify such tokens but treats them as opaque tokens and verifies them through remote introspection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` 不仅可以在本地处理有签名的 token ，而且还可以处理内部签名并加密(inner-signed-and-encrypted)和单纯加密的 token 。事实上， `quarkus-oidc` 和 `quarkus-elytron-security-oauth2` 也可以验证这样的 token ，但只能把它们当作不透明的 token ，并通过远程自查来验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` is an alternative to the `quarkus-oidc` Bearer Token authentication mechanism, and verifies only `JWT` tokens by using either PEM keys or the refreshable `JWK` key set.
`quarkus-smallrye-jwt` also provides the JWT generation API, which you can use to easily create `signed`, `inner-signed`, and `encrypted` `JWT` tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` 提供了一个替代 `quarkus-oidc` Bearer Token认证机制的方法，并且目前只能验证使用PEM密钥或可刷新的 `JWK` 密钥集的 `JWT` token。此外，`quarkus-smallrye-jwt` 还提供了 JWT generation API`，以便轻松创建 `signed` 、 `inner-signed` 和 `encrypted` `JWT` token。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` is an alternative to the `quarkus-oidc` Bearer Token authentication mechanism, and verifies only `JWT` tokens by using either PEM keys or the refreshable `JWK` key set.  `quarkus-smallrye-jwt` also provides the JWT generation API, which you can use to easily create `signed`, `inner-signed`, and `encrypted` `JWT` tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` 提供了一个替代 `quarkus-oidc` Bearer Token认证机制的方法，并且目前只能验证使用PEM密钥或可刷新的 `JWK` 密钥集的 `JWT` token。此外，`quarkus-smallrye-jwt` 还提供了 JWT generation API`，以便轻松创建 `signed` 、 `inner-signed` 和 `encrypted` `JWT` token。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` supports more key formats than `quarkus-oidc`.
`quarkus-oidc` uses only the JWK-formatted keys that are part of a JWK set, whereas `quarkus-smallrye-jwt` supports PEM keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` 比 `quarkus-oidc` 支持更多的密钥格式。后者只使用属于JWK集的JWK格式的密钥，反之前者还支持PEM密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` supports more key formats than `quarkus-oidc`.  `quarkus-oidc` uses only the JWK-formatted keys that are part of a JWK set, whereas `quarkus-smallrye-jwt` supports PEM keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` 比 `quarkus-oidc` 支持更多的密钥格式。后者只使用属于JWK集的JWK格式的密钥，反之前者还支持PEM密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` supports more key formats than `quarkus-oidc`. `quarkus-oidc` uses only the JWK-formatted keys that are part of a JWK set, whereas `quarkus-smallrye-jwt` supports PEM keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` 比 `quarkus-oidc` 支持更多的密钥格式。后者只使用属于JWK集的JWK格式的密钥，反之前者还支持PEM密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-reactive-messaging`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-reactive-messaging`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.amqp.devservices.enabled` is set to `false`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.amqp.devservices.enabled` 被设置为 `false` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.apicurio-registry.devservices.enabled` is set to `false`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.apicurio-registry.devservices.enabled` 设为 `false` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.container-image.build=true` 指示Quarkus使用最终的应用程序工件（在本例中是原生可执行文件）创建一个容器镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kafka.devservices.enabled` is set to `false`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kafka.devservices.enabled` 被设置为 `false`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.native.container-build=true` 允许在不安装GralVM的情况下创建一个Linux可执行文件（只有在你没有安装GralVM或者你的本地操作系统不是Linux的情况下才需要）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.oidc.client-id` property identifies an OpenID Connect Client which requested the current bearer token. It can be an SPA application running in a browser or a Quarkus `web-app` confidential client application propagating the access token to the Quarkus `service` application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.oidc.client-id` 属性标识请求当前持有者令牌的 OpenID Connect Client。它可以是在浏览器中运行的SPA应用程序，也可以是Quarkus `web-app` 机密客户端应用程序，将访问令牌传播到Quarkus `service` 的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.oidc.runtime.OidcProviderClient` is used when a remote request to an OpenID Connect Provider has to be done. If the bearer token has to be introspected then `OidcProviderClient` has to authenticate to the OpenID Connect Provider. Please see xref:security-openid-connect-web-authentication.adoc#oidc-provider-client-authentication[OidcProviderClient Authentication] for more information about all the supported authentication options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性 `quarkus.oidc.runtime.OidcProviderClient` 是在需要对OpenID连接提供者进行远程请求时使用的。如果必须对不记名令牌进行检查，那么 ，必须对OpenID Connect Provider进行认证。请参阅 `OidcProviderClient` link:security-openid-connect-web-authentication.html#oidc-provider-client-authentication[OidcProviderClient 认证] 以了解更多关于所支持认证选项的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.test.profile.tags=foo`: In this case none of tests will be executed because none of the tags defined on the `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`.
Note that `NoQuarkusProfileTest` is not executed either because it is not annotated with `@TestProfile`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.test.profile.tags=foo` :在这种情况下，所欧测试都不会被执行，因为在 `QuarkusTestProfile` 实现上定义的标签中没有一个与 `quarkus.test.profile.tags` 的值相匹配。注意， `NoQuarkusProfileTest` 也不会被执行，因为它没有 `@TestProfile` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.test.profile.tags=foo`: In this case none of tests will be executed because none of the tags defined on the `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`.  Note that `NoQuarkusProfileTest` is not executed either because it is not annotated with `@TestProfile`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.test.profile.tags=foo` :在这种情况下，所欧测试都不会被执行，因为在 `QuarkusTestProfile` 实现上定义的标签中没有一个与 `quarkus.test.profile.tags` 的值相匹配。注意， `NoQuarkusProfileTest` 也不会被执行，因为它没有 `@TestProfile` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.test.profile.tags=test1,test3`: This case results in the same tests being executed as the previous case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.test.profile.tags=test1,test3` :这种情况下，执行的测试与前一种情况相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.test.profile.tags=test1`: In this case `SingleTagTest` and `MultipleTagsTest` will be run because the tags on their respective `QuarkusTestProfile` implementations
match the value of `quarkus.test.profile.tags`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.test.profile.tags=test1` :在这种情况下， `SingleTagTest` 和 `MultipleTagsTest` 将被运行，因为它们各自的 `QuarkusTestProfile` 实现的标签与 `quarkus.test.profile.tags` 的值一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.test.profile.tags=test1`: In this case `SingleTagTest` and `MultipleTagsTest` will be run because the tags on their respective `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.test.profile.tags=test1` :在这种情况下， `SingleTagTest` 和 `MultipleTagsTest` 将被运行，因为它们各自的 `QuarkusTestProfile` 实现的标签与 `quarkus.test.profile.tags` 的值一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.test.profile.tags=test2,test3`: In this case only `MultipleTagsTest` will be run because `MultipleTagsTest` is the only `QuarkusTestProfile` implementation whose `tags` method
matches the value of `quarkus.test.profile.tags`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.test.profile.tags=test2,test3` :在这种情况下，只有 `MultipleTagsTest` 会被运行，因为 `MultipleTagsTest` 是唯一一个 `tags` 方法与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.test.profile.tags=test2,test3`: In this case only `MultipleTagsTest` will be run because `MultipleTagsTest` is the only `QuarkusTestProfile` implementation whose `tags` method matches the value of `quarkus.test.profile.tags`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.test.profile.tags=test2,test3` :在这种情况下，只有 `MultipleTagsTest` 会被运行，因为 `MultipleTagsTest` 是唯一一个 `tags` 方法与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.test.profile.tags` is not set: All tests will be executed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.test.profile.tags` 未被设置。所有的测试都将被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means
that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.
This works too for resource files like the configuration property file.
Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled
and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues
with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus:dev` 在开发模式下运行Quarkus。这使得后台编译的实时重载成为可能，这意味着当你修改你的Java文件或者资源文件并刷新你的浏览器时，这些变化将自动生效。这也适用于资源文件，如配置属性文件。刷新浏览器会触发对工作区的扫描，如果检测到任何变化，Java文件会被重新编译，应用程序会被重新部署；然后你的请求会被重新部署的应用程序提供服务。如果编译或部署有任何问题，错误页面会让你知道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus:dev` 在开发模式下运行Quarkus。这使得后台编译的实时重载成为可能，这意味着当你修改你的Java文件或者资源文件并刷新你的浏览器时，这些变化将自动生效。这也适用于资源文件，如配置属性文件。刷新浏览器会触发对工作区的扫描，如果检测到任何变化，Java文件会被重新编译，应用程序会被重新部署；然后你的请求会被重新部署的应用程序提供服务。如果编译或部署有任何问题，错误页面会让你知道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`refresh_token`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`refresh_token`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`reject` - this strategy marks the AMQP message as rejected. The processing continues with the next message.
Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected[rejected delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`reject` - 这个策略将该AMQP消息标记为拒绝。继续处理下一条消息。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected[被拒绝的交付状态的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`reject` - this strategy marks the AMQP message as rejected. The processing continues with the next message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected[rejected delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`reject` - 这个策略将该AMQP消息标记为拒绝。继续处理下一条消息。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected[被拒绝的交付状态的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`release` - this strategy marks the AMQP message as _released_. The processing continues with the next message. The broker can redeliver the message.
Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released[released delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`release` - 这个策略将AMQP消息标记为 _released_ 。继续处理下一条消息。代理可以重新交付消息。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released[被释放的交付状态的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`release` - this strategy marks the AMQP message as _released_. The processing continues with the next message. The broker can redeliver the message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released[released delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`release` - 这个策略将AMQP消息标记为 _released_ 。继续处理下一条消息。代理可以重新交付消息。请参考 link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released[被释放的交付状态的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`requestContext.authorizer.claims.cognito:username` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`requestContext.authorizer.iam.userId` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`requestContext.authorizer.lambda.principalId` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.principalId`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`requestContext.authorizer.principalId` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.identity.user`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`requestContext.identity.user` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`request` a message and expect a reply</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`request` 留言并期望得到回复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`resteasy-reactive-jackson`, which also brings `resteasy-reactive`. We are going to use it to expose our HTTP endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`resteasy-reactive-jackson` ，它也带来了 `resteasy-reactive` 。我们将使用它来暴露出我们的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.jvm.yaml` - (optional) for use with sam cli and local testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `sam.jvm.yaml` - (可选)用于sam cli和本地测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.jvm.yaml` - sam cli deployment script</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.jvm.yaml` - sam cli部署脚本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.native.yaml` - (optional) for use with sam cli and native local testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `sam.native.yaml` - (可选)，用于Sam cli和原生本地测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.native.yaml` - sam cli deployment script for native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.native.yaml` - sam cli的原生部署脚本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`send` a message to a specific address - one single consumer receives the message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`send` 一个消息到一个特定的地址 - 单个消费者收到该消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`set? &lt;singleColumnName&gt;` (and single parameter) which will expand to `update from EntityName set &lt;singleColumnName&gt; = ?`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`set? &lt;singleColumnName&gt;` (带单个参数）语句会被扩展为： `update from EntityName set &lt;singleColumnName&gt; = ?` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`set? &lt;update-query&gt;` will expand to `update from EntityName set &lt;update-query&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`set? &lt;update-query&gt;` 语句会被扩展为： `update from EntityName set &lt;update-query&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`short` and `java.lang.Short`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`short` 和 `java.lang.Short`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`status in ?1` will be mapped to `{'status':{$in: [?1]}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`status in ?1` 将被映射到 `{'status':{$in: [?1]}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`tags` should be used with some care as an archive page is created for of them. Below are some basic rules to try follow:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`tags` 应该谨慎使用，因为存档页面是为它们创建的。以下是一些你可以尝试遵循的基本规则：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`toBlockingIterable` / `toBlockingStream` 方法允许转换Vert.x `ReadStream` 写入阻塞的可迭代对象或阻塞的 `java.util.Stream`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`toMulti` 方法允许将一个 Vert.x `ReadStream` 转换为 `Multi`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`true` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`user-story` used for stories from users/companies adopting Quarkus.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`user-story` 用于用户/公司采用Quarkus的故事。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`vertx`, which provides access to the underlying managed Vert.x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`vertx` ，它提供了对底层管理的Vert.x的访问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{'firstname' : ?1, 'status' : ?2}` will be mapped to the update document `{'$set' : {'firstname': ?1, 'status': ?2}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{'firstname' : ?1, 'status' : ?2}` 将被映射到更新文档中 `{'$set' : {'firstname': ?1, 'status': ?2}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{'firstname' : firstname, 'status' : :status}` ` will be mapped to the update document `{'$set' : {'firstname': :firstname, 'status': :status}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{'firstname' : firstname, 'status' : :status}` `将被映射到更新文档中。 `{'$set' : {'firstname': :firstname, 'status': :status}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a landing page that is accessible on `http://localhost:8080` after starting the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动应用程序后，可在 `http://localhost:8080` 上访问登录页面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a message containing the _name_ is sent to the event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>含有该 _name_ 的消息被发送到事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a non-anonymous caller name of jdoe@quarkus.io</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个非匿名的呼叫者的名字是 jdoe@quarkus.io</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a non-null JsonWebToken</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个非空的JsonWebToken</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>accessing `/api/admin` will return `200`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问 `/api/admin` ，将返回 `200`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>accessing `/api/admin` will return `403`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问 `/api/admin` ，将返回 `403`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>accessing `/api/users/me` will return `200`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问 `/api/users/me` ，将返回 `200`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>activate the `migrate-at-start` option to migrate the schema automatically or inject the `Flyway` object and run
your migration as you normally do</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>激活 `migrate-at-start` 选项来自动迁移表，或者添加 `Flyway` 对象，然后像通常那样运行迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>activate the `migrate-at-start` option to migrate the schema automatically or inject the `Flyway` object and run your migration as you normally do</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>激活 `migrate-at-start` 选项来自动迁移表，或者添加 `Flyway` 对象，然后像通常那样运行迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add a tech specific, like `kafka`, if your post has a significant mention/relevance to that technology.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的帖子与该技术有显著的相关性，可以添加一个技术细节，比如 `kafka`。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add new fruits to the list via the form</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过表格添加新的fruits到列表中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your migrations to the `{migrations-path}` folder as you usually do with Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>像通常使用Flyway那样，将你的迁移文件添加到 `{migrations-path}` 文件夹中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your settings in `{config-file}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `{config-file}` 中添加你的设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all files in the `foo/` directory and its subdirectories except for files in `foo/private/` and its subdirectories,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `foo/` 目录及其子目录中的所有文件，但 `foo/private/` 及其子目录中的文件除外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all text files in the `bar/` directory and its subdirectories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `bar/` 目录及其子目录下的所有文本文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all the Reactive Messaging AMQP channels have the `host` or `port` attributes set</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有的Reactive Messaging AMQP通道都设置了 `host` 或 `port` 属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all the Reactive Messaging Kafka channels have either the `apicurio.registry.url` attribute or the `schema.registry.url` attribute set</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有响应式消息Kafka通道都设置了 `apicurio.registry.url` 属性或 `schema.registry.url` 属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all the Reactive Messaging Kafka channels have the `bootstrap.servers` attribute set</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有的Reactive Messaging Kafka通道都设置了 `bootstrap.servers` 属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>alternative-languages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>替代语言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个编辑器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `enforcedPlatform` directive for the Quarkus BOM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`enforcedPlatform` ，用于指示Quarkus BOM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.GreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `/hello` 暴露出来的 `org.acme.GreetingResource` 资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个 `org.acme.quickstart.ReactiveGreetingResource` 资源暴露 `/hello`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an associated unit test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关联的单元测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an authentication scheme of Bearer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个不记名(bearer)的认证方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and enabled at runtime with a system property or environment variable, for example: `-Dquarkus.http.auth.permission.permit1.enabled=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并在运行时通过系统属性或环境变量启用，例如： `-Dquarkus.http.auth.permission.permit1.enabled=true` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and executed with `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并可以使用 `java -jar target/quarkus-app/quarkus-run.jar`  来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and finally write the test code, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并最终写出测试代码，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and in native mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在原生模式(native mode)下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and in the case of using the Maven configuration instead of `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以及在使用Maven配置而不是 `application.properties` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and more</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and update `application.properties` to get all the CDI producers provided by `smallrye-jwt` included as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并更新 `application.properties` ，以获得所有由 `smallrye-jwt` 提供的CDI生产者，包括如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and write a test code like this one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写一个测试代码如同下面这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and you should see output similar to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而你应该看到类似的输出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and your configuration indicates that the `generated-price` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `IntegerSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而您的配置表明 `generated-price`  channel 使用了 `smallrye-kafka` 连接器，那么Quarkus会自动将 `value.serializer` 设置为Kafka内置的 `IntegerSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and your configuration indicates that the `my-kafka-records` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `key.deserializer` to Kafka's built-in `LongDeserializer`, as well as the `value.deserializer` to `ByteArrayDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并且您的配置表明 `my-kafka-records`  channel 使用了 `smallrye-kafka` 连接器，那么Quarkus会自动将 `key.deserializer` 设置为Kafka内置的 `LongDeserializer` ，以及 `value.deserializer` 设置为 `ByteArrayDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and your configuration indicates that the `price-create` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `DoubleSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而您的配置表明 `price-create`  channel 使用 `smallrye-kafka` 连接器，那么Quarkus将自动将 `value.serializer` 设置为Kafka内置的 `DoubleSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>annotate your entities with `@Entity`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>给实体类增加 `@Entity` 注解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>application.properties for TokenSecuredResource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TokenSecuredResource的application.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>arc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>around 15 minutes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大约15分钟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>assign your consumer to a consumer group not used by any other application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将您的消费者分配到一个不被任何其他程序使用的消费者组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>authScheme is null</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>authScheme为null</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>birthdate claim value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>birthdate声明(claim)的值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>blog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>博客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>build.gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>build.gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>business-automation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>业务-自动化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>classes for which a direct implementation of `org.apache.kafka.common.serialization.Serializer&lt;T&gt;` / `org.apache.kafka.common.serialization.Deserializer&lt;T&gt;` is present.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>直接实现了 `org.apache.kafka.common.serialization.Serializer&lt;T&gt;` / `org.apache.kafka.common.serialization.Deserializer&lt;T&gt;` 的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>classes for which a subclass of `JsonbSerializer` / `JsonbDeserializer` is present, as described in &lt;&lt;jsonb-serialization&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`JsonbSerializer` / `JsonbDeserializer` 的子类，如 link:#jsonb-serialization[[jsonb序列化]] 中所述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>classes for which a subclass of `ObjectMapperSerializer` / `ObjectMapperDeserializer` is present, as described in &lt;&lt;jackson-serialization&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ObjectMapperSerializer` / `ObjectMapperDeserializer` 的子类，如 link:#jackson-serialization[[jackson序列化]] 中所述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>classes generated from Avro schemas, as well as Avro `GenericRecord`, if Confluent or Apicurio Registry _serde_ is present</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Avro Schema生成的类，类似于Avro `GenericRecord`。如果Confluent或Apicurio Registry _serde_ 存在的话</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令行cli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>command-line</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>compatibility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>兼容性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>contains the right set of dependencies (glibc, libstdc++, zlib)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含正确的依赖项（glibc、libstdc++、zlib）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>copy `privateKey.pem` from the `integration-tests/oidc-tenancy` in the `main` Quarkus repository and use a test code similar to the one in the `Wiremock` section above to generate JWT tokens. You can use your own test keys if preferred.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 `main` Quarkus资源库中的 `integration-tests/oidc-tenancy` 中复制 `privateKey.pem` ，并使用类似于上面 `Wiremock` 部分的测试代码来生成JWT令牌。如果愿意，你可以使用你自己的测试密钥。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>core</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>核心</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create an author entry in [_data/authors.yaml](https://github.com/quarkusio/quarkusio.github.io/blob/develop/_data/authors.yaml)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个作者条目在 [_data/authors.yaml](https://github.com/quarkusio/quarkusio.github.io/blob/develop/_data/authors.yaml)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create an blog entry under [_posts](https://github.com/quarkusio/quarkusio.github.io/tree/develop/_posts)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个博客条目在 [_posts](https://github.com/quarkusio/quarkusio.github.io/tree/develop/_posts)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建本地可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl Command for /secured/roles-allowed With JWT</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用curl命令带上所需的JWT来访问/secured/roles-allowed</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl command for /secured/permit-all</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用curl命令访问/secured/permit-all</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl command for /secured/roles-allowed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用curl 命令访问/secured/roles-allowed</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>designed for containers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>专为容器而设计的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>e.g.,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>比如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>enable the _development mode_ (hot reload)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开启 _开发模式_ (热重载)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例 `Dockerfile` 文件，用于 `native` 和 `jvm` 两种模式，在 `src/main/docker` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>execute it with `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用以下方式执行它 `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>false</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>filter extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>筛选扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>for everything going from live reload to the opinionated layer to a single config file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从实时重载到意见层，再到单一的配置文件，一切都在进行中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>for our `quarkus:dev` capability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为我们的 `quarkus:dev` 能力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>for the actual `Dockerfile` definition and when the tool chain is involved</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于实际的 `Dockerfile` ，当涉及到工具链的时候</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC endpoint for sending spans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于发送spans的gRPC节点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入门指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>groupId:artifactId</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目包名:工程名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>has to be registered via `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该回调类必须通过 `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` 注册，具体如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hasJWT is false</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>hasJWT为false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hit `Ctrl+C` to stop the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `Ctrl+C` ，停止应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to compile your application natively</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何原生地编译你的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to create and scaffold a new project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何创建和建立一个新项目的脚手架</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to deal with extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何处理扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何在你的IDE中开发应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to enable live reload</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何启用实时重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to setup Quarkus tools in link:ide-tooling[Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何在 link:ide-tooling[Visual Studio Code、Eclipse IDE、Eclipse Che和IntelliJ] 中设置Quarkus工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to setup Quarkus tools in xref:ide-tooling.adoc[Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何在 xref:ide-tooling.adoc[Visual Studio Code、Eclipse IDE、Eclipse Che和IntelliJ] 中设置Quarkus工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use link:gradle-tooling[Gradle] as a build tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何使用 link:gradle-tooling[Gradle] 作为构建工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use link:maven-tooling[Maven] as a build tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何使用 link:maven-tooling[Maven] 作为构建工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use the CLI for your toolchain (coming soon)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何为你的工具链使用CLI（即将到来）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use the link:cli-tooling[CLI] for your toolchain</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何为你的工具链使用 link:cli-tooling[CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use the xref:cli-tooling.adoc[CLI] for your toolchain</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何为你的工具链使用 xref:cli-tooling.adoc[CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use xref:gradle-tooling.adoc[Gradle] as a build tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何使用 xref:gradle-tooling.adoc[Gradle] 作为构建工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use xref:maven-tooling.adoc[Maven] as a build tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何使用 xref:maven-tooling.adoc[Maven] 作为构建工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://camel.apache.org/[Apache Camel] is the Swiss knife of integrating heterogeneous systems with more than a decade
of history and a lively community of users and developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://camel.apache.org/[Apache Camel] 是集成异构系统的瑞士军刀，拥有十多年的历史以及活跃的用户和开发人员社区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://camel.apache.org/[Apache Camel] is the Swiss knife of integrating heterogeneous systems with more than a decade of history and a lively community of users and developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://camel.apache.org/[Apache Camel] 是集成异构系统的瑞士军刀，拥有十多年的历史以及活跃的用户和开发人员社区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello/Quarkus/array returns:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> http://localhost:8080/hello/Quarkus/array 返回：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello/Quarkus/object returns:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> http://localhost:8080/hello/Quarkus/object 返回：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[the _UBI-minimal_ image page]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[ _UBI-minimal_ image 页面]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[the UBI image page]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI镜像页面]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/containers/?tab=tags#/registry.access.redhat.com/ubi8/ubi-minimal[the list of _UBI-minimal_ tags]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/containers/?tab=tags#/registry.access.redhat.com/ubi8/ubi-minimal[ _UBI-minimal_ 标签列表]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/security/team/contact/[红帽]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://aws.amazon.com[An Amazon AWS account]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://aws.amazon.com[一个亚马逊AWS账户]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://catalog.redhat.com/software/container-stacks/detail/5ec53f50ef29fd35586d9a56[Red Hat Universal Base Image 8]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://catalog.redhat.com/software/container-stacks/detail/5ec53f50ef29fd35586d9a56[红帽通用基础镜像8]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://che.openshift.io/f?url=https://raw.githubusercontent.com/redhat-developer/devfile/master/getting-started/quarkus/devfile.yaml[Start Che Workspace]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://che.openshift.io/f?url=https://raw.githubusercontent.com/redhat-developer/devfile/master/getting-started/quarkus/devfile.yaml[开始使用Che Workspace]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloud.redhat.com/[Red Hat OpenShift Streams for Apache Kafka] provides managed Kafka brokers.
First, follow the instructions from https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the `rhoas` CLI for Red Hat OpenShift Streams for Apache Kafka] to create your Kafka broker instance.
Make sure you copied the client id and client secret associated with the _ServiceAccount_ you created.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://cloud.redhat.com/[红帽OpenShift Streams for Apache Kafka] 提供了受管理的Kafka brokers。首先，按照 link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[红帽OpenShift Streams for Apache Kafka的 `rhoas` 命令行入门] 的说明，创建您的Kafka broker实例。请确保您复制了与您创建的 _ServiceAccount_ 相关的客户ID和客户密码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloud.redhat.com/[Red Hat OpenShift Streams for Apache Kafka] provides managed Kafka brokers.  First, follow the instructions from https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the `rhoas` CLI for Red Hat OpenShift Streams for Apache Kafka] to create your Kafka broker instance.  Make sure you copied the client id and client secret associated with the _ServiceAccount_ you created.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://cloud.redhat.com/[红帽OpenShift Streams for Apache Kafka] 提供了受管理的Kafka brokers。首先，按照 link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[红帽OpenShift Streams for Apache Kafka的 `rhoas` 命令行入门] 的说明，创建您的Kafka broker实例。请确保您复制了与您创建的 _ServiceAccount_ 相关的客户ID和客户密码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] ，用于本地测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] provides an endpoint compatible with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] 提供了一个与Apache Kafka兼容的节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://download.jboss.org/jbosstools/photon/snapshots/builds/jbosstools-quarkus_master/[Development Update Site]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://download.jboss.org/jbosstools/photon/snapshots/builds/jbosstools-quarkus_master/[开发更新站点]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://en.wikipedia.org/wiki/YAML[YAML] is a very popular format. Kubernetes relies heavily on the YAML format to
write the various resource descriptors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://en.wikipedia.org/wiki/YAML[YAML] 是一种非常流行的格式。Kubernetes高度依赖YAML格式来编写各种资源描述符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://en.wikipedia.org/wiki/YAML[YAML] is a very popular format. Kubernetes relies heavily on the YAML format to write the various resource descriptors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://en.wikipedia.org/wiki/YAML[YAML] 是一种非常流行的格式。Kubernetes高度依赖YAML格式来编写各种资源描述符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://flywaydb.org/[Flyway] is a popular database migration tool that is commonly used in JVM environments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://flywaydb.org/[Flyway] 是一个流行的数据库迁移工具，通常用于JVM环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/jbosstools/jbosstools-quarkus[GitHub]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/jbosstools/jbosstools-quarkus[GitHub]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/redhat-developer/intellij-quarkus[GitHub]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/redhat-developer/intellij-quarkus[GitHub]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/redhat-developer/vscode-quarkus[GitHub]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/redhat-developer/vscode-quarkus[GitHub]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny]是一个响应式编程库，允许表达和组合异步动作。它提供两种类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kafka.apache.org[Apache Kafka] is a popular open-source distributed event streaming platform.
It is used commonly for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.
Similar to a message queue, or an enterprise messaging platform, it lets you:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://kafka.apache.org[Apache Kafka] 是一个流行的开源分布式事件流平台。它通常用于高性能数据管道、流式分析、数据集成以及任务关键型应用。类似于消息队列或企业消息平台，它可以允许您：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kafka.apache.org[Apache Kafka] is a popular open-source distributed event streaming platform.  It is used commonly for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.  Similar to a message queue, or an enterprise messaging platform, it lets you:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://kafka.apache.org[Apache Kafka] 是一个流行的开源分布式事件流平台。它通常用于高性能数据管道、流式分析、数据集成以及任务关键型应用。类似于消息队列或企业消息平台，它可以允许您：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kotlinlang.org/[Kotlin] is a very popular programming language that targets the JVM (amongst other environments). Kotlin has experienced a surge in popularity the last few years making it the most popular JVM language, except for Java of course.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://kotlinlang.org/[Kotlin] 是一种非常流行的基于JVM的编程语言（在其他环境中）。在过去的几年里，Kotlin的受欢迎程度激增，使其成为最受欢迎的JVM语言，当然，除了Java之外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://marketplace.eclipse.org/content/quarkus-tools[Quarkus Tools for Eclipse]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://marketplace.eclipse.org/content/quarkus-tools[用于Eclipse的Quarkus工具]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus[Marketplace]
{empty} +
 https://download.jboss.org/jbosstools/vscode/snapshots/vscode-quarkus/?C=M;O=D[Development Builds]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus[插件市场]  link:https://download.jboss.org/jbosstools/vscode/snapshots/vscode-quarkus/?C=M;O=D[构建产物归档]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus[Quarkus Tools for Visual Studio Code]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus[用于Visual Studio Code的Quarkus工具]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://openid.net/connect/[OpenID Connect]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://openid.net/connect/[OpenID Connect]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://plugins.jetbrains.com/plugin/13234-quarkus/versions[Marketplace]
{empty} +
https://download.jboss.org/jbosstools/intellij/snapshots/intellij-quarkus/[Development Builds]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://plugins.jetbrains.com/plugin/13234-quarkus/versions[插件市场]  link:https://download.jboss.org/jbosstools/intellij/snapshots/intellij-quarkus/[构建产物归档]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://plugins.jetbrains.com/plugin/13234-quarkus/versions[Quarkus Tools for IntelliJ IDEA]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://plugins.jetbrains.com/plugin/13234-quarkus/versions[用于IntelliJ IDEA的Quarkus工具]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-dynamodb.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-dynamodb.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-iam.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-iam.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-kms.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-kms.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-s3.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-s3.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ses.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ses.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sns.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sns.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sqs.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sqs.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ssm.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ssm.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-config-extensions/dev/consul.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-config-extensions/dev/consul.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigquery.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigquery.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigtable.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigtable.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/firestore.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/firestore.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/pubsub.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/pubsub.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/secretmanager.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/secretmanager.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/spanner.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/spanner.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/storage.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/storage.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-jgit/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-jgit/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-logging-sentry/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-logging-sentry/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-neo4j/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-neo4j/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-tika/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-tika/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-auth.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-auth.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-datasource.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-datasource.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-pki.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-pki.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-transit.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-transit.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/amqp </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/kafka </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/mailer </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/mqtt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/mqtt </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/reactive-sql-clients </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/redis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/redis </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://stedolan.github.io/jq/[jq tool]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://stedolan.github.io/jq/[jq工具]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://tools.ietf.org/html/rfc7519[JSON Web Token]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7519[JSON网络令牌]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`] or https://vertx.io/docs/apidocs/io/vertx/core/json/JsonArray.html[`JsonArray`]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`] 或 link:https://vertx.io/docs/apidocs/io/vertx/core/json/JsonArray.html[`JsonArray`]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/vertx-circuit-breaker/java/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://vertx.io/docs/vertx-circuit-breaker/java/ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/vertx-consul-client/java/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://vertx.io/docs/vertx-consul-client/java/ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/vertx-rabbitmq-client/java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://vertx.io/docs/vertx-rabbitmq-client/java </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/vertx-web-client/java/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://vertx.io/docs/vertx-web-client/java/ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io[Vert.x] is a toolkit for building reactive applications.
As described in the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture], Quarkus uses Vert.x underneath.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io[Vert.x] 是一个用于构建响应式应用程序的工具集。正如 link:quarkus-reactive-architecture.html[Quarkus响应式架构] 中所描述的，下面，Quarkus将使用Vert.x。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io[Vert.x] is a toolkit for building reactive applications.  As described in the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture], Quarkus uses Vert.x underneath.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io[Vert.x] 是一个用于构建响应式应用程序的工具集。正如 link:quarkus-reactive-architecture.html[Quarkus响应式架构] 中所描述的，下面，Quarkus将使用Vert.x。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://webauthn.guide/[WebAuthn] is an authentication mechanism that replaces passwords.
When you write a service for registering new users, or logging them in, instead of asking for a password, you can use WebAuthn, which replaces the password.
For more information, see xref:security-webauthn.adoc[Secure a Quarkus application by using the WebAuthn authentication mechanism].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://webauthn.guide/[WebAuthn] 是一种旨在取代密码的认证机制。简而言之，每当您写一个注册新用户或提供登录的服务，您就可以使用WebAuthn来代替使用密码的方式。更多信息，请参阅 link:security-webauthn.html[使用WebAuthn 认证机制保护 Quarkus 应用程序].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://webauthn.guide/[WebAuthn] is an authentication mechanism that replaces passwords.  When you write a service for registering new users, or logging them in, instead of asking for a password, you can use WebAuthn, which replaces the password.  For more information, see xref:security-webauthn.adoc[Secure a Quarkus application by using the WebAuthn authentication mechanism].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://webauthn.guide/[WebAuthn] 是一种旨在取代密码的认证机制。简而言之，每当您写一个注册新用户或提供登录的服务，您就可以使用WebAuthn来代替使用密码的方式。更多信息，请参阅 link:security-webauthn.html[使用WebAuthn 认证机制保护 Quarkus 应用程序].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.graalvm.org[GraalVM] is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.graalvm.org[GraalVM] 是一个通用的虚拟机，用于运行用各种不同语言编写的应用程序，并提供将JVM字节码编译为原生可执行文件的能力(这个原生可执行文件运行一个名为SubstrateVM的特殊虚拟机)。与传统JVM相比，这些原生可执行文件启动速度更快，使用的内存也少得多，但是并不是所有JVM特性都得到支持，有些特性的限制比一般的要多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.jetbrains.com/help/idea/quarkus.html[IntelliJ IDEA Ultimate Edition built-in Quarkus support]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.jetbrains.com/help/idea/quarkus.html[IntelliJ IDEA Ultimate版内置Quarkus支持]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.jetbrains.com/idea/nextversion/[Installer]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.jetbrains.com/idea/nextversion/[安装程序]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.keycloak.org/docs/latest/server_installation/index.html[Keycloak]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.keycloak.org/docs/latest/server_installation/index.html[Keycloak]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.keycloak.org/documentation.html[Keycloak Documentation]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.keycloak.org/documentation.html[Keycloak文档]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image[Introduction to Universal Base Image]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image[通用基础镜像介绍]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] Configuration property fixed at build time - All other configuration properties are overridable at runtime</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=Fixed at build time] 以下配置选项在构建中会被确定下来 - 其他的选项则会在运行时被覆盖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if a reply handler is set, then the failure is propagated back to the sender via an `io.vertx.core.eventbus.ReplyException` with code `ConsumeEvent#FAILURE_CODE` and the exception message,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置了一个回复处理程序，那么失败就会通过一个带有代码 `ConsumeEvent#FAILURE_CODE` 和异常消息的 `io.vertx.core.eventbus.ReplyException` 传播回发送者，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if no reply handler is set, then the exception is rethrown (and wrapped in a `RuntimeException` if necessary) and can be handled by the default exception handler, i.e. `io.vertx.core.Vertx#exceptionHandler()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置回复处理程序，那么异常会被重新抛出（如果需要的话，会被包裹在一个 `RuntimeException` ），并且可以由默认的异常处理程序来处理，即 `io.vertx.core.Vertx#exceptionHandler()` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if not set, the connector looks for a `Map` with the channel name or the configured `kafka-configuration` (if set) and the value is retrieved from that `Map`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置，连接器会使用 channel 名称或 `kafka-configuration` (如果设置了)来查找查找一个 `Map` ，并从 `Map` 中取值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if set to true, the access will be denied to all CDI methods
and JAX-RS endpoints that do not have security annotations but are defined in classes that contain methods with
security annotations.
Defaults to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置为 "true"，所有没有加安全注解但被定义在包含安全注解的方法的类中的CDI方法和JAX-RS节点的访问将被拒绝。默认为 `false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if set to true, the access will be denied to all CDI methods
and JAX-RS endpoints that do not have security annotations but are defined in classes that contain methods with
security annotations. Defaults to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置为 "true"，所有没有加安全注解但被定义在包含安全注解的方法的类中的CDI方法和JAX-RS节点的访问将被拒绝。默认为 `false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if set to true, the access will be denied to all CDI methods and JAX-RS endpoints that do not have security annotations but are defined in classes that contain methods with security annotations.  Defaults to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置为 "true"，所有没有加安全注解但被定义在包含安全注解的方法的类中的CDI方法和JAX-RS节点的访问将被拒绝。默认为 `false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if set to true, the access will be denied to all CDI methods and JAX-RS endpoints that do not have security annotations but are defined in classes that contain methods with security annotations. Defaults to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置为 "true"，所有没有加安全注解但被定义在包含安全注解的方法的类中的CDI方法和JAX-RS节点的访问将被拒绝。默认为 `false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,
there is some additional work to bundle the `function.zip`, as below.  For more information, please see the xref:native-and-ssl.adoc[Quarkus Native SSL Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你看到 `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` 或类似的SSL错误，由于GraalVM的当前状态，有一些额外的工作来捆绑 `function.zip` ，如下所示。更多信息，请参见 link:native-and-ssl.html[Quarkus Native SSL指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM, there is some additional work to bundle the `function.zip`, as below.  For more information, please see the xref:native-and-ssl.adoc[Quarkus Native SSL Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你看到 `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` 或类似的SSL错误，由于GraalVM的当前状态，有一些额外的工作来捆绑 `function.zip` ，如下所示。更多信息，请参见 link:native-and-ssl.html[Quarkus Native SSL指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:containerization-process.png[Containerization Process]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:containerization-process.png[容器化过程]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:native-executable-process.png[Creating a native executable]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:native-executable-process.png[创建原生可执行文件]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{che-logo}[Eclipse Che,100,100]
{empty} +
Eclipse Che</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{che-logo}[alt="Eclipse Che", width="100", height="100"]  Eclipse Che</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{eclipse-logo}[Eclipse,100,100]
{empty} +
Eclipse Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{eclipse-logo}[alt="Eclipse", width="100", height="100"]  Eclipse Quarkus工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ IDEA Ultimate</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{intellij-logo}[alt="IntelliJ", width="100", height="100"]  IntelliJ IDEA Ultimate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{intellij-logo}[alt="IntelliJ", width="100", height="100"]  IntelliJ Quarkus工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{vscode-logo}[VSCode,100,100]
{empty} +
VSCode Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{vscode-logo}[alt="VSCode", width="100", height="100"]  VSCode Quarkus工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>imperative and reactive. 'Nuff said.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式和响应式。这就是最有名的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.vertx.ConsumeEvent;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.vertx.ConsumeEvent;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.vertx.ConsumeEvent;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.vertx.ConsumeEvent;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import the project in your favorite IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你喜欢的编辑器里面导入项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in case multiple Avro serdes are present, serializer/deserializer must be configured manually for Avro-generated classes, because autodetection is impossible</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果存在多个Avro serdes，必须为Avro生成的类手动配置序列化器/反序列化器，因为这种情况下无法进行自动侦测</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in order to ensure that various resources are included and additional reflection is registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以确保各种资源被包括在内，并登记了额外的反射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the `gdb` prompt.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `gdb` 提示中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the context of an application, you will rely on configuring the `native-image` configuration by tweaking your `pom.xml`;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个应用程序的背景下，你将依靠配置 `native-image` ，通过调整你的 `pom.xml` ；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the context of an extension, Quarkus offers a lot of infrastructure to simplify all of this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在扩展的背景下，Quarkus提供了很多基础设施来简化这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>isHttps is false as https is not used</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>isHttps为false，因为没有使用https</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>it is technically not needed to subclass `JsonbSerializer`, but in such case, autodetection isn't possible</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>技术上不需要对 `JsonbSerializer` 子类化，但在这种情况下无法进行自动侦测</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>it is technically not needed to subclass `ObjectMapperSerializer`, but in such case, autodetection isn't possible</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>技术上不需要对 `ObjectMapperSerializer` 子类化，但在这种情况下无法进行自动侦测</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>it's in asciidoc format, there is an example as shown with [2019-06-05-quarkus-and-web-ui-development-mode.adoc](https://github.com/quarkusio/quarkusio.github.io/blob/develop/_posts/2019-06-05-quarkus-and-web-ui-development-mode.adoc)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它是asciidoc格式的，有一个示例显示 [2019-06-05-quarkus-and-web-ui-development-mode.adoc](https://github.com/quarkusio/quarkusio.github.io/blob/develop/_posts/2019-06-05-quarkus-and-web-ui-development-mode.adoc)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jbang整合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jwt,security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jwt, 安全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>less than 15 minutes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不到15分钟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>lifecycle event</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生命周期事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:cli-tooling[CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:cli-tooling[CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:http://hibernate.org/reactive/[Hibernate Reactive] is the only reactive JPA implementation and offers you the full
breadth of an Object Relational Mapper allowing you to access your database over reactive drivers.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Hibernate Reactive with Panache focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://hibernate.org/reactive/[Hibernate Reactive] 是唯一的响应式JPA实现，提供了全方位的对象关系映射（Object Relational Mapper，简称ORM）支持，支持通过响应式驱动访问数据库。它使复杂的映射成为可能，它支持编写复杂的映射，但编写简单常用的映射却不够简便。Hibernate Reactive Panache专注于简化ORM实体，让你的Quarkus开发有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:http://hibernate.org/reactive/[Hibernate Reactive] is the only reactive JPA implementation and offers you the full breadth of an Object Relational Mapper allowing you to access your database over reactive drivers.  It makes complex mappings possible, but it does not make simple and common mappings trivial.  Hibernate Reactive with Panache focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://hibernate.org/reactive/[Hibernate Reactive] 是唯一的响应式JPA实现，提供了全方位的对象关系映射（Object Relational Mapper，简称ORM）支持，支持通过响应式驱动访问数据库。它使复杂的映射成为可能，它支持编写复杂的映射，但编写简单常用的映射却不够简便。Hibernate Reactive Panache专注于简化ORM实体，让你的Quarkus开发有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://download.eclipse.org/microprofile/microprofile-jwt-auth-1.2/microprofile-jwt-auth-spec-1.2.html[MP JWT 1.2 HTML]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://download.eclipse.org/microprofile/microprofile-jwt-auth-1.2/microprofile-jwt-auth-spec-1.2.html[MP JWT 1.2 HTML]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://download.eclipse.org/microprofile/microprofile-jwt-auth-1.2/microprofile-jwt-auth-spec-1.2.pdf[MP JWT 1.2 PDF]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://download.eclipse.org/microprofile/microprofile-jwt-auth-1.2/microprofile-jwt-auth-spec-1.2.pdf[MP JWT 1.2 PDF]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/smallrye/smallrye-jwt[SmallRye JWT]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/smallrye/smallrye-jwt[SmallRye JWT]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://tools.ietf.org/html/rfc7515[JSON Web Signature]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7515[JSON网络签名]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://tools.ietf.org/html/rfc7516[JSON Web Encryption]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7516[JSON网络加密]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://tools.ietf.org/html/rfc7518[JSON Web Algorithms]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7518[JSON网络算法]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://tools.ietf.org/html/rfc7519[JSON Web Token]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7519[JSON网络令牌]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is "a simple, scalable, actor-like deployment and concurrency model" provided by _Vert.x_.
This model does not claim to be a strict actor-model implementation, but it shares similarities, especially concerning concurrency, scaling, and deployment.
To use this model, you write and _deploy_ verticles, communicating by sending messages on the event bus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/vertx-core/java/#&lt;em&gt;verticles[Verticles] 是_Vert.x提供的 "一个简单的、可扩展的、类似于演员的部署和并发模型"。这个模型并不声称是一个严格的actor-model实现，但它有相似之处，特别是关于并发、扩展和部署。为了使用这个模型，你编写和 _部署_ 顶点，通过在事件总线上发送消息进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is "a simple, scalable, actor-like deployment and concurrency model" provided by _Vert.x_.  This model does not claim to be a strict actor-model implementation, but it shares similarities, especially concerning concurrency, scaling, and deployment.  To use this model, you write and _deploy_ verticles, communicating by sending messages on the event bus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/vertx-core/java/#&lt;em&gt;verticles[Verticles] 是_Vert.x提供的 "一个简单的、可扩展的、类似于演员的部署和并发模型"。这个模型并不声称是一个严格的actor-model实现，但它有相似之处，特别是关于并发、扩展和部署。为了使用这个模型，你编写和 _部署_ 顶点，通过在事件总线上发送消息进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:kafka[Interacting with Kafka] and link:amqp[Interacting with AMQP]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:kafka[与Kafka交互] 和 link:amqp[与AMQP交互]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mailer[Sending email]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mailer[发送电邮件]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mongodb#reactive[使用 MongoDB] 和 link:mongodb-panache#reactive[MongoDB 和Panache]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:neo4j#reactive[Using Neo4J]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:neo4j#reactive[使用Neo4J]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:reactive-routes[Using reactive routes]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:reactive-routes[使用响应式路由]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:reactive-sql-clients[Reactive Database Clients]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:reactive-sql-clients[Reactive 数据库客户端]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:rest-json#reactive[Using Mutiny with RestEasy]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:rest-json#reactive[使用Mutiny和RestEasy]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:vertx[Using Vert.x]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:vertx[使用 Vert.x]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>make your entities extend `PanacheEntity` (optional if you are using the repository pattern)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实体类改为继承 `PanacheEntity` 类（使用Repository模式时为可选操作）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>miscellaneous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>杂项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.decrypt.key.location</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.decrypt.key.location</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.token.header</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.token.header</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.verify.audience</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.verify.audience</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.verify.issuer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.verify.issuer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.verify.publickey</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.verify.publickey</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.verify.publickey.location</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.verify.publickey.location</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.messaging.connector.smallrye-kafka.apicurio.registry.url=... your Apicurio Registry URL...
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.messaging.connector.smallrye-kafka.apicurio.registry.url=... 你的Apicurio注册表URL...
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.messaging.connector.smallrye-kafka.schema.registry.url=... your Confluent Schema Registry URL...
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.messaging.connector.smallrye-kafka.schema.registry.url=... 你的Confluent Schema Registry URL...
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>non-preferred. Exclude.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非优先考虑的。不包括。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>observability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可观察性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>open a browser and go to http://localhost:8080/legumes.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开浏览器，访问 http://localhost:8080/legumes.html </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>open a browser to `http://localhost:8080/fruits.html`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开浏览器访问 `&lt;a href="http://localhost:8080/fruits.html" class="bare"&gt;http://localhost:8080/fruits.html&lt;/a&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>openssl command for converting private key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>openssl转换私钥的命令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>openssl commands for generating keys</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于生成密钥的openssl命令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or &lt;a href="https://gradle.org/" target="_blank"&gt;Gradle&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或&lt;a href="https://gradle.org/" target="_blank"&gt;Gradle&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if configuring the OTLP gRPC endpoint via JVM arguments:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者如果通过JVM参数配置OTLP gRPC节点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you are using Jackson:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或如果你在使用Jackson：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you do not have `LAMBDA_ROLE_ARN` already defined in this shell:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者如果在这个shell中没有定义 `LAMBDA_ROLE_ARN` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or set `enable.auto.commit` to true and annotate the consuming method with `@Acknowledgment(Acknowledgment.Strategy.NONE)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要么将 `enable.auto.commit` 设置为true，并在consuming方法中使用 `@Acknowledgment(Acknowledgment.Strategy.NONE)` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or to build a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者构建一个原生可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or, if you use the Gradle Kotlin DSL:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，如果您使用Gradle Kotlin DSL:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>org.acme.getting.started.testing.MyQuarkusTestBeforeEachCallback
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>org.acme.getting.started.testing.MyQuarkusTestBeforeEachCallback
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>our preferred tagline to say that we rock for containers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的首选口号是：我们为容器而摇滚</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>our tagline</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的口号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package io.quarkus.vertx.verticles;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package io.quarkus.vertx.verticles;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round-robin is applied;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>point-to-point - 发送消息，一个消费者接收。如果有几个消费者监听该地址，则采用轮流的方式；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pom.xml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>preferred term for the VM creating native executable. No space.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虚拟机创建原生可执行文件的首选术语。没有空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>primitive types or `String`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原始类型或 `String` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class Person extends PanacheMongoEntity {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class Person extends PanacheMongoEntity {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>publish/subscribe - publish a message; all the consumers listening to the address are receiving the message;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>publish/subscribe - 发布一个消息；所有监听该地址的消费者都在接收该消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>限定器 事件拦截器 观察者 内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkiverse-hub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkiverse-hub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.amqp.devservices.image-name=quay.io/artemiscloud/activemq-artemis-broker:latest
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.amqp.devservices.image-name=quay.io/artemiscloud/activemq-artemis-broker:latest
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus:dev Output</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus:dev 输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous fashion.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>request/reply - 发送消息并期望得到响应。接收者可以以异步的方式对消息作出回应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>scaffold a project in a single command line</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在单个命令行中为项目搭建脚手架</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>security at quarkus.io
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.io 安全
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>security,webauthn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全, webauthn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>see xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro] for more information about using Confluent or Apicurio Registry libraries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于使用Confluent或Apicurio Registry的更多信息，请参见 link:kafka-schema-registry-avro.html[协同使用Apache Kafka，Schema Registry以及Avro]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>send a pull request against the develop branch and voilà
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对开发分支发送一个博客的合并请求
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>send the `name` to the `greeting` address and request a response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `name` 发送到 `greeting` 地址，并要求作出回应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set `use-anonymous-sender` to false</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `use-anonymous-sender` 设为false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set the destination address (anonymous sender are not supported)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置目的地地址（不支持匿名发送者）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>small (based on `ubi8-micro`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>小的 (基于 `ubi8-micro` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.always-check-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.always-check-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.claims.group</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.claims.group</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.claims.sub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.claims.sub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.groups-separator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.groups-separator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.path.group</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.path.group</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.path.sub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.path.sub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.token.header</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.token.header</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.algorith</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.algorith</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.certificate-thumbprint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.certificate-thumbprint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.key-format</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.key-format</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.key.location</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.key.location</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.relax-key-validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.relax-key-validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start Quarkus with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动Quarkus：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>support upx-compressed executables (more details on the xref:upx.adoc[enabling compression documentation])</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持upx压缩的可执行文件（更多相关细节在 link:upx.html[启用压缩文档] 中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tags is space separated list `tags:extension grpc`
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>标记是由空格分隔的列表 `tags:extension grpc`
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tags must be in lowercase
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>标签必须英文小写
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Flyway extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the HTTP method returns a `Uni`.
If you are using RESTEasy Reactive, `Uni` support is built-in.
If you are using _classic_ RESTEasy, you need to add the `quarkus resteasy-mutiny` extension to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP方法返回一个 `Uni` 。如果你使用的是RESTEasy Reactive， `Uni` 支持是内置的。如果你使用的是 _经典的_ RESTEasy，你需要在你的项目中添加 `quarkus resteasy-mutiny` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the HTTP method returns a `Uni`.  If you are using RESTEasy Reactive, `Uni` support is built-in.  If you are using _classic_ RESTEasy, you need to add the `quarkus resteasy-mutiny` extension to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP方法返回一个 `Uni` 。如果你使用的是RESTEasy Reactive， `Uni` 支持是内置的。如果你使用的是 _经典的_ RESTEasy，你需要在你的项目中添加 `quarkus resteasy-mutiny` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Hibernate ORM with Panache extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM with Panache扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Hibernate Reactive with Panache extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Reactive with Panache扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the MariaDB/MySQL support is now in a separate dependency, MariaDB/MySQL users need to add the `flyway-mysql` dependency from now on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MariaDB/MySQL的支持现在在一个单独的依赖中，MariaDB/MySQL的用户从现在开始需要添加 `flyway-mysql` 的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Maven structure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven的结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Microsoft SQL Server support is now in a separate dependency, Microsoft SQL Server users need to add the `flyway-sqlserver` dependency from now on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Microsoft SQL Server的支持现在在一个单独的依赖中，Microsoft SQL Server的用户从现在开始需要添加 `flyway-sqlserver` 的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Quarkus Gradle plugin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Gradle插件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Vert.x Web Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 网络客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Vert.x event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `amqp-host` or `amqp-port` is configured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`amqp-host` 或 `amqp-port` 已配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `kafka.bootstrap.servers` is configured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置了 `kafka.bootstrap.servers` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `list()` method might be surprising at first. It takes fragments of HQL (JP-QL) queries and contextualizes the rest. That makes for very concise but yet readable code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `list()` 方法一开始可能会让人吃惊。它只需要接收HQL（JP-QL）查询语句的片段，并对查询语句其余部分进行上下文推断处理。这使得代码非常简明，但也不失可读性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `list()` method might be surprising at first. It takes fragments of PanacheQL queries (subset of JPQL) and contextualizes the rest.
That makes for very concise but yet readable code.
MongoDB native queries are also supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`list()` 的方法一开始可能会让人吃惊。它采用PanacheQL查询的片段（JPQL的子集），并将其余部分进行上下文处理。这使得代码非常简明，但又可读。也支持MongoDB本地查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `list()` method might be surprising at first. It takes fragments of PanacheQL queries (subset of JPQL) and contextualizes the rest.  That makes for very concise but yet readable code.  MongoDB native queries are also supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`list()` 的方法一开始可能会让人吃惊。它采用PanacheQL查询的片段（JPQL的子集），并将其余部分进行上下文处理。这使得代码非常简明，但又可读。也支持MongoDB本地查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as
the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-app` 目录，其中包含 `quarkus-run.jar` jar文件--是一个可执行的 _jar_ 。请注意，它不是 _über-jar_ ，因为依赖项目被复制到 `quarkus-app/lib/` 的子目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-app` 目录，其中包含 `quarkus-run.jar` jar文件--是一个可执行的 _jar_ 。请注意，它不是 _über-jar_ ，因为依赖项目被复制到 `quarkus-app/lib/` 的子目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the application configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the attribute is set directly on the channel configuration (`mp.messaging.incoming.my-channel.attribute=value`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性是直接在 channel 配置上设置的( `mp.messaging.incoming.my-channel.attribute=value` ),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the auto-detection did not find a matching serializer/deserializer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自动侦测机制没有找到匹配的序列化器/反序列化器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the channel configuration defines the `cloud-events-type` and `cloud-events-source` attributes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通道配置定义了 `cloud-events-type` 和 `cloud-events-source` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the corresponding Java type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对应的Java类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the executable that is compiled to native 1s and 0s</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>被编译为原生1和0的可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the implementation needs to specify the type argument `T` as the (de-)serialized type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些实现类需要指定类型参数 `T` 作为(反)序列化的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the kafka password (the client secret from the service account)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>kafka密码(来自service account的客户密码)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the managed instance of Vert.x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>被管理的 Vert.x 实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the message metadata contains an `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` instance,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消息元数据包含一个 `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the name of the client for multi-tenant application, see xref:mongodb.adoc#multiple-mongodb-clients[Multiple MongoDB Clients]. Otherwise, the default client will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多租户应用程序的客户端名称，见 link:mongodb.html#multiple-mongodb-clients[多个MongoDB客户端] 。否则，将使用默认客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the name of the collection, otherwise the simple name of the class will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集合的名称，否则将使用该类的简单名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the name of the database, otherwise, the `quarkus.mongodb.database` property will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数据库的名称，否则，将使用 `quarkus.mongodb.database` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the serializer/deserializer is not configured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化器/反序列化器未配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>then the behaviour is a bit different, because the transaction will not be terminated until the
returned reactive value is terminated. In effect, the returned reactive value will be listened to
and if it terminates exceptionally the transaction will be marked for rollback, and will be committed
or rolled-back only at termination of the reactive value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么行为就有点不同了，因为在返回的响应式值终止之前，事务不会被终止。实际上，返回的响应式值将被监听，如果它意外终止，事务将被标记为回滚，并且只有在响应式值终止时才会提交或回滚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>then the behaviour is a bit different, because the transaction will not be terminated until the returned reactive value is terminated. In effect, the returned reactive value will be listened to and if it terminates exceptionally the transaction will be marked for rollback, and will be committed or rolled-back only at termination of the reactive value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么行为就有点不同了，因为在返回的响应式值终止之前，事务不会被终止。实际上，返回的响应式值将被监听，如果它意外终止，事务将被标记为回滚，并且只有在响应式值终止时才会提交或回滚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is another guide if you need a xref:rest-client-reactive.adoc[REST client] (including support for JSON).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要一个 link:rest-client-reactive.html[REST客户端] （包括对JSON的支持），还有另一个指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to set `auto.offset.reset = earliest`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置 `auto.offset.reset = earliest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>use the `throttled` policy,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `throttled` 策略,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>username is anonymous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用户名称是匿名的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网络</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>what was described above is essentially the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.
Hibernate with Panache also allows for the use of the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheRepository`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面所描述的编码模式本质上是 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[Active Record模式] ，有时也称为实体模式。Panache也支持通过 `PanacheRepository` 使用更经典的 link:https://martinfowler.com/eaaCatalog/repository.html[Repository模式] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>what was described above is essentially the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.
MongoDB with Panache also allows for the use of the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheMongoRepository`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面所描述的本质上是 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[活动记录模式] ，有时也称为实体模式。带有Panache的MongoDB也允许通过 `PanacheMongoRepository` ，使用更经典的 link:https://martinfowler.com/eaaCatalog/repository.html[存储库模式] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>what was described above is essentially the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.  Hibernate with Panache also allows for the use of the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheRepository`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面所描述的编码模式本质上是 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[Active Record模式] ，有时也称为实体模式。Panache也支持通过 `PanacheRepository` 使用更经典的 link:https://martinfowler.com/eaaCatalog/repository.html[Repository模式] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>what was described above is essentially the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.  MongoDB with Panache also allows for the use of the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheMongoRepository`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面所描述的本质上是 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[活动记录模式] ，有时也称为实体模式。带有Panache的MongoDB也允许通过 `PanacheMongoRepository` ，使用更经典的 link:https://martinfowler.com/eaaCatalog/repository.html[存储库模式] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when we discuss Quarkus running in... containers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当我们讨论Quarkus在......容器中运行时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when we explain our stack</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当我们解释我们的技术栈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when we get the response, extract the body and send it to the user</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当我们得到响应时，提取正文并将其发送给用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>where `ProtectedResource` class may look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其中 `ProtectedResource` 类可能看起来像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>where `keycloak.version` should be set to `17.0.0` or higher.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其中 `keycloak.version` 应该设置为 `17.0.0` 或更高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which provides `io.quarkus.test.kafka.KafkaCompanionResource` - an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它提供了 `io.quarkus.test.kafka.KafkaCompanionResource` -- `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` 的一种实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which provides `io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager` - an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` which starts a Keycloak container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它提供了 `io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager` - 一个 `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` 的实现，用来启动一个Keycloak容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which provides a utility class `io.quarkus.test.keycloak.client.KeycloakTestClient` you can use in tests for acquiring the access tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其中提供了一个实用类 `io.quarkus.test.keycloak.client.KeycloakTestClient` ，你可以在测试中使用它来获取访问令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will include:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>writing-extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写-扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:cli-tooling.adoc[CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:cli-tooling.adoc[CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:gradle-tooling.adoc[Gradle]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:gradle-tooling.adoc[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:ide-tooling.adoc[IDE]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:ide-tooling.adoc[IDE]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:maven-tooling.adoc[Maven]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:maven-tooling.adoc[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:mutiny-primer.adoc[Mutiny - 一个直观的响应式编程库]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:quarkus-reactive-architecture.adoc[The Quarkus Reactive Architecture]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:quarkus-reactive-architecture.adoc[Quarkus响应式架构]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:quarkus-runtime-base-image.adoc[This page] explains how to extend the `quarkus-micro` image when your application has specific requirements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:quarkus-runtime-base-image.adoc[此页] 解释了当你的应用有特殊要求时，如何扩展 `quarkus-micro` 镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-basic-auth-concept.adoc[Basic HTTP Authentication] and xref:security-built-in-authentication.adoc#form-auth[Form HTTP authentication] are the core authentication mechanisms supported in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:security-basic-auth-concept.adoc[Basic HTTP 认证] and xref:security-built-in-authentication.adoc#form-auth[Form HTTP 认证] 是Quarkus支持的核心认证机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-getting-started.adoc[Secure a Quarkus application with Basic authentication]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-getting-started.html[使用Basic认保护Quarkus应用程序]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-jdbc.adoc[Using security with JDBC]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-jdbc.html[使用JDBC security]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-jwt-build.adoc[Sign and encrypt JWT tokens with SmallRye JWT Build]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:security-jwt-build.adoc[使用 SmallRye JWT Build 对 JWT 令牌进行签名和加密]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-keycloak-admin-client.adoc[Using the Keycloak admin client]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-keycloak-admin-client.html[使用Keycloak管理客户端]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-keycloak-authorization.adoc[Using OpenID Connect (OIDC) and Keycloak to centralize authorization]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-keycloak-authorization.html[使用OpenID连接（OIDC）和Keycloak来集中授权]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-ldap.adoc[Using security with an LDAP realm]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-ldap.html[使用LDAP realm security]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-openid-connect-client-reference.adoc[OpenID Connect and OAuth2 Client and Filters Reference Guide]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-openid-connect-client.html[Quarkus - 使用OpenID Connect，OAuth2客户端和过滤器的参考指南]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-openid-connect-dev-services.html[为Keycloak开发服务]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] will launch a Keycloak container and import a `quarkus-realm.json`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-openid-connect-dev-services.html[Keycloak开发服务] 将启动一个Keycloak容器并导入一个 `quarkus-realm.json` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-openid-connect-multitenancy.adoc[Using OpenID Connect (OIDC) multi-tenancy]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-openid-connect-multitenancy.html[使用OpenID连接（OIDC）多租户]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-openid-connect-web-authentication.adoc[OpenID Connect (OIDC) authorization code flow mechanism]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-openid-connect-web-authentication.html[OpenID Connect (OIDC) authorization code flow mechanism]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-openid-connect.adoc[Using OpenID Connect (OIDC) to protect service applications using Bearer Token authorization]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于Bearer Token认证机制的信息，请参见 link:security-openid-connect.html[使用OpenID Connect保护应用程序服务] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-boot-properties.adoc[Quarkus - Extension for Spring Boot properties]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:spring-boot-properties.adoc[Quarkus - Spring Boot properties 扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-cache.adoc[Quarkus - Extension for Spring Cache]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:spring-cache.adoc[Quarkus - Spring Cache 扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-cloud-config-client.adoc[Quarkus - Reading properties from Spring Cloud Config Server]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:spring-cloud-config-client.adoc[Quarkus - 从Spring Cloud Config Server 中读取属性]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-data-jpa.adoc[Quarkus - Extension for Spring Data JPA]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:spring-data-jpa.adoc[Quarkus - Spring Data JPA 扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-data-rest.adoc[Quarkus - Extension for Spring Data REST]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:spring-data-rest.adoc[Quarkus - Spring Data REST 扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-di.adoc[Quarkus - Extension for Spring DI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:spring-di.html[Quarkus - Spring DI 扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-scheduled.adoc[Quarkus - Extension for Spring Scheduled]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:spring-scheduled.adoc[Quarkus - Spring Scheduled 扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-security.adoc[Quarkus - Extension for Spring Security]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:spring-security.adoc[Quarkus - Spring Security 扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:spring-web.adoc[Quarkus - Extension for Spring Web]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:spring-web.html[Quarkus - Spring Web 扩展]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can return different entity types depending on what happens in your method (a `Legume` or an `Error` for instance);</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以根据你的方法中发生的情况，返回不同的实体类型（例如， `Legume` 或 `Error` ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can set the attributes of the `Response` (the status comes to mind in the case of an error).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以设置 `Response` 的属性（在出现错误的情况下，会想到状态）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能需要添加 `import io.smallrye.mutiny.Multi;` 和 `import java.time.Duration;` 语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC驱动扩展 (如 `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your favorite IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你最喜欢的IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your reactive driver extension (`quarkus-reactive-pg-client`, `quarkus-reactive-mysql-client`, `quarkus-reactive-db2-client`, ...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式驱动扩展 ( `quarkus-reactive-pg-client` , `quarkus-reactive-mysql-client` , `quarkus-reactive-db2-client` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your selected filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您选择的筛选</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{graalvm-flavor}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{graalvm-flavor}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{graalvm-version}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{graalvm-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-archive-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-archive-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-base-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-base-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-blob-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-blob-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-chat-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-chat-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-clone-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-clone-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-home-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-hom-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-images-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-images-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-issues-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-issues-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-mailing-list-index}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-mailing-list-index}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-mailing-list-subscription-email}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-mailing-list-subscription-email}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-org-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-org-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-site-getting-started}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-site-getting-started}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-tree-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-tree-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-version}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-archive-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-archive-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-base-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-base-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-blob-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-blob-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-clone-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-clone-url}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-tree-url}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-tree-url}</seg>
      </tuv>
    </tu>
    </body>
</tmx>