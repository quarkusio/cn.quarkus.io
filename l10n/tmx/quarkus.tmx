<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.7.0" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>What we mean by "Supersonic Subatomic Java".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"超音速亚原子Java"是什么意思。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Quarkus?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡演</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Components</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have found nowhere.&lt;br/&gt;The pathway to normal space&lt;br/&gt;is found in the nav.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>没有找到您要访问的资源。&lt;br/&gt;请通过导航栏返回到正常空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Video podcast hosted by Quarkus Developers about things moving in and around Quarkus ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由Quarkus开发者主办的关于在Quarkus生态系统内和周边事物的视频播客。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributors</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可观察性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conclusion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/about/"&gt;About &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/about/"&gt;关于&lt;i class="fas fa-chevron-down"&gt; &lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;WHAT IS QUARKUS?&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;QUARKUS是什么？&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/container-first" class="{% if page.url contains '/container-first/' %}active{% endif %}"&gt;CONTAINER FIRST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/container-first" class="{% if page.url contains '/container-first/' %}active{% endif %}"&gt;容器优先 &lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;DEVELOPER JOY&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;开发者的乐趣 &lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Learn &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;学习 &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;GET STARTED&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;入门&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides" class="{% if page.url contains '/guides/' %}active{% endif %}"&gt;GUIDES&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides" class="{% if page.url contains '/guides/' %}active{% endif %}" &gt;指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Extensions &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;扩展&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog" class="{% if page.url contains '/catalog/' %}active{% endif %}"&gt;EXTENSION CATALOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/catalog" class="{% if page.url contains '/catalog/' %}active{% endif %}"&gt;扩展目录&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/useextensions" class="{% if page.url contains '/useextensions/' %}active{% endif %}"&gt;USE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/useextensions" class="{% if page.url contains '/useextensions/' %}active{% endif %}"&gt;使用扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/createextensions" class="{% if page.url contains '/createextensions/' %}active{% endif %}"&gt;CREATE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/createextensions" class="{% if page.url contains '/createextensions/' %}active{% endif %}"&gt;创建扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;Community &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/learn/"&gt;社区&lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}" &gt;博客&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}" &gt;播客&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kube-Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kube-Native</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus tailors your application for GraalVM and HotSpot. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes. We use a technique we call compile time boot.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为GraalVM和HotSpot定制你的应用程序。令人惊讶的快速启动时间，令人难以置信的低RSS内存（不仅仅是堆的大小！），在Kubernetes等容器协调平台中提供近乎即时的扩展和高密度的内存利用。我们使用一种我们称之为编译时启动的技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/container-first"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/container-first"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unifies imperative and reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一指令式和响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combine both the familiar imperative code and the reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发应用程序时，将熟悉的指令式和响应式代码风格结合起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/continuum"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/continuum"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Community and Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>社区和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of over fifty best-of-breed libraries that you love and use. All wired on a standard backbone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个有凝聚力的、有趣的、全栈式的框架，它利用了各类不断增长的50多个你喜欢和使用的最好的库。所有这些都在一个标准的主干上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/standards"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/standards"&gt;了解更多&lt;/a&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developer Joy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发者的乐趣</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A cohesive platform for optimized developer joy:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个优化开发者乐趣的有凝聚力的平台：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unified configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Zero config, live reload in the blink of an eye</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>零配置，瞬间重新加载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Streamlined code for the 80% common usages, flexible for the 20%</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化80%的常用代码，灵活处理剩余的20%</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No hassle native executable generation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>轻松生成本机可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/developer-joy"&gt;Learn more&lt;/a&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/vision/developer-joy"&gt;了解更多&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/vision/developer-joy"&gt;Learn more&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/vision/developer-joy"&gt;了解更多&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feedback and Help</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反馈和帮助</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For usage questions, we recommend to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于使用问题，我们建议到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the &lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;Discussions&lt;/a&gt; section on our GitHub project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用我们GitHub项目上的&lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;讨论&lt;/a&gt;部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow with the &lt;code&gt;quarkus&lt;/code&gt; tag&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow的&lt;code&gt;quarkus&lt;/code&gt;标签&lt;/a&gt;下提问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For questions related to the development of Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于与Quarkus自身开发相关的问题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;a href="https://groups.google.com/d/forum/quarkus-dev" target="_blank"&gt;quarkus-dev Google Groups&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以访问 &lt;a href="https://groups.google.com/d/forum/quarkus-dev" target="_blank"&gt;quarkus-dev Google Groups&lt;/a&gt;讨论组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chat using &lt;a href="https://quarkusio.zulipchat.com" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或在 &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream) 聊天室发问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your help is more than welcome! Don’t hesitate to join the crowd.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们非常欢迎您的帮助！不要犹豫，加入我们大家吧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Join the Quarkus Community</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>加入Quarkus社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out our &lt;a href="https://github.com/quarkusio/quarkus" target="_blank"&gt;GitHub&lt;/a&gt; for details on reporting issues and the process for submitting pull requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看我们的&lt;a href="https://github.com/quarkusio/quarkus" target="_blank"&gt;GitHub&lt;/a&gt;，了解有关报告问题和提交合并请求流程的详细信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every contribution is valuable. It can be a bug report, an example application, a feature request, a fix in the documentation or just feedback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每一份贡献都是有价值的。它可以是bug报告、示例应用程序、功能请求、文档中的修复或仅仅是反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A virtual (and in person where possible) tour of Java User Groups creating a unique hands-on experience with access to Quarkus experts designed to help you get started with Java in a Kubernetes world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个Java用户组的虚拟之旅(如果可能的话还可以亲自去)，创建一个独特的亲身体验，造访旨在帮助您在Kubernetes世界中开始使用Java的Quarkus专家。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unifies Imperative and Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一指令式和响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combine both the familiar imperative code and the reactive style when developing applications.  &lt;a href="/vision/continuum"&gt;Learn more&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发应用程序时，将熟悉的命令式代码和响应式风格结合起来。&lt;a href="/vision/continuum"&gt;了解更多&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Best of Breed Libraries and Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最好的类库和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of hundreds of best-of-breed libraries that you love and use. All wired on a standard backbone. &lt;a href="/vision/standards"&gt;Learn more about Quarkus Extensions&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个内聚的、使用起来有趣的全栈框架，它利用了您所喜爱和使用的数百个最佳组合库，都将其连接在一个标准主干上。&lt;a href="/vision/standards"&gt;了解更多关于Quarkus扩展的信息&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the outset, Quarkus has been designed around a container-first philosophy. What this means in concrete terms is that Quarkus applications are optimised for low memory usage and fast startup times in the following ways:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从一开始，Quarkus的设计就围绕着容器优先的理念。这意味着Quarkus应用程序在以下方面进行了优化，以达到低内存使用和快速启动的目的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建时处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The central idea behind Quarkus is to do at build-time what traditional frameworks do at runtime: configuration parsing, classpath scanning, feature toggle based on classloading, and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的中心思想是在构建时做传统框架在运行时做的事情：配置解析、classpath扫描、基于classloading的功能切换，等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much processing as possible is done at build time; thus, your application only contains the classes used at runtime. In traditional frameworks, all the classes required to perform the initial application deployment hang around for the application’s life, even though they are only used once. With Quarkus, they are not even loaded into the production JVM! Quarkus does not stop here. During the build-time processing, it prepares the initialization of all components used by your application. It results in less memory usage and faster startup time as all metadata processing has already been done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>尽可能将更多的处理在构建时完成；因此，你的应用程序只包含在运行时使用的类。在传统的框架中，所有执行初始应用部署所需的类都在应用的生命周期中存在，尽管它们只被使用一次。在Quarkus中，它们甚至不会被加载到生产用的JVM中。Quarkus并没有到此为止。在构建时的处理过程中，它为你的应用程序使用的所有组件的初始化做准备。由于所有的元数据处理都已经完成，这带来了更少的内存使用和更快的启动时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reduction in Reflection Usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>减少反射的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible Quarkus tries to avoid reflection, reducing startup time and memory usage. During the built-time processing, extensions can analyze the application code and the classes available on the classpath and replace reflection calls with regular invocations. The usage of dynamic proxies is also prevented by using generating custom proxy at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus尽可能地避免反射，减少启动时间和内存使用。在构建时的处理过程中，扩展可以分析应用程序代码和classpath上可用的类，并以常规调用取代反射调用。通过在构建时使用生成的自定义代理，也可以防止使用动态代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arc, the dependency injection framework used by Quarkus, eliminates all the reflection calls and deduces the injection graph at build time. So, when the application starts, no expensive lookups; it’s done already!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Arc是Quarkus使用的依赖注入框架，它消除了所有的反射调用，并在构建时推断出注入图。因此，当应用程序启动时，不需要昂贵的查找，它已经完成了!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First-Class Support for GraalVM Native Images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>优秀的对GraalVM原生镜像支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM Native Executable support has been an essential part of the design for Quarkus from the beginning. When an application is compiled down to a native executable, it starts much faster and can run with a much smaller heap than a standard JVM. The native compiler uses aggressive dead-code elimination techniques to only embed the parts of the JVM and classes that are absolutely required by your application. Quarkus makes building optimized native executables plain easy. The build-time approach allows Quarkus to collect enough metadata on your application to fine-tune the compilation. No &lt;code&gt;-H:+ReportUnsupportedElementsAtRuntime&lt;/code&gt; flag, no fallback, no compromise!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM原生可执行文件支持从一开始就是Quarkus设计的重要组成部分。当一个应用程序被编译成一个原生可执行文件时，它的启动速度要快得多，并且可以在比标准JVM小得多的堆中运行。原生编译器使用积极的死代码消除技术，只嵌入JVM的部分和应用程序绝对需要的类。Quarkus使构建优化的原生可执行文件变得非常容易。构建时的方法允许Quarkus在你的应用程序上收集足够的元数据，以便对编译进行微调。没有&lt;code&gt;-H:+ReportUnsupportedElementsAtRuntime&lt;/code&gt;标志，没有回退，没有妥协！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Pre-Boot</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生镜像预启动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We pre-boot as many of the frameworks as possible during the native compilation of a Quarkus application. It means that the resulting native executable has already run most of the startup code and serialized the result into the executable: even faster startup!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus应用程序的原生编译过程中，我们尽可能多地对框架进行预启动。这意味着产生的原生可执行文件已经运行了大部分的启动代码，并将结果序列化到可执行文件中：启动速度更快！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the techniques allowing reducing the memory usage and provide faster startup times are not only advantageous in containers. Even on bare metal, it would reduce your memory pressure, and it’s always pleasant to not have to wait 10 seconds to see your application running.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有允许减少内存使用和提供更快的启动时间的技术，不仅在容器中是有利的。即使在裸金属环境上，它也会减少你的内存压力，而且不必等待10秒就能看到你的应用程序运行，这总是令人愉快的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Quarkus was designed, we didn’t focus only on containers but also on deploying Quarkus applications on container orchestrators such as Kubernetes. Quarkus build-time processing also generates the Kubernetes metadata, so your application is ready to be deployed on Kubernetes. Runtime capabilities such as health checks and metrics are exposed out of the box. Quarkus collects all the required metadata at build time to create the Kubernetes deployment descriptor and produce a container image. A single command line can deploy your application onto your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在设计Quarkus时，我们不仅关注容器，还关注将Quarkus应用程序部署到容器协调器(如Kubernetes)上。Quarkus构建时处理还会生成Kubernetes元数据，这样就可以将应用程序部署到Kubernetes上了。运行时功能(如健康检查和指标)是开箱即用的。Quarkus在构建时收集所有必需的元数据，以创建Kubernetes部署描述符并生成容器镜像。一个命令行就可以将应用程序部署到Kubernetes集群上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog"&gt;Extension Catalog&lt;/a&gt; &lt;i class="fas fa-chevron-right"&gt;&lt;/i&gt; {{ page.title }}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/catalog"&gt;扩展目录&lt;/a&gt; &lt;i class="fas fa-chevron-right"&gt;&lt;/i&gt; {{ page.title }}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Title Quarkiverse-JBeret</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展标题Quarkiverse-JBeret</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provided by the JBeret Project Team</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由JBeret项目组提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus JBeret Extension adds support for JSR-352 Batch Applications for the Java Platform. JBeret is an implementation of the JSR-352.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus JBeret Extension增加了对Java平台的JSR-352批处理应用的支持。JBeret是JSR-352的一个实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DOCUMENTATION</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure use the documentation to have your questions answered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保使用文档来寻求问题答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS GUIDES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QUARKUS指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get a better understanding on how to use this extension in the Quarkus Guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在Quarkus指南中更好地了解如何使用这个扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out these applicable guides:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看这些适用的指南：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>USAGE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the extension, add the dependency to the target project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用该扩展，请将该依赖性添加到目标项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch API and Runtime will be available out of the box. Please refer to the &lt;a href="#"&gt;Batch documentation&lt;/a&gt;, or the &lt;a href="#"&gt;JBeret documentation&lt;/a&gt; to learn about Batch Applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API和运行时将是开箱即用的。请参考&lt;a href=""&gt;批处理文档&lt;/a&gt;，或&lt;a href=""&gt;JBeret文档&lt;/a&gt;以了解批处理应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CONFIGURATION</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret Quarkus extension supports the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret Quarkus扩展支持以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名称</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The repository type to store JBeret and Job data. A jdbc type requires a JDBC datasource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>存储JBeret和Job数据的存储库类型。jdbc类型需要JDBC数据源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NON-STANDARD FEATURES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非标准功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-standard Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非标准功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch API requires the @BatchProperty annotation to inject the specific configuration from the batch definition file. Instead, you can use the @ConfigProperty annotation, which is used to inject configuration properties in Quarkus using the MicroProfile Config API and keep consistency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API需要@BatchProperty注解来注入批处理定义文件中的特定配置。或者，你可以使用@ConfigProperty注解，它被用来在Quarkus中使用MicroProfile配置API注入配置属性，并保持一致性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although, there is a slight limitation: since job configuration is mostly dynamic and only injected on job execution, Quarkus may fail to start due to invalid configuration (can’t find the Job configuration values). In this case, configuration injection points with the @ConfigProperty annotation need to set a default value or use an Optional.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然，有一个小小的限制：由于作业配置大多是动态的，并且只在作业执行时注入，Quarkus可能会因为无效的配置（找不到作业配置值）而启动失败。在这种情况下，带有@ConfigProperty注解的配置注入点需要设置一个默认值或使用一个Optional。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Batch APIs JobOperator and JobRepository are available as CDI beans, so they can be injected directly into any code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批处理API的JobOperator和JobRepository可以作为CDI Bean使用，所以它们可以直接注入到任何代码中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret Scheduler is integrated out of the box in this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个扩展中，JBeret Scheduler是开箱即用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To schedule a Job execution, please refer to the quarkus.jberet.job.”job-name”.cron and quarkus.jberet.job.”job-name”.params.”param-key” configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要安排工作的执行，请参考quarkus.jberet.job.”job-name”.cron和quarkus.jberet.job.”job-name”.params.”param-key”配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Job can also be scheduled programmatically, using the JobScheduler API and the Quarkus startup event:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作业也可以通过程序安排，使用JobScheduler API和Quarkus的启动事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JobScheduler does not support persistent schedules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JobScheduler不支持持久化调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret REST is integrated as separate extension that can be easily added to the target project with the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret REST被集成为独立的扩展，可以通过以下依赖关系轻松地添加到目标项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JBeret REST API, provides REST resources to several operations around the Batch API: starting and stopping jobs, querying the status of a job, schedule a job, and many more. The extension includes a REST client to simplify the REST API calls:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBeret REST API，为围绕Batch API的几个操作提供REST资源：启动和停止作业、查询作业状态、安排作业等等。该扩展包括一个REST客户端来简化REST API的调用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>EXAMPLE APPLICATIONS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code&gt;chunk&lt;/code&gt; - A simple Job that reads, processes, and stores data from a file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;chunk&lt;/code&gt; - 一个简单的作业，从文件中读取、处理和存储数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code&gt;jdbc-repository&lt;/code&gt; - A Job that uses a jdbc datasource to store JBeret and Job metadata.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;jdbc-repository&lt;/code&gt; - 一个使用jdbc数据源来存储JBeret和作业元数据的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or take a look into the World of Warcraft Auctions - Batch Application. It downloads the World of Warcraft Auction House data and provides statistics about items prices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者看看《魔兽世界》的拍卖 - 批处理应用。它下载魔兽世界拍卖行的数据并提供物品价格的统计数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CONTRIBUTORS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks goes to these wonderful people:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>感谢这些优秀的人：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This project follows the &lt;a href="#"&gt;all-contributors&lt;/a&gt; specification. Contributions of any kind welcome!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本项目遵循&lt;a href="#"&gt;所有贡献者&lt;/a&gt;规范。欢迎任何形式的贡献!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>LICENSE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>许可证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Version</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatible with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Quarkus兼容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>平台</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatibility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>兼容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;Passing&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;通过&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Repository</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;Documentation&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;文档&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maintainer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>维护者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Homepage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目主页</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>缺陷</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pull Requests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>合并请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Size</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大小</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last Publish Date</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后发布日期</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jan 01, 2021</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年1月1日</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Weekly Builds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每周构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Total Builds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>总构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Created on</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jan 01, 2016</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2016年1月1日</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>License</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>许可证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Category</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网络</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#"&gt;62 Contributors&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#"&gt;62位贡献者&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Need More Than Community Support?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要超出社区范围的支持?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you require a higher level of support, you have options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要更高级别的支持，您可以选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Red Hat Build of Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>红帽的Quarkus构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enterprise support provided by Red Hat for the product.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该产品由红帽公司提供企业级支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickly Bootstrap Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>快速引导您的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With &lt;a href="https://code.quarkus.io/"&gt;code.quarkus.io&lt;/a&gt;, in a few clicks, you can bootstrap your Quarkus application and discover its extension ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 &lt;a href="https://code.quarkus.io/"&gt;code.quarkus.io&lt;/a&gt;链接, 只需几次单击就可以引导您的Quarkus应用程序并发现其扩展生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the wide breadth of technologies Quarkus with which applications can be made.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索Quarkus可以应用的广泛的技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Selected Filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选定的筛选</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Filter the Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>筛选扩展程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Want to have your extension added to the Quarkiverse?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>想让您的扩展功能加入到Quarkiverse中吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/catalog/catalog-detail"&gt;&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/catalog/catalog-detail"&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provided by JBeret project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由JBeret项目组提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Category: Web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类别：Web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Version: 1.1.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展版本: 1.1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Works with Quarkus 1.1.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>适用于 Quarkus 1.1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't see and extension you need? &lt;a href="{{site.baseurl}}/createextensions"&gt;Request a new extension&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>没有看到您需要的扩展吗? &lt;a href="{{site.baseurl}}/createextensions"&gt;申请新的扩展&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>贡献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License version 2.0&lt;/a&gt;. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and contributors are welcome. Let’s join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个在&lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache许可证2.0版&lt;/a&gt;下许可的开源项目。首先，它是一个开放的社区，在这里，贡献、想法和讨论都是公开进行的，并且欢迎贡献者。让我们携手共建Java应用的未来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roadmap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>路线图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read about the community plans for the future. Here is &lt;a href="https://github.com/orgs/quarkusio/projects/5"&gt;our current roadmap&lt;/a&gt;. This is driven by the community, come and tell us what &lt;i&gt;your&lt;/i&gt; needs are.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>阅读有关社区未来的计划。这里是&lt;a href="https://github.com/orgs/quarkusio/projects/5"&gt;我们目前的路线图&lt;/a&gt;。这是由社区推动的，来告诉我们&lt;i&gt;你&lt;/i&gt;的需求是什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code and Issue Tracker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码和问题跟踪</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code is hosted on &lt;a href="https://github.com/quarkusio/quarkus"&gt;GitHub&lt;/a&gt;. If you need to report a bug or request a new feature, look for a similar one on our &lt;a href="https://github.com/quarkusio/quarkus/issues"&gt;GitHub issue tracker&lt;/a&gt;. If you don’t find any, &lt;a href="https://github.com/quarkusio/quarkus/issues/new/choose"&gt;create a new issue&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>源代码被托管在&lt;a href="https://github.com/quarkusio/quarkus"&gt;GitHub&lt;/a&gt;。如果您需要报告一个错误或要求一个新功能，请在我们的&lt;a href="https://github.com/quarkusio/quarkus/issues"&gt;GitHub问题跟踪&lt;/a&gt;上寻找类似的问题。如果您没有找到，&lt;a href="https://github.com/quarkusio/quarkus/issues/new/choose"&gt;创建一个新问题&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write QuickStart Guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写快速入门指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are always new users trying to get started quickly. Share your experience with everyone by writing a Quickstart and submitting it for peer review.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>总有一些新用户试图快速入门。通过撰写 "快速入门 "并提交给同行评审，与大家分享你的经验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write New Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写新的扩展程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are an extension developer or want to contribute to Quarkus development, join our mailing list either &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;emailing us&lt;/a&gt; or by visiting our &lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groups page&lt;/a&gt;. Make sure you visit our extensive &lt;a href="{{site.baseurl}}/guides/writing-extensions"&gt;Writing extensions guide&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是一个扩展程序的开发者，或者想为Quarkus的发展做出贡献，请加入我们的邮件列表，可以&lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;给我们写信&lt;/a&gt;，或者访问我们的&lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groups页面&lt;/a&gt;。请务必访问我们广泛的&lt;a href="{{site.baseurl}}/guides/writing-extensions"&gt;写作扩展指南&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A periodical video podcast hosted by Quarkus Developers about things moving in and around Quarkus ecosystem. View the &lt;a href="{{site.baseurl}}/insights"&gt;live podcasts&lt;/a&gt; and check out older episodes on the Podcasts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由Quarkus开发者主持的定期视频播客，讲述Quarkus生态系统内和周边事物。查看&lt;a href="{{site.baseurl}}/insights"&gt;实时播客&lt;/a&gt;，并在播客中查看先前的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow Quarkus on Twitter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Twitter上关注Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of our updates go out on &lt;a href="https://twitter.com/quarkusio"&gt;Twitter&lt;/a&gt;. Sometimes our project team speaks at industry events, and sometimes they post cool ways people use Quarkus. Wash, rinse, and retweet.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的大部分更新都是在&lt;a href="https://twitter.com/quarkusio"&gt;Twitter&lt;/a&gt;上发布的。有时我们的项目团队会在行业活动中发言，有时他们会发布人们使用Quarkus的很酷的方法。欢迎一键三连，多多转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community publishes thoughtful how-to videos to help you get started. Check them out on &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;YouTube&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus社区发布了周到的操作视频，以帮助您开始使用。请在&lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;YouTube&lt;/a&gt;上查看它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Publications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are heaps of helpful &lt;a href="{{site.baseurl}}/publications"&gt;articles and blog posts&lt;/a&gt; out there presenting interesting use-cases and examples of Quarkus in action.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有很多有用的&lt;a href="{{site.baseurl}}/publications"&gt;文章和博文&lt;/a&gt;，介绍了Quarkus的有趣用例和实际应用的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Newsletter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新闻</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subscribe to the &lt;a href="{{site.baseurl}}/newsletter"&gt;monthly newsletter&lt;/a&gt; to have choice Quarkus content from across our community delivered to your inbox.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>订阅&lt;a href="{{site.baseurl}}/newsletter"&gt;每月通讯&lt;/a&gt;，将来自我们整个社区的Quarkus精选内容发送到您的收件箱。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Awards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>获奖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Share in our excitement when the project receives &lt;a href="{{site.baseurl}}/awards"&gt;awards and recognition&lt;/a&gt; for all of the hard work done by the community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为社区所做的所有辛勤工作，当项目获得&lt;a href="{{site.baseurl}}/awards"&gt;奖项和认可&lt;/a&gt;时，分享我们的兴奋之情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Report a Vulnerability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>报告漏洞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Found a security vulnerability in Quarkus, its extensions or the dependencies they use? See the &lt;a href="{{site.baseurl}}/security"&gt;security policy page&lt;/a&gt; to learn to report it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus、其扩展或其使用的依赖项中发现了安全漏洞？请参阅&lt;a href="{{site.baseurl}}/security"&gt;安全策略页面&lt;/a&gt;，了解如何报告它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Books</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>书籍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get new and deeper views into Quarkus from the community through &lt;a href="{{site.baseurl}}/books"&gt;these great books&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 &lt;a href="{{site.baseurl}}/books"&gt;这些很棒的书&lt;/a&gt;，从社区获得对Quarkus新的、更深入的看法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is not just about being great for writing Web Applications or Micro-Services. We’re focusing on more than the feature set: we make sure that every feature works well, simply, with little to no configuration, in the most intuitive way possible. It should be trivial to develop simple things, and easy to develop the more complex ones.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus不仅仅是为编写网络应用程序或微服务提供良好的条件。我们关注的不仅仅是功能集：我们要确保每个功能都能很好地工作，简单地工作，几乎不需要配置，以最直观的方式进行。开发简单的东西应该是微不足道的，而开发更复杂的东西应该是容易的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Improve and expedite the inner loop development process with live coding where code changes are automatically reflected in your running application. code -&gt; refresh browser -&gt; repeat</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过实时编码改善和加快内循环开发过程，代码的变化会自动反映在你运行的应用程序中。 代码 -&gt; 刷新浏览器 -&gt; 重复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode/"&gt;Read the Dev Mode guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/maven-tooling#dev-mode/"&gt;阅读开发模式指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unified Config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>统一配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gone are the days of a thousand configuration files and formats. A single configuration file is all it takes for Quarkus applications to configure every single extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>千篇一律的配置文件和格式的时代已经过去了。Quarkus应用程序只需要一个配置文件就可以配置每一个扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Opinionated</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有态度的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus focuses on the simplest and most useful way to use a given feature, trimming it to its most useful essence. This includes upfront analysis on how to best use a feature and guiding you in what we think is the best way to do things.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus专注于使用给定特性最简单和最有用的方法，将其裁剪到最有用的本质。这包括关于如何最好地使用一个功能的前期分析，以及指导您我们认为最好的做事方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发用户界面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visualize and configure extensions as well as access to application logs and testing components</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可视化和配置扩展，以及访问应用程序日志和测试组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Read the Dev UI guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/dev-ui"&gt;阅读开发用户界面指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic provisioning and application wiring of supporting services such as databases, identity servers, and more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持服务(如数据库、标识服务器等)的自动配置和应用程序连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-services"&gt;Read the Dev Services guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/dev-services"&gt;阅读开发服务指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuous Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持续测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get instant feedback on code changes as tests run in the background on impacted code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当测试在后台对受影响的代码运行时，获得对代码变化的即时反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/continuous-testing"&gt;Read the Continuous Testing guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{site.baseurl}}/guides/continuous-testing"&gt;阅读持续测试指南&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Interface</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令行界面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create projects, manage extensions, and execute essential build and dev commands.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建项目，管理扩展，并执行基本的构建和开发命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote Development</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>远程开发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run &lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode"&gt;dev mode&lt;/a&gt; remotely with changes to local files immediately available in a containerize environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行远程 &lt;a href="{{site.baseurl}}/guides/maven-tooling#dev-mode"&gt;开发者模式&lt;/a&gt; 可以在容器化环境中立即对本地文件进行更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS 2.0 IS HERE!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QUARKUS 2.0来了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 continues the mission of making Java the preferred framework for Kubernetes-native development with new developer tools and improved performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2.0继续致力于通过新的开发工具和改进的性能，使Java成为kubernetes本地开发的首选框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;1&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;1&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install via Command Line Interface</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过命令行界面安装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open your favorite terminal and use JBang to install the Quarkus CLI. You do not need to have Java installed first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开您喜欢的终端并使用JBang安装Quarkus CLI。您不需要首先安装Java。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux, macOS, and Windows (using WSL or bash compatible shell like Cygwin or MinGW)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Linux、macOS和Windows（使用WSL或bash兼容的shell，如Cygwin或MinGW）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Windows using Powershell</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>面向Windows使用Powershell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, you can also install the CLI with SDKMAN!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，您也可以用SDKMAN安装CLI！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more options, such as Homebrew or Chocolatey, see &lt;a href="/guides/cli-tooling"&gt;the Quarkus CLI guide&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多的选项，如Homebrew或Chocolatey，请参见&lt;a href="/guides/cli-tooling"&gt;Quarkus CLI指南&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;2&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;2&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the Getting Started Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 "入门 "应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run this script in your CLI:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的CLI中运行这个脚本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;3&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;3&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the Getting Started Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行 "入门 "应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boom! Your Quarkus app is now running at &lt;code&gt;localhost:8080&lt;/code&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当当当！您的Quarkus应用已经在&lt;code&gt;localhost:8080&lt;/code&gt;运行了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step &lt;span class="step-no"&gt;4&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>步骤&lt;span class="step-no"&gt;4&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus进行实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes it easy to change your code on the fly. Let's modify the &lt;a href="localhost:8080/hello"&gt;RESTful endpoint&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus使您可以轻松地动态更改代码。让我们修改 &lt;a href="localhost:8080/hello"&gt;RESTful 端点&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open &lt;code&gt;src/main/java/GreetingsResource.java&lt;/code&gt; in a text editor or your &lt;a href="https://quarkus.io/guides/ide-tooling"&gt;favorite IDE&lt;/a&gt; and change "hello RESTEasy" to "hola RESTEasy". Then refresh the browser and see the changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用文本编辑器或您惯用的 &lt;a href="https://quarkus.io/guides/ide-tooling"&gt;IDE&lt;/a&gt; 打开&lt;code&gt;src/main/java/GreetingsResource.java&lt;/code&gt; ，把 ”hello RESTEasy“ 改为 ”你好 RESTEasy“。然后刷新浏览器并查看更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cool stuff right? &lt;a href="https://quarkus.io/guides/maven-tooling#dev-mode"&gt;Learn more about Quarkus's dev mode&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很Cool的东东对吧？&lt;a href="https://quarkus.io/guides/maven-tooling#dev-mode"&gt;了解更多Quarkus的开发模式&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The combination of Quarkus and Kubernetes provides an ideal environment for creating scalable, fast, and lightweight applications. Quarkus significantly increases developer productivity with tooling, pre-built integrations, application services, and more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus和Kubernetes的组合为创建可伸缩、快速和轻量级的应用程序提供了理想的环境。Quarkus通过工具、预构建集成、应用程序服务等显著提高了开发人员的生产率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does it mean to be a Kubernetes-native framework?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为一个Kubernetes原生框架意味着什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single-step Deployments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>单步执行部署</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes it easy to deploy microservice applications to Kubernetes without having to understand the intricacies of the underlying Kubernetes framework. Extensions are available for Kubernetes, and Kubernetes distributions, to facilitate this process with only a minimal amount of configuration variables needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus使得在Kubernetes上部署微服务应用变得容易，而不需要了解Kubernetes底层框架的复杂性。Kubernetes和Kubernetes发行版都有相应的扩展，以促进这个过程，只需要最小的配置变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Kubernetes extension, developers can perform or automate a single-step deployment using Jib, Docker, and Source-to-Image (S2i) including the creation of DeploymentConfig to trigger automatic redeployments. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Kubernetes扩展，开发人员可以使用Jib、Docker和Source-to-Image（S2i）执行或自动进行单步部署，包括创建DeploymentConfig以触发自动重新部署。 &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;阅读指南了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, Quarkus includes extensions that make it easy to deploy serverless microservices to cloud providers including AWS Lambda, Azure Functions, and Google Cloud Functions as well as Knative to take advantage of Quarkus application’s fast startup times. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，Quarkus还包括一些扩展，使其能够轻松地将无服务器微服务部署到云提供商，包括AWS Lambda、Azure Functions和Google Cloud Functions以及Knative，以获得Quarkus应用程序的快速启动时间方面优势。&lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing &amp; Debugging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追踪和调试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides developers the tools and capabilities to troubleshoot distributed microservices applications in Kubernetes including tracing and debugging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为开发者提供了工具和能力，以解决Kubernetes中分布式微服务应用程序的故障，包括跟踪和调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus utilizes &lt;a href="https://opentracing.io/" target="_blank"&gt;OpenTracing&lt;/a&gt; which is a vendor-agnostic API to help developers easily instrument tracing into their codebase. Distributed tracing helps pinpoint where failures occur and what causes poor performance. &lt;a href="{{site.baseurl}}/guides/opentracing"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 利用&lt;a href="https://opentracing.io/" target="_blank"&gt;OpenTracing&lt;/a&gt;，这是一个与供应商无关的 API，可帮助开发人员轻松地将跟踪功能纳入其代码库。分布式跟踪有助于确定故障发生的位置以及导致性能不佳的原因。 &lt;a href="{{site.baseurl}}/guides/opentracing"&gt;阅读该指南以了解更多详情&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Health &amp; Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用健康和指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus leverages SmallRye Health, an implementation of the MicroProfile Health specification. This allows applications to provide information about their state to external viewers in a Kubernetes environment where automated processes must be able to determine whether the application should be discarded or restarted. &lt;a href="{{site.baseurl}}/guides/microprofile-health"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus利用SmallRye Health，这是MicroProfile Health规范的一个实现。这允许应用程序在Kubernetes环境中向外部查看者提供有关其状态的信息，在这种环境中，自动化流程必须能够确定应用程序是否应该被丢弃或重新启动。 &lt;a href="{site.baseurl}}/guides/microprofile-health"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus utilizes the &lt;a href="https://micrometer.io/" target="_blank"&gt;Micrometer&lt;/a&gt; metrics library for runtime and application metrics. It provides a simple facade for the most popular monitoring systems to instrument your JVM-based application code without vendor lock-in. Application-specific and built-in metrics can be exposed using Micrometer. &lt;a href="{{site.baseurl}}/guides/micrometer#support-for-the-microprofile-metrics-api"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus利用&lt;a href="https://micrometer.io/" target="_blank"&gt;Micrometer&lt;/a&gt;度量库来实现运行时和应用程序的度量。它为最流行的监控系统提供了一个简单的接口，以便在不锁定供应商的情况下对基于JVM的应用程序代码进行检测。&lt;a href="{{site.baseurl}}/guides/micrometer#support-for-the-microprofile-metrics-api"&gt;阅读该指南以了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes an extension that allows developers to use Kubernetes ConfigMaps and Secrets as a configuration source, without having to mount them into the Pod running the Quarkus application or make any other modifications to their Kubernetes Deployment (or Openshift DeploymentConfig) &lt;a href="{{site.baseurl}}/guides/kubernetes-config"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus包含一个扩展，允许开发者使用Kubernetes ConfigMaps和Secrets作为配置源，而无需将它们挂载到运行Quarkus应用的Pod中，也无需对Kubernetes的部署(或Openshift DeploymentConfig)进行任何修改。&lt;a href="{{site.baseurl}}/guides/kubernetes-config"&gt;阅读指南了解更多细节&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create and debug applications in the same environment where applications run. Live coding in development mode where any changes made locally will be immediately visible in a clustered Kubernetes environment. &lt;a href="https://developers.redhat.com/blog/2021/02/11/enhancing-the-development-loop-with-quarkus-remote-development"&gt;Read this blog post for greater insight.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在应用程序运行的同一环境中创建和调试应用程序。在开发模式下的实时编码，在集群化的Kubernetes环境中，本地做出的任何更改都将立即可见。&lt;a href="https://developers.redhat.com/blog/2021/02/11/enhancing-the-development-loop-with-quarkus-remote-development"&gt;阅读这篇博客可以获得更深刻的见解&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUPERSONIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>超音速&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUBATOMIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>亚原子&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes Native Java栈为OpenJDK HotSpot和GraalVM量身定制，从Java库和标准中精心打造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Available</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现已可用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;Read the release notes&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;阅读发布说明&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The core foundation of every good open source project is open discussion and collaboration. Quarkus is committed to this belief. We've enabled GitHub Discussions so the community can have open communication. This gives a focal point for the community to ask and answer questions regarding the project. This means all of that great knowledge can be shared and is discoverable. Additionally, other conversations about the Quarkus Community can be had there as well. Come collaborate with us.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每个好的开源项目的核心基础是公开讨论和合作。Quarkus致力于这一信念。我们已经启用了GitHub讨论，以便社区能够进行公开交流。这为社区提供了一个焦点，以提出和回答关于项目的问题。这意味着所有这些伟大的知识都可以被分享和发现。此外，关于Quarkus社区的其他对话也可以在这里进行。来与我们合作吧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chat using &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或在 &lt;a href="https://quarkusio.zulipchat.com/#narrow/stream/187038-dev" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream) 聊天室发问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://github.com/quarkusio/quarkus/discussions/categories/events"&gt;Check out the "Events" section of Quarkus Discussions&lt;/a&gt; for additional community related events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://github.com/quarkusio/quarkus/discussions/categories/events"&gt;查看Quarkus讨论组的”活动“部分&lt;/a&gt; 参与其他社区相关活动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/continuum"&gt;Unifies imperative and reactive&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/continuum"&gt;统一指令式和响应式&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A cohesive platform for optimized developer joy with unified configuration and no hassle native executable generation. Zero config, live reload in the blink of an eye and streamlined code for the 80% common usages, flexible for the remainder 20%.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个内聚的平台，优化开发人员的乐趣，统一的配置和没有麻烦的本地可执行文件生成。零配置，瞬间重新加载，简化80%的常用代码，灵活处理剩余的20%。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For years, the client-server architecture has been the de-facto standard to build applications. But a significant shift happened. The &lt;em&gt;one model rules them all&lt;/em&gt; age is over. A new range of applications and architectural styles have emerged and transformed how code is written and how applications are deployed and executed. HTTP microservices, reactive applications, event-driven architecture, and serverless are now central players in modern systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多年来，客户端服务器（CS）架构一直是构建应用程序的事实标准。但是，一个重大的转变发生了。&lt;em&gt;一种模式统治一切&lt;/em&gt;的时代已经过去。一系列新的应用程序和架构风格已经出现，并改变了代码的编写方式以及应用程序的部署和执行方式。HTTP微服务、响应式应用、事件驱动架构和无服务器现在是现代系统的核心角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been designed with this new world in mind and provides first-class support for these different paradigms. That does not mean you cannot build monoliths with Quarkus; you can do it smoothly. On the contrary, it means that the Quarkus development model morphs to adapt itself to the type of application you are developing, monolith, microservice, reactive, event-driven, functions…</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的设计考虑到了这个新的世界，并为这些不同的范式提供了一流的支持。这并不意味着你不能用Quarkus建立单体；你可以顺利地做到这一点。反而这意味着Quarkus的开发模型会变化，来适应您正在开发的应用程序的类型，单片机、微服务、响应式、事件驱动、无服务......</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s start with the basics: HTTP microservices. In this context, you need to develop an HTTP endpoint, often called REST or CRUD. You process incoming HTTP requests, and to do so you often need to rely on other services, such as databases, or another HTTP service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从最基本的开始：HTTP微服务。在这种情况下，你需要开发一个HTTP端点，通常称为REST或CRUD。你处理传入的HTTP请求，而要做到这一点，你往往需要依靠其他服务，如数据库，或另一个HTTP服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this type of application, Quarkus relies on well-known standards such as JAX-RS, JPA and MicroProfile Rest Client, but also Hibernate with Panache to simplify interactions with databases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于这种类型的应用，Quarkus依赖于众所周知的标准，如JAX-RS、JPA和MicroProfile Rest Client，但也有Hibernate与Panache来简化与数据库的交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s take a very simple application handling &lt;em&gt;elements&lt;/em&gt; from the periodic table. The code would be something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们来看看一个非常简单的处理周期表中&lt;em&gt;元素&lt;/em&gt;的应用程序。代码将是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a Java EE or Spring user, this development model should look familiar.  You expose a resource containing methods annotated with &lt;code&gt;@GET&lt;/code&gt;, &lt;code&gt;@POST&lt;/code&gt;…&amp;ZeroWidthSpace;&amp;ZeroWidthSpace; to handle the different requests.  The path is specified using the &lt;code&gt;@Path&lt;/code&gt; annotation.  Quarkus also supports &lt;a href="https://quarkus.io/guides/spring-web"&gt;Spring controller&lt;/a&gt; annotations such as &lt;code&gt;@GetMapping&lt;/code&gt; or &lt;code&gt;@RestController&lt;/code&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是一个Java EE或Spring的用户，这个开发模型应该看起来很熟悉。你暴露一个资源，其中包含有&lt;code&gt;@GET&lt;/code&gt;, &lt;code&gt;@POST&lt;/code&gt;...&amp;ZeroWidthSpace;&amp;ZeroWidthSpace; 注释的方法来处理不同的请求。路径是使用&lt;code&gt;@Path&lt;/code&gt;注解指定的。Quarkus还支持&lt;a href="https://quarkus.io/guides/spring-web"&gt;Spring控制器&lt;/a&gt;注释，如&lt;code&gt;@GetMapping&lt;/code&gt;或&lt;code&gt;@RestController&lt;/code&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the JPA entity manager directly.  Panache proposes an alternative removing boilerplate and exposing an active record and repository models.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以直接使用JPA实体管理器。Panache提出了一个替代方案，去掉了模板，暴露了一个活跃的记录和存储库模型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Panache, the &lt;code&gt;Element&lt;/code&gt; class would be as simple as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了Panache，&lt;code&gt;Element&lt;/code&gt;类就会像这样简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microservices tend to come in systems.  Let’s now imagine you need to access another HTTP endpoint.  You can use an HTTP client directly; this is nothing more than repeating boilerplate code.  Quarkus provides a way to call HTTP endpoints easily using the &lt;a href="https://quarkus.io/guides/rest-client"&gt;MicroProfile Rest Client API&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>微服务往往是以系统的形式出现的。现在让我们想象一下，你需要访问另一个HTTP端点。你可以直接使用HTTP客户端；这不过是在重复模板代码。Quarkus提供了一种方法，可以使用&lt;a href="https://quarkus.io/guides/rest-client"&gt;MicroProfile Rest Client API&lt;/a&gt;轻松调用HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First declare your service as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先声明你的服务如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each call you are intending to do, add a method and use annotations to describe the behavior.  You can combine the REST Client with the &lt;a href="https://quarkus.io/guides/smallrye-fault-tolerance"&gt;fault tolerance extension&lt;/a&gt; to handle failure gracefully.  Then, in your resource, just use the &lt;code&gt;ElementService&lt;/code&gt; interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于你打算做的每个调用，添加一个方法并使用注解来描述行为。您可以将REST客户端与&lt;a href="https://quarkus.io/guides/smallrye-fault-tolerance"&gt;容错扩展&lt;/a&gt;结合起来，以优雅地处理失败。然后，在你的资源中，只需使用&lt;code&gt;ElementService&lt;/code&gt;接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you may be wondering where the URL is configured as it’s not in the code. Remember, it must not be hard-coded because the URL likely depends on the environment. The URL is configured in the application configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但你可能想知道URL是在哪里配置的，因为它不在代码中。记住，它不能是硬编码的，因为URL很可能取决于环境。URL是在应用程序配置中设置的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL can now be updated during the deployment or at launch time using system properties or environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在可以在部署期间或在启动时使用系统属性或环境变量更新URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is not limited to HTTP.  You can use &lt;a href="https://quarkus.io/guides/grpc-getting-started"&gt;gRPC&lt;/a&gt; or &lt;a href="https://quarkus.io/guides/smallrye-graphql"&gt;GraphQL&lt;/a&gt;, two prominent alternatives in the microservice space.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus并不局限于HTTP。您可以使用&lt;a href="https://quarkus.io/guides/grpc-getting-started"&gt;gRPC&lt;/a&gt;或&lt;a href="https://quarkus.io/guides/smallrye-graphql"&gt;GraphQL&lt;/a&gt;，这是微服务领域的两个突出的替代方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a class="anchor" href="#being-reactive"&gt;&lt;/a&gt;Being reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a class="anchor" href="#being-reactive"&gt;&lt;/a&gt;响应式风格</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, Big Data, or IoT, going reactive is increasingly becoming the architecture style to follow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在过去的几年里，应用需求发生了巨大的变化。任何应用要想在云计算、大数据或物联网时代取得成功，采取响应式的做法正日益成为应遵循的架构风格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today’s users embrace applications with milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput, and elasticity. However, these features are nearly impossible to achieve using yesterday’s software architecture without a considerable investment in resources, infrastructure, and tooling. The world changed, and having dozens of servers, long response times (&amp;gt; 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今天的用户接受具有几毫秒响应时间、100%正常运行时间、更低延迟、推送数据而不是拉动、更高的吞吐量和弹性的应用程序。然而，如果不对资源、基础设施和工具进行大量投资，使用昨天的软件架构几乎不可能实现这些功能。世界变了，拥有几十台服务器、较长的响应时间（&gt;500毫秒）、因维护或瀑布式的故障而导致的停机时间，并不能满足预期的用户体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus aids you on your journey to reactive.  Quarkus is based on a &lt;a href="https://quarkus.io/version/main/guides/quarkus-reactive-architecture"&gt;reactive core&lt;/a&gt; allowing your application to mix reactive and imperative components.  As an example, you can implement reactive HTTP endpoint using the &lt;a href="https://quarkus.io/guides/resteasy-reactive"&gt;RESTEasy Reactive extension&lt;/a&gt; as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus可以帮助您实现响应式的旅程。Quarkus基于&lt;a href="https://quarkus.io/version/main/guides/quarkus-reactive-architecture"&gt;响应式核心&lt;/a&gt;，允许您的应用程序混合响应式和指令式组件。例如，您可以使用&lt;a href="https://quarkus.io/guides/resteasy-reactive"&gt;RESTEasy 响应式扩展&lt;/a&gt;实现响应式HTTP端点，具体如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , you can compose asynchronous operations and complete the result when everything is done without blocking the I/O threads.  This greatly improves resource consumption and elasticity.  Most Quarkus APIs are available in both imperative and reactive.  As example, you can use the reactive version of the REST Client:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用&lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny 响应式API&lt;/a&gt;，你可以组成异步操作，并在不阻塞I/O线程的情况下达成一切结果。这大大改善了资源消耗和弹性。大多数Quarkus API都可以使用指令式和响应式两种方式。例如，你可以使用REST客户端的响应式版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about streams? Generating a &lt;em&gt;server-sent event&lt;/em&gt; response with Quarkus is just as simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>还有，事件流怎么处理？用Quarkus生成一个&lt;em&gt;server-sent 事件&lt;/em&gt;响应也同样简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, HTTP characteristics prohibit implementing &lt;a href="https://www.reactivemanifesto.org/"&gt;reactive systems&lt;/a&gt;, where all the components interact using asynchronous messages passing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，HTTP的特性禁止实现&lt;a href="https://www.reactivemanifesto.org/"&gt;响应式系统&lt;/a&gt;，即所有组件都使用异步消息传递进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you can consume messages from various brokers such as AMQP or Apache Kafka, and process these messages smoothly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，你可以从AMQP或Apache Kafka等各种代理那里消费消息，并顺利地处理这些消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;code&gt;@Incoming&lt;/code&gt; and &lt;code&gt;@Outgoing&lt;/code&gt; annotations are part of &lt;a href="https://www.smallrye.io/smallrye-reactive-messaging"&gt;Reactive Messaging&lt;/a&gt;.  They are used to express from which &lt;em&gt;channel&lt;/em&gt; you are consuming and to which &lt;em&gt;channel&lt;/em&gt; you are sending.  Thanks to Reactive Messaging you can consume and send messages from and to different brokers and transports such as HTTP, Kafka, or &lt;a href="http://camel.apache.org"&gt;Apache Camel&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code&gt;@Incoming&lt;/code&gt; 和 &lt;code&gt;@Outgoing&lt;/code&gt; 注解是&lt;a href="https://www.smallrye.io/smallrye-reactive-messaging"&gt;响应式消息&lt;/a&gt;的一部分。它们用于表达您从哪个&lt;em&gt;channel&lt;/em&gt;消费，以及向哪个&lt;em&gt;channel&lt;/em&gt;发送。由于响应式消息传递，您可以从不同的代理和传输工具（如HTTP、Kafka或&lt;a href="http://camel.apache.org"&gt;Apache Camel&lt;/a&gt;）消费和发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you need more than just handling messages one by one.  You can also express your message processing logic using reactive programming as illustrated in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时你需要的不仅仅是逐一处理消息。你也可以使用响应式编程来表达消息处理逻辑，如下面的片段所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for the reactive APIs exposed by Quarkus, stream manipulation uses the Mutiny API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么Quarkus的采用Mutiny API作为响应式API来进行流操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments.  Quarkus provides Funqy, an approach to writing functions that are deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative Events (Cloud Events). It is also usable as a standalone service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于其出色的启动时间和较低的内存使用，您可以使用Quarkus实现在无服务器环境中使用的功能。Quarkus提供了Funqy，一种编写可部署到各种FaaS环境中的函数的方法，如AWS Lambda、Azure函数、Knative和Knative事件(云事件)。它也可以作为一个独立的服务使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Funqy, a function is just:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy函数就像是这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在函数中使用任何Quarkus特性，并受益于快速启动和低内存利用率。使用Quarkus，您无需改变编程语言就可以拥抱这个新世界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java" target="_blank"&gt;an IDE&lt;/a&gt; like &lt;a href="https://www.jetbrains.com/idea/download/"&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href="https://www.eclipse.org/downloads/"&gt;Eclipse&lt;/a&gt;, &lt;a href="https://code.visualstudio.com/Download"&gt;VSCode&lt;/a&gt; or even &lt;a href="https://spacevim.org/use-vim-as-a-java-ide/"&gt;Vim&lt;/a&gt; or &lt;a href="http://spacemacs.org"&gt;Emacs&lt;/a&gt;!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java" target="_blank"&gt;一个IDE&lt;/a&gt;，比如&lt;a href="https://www.jetbrains.com/idea/download/"&gt;IntelliJ IDEA&lt;/a&gt;，&lt;a href="https://www.eclipse.org/downloads/"&gt;Eclipse&lt;/a&gt;、&lt;a href="https://code.visualstudio.com/Download"&gt;VSCode&lt;/a&gt;或者至少有一个&lt;a href="https://spacevim.org/use-vim-as-a-java-ide/"&gt;Vim&lt;/a&gt;、&lt;a href="http://spacemacs.org"&gt;Emacs&lt;/a&gt;文本编辑器！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need a &lt;a href="https://adoptopenjdk.net" target="_blank"&gt;a JDK {{ site.data.versions.jdk }}&lt;/a&gt; (any distribution)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要一个&lt;a href="https://adoptopenjdk.net" target="_blank"&gt;JDK {{ site.data.version.jdk }}&lt;/a&gt;（任意发行版）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally get &lt;a href="https://www.graalvm.org/" target="_blank"&gt;GraalVM&lt;/a&gt; {{ site.data.versions.graalvm }} for native compilation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可选择获取&lt;a href="https://www.graalvm.org/" target="_blank"&gt;GraalVM&lt;/a&gt; {{ site.data.version.graalvm }}进行原生编译</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.versions.maven }}&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.version.maven }}&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://code.quarkus.io"&gt;Start Coding&lt;/a&gt; with Quarkus {{ site.data.versions.quarkus.version }} [&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;announce&lt;/a&gt;|&lt;a href="https://github.com/quarkusio/quarkus/releases/tag/{{ site.data.versions.quarkus.version }}"&gt;changelog&lt;/a&gt;]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用Quarkus {{ site.data.versions.quarkus.version }} [&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;通告&lt;/a&gt;|&lt;a href="https://github.com/quarkusio/quarkus/releases/tag/{{ site.data.versions.quarkus.version }}"&gt;变更日志&lt;/a&gt;]&lt;a href="https://code.quarkus.io"&gt;开始写代码&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional Java stacks were engineered for monolithic applications with long startup times and large memory requirements in a world where the cloud, containers, and Kubernetes did not exist. Java frameworks needed to evolve to meet the needs of this new world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的Java堆栈是为单体应用设计的，启动时间长，内存需求大，而当时还没有云、容器和Kubernetes的存在。Java框架需要发展以满足这个新世界的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was created to enable Java developers to create applications for a modern, cloud-native world. Quarkus is a Kubernetes-native Java framework tailored for GraalVM and HotSpot, crafted from best-of-breed Java libraries and standards. The goal is to make Java the leading platform in Kubernetes and serverless environments while offering developers a framework to address a wider range of distributed application architectures.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的创建是为了使Java开发人员能够为现代的、云原生的世界创建应用程序。Quarkus是一个为GraalVM和HotSpot定制的Kubernetes原生Java框架，由最佳的Java库和标准精心打造。其目标是使Java成为Kubernetes和无服务器环境的领先平台，同时为开发者提供一个框架，以解决更广泛的分布式应用架构问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open Source Utterly and Absolutely</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全和绝对地开放源代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What Makes Quarkus Different?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是什么让Quarkus与众不同？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developers are critical to the success of almost every organization and they need the tools to build cloud-native applications quickly and efficiently. Quarkus provides a frictionless development experience through a combination of tools, libraries, extensions, and more. Quarkus makes developers more efficient with tools to improve the inner loop development cycle while in dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发人员对几乎每个组织的成功都至关重要，他们需要工具来快速、高效地构建云原生应用程序。Quarkus通过工具、库、扩展等的组合提供了无摩擦的开发体验。Quarkus通过工具使开发人员在开发模式下更有效率地改善内循环开发周期。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was built from the ground up for Kubernetes making it easy to deploy applications without having to understand all of the complexities of the platform. Quarkus allows developers to automatically generate Kubernetes resources including building and deploying container images without having to manually create YAML files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是为Kubernetes建立的，使其能够轻松部署应用程序，而无需了解该平台的所有复杂性。Quarkus允许开发者自动生成Kubernetes资源，包括构建和部署容器镜像，而无需手动创建YAML文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of hundreds of best-of-breed libraries that you love and use. All wired on a standard backbone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个内聚的、使用起来有趣的全栈框架，它利用了您所喜爱和使用的数百个最佳组合库，都将其连接在一个标准主干上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative and reactive code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式和响应式代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is designed to seamlessly combine the familiar imperative style code and the non-blocking, reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的设计是为了在开发应用程序时将熟悉的指令式和非阻塞的响应式代码无缝结合起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is helpful for both Java developers who are used to working with the imperative model and don’t want to switch things up, and those working with a cloud-native/reactive approach. The Quarkus development model can adapt itself to whatever app you’re developing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这对于那些习惯于使用指令式模型并且不想改变的Java开发人员，以及那些使用原生云/响应式方法的开发人员都是有帮助的。Quarkus开发模型可以适应您正在开发的任何应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Help from the Community</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从社区获得帮助</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a lot of documentation. Be sure to check our &lt;a href="{{site.baseurl}}/get-started/"&gt;Getting started page&lt;/a&gt;, and all our &lt;a href="{{site.baseurl}}/guides/"&gt;guides&lt;/a&gt;. Also check out our &lt;a href="{{site.baseurl}}/faq/"&gt;FAQ section&lt;/a&gt; and &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips Playlist&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们有大量的文档。请务必查看我们的&lt;a href="{{site.baseurl}}/get-started/"&gt;入门页面&lt;/a&gt;，以及我们所有的&lt;a href="{{site.baseurl}}/guides/"&gt;指南&lt;/a&gt;。还可以查看我们的&lt;a href="{{site.baseurl}}/faq/"&gt;FAQ部分&lt;/a&gt;和&lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips 播放列表&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stack Overflow</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stack Overflow</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask your questions on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow&lt;/a&gt;. After the documentation, it’s probably the best place to look for answers. We actively monitor the &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Quarkus tag&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow&lt;/a&gt;上提出您的问题。在文档化之后，它可能是寻找答案的最佳地方。我们积极跟踪&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Quarkus标签&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discussions and Collaboration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>讨论与合作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out our &lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;GitHub Discussions&lt;/a&gt; collaboration area to interact with other Quarkus users and developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请查看我们的&lt;a href="https://github.com/quarkusio/quarkus/discussions"&gt;GitHub讨论&lt;/a&gt;协作区，与其他Quarkus用户和开发人员进行互动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discuss the development of Quarkus with the team in the &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;development mailing list &lt;/a&gt; or by &lt;a href="https://quarkusio.zulipchat.com/"&gt;Zulip Chat&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与团队讨论Quarkus开发的地方是 &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;开发邮件列表 &lt;/a&gt; 或通过 &lt;a href="https://quarkusio.zulipchat.com/"&gt;Zulip Chat&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;span href="{{site.baseurl}}/community/"&gt;Community &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span href="{{site.baseurl}}/community/"&gt;社区 &lt;i class="fas fa-chevron-down"&gt;&lt;/i&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supersonic Subatomic Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>超音速 亚原子 Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don’t want you to spend hours learning new technologies. Instead, the Quarkus programming model builds on top of proven standards. Be it official standards such as Eclipse MicroProfile or leading frameworks in a specific domain such as Eclipse Vert.x.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们不希望你花时间学习新技术。相反，Quarkus编程模型构建在经过验证的标准之上。无论是官方标准(如Eclipse MicroProfile)还是特定领域的领先框架(如Eclipse Vert.x)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our dependency injection solution is based on CDI. You can use JAX-RS annotations to define the REST endpoints. You can use JPA annotations to map your persistent entities and JTA annotations to declare the transaction boundaries. You can use Eclipse MicroProfile to configure and monitor your application. You can use Vert.x, Apache Camel and we support much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的依赖注入方案是基于CDI的。可以使用JAX-RS注解定义REST端点。您可以使用JPA注解来映射持久实体，使用JTA注解来声明事务边界。可以使用Eclipse MicroProfile配置和监视应用程序。你可以使用Vert.x, Apache Camel，我们还支持更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we’re not limited to standards we can go beyond and extend your possibilities. Of course, Quarkus is not a passive consumer. Our goal is to improve and innovate the technologies we use and contribute back to the open source projects and standards we rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们不受标准的限制，我们可以超越并扩展您的可能性。当然，Quarkus不是一个被动的消费者。我们的目标是改进和创新我们所使用的技术，并为我们所依赖的开源项目和标准做出贡献。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.versions.maven }}&lt;/a&gt; or &lt;a href="https://gradle.org/" target="_blank"&gt;Gradle&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要&lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.version.maven }}&lt;/a&gt;或&lt;a href="https://gradle.org/" target="_blank"&gt;Gradle&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container First</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>容器优先</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus tailors your application for GraalVM and HotSpot. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes. We use a technique we call compile time boot. &lt;a href="/vision/container-first"&gt;Learn more.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为GraalVM和HotSpot定制您的应用程序。惊人的快速启动时间，令人难以置信的低RSS内存（不仅仅是堆大小！）提供近乎即时的扩展和在Kubernetes等容器编排平台中高密度内存利用率。我们使用一种称为编译时引导的技术。&lt;a href="/vision/container-first"&gt;了解更多信息。&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>博客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proven Java for the Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>经过验证的云计算Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为Quarkus.io网站贡献力量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>欢迎贡献，请为 `develop` 分支提交pull requests。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**重要：** 指南保存在主Quarkus仓库中，合并请求应该提交在那里：
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序针对低内存使用和快速启动时间进行了优化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lifecycle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/lifecycle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scheduler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-native-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/building-native-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-neo4j/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-neo4j/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-transit.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-transit.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sqs.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sqs.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vertx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ses.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ses.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-s3.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-s3.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/infinispan-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/infinispan-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-logging-sentry/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-logging-sentry/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-tika/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-tika/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-kms.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-kms.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-iam.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-iam.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/jms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ssm.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-ssm.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-auth.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-auth.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-routes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/opentracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-perties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/websockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/websockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-oauth2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-oauth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-config-extensions/dev/consul.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-config-extensions/dev/consul.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-dynamodb.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-dynamodb.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jdbc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jdbc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-di</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-di</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/context-propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/context-propagation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-graphql</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-graphql</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mailer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/transaction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-fault-tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-fault-tolerance</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-jgit/dev/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-jgit/dev/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/logging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-pki.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-pki.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sns.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-amazon-services/dev/amazon-sns.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-datasource.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-vault/dev/vault-datasource.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-json</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-json</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jwt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/http-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/http-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond simply working, we’re aiming for Joy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了工作，我们的目标是充满乐趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour - Sound Check... Getting Started with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡回-试音…从Quarkus开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s go to the quark of things.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们来看看quark的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Articles, blogs, podcast and other tidbits published online around Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>围绕Quarkus在线发布的文章、博客、播客和其他花絮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Short informative videos that highlight unique technical points and instructions on how to get the most out of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简短的信息视频突出了独特的技术要点和关于如何最大限度地利用Quarkus的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-Person and online events which feature Quarkus tracks, discussion and topics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以Quarkus为特色的现场和在线活动、讨论和话题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>活动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn step by step how to build a simple extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一步一步地学习如何构建一个简单的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building My First Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建我的第一个扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-my-first-extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/building-my-first-extension</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions optimize your applications by pushing as much work as possible to the build operation. This guide explains the rationale of Quarkus extensions and guides you through authoring your own extensions.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus扩展通过将尽可能多的工作推给构建操作来优化你的应用程序。本指南解释了Quarkus扩展的基本原理，并指导你编写你自己的扩展。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Your Own Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写您自己的扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus class loading infrastructure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解关于Quarkus类加载基础设施的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class Loading Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>类加载参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入门指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to create your first Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何创建您的第一个Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through First Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指导您完成第一个应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about developing reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解有关使用Quarkus开发响应式应用程序的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build native executables with GraalVM or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用GraalVM或Mandrel构建原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the Quarkus developer toolchain which makes Quarkus development so fast and enjoyable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索Quarkus开发者工具链，让Quarkus开发如此快速和愉快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using our Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用我们的工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus integrations in IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus在IDE中的整合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Tools in your favorite IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你最喜欢的IDE中使用Quarkus工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/ide-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/ide-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Core</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>核心</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code is a no go (even if we all did it at some point ;-)). In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的代码中将值硬编码是行不通的（即使我们在某些时候都会这样做;-)）。在本指南中，我们学习如何配置你的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置你的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to configure your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何配置你的Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Group multiple configuration properties into an object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将多个配置属性分组到一个对象中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping Configuration to Objects</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将配置映射到对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-mappings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-mappings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extend and customize the Configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展和定制配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending Configuration Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展配置支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-extending-support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-extending-support</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YAML as a Configuration Source.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML 作为配置源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-yaml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List all the configuration properties per extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>列出每个扩展的所有配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/all-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops. This guide explains how to be notified when an application stops or starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你经常需要在应用程序启动时执行自定义动作，在应用程序停止时清理一切。本指南解释了如何在应用程序停止或启动时获得通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Initialization and Termination</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序的初始化和终止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus DI解决方案是基于 [Java的上下文和依赖注入 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) 规范。本指南解释了CDI的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go more in depth into the Quarkus implementation of CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更深入地了解Quarkus对CDI的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to develop reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何用Quarkus开发响应式应用程序的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mutiny-primer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mutiny-primer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括：
* 在JVM模式下的测试
* 在原生模式下的测试
* 将资源注入测试
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试你的应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get early test feedback with Continuous Testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过持续测试获得早期测试反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/continuous-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/continuous-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of all extensions that support Dev Services and their configuration options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有支持开发服务的扩展及其配置选项的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic Service Setup with Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用开发服务的自动服务设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains logging and how to configure it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了日志记录以及如何配置它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains how to develop command line applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南解释了如何用Quarkus开发命令行应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Mode Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令模式参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can pass contextual information with SmallRye Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何利用SmallRye Context Propagation传递上下文信息的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context Propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务和安全上下文传播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native executables to support SSL, as native executables don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将讨论如何让你的原生可执行文件支持SSL，因为原生可执行文件并不支持开箱即用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using SSL With Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在原生可执行文件中使用SSL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the base runtime image used by Quarkus for native executables and how you can tweak it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus用于原生可执行文件的基本运行时镜像，以及如何调整它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base Runtime Image for Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生可执行文件的基本运行时镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quarkus-runtime-base-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quarkus-runtime-base-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how you can reduce the size of your native executables with UPX.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解你如何用UPX减少你的原生可执行文件的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compress Native Executables with UPX</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用UPX压缩原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/upx</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/upx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南收集了一些提示，帮助你解决将应用程序编译为原生可执行文件时遇到的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Native Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写原生应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore in more details how to debug native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更详细地探讨如何调试原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/native-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON现在是微服务之间的通用语言。在本指南中，我们看看如何让你的REST服务消费和提供JSON有效载荷。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction to writing REST JSON Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST JSON服务的介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to develop highly scalable REST services with JAX-RS and RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用JAX-RS和RESTEasy Reactive开发高度可扩展的REST服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing REST Services Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST服务参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy Reactive REST Client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用RESTEasy Reactive REST客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用REST客户端（包括JSON）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to migrate an application from RESTEasy Classic to RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将一个应用从RESTEasy 指令式迁移到RESTEasy 响应式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Migrating from RESTEasy Classic to RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从RESTEasy 指令式迁移到RESTEasy 响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive-migration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy-reactive-migration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache simplifies the creation of CRUD applications based on JAX-RS and Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运用Panache来操作Hibernate ORM REST数据，简化了基于JAX-RS和Hibernate ORM的CRUD应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple REST CRUD Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写简单的REST CRUD服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation in your REST services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在REST服务中使用Hibernate验证器/Bean验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation with Hibernate Validator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Hibernate验证器进行验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy REST Client to send multipart REST requests, typically to upload documents.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍如何使用RESTEasy REST客户端发送多部分REST请求，通常是为了上传文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client with Multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Multipart的REST客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize web sockets to create interactive web applications. Because it’s the canonical web socket application, we are going to create a simple chat application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用网络套接字来创建交互式网络应用。因为它是典型的网络套接字应用程序，我们将创建一个简单的聊天应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using WebSockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebSockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用OpenAPI扩展来生成OpenAPI描述符，并获得一个Swagger UI前端来测试你的REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenAPI and Swagger UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenAPI和Swagger UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy REST Client in order to interact with REST APIs (JSON and other) with very little effort.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用RESTEasy REST客户端，以便用很少的精力与REST API（JSON和其他）进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developing REST Services with RESTEasy Classic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用RESTEasy Classic开发REST服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the RESTEasy Classic REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用RESTEasy Classic REST客户端（包括JSON）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于配置Quarkus基于Vert.x的HTTP层的信息--如果你使用servlets的话，还有Undertow。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Fault Tolerance specification through the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何通过SmallRye容错扩展来利用SmallRye容错规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用容错技术</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use reactive routes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用响应式路由。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式路由</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage SmallRye GraphQL to implement GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何利用SmallRye GraphQL来实现GraphQL服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing GraphQL Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实施GraphQL服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage SmallRye GraphQL Client to consume GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何利用SmallRye GraphQL客户端来消费GraphQL服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming GraphQL Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费GraphQL服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/smallrye-graphql-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/smallrye-graphql-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, you can easily configure a datasource, or several if need be.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus，你可以很容易地配置一个数据源，如果需要的话，也可以配置若干个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置你的数据源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breath of an Object Relational Mapper. It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，为你提供了对象关系映射器的全部功能。它在Quarkus中工作得很好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate ORM and JPA</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Hibernate ORM和JPA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Panache focuses on making your entities trivial and fun to write.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，提供了全方位的对象关系映射支持。
它支持编写复杂的映射，但编写简单常用的映射却不够简便。
Panache专注于简化Hibernate ORM实体，让你的Quarkus开发有趣。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate ORM with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache简化Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This explain the specifics of using Hibernate ORM with Panache in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将解释在Kotlin项目中使用Hibernate ORM与Panache的具体细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate ORM with Panache and Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Panache和Kotlin简化Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search allows you to index your entities in an Elasticsearch cluster and easily offer full text search in all your Hibernate ORM-based applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Search允许你在Elasticsearch集群中索引你的实体，并在你所有基于Hibernate ORM的应用程序中轻松提供全文搜索。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带一个事务管理器，并使用它来协调和暴露事务给你的应用程序。每个处理持久性的扩展都会为你与它集成。而且你将通过CDI明确地与事务进行交互。本指南将指导你完成这一切。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Blaze-Persistence to simplify your data and DTO layers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Blaze-Persistence来简化你的数据和DTO层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Blaze-Persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Blaze-Persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to cache expensive method calls of your CDI beans using simple annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用简单的注解来缓存CDI Bean中昂贵的方法调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cache your application data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>缓存你的应用程序数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Flyway extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何使用Flyway扩展来管理你的模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Schema Migration with Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Flyway进行模式迁移</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Liquibase extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何使用Liquibase扩展来管理你的模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Schema Migration with Liquibase</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Liquibase进行模式迁移</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/liquibase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Reactive SQL Clients in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Quarkus中使用响应式SQL客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式SQL客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Hibernate响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified reactive ORM layer based on Hibernate Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于Hibernate 响应式的简化响应式ORM层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Hibernate Reactive with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化的Hibernate 响应式与Panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-reactive-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-reactive-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an in memory data grid that allows running in a server outside of application processes. This extension provides functionality to allow the client that can connect to said server when running in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan是一个内存中的数据网格，允许在应用程序进程之外的服务器中运行。这个扩展提供了功能，允许在Quarkus中运行时可以连接到所述服务器的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Infinispan Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Infinispan客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use an Elasticsearch cluster using the low level or high level REST clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何使用低级或高级的REST客户端来使用Elasticsearch集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Elasticsearch automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Elasticsearch。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/elasticsearch-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use MongoDB in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用MongoDB。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manage your MongoDB schema migrations with Liquibase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Liquibase管理你的MongoDB模式迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase MongoDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibase MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase-mongodb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/liquibase-mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了MongoDB使用活动记录和存储库的用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了在Kotlin项目中使用活动记录和存储库的MongoDB的用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache and Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache和Kotlin的MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use a Redis datastore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Redis数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to customize the Redis client to your needs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何根据自己的需要定制Redis客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Redis automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Redis。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Neo4j graph database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用Neo4j图数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkiverse-hub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkiverse-hub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Apache Cassandra NoSQL database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Apache Cassandra NoSQL数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cassandra</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cassandra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon DynamoDB database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Amazon DynamoDB数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon DynamoDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon DynamoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon S3 cloud storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用Amazon S3云存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon S3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP BigQuery in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP BigQuery。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud BigQuery</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud BigQuery</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigquery.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigquery.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Bigtable in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Bigtable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Bigtable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Bigtable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigtable.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/bigtable.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Firestore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Firestore。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Firestore</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Firestore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/firestore.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/firestore.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Spanner in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP Spanner。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Spanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Spanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/spanner.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/spanner.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Storage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Storage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/storage.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/storage.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of Software Transactional Memory (STM).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了软件事务性内存（STM）的使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Software Transactional Memory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用软件事务性内存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of LRA to coordinate activities across services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了使用LRA来协调跨服务的活动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using LRA (Long Running Actions)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用LRA（长期运行的活动）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lra</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/lra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的Quarkus应用程序如何利用SmallRye响应式消息传递与Apache Kafka进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started to SmallRye Reactive Messaging with Apache Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始使用Apache Kafka的SmallRye响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-reactive-getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-reactive-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide provides an in-depth look on Apache Kafka and Smallrye Reactive Messaging framework.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南深入介绍了Apache Kafka和Smallrye响应式消息传递框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Apache Kafka automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Apache Kafka。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Apache Kafka, Avro serialized records, and connect to a schema registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka，Avro序列化记录，并连接到一个模式注册中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Apache Kafka with Schema Registry and Avro</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka与模式仓库和Avro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-schema-registry-avro</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-schema-registry-avro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Apicurio Registry automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Apicurio仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/apicurio-registry-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/apicurio-registry-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye响应式消息传递与AMQP进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AMQP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用AMQP与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference guide for SmallRye Reactive Messaging and AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye响应式消息传递和AMQP的参考指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start AMQP automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动AMQP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with RabbitMQ.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的 Quarkus 应用程序如何利用 SmallRye响应式消息传递与RabbitMQ进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RabbitMQ with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用RabbitMQ与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference guide for SmallRye Reactive Messaging and RabbitMQ.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye响应式消息传递和RabbitMQ的参考指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start RabbitMQ automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动 RabbitMQ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rabbitmq-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rabbitmq-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce HTTP messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye响应式消息传递来消费和提供HTTP消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HTTP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用HTTP与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce messages via WebSockets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了您的Quarkus应用程序如何利用SmallRye响应式消息通过WebSockets来消费和产生消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using WebSockets with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebSockets与响应式消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-messaging-websocket</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-messaging-websocket</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用如何利用Apache Kafka Streams API来实现基于Apache Kafka的流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Apache Kafka Streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Apache Kafka Streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how different beans can interact using the event bus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了不同的Bean如何使用事件总线进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use JMS messaging with AMQP 1.0 using Apache Qpid JMS, or using Apache ActiveMQ Artemis JMS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用AMQP 1.0的Apache Qpid JMS，或使用Apache ActiveMQ Artemis JMS进行JMS信息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using JMS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP PubSub in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用GCP PubSub。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud PubSub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud PubSub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/pubsub.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/pubsub.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the entry point for everything security in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是Quarkus中一切安全问题的入口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Overview</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secure your web endpoints with authorizations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用授权来保护你的网络端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization of Web Endpoints</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网络端点的授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how Quarkus handles authentication.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus如何处理认证的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-In Authentication Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内置的认证支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-built-in-authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-built-in-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customize Quarkus' security layer behavior.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义Quarkus的安全层行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Customization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全定制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-customization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-customization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test the security of your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试你的Quarkus应用程序的安全性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安全测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a .properties file to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用.properties文件来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with .properties File</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用.properties文件的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用Hibernate ORM的数据库来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with JPA</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JPA的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jpa</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用数据库来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with JDBC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JDBC的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a LDAP directory to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用LDAP目录来存储你的用户身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with LDAP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用LDAP的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-ldap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-ldap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect extension to protect your Quarkus JAX-RS service application using Bearer Token Authorization where the tokens are issued by OpenID Connect Providers such as Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用OpenID Connect扩展来保护你的Quarkus JAX-RS服务应用程序，使用Bearer令牌授权，其中令牌由OpenID Connect提供者（如Keycloak）出具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) to Protect Service Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）来保护服务应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect extension to protect your Quarkus JAX-RS web application using the Authorization Code Flow and OpenID Connect Providers such as Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用OpenID Connect扩展来保护你的Quarkus JAX-RS网络应用程序，使用授权代码流和OpenID Connect提供者，如Keycloak。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) to Protect Web Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）来保护网络应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your OpenID Connect application can support multi-tenancy so that you can serve multiple tenants from a single application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的OpenID Connect应用程序如何支持多租户，这样你就可以从一个应用程序中为多个租户提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) Multi-Tenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）多租户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize access to protected resources using Keycloak Authorization Services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用Keycloak授权服务来授权访问受保护的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) and Keycloak to Centralize Authorizations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）和Keycloak来集中授权</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use OpenID Connect and OAuth2 Client and Filters to acquire, refresh and propagate access tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用OpenID Connect和OAuth2客户端和过滤器来获取、刷新和传播访问令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenID Connect (OIDC) and OAuth2 Client and Filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenID Connect（OIDC）和OAuth2客户端和过滤器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to configure Quarkus to authenticate against well-known OpenID Connect providers such as GitHub, Google, Microsoft, Apple...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何配置Quarkus来验证著名的OpenID Connect提供者，如GitHub、谷歌、微软、苹果...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Well-Known OpenID Connect (OIDC) Providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置知名的OpenID Connect（OIDC）提供者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-providers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Keycloak or other providers automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Keycloak或其他提供者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenID Connect (OIDC) Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect（OIDC）开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can utilize SmallRye JWT to verify JWT tokens and provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的应用程序如何利用SmallRye JWT来验证JWT令牌并为JAX-RS端点提供安全访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using JWT RBAC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用JWT RBAC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can build, sign and/or encrypt JWT tokens with a fluent and configurable SmallRye JWT Build API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的应用程序如何利用流畅且可配置的SmallRye JWT构建API构建、签署和/或加密JWT令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build, Sign and Encrypt JSON Web Tokens (JWT)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立、签署和加密JSON网络令牌(JWT)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt-build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jwt-build</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OAuth2 tokens to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OAuth2令牌来提供对JAX-RS端点的安全访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OAuth2 RBAC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OAuth2 RBAC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault to securely store your credentials in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用HashiCorp Vault在Quarkus中安全地存储您的凭证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault for "encryption as a service".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用HashiCorp Vault进行 "加密即服务"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault Transit Secret Engine</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vault Transit保密引擎</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep confidential your database credentials by storing them in Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将你的数据库凭证存储在Vault中，对其进行保密。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HashiCorp Vault with Databases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在数据库中使用HashiCorp Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains the various methods supported by Quarkus to authenticate to your Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Quarkus支持的各种方法来验证您的Vault。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with HashiCorp Vault’s Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与HashiCorp Vault的认证合作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate X.509 certificates with Vault’s PKI Secret Engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Vault的PKI加密引擎生成X.509证书。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using HashiCorp Vault’s PKI Secret Engine</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用HashiCorp Vault的PKI加密引擎</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides explains how to use the Vault credentials provider or implement your own custom one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Vault凭证提供者或实现你自己的自定义凭证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>证书提供者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/credentials-provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/credentials-provider</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use WebAuthn authentication instead of passwords.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用WebAuthn认证来代替密码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with WebAuthn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用WebAuthn的安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-webauthn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-webauthn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business Automation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>业务自动化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Kogito to add business automation to power it up with business processes and rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了你的Quarkus应用程序如何使用Kogito来添加业务自动化，从而为其提供业务流程和规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add business automation capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加业务自动化功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add business automation and power it up with DMN decision support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来增加业务自动化，并通过DMN决策支持为其提供动力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito DMN support to add decision automation capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito DMN支持为应用程序添加决策自动化功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-dmn</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-dmn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add DRL files with rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来添加带有规则的DRL文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add rule engine capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加规则引擎功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-drl</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-drl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Kogito to add business automation to power it up with predictions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito来添加业务自动化，为其提供预测的动力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kogito to add prediction capabilities to an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kogito为应用程序添加预测功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-pmml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-pmml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Kogito automatically in dev and test modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发和测试模式下自动启动Kogito。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito-dev-services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito-dev-services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将引导你完成用OptaPlanner的约束解决人工智能（AI）创建Quarkus应用程序的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AI to optimize a schedule with OptaPlanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用人工智能来优化OptaPlanner的日程安排</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/optaplanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/optaplanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the systems integration with Apache Camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括与Apache Camel的系统集成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令行应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplify command line applications creation with the Picocli extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Picocli扩展简化了命令行应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Picocli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/picocli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Quarkus-based scripting with jbang.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用jbang轻松实现基于Quarkus的脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jbang整合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scripting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scripting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to use SmallRye Stork for service discovery and load balacing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用SmallRye Stork进行服务发现和负载平衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stork</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stork</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/stork</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/stork</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have a more in-depth look at how SmallRye Stork can be configured and used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更深入地了解如何配置和使用SmallRye Stork。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/stork-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/stork-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to build and push container images with Jib, S2I or Docker as part of the Quarkus build.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用Jib、S2I或Docker构建和推送容器镜像，作为Quarkus构建的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Container Images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建容器镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/container-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/container-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Kubernetes上部署一个原生应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying Quarkus Applications on Kubernetes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kubernetes上部署Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在OpenShift上部署一个原生应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying Quarkus Applications on OpenShift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在OpenShift上部署Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying toopenshift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ConfigMaps as a configuration source for your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用ConfigMaps作为Quarkus应用程序的配置源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming Kubernetes ConfigMaps</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费Kubernetes ConfigMaps</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the Fabric8 Kubernetes client to interact with your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何使用Fabric8 Kubernetes客户端与你的Kubernetes集群互动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Kubernetes Client to Interact with a Kubernetes Cluster</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kubernetes客户端与Kubernetes集群互动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Microsoft Azure Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何将Quarkus应用程序部署到Microsoft Azure云中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Microsoft Azure Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到微软Azure云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Azure Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Azure Function。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Functions (Serverless) with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x Web、Servlet或RESTEasy的Azure Functions（无服务器）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Amazon Lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何部署基于Quarkus的Amazon Lambdas。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Amazon Lambda。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Vert.x Web、Servlet或RESTEasy的Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何将Quarkus应用程序部署到谷歌云。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Google Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到谷歌云</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何部署基于Quarkus的Google Cloud Functions。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as a Google Cloud Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何将Vert.x Web、Servlet或RESTEasy微服务部署为Google Cloud Function。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions with Vert.x Web, Servlet, or RESTEasy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x Web、Servlet或RESTEasy的Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy your Quarkus applications on Heroku.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Heroku上部署你的Quarkus应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to Heroku</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到Heroku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-heroku</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying toheroku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains basics of the Funqy framework, a simple portable cross-provider cloud function API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy框架的基础知识，这是一个简单的可移植的跨供应商的云功能API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Amazon Lambda绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Amazon Lambda HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Knative Events binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Knative Events绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Azure Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Azure Functions HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Google Cloud Platform Functions绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了Funqy的Google Cloud Platform Functions HTTP绑定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Key Management Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用亚马逊密钥管理服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon KMS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon KMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Identity and Access Management in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊身份和访问管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon IAM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon IAM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Email Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊简单电子邮件服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Notification Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用亚马逊简单通知服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SNS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SNS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Queue Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了如何在Quarkus中使用Amazon Simple Queue Service。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SQS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SQS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the AWS Systems Manager in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何在Quarkus中使用AWS系统管理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SSM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SSM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use multiple GCP services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括如何使用多种GCP服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Access Google Cloud services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Access Google Cloud services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/index.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Health extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了您的Quarkus应用程序如何利用SmallRye Health扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用健康检查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTelemetry to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OpenTelemetry来为交互式Web应用程序提供分布式跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenTelemetry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenTelemetry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentelemetry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/opentelemetry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何利用OpenTracing来为交互式网络应用程序提供分布式跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using OpenTracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用OpenTracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can collect metrics using the Micrometer extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何使用Micrometer扩展来收集指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Collecting Metrics with Micrometer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Micrometer收集指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/micrometer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/micrometer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Metrics extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye Metrics扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Collecting Metrics with SmallRye Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用SmallRye Metrics收集指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了你的Quarkus应用程序如何利用SmallRye容错扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Sentry to monitor your application and be notified when exceptions occur.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Sentry来监控你的应用程序，并在发生异常时得到通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Sentry to Monitor your Logs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Sentry来监控你的日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to centralize your logs with Logstash or Fluentd using the Graylog Extended Log Format (GELF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Graylog扩展日志格式（GELF）用Logstash或Fluentd集中管理你的日志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Centralized Log Management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集中的日志管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing REST JSON Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写REST JSON服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Entry point for everything gRPC.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一切gRPC的总入口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to start using gRPC in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中开始使用gRPC。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始使用gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to implement gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中实现gRPC服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing gRPC Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现gRPC服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to consume gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在你的Quarkus应用程序中消费gRPC服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming gRPC Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费gRPC服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Quarkus CLI to create, build, run, and manage extensions for Quarkus projects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus CLI来创建、构建、运行和管理Quarkus项目的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cli-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cli-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了以下内容：
* Maven配置
* 创建新项目
* 处理扩展
* 开发模式 
* 调试
* 在IDE中导入 
* 构建原生可执行文件 
* 构建容器友好型可执行文件
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Applications with Maven</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Maven构建应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/maven-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/maven-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了以下内容：
* Gradle配置 
* 创建新项目 
* 处理扩展 
* 开发模式 
* 调试 
* 在你的IDE中导入 
* 构建原生可执行文件 
* 构建容器友好型可执行文件 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Applications with Gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Gradle构建应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how you can streamline the release process of your Quarkus applications with JReleaser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何利用JReleaser简化Quarkus应用程序的发布过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Releasing your Quarkus applications with JReleaser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用JReleaser发布你的Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jreleaser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/jreleaser</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to measure the test coverage of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何测量你的Quarkus应用程序的测试覆盖率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测量你的测试的覆盖率</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use mutable jars to rebuild your application with different build time configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用易变的jars来重建具有不同构建时间配置的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Re-augment a Quarkus Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重新增强Quarkus应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reaugmentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reaugmentation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the spring-di extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用CDI注解进行注入，但Quarkus以spring-di扩展的形式为Spring依赖注入提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring DI API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring DI API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use JAX-RS annotations for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the spring-web extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用JAX-RS注解来定义REST端点，但Quarkus以spring-web扩展的形式为Spring Web提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Web API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Web API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use Hibernate ORM with Panache for your data layer, Quarkus provides a compatibility layer for Spring Data JPA in the form of the spring-data-jpa extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Hibernate ORM与Panache作为你的数据层，但Quarkus以spring-data-jpa扩展的形式为Spring Data JPA提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Data JPA API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Data JPA API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST simplifies the creation of CRUD applications based on our Spring Data compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Data REST简化了基于我们Spring Data兼容层的CRUD应用程序的创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple CRUD Applications with Spring Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Spring Data编写简单的CRUD应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Quarkus security layer to secure your applications, Quarkus provides a compatibility layer for Spring Security in the form of the spring-security extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Quarkus安全层来保护你的应用程序，但Quarkus以spring-security扩展的形式为Spring Security提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Security API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Security API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Cache extension for your application-level caching, Quarkus provides a compatibility layer for Spring Cache in the form of the spring-cache extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Cache扩展来进行应用级缓存，但Quarkus以spring-cache扩展的形式为Spring Cache提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Scheduler or Quartz extensions to schedule tasks, Quarkus provides a compatibility layer for Spring Scheduled in the form of the spring-scheduled extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励你使用Scheduler或Quartz扩展来安排任务，但Quarkus以spring-scheduled扩展的形式为Spring Scheduled提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Scheduled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot的 `@ConfigurationProperties` ，代替MicroProfile配置注解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Spring Boot's ConfigurationProperties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot的ConfigurationProperties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a compatibility layer for Spring Cloud Config in the form of the spring-cloud-config-client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus以spring-cloud-config-client扩展的形式为Spring Cloud Config提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Extension for Spring Cloud Config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus Extension for Spring Cloud Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Miscellaneous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>杂项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically. In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现代应用程序经常需要定期运行特定的任务。在本指南中，你将学习如何安排定期任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Periodic Tasks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安排周期性任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the Scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Scheduler扩展的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need clustering support for your scheduled tasks? This guide explains how to use the Quartz extension for that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的计划任务需要集群支持？本指南解释了如何使用Quartz扩展来实现这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Clustered Tasks with Quartz</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Quartz调度集群任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quartz</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can send email from a Quarkus application with our reactive email client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何使用我们的响应式电子邮件客户端从Quarkus应用程序发送电子邮件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Emails using SMTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用SMTP发送邮件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains in more details the configuration and usage of the Quarkus Mailer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南更详细地解释了Quarkus Mailer的配置和使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mailer-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can use templating in your applications with the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何利用Qute模板引擎在你的应用程序中使用模板。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templating with Qute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Qute进行模板设计</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn everything you need to know about the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解你需要知道的关于Qute模板引擎的一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/qute-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you extract content from documents using the Apache Tika toolkit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于如何使用Apache Tika工具包从文档中提取内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extracting Content with Apache Tika</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Apache Tika提取内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Vert.x in Quarkus to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何在Quarkus中使用Vert.x来构建响应式应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide provides advanced details about the usage and the configuration of the Vert.x instance used by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南提供了关于Quarkus使用的Vert.x实例的使用和配置的高级细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vertx-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can access Git repositories with JGit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何用JGit访问Git仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Access Git repositories with JGit</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用JGit访问Git存储库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from Consul.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了你的Quarkus应用程序如何在运行时从Consul读取配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume Configuration from Consul</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Consul中消费配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to best measure the footprint of a Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何最好地测量Quarkus应用程序的占用空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring Performance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>衡量性能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/performance-measure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/performance-measure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Secret Manager in Quarkus to consume configuration properties directly or via your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在Quarkus中使用GCP Secret Manager直接或通过 `application.properties` 来使用配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume Configuration from Google Cloud Secret Manager</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从谷歌云秘密管理器中消费配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/secretmanager.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkiverse.github.io/quarkiverse-docs/quarkus-google-cloud-services/main/secretmanager.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Languages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>替代语言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Kotlin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了如何使用Kotlin。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何将你的扩展与Quarkus的CDI容器集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi-integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何让你的扩展为Dev UI贡献功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to Dev UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为开发用户界面做出贡献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-ui</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-ui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore all the BuildItems you can consume/produce in your extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>探索你可以在你的扩展中消费/提供的所有BuildItems。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All BuildItems</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有BuildItems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-builditems</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/all-builditems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How capabilities are implemented and used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus中如何实现和使用功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Capabilities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/capabilities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/capabilities</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Trigger the inclusion on additional extensions based on certain conditions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基于特定条件触发包含附加扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conditional Extension Dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>条件性扩展的依赖性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/conditional-extension-dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/conditional-extension-dependencies</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provide users with initial code for extensions when generating Quarkus applications on code.quarkus.io and all the Quarkus tooling. This guide explains how to create and configure a Codestart for an extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当用户在 code.quarkus.io 和所有Quarkus工具上生成Quarkus应用程序时，为扩展提供初始代码。本指南解释如何为扩展创建和配置Codestart。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a Codestart for an extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为扩展编写Codestart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/extension-codestart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/extension-codestart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus reactive architecture.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解关于Quarkus响应式架构的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quarkus-reactive-architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quarkus-reactive-architecture</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about what we call a Platform in the Quarkus world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于Quarkus 世界中我们称之为平台的东西。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Understanding the Platform concept</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>理解平台概念</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the notion of extension registry and how you can use your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解更多关于扩展仓库的概念，以及如何使用自己的扩展仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/extension-registry-user</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/extension-registry-user</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How dev mode differs from a production application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式与生产应用程序有何不同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Mode Differences</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式的差异</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/dev-mode-differences</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/dev-mode-differences</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连续统一体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序被设计为在容器中运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The format for durations uses the standard `java.time.Duration` format.  You can learn more about it in the link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持续时间的格式使用标准的 `java.time.Duration` 格式您可以在 https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc] 中了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide duration values starting with a number.  In this case, if the value consists only of a number, the converter treats the value as seconds.  Otherwise, `PT` is implicitly prepended to the value to obtain a standard `java.time.Duration` format.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您还可以提供以数字开头的持续时间值。 在这种情况下，如果该值仅包含一个数字，则转换器将该值视为秒。 否则，`PT` 会隐式添加到值的前面，以获得标准的 `java.time.Duration` 格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It’s a snap to be up and running with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>和Quarkus一起工作很容易。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get Started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始体验</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get answers to some of your common Quarkus questions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>找到一些常见Quarkus问题的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用什么许可证？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个使用https://www.apache.org/licenses/LICENSE-2.0[Apache License 2.0版]授权的开源项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我在哪儿能获得到?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus发布在Maven Central中，请查看 link:/extensions[扩展]，只需将它们导入到 `pom.xml`中就可以获得Quarkus。我们建议您通过我们的 link:/get-started[入门指南]开始您的Quarkus体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, we consider Quarkus stable. Remember 95% of the features Quarkus apps use are provided by the ecosystem like Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy, etc. These libraries are rock solid :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是的，我们认为Quarkus是稳定的。请记住，Quarkus应用程序使用的95%的特性都是由Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy等生态系统提供的。这些库是坚如磐石的 :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to https://code.quarkus.io/[code.quarkus.io] to see if a particular extension is _stable_ (default) or _preview_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以访问 https://code.quarkus.io/[code.quarkus.io] 查看特定扩展是否为 _stable_ (默认) or _preview_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的主要目标之一是易于扩展和构建一个充满活力的生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以将Quarkus扩展视为您的项目依赖项。扩展可以配置、引导并将框架或技术集成到您的Quarkus应用程序中。它们还做了所有繁重的工作，为GraalVM提供正确的信息，以便应用程序本地编译。这将允许第三方项目轻松地利用我们所做的工作，使其更容易瞄准GraalVM。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么是扩展状态?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展在进入Quarkus生态系统时具有不同程度的成熟度。状态提供了你可以依赖的期望。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Stable*: backward compatibility and presence in the ecosystem are taken very seriously. An application can safely rely on these extensions. Extensions not marked as preview or experimental (the majority) are stable.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Stable*: 向后兼容性和在生态系统中的存在被非常重视。应用程序可以安全地依赖于这些扩展。没有标记为预览或实验的扩展(大多数)是稳定的。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Preview*: 不能保证向后兼容性和在生态系统中的存在。具体的改进可能需要改变配置、API和计划，使之变得 _stable_ 。这些扩展还处于成熟过程的中间阶段。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Experimental*: early feedback is requested to mature the idea. There is no guarantee of stability nor long term presence in the platform until the solution matures. Such extensions are at the beginning of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Experimental*: 尽早反馈，以使想法更加成熟。在解决方案成熟之前，无法保证平台的稳定性或长期存在。这些扩展正处于其成熟过程的开始阶段。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on https://code.quarkus.io[code.quarkus.io] or in the extension link:/guides/[guides].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在 https://code.quarkus.io[code.quarkus.io] 或在扩展 link:/guides/[手册]中找到扩展状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我可以写一个扩展吗?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will the Quarkus team accept my extension?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus团队会接受我的扩展吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>噢，是的！我们在Quarkus "初始" 团队之外编写了相当多的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an open ecosystem and we hope to see all the extensions people need to write their apps. We are working as we speak to allow an extension to be published in separate repos and separate GAVs and thus published in Maven repos independently of Quarkus core. This will greatly simplify the publication process. Expect news soon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个开放的生态系统，我们希望看到人们编写应用程序所需的所有扩展。我们正在工作，正如我们所说，允许一个扩展在单独的repo和单独的GAV中发布，从而在Maven repo中独立于Quarkus核心发布。这将大大简化发布过程，期待很快有新消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our https://quarkus.io/community/#discussions[mailing list] to discuss your ideas and get help. And you can start reading our https://quarkus.io/guides/writing-extensions[Writing extensions guide] as well or more simply get inspiration from the https://github.com/quarkusio/quarkus/tree/main/extensions[existing ones].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当前的一个限制是，扩展必须同时在OpenJDK和GraalVM本机可执行文件中工作。这是我们给Quarkus用户的保证(他们应用程序的交叉编译)。我们有一个成熟度模型来改进扩展，使其完全 "Quarked" ，并从Quarkus中受益，所有这些都是在增量步骤中完成的。请登录我们的 https://quarkus.io/community/#discussions[邮件列表] 讨论您的想法并获得帮助。你也可以开始阅读我们的 https://quarkus.io/guides/writing-extensions[编写扩展指南]，或者更简单地从 https://github.com/quarkusio/quarkus/tree/main/extensions[现有的扩展] 中获得灵感。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 什么是GraalVM？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.graalvm.org[GraalVM] is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.graalvm.org[GraalVM] 是一个通用的虚拟机，用于运行用各种不同语言编写的应用程序，并提供将JVM字节码编译为原生可执行文件的能力(这个原生可执行文件运行一个名为SubstrateVM的特殊虚拟机)。与传统JVM相比，这些原生可执行文件启动速度更快，使用的内存也少得多，但是并不是所有JVM特性都得到支持，有些特性的限制比一般的要多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，默认情况下，GraalVM中的反射将不能工作，除非类/成员已显式地为反射注册。这通常是通过列出JSON文件中的每个类、方法、字段和构造函数，并将其作为参数传递到原生镜像构建中实现的。显然，除了最简易的项目外，这对于所有项目来说都是相当麻烦的。Quarkus提供了一个框架，可以轻松地处理这些注解，并以编程的方式确定应该注册哪些内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 如何统一指令式编程和响应式编程?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/continuum[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/continuum[了解更多].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/container-first[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/container-first[了解更多].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 对标准有什么考虑?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/standards[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/standards[了解更多].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 项目会做些什么来提高开发者的乐趣?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/developer-joy[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/developer-joy[了解更多].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Browse through these selections of new Quarkus related books and resources to expand your knowledge and hone your coding skills to step up your Quarkus game.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览这些与Quarkus相关的新书籍和资源，扩展您的知识，磨练您的编码技能，从而提升您的Quarkus游戏水平。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour 2021 - Abstracts and Support materials.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年世界巡演-摘要和支持材料。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour 2021 - Sound Check... Getting Started with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2021年世界巡演-试音…从Quarkus开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus团队和社区非常重视所有的安全漏洞。你可以在这里找到关于我们的政策和安全披露的指导方针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reporting security issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>报告安全问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please report any security issues you find in Quarkus to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请将您在Quarkus中发现的任何安全问题报告给：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone can post to this list. The subscribers are only trusted individuals from the Quarkus community who will handle the resolution of any reported security issues in confidence. In your report, please note how you would like to be credited for discovering the issue and the details of any embargo you would like to impose. Currently the security response teams for the following distributions are subscribed to this list and will respond to your report:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任何人都可以在这个列表上发帖。订阅者仅是来自Quarkus社区的受信任的个人，他们将在保密的情况下处理任何报告的安全问题的解决方案。请在你的报告中注明你希望因发现该问题而获得的荣誉，以及你希望实施的任何禁运措施的细节。目前，以下发行版的安全响应团队已经订阅了这个列表，并将对您的报告作出响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ecosystem</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生态系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an ecosystem made from many extensions and many libraries (like Eclipse Vert.x, Hibernate, Apache Camel and more), most of them not under the direct responsibility of the Quarkus team. If you find a security bug possibly rooted in one of these libraries, you can either disclose to them directly or disclose them to the Quarkus team (following this process) and we will responsibly disclose the issue to the respective extension or library maintainer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个由许多扩展和许多库组成的生态系统（如Eclipse Vert.x, Hibernate, Apache Camel等），其中大多数都不是由Quarkus团队直接负责的。如果您发现一个安全漏洞可能根植于这些库中的一个，您可以直接向他们披露，也可以向Quarkus团队披露（遵循此过程），我们将负责地向相应的扩展或库维护人员披露问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为什么要遵循这个过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the sensitive nature of security bugs, the disclosure process is more constrained than a regular bug. We appreciate you following these industry accepted guidelines, which gives time for a proper fix and limit the time window of attack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于安全性缺陷的敏感性，披露过程比普通缺陷更受限制。我们感谢您遵循这些业界公认的指导方针，这些方针为适当的修复提供了时间，并限制了攻击的时间窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Versions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受支持版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>社区将修复最新的major.minor版本安全漏洞，发布于 https://quarkus.io/get-started/。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We may fix the vulnerability to older versions depending on the severity of the issue and the age of the release, but we are only committing to the latest version released.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>根据问题的严重程度和发布的时间，我们可能会修复旧版本的漏洞，但我们只承诺发布的最新版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling security issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理安全问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you represent a Quarkus extension or a Quarkus platform, you are welcome to subscribe to the security at quarkus.io mailing list. Your subscription will only be approved if you can demonstrate that you will handle issues in confidence and properly credit reporters for discovering issues (e.g. experience with embargoe process).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您代表一个Quarkus扩展或Quarkus平台，欢迎您订阅quarkus.io的安全性邮件列表。只有当你能证明你会保密地处理问题，并正确地信任问题发现者时，你的订阅才会被批准（例如，禁运流程的经验）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先决条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide, you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要完成这个指南，你需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个编辑器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装JDK 11以上版本并正确配置了 `JAVA_HOME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>克隆 Git 仓库: `git clone {quickstarts-clone-url}` ，或下载一个 {quickstarts-archive-url}[存档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project. Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要一个新的项目。使用以下命令创建一个新的项目:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将在你的 `pom.xml` 中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then run it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package and run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包并运行该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the MongoDB Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用MongoDB客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB是一个众所周知的NoSQL数据库，被广泛使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use the MongoDB database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们看到如何让你的REST服务使用MongoDB数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB installed or Docker installed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装了MongoDB或安装了Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南中构建的应用程序非常简单：用户可以使用一个表单在列表中添加元素并更新列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server is formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览器和服务器之间的所有信息都被格式化为JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements are stored in MongoDB.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些元素被存储在MongoDB中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `mongodb-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `mongodb-client` 扩展添加到你的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating your first JSON REST service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建你的第一个JSON REST服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of fruits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个例子中，我们将创建一个应用程序来管理fruit列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's create the `Fruit` bean as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，让我们创建 `Fruit` 实体类，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这非常的简单。需要注意的一件事是， JSON 序列化层需要具有默认构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.mongodb.FruitService` that will be the business layer of our application and store/load the fruits from the mongoDB database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在创建一个 `org.acme.mongodb.FruitService` ，它将是我们应用程序的业务层，并从mongoDB数据库 store/load fruits。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitService` to list/add new fruits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现起来非常简单，你只需要使用JAX-RS注解来定义你的端点，并使用 `FruitService` 来list/add新的fruits。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the MongoDB database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置MongoDB数据库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main property to configure is the URL to access to MongoDB, almost all configuration can be included in the connection URI so we advise you to do so, you can find more information in the MongoDB documentation: https://docs.mongodb.com/manual/reference/connection-string/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要配置的主要属性是访问MongoDB的URL，几乎所有的配置都可以包含在连接URI中，所以我们建议你这样做，你可以在MongoDB文档中找到更多信息 https://docs.mongodb.com/manual/reference/connection-string/ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A sample configuration should look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例配置应如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we are using a single instance running on localhost:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在此示例中，我们在 localhost 上运行的单个实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need more configuration properties, there is a full list at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要更多的配置属性，在本指南的末尾有一个完整的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services (Configuration Free Databases)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发服务（免配置数据库）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports a feature called Dev Services that allows you to create various datasources without any config. In the case of MongoDB this support extends to the default MongoDB connection.  What that means practically, is that if you have not configured `quarkus.mongodb.connection-string` Quarkus will automatically start a MongoDB container when running tests or dev-mode, and automatically configure the connection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持一种叫做Dev Services的功能，它允许你在没有任何配置的情况下创建各种数据源。在MongoDB的情况下，这种支持延伸到默认的MongoDB连接。也就是说，如果你没有配置 `quarkus.mongodb.connection-string` ，Quarkus会在运行测试或开发模式时自动启动一个MongoDB容器，并自动配置连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running the production version of the application, the MongoDB connection need to be configured as normal, so if you want to include a production database config in your `application.properties` and continue to use Dev Services we recommend that you use the `%prod.` profile to define your MongoDB settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当运行应用程序的生产版本时，MongoDB连接需要正常配置，如果您希望在 `application.properties` 中包含生产数据库配置并继续使用开发服务，我们建议你使用 `%prod.` 配置文件来定义你的MongoDB设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple MongoDB Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个MongoDB客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB allows you to configure multiple clients.  Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB允许你配置多个客户端。使用多个客户端的方式与拥有一个客户端的方式相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `users` and `inventory` segments).  The syntax is as follows: `quarkus.mongodb.[optional name.][mongo connection property]`.  If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意在键中有一个额外的位（ `users` 和 `inventory` 段）。语法如下： `quarkus.mongodb.[optional name.][mongo connection property]` 。如果省略了名称，则配置默认的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use of multiple MongoDB clients enables multi-tenancy for MongoDB by allowing to connect to multiple MongoDB clusters. + If you want to connect to multiple databases inside the same cluster, multiple clients are **not** necessary as a single client is able to access all databases in the same cluster (like a JDBC connection is able to access to multiple schemas inside the same database).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个 MongoDB 客户端的使用通过允许连接到多个 MongoDB 集群来实现 MongoDB 的多租户。+ 如果你想连接同一集群内的多个数据库，则 **不** 需要使用多个客户端，因为单个客户端能够访问同一集群内的所有数据库（就像JDBC连接能够访问同一数据库内的多个模式）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Mongo client Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以Mongo客户端的名字进行注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, each `MongoClient`, you can select the client to inject using the `io.quarkus.mongodb.MongoClientName` qualifier.  Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用多个客户端时，每个 `MongoClient` ，你可以使用 `io.quarkus.mongodb.MongoClientName` 修饰语选择要注入的客户端。使用上述属性来配置三个不同的客户端，你也可以按以下方式来注入每个客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running a MongoDB Database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行MongoDB数据库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As by default, `MongoClient` is configured to access a local MongoDB database on port 27017 (the default MongoDB port), if you have a local running database on this port, there is nothing more to do before being able to test it!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在默认情况下， `MongoClient` 被配置为在27017端口（默认的MongoDB端口）上访问本地的MongoDB数据库，如果你在这个端口上有一个本地运行的数据库，那么在能够测试之前，不需要做其他操作！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Docker to run a MongoDB database, you can use the following command to launch one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用Docker来运行MongoDB数据库，你可以使用以下命令来启动一个数据库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use &lt;&lt;dev-services,Dev Services&gt;&gt;, launching the container manually is not necessary!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 link:#dev-services[开发服务] ，则不需要手动启动容器！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a frontend</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个网页</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来与我们的 `FruitResource` 进行交互。Quarkus会自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含这个 {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now interact with your REST service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在你可以与你的REST服务进行交互：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>open a browser to `http://localhost:8080/fruits.html`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开浏览器访问 `&lt;a href="http://localhost:8080/fruits.html" class="bare"&gt;http://localhost:8080/fruits.html&lt;/a&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive MongoDB Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式MongoDB客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A reactive MongoDB Client is included in Quarkus.  Using it is as easy as using the classic MongoDB Client.  You can rewrite the previous example to use it like the following.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus中包含一个响应式MongoDB客户端。使用它就像使用经典的MongoDB客户端一样简单。你可以重写前面的例子来使用它，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>弃用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.mongodb.ReactiveMongoClient` client is deprecated and will be removed in the future.  It is recommended to switch to the `io.quarkus.mongodb.reactive.ReactiveMongoClient` client providing the `Mutiny` API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.mongodb.ReactiveMongoClient` 客户端已被废弃，并将在未来被删除。建议切换到提供 `Mutiny` API的 `io.quarkus.mongodb.reactive.ReactiveMongoClient` 客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MongoDB reactive client uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB的响应式客户端使用Mutiny响应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplifying MongoDB Client usage using BSON codec</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用BSON编解码器简化MongoDB客户端的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using a Bson `Codec`, the MongoDB Client will take care of the transformation of your domain object to/from a MongoDB `Document` automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过使用Bson `Codec` ，MongoDB 客户端将自动处理您的域对象与 MongoDB `Document` 的相互转化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you need to create a Bson `Codec` that will tell Bson how to transform your entity to/from a MongoDB `Document`.  Here we use a `CollectibleCodec` as our object is retrievable from the database (it has a MongoDB identifier), if not we would have used a `Codec` instead.  More information in the codec documentation: https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先你需要创建一个Bson `Codec` ，它将告诉Bson如何将你的实体与MongoDB `Document` 的相互转化。这里我们使用一个 `CollectibleCodec` ，因为我们的对象可以从数据库中检索到（它有一个MongoDB标识符），如果不是这样，我们会使用一个 `Codec` 。更多信息见编解码器文档 https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need to create a `CodecProvider` to link this `Codec` to the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后你需要创建一个 `CodecProvider` 来把这个 `Codec` 链接到 `Fruit` 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, when getting the `MongoCollection` from the database you can use directly the `Fruit` class instead of the `Document` one, the codec will automatically map the `Document` to/from your `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，当从数据库中获取 `MongoCollection` 时，你可以直接使用 `Fruit` 类，而不是 `Document` ，编解码器会自动将 `Document` 与 `Fruit` 类相互映射（从 `Fruit` 类映射 `Document` 或者将 `Document` 映射到 `Fruit` 类）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of using a `MongoCollection` with the `FruitCodec`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个将 `MongoCollection` 与 `FruitCodec` 一起使用的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO Codec] provides a set of annotations that enable the customization of the way a POJO is mapped to a MongoDB collection and this codec is initialized automatically by Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO编解码器] 提供了一组注解，可以自定义POJO映射到MongoDB集合的方式，该编解码器由Quarkus自动初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of these annotations is the `@BsonDiscriminator` annotation that allows to storage multiple Java types in a single MongoDB collection by adding a discriminator field inside the document. It can be useful when working with abstract types or interfaces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其中一个注解是 `@BsonDiscriminator` ，它允许通过在文档中添加一个判别字段来在单个MongoDB集合中存储多个Java类型。在处理抽象类型或接口时，它可能很有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus will automatically register all the classes annotated with `@BsonDiscriminator` with the POJO codec.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 将使用 POJO codec自动注册所有使用 `@BsonDiscriminator` 的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplifying MongoDB with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Panache简化MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connection Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接健康检查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-mongodb-client` will automatically add a readiness health check to validate the connection to the cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-smallrye-health` 扩展， `quarkus-mongodb-client` 将自动添加就绪状态检查，以验证与集群的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，当你访问应用程序的 `/q/health/ready` 端点时，可获得有关于连接验证状态的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.mongodb.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以通过在 `application.properties` 中将 `quarkus.mongodb.health.enabled` 属性设置为 `false` 来禁用此行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-micrometer` or `quarkus-smallrye-metrics` extension, `quarkus-mongodb-client` can provide metrics about the connection pools.  This behavior must first be enabled by setting the `quarkus.mongodb.metrics.enabled` property to `true` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-micrometer` 或 `quarkus-smallrye-metrics` 扩展， `quarkus-mongodb-client` 可以提供关于连接池的指标。这种行为必须首先通过在你的 `application.properties` 中设置 `quarkus.mongodb.metrics.enabled` 属性为 `true` 来启用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>跟踪</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing helpers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试助手</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start a MongoDB database for your unit tests, Quarkus provides two `QuarkusTestResourceLifecycleManager` that relies on link:https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[Flapdoodle embedded MongoDB].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了给你的单元测试启动MongoDB数据库，Quarkus提供了两个 `QuarkusTestResourceLifecycleManager` 依赖于 link:https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[Flapdoodle嵌入式MongoDB] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.mongodb.MongoTestResource` will start a single instance on port 27017.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.mongodb.MongoTestResource` 将在27017端口启动一个单一的实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.mongodb.MongoReplicaSetTestResource` will start a replicaset with two instances, one on port 27017 and the other on port 27018.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.mongodb.MongoReplicaSetTestResource` 将启动一个有两个实例的复制集，一个在27017端口，另一个在27018端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use them, you need to add the `io.quarkus:quarkus-test-mongodb` dependency to your pom.xml.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用它们，你需要在你的pom.xml中添加 `io.quarkus:quarkus-test-mongodb` 依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The legacy client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>旧客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don't include the legacy MongoDB client by default. It contains the now retired MongoDB Java API (DB, DBCollection,... )  and the `com.mongodb.MongoClient` that is now superseded by `com.mongodb.client.MongoClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们默认不包括旧版的MongoDB客户端。它包含现已废弃的MongoDB Java API（DB、DBCollection......）以及现已被 `com.mongodb.client.MongoClient` 所取代的 `com.mongodb.MongoClient` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个本地可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the MongoDB client in a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在一个本地可执行文件中使用MongoDB客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use SSL/TLS encryption, you need to add these properties in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用SSL/TLS加密，你需要在你的 `application.properties` 中添加这些属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/mongodb-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行它就像执行 `./target/mongodb-quickstart-1.0.0-SNAPSHOT-runner` 一样简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then point your browser to `http://localhost:8080/fruits.html` and use your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后你可以使用的浏览器访问 `&lt;a href="http://localhost:8080/fruits.html" class="bare"&gt;http://localhost:8080/fruits.html&lt;/a&gt;` 来使用你的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you encounter the following error when running your application in native mode: + `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can't find a codec for class org.acme.MyVariable.` + This means that the `org.acme.MyVariable` class is not known to GraalVM, the remedy is to add the `@RegisterForReflection` annotation to your `MyVariable class`.  More details about the `@RegisterForReflection` annotation can be found on the xref:writing-native-applications-tips.adoc#registerForReflection[native application tips] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在本地模式下运行你的应用程序时遇到以下错误。+ `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can’t find a codec for class org.acme.MyVariable.` + 这意味着GeralVM不知道 `org.acme.MyVariable` 类，补救措施是将 `@RegisterForReflection` 注解添加到你的 `MyVariable class` 。关于 `@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips.html#registerForReflection[本地应用程序提示] 页面找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling the application to a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将应用程序编译为原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the native executable in a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将原生可执行文件打包到一个容器中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>调试原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南以 link:getting-started[入门指南]中开发的应用程序作为输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.  There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.  The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建一个原生可执行文件需要使用GraalVM的发行版。有三个发行版：Oracle GraalVM社区版（CE）、Oracle GraalVM企业版（EE）和Mandrel。Oracle和Mandrel发行版之间的区别如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.  Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel是Oracle GraalVM CE的一个下游发行版。Mandrel的主要目标是提供一种方法来构建专门为支持Quarkus而设计的原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base, with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.  They support the same capabilities to build native executables as Oracle GraalVM CE, with no significant changes to functionality.  Notably, they do not include support for polyglot programming.  The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.  These exclusions also mean Mandrel offers a considerable reduction in its distribution size when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel版本的代码库来自于上游的Oracle GraalVM CE代码库，只做了一些小的改动，但也有一些重要的对于Quarkus本地应用程序来说是没有必要的排除项。它们支持与Oracle GraalVM CE相同的构建原生可执行文件的能力，在功能上没有重大变化。值得注意的是，它们不包括对多语言编程的支持。之所以排除这些功能，是为了给大多数Quarkus用户提供更好的支持水平。与Oracle GraalVM CE/EE相比，这些不包括的内容也意味着Mandrel发布的软件包大小大大减小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel的构建方式与Oracle GraalVM CE略有不同，它使用的是标准的OpenJDK项目。这意味着它不能从Oracle对用于构建他们自己的GraalVM下载的OpenJDK版本添加的一些小的增强功能中获益。这些增强功能被省略了，因为上游的OpenJDK并不管理它们，也无法担保。在涉及到一致性和安全性时，这一点尤其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel目前只推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着Mandrel用户应该使用容器来构建他们的原生可执行文件。如果你正在为macOS或Windows目标平台构建原生可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前并不针对这些平台。直接在裸金属Linux上构建原生可执行文件是可能的，详细信息请参见 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel releases]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The prerequisites vary slightly depending on whether you are using Oracle GraalVM CE/EE or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前提条件依据您使用的是Oracle GraalVM CE/EE还是Mandrel略有不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Java 11 version of GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装Java 11版本的GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Oracle GraalVM is available for both Java 8 and Java 11 (Mandrel only supports Java 11), Quarkus only works with the Java 11 version.  If you use the Oracle distribution, make sure to install the Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Oracle GraalVM在Java 8和Java 11上都可以使用(Mandrel只支持Java 11)，而Quarkus只支持Java 11版本。如果您使用Oracle发行版，请确保安装Java 11版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide using Mandrel, you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用Mandrel完成本指南，你需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker, podman)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个工作的容器运行时（Docker 或 podman）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序开发的代码在 link:getting-started[入门指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skip to &lt;&lt;#container-runtime,this section&gt;&gt; to continue with the guide for Mandrel, and follow the Mandrel-specific instructions in that section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>跳转到 &lt;&lt;#container-runtime,this section&gt;&gt; 继续指导Mandrel，并遵循该节中特定于Mandrel的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM version {graalvm-version} (be sure to install the Java 11 support) installed and xref:configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM的版本 {graalvm-version} （确保安装了Java 11支持）已安装并且 xref:configuring-graalvm[配置适当]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native compilation in C</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持C语言的原生编译</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does having a working C developer environment mean?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拥有一个C语言工作开发者环境意味着什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Linux上，你将需要GCC，以及glibc和zlib头文件。常见发行版的例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XCode provides the required dependencies on macOS:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>XCode在macOS上提供了必要的依赖性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上，你将需要安装 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++构建工具]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. There is an explanation of how to do this at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你无法安装GraalVM，你可以使用多阶段Docker构建在嵌入GraalVM的Docker容器内运行Maven。本指南最后有关于如何操作的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version {graalvm-version} is required. Using the community edition is enough.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>版本 {graalvm-version} 是必需的。使用社区版就可以了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM (pick the java 11 version) if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果还没有安装GraalVM（选择java 11版本），您有几个选择：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用平台特定的安装工具，如 https://github.com/graalvm/homebrew-tap[homebrew]，https://sdkman.io/jdks#Oracle[sdkman]，或 https://github.com/ScoopInstaller/Java[scoop]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate Community Edition archive from &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.  Make sure to download and install at Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;下载适当的社区版归档文件，然后像解包其他JDK一样解包。确保Java 11版本已经下载并安装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置运行环境。例如将 `GRAALVM_HOME` 环境变量设置为GraalVM的安装目录，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS, point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在macOS中，将变量指向 `Home` 子目录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will have to go through the Control Panel to set your environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上，您将不得不通过控制面板来设置你的环境变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing via scoop will do this for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过scoop安装将为你做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `gu install` 安装 `native-image` 工具：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some previous releases of GraalVM included the `native-image` tool by default.  This is no longer the case; it must be installed as a second step after GraalVM itself is installed. Note: there is an outstanding issue xref:graal-and-catalina[using GraalVM with macOS Catalina].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM以前的一些版本默认包括 `native-image` 工具。现在已经不是这样了，它必须在安装完GraalVM本身后作为第二步来安装。注意：一个已知的问题 xref:graal-and-catalina[在MacOS Catalina上使用GraalVM]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(可选）将 `JAVA_HOME` 环境变量设置为GraalVM的安装目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Add the GraalVM `bin` directory to the path</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(可选）将GraalVM `bin` 目录添加到路径中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues using GraalVM with macOS Catalina</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在MacOS Catalina上使用GraalVM的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM binaries are not (yet) notarized for macOS Catalina as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `gu`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM的二进制文件（尚未）对macOS Catalina进行认证，正如这个 https://github.com/oracle/graal/issues/1724[GralVM问题]中所报告的那样。这意味着您在使用 `gu` 时可能会看到以下错误：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令递归删除GraalVM安装目录上的 `com.apple.quarantine` 扩展属性，作为一种解决方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地打包应用。不过您还可以直接进入完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `getting-started` 目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制作一个原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们应用程序的原生可执行文件将包含应用程序代码、所需的库、Java API和一个缩小版的虚拟机。较小的虚拟机基础提高了应用程序的启动时间和最小的磁盘占用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:native-executable-process.png[Creating a native executable]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:native-executable-process.png[创建原生可执行文件]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经从前面的教程中生成了应用程序，你可以在 `pom.xml` ，找到以下 _profile_：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.  Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `&lt;quarkus.native.additional-build-args&gt;` 属性为 `native-image` 命令提供自定义选项。多个选项可以用逗号隔开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一种做法是在你的 `application.properties` ，填写 `quarkus.native.additional-build-args` 配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about how to configure the native image building process in the &lt;&lt;configuration-reference&gt;&gt; section below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在下面的 &lt;&lt;configuration-reference&gt;&gt; 部分找到关于如何配置原生镜像构建过程的更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as this allows native image tests to also be run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用profile是因为，你很快就会看到，打包原生可执行文件需要 _few_ 分钟。你可以在命令行中把 -Dquarkus.package.type=native 作为一个属性，但是最好是使用一个profile，因为这可以使原生镜像测试也被运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用： `./mvnw package -Pnative` 创建一个原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues with packaging on Windows</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Windows上打包的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At `x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在打包之前，必须首先初始化 Microsoft Native Tools for Visual Studio。你可以通过启动与Visual Studio Build Tools 一起安装的 `x64 Native Tools Command Prompt` 来做到这一点。在 `x64 Native Tools Command Prompt` ，你可以导航到你的项目文件夹并运行 `mvnw package -Pnative` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another solution is to write a script to do this for you:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一个解决方案是写一个脚本来为您做这件事：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.  You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了常规文件外，该构建还产生了 `target/getting-started-1.0.0-SNAPSHOT-runner` 。你可以用以下方式运行它： `./target/getting-started-1.0.0-SNAPSHOT-runner` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制作一个原生可执行文件可能会导致一些问题，因此，针对在原生文件中运行的应用程序运行一些测试也是一个好主意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file, the `native` profile contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `pom.xml` 文件中， `native` 配置文件包含：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这指示 failsafe-maven-plugin 运行集成测试，并指出生成的原生可执行文件的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，打开 `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java` 。它包含了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.  The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用另一个测试运行器，在测试前从原生文件启动应用程序。使用 _Failsafe Maven Plugin_ 中配置的 `native.image.path` 系统属性检索该可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We extend our previous tests, but you can also implement your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们扩展了之前的测试，但您也可以实现自己的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `NativeGreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要查看针对原生可执行文件运行 `NativeGreetingResourceIT` ，请用 `./mvnw verify -Pnative`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会等待60秒的时间来启动原生镜像，然后本地测试自动失败。这个持续时间可以使用 `quarkus.test.wait-time` 系统属性来改变。例如，要增加持续时间到300秒，使用： `./mvnw verify -Pnative -Dquarkus.test.wait-time=300` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the future, `@NativeImageTest` will be deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the link:getting-started-testing#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在未来， `@NativeImageTest` 将被弃用，取而代之的是`@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 link:getting-started-testing#quarkus-integration-test[测试指南]中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, native tests runs using the `prod` profile.  This can be overridden using the `quarkus.test.native-image-profile` property.  For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.  Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  However, don't forget that when the native executable is built the `prod` profile is enabled.  So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，原生测试使用 `prod` 配置文件运行。这可以用 `quarkus.test.native-image-profile` 属性来覆盖。例如，在你的 `application.properties` 文件中，添加： `quarkus.test.native-image-profile=test` 。或者，你可以用以下方式运行你的测试。 `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` 。然而，不要忘记当原生可执行文件被构建时， `prod` 配置文件被启用。因此，你通过这种方式启用的配置文件必须与生成的可执行文件兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excluding tests when running as a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为原生可执行文件运行时排除测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running tests this way, the only things that actually run natively are you application endpoints, which you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当以这种方式运行测试时，唯一真正在本地运行的是你的应用程序端点，你只能通过HTTP调用来测试。你的测试代码实际上并不在本地运行，所以如果你测试的代码不调用你的HTTP端点，把它们作为本地测试的一部分运行可能不是一个好主意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你像我们上面建议的那样，在JVM和原生执行之间共享你的测试类，你可以用 `@DisabledOnNativeImage` 注解标记某些测试，以便只在JVM上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing an existing native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试一个现有的原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以针对已经建立的原生可执行文件重新运行测试。要做到这一点，运行 `./mvnw test-compile failsafe:integration-test` 。这将发现现有的原生镜像，并使用故障安全系统对其运行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果进程由于某种原因找不到原生镜像，或者你想测试一个已经不在目标目录中的原生镜像，你可以用 `-Dnative.image.path=` 系统属性指定可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a Linux executable without GraalVM installed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在没有安装GraalVM的情况下创建一个Linux可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在进一步行动之前，请确保有一个工作的容器运行环境（Docker或podman）。如果你在Windows上使用Docker，你应该在Docker Desktop文件共享设置中共享你的项目的驱动器，并重新启动Docker Desktop。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice to install as little software as possible).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很多时候，人们只需要为他们的Quarkus应用程序创建一个原生Linux可执行文件（例如，为了在容器化环境中运行），并希望避免安装适当的GraalVM版本来完成这项麻烦任务（例如，在CI环境中，通常的做法是尽可能少地安装软件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.  The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为此，Quarkus提供了一个非常方便的方法，通过利用容器运行时（如Docker或podman）来创建一个原生Linux可执行文件。完成这项任务的最简单方法是执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus automatically detects the container runtime.  If you want to explicitely select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在默认情况下，Quarkus会自动检测容器的运行时。如果你想明确地选择容器的运行时，你可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are normal Quarkus config properties, so if you always want to build in a container it is recommended you add these to your `application.properties` in order to avoid specifying them every time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些是标准的Quarkus配置属性，所以如果你总是想在容器中构建，建议你把这些添加到你的 `application.properties` ，以避免每次都指定它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you see the following invalid path error for your application JAR when trying to create a native executable using a container build, even though your JAR was built successfully, you're most likely using a remote daemon for your container runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你在试图使用容器构建创建原生可执行文件时，尽管你的JAR已经成功构建，仍看到应用程序JAR出现以下无效路径错误，您很可能为容器运行时使用了一个远程守护进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, use the parameter `-Dquarkus.native.remote-container-build=true` instead of `-Dquarkus.native.container-build=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，使用参数 `-Dquarkus.native.remote-container-build=true` ，而不是 `-Dquarkus.native.container-build=true` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason for this is that the local build driver invoked through `-Dquarkus.native.container-build=true` uses volume mounts to make the JAR available in the build container, but volume mounts do not work with remote daemons. The remote container build driver copies the necessary files instead of mounting them. Note that even though the remote driver also works with local daemons, the local driver should be preferred in the local case because mounting is usually more performant than copying.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原因是通过 `-Dquarkus.native.container-build=true` 调用的本地构建驱动程序使用卷挂载来使 JAR 在构建容器中可用，但卷挂载对远程守护程序不起作用。远程容器构建驱动程序复制必要的文件，而不是挂载它们。请注意，即使远程驱动程序也能与本地守护进程一起工作，但在本地情况下，本地驱动程序应该是首选，因为挂载通常比复制性能更高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building with Mandrel requires a custom builder image parameter to be passed additionally:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Mandrel构建需要额外传递一个自定义的构建器镜像参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.  It is highly recommended to use the floating tag, so that your builder image remains up-to-date and secure.  If you absolutely must, you may hard-code to a specific tag (see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags), but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，上述命令指向的是一个浮动标签。我们强烈建议你使用浮动标签，这样你的构建器镜像就能保持最新和安全。如果你一定要硬编码到一个特定的标签（参见 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[这里] 的可用标签），但要注意，你不会得到安全更新，而且这不被支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个容器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the container-image extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用容器-镜像扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，从你的Quarkus应用程序中创建一个容器镜像的最简单方法是利用容器镜像扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果这些扩展之一是存在的，那么为原生可执行文件创建一个容器镜像基本上就是执行一个命令的问题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `quarkus.native.container-build=true` 允许在不安装GralVM的情况下创建一个Linux可执行文件（只有在你没有安装GralVM或者你的本地操作系统不是Linux的情况下才需要）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.container-image.build=true` 指示Quarkus使用最终的应用程序工件（在本例中是原生可执行文件）创建一个容器镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:container-image[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节见 link:container-image[容器镜像指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手工</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.  However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用Quarkus Maven插件生成的JAR在容器中运行该应用程序。然而，在本节中我们将重点讨论使用生成的原生可执行文件创建一个容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).  However, as a container may not use the same _executable_ format as the one produced by your operating system, we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in &lt;&lt;#container-runtime,this section&gt;&gt;):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用本地GraalVM安装时，原生可执行文件的目标是您的本地操作系统（Linux、macOS、Windows等）。然而，由于容器可能不使用与操作系统相同的 _executable_ 格式，我们将指示Maven构建通过利用容器运行时（ 如 &lt;&lt;#container-runtime,this section&gt;&gt; 所述）来生成可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>产生的可执行文件将是一个64位的Linux可执行文件，所以取决于您的操作系统，它可能不再能够运行。然而，这不是一个问题，因为我们要把它复制到一个容器中。生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided `Dockerfiles` use https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI] (Universal Base Image) as parent image.  This base image has been tailored to work perfectly in containers.  The `Dockerfiles` use the https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version] of the base image to reduce the size of the produced image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供的 `Dockerfiles` 使用 https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI]（通用基础镜像）作为父镜像。这个基础镜像经过量身定做，可以在容器中完美工作。 `Dockerfiles` 使用基础镜像的 https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version]来减小生成镜像的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI on:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以在以下网站阅读更多关于UBI的信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[the _UBI-minimal_ image page]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[ _UBI-minimal_ image 页面]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/containers/?tab=tags#/registry.access.redhat.com/ubi8/ubi-minimal[the list of _UBI-minimal_ tags]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/containers/?tab=tags#/registry.access.redhat.com/ubi8/ubi-minimal[ _UBI-minimal_ 标签列表]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, if you didn't delete the generated native executable, you can build the docker image with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，如果你没有删除生成的原生可执行文件，可以用以下方法构建docker镜像：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，用以下方式运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a multi-stage Docker build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用多阶段的Docker构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven or Gradle, but it requires you to have created the native executable first.  In addition, this native executable must be a Linux 64 bits executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上一节向你展示了如何使用Maven或Gradle构建原生可执行文件，但这需要你先创建原生可执行文件。此外，这个原生可执行文件必须是Linux 64位可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may want to build the native executable directly in a container without having a final container containing the build tools.  That approach is possible with a multi-stage Docker build:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能想直接在一个容器中构建原生可执行文件，而不需要一个包含构建工具的最终容器。这种方法可以通过多阶段的Docker构建来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first stage builds the native executable using Maven or Gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一阶段使用Maven或Gradle构建原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second stage is a minimal image copying the produced native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第二阶段是复制产生了原生可执行文件的最小镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a multi-stage build can be achieved as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样的多阶段构建可以通过以下方式实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Maven:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Maven构建的Docker文件例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This multi-stage Docker build copies the Maven wrapper from the host machine.  The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.  It avoids having to create a base image with Maven and Gradle.  To provision the Maven Wrapper in your project, use: `mvn -N io.takari:maven:0.7.7:wrapper`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种多阶段Docker构建从主机上复制Maven包装器。Maven包装器（或Gradle包装器）是提供特定版本Maven/Gradle的一种便捷方式。它避免了用Maven和Gradle创建一个基础镜像。要在项目中配置Maven包装器，请使用： `mvn -N io.takari:maven:0.7.7:wrapper`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将此文件保存在 `src/main/docker/Dockerfile.multistage` ，因为它不包括在开始快速入门中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Gradle:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Gradle构建的Docker文件例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在项目中使用Gradle，你可以使用这个Docker文件例子。将其保存在 `src/main/docker/Dockerfile.multistage` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory. As we plan to build inside a container, we need to copy the `src` directory. Thus, edit your `.dockerignore` and update the content.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在启动我们的Docker构建之前，我们需要更新默认的 `.dockerignore` 文件，因为它过滤了除 `target` 目录之外的所有内容。由于我们计划在容器内构建，我们需要复制 `src` 目录。因此，编辑你的 `.dockerignore` ，并更新内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And, finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，用以下方式运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的原生可执行文件需要SSL支持，你可以轻松地在Docker镜像中包含必要的库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:native-and-ssl#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息请参见 link:native-and-ssl#working-with-containers[我们的使用SSL与原生可执行文件指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Mandrel instead of GraalVM CE, update the `FROM` clause to: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build`.  `$TAG` can be found on the https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel Images Tags page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用Mandrel而不是GraalVM CE，请将 `FROM` 子句更新为: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build` 。 `$TAG` 可以在 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel镜像标签页]上找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a distroless base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用无发行版基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are looking for small container images, the https://github.com/GoogleContainerTools/distroless[distroless] approach reduces the size of the base layer.  The idea behind _distroless_ is the usage of a single and minimal base image containing all the requirements, and sometimes even the application itself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在寻找小型的容器镜像，https://github.com/GoogleContainerTools/distroless[无发行] 的方法可以减少基础层的大小。 _distroless_ 背后的想法是使用一个单一和最小的基础镜像包含所有的需求，有时甚至是应用程序本身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a distroless base image that you can use in your `Dockerfile`.  You only need to copy your application, and you are done:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个无发行版的基础镜像，可以用于你的 `Dockerfile` 。你只需要复制你的应用程序，就可以了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides the `quay.io/quarkus/quarkus-distroless-image:1.0` image.  It contains the required packages to run a native executable and is only **9Mb**.  Just add your application on top of this image, and you will get a tiny container image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了 `quay.io/quarkus/quarkus-distroless-image:1.0` 镜像。它包含了运行原生可执行文件所需的软件包，并且只有 *9Mb* 。只要在这个镜像上添加你的应用程序，你就会得到一个很小的容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In certain circumstances, you may want to build the native image in a separate step.  For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.  For this use case, you can set the `quarkus.package.type=native-sources`.  This will execute the java compilation as if you would have started native compilation (`-Pnative`), but stops before triggering the actual call to GraalVM's `native-image`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，你可能想在一个单独的步骤中构建本地镜像。例如，在CI/CD管道中，你可能希望有一个步骤来生成用于原生镜像的源，另一个步骤是使用这些源来实际构建原生可执行文件。对于这种用例，你可以设置 `quarkus.package.type=native-sources` 。这将执行java编译，就像你已经开始原生编译一样（ `-Pnative` ），但在触发对GraalVM的 `native-image` 的实际调用之前停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After compilation has finished, you find the build artifact in `target/native-sources`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译完成后，你可以在 `target/native-sources` 找到构建工件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the output above one can see that, in addition to the produced jar file and the associated lib directory, a text file named `native-image.args` was created.  This file holds all parameters (including the name of the JAR to compile) to pass along to GraalVM's `native-image` command.  If you have GraalVM installed, you can start the native compilation by executing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从上面的输出可以看出，除了生成的jar文件和相关的lib目录外，还创建了一个名为 `native-image.args` 的文本文件。这个文件包含了所有的参数（包括要编译的JAR的名字），以及传递给GraalVM的 `native-image` 命令。如果你已经安装了GraalVM，你可以通过执行以下命令开始本地编译：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The process for Gradle is analogous.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle的过程是类似的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the build process in a container is also possible:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个容器中运行构建过程也是可能的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mount the host's directory `target/native-image` to the container's `/work`. Thus, the generated binary will also be written to this directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将主机的目录 `target/native-image` 挂载到容器的 `/work` 。因此，生成的二进制文件也将被写入这个目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the working directory to `/work`, which we have mounted in &lt;1&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将工作目录切换到 `/work` ，我们已经在&lt;1&gt;中挂载了这个目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` docker image introduced in &lt;&lt;#multistage-docker,Using a multi-stage Docker build&gt;&gt; to build the native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 &lt;&lt;#multistage-docker,Using a multi-stage Docker build&gt;&gt; 中介绍的 `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` docker镜像来构建原生镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Call `native-image` with the content of file `native-image.args` as arguments. We also supply an additional argument to limit the process's maximum memory to 4 Gigabytes (this may vary depending on the project being built and the machine building it).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以文件 `native-image.args` 的内容为参数调用 `native-image` 。我们还提供了一个额外的参数，将进程的最大内存限制在4G字节（这可能取决于正在构建的项目和构建它的机器）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are running on a Windows machine, please keep in mind that the binary was created within a Linux docker container.  Hence, the binary will not be executable on the host Windows machine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你是在Windows机器上运行，请记住，二进制文件是在Linux docker容器中创建的。因此，二进制文件在Windows主机上是无法执行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A high level overview of what the various steps of a CI/CD pipeline would look is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下是对CI/CD管道的各个步骤的高度概述：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register the output of the step executing `./mvnw ...` command (i.e. directory `target/native-image`) as a build artifact,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将执行 `./mvnw …​` 命令的步骤的输出（即目录 `target/native-image` ）注册为构建工件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Require this artifact in the step executing the `native-image ...` command, and</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在执行 `native-image …​` 命令的步骤中需要这个工件，并且</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register the output of the step executing the `native-image ...` command (i.e. files matching `target/*runner`) as build artifact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将执行 `native-image …​` 命令的步骤的输出（即匹配 `target/*runner` 的文件）注册为构建工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The environment executing step `1` only needs Java and Maven (or Gradle) installed, while the environment executing step `3` only needs a GraalVM installation (including the `native-image` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>执行步骤 `1` 的环境只需要安装Java和Maven（或Gradle），而执行步骤 `3` 的环境只需要安装GralVM（包括 `native-image` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on what the final desired output of the CI/CD pipeline is, the generated binary might then be used to create a container image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>根据CI/CD管道的最终期望输出，生成的二进制文件可能被用来创建一个容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Oracle GraalVM 20.2或Mandrel 20.1开始，可以为Linux环境生成本地可执行文件的调试符号（Windows支持仍在开发中）。这些符号可用于用工具调试本地可执行文件，如 `gdb` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols, add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.  You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要生成调试符号，在生成原生可执行文件时添加 `-Dquarkus.native.debug.enabled=true` 标志。你将在原生可执行文件旁边的 `.debug` 文件中找到原生可执行文件的调试符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions and macOS you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.debug` 文件的生成取决于 `objcopy` 。在常见的Linux发行版和macOS上，你将需要安装 `binutils` 包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `objcopy` is not available debug symbols are embedded in the executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当被嵌入到可执行文件中的 `objcopy` 调试符号不可用时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols, setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.  This source cache is useful for native debugging tools, to establish the link between the symbols and matching source code.  It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了调试符号外，设置 `-Dquarkus.native.debug.enabled=true` 标志会生成一个源文件缓存，用于生成原生可执行文件时解决的任何JDK运行时类、GraalVM类和应用程序类。这个源码缓存对原生调试工具很有用，可以在符号和匹配的源代码之间建立联系。在调试本原生执行文件时，它提供了一种方便的方法，使调试器/IDE仅能获得必要的源文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code, are not added to the source cache by default.  To include those, make sure you invoke `mvn dependency:sources` first.  This step is required in order to pull the sources for these dependencies, and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第三方jar依赖的源，包括Quarkus源代码，默认情况下不会被添加到源缓存中。要包括这些，请确保你先调用 `mvn dependency:sources` 。这一步是必须的，以便拉出这些依赖的源代码，并将其包含在源代码缓存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source cache is located in the `target/sources` folder.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>源缓存位于 `target/sources` 文件夹中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If running `gdb` from a different directory than `target`, then the sources can be loaded by running:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果从与 `target` 不同的目录下运行 `gdb` ，那么可以通过运行源代码加载：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the `gdb` prompt.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `gdb` 提示中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or start `gdb` with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或这样运行 `gdb` 命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置原生可执行文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有很多不同的配置选项可以影响原生可执行文件的生成方式。这些都是在 `application.properties` ，与其他配置属性相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties are shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些属性显示如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下一步做什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.  It provides an application exhibiting a swift startup time and consuming less memory.  However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何为应用程序创建原生(二进制)可执行文件。它提供了一个具备快速启动时间和消耗更少内存的应用程序。然而，还有更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the link:deploying-to-kubernetes[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议继续阅读 link:deploying-to-kubernetes[部署到Kubernetes和OpenShift]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports a feature called Dev Services that allows you to create various datasources without any config.  What that means practically, is that if you have docker running and have not configured `quarkus.redis.hosts`, Quarkus will automatically start a Redis container when running tests or dev-mode, and automatically configure the connection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持一项叫做Dev Services的功能，籍此，无需进行任何配置即可创建各种数据源。这意味着，如果你运行着docker服务，但没有配置 `quarkus.redis.hosts` ，Quarkus会在运行测试或dev模式时自动启动一个Redis容器，并自动配置连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Available properties to customize the Redis DevService.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis DevService的可用配置属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running the production version of the application, the Redis connection need to be configured as normal, so if you want to include a production database config in your `application.properties` and continue to use Dev Services we recommend that you use the `%prod.` profile to define your Redis settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行应用程序的生产版本需要正常配置Redis连接，所以如果你想在 `application.properties` 中定义生产的数据库配置，同时继续使用Dev Services，我们建议你使用 `%prod.` profile来定义你的Redis设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Redis relies on Docker to start the server.  If your environment does not support Docker, you will need to start the server manually, or connect to an already running server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis的Dev Services依赖Docker来启动服务器。如果你的环境不支持Docker，则需要手动启动服务，或者连接到一个运行中的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shared server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>服务共享</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the server between applications.  Dev Services for Redis implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>很多时候你需要在多个应用之间共享Dev Services。Redis的Dev Services实现了 _服务发现_ 机制，允许多个以 _dev_ 模式运行的Quarkus应用共享同一个Dev Services。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Redis starts the container with the `quarkus-dev-service-redis` label which is used to identify the container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis的Dev Services启动容器时使用 `quarkus-dev-service-redis` 标签，该标签用于识别容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) servers, you can configure the `quarkus.redis.devservices.service-name` attribute and indicate the server name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `redis`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果需要多个（共享的）Dev Services，可以用 `quarkus.redis.devservices.service-name` 属性指定服务名称。Quarkus将尝试查找具有相同服务名称的容器，如果找不到，则启动一个新容器。默认的服务名称是 `redis` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.redis.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在dev模式下默认启用服务共享，而在测试模式下默认禁用。也可以使用 `quarkus.redis.devservices.shared=false` 配置禁用服务共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本参考指南展示了如何在您的Quarkus应用程序中利用SmallRye Reactive Messaging与Apache Kafka进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kafka.apache.org[Apache Kafka] is a popular open-source distributed event streaming platform.  It is used commonly for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.  Similar to a message queue, or an enterprise messaging platform, it lets you:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://kafka.apache.org[Apache Kafka] 是一个流行的开源分布式事件流平台。它通常用于高性能数据管道、流式分析、数据集成以及任务关键型应用。类似于消息队列或企业消息平台，它可以允许您：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*publish* (write) and *subscribe* to (read) streams of events, called _records_.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*发布* (写)以及 *订阅* (读)事件流，称为 _记录_ 。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*store* streams of records durably and reliably inside _topics_.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _topic_ 内持久而可靠地 *存储* 流式记录。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*process* streams of records as they occur or retrospectively.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对流式记录进行起始或回溯*处理*。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And all this functionality is provided in a distributed, highly scalable, elastic, fault-tolerant, and secure manner.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而所有这些功能都是以分布式、高可扩展性、弹性、容错以及安全的方式提供的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for Apache Kafka through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.  Based on Eclipse MicroProfile Reactive Messaging specification 2.0, it proposes a flexible programming model bridging CDI and event-driven.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过 link:https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] 框架为Apache Kafka提供支持。基于Eclipse MicroProfile Reactive Messaging 2.0 规范，框架提供了一种灵活的基于CDI和事件驱动的编程模型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide provides an in-depth look on Apache Kafka and SmallRye Reactive Messaging framework.  For a quick start take a look at xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南深入介绍了Apache Kafka和SmallRye Reactive Messaging框架。要想快速入门，请参考 xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add the `smallrye-reactive-messaging-kafka` extensions to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过在您的项目根目录下运行以下命令来将 `smallrye-reactive-messaging-kafka` 扩展添加到您的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Smallrye Kafka Connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Smallrye Kafka Connector</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Smallrye Reactive Messaging framework supports different messaging backends like Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为Smallrye Reactive Messaging框架支持不同的消息后端，如Apache Kafka，AMQP，Apache Camel，JMS以及MQTT等，所以它使用了一个通用的术语表：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications send and receive *messages*. A message wraps a _payload_ and can be extended with some _metadata_. With the Kafka connector, a _message_ corresponds to a Kafka _record_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序发送和接收 *messages* 。一条消息包含一个 _payload_ ，并可以用一些 _metadata_ 进行扩展。通过Kafka connector，一条 _message_ 对应于一条Kafka _record_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Kafka connector maps _channels_ to Kafka _topics_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>信息在 *channels* 上传输。应用程序组件通过连接 channels 来发布和消费消息。Kafka connector将 _channels_ 映射到Kafka的 _topics_上 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Channels are connected to message backends using *connectors*. Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. Each connector is dedicated to a specific messaging technology. For example, the connector dealing with Kafka is named `smallrye-kafka`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Channels 通过 *connectors* 连接到消息后端。Connectors通过配置将传入的消息映射到一个指定channel上(该channel由应用程序来消费)，并对发送到指定channel的消息进行收集。每个connector都专用于某种特定的消息传递技术。例如，与Kafka交互的的connector被命名为 `smallrye-kafka` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A minimal configuration for the Kafka connector with an incoming channel looks like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个配有消息接收channel的Kafka connector的最小配置如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the connector to manage the prices channel. By default the topic name is same as the channel name. You can configure the topic attribute to override it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置connector来管理prices channel。默认情况下，topic名称与channel名称相同。您可以通过配置topic属性来覆盖它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%prod` 前缀表示该属性只在应用程序运行在生产模式下时生效(而不是在开发或测试模式)。更多细节请参考 xref:config-reference.adoc#profiles[Profile documentation]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receiving messages from Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收来自Kafka的消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuing from the previous minimal configuration, your Quarkus application can receive message payload directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们继续刚才的最小配置。您的Quarkus应用程序可以直接接收消息payload：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several other ways your application can consume incoming messages:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您的应用程序还可以通过另外集中方式来消费接收到的消息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually.  We'll explore different acknowledgment strategies in &lt;&lt;commit-strategies&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Message` 类型允许consuming methond访问接收到消息的metadata并手动进行确认。我们将在 &lt;&lt;commit-strategies&gt;&gt;中探讨不同的确认策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to access the Kafka record objects directly, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想直接访问Kafka record对象，请使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ConsumerRecord` is provided by the underlying Kafka client and can be injected directly to the consumer method.  Another simpler approach consists in using `Record`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ConsumerRecord` 由底层Kafka client提供，并且可以直接注入到consumer method中。另一种更简单的方法是使用  `Record`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Record` is a simple wrapper around key and payload of the incoming Kafka record.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Record` 提供了对接收到的Kafka record中key和payload的简单的包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, your application can inject a `Multi` in your bean and subscribe to its events as the following example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，您的应用程序可以在您的Bean中注入一个 `Multi` ，然后像下面的例子那样订阅它的事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a good example of how to integrate a Kafka consumer with another downstream, in this example exposing it as a Server-Sent Events endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个例子很好的展示了如何将Kafka consumer与另一个downstream进行集成。在这个例子中，我们将这个downstream暴露为一个服务端事件节点(Server-Sent Events endpoint)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following types can be injected as channels:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下类型可以作为 channels 被注入：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the previous `Message` example, if your injected channel receives payloads (`Multi&lt;T&gt;`), it acknowledges the message automatically, and support multiple subscribers.  If you injected channel receives Message (`Multi&lt;Message&lt;T&gt;&gt;`), you will be responsible for the acknowledgment and broadcasting.  We will explore sending broadcast messages in &lt;&lt;broadcasting-messages-on-multiple-consumers&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如前面 `Message` 例子所示，如果您的注入channel接收到了playloads( `Multi&lt;T&gt;` )，它可以支持多订阅者自动确认消息。如果您的注入channel收到Message( `Multi&lt;Message&lt;T&gt;&gt;` )，那么您需要自行负责消息确认和广播。我们将在&lt;&lt;broadcasting-messages-on-multiple-consumers&gt;&gt; 中探讨消息的发送和广播。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting `@Channel("prices")` or having `@Incoming("prices")` does not automatically configure the application to consume messages from Kafka.  You need to configure an inbound connector with `mp.messaging.incoming.prices\...` or have an `@Outgoing("prices")` method somewhere in your application (in which case, `prices` will be an in-memory channel).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入 `@Channel("prices")` 或使用 `@Incoming("prices")` 无法通过配置使应用程序自动从Kafka消费消息。您需要用 `mp.messaging.incoming.prices...` 配置一个接收connector，或者在您的应用程序中使用 `@Outgoing("prices")` 方法(在这种情况下， `prices` 将是一个内存型channel)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blocking processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>阻塞处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging invokes your method on an I/O thread.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.  But, you often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Messaging会在一个I/O线程中调用您的方法。关于这个话题的更多细节，请看  xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation]  。但是您可能需要经常将Reactive Messaging 与阻塞式处理相结合使用，比如与数据库通信。为此，您需要使用 `@Blocking` 注解来表该明处理是 _阻塞的_ ，并且不在调用者线程中运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，下面的代码演示了如何使用Hibernate与Panache将接收到的payload存储到数据库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完整的例子可以参考 `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 `@Blocking` annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有2种 `@Blocking` 注解：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They have the same effect.  Thus, you can use both.  The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.  The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它们效果相同。因此，您可以随意使用。第一个提供了更精细的配置，比如worker pool以及是否保留顺序。第二种，同其他的Quarkus Reactive功能类似，使用默认的worker pool并且保留了顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Acknowledgment Strategies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确认策略(Acknowledgment Strategies)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All messages received by a consumer must be acknowledged.  In the absence of acknowledgment, the processing is considered in error.  If the consumer method receives a `Record` or a payload, the message will be acked on method return, also known as `Strategy.POST_PROCESSING`.  If the consumer method returns another reactive stream or `CompletionStage`, the message will be acked when the downstream message is acked.  You can override the default behavior to ack the message on arrival (`Strategy.PRE_PROCESSING`), or do not ack the message at all (`Strategy.NONE`) on the consumer method as in the following example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者收到的所有消息都必须被确认(acknowleged)。在没有确认的情况下，消息处理会出错。如果消费者方法收到一个 `Record` 或一个payload，该消息将通过方法返回被确认，也被称为 `Strategy.POST_PROCESSING` 。如果消费者方法返回另一个reactive stream或 `CompletionStage` ，那么当下游消息(downstream message)被确认时，该消息也将被确认。您可以覆盖默认行为从而在消息到达时进行确认( `Strategy.PRE_PROCESSING` )，或者在消费者方法中不进行任何确认( `Strategy.NONE` )，如下例所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the consumer method receives a `Message`, the acknowledgment strategy is `Strategy.MANUAL` and the consumer method is in charge of ack/nack the message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果消费者方法接收到一个 `Message` ，那么确认策略是 `Strategy.MANUAL` 并且消费者方法将负责对消息进行ack/nack。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the method can also override the acknowledgment strategy to `PRE_PROCESSING` or `NONE`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，该方法还可以将确认策略设置为 `PRE_PROCESSING` 或 `NONE` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Commit Strategies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提交策略(Commit Strategies)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a message produced from a Kafka record is acknowledged, the connector invokes a commit strategy.  These strategies decide when the consumer offset for a specific topic/partition is committed.  Committing an offset indicates that all previous records have been processed.  It is also the position where the application would restart the processing after a crash recovery or a restart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当一条由Kafka记录产生的消息被确认时，connector将会调用一个提交策略。这些策略决定了特定topic/分区(topic/partition)的消费者偏移将在何时被提交。提交一个偏移量(offset)表明所有之前的记录已经被处理了。它也是应用程序从崩溃中恢复后或重启后重新开始处理的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Committing every offset has performance penalties as Kafka offset management can be slow.  However, not committing the offset often enough may lead to message duplication if the application crashes between two commits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于Kafka的偏移量管理可能很慢，所以每次提交偏移量都会有性能上的损失。然而，如果程序在两次提交之间崩溃，不够频繁的偏移量提交可能会导致消息出现重复提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector supports three strategies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka connector支持三种策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`latest` commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).  This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.  This strategy should not be used in high load environment, as offset commit is expensive. However, it reduces the risk of duplicates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`latest` 一旦关联消息被确认，Kafka消费者就会提交所接收到的record偏移量(前提是当前偏移量高于之前提交的偏移量)。如果channel在不执行任何异步处理的情况下处理消息的话，这种策略能保证至少一次提交。这种策略不推荐在高负载环境中使用，因为偏移量的提交很昂贵。但是它减少了消息重复提交的风险。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector disables the Kafka auto commit when it is not explicitly enabled. This behavior differs from the traditional Kafka consumer.  If high throughput is important for you, and you are not limited by the downstream, we recommend to either:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka connector没有明确启用时，它将禁用Kafka自动提交。这与传统的Kafka消费者不同。如果高吞吐量对您来说很重要而且您不受下游的限制，我们建议要么：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or set `enable.auto.commit` to true and annotate the consuming method with `@Acknowledgment(Acknowledgment.Strategy.NONE)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要么将 `enable.auto.commit` 设置为true，并在consuming方法中使用 `@Acknowledgment(Acknowledgment.Strategy.NONE)` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error Handling Strategies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>错误处理策略(Error Handling Strategies)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a message produced from a Kafka record is nacked, a failure strategy is applied. The Kafka connector supports three strategies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果从Kafka record中产生的消息未被确认，那么一个失败策略就会被启用。Kafka connector支持三种策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail`: fail the application, no more records will be processed (default strategy). The offset of the record that has not been processed correctly is not committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fail` ：直接使程序失败，不再处理更多的记录(默认策略)。未被正确处理的记录的偏移量不会被提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ignore`: the failure is logged, but the processing continue. The offset of the record that has not been processed correctly is committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ignore` ：记录失败的日志，但消息处理将继续进行。没有被正确处理的记录的偏移量会被提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`dead-letter-queue`: the offset of the record that has not been processed correctly is committed, but the record is written to a Kafka dead letter topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dead-letter-queue` ：未被正确处理的记录的偏移量会被提交，但该记录会被写入Kafka的dead letter topic。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The strategy is selected using the `failure-strategy` attribute.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>失败策略通过 `failure-strategy` 属性来设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of `dead-letter-queue`, you can configure the following attributes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `dead-letter-queue` 情况下 ，您可以配置以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`dead-letter-queue.topic`: the topic to use to write the records not processed correctly, default is `dead-letter-topic-$channel`, with `$channel` being the name of the channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dead-letter-queue.topic` : 该topic用来保存未被正确处理的记录，默认为 `dead-letter-topic-$channel` ， `$channel` 是channel的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`dead-letter-queue.key.serializer`: the serializer used to write the record key on the dead letter queue. By default, it deduces the serializer from the key deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dead-letter-queue.key.serializer` 该序列化器用来对记录到dead letter queue中的record key进行序列化。默认情况下，该序列化器会从key的反序列化器反推出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`dead-letter-queue.value.serializer`: the serializer used to write the record value on the dead letter queue. By default, it deduces the serializer from the value deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dead-letter-queue.value.serializer` :该序列化器用来对记录到dead letter queue中的record value进行序列化。默认情况下，该序列化器会从value的反序列化器反推出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The record written on the dead letter queue contains a set of additional headers about the original record:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有写入dead letter queue中的记录将包含一组关于原始记录的附加headers：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-reason*: the reason of the failure
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-reason* ：失败原因
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-cause*: the cause of the failure if any
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-cause* ：失败的起因(如果有)。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-topic*: the original topic of the record
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-topic* ：失败记录的原始topic
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-partition*: the original partition of the record (integer mapped to String)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-partition* ：失败记录的原始分区(integer映射为String)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-offset*: the original offset of the record (long mapped to String)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-offset* ：失败记录的原始偏移量(long映射为String)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrying processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重试处理(Retrying processing)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can combine Reactive Messaging with https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance], and retry processing if it failed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以将Reactive Messaging与 link:https://github.com/smallrye/smallrye-fault-tolerance[SmallRye 容错]结合起来，如果失败的话可以进行重试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the delay, the number of retries, the jitter, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以对延迟，重试次数以及抖动(jitter)等处理方式进行设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your method returns a `Uni` or `CompletionStage`, you need to add the `@NonBlocking` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的方法返回一个 `Uni` 或 `CompletionStage` ，您需要添加 `@NonBlocking` 注解：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@NonBlocking` annotation is only required with SmallRye Fault Tolerance 5.1.0 and earlier.  Starting with SmallRye Fault Tolerance 5.2.0 (available since Quarkus 2.1.0.Final), it is not necessary.  See https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Tolerance documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@NonBlocking` 注解仅在SmallRye Fault Tolerance 5.1.0及之前版本中需要。从SmallRye Fault Tolerance 5.2.0开始(Quarkus 2.1.0.Final开始)，它就不再必须了。更多信息请参见link:https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye 容错文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The incoming messages are acknowledged only once the processing completes successfully.  So, it commits the offset after the successful processing.  If the processing still fails, even after all retries, the message is _nacked_ and the failure strategy is applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传入的消息只有在处理成功完成后才会被确认。所以，它在处理成功后会提交偏移量。如果在所有的重试后处理仍然失败， 消息就会被标记为 _未确认(nacked)_ ，然后触发失败策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumer Groups</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者组(Consumer Groups)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Kafka, a consumer group is a set of consumers which cooperate to consume data from a topic.  A topic is divided into a set of partitions.  The partitions of a topic are assigned among the consumers in the group, effectively allowing to scale consumption throughput.  Note that each partition is assigned to a single consumer from a group.  However, a consumer can be assigned multiple partitions if the number of partitions is greater than the number of consumer in the group.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kafka中，消费者组表示可以通过合作来消费来自于同一个topic的数据的一组消费者。 一个topic可以包含一组分区(partitions)。一个topic的分区会在组内的消费者之间分配，从而有效地提高消费的吞吐量。请注意，每个分区只会被分配给组内的一个消费者。但如果分区的数量大于组中消费者的数量， 那么一个消费者可以被分配多个分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's explore briefly different producer/consumer patterns and how to implement them using Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们简单展示一下不同的生产者/消费者模式以及如何使用Quarkus来实现它们：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Single consumer thread inside a consumer group*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*消费者组内使用单一消费者线程*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the default behavior of an application subscribing to a Kafka topic: Each Kafka connector will create a single consumer thread and place it inside a single consumer group.  Consumer group id defaults to the application name as set by the `quarkus.application.name` configuration property.  It can also be set using the `kafka.group.id` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个应用程序订阅Kafka topic的默认方式：每个Kafka Connector将创建一个独立的消费者线程，并将其置于一个单独的消费者组内。消费者组id默认为 `quarkus.application.name` 所设定的应用程序名称。它也可以使用 `kafka.group.id` 来设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用结构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Multiple consumer threads inside a consumer group*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*一个消费者组内使用多个消费者线程* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a given application instance, the number of consumers inside the consumer group can be configured using `mp.messaging.incoming.$channel.partitions` property.  The partitions of the subscribed topic will be divided among the consumer threads.  Note that if the `partitions` value exceed the number of partitions of the topic, some consumer threads won't be assigned any partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于一个给定的应用程序实例，消费者组内的消费者数量可以使用 `mp.messaging.incoming.$channel.partitions` 进行配置。被订阅的topic中的分区将会在所有的消费者线程间进行分配。请注意，如果 `partitions` 值超过topic本身的分区数量，那么某些消费者线程将得不到分区分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Multiple consumer applications inside a consumer group*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*一个消费者组内有多个消费者应用程序* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to the previous example, multiple instances of an application can subscribe to a single consumer group, configured via `mp.messaging.incoming.$channel.group.id` property, or left default to the application name.  This in turn will divide partitions of the topic among application instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与前面的例子类似，一个应用程序的多个实例可以订阅同一个消费者组。这种方式可以通过 `mp.messaging.incoming.$channel.group.id` 进行配置，或默认为应用程序的名称。这种方式会在应用程序实例之间分配topic的分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Pub/Sub: Multiple consumer groups subscribed to a topic*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*发布/订阅：多个消费者群体订阅同一个topic* 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly different applications can subscribe independently to same topics using different *consumer group ids*.  For example, messages published to a topic called _orders_ can be consumed independently on two consumer applications, one with `mp.messaging.incoming.orders.group.id=invoicing` and second with `mp.messaging.incoming.orders.group.id=shipping`.  Different consumer groups can thus scale independently according to the message consumption requirements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，不同的应用程序可以使用不同的 *consumer group ids* 来的独立订阅同一topic。例如，发布在一个名为 _orders_ 的topic上的消息可以被两个消费者应用相互独立的消费，其中一个的group id是 `mp.messaging.incoming.orders.group.id=invoicing` ，另一个是 `mp.messaging.incoming.orders.group.id=shipping` 。因此，不同的消费者组可以根据消息消费的需求独立的进行扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumer Rebalance Listener</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者再平衡监听器(Consumer Rebalance Listener)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside a consumer group, as new group members arrive and old members leave, the partitions are re-assigned so that each member receives a proportional share of the partitions.  This is known as rebalancing the group.  To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.  To achieve this, implement the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` interface and expose it as a CDI bean with the `@Idenfier` qualifier.  A common use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个消费者组内，随着新老组员的交替，分区将会被重新分配，从而使每个组员都能分配到分区。这就是组的再平衡。为了处理偏移提交以及分区的分配，您可以提供一个消费者再平衡监听器。为了实现这一点，请实现 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 接口，并将其暴露为CDI bean并使用 `@Idenfier` 修饰符修饰。一个常见的用例是将偏移量存储在一个单独的数据存储中以使其保证语义上的精准一次(exactly-once semantic)，或者在某一个特定的偏移量开始时处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The listener is invoked every time the consumer topic/partition assignment changes.  For example, when the application starts, it invokes the `partitionsAssigned` callback with the initial set of topics/partitions associated with the consumer.  If, later, this set changes, it calls the `partitionsRevoked` and `partitionsAssigned` callbacks again, so you can implement custom logic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>监听器会在消费者的topic/分区分配发生变化时启动。例如，当应用程序启动时，它会调用 `partitionsAssigned`  回调并传入与消费者相关的初始topic/分区集合 。如果后来这个集合发生变化，它会再次调用 `partitionsRevoked` 和 `partitionsAssigned` 回调，所以您可以自行实现对应的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the rebalance listener methods are called from the Kafka polling thread and **will** block the caller thread until completion.  That’s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，再平衡(rebalance)监听器方法是在Kafka轮询线程中被调用的，并且 *会* 阻塞调用者线程直到完成。这是因为再平衡协议(rebalance protocol)有同步屏障，而在再平衡监听器中的异步代码可能会在同步屏障之后执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When topics/partitions are assigned or revoked from a consumer, it pauses the message delivery and resumes once the rebalance completes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当topic/分区被从消费者那里分配或撤销时，它会暂停消息传递， 然后在重平衡完成后立即恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the rebalance listener handles offset commit on behalf of the user (using the `NONE` commit strategy), the rebalance listener must commit the offset synchronously in the partitionsRevoked callback.  We also recommend applying the same logic when the application stops.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用再平衡监听器代替用户来处理偏移量提交(使用 `NONE` 提交策略)，再平衡监听器就必须在partitionRevoked回调中同步提交偏移量。我们也建议在应用程序停止时使用同样的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the `ConsumerRebalanceListener` from Apache Kafka, the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` methods pass the Kafka Consumer and the set of topics/partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Apache Kafka的 `ConsumerRebalanceListener` 不同， `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 的方法会传递Kafka消费者和topic/分区集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following example we set-up a consumer that always starts on messages from at most 10 minutes ago (or offset 0).  First we need to provide a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` and is annotated with `io.smallrye.common.annotation.Identifier`.  We then must configure our inbound connector to use this bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在下面例子设置的消费者中，它总是会在最多10分钟前(或偏移量0)的消息上启动。首先，我们需要提供一个实现了 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 并被注解为 `io.smallrye.common.annotation.Identifier` 的bean。然后我们必须配置inbound connector来使用这个Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the inbound connector to use the provided listener, we either set the consumer rebalance listener’s identifier: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如要配置inbound connector使用所提供的监听器，我们可以通过消费者再平衡监听器的标识符 `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer` 来设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or have the listener’s name be the same as the group id:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者令监听器的名字与消费者组的ID相同：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the consumer rebalance listener’s name takes precedence over using the group id.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，设置消费者再平衡监听器的名称的方式要比使用组ID的方式优先被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using unique consumer groups</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用单一的消费者组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to process all the records from a topic (from its beginning), you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想处理一个topic中的所有记录(从其最开始时)，您需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>assign your consumer to a consumer group not used by any other application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将您的消费者分配到一个不被任何其他程序使用的消费者组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus generates a UUID that changes between two executions (including in dev mode).  So, you are sure no other consumer uses it, and you receive a new unique group id every time your application starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus生成的UUID在两次执行之间会发生变化(包括在dev模式下)。因此，您可以确定没有其他消费者使用它，而且每次您的应用程序启动时都会收到一个新的唯一的组ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use that generated UUID as the consumer group as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用生成的UUID作为消费者组id，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `group.id` attribute is not set, it defaults the `quarkus.application.name` configuration property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置 `group.id` ，则其默认与 `quarkus.application.name` 相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>向Kafka发送消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration for the Kafka connector outgoing channels is similar to that of incoming:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Connector中用于发送的 channels 的配置与用于接收的 channel 的配置类似：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the connector to manage the `prices-out` channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置connector来管理 `prices-out` channel。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the topic name is same as the channel name. You can configure the topic attribute to override it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，topic名称与channel名称相同。您可以配置topic属性来覆盖它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside application configuration, channel names are unique.  Therefore, if you'd like to configure an incoming and outgoing channel on the same topic, you will need to name channels differently (like in the examples of this guide, `mp.messaging.incoming.prices` and `mp.messaging.outgoing.prices-out`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在应用配置里面，channel名称是唯一的。因此，如果您打算在相同topic上同时配置一个接收和一个发送的channel，您需要对这两个 channels 使用不同的名称(比如本指南的例子，`mp.messaging.incoming.prices` 和 `mp.messaging.outgoing.prices-out` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, your application can generate messages and publish them to the `prices-out` channel.  It can use `double` payloads as in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，您的程序可以生成消息并将其发布到 `prices-out` channel。它可以使用 `double` payloads，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您不应该在您的代码中直接调用被标记了 `@Incoming` 和/或 `@Outgoing` 注解的方法。它们会被框架调用。如果在用户代码中调用将不会得到预期的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the `generate` method returns a `Multi&lt;Double&gt;`, which implements the Reactive Streams `Publisher` interface.  This publisher will be used by the framework to generate messages and send them to the configured Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `generate` 方法返回了一个 `Multi&lt;Double&gt;` ，它实现了Reactive Streams `Publisher` 接口。Quarkus框架会使用这个发布者生成消息，并将其发送到您配置的Kafka topic中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.kafka.Record` to send key/value pairs:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了发送键/值对， 您可以直接返回一个 `io.smallrye.reactive.messaging.kafka.Record` 来代理一个payload：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Payload可以被封装在 `org.eclipse.microprofile.reactive.messaging.Message`，以便对写入的记录有更多的控制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`OutgoingKafkaRecordMetadata` allows to set metadata attributes of the Kafka record, such as `key`, `topic`, `partition` or `timestamp`.  One use case is to dynamically select the destination topic of a message.  In this case, instead of configuring the topic inside your application configuration file, you need to use the outgoing metadata to set the name of the topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OutgoingKafkaRecordMetadata` 允许您设置Kafka记录的元数据属性，如 `key` ， `topic` ， `partition` 或 `timestamp` 。一种场景是动态地选择消息的目标topic。在这种情况下，您需要使用出站元数据(outgoing metadata)来设置topic名称，而不是在配置文件中配置topic。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other than method signatures returning a Reactive Stream `Publisher` (`Multi` being an implementation of `Publisher`), outgoing method can also return single message.  In this case the producer will use this method as generator to create an infinite stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了返回Reactive Stream `Publisher` ( `Multi` 实现了 `Publisher` )的方法签名外，发送方法也可以返回单个消息。在这种情况下，生产者将使用该方法作为生成器来创建一个无限的流(infinite stream)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages with @Emitter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用@Emitter发送消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you need to have an imperative way of sending messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有时，您需要使用命令式的方式来发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you need to send a message to a stream when receiving a POST request inside a REST endpoint.  In this case, you cannot use `@Outgoing` because your method has parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您需要在REST节点内收到一个POST请求时向一个流发送消息。在这种情况下，您无法使用 `@Outgoing` ，因为您的方法有参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, you can use an `Emitter`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种情况下您可以使用 `Emitter` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending a payload returns a `CompletionStage`, completed when the message is acked. If the message transmission fails, the `CompletionStage` is completed exceptionally with the reason of the nack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送一个payload会返回一个 `CompletionStage` ，并且它会在消息被确认时完成。如果消息传输失败， `CompletionStage` 会以异常结束，并且包含未被确认的原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Emitter` 的配置方式与 其他被 `@Incoming` 和 `@Outgoing` 使用的流配置相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the `Emitter` you are sending messages from your imperative code to reactive messaging.  These messages are stored in a queue until they are sent.  If the Kafka producer client can't keep up with messages trying to be sent over to Kafka, this queue can become a memory hog and you may even run out of memory.  You can use `@OnOverflow` to configure back-pressure strategy.  It lets you configure the size of the queue (default is 256) and the strategy to apply when the buffer size is reached. Available strategies are `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` and `NONE`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `Emitter` 的话您会以命令式代码的方式发送消息到响应式消息中(reactive messaging)。这些消息被存储在一个队列中，直到它们被发送。如果Kafka生产者client无法跟上发送到Kafka的消息节奏，这个队列就会成为一个内存占用者，甚至会耗尽内存。您可以使用 `@OnOverflow` 来配置背压策略。它可以让您配置队列的大小(默认是256)和达到缓冲区上限时要应用的策略。可用的策略有 `DROP` , `LATEST` , `FAIL` , `BUFFER` , `UNBOUNDED_BUFFER` 和 `NONE` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the `Emitter` API, you can also encapsulate the outgoing payload inside `Message&lt;T&gt;`. As with the previous examples, `Message` lets you handle the ack/nack cases differently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `Emitter` API，您也可以将要发送的payload封装在 `Message&lt;T&gt;` 中 。与前面的例子一样， `Message` 让您以不同的方式处理确认/拒绝(ack/nack)的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer using Reactive Stream APIs, you can use `MutinyEmitter` that will return `Uni&lt;Void&gt;` from the `send` method.  You can therefore use Mutiny APIs for handling downstream messages and errors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您偏好于使用Reactive Stream APIs，您可以使用 `MutinyEmitter` ，它将在 `send` 方法中返回 `Uni&lt;Void&gt;` 。因此，您可以使用Mutiny APIs来处理下游的信息和错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to block on sending the event to the emitter with the `sendAndAwait` method.  It will only return from the method when the event is acked or nacked by the receiver.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以通过 `sendAndAwait` 方法在发送事件到emitter的时候进行阻塞。只有当事件被接收者确认或拒绝时，它才会从该方法中返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.annotations.Emitter` , `io.smallrye.reactive.messaging.annotations.Channel` 和 `io.smallrye.reactive.messaging.annotations.OnOverflow` 类现在已被废弃，并被替换为：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新的 `Emitter.send` 方法会返回一个 `CompletionStage` ，并且它会在产生的消息被确认时完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write Acknowledgement</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写确认</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Kafka broker receives a record, its acknowledgement can take time depending on the configuration.  Also, it stores in-memory the records that cannot be written.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka broker收到一条记录时，它的确认可能需要时间，这取决于配置。此外，它还会在内存中存储不能写入的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the connector does wait for Kafka to acknowledge the record to continue the processing (acknowledging the received Message).  You can disable this by setting the `waitForWriteCompletion` attribute to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，connector会等待Kafka确认记录以继续处理(确认收到的消息)。您可以通过将 `waitForWriteCompletion` 设置为 `false` 来禁用这个功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the `acks` attribute has a huge impact on the record acknowledgement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `acks` 属性对记录的确认有巨大影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a record cannot be written, the message is nacked.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一条记录无法写入，消息就会被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Backpressure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>背压</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka outbound connector handles back-pressure, monitoring the number of in-flight messages waiting to be written to the Kafka broker.  The number of in-flight messages is configured using the `max-inflight-messages` attribute and defaults to 1024.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的出站connector负责处理背压，并且会监测等待写入Kafka broker中的in-flight的消息数量。in-flight的消息的数量是通过 `max-inflight-messages` 配置的，默认为1024。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector only sends that amount of messages concurrently.  No other messages will be sent until at least one in-flight message gets acknowledged by the broker.  Then, the connector writes a new message to Kafka when one of the broker’s in-flight messages get acknowledged.  Be sure to configure Kafka’s `batch.size` and `linger.ms` accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Connector只会并行发送指定数量的消息。在至少一个in-flight的消息被broker确认之前，其他消息都不会被发送。然后，当broker中有in-flight的消息得到确认时，connector才会向Kafka写入一个新的消息。请确保相应地配置Kafka的 `batch.size` 和 `linger.ms` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also remove the limit of in-flight messages by setting `max-inflight-messages` to `0`.  However, note that the Kafka producer may block if the number of requests reaches `max.in.flight.requests.per.connection`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以通过将 `max-inflight-messages` 设置为 `0` 来取消in-flight消息的限制。但请注意，如果请求数量达到 `max.in.flight.requests.per.connection` 指定的值，Kafka生产者可能会阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrying message dispatch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重试消息的发送</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the Kafka producer receives an error from the server, if it is a transient, recoverable error, the client will retry sending the batch of messages.  This behavior is controlled by `retries` and `retry.backoff.ms` parameters.  In addition to this, SmallRye Reactive Messaging will retry individual messages on recoverable errors, depending on the `retries` and `delivery.timeout.ms` parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka生产者收到来自服务器的错误时，如果它是一个暂时的、可恢复的错误，那么客户端将重试发送这批消息。这种行为是由 `retries` 和 `retry.backoff.ms` 参数控制的。除此之外，SmallRye Reactive Messaging还会在可恢复的错误中重试单个消息，这取决于 `retries` 和 `delivery.timeout.ms` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that while having retries in a reliable system is a best practice, the `max.in.flight.requests.per.connection` parameter defaults to `5`, meaning that the order of the messages is not guaranteed.  If the message order is a must for your use case, setting `max.in.flight.requests.per.connection` to `1` will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，虽然在对一个可靠的系统来说拥有重试机制是一种最佳实践，但 `max.in.flight.requests.per.connection` 参数默认为 `5` 将会意味着消息的顺序不会被保证。如果消息的顺序对您来说是必须保证的，将 `max.in.flight.requests.per.connection` 设置为 `1` 将确保一次只发送一批消息，但代价是限制生产者的吞吐量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For applying retry mechanism on processing errors, see the section on &lt;&lt;retrying-processing&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于如何对错误处理应用重试机制，请参见 link:#retrying-processing[[重试-处理]] 一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-memory channels</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内存 channels</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some use cases, it is convenient to use the messaging patterns to transfer messages inside the same application.  When you don't connect a channel to a messaging backend like Kafka, everything happens in-memory, and the streams are created by chaining methods together.  Each chain is still a reactive stream and enforces the back-pressure protocol.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在某些情况下，使用消息模式在同一个应用程序内传输消息是很方便的。当您没有将channel连接到像Kafka这样的消息后端时，一切都会发生在内存中，并且流会通过链式方法创建。每个链式调用仍是一个响应式流，并执行背压策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The framework verifies that the producer/consumer chain is complete, meaning that if the application writes messages into an in-memory channel (using a method with only `@Outgoing`, or an `Emitter`), it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus框架会验证生产者/消费者链是否完整，这意味着如果应用程序将消息写入内存channel(仅使用 `@Outgoing` 修饰符方法，或 `Emitter` )，它也必须从应用程序内部消费消息(仅 `@Incoming` 修饰符方法 ，或使用不受管理的流)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Broadcasting messages on multiple consumers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对多个消费者广播信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a channel can be linked to a single consumer, using `@Incoming` method or `@Channel` reactive stream.  At application startup, channels are verified to form a chain of consumers and producers with single consumer and producer.  You can override this behavior by setting `mp.messaging.$channel.broadcast=true` on a channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，一个channel可以关联到一个单一的消费者上，通过使用 `@Incoming` 方法或 `@Channel` 响应式应式流。在程序启动时，channels 会被验证，以形成一个由单个消费者和生产者组成的消费者和生产者链。您可以通过在channel上设置 `mp.messaging.$channel.broadcast=true` 来覆盖这种行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case of in-memory channels, `@Broadcast` annotation can be used on the `@Outgoing` method. For example,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在内存 channels 的情况下， `@Broadcast` 注释可以用在 `@Outgoing` 方法上。比如说,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reciprocally, multiple producers on the same channel can be merged by setting `mp.messaging.incoming.$channel.merge=true`.  On the `@Incoming` methods, you can control how multiple channels are merged using the `@Merge` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相应地，同一 channel 上的多个生产者可以通过设置 `mp.messaging.incoming.$channel.merge=true` 来进行合并。在 `@Incoming` 方法上，您可以使用 `@Merge` 来控制多个 channels 的合并方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Processing Messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications streaming data often need to consume some events from a topic, process them and publish the result to a different topic.  A processor method can be simply implemented using both the `@Incoming` and `@Outgoing` annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用的流式数据常常需要从一个topic中消费一些事件，对其进行处理并将结果发布到不同的topic中。一个处理器方法可以简单地通过使用 `@Incoming` 和 `@Outgoing` 注解来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameter of the `process` method is the incoming message payload, whereas the return value will be used as the outgoing message payload.  Previously mentioned signatures for parameter and return types are also supported, such as `Message&lt;T&gt;`, `Record&lt;K, V&gt;`, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`process` 方法的参数是传入的消息的payload，而返回值将被用作传出的消息的payload。之前提到的参数和返回类型的签名也被支持，如 `Message&lt;T&gt;` ， `Record&lt;K, V&gt;` 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can apply asynchronous stream processing by consuming and returning reactive stream `Multi&lt;T&gt;` type:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过消费和返回响应式流 `Multi&lt;T&gt;` 类型来应用异步流处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Propagating Record Key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传播记录键</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When processing messages, you can propagate incoming record key to the outgoing record.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在处理信息时，您可以将传入的记录键发送给传出的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabled with `mp.messaging.outgoing.$channel.propagate-record-key=true` configuration, record key propagation produces the outgoing record with the same _key_ as the incoming record.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过启用 `mp.messaging.outgoing.$channel.propagate-record-key=true` ，记录键传播可以产生与传入记录的 _键_ 相同的传出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the outgoing record already contains a _key_, it *won't be overridden* by the incoming record key.  If the incoming record does have a _null_ key, the `mp.messaging.outgoing.$channel.key` property is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果传出的记录已经包含一个 _键_，那么它 *不会* 被传入的记录键的键所覆盖。如果传入的记录键为_空_，那么 `mp.messaging.outgoing.$channel.key` 设置的值会被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing Kafka clients directly</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>直接访问Kafka客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In rare cases, you may need to access the underlying Kafka clients.  `KafkaClientService` provides thread-safe access to `Producer` and `Consumer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在少数情况下，您可能需要访问底层的Kafka客户端。`KafkaClientService` 提供线程安全的方式来访问 `Producer` 和 `Consumer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KafkaClientService` is an experimental API and can change in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KafkaClientService` 是一个实验性的API，在未来可能会发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also get the Kafka configuration injected to your application and create Kafka producer, consumer and admin clients directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以把Kafka配置注入到您的应用程序中来直接创建Kafka生产者，消费者以及管理客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in capabilities to deal with JSON Kafka messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus有内置的能力来处理JSON格式的Kafka消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine we have a `Fruit` data class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>假设我们有一个 `Fruit` 数据类，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而我们想用它来接收来自Kafka的消息，从而进行一些价格转换，并将消息传回Kafka。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, we will need to setup JSON serialization with Jackson or JSON-B.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要做到这一点，我们需要用Jackson或JSON-B来设置JSON序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With JSON serialization correctly configured, you can also use `Publisher&lt;Fruit&gt;` and `Emitter&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在正确配置了JSON序列化后，您也可以使用 `Publisher&lt;Fruit&gt;` 和 `Emitter&lt;Fruit&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serializing via Jackson</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过Jackson进行序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `ObjectMapperSerializer` that can be used to serialize all data objects via Jackson.  You may create an empty subclass if you want to use &lt;&lt;serialization-autodetection&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个现有的 `ObjectMapperSerializer` ，可以用来通过Jackson来序列化所有的数据对象。如果您想使用 link:#serialization-autodetection[[自动侦测序列化]] ，您可以创建一个空的子类来继承该类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对应的反序列化器类也需要被子类化。因此，让我们创建一个 `FruitDeserializer` 来继承 `ObjectMapperDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your channels to use the Jackson serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，配置您的 channelss 以使用Jackson序列化器和反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a Jackson serialized representation of your `Fruit` data object.  In this case, the `deserializer` configuration is not necessary as the &lt;&lt;serialization-autodetection&gt;&gt; is enabled by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，您的Kafka消息将包含 `Fruit` 数据对象的Jackson序列化格式。在这种情况下，`deserializer` 的配置不是必须的，因为 link:#serialization-autodetection[[序列化自动侦测]] 是默认启用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serializing via JSON-B</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过JSON-B进行序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to include the `quarkus-jsonb` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，您需要引入 `quarkus-jsonb` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `JsonbSerializer` that can be used to serialize all data objects via JSON-B.  You may create an empty subclass if you want to use &lt;&lt;serialization-autodetection&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个现有的 `JsonbSerializer` ，可以通过JSON-B来序列化所有的数据对象。如果您想使用 link:#serialization-autodetection[[序列化自动侦测]] ，您可以创建一个空的子类类继承它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相应的反序列化器类需要被子类化。因此，让我们创建一个 `FruitDeserializer` 来继承 `JsonbDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your channels to use the JSON-B serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，通过配置来使您的 channels 使用JSON-B串行器和反串行器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a JSON-B serialized representation of your `Fruit` data object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，您的Kafka消息将包含 `Fruit` 数据对象的JSON-B序列化格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to create a deserializer for each data object, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您不想为每个数据对象创建一个反序列化器，您可以使用通用的 `io.vertx.kafka.client.serialization.JsonObjectDeserializer` ，它将把消息反序列化为一个 `io.vertx.core.json.JsonObject` 。也可以使用与之相对应的序列化器： `io.vertx.kafka.client.serialization.JsonObjectSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serializer/deserializer autodetection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化/反串行器自动侦测</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you declare</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您声明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and your configuration indicates that the `generated-price` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `IntegerSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而您的配置表明 `generated-price`  channel 使用了 `smallrye-kafka` 连接器，那么Quarkus会自动将 `value.serializer` 设置为Kafka内置的 `IntegerSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, if you declare</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同样地，如果您声明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and your configuration indicates that the `my-kafka-records` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `key.deserializer` to Kafka's built-in `LongDeserializer`, as well as the `value.deserializer` to `ByteArrayDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并且您的配置表明 `my-kafka-records`  channel 使用了 `smallrye-kafka` 连接器，那么Quarkus会自动将 `key.deserializer` 设置为Kafka内置的 `LongDeserializer` ，以及 `value.deserializer` 设置为 `ByteArrayDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, if you declare</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后，如果您声明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and your configuration indicates that the `price-create` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `DoubleSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而您的配置表明 `price-create`  channel 使用 `smallrye-kafka` 连接器，那么Quarkus将自动将 `value.serializer` 设置为Kafka内置的 `DoubleSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full set of types supported by the serializer/deserializer autodetection is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>序列化器/反序列化器自动侦测所支持的全部类型有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`byte[]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`byte[]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.lang.String`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.lang.String`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.UUID`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.UUID`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.nio.ByteBuffer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.nio.ByteBuffer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.common.utils.Bytes`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.common.utils.Bytes`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.buffer.Buffer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.buffer.Buffer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.json.JsonObject`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.json.JsonObject`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.json.JsonArray`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.json.JsonArray`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>classes for which a subclass of `ObjectMapperSerializer` / `ObjectMapperDeserializer` is present, as described in &lt;&lt;jackson-serialization&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ObjectMapperSerializer` / `ObjectMapperDeserializer` 的子类，如 link:#jackson-serialization[[jackson序列化]] 中所述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>it is technically not needed to subclass `ObjectMapperSerializer`, but in such case, autodetection isn't possible</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>技术上不需要对 `ObjectMapperSerializer` 子类化，但在这种情况下无法进行自动侦测</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>classes for which a subclass of `JsonbSerializer` / `JsonbDeserializer` is present, as described in &lt;&lt;jsonb-serialization&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`JsonbSerializer` / `JsonbDeserializer` 的子类，如 link:#jsonb-serialization[[jsonb序列化]] 中所述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>it is technically not needed to subclass `JsonbSerializer`, but in such case, autodetection isn't possible</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>技术上不需要对 `JsonbSerializer` 子类化，但在这种情况下无法进行自动侦测</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a serializer/deserializer is set by configuration, it won't be replaced by the autodetection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个序列化器/反序列化器是通过配置设置的，那么它不会被自动检测所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.  If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您对使用序列化器自动侦测有任何疑问，您可以通过设置 `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false` 来彻底关闭它。如果您需要这样做，请在 link:https://github.com/quarkusio/quarkus/issues[Quarkus问题跟踪] 中提交一个bug，这样我们就能跟踪并解决您的任何问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Schema Registry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Schema注册表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health Checks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>健康检查</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为Kafka提供了几种健康检查方式。这些方式需要与 `quarkus-smallrye-health` 扩展结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Broker Readiness Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Broker就绪检查(Readiness Check)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the `quarkus-kafka-client` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  It requires an _admin connection_ with the Kafka broker, and it is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `quarkus-kafka-client` 扩展时，您可以通过在您的 `application.properties` 配置文件中将 `quarkus.kafka.health.enabled` 属性设置为 `true` 来启用 _就绪_ 健康检查。该检查会报告与 _默认的_ Kafka Broker(使用 `kafka.bootstrap.servers` 配置)的交互状态。它需要一个与Kafka Broker的 _管理员连接_ ，并且默认是禁用的。如果启用，当您访问您应用程序的 `/q/health/ready` 节点时，您将获得关于连接验证状态的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides _startup_, _liveness_ and _readiness_ checks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用响应式消息传递和Kafka 连接器时，每个配置的 channel (传入或传出)都会提供 _启动_ 、 _活跃度(liveness)_ 和 _就绪_ 检查。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _startup_ check verifies that the communication with Kafka cluster is established.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_启动_ 检查确保与Kafka集群的通信是否建立。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_活跃性_ 检查可以捕获与Kafka通信过程中发生的任何不可恢复的故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _readiness_ check verifies that the Kafka connector is ready to consume/produce messages to the configured Kafka topics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_就绪_ 检查确保Kafka 连接器是否准备好针对配置的Kafka topic消费或生产消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each channel, you can disable the checks using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于每个 channel ，您都可以禁用检查，通过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Disable both liveness and readiness checks with `health-enabled=false`:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 通过 `health-enabled=false` 来同时禁用活跃性检查和就绪检查:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Disable only the readiness check with `health-readiness-enabled=false`:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 通过 `health-readiness-enabled=false` 来单独禁用就绪检查:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the `bootstrap.servers` for each channel using `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` property.  Default is `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` 属性为每个 channel 配置 `bootstrap.servers` 。默认是 `kafka.bootstrap.servers` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging _startup_ and _readiness_ checks offer two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in Kafka client metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息传递的 _启动_ 和 _就绪_ 检查提供了两种策略。默认策略是确认是否与broker建立了活动连接。这种方法不具有侵入性，因为它基于内置的Kafka客户端指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the `health-topic-verification-enabled=true` attribute, _startup_ probe uses an _admin client_ to check for the list of topics.  Whereas the _readiness_ probe for an incoming channel checks that at least one partition is assigned for consumption, and for an outgoing channel checks that the topic used by the producer exist in the broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `health-topic-verification-enabled=true` 属性， _启动_ 探针使用一个 _管理客户端_ 来检查topic列表。而传入 channel 的 _就绪_ 探针将检查是否至少有一个分区被分配用于消费，而传出 channel 则检查生产者使用的topic是否存在于broker中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that to achieve this, an _admin connection_ is required.  You can adjust the timeout for topic verification calls to the broker using the `health-topic-verification-timeout` configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，要实现这一点， 一个_管理员连接_是必须存在的 。您可以使用 `health-topic-verification-timeout` 来调整对broker的topic验证调用的超时时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Snappy for message compression</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Snappy进行消息压缩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _出站_  channels 上，您可以通过将 `compression.type` 设置为 `snappy` 来启用Snappy压缩：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在JVM模式下，它开箱即用。然而，如果要把您的应用程序编译成一个原生的可执行文件，您需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uses GraalVM 21.+</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用GraalVM 21.+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `quarkus.kafka.snappy.enabled=true` 添加到您的 `application.properties` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在原生模式下，Snappy默认是禁用的，因为使用Snappy需要嵌入一个原生库，并在应用程序启动时对其进行解包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authentication with OAuth</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用OAuth进行认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的Kafka broker使用OAuth作为认证机制，您需要配置Kafka消费者来启用这个认证过程。首先，在您的应用程序中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个依赖提供了处理OAuth工作流所需的回调处理器。然后，在 `application.properties` ，添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更改 `oauth.client.id` ， `oauth.client.secret` 和 `oauth.token.endpoint.uri` 值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth authentication works for both JVM and native modes. Since SSL in not enabled by default in native mode, `quarkus.ssl.native=true` must be added to support JaasClientOauthLoginCallbackHandler, which uses SSL. (See the xref:native-and-ssl.adoc[Using SSL with Native Executables] guide for more details.)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth认证在JVM和原生模式下都有效。由于SSL在原生模式下默认不启用，所以必须添加 `quarkus.ssl.native=true` ，以支持JaasClientOauthLoginCallbackHandler。它使用了SSL。(更多细节请参见《 link:native-and-ssl.html[在原生可执行文件中使用SSL] 》指南)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a Kafka application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试一个Kafka应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing without a broker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>无broker的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在不启动Kafka broker的情况下测试应用程序会很有用。为了实现这一点，您可以把Kafka连接器管理的 channels  _切换_ 到_内存 _中 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种方法只适用于JVM测试。它不能用于原生测试(因为原生模式不支持注入)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a Quarkus Test Resource as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，按以下方法创建Quarkus测试资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建并返回一个 `Map` ，包含配置应用程序使用内存 channels 所需的所有属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当测试停止时，清除 `InMemoryConnector` (丢弃所有接收和发送的信息)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a Quarkus Test using the test resource created above:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用上面创建的测试资源创建一个Quarkus测试：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the in-memory connector in your test class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在您的测试类中注入内存内连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检索传入 channel ( `orders` ) - 该 channel 必须在测试资源中被切换到内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，您也可以在测试资源中启动一个Kafka broker。下面的片段展示了如何在一个测试资源使用 link:https://www.testcontainers.org/modules/kafka/[Testcontainers] 启动一个Kafka broker：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the Kafka bootstrap location, so the application connects to this broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Kafka bootstrap位置，这样应用程序就会连接到这个broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in appropriately configured Kubernetes clusters, Kafka extension will pull its Kafka broker connection configuration from the service binding available inside the cluster, without the need for user configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当在正确配置的Kubernetes集群中运行时，Kafka扩展将从集群内部可用的服务绑定中获取Kafka broker连接配置，而不需要用户来配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execution model</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>执行模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging invokes user's methods on an I/O thread.  Thus, by default, the methods must not block.  As described in &lt;&lt;blocking-processing&gt;&gt;, you need to add the `@Blocking` annotation on the method if this method will block the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式流会在I/O线程上调用用户的方法。因此在默认情况下，这些方法不能阻塞。正如 link:#blocking-processing[[阻塞处理]] 中所述，如果这个方法会阻塞调用者线程，那么您需要在方法上添加 `@Blocking` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于这个话题的更多细节，请看 link:quarkus-reactive-architecture.html[Quarkus响应式架构文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incoming channel configuration (polling from Kafka)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入站 channel 配置(从Kafka轮询)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following attributes are configured using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下属性通过该方式进行配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some properties have aliases which can be configured globally:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些属性拥有可以进行全局配置的别名：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outgoing channel configuration (writing to Kafka)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出站 channel 配置(写入Kafka)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integrating with Kafka - Common patterns</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Kafka的整合--通用模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing to Kafka from an HTTP endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从HTTP节点写消息到Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To send messages to Kafka from an HTTP endpoint, inject an `Emitter` (or a `MutinyEmitter`) in your endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要从HTTP节点向Kafka发送消息，可以在您的节点中注入一个 `Emitter` (或一个 `MutinyEmitter` )：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject an `Emitter&lt;String&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入一个 `Emitter&lt;String&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTTP method receives the payload and returns a `CompletionStage` completed when the message is written to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP方法接会接收payload，并在消息被写入Kafka时返回一个 `CompletionStage`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send the message to Kafka, the `send` method returns a `CompletionStage`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将消息发送到Kafka后， `send` 方法会返回一个 `CompletionStage`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The endpoint sends the passed payload (from a `POST` HTTP request) to the emitter.  The emitter's channel is mapped to a Kafka topic in the `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点将已传递的payload(来自 `POST` HTTP请求)发送给emitter。emitter的 channel 被映射到 `application.properties` 文件中指定的一个Kafka topic：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The endpoint returns a `CompletionStage` indicating the asynchronous nature of the method.  The `emitter.send` method returns a `CompletionStage&lt;Void&gt;` .  The returned future is completed when the message has been written to Kafka.  If the writing fails, the returned `CompletionStage` is completed exceptionally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点会返回一个 `CompletionStage` ，表明该方法是异步的。 `emitter.send` 方法返回一个 `CompletionStage&lt;Void&gt;` 。当消息被写入Kafka时，返回的Future就被认为i完成了。如果写入失败，返回的 `CompletionStage` 会抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the endpoint does not return a `CompletionStage`, the HTTP response may be written before the message is sent to Kafka, and so failures won't be reported to the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果节点没有返回 `CompletionStage` ，HTTP响应可能会返回在消息被发送到Kafka之前，因此失败不会被报告给用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to send a Kafka record, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要发送一条Kafka记录，请使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the usage of an `Emitter&lt;Record&lt;K, V&gt;&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>声明 `Emitter&lt;Record&lt;K, V&gt;&gt;` 的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the record using `Record.of(k, v)`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `Record.of(k, v)` 来创建记录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persisting Kafka messages with Hibernate with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Hibernate与Panache来持久化Kafka消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To persist objects received from Kafka into a database, you can use Hibernate with Panache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了将从Kafka接收到的对象持久化到数据库中，您可以结合使用Hibernate与Panache。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Hibernate Reactive, look at &lt;&lt;persisting-kafka-messages-with-hibernate-reactive&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用Hibernate Reactive，请参看 link:#persisting-kafka-messages-with-hibernate-reactive[[使用Hibernate Reactive持久化Kafka消息]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you receive `Fruit` objects.  For simplicity purposes, our `Fruit` class is pretty simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们假设您收到了 `Fruit` 对象。为了简单起见，我们的 `Fruit` 类非常简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To consume `Fruit` instances stored on a Kafka topic, and persist them into a database, you can use the following approach:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了消费存储在Kafka topic上的 `Fruit` 实例，并将其持久化到数据库中，您可以使用以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the incoming channel. This channel reads from Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传入 channel 。该 channel 从Kafka读取消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method receives each Fruit. Note that you would need a deserializer to reconstruct the Fruit instances from the Kafka records.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方法接收每个Fruit对象。注意，您需要一个反序列化器来从Kafka记录中重建Fruit实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persist the received `fruit` object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持久化接收到的 `fruit` 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in &lt;4&gt;, you need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如&lt;4&gt;中提到的，您需要一个能从记录中重建 `Fruit` 对象的反序列化器。可以使用Jackson的反序列化器来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The associated configuration would be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相关的配置如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check &lt;&lt;jackson-serialization&gt;&gt; for more detail about the usage of Jackson with Kafka.  You can also use Avro.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参看 link:#jackson-serialization[[jackson序列化]]，了解更多关于Jackson与Kafka的使用细节。您也可以使用Avro。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persisting Kafka messages with Hibernate Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Hibernate Reactive持久化Kafka消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To persist objects received from Kafka into a database, you can use Hibernate Reactive with Panache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了将从Kafka收到的对象持久化到数据库中，您可以结合使用Hibernate Reactive与Panache。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to use the reactive variant</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保使用响应式变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Panache to run the given (asynchronous) action in a transaction. The transaction completes when the action completes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指令使Panache在一个事务中运行给定的(异步)操作。当该操作完成时，事务会结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persist the entity. It returns a `Uni&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>持久化该实体对象。它会返回一个 `Uni&lt;Fruit&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch back to a `Uni&lt;Void&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>切换并返回 `Uni&lt;Void&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike with _classic_ Hibernate, you can't use `@Transactional`.  Instead, we use `Panache.withTransaction` and persist our entity.  The `map` is used to return a `Uni&lt;Void&gt;` and not a `Uni&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与 _常规的_ Hibernate不同，您无法使用 `@Transactional` 注解。相反，可以使用 `Panache.withTransaction` ，并持久化实体实例。`map` 用来返回一个 `Uni&lt;Void&gt;` 实例，而不是一个 `Uni&lt;Fruit&gt;` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要一个能从记录中创建 `Fruit` 实例的反序列化器。可以使用Jackson的反序列化器来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing entities managed by Hibernate to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Hibernate管理的实体写入Kafka中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine the following process:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们假设以下过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You receive an HTTP request with a payload,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您收到一个带有payload的HTTP请求,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You create an Hibernate entity instance from this payload,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您从这个payload中创建一个Hibernate实体对象,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You persist that entity into a database,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您将该实体持久化到数据库中,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You send the entity to a Kafka topic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您把实体发送到一个Kafka topic中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Hibernate Reactive, look at &lt;&lt;writing-entities-managed-by-hibernate-reactive-to-kafka&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用Hibernate Reactive，请参看link:#writing-entities-managed-by-hibernate-reactive-to-kafka[[将hibernate reactive管理的实体写入kafka]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we write to a database, we must run this method in a transaction.  Yet, sending the entity to Kafka happens asynchronously.  The operation returns a `CompletionStage` (or a `Uni` if you use a `MutinyEmitter`) reporting when the operation completes.  We must be sure that the transaction is still running until the object is written.  Otherwise, you may access the object outside the transaction, which is not allowed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为我们要往数据库写入数据，所以我们必须在事务中运行该方法。然而，向Kafka发送消息是异步的。该操作完成后会返回一个 `CompletionStage` (如果您使用 `MutinyEmitter`，则返回 `Uni`)。我们必须确认在对象被写入之前事务仍然在运行。否则，您可能会在事务之外访问到该对象，而这是不允许的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement this process, you need the following approach:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了实现这一过程，您需要采取以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we are writing to the database, make sure we run inside a transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当我们向数据库中写入数据时，请确保运行在事务中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method receives the fruit instance to persist. It returns a `CompletionStage` which is used for the transaction demarcation. The transaction is committed when the return `CompletionStage` completes. In our case, it's when the message is written to Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方法接收要持久化的fruit实例。它返回了一个 `CompletionStage` ，用于事务分界。当返回的 `CompletionStage` 完成时，事务即会提交。在我们的例子中，这种情况就是消息被写入Kafka的时候。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send the managed instance to Kafka. Make sure we wait for the message to complete before closing the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将管理的实例发送到Kafka。确保我们在事务关闭之前等待消息的完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing entities managed by Hibernate Reactive to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Hibernate Reactive管理的实体写入Kafka中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To send to Kafka entities managed by Hibernate Reactive, we recommend using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了将Hibernate Reactive管理的实体发送到Kafka，建议使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `MutinyEmitter` to send message to a channel, so it can be easily integrated with the Mutiny API exposed by Hibernate Reactive or Hibernate Reactive with Panache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`MutinyEmitter` 会向 channel 发送消息，所以它可以很容易地与Hibernate Reactive或Hibernate Reactive with Panache所暴露的Mutiny API进行集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example demonstrates how to receive a payload, store it in the database using Hibernate Reactive with Panache, and send the persisted entity to Kafka:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子演示了如何接收一个payload，使用Hibernate Reactive with Panache将其存储在数据库中，并将持久化的实体发送到Kafka：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject a `MutinyEmitter` which exposes a Mutiny API. It simplifies the integration with the Mutiny API exposed by Hibernate Reactive with Panache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入一个暴露了Mutiny API的 `MutinyEmitter` 。它简化了与Hibernate Reactive with Panache所暴露的Mutiny API的整合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTTP method receiving the payload returns a `Uni&lt;Void&gt;`. The HTTP response is written when the operation completes (the entity is persisted and written to Kafka).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收payload的HTTP方法返回一个 `Uni&lt;Void&gt;` 。当操作完成后，会返回HTTP响应(实体被持久化并被写入Kafka)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to write the entity into the database in a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要在一个事务中把实体写进数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the persist operation completes, we send the entity to Kafka. The `send` method returns a `Uni&lt;Void&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦持久化操作完成，我们就把实体发送到Kafka。 `send` 方法会返回一个 `Uni&lt;Void&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Streaming Kafka topics as server-sent events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Kafka topic作为服务器发送的事件流化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Streaming a Kafka topic as server-sent events (SSE) is straightforward:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将Kafka topic作为服务器发送的事件(Server-sent events, SSE)进行流化非常直白:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You inject the channel representing the Kafka topic in your HTTP endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您在您的HTTP节点中注入代表Kafka topic的 channel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You return that channel as a `Publisher` or a `Multi` from the HTTP method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您将该 channel 作为一个 `Publisher` 或 `Multi` 从HTTP方法中返回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following code provides an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下代码提供了一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some environment cuts the SSE connection when there is not enough activity.  The workaround consists of sending _ping_ messages (or empty objects) periodically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当没有足够的活跃度时，一些环境会切断SSE的连接。替代方法则是定期发送 _ping_ 消息(或空对象)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The workaround is a bit more complex as besides sending the fruits coming from Kafka, we need to send pings periodically.  To achieve this we merge the stream coming from Kafka and a periodic stream emitting `{}` every 10 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该替代方法有点复杂，因为除了发送来自Kafka的fruit实例，我们还需要定期发送ping。为了实现这一点，我们合并了来自Kafka的数据流和一个每10秒发送一个 `{}` 的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going further</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>进一步探索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南已经展示了如何使用Quarkus与Kafka进行交互。它利用SmallRye Reactive Messaging来构建数据流应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想更进一步，请参看link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging]，在Quarkus中使用的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置端口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>描述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `CTRL+C` 来停止应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Maven structure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven的结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a scheduled job</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个计划作业</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `get()` method allows retrieving the current value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`get()` 方法允许检索当前值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression `cron.expr` which is configurable in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `application.properties` 中使用类似于cron表达式的方式定义一个名为 `cron.expr` 的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the application configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新该应用程序的配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CounterBean`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入 `CounterBean` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send back the current counter value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>返回当前计数器的值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the tests. Edit the `CountResourceTest` class to match:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，我们还需要更新测试。如下编辑 `CountResourceTest` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that the response contains `count`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确保响应中包含 `count`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions in Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus中使用事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.  Each extension dealing with persistence will integrate with it for you.  And you will explicitly interact with transactions via CDI.  This guide will walk you through all that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带一个事务管理器，并使用它来协调和暴露事务给你的应用程序。每个处理持久性的扩展都会与它集成。而且你将通过CDI明确地与事务进行交互。本指南将指导你完成这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting it up</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置它</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't need to worry about setting it up most of the time as extensions needing it will simply add it as a dependency.  Hibernate ORM for example will include the transaction manager and set it up properly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在大多数情况下，你不需要担心设置它，因为需要它的扩展会简单地把它作为一个依赖项加入。例如，Hibernate ORM将包括事务管理器并对其进行正确设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting and stopping transactions: defining your boundaries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开始和停止事务：确定你的事务边界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declarative approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>声明式方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to define your transaction boundaries is to use the `@Transactional` annotation on your entry method (`javax.transaction.Transactional`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义你的事务边界的最简单的方法是在你的入口方法上使用 `@Transactional` 注释( `javax.transaction.Transactional` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation defines your transaction boundaries and will wrap this call within a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个注解定义了你的事务边界，并将把这个调用包含在一个事务中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `RuntimeException` crossing the transaction boundaries will rollback the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个 `RuntimeException` ，越过事务边界，将回滚交易。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.  That includes REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional` 可以用来在方法层或类层控制任何CDI bean的事务边界，以确保每个方法都是事务性的。这包括REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can control whether and how the transaction is started with parameters on `@Transactional`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过 `@Transactional` 上的参数来控制是否以及如何启动事务：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRED)` (default): starts a transaction if none was started, stays with the existing one otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(REQUIRED)` (默认）：如果当前没有事务，则启动一个事务，否则保持现有的事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRES_NEW)`: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(REQUIRES_NEW)` ：如果当前没有事务，则启动一个事务；如果已经启动了一个事务，则暂停该事务，并从该方法的边界开始重新启动一个新事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(MANDATORY)`: fails if no transaction was started ; works within the existing transaction otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(MANDATORY)` ：如果没有启动任何事务，则失败；否则在现有事务中工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(SUPPORTS)`: if a transaction was started, joins it ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(SUPPORTS)` :如果一个事务已经开始，则加入它；否则在没有事务的情况下工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(NOT_SUPPORTED)`: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(NOT_SUPPORTED)` 暂停事务：如果一个事务已经开始，则暂停事务，并在方法的边界内不使用事务；否则不使用事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(NEVER)`: if a transaction was started, raises an exception ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(NEVER)` :如果一个事务被启动，引发一个异常；否则在没有事务的情况下工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`REQUIRED` or `NOT_SUPPORTED` are probably the most useful ones.  This is how you decide whether a method is to be running within or outside a transaction.  Make sure to check the JavaDoc for the precise semantic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`REQUIRED` 或 `NOT_SUPPORTED` 可能是最有用的。它们决定一个方法是在事务内还是事务外运行。请确保查看JavaDoc以了解准确的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transaction context is propagated to all calls nested in the `@Transactional` method as you would expect (in this example `childDAO.addToGiftList()` and `santaDAO.addToSantaTodoList()`).  The transaction will commit unless a runtime exception crosses the method boundary.  You can override whether an exception forces the rollback or not by using `@Transactional(dontRollbackOn=SomeException.class)` (or `rollbackOn`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如你所期望的那样，事务上下文被传播并嵌套在 `@Transactional` 方法中的所有调用（在这个例子中 `childDAO.addToGiftList()` 和 `santaDAO.addToSantaTodoList()` ）。除非有运行时异常穿越方法边界，否则事务将会提交。你可以通过使用 `@Transactional(dontRollbackOn=SomeException.class)` （或 `rollbackOn` ）来覆盖异常是否强制回滚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also programmatically ask for a transaction to be marked for rollback.  Inject a `TransactionManager` for this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以使用编程方式要求一个事务被标记为回滚。为此需要注入 `TransactionManager` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `TransactionManager` to be able to activate `setRollbackOnly` semantic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入 `TransactionManager` ，能够激活 `setRollbackOnly` 语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically decide to set the transaction for rollback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以编程方式决定将该事务设置为回滚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced configuration of the transaction is possible with the use of the `@TransactionConfiguration` annotation that is set in addition to the standard `@Transactional` annotation on your entry method or at the class level.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了在你的入口方法上或在类的层面上设置标准的 `@Transactional` 注解之外，事务的高级配置还可以通过使用 `@TransactionConfiguration` 注解来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@TransactionConfiguration` annotation allows to set a timeout property, in seconds, that applies to transactions created within the annotated method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@TransactionConfiguration` 注解允许设置一个超时属性，以秒为单位，适用于在注解方法中创建的事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation may only be placed on the top level method delineating the transaction.  Annotated nested methods once a transaction has started will throw an exception.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个注释只能放在划定事务的顶层方法上。一旦事务开始，被注解的嵌套方法将抛出一个异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If defined on a class, it is equivalent to defining it on all the methods of the class marked with `@Transactional`.  The configuration defined on a method takes precedence over the configuration defined on a class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在一个类上定义，就相当于在该类所有标有 `@Transactional` 的方法上定义了它。在方法上定义的配置优先于在类上定义的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应性扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your `@Transactional`-annotated method returns a reactive value, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的 `@Transactional` -注释的方法返回一个响应性的值，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any type which can be converted to one of the two previous types using Reactive Type Converters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任何可以使用响应式类型转换器转换为前两种类型之一的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>then the behaviour is a bit different, because the transaction will not be terminated until the returned reactive value is terminated. In effect, the returned reactive value will be listened to and if it terminates exceptionally the transaction will be marked for rollback, and will be committed or rolled-back only at termination of the reactive value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么行为就有点不同了，因为在返回的响应式值终止之前，事务不会被终止。实际上，返回的响应式值将被监听，如果它意外终止，事务将被标记为回滚，并且只有在响应式值终止时才会提交或回滚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows your reactive methods to keep on working on the transaction asynchronously until their work is really done, and not just until the reactive method returns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这允许你的响应式方法以异步方式继续在事务上工作，直到他们的工作真正完成，而不仅仅是当响应式方法返回时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The less easy way is to inject a `UserTransaction` and use the various transaction demarcation methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不太容易的方法是注入一个 `UserTransaction` ，并使用各种事务处理方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot use `UserTransaction` in a method having a transaction started by a `@Transactional` call.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不能在一个由 `@Transactional` 控制事务启动的方法中使用 `UserTransaction` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the transaction timeout</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置事务超时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the default transaction timeout, the timeout that applies to all transactions managed by the transaction manager, via the property `quarkus.transaction-manager.default-transaction-timeout`, specified as a duration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过属性 `quarkus.transaction-manager.default-transaction-timeout` 来配置默认的事务超时，即适用于由事务管理器管理的所有事务的超时，指定为一个持续时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value is 60 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认值是60秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring transaction node name identifier</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置事务节点名称标识符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Narayana, as the underlying transaction manager, has a concept of a unique node identifier.  This is important if you consider using XA transactions that involve multiple resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Narayana作为底层事务管理器，有一个唯一节点标识符的概念。如果你考虑使用涉及多个资源的XA事务，这就很重要了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier plays a crucial part in the identification of a transaction.  The node name identifier is forged into the transaction id when the transaction is created.  Based on the node name identifier, the transaction manager is capable of recognizing the XA transaction counterparts created in database or JMS broker. The identifier makes possible for the transaction manager to roll back the transaction counterparts during recovery.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点名称标识符在交易的识别中起着至关重要的作用。当交易被创建时，节点名称标识符被做为成交易ID的一部分。基于节点名称标识符，事务管理器能够识别在数据库或JMS代理中创建的XA事务对应物。该标识符使事务管理器有可能在恢复期间回滚事务对应方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier needs to be unique per transaction manager deployment.  And the node identifier needs to be stable over the transaction manager restarts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点名称标识符需要在每个事务管理器部署中是唯一的。而且节点标识符需要在事务管理器重新启动时保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier may be configured via the property `quarkus.transaction-manager.node-name`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>节点名称标识符可以通过属性 `quarkus.transaction-manager.node-name` 进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why always having a transaction manager?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为什么总是有一个事务处理器？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does it work everywhere I want to?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它能在我希望的所有地方工作吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yep, it works in your Quarkus application, in your IDE, in your tests, because all of these are Quarkus applications.  JTA has some bad press for some people.  I don't know why.  Let's just say that this is not your grandpa's JTA implementation.  What we have is perfectly embeddable and lean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是的，它在你的Quarkus应用程序中，在你的IDE中，在你的测试中都可以使用，因为这些都是Quarkus应用程序。JTA对一些人来说有一些不好的影响。我不知道为什么。我们只能说，这不是老旧的JTA实现。我们所拥有的是完美的可嵌入的和精简的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does it do 2 Phase Commit and slow down my app?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>两阶段提交是否会减慢了我的应用程序？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No, this is an old folk tale.  Let's assume it essentially comes for free and let you scale to more complex cases involving several datasources as needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不，这是一个古老的民间故事。让我们假设它基本上是免费的，让你根据需要扩展到涉及几个数据源的更复杂的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I don't need transaction when I do read only operations, it's faster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当我做只读操作时，就不需要事务，这样会更快</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wrong. + First off, just disable the transaction by marking your transaction boundary with `@Transactional(NOT_SUPPORTED)` (or `NEVER` or `SUPPORTS` depending on the semantic you want). + Second, it's again fairy tale that not using transaction is faster.  The answer is, it depends on your DB and how many SQL SELECTs you are making.  No transaction means the DB does have a single operation transaction context anyways. + Third, when you do several SELECTs, it's better to wrap them in a single transaction because they will all be consistent with one another.  Say your DB represents your car dashboard, you can see the number of kilometers remaining and the fuel gauge level.  By reading it in one transaction, they will be consistent.  If you read one and the other from two different transactions, then they can be inconsistent.  It can be more dramatic if you read data related to rights and access management for example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>错误。 + 首先，只要用 `@Transactional(NOT_SUPPORTED)` （或 `NEVER` 或 `SUPPORTS` ，取决于你想要的语义）标记你的事务边界，就可以禁用事务。 + 其次，不使用事务会更快，这又是另一个故事。答案是，这取决于你的数据库和你正在进行的SQL SELECT的数量。不使用事务意味着无论如何，数据库确实有一个单一的操作事务环境。 + 第三，当你做几个SELECT时，最好把它们包在一个事务中，因为它们都会保持一致性。假设你的数据库代表你的汽车仪表盘，你可以看到剩余的公里数和油表水平。通过在一个事务中读取它，它们将是一致的。如果你从两个不同的事务中读取一个和另一个，那么它们可能是不一致的。再例如，如果你读取与权限和访问管理有关的数据，结果可能会更加戏剧化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why do you prefer JTA vs Hibernate's transaction management API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为什么相对Hibernate 的事务管理 API你更推荐JTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing the transactions manually via `entityManager.getTransaction().begin()` and friends lead to a butt ugly code with tons of try catch finally that people get wrong.  Transactions are also about JMS and other database access, so one API makes more sense.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 `entityManager.getTransaction().begin()` 和手动管理事务会导致一段丑陋的代码，最终人们会出错。 事务也与 JMS 和其他数据库访问有关，因此一个 API 更有意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a mess because I don't know if my JPA persistence unit is using `JTA` or `Resource-level` Transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当不知道JPA persistence unit 使用的是“JTA”还是“Resource-level”事务，这可能会造成混乱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not a mess in Quarkus :)  Resource-level was introduced to support JPA in a non managed environment.  But Quarkus is both lean and a managed environment so we can safely always assume we are in JTA mode.  The end result is that the difficulties of running Hibernate ORM + CDI + a transaction manager in Java SE mode are solved by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 Quarkus 中不会引起混乱 :) 引入资源级是为了在非托管环境中支持 JPA。 但是 Quarkus 既是精益环境又是托管环境，因此我们始终可以安全地假设我们处于 JTA 模式。 最终的结果是，Quarkus 解决了在 Java SE 模式下运行 Hibernate ORM + CDI + 事务管理器的困难。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute (_alias_)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性 _（别名）_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandatory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否强制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether tracing is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否启用（默认启用）或禁用tracing

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the connector should allow multiple upstreams

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器是否可以允许多个上游(upstream)

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Spring guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多 Spring 指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has more Spring compatibility features. See the following guides for more details:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus拥有更多的Spring兼容特性。获取更多细节请参阅以下指南:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified MongoDB with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache简化MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used, but using its raw API can be cumbersome as you need to express your entities and your queries as a MongoDB link:{mongodb-doc-root-url}/bson/documents/#document[`Document`].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB是一个广为人知的NoSQL数据库，但使用其原始API可能很麻烦，因为你需要将你的实体和你的查询表达为MongoDB的 link:{mongodb-doc-root-url}/bson/documents/#document[`Document`] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First: an example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一：一个例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Panache allows you to write your MongoDB entities like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache允许你像这样写你的MongoDB实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have noticed how much more compact and readable the code is compared to using the MongoDB API? Does this look interesting? Read on!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你是否注意到与使用MongoDB API相比，代码更加紧凑和可读？这看起来是不是很有趣？请继续阅读!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `list()` method might be surprising at first. It takes fragments of PanacheQL queries (subset of JPQL) and contextualizes the rest.  That makes for very concise but yet readable code.  MongoDB native queries are also supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`list()` 的方法一开始可能会让人吃惊。它采用PanacheQL查询的片段（JPQL的子集），并将其余部分进行上下文处理。这使得代码非常简明，但又可读。也支持MongoDB本地查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>what was described above is essentially the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.  MongoDB with Panache also allows for the use of the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheMongoRepository`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面所描述的本质上是 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[活动记录模式] ，有时也称为实体模式。带有Panache的MongoDB也允许通过 `PanacheMongoRepository` ，使用更经典的 link:https://martinfowler.com/eaaCatalog/repository.html[存储库模式] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `mongodb-panache-quickstart` {quickstarts-tree-url}/mongodb-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `mongodb-panache-quickstart` {quickstarts-tree-url}/mongodb-panache-quickstart[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up and configuring MongoDB with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Panache 设置和配置 MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get started:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起步：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your settings in `{config-file}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `{config-file}` 中添加你的设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make your entities extend `PanacheMongoEntity` (optional if you are using the repository pattern)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使你的实体继承 `PanacheMongoEntity` （如果你使用资源库模式，则是可选的）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, use the `@MongoEntity` annotation to specify the name of the collection, the name of the database or the name of the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以选择使用 `@MongoEntity` 注解来指定集合的名称、数据库的名称或客户端的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then add the relevant configuration properties in `{config-file}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后在 `{config-file}` 中添加相关的配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.mongodb.database` property will be used by MongoDB with Panache to determine the name of the database where your entities will be persisted (if not overridden by `@MongoEntity`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB将使用 `quarkus.mongodb.database` 属性和Panache来确定实体将持久化的数据库的名称。（如果没有被 `@MongoEntity` 重写）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@MongoEntity` annotation allows configuring:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@MongoEntity` 注解允许根据以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the name of the database, otherwise, the `quarkus.mongodb.database` property will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数据库的名称，否则，将使用 `quarkus.mongodb.database` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the name of the collection, otherwise the simple name of the class will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集合的名称，否则将使用该类的简单名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution 1: using the active record pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案1：使用active record（活动记录）模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining your entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义你的实体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a Panache entity, simply extend `PanacheMongoEntity` and add your columns as public fields.  You can add the `@MongoEntity` annotation to your entity if you need to customize the name of the collection, the database, or the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要定义一个Panache实体，只需扩展 `PanacheMongoEntity` ，并添加你的列作为公共字段。如果你需要自定义集合、数据库或客户端的名称，你可以向你的实体添加 `@MongoEntity` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotating with `@MongoEntity` is optional. Here the entity will be stored in the `ThePerson` collection instead of the default `Person` collection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@MongoEntity` 注解是可选的。在这里，实体将被存储在 `ThePerson` 集合中，而不是默认的 `Person` 集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache uses the link:{mongodb-doc-root-url}/bson/pojos/[PojoCodecProvider] to convert your entities to a MongoDB `Document`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB使用 link:{mongodb-doc-root-url}/bson/pojos/[PojoCodecProvider] 将你的实体转换为MongoDB `Document` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will be allowed to use the following annotations to customize this mapping:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你将被允许使用以下注解来自定义这种映射：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@BsonId`: allows you to customize the ID field, see &lt;&lt;custom-ids,Custom IDs&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@BsonId` ：允许你自定义ID字段，见 link:#custom-ids[自定义ID] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@BsonProperty`: customize the serialized name of the field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@BsonProperty` ：自定义字段的序列化名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@BsonIgnore`: ignore a field during the serialization.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@BsonIgnore` ：在序列化过程中忽略一个字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to write accessors, you can:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要编写访问器，你可以这样编写：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class Person extends PanacheMongoEntity {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class Person extends PanacheMongoEntity {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And thanks to our field access rewrite, when your users read `person.name` they will actually call your `getName()` accessor, and similarly for field writes and the setter.  This allows for proper encapsulation at runtime as all fields calls will be replaced by the corresponding getter/setter calls.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>而且由于我们的字段访问重写，当你的用户读取 `person.name` ，他们实际上会调用你的 `getName()` 方法，类似的还有字段写入和设置器。这允许在运行时进行适当的封装，因为所有字段的调用都将被相应的getter/setter调用所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most useful operations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最有用的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have written your entity, here are the most common operations you will be able to perform:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写实体后，可以执行以下最常见的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `list` methods have equivalent `stream` versions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有 `list` 方法都有相对应的 `stream` 版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `persistOrUpdate()` method exist that persist or update an entity in the database, it uses the __upsert__ capability of MongoDB to do it in a single query.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>存在一个 `persistOrUpdate()` 方法来持久化或更新数据库中的实体，它使用MongoDB的 __upsert__ 功能在单个查询中完成此操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding entity methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>添加实体方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add custom queries on your entities inside the entities themselves.  That way, you and your co-workers can find them easily, and queries are co-located with the object they operate on.  Adding them as static methods in your entity class is the Panache Active Record way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在实体本身内部的实体上添加自定义查询。这样，您和您的同事可以轻松找到它们，并且查询与他们操作的对象位于同一位置。将它们作为静态方法添加到实体类中是 Panache Active Record 方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution 2: using the repository pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案2：使用资源库模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your entity as regular POJO.  You can add the `@MongoEntity` annotation to your entity if you need to customize the name of the collection, the database, or the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以将你的实体定义为普通的POJO。如果你需要自定义集合、数据库或客户端的名称，你可以给你的实体添加 `@MongoEntity` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use public fields or private fields with getters/setters.  If you don't want to manage the ID by yourself, you can make your entity extends `PanacheMongoEntity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用公共字段或带有getters/setters的私有字段。如果你不想自己管理ID，你可以让你的实体继承 `PanacheMongoEntity` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining your repository</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义你的存储库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you can get the exact same convenient methods as wit the active record pattern, injected in your Repository, by making them implements `PanacheMongoRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 Repositories 时，你可以得到与主动记录模式完全相同的方便方法，注入到你的 Repository 中，通过使它们实现 `PanacheMongoRepository` 接口 ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the operations that are defined on `PanacheMongoEntityBase` are available on your repository, so using it is exactly the same as using the active record pattern, except you need to inject it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有在 `PanacheMongoEntityBase` 上定义的操作都可以在你的版本库上使用，所以使用它与使用active record（活动记录）模式完全一样，只是你需要注入它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have written your repository, here are the most common operations you will be able to perform:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写存储库后，您可以执行以下最常见的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the documentation show usages based on the active record pattern only, but keep in mind that they can be performed with the repository pattern as well.  The repository pattern examples have been omitted for brevity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其余的文档只展示了基于活动记录模式的用法，但请记住，这些用法也可以用资源库模式来执行。为了简洁起见，已省略存储库模式示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a JAX-RS resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写一个JAX-RS资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you can create the following resource to create/read/update/delete your Person entity:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，你可以创建以下资源来create/read/update/delete你的Person实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced Query</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高级查询</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Paging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分页</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should only use `list` and `stream` methods if your collection contains small enough data sets. For larger data sets you can use the `find` method equivalents, which return a `PanacheQuery` on which you can do paging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的集合包含足够小的数据集，你应该只使用 `list` 和 `stream` 方法。对于较大的数据集，你可以使用 `find` 方法来替代，它返回一个 `PanacheQuery` ，你可以对其进行分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `PanacheQuery` type has many other methods to deal with paging and returning streams.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PanacheQuery` 类型有许多其他方法来处理分页和返回流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a range instead of pages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用range而不是pages</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`PanacheQuery` also allows range-based queries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PanacheQuery` 也允许基于范围的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot mix ranges and pages: if you use a range, all methods that depend on having a current page will throw an `UnsupportedOperationException`; you can switch back to paging using `page(Page)` or `page(int, int)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不能混合使用ranges和pages：如果你使用range，所有依赖于拥有当前页面的方法将抛出一个 `UnsupportedOperationException` ；你可以使用 `page(Page)` 或 `page(int, int)` 切换回分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sorting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>排序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All methods accepting a query string also accept an optional `Sort` parameter, which allows you to abstract your sorting:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有接受查询字符串的方法也接受一个可选的 `Sort` 参数，这使你可以抽象出你的排序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Sort` class has plenty of methods for adding columns and specifying sort direction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Sort` 类有很多方法用于添加列和指定排序方向。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified queries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>简化查询</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally, MongoDB queries are of this form: `{'firstname': 'John', 'lastname':'Doe'}`, this is what we call MongoDB native queries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常情况下，MongoDB的查询是这种形式： `{'firstname': 'John', 'lastname':'Doe'}` ，这就是我们所说的MongoDB原生查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use them if you want, but we also support what we call **PanacheQL** that can be seen as a subset of link:https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm#BNBTG[JPQL] (or link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL]) and allows you to easily express a query.  MongoDB with Panache will then map it to a MongoDB native query.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你愿意，你可以使用它们，但我们也支持所谓的 **PanacheQL** ，它可以被看作是 link:https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm#BNBTG[JPQL] （或 link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL] ）的一个子集，并允许你轻松地表达一个查询。使用Panache的MongoDB会将其映射为MongoDB的原生查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your query does not start with `{`, we will consider it a PanacheQL query:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的查询不是以 `{` 开始，我们将认为它是一个PanacheQL查询：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;singlePropertyName&gt;` (and single parameter) which will expand to `{'singleColumnName': '?1'}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;singlePropertyName&gt;` (和单一参数），这将扩展为 `{'singleColumnName': '?1'}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;query&gt;` will expand to `{&lt;query&gt;}` where we will map the PanacheQL query to MongoDB native query form. We support the following operators that will be mapped to the corresponding MongoDB operators: 'and', 'or' ( mixing 'and' and 'or' is not currently supported), '=', '&gt;', '&gt;=', '&lt;', '&lt;=', '!=', 'is null', 'is not null', and 'like' that is mapped to the MongoDB `$regex` operator (both String and JavaScript patterns are supported).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;query&gt;` 将扩展到 ，在这里我们将把PanacheQL查询映射到MongoDB原生查询形式。我们支持以下运算符，它们将被映射为相应的MongoDB运算符：'and'、 'or'（目前不支持 'and' 和 'or'一起使用）、'='、'&gt;'、'&gt;='、 '&lt;'、'&lt;='、'!='、'is null'、'is not null' 和 'like' 映射到 MongoDB `regex` 运算符（支持字符串和 JavaScript 模式）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are some query examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是一些查询例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`firstname = ?1 and status = ?2` will be mapped to `{'firstname': ?1, 'status': ?2}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`firstname = ?1 and status = ?2` 将被映射到 `{'firstname': ?1, 'status': ?2}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`amount &gt; ?1 and firstname != ?2` will be mapped to `{'amount': {'$gt': ?1}, 'firstname': {'$ne': ?2}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`amount &gt; ?1 and firstname != ?2` 将被映射到 `{'amount': {'$gt': ?1}, 'firstname': {'$ne': ?2}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`lastname like ?1` will be mapped to `{'lastname': {'$regex': ?1}}`. Be careful that this will be link:https://docs.mongodb.com/manual/reference/operator/query/regex/#op._S_regex[MongoDB regex] support and not SQL like pattern.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`lastname like ?1` 将被映射到 `{'lastname': {'$regex': ?1}}` 。注意 link:https://docs.mongodb.com/manual/reference/operator/query/regex/#op._S_regex[MongoDB的regex] 支持，而不是类似SQL模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`lastname is not null` will be mapped to `{'lastname':{'$exists': true}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`lastname is not null` 将被映射到 `{'lastname':{'$exists': true}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`status in ?1` will be mapped to `{'status':{$in: [?1]}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`status in ?1` 将被映射到 `{'status':{$in: [?1]}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB queries must be valid JSON documents, using the same field multiple times in a query is not allowed using PanacheQL as it would generate an invalid JSON (see link:https://github.com/quarkusio/quarkus/issues/12086[this issue on github]).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB查询必须是有效的JSON文档，不允许使用 PanacheQL 在查询中多次使用同一字段，因为它将生成无效的JSON（见 link:https://github.com/quarkusio/quarkus/issues/12086[这个问题在github上] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also handle some basic date type transformations: all fields of type `Date`, `LocalDate`, `LocalDateTime` or `Instant` will be mapped to the link:https://docs.mongodb.com/manual/reference/bson-types/#date[BSON Date] using the `ISODate` type (UTC datetime).  The MongoDB POJO codec doesn't support `ZonedDateTime` and `OffsetDateTime` so you should convert them prior usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还处理一些基本的日期类型转换：所有类型为 `Date` , `LocalDate` , `LocalDateTime` 或 `Instant` 的字段都将使用 `ISODate` 类型（UTC日期时间）映射到 link:https://docs.mongodb.com/manual/reference/bson-types/#date[BSON Date] 。MongoDB的POJO编解码器不支持 `ZonedDateTime` 和 `OffsetDateTime` ，因此你应该在使用前转换它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache offers operations to update multiple documents based on an update document and a query : `Person.update("foo = ?1, bar = ?2", fooName, barName).where("name = ?1", name)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB提供了基于一个更新文档和一个查询的操作来更新多个文档： `Person.update("foo = ?1, bar = ?2", fooName, barName).where("name = ?1", name)` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For these operations, you can express the update document the same way you express your queries, here are some examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于这些操作，你可以用表达查询的同样方式来表达更新文件，这里有一些例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;singlePropertyName&gt;` (and single parameter) which will expand to the update document `{'$set' : {'singleColumnName': '?1'}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;singlePropertyName&gt;` (和单一参数），这将扩展到更新文档 `{'$set' : {'singleColumnName': '?1'}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`firstname = ?1, status = ?2` will be mapped to the update document `{'$set' : {'firstname': ?1, 'status': ?2}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`firstname = ?1, status = ?2` 将被映射到更新文档中 `{'$set' : {'firstname': ?1, 'status': ?2}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`firstname = :firstname, status = :status` will be mapped to the update document `{'$set' : {'firstname': :firstname, 'status': :status}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`firstname = :firstname, status = :status` 将被映射到更新文档中 `{'$set' : {'firstname': :firstname, 'status': :status}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{'firstname' : ?1, 'status' : ?2}` will be mapped to the update document `{'$set' : {'firstname': ?1, 'status': ?2}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{'firstname' : ?1, 'status' : ?2}` 将被映射到更新文档中 `{'$set' : {'firstname': ?1, 'status': ?2}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{'firstname' : firstname, 'status' : :status}` ` will be mapped to the update document `{'$set' : {'firstname': :firstname, 'status': :status}}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{'firstname' : firstname, 'status' : :status}` `将被映射到更新文档中。 `{'$set' : {'firstname': :firstname, 'status': :status}}` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query parameters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询参数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can pass query parameters, for both native and PanacheQL queries, by index (1-based) as shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于原生和PanacheQL查询，你可以通过索引（基于1）传递查询参数，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or by name using a `Map`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者使用 `Map` ，按名字来命名：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or using the convenience class `Parameters` either as is or to build a `Map`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者使用方便的类 `Parameters` ，既可以是原样，也可以是建立一个 `Map` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every query operation accepts passing parameters by index (`Object...`), or by name (`Map&lt;String,Object&gt;` or `Parameters`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每个查询操作都接受按索引（ `Object...` ）或按名称（ `Map&lt;String,Object&gt;` 或 `Parameters` ）传递参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use query parameters, be careful that PanacheQL queries will refer to the Object parameters name but native queries will refer to MongoDB field names.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你使用查询参数时，要注意PanacheQL查询将参考Object参数名称，但本地查询将参考MongoDB字段名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine the following entity:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>想象一下下面这个实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `findByNameWithPanacheQLQuery()` and `findByNameWithNativeQuery()` methods will return the same result but query written in PanacheQL will use the entity field name: `name`, and native query will use the MongoDB field name: `lastname`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`findByNameWithPanacheQLQuery()` 和 `findByNameWithNativeQuery()` 方法都将返回相同的结果，但用PanacheQL编写的查询将使用实体字段名： `name` ，而原生查询将使用MongoDB字段名： `lastname` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query projection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询映射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询映射可以使用 `find()` 方法返回的 `PanacheQuery` 对象上的 `project(Class)` 方法来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use it to restrict which fields will be returned by the database, the ID field will always be returned, but it's not mandatory to include it inside the projection class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用它来限制哪些字段将被数据库返回，ID字段将始终被返回，但并不强制要求在映射类中包含它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, you need to create a class (a POJO) that will only contain the projected fields.  This POJO needs to be annotated with `@ProjectionFor(Entity.class)` where `Entity` is the name of your entity class.  The field names, or getters, of the projection class will be used to restrict which properties will be loaded from the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为此，你需要创建一个只包含映射字段的类（一个POJO）。这个POJO需要被注释为 `@ProjectionFor(Entity.class)` ，其中 `Entity` 是你的实体类的名称。映射类的字段名称或 getter 将用于限制将从数据库加载的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Projection can be done for both PanacheQL and native queries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对PanacheQL和原生查询都可以进行映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@BsonProperty` is not needed to define custom column mappings, as the mappings from the entity class will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@BsonProperty` ，不需要定义自定义列映射，因为将使用来自实体类的映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can have your projection class extends from another class. In this case, the parent class also needs to have use `@ProjectionFor` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以让你的映射类从另一个类继承。在这种情况下，父类也需要有使用 `@ProjectionFor` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query debugging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询调试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As MongoDB with Panache allows writing simplified queries, it is sometimes handy to log the generated native queries for debugging purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于带有Panache的MongoDB允许编写简化的查询，有时为调试目的而记录生成的原生查询是很方便的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be achieved by setting to DEBUG the following log category inside your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这可以通过在你的 `application.properties` ，将以下日志类别设置为DEBUG来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The PojoCodecProvider: easy object to BSON document conversion.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PojoCodecProvider：简单的object（对象）到 BSON 文档的转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you encounter the `org.bson.codecs.configuration.CodecConfigurationException` exception, it means the codec is not able to automatically convert your object.  This codec obeys the Java Bean standard, so it will successfully convert a POJO using public fields or getters/setters.  You can use `@BsonIgnore` to make a field, or a getter/setter, ignored by the codec.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你遇到了 `org.bson.codecs.configuration.CodecConfigurationException` 异常，这意味着编解码器不能自动转换你的对象。这个编解码器遵守Java Bean的标准，所以它将成功地转换使用公共字段或getter/setters的POJO。你可以使用 `@BsonIgnore` ，使一个字段或一个getter/setter被编解码器所忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB offers ACID transactions since version 4.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB从4.0版本开始提供ACID事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use them with MongoDB with Panache you need to annotate the method that starts the transaction with the `@Transactional` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要将它们与带有 Panache 的 MongoDB 一起使用，你需要在相应的方法上使用 `@Transactional` 注解启动事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction support inside MongoDB with Panache is still experimental.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache的MongoDB内部的事务支持仍处于试验阶段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom IDs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IDs are often a touchy subject. In MongoDB, they are usually auto-generated by the database with an `ObjectId` type.  In MongoDB with Panache the ID are defined by a field named `id` of the `org.bson.types.ObjectId` type, but if you want to customize them, once again we have you covered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ID往往是一个敏感的话题。在MongoDB中，，它们通常由数据库以 `ObjectId` 类型自动生成。 在带有 Panache 的 MongoDB 中，ID是由一个名为 `org.bson.types.ObjectId` 类型的名为 `id` 的字段定义的，但如果你想自定义它们，我们再次为您提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify your own ID strategy by extending `PanacheMongoEntityBase` instead of `PanacheMongoEntity`. Then you just declare whatever ID you want as a public field by annotating it by `@BsonId`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过继承 `PanacheMongoEntityBase` ，而不是 `PanacheMongoEntity` ，来指定你自己的ID策略。然后你只要通过 `@BsonId` ，将你想要的任何ID声明为一个公共字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're using repositories, then you will want to extend `PanacheMongoRepositoryBase` instead of `PanacheMongoRepository` and specify your ID type as an extra type parameter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用存储库，那么你要继承 `PanacheMongoRepositoryBase` ，而不是 `PanacheMongoRepository` ，并指定你的ID类型作为一个额外的类型参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `ObjectId`, MongoDB will automatically provide a value for you, but if you use a custom field type, you need to provide the value by yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `ObjectId` ，MongoDB会自动为你提供一个值，但如果你使用一个自定义字段类型，你需要自己提供一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the standard `ObjectId` ID type, don't forget to retrieve your entity by creating a new `ObjectId` when the identifier comes from a path parameter. For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用标准的 `ObjectId` ID类型，当标识符来自路径参数时，不要忘记通过创建一个新的 `ObjectId` 来检索你的实体。例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with Kotlin Data classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kotlin Data classes工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin data classes are a very convenient way of defining data carrier classes, making them a great match to define an entity class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin data classes是定义数据载体类的一种非常方便的方式，非常适合定义实体类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But this type of class comes with some limitations: all fields needs to be initialized at construction time or be marked as nullable, and the generated constructor needs to have as parameters all the fields of the data class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是这种类型的类有一些限制：所有的字段都需要在构造时被初始化或者被标记为nullable（可空），而且生成的构造函数需要有数据类的所有字段作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache uses the link:{mongodb-doc-root-url}/bson/pojos[PojoCodecProvider], a MongoDB codec which mandates the presence of a parameterless constructor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB使用 link:{mongodb-doc-root-url}/bson/pojos[PojoCodecProvider] ，这是一个MongoDB编解码器，它强制要求存在一个无参数构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, if you want to use a data class as an entity class, you need a way to make Kotlin generate an empty constructor.  To do so, you need to provide default values for all the fields of your classes.  The following sentence from the Kotlin documentation explains it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，如果你想使用一个数据类作为实体类，你需要一种方法来使Kotlin生成一个空的构造函数。要做到这一点，你需要为你的类的所有字段提供默认值。下面这句话来自Kotlin文档的解释：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>__On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified (see Constructors).__</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>__在JVM上，如果生成的类需要有一个无参数的构造函数，就必须为所有属性指定默认值（见构造函数）。__</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for whatever reason, the aforementioned solution is deemed unacceptable, there are alternatives.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果由于某种原因，上述解决方案被认为是不可接受的，那么还有其他选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another option is to use the `@BsonCreator` annotation to tell the `PojoCodecProvider` to use the Kotlin data class default constructor, in this case all constructor parameters have to be annotated with `@BsonProperty`: see link:{mongodb-doc-root-url}/bson/pojos/#supporting-pojos-without-no-args-constructors[Supporting pojos without no args constructor].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一个选择是使用 `@BsonCreator` 注解来告诉 `PojoCodecProvider` 使用Kotlin数据类的默认构造函数，在这种情况下，所有的构造函数参数都必须用 `@BsonProperty` 注解：见 link:{mongodb-doc-root-url}/bson/pojos/#supporting-pojos-without-no-args-constructors[支持pojos无args构造函数] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will only work when the entity extends `PanacheMongoEntityBase` and not `PanacheMongoEntity`, as the ID field also needs to be included in the constructor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这只有在实体继承了 `PanacheMongoEntityBase` ，而不是 `PanacheMongoEntity` ，这样才会起作用，因为ID字段也需要被包含在构造函数中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of a `Person` class defined as a Kotlin data class would look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个定义为Kotlin数据类的 `Person` 类的例子是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we use `var` but note that `val` can also be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里我们使用 `var` ，但注意也可以使用 `val` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@BsonId` annotation is used instead of `@BsonProperty("_id")` for brevity's sake, but use of either is valid.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了简洁起见，使用了 `@BsonId` 注解，而不是 `@BsonProperty("_id")` ，但使用其中任何一种都是有效的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last option is to the use the link:https://kotlinlang.org/docs/reference/compiler-plugins.html#no-arg-compiler-plugin[no-arg] compiler plugin.  This plugin is configured with a list of annotations, and the end result is the generation of no-args constructor for each class annotated with them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一个选项是使用 link:https://kotlinlang.org/docs/reference/compiler-plugins.html#no-arg-compiler-plugin[无arg（参数）] 编译器插件。这个插件是用一个注释列表来配置的，最终的结果是为每个有注释的类生成无args（参数）构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For MongoDB with Panache, you could use the `@MongoEntity` annotation on your data class for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于带有Panache的MongoDB，你可以在你的数据类上使用 `@MongoEntity` 注解来实现这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Entities and Repositories</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式实体和存储库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache allows using reactive style implementation for both entities and repositories.  For this, you need to use the Reactive variants when defining your entities : `ReactivePanacheMongoEntity` or `ReactivePanacheMongoEntityBase`, and when defining your repositories: `ReactivePanacheMongoRepository` or `ReactivePanacheMongoRepositoryBase`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB允许对实体和存储库使用响应式实现。为此，你需要在定义实体时使用Reactive变形： `ReactivePanacheMongoEntity` 或 `ReactivePanacheMongoEntityBase` ，在定义存储库时使用： `ReactivePanacheMongoRepository` 或 `ReactivePanacheMongoRepositoryBase` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive API of the MongoDB with Panache uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache的MongoDB的反应式API使用Mutiny反应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive variant of the `Person` class will be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Person` 类的响应式变形将是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will have access to the same functionalities of the _imperative_ variant inside the reactive one: bson annotations, custom ID, PanacheQL, ...  But the methods on your entities or repositories will all return reactive types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 _imperative_ 变形中使用同样的功能：Bson注释、自定义ID、PanacheQL......但是你的实体或资源库上的方法将全部返回响应式类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the equivalent methods from the imperative example with the reactive variant:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参阅带有响应变形的命令式示例中的等效方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same query facility exists for the reactive types, but the `stream()` methods act differently: they return a `Multi` (which implement a reactive stream `Publisher`) instead of a `Stream`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应类型存在相同的查询工具，但 `stream()` 方法的作用不同：它们返回一个 `Multi` （实现了反应式流 `Publisher` ），而不是 `Stream` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transactions are not supported for Reactive Entities and Repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式实体和存储库不支持事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the active-record pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用active-record模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the active-record pattern you cannot use Mockito directly as it does not support mocking static methods, but you can use the `quarkus-panache-mock` module which allows you to use Mockito to mock all provided static methods, including your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用active-record模式，你不能直接使用Mockito，因为它不支持模拟静态方法，但你可以使用 `quarkus-panache-mock` 模块，它允许你使用Mockito来模拟所有提供的静态方法，包括你自己的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add this dependency to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将此依赖添加到你的 `pom.xml` 中 ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given this simple entity:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供这个简单的实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can write your mocking test like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以像这样写你的模拟测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to call your `verify` methods on `PanacheMock` rather than `Mockito`, otherwise you won't know what mock object to pass.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保在 `PanacheMock` 而不是 `Mockito` 上调用你的 `verify` 方法，否则你将不知道要传递什么模拟对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the repository pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用资源库模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the repository pattern you can use Mockito directly, using the `quarkus-junit5-mockito` module, which makes mocking beans much easier:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用存储库模式，你可以直接使用Mockito，使用 `quarkus-junit5-mockito` 模块，这使得模拟Bean变得更加容易：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And this repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>还有这个储存库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How and why we simplify MongoDB API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们如何以及为什么要简化MongoDB的API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it comes to writing MongoDB entities, there are a number of annoying things that users have grown used to reluctantly deal with, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写MongoDB实体时，用户已经习惯了不情愿地处理许多烦人的事情，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Duplicating ID logic: most entities need an ID, most people don't care how it's set, because it's not really relevant to your model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重复ID逻辑：大多数实体需要一个ID，大多数人并不关心它是如何设置的，因为它与你的模型并不真正相关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dumb getters and setters: since Java lacks support for properties in the language, we have to create fields, then generate getters and setters for those fields, even if they don't actually do anything more than read/write the fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>繁琐的 getters 和 setters：由于Java语言中缺乏对属性的支持，我们必须创建字段，然后为这些字段getters 和 setters，即使它们除了read/write字段外实际上没有做任何事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional EE patterns advise to split entity definition (the model) from the operations you can do on them (DAOs, Repositories), but really that requires an unnatural split between the state and its operations even though we would never do something like that for regular objects in the Object Oriented architecture, where state and methods are in the same class. Moreover, this requires two classes per entity, and requires injection of the DAO or Repository where you need to do entity operations, which breaks your edit flow and requires you to get out of the code you're writing to set up an injection point before coming back to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的EE模式建议将实体定义（模型）与你可以对其进行的操作（DAO、Repositories）分开，但实际上这需要在状态和其操作之间进行不自然的分割，尽管在面向对象的架构中，我们永远不会对普通对象做这样的事情，因为状态和方法是在同一个类中。此外，这需要每个实体有两个类，并且需要在你需要进行实体操作的地方注入DAO或Repository，这就破坏了你的编辑流程，需要你从正在编写的代码中跳出来，建立一个注入点，然后再回来使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB queries are super powerful, but overly verbose for common operations, requiring you to write queries even when you don't need all the parts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB的查询功能超级强大，但对于普通操作来说过于冗长，即使不需要所有的部分，也需要你编写查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB queries are JSON based, so you will need some String manipulation or using the `Document` type and it will need a lot of boilerplate code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB的查询是基于JSON的，所以你需要一些String操作或使用 `Document` 类型，它需要大量的模板代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Panache, we took an opinionated approach to tackle all these problems:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过Panache，我们采取了一种有主见的方法来解决所有这些问题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make your entities extend `PanacheMongoEntity`: it has an ID field that is auto-generated. If you require a custom ID strategy, you can extend `PanacheMongoEntityBase` instead and handle the ID yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让你的实体继承 `PanacheMongoEntity` ：它有一个自动生成的ID字段。如果你需要一个自定义的ID策略，你可以继承 `PanacheMongoEntityBase` ，而不是自己处理ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use public fields. Get rid of dumb getter and setters. Under the hood, we will generate all getters and setters that are missing, and rewrite every access to these fields to use the accessor methods. This way you can still write _useful_ accessors when you need them, which will be used even though your entity users still use field accesses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用公共字段。摆脱繁琐的getter和setters。在后台，我们将生成所有缺失的getter和setter，并重写对这些字段的每个访问，以使用访问器方法。这样，当你需要时，你仍然可以写出 _有用的_ 访问器，即使你的实体用户仍然使用字段访问，也会被使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the active record pattern: put all your entity logic in static methods in your entity class and don't create DAOs.  Your entity superclass comes with lots of super useful static methods, and you can add your own in your entity class.  Users can just start using your entity `Person` by typing `Person.` and getting completion for all the operations in a single place.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用活动记录模式：把你所有的实体逻辑放在实体类的静态方法中，不要创建DAO。你的实体超类带有很多超级有用的静态方法，你也可以在你的实体类中添加你自己的静态方法。用户可以通过输入 `Person.` ，开始使用你的实体 `Person` ，并在一个地方获得所有操作的完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't write parts of the query that you don't need: write `Person.find("order by name")` or `Person.find("name = ?1 and status = ?2", "Loïc", Status.Alive)` or even better `Person.find("name", "Loïc")`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不要写你不需要的查询部分：写 `Person.find("order by name")` 或 `Person.find("name = ?1 and status = ?2", "Loïc", Status.Alive)` ，甚至更好的 `Person.find("name", "Loïc")` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all there is to it: with Panache, MongoDB has never looked so trim and neat.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这就是它的全部内容：有了Panache，MongoDB看起来从未如此简洁</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining entities in external projects or jars</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在外部项目或jar中定义实体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache relies on compile-time bytecode enhancements to your entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB依赖于对你的实体进行编译时的字节码增强。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It attempts to identity archives with Panache entities (and consumers of Panache entities)  by the presence of the marker file `META-INF/panache-archive.marker`. Panache includes an annotation processor that will automatically create this file in archives that depend on Panache (even indirectly). If you have disabled annotation processors you may need to create this file manually in some cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它试图通过标记文件 `META-INFpanache-archive.marker` 的存在来识别具有 Panache 实体（和 Panache 实体的消费者）的档案。 Panache 包含一个注释处理器，它将自动在依赖于 Panache（甚至间接）的档案中创建此文件。如果您禁用了注释处理器，在某些情况下您可能需要手动创建此文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This technology is considered {extension-status}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这项技术被认为是{extension-status}。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _experimental_ mode, early feedback is requested to mature the idea.  There is no guarantee of stability nor long term presence in the platform until the solution matures.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _experimental(实验)_ 模式下，要求早期反馈以使想法成熟。在解决方案成熟之前，不保证稳定性或长期存在于平台中。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题列表] 中提出问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being _stable_, backward compatibility and presence in the ecosystem are taken very seriously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_stable(稳定)_ 版本，确保向后兼容和生态系统的持续性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterForReflection` annotation instructs Quarkus to keep the class and its members during the native compilation. More details about the `@RegisterForReflection` annotation can be found on the xref:writing-native-applications-tips.adoc#registerForReflection[native application tips] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterForReflection` 注解用于指导Quarkus在native编译过程中保留该类和其成员。关于 `@RegisterForReflection` 注解的更多细节可以在 link:writing-native-applications-tips.html#registerForReflection[native应用程序提示] 页面找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java System Properties - `aws.accessKeyId` and `aws.secretAccessKey`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 系统属性 - `aws.accessKeyId` 和 `aws.secretAccessKey` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>环境变量 - `AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有 AWS 开发工具包和 AWS CLI 共享的默认位置 （ `~.awscredentials` ）的凭证配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials delivered through the Amazon ECS if the `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the security manager has permission to access the variable,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置了 `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` 环境变量并且安全管理员有权访问该变量，则通过 Amazon ECS 传递的凭证，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instance profile credentials delivered through the Amazon EC2 metadata service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过 Amazon EC2 元数据服务交付的实例配置文件凭证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.  It makes complex mappings possible, but it does not make simple and common mappings trivial.  Hibernate ORM with Panache focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM是事实上的JPA实现，提供了全方位的对象关系映射（Object Relational Mapper，简称ORM）支持。它支持编写复杂的映射，但编写简单常用的映射却不够简便。Panache专注于简化Hibernate ORM实体，让你的Quarkus开发有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have noticed how much more compact and readable the code is? Does this look interesting? Read on!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你有注意到代码的紧凑性和可读性大大提高了吗？看起来很有趣吧？请继续阅读!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `list()` method might be surprising at first. It takes fragments of HQL (JP-QL) queries and contextualizes the rest. That makes for very concise but yet readable code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `list()` 方法一开始可能会让人吃惊。它只需要接收HQL（JP-QL）查询语句的片段，并对查询语句其余部分进行上下文推断处理。这使得代码非常简明，但也不失可读性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>what was described above is essentially the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.  Hibernate with Panache also allows for the use of the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheRepository`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面所描述的编码模式本质上是 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[Active Record模式] ，有时也称为实体模式。Panache也支持通过 `PanacheRepository` 使用更经典的 link:https://martinfowler.com/eaaCatalog/repository.html[Repository模式] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `hibernate-orm-panache-quickstart` {quickstarts-tree-url}/hibernate-orm-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `hibernate-orm-panache-quickstart` {quickstarts-tree-url}/hibernate-orm-panache-quickstart[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up and configuring Hibernate ORM with Panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Hibernate ORM中配置Panache </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>make your entities extend `PanacheEntity` (optional if you are using the repository pattern)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实体类改为继承 `PanacheEntity` 类（使用Repository模式时为可选操作）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC驱动扩展 (如 `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a Panache entity, simply extend `PanacheEntity`, annotate it with `@Entity` and add your columns as public fields:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要定义一个Panache实体类，只需继承 `PanacheEntity` ，增加 `@Entity` 注解，并将数据库列作为公共字段添加到实体类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put all your JPA column annotations on the public fields. If you need a field to not be persisted, use the `@Transient` annotation on it. If you need to write accessors, you can:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些公共字段可以添加任何JPA列注解。如果你不想持久化某个字段，给它增加 `@Transient` 注解即可。如果你需要编写访问器，可以：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `stream` methods require a transaction to work. + As they perform I/O operations, they should be closed via the `close()` method or via a try-with-resource to close the underlying `ResultSet`.  If not, you will see warnings from Agroal that will close the underlying `ResultSet` for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`stream` 方法的运行需要事务。+ 由于这些stream开头的方法会执行I/O操作，所以应该通过 `close()` 方法或try-with-resource来关闭底层的 `ResultSet` 。否则你会看到来自Agroal的警告，它会为你关闭底层的 `ResultSet` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the repository pattern, you can define your entities as regular JPA entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Repository模式时，可以将实体类定义为普通的JPA实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to bother defining getters/setters for your entities, you can make them extend `PanacheEntityBase` and Quarkus will generate them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不想自己定义实体的getter和setter方法，可以让实体类继承 `PanacheEntityBase` ，Quarkus将自动生成getter和setter方法。你也可以继承 `PanacheEntity` ，相比 `PanacheEntityBase` ，其优势是它还提供默认的ID字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository, by making them implements `PanacheRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Repository 模式时，通过实现 `PanacheRepository` 接口，你可以使用与Active Record模式下完全相同的便捷方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the operations that are defined on `PanacheEntityBase` are available on your repository, so using it is exactly the same as using the active record pattern, except you need to inject it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PanacheEntityBase` 中定义的所有方法都可以在你的Repository类上使用，所以它使用起来与Active Record模式完全一样，只是你需要注入Repository类的实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `stream` methods require a transaction to work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`stream` 方法的运行需要事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful to use the `@Transactional` annotation on the operations that modify the database, you can add the annotation at the class level for simplicity purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在修改数据库的操作上需要使用 `@Transactional` 注解，为了简单起见，你可以给类添加这个注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should only use `list` and `stream` methods if your table contains small enough data sets. For larger data sets you can use the `find` method equivalents, which return a `PanacheQuery` on which you can do paging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的表数据量很小，你应该只用到 `list` 和 `stream` 方法。对于较大的数据集，你可以使用对应的 `find` 方法，它返回一个 `PanacheQuery` ，可以对其进行分页查询操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All methods accepting a query string also accept the following simplified query form:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有接收查询字符串的方法也能接收以下简化形式的查询：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But these methods also accept an optional `Sort` parameter, which allows your to abstract your sorting:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些方法也可以接收一个 `Sort` 参数，它是对排序的抽象封装：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally, HQL queries are of this form: `from EntityName [where ...] [order by ...]`, with optional elements at the end.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常情况下，HQL查询语句是这种形式： `from EntityName [where ...​] [order by ...​]` ，结尾处有可选元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your select query does not start with `from`, we support the following additional forms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的查询语句不是以 `from` 开始，我们还支持以下的形式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`order by ...` which will expand to `from EntityName order by ...`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`order by ...` 语句会被扩展为： `from EntityName order by ...` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;singleColumnName&gt;` (and single parameter) which will expand to `from EntityName where &lt;singleColumnName&gt; = ?`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;singleColumnName&gt;` (带单个参数）语句会被扩展为： `from EntityName where &lt;singleColumnName&gt; = ?` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;query&gt;` will expand to `from EntityName where &lt;query&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;query&gt;` 语句会被扩展为： `from EntityName where &lt;query&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your update query does not start with `update`, we support the following additional forms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的更新语句不是以 `update` 开始，我们还支持以下的形式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`from EntityName ...` which will expand to `update from EntityName ...`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`from EntityName ...​` 语句会被扩展为： `update from EntityName ...​` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`set? &lt;singleColumnName&gt;` (and single parameter) which will expand to `update from EntityName set &lt;singleColumnName&gt; = ?`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`set? &lt;singleColumnName&gt;` (带单个参数）语句会被扩展为： `update from EntityName set &lt;singleColumnName&gt; = ?` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`set? &lt;update-query&gt;` will expand to `update from EntityName set &lt;update-query&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`set? &lt;update-query&gt;` 语句会被扩展为： `update from EntityName set &lt;update-query&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your delete query does not start with `delete`, we support the following additional forms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的删除语句不是以 `delete` 开始，我们还支持以下的形式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`from EntityName ...` which will expand to `delete from EntityName ...`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`from EntityName ...​` 语句会被扩展为： `delete from EntityName ...​` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;singleColumnName&gt;` (and single parameter) which will expand to `delete from EntityName where &lt;singleColumnName&gt; = ?`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `&lt;singleColumnName&gt;` (带单个参数）语句会被扩展为： `delete from EntityName where &lt;singleColumnName&gt; = ?` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&lt;query&gt;` will expand to `delete from EntityName where &lt;query&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;query&gt;` 语句会被扩展为： `delete from EntityName where &lt;query&gt;` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also write your queries in plain link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以用普通的 link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql[HQL] 编写查询语句：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named queries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命名查询</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named queries can only be defined inside your JPA entity classes (being the Panache entity class, or the repository parameterized type), or on one of its super classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命名查询只能在JPA实体类（必须是Panache实体类，或Repository类的参数化类型）内定义，或在它的父类中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can pass query parameters by index (1-based) as shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过索引（从1开始）传递查询参数，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use it to restrict which fields will be returned by the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用投影限制数据库返回哪些字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.  This is also called **dynamic instantiation** or **constructor expression**, more info can be found on the Hibernate guide: link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate会使用 *DTO投影* ，并根据投影的类的属性生成SELECT子句。这也被称为 *动态实例化* 或 *构造器表达* ，更多信息可以在Hibernate指南中找到： link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[HQL select子句]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to instantiate the projection DTO instead of using the entity class. This class must have a matching constructor with all the class attributes as parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>投影类必须是有效的Java Bean，并且拥有一个包含所有属性的构造方法，这个构造函数用于实例化投影DTO，而不是使用实体类。投影类必须有一个包含所有的类属性作为参数的构造方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use public fields here, but you can use private fields and getters/setters if you prefer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里我们使用public的字段，你也可以使用private字段和对应的getter/setter方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This constructor will be used by Hibernate, it must be the only constructor in your class and have all the class attributes as parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate会用到这个构造方法，它必须是类中唯一的构造函数，并且包含所有类属性作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If in the DTO projection object you have a field from a referenced entity, you can use the `@ProjectedFieldName` annotation to provide the path for the SELECT statement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果DTO投影对象中有来自引用的实体字段，可以使用 `@ProjectedFieldName` 注解指定SELECT语句使用的查询路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `ownerName` DTO constructor's parameter will be loaded from the `owner.name` HQL property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DTO构造器的 `ownerName` 参数将从 `owner.name` HQL属性加载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Persistence Units</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个持久化单元</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Panache, things are simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Panache时，事情很简单：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A given Panache entity can be attached to only a single persistence unit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个Panache实体类只能配置到一个持久化单元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given that, Panache already provides the necessary plumbing to transparently find the appropriate `EntityManager` associated to a Panache entity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>鉴于此，Panache已经提供了必要的管道， 可以透明地找到Panache实体类对应的 `EntityManager` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to wrap methods modifying your database (e.g. `entity.persist()`) within a transaction. Marking a CDI bean method `@Transactional` will do that for you and make that method a transaction boundary. We recommend doing so at your application entry point boundaries like your REST endpoint controllers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保修改数据库的方法（例如： `entity.persist()` ）处于同一个事务中。给一个CDI bean方法增加 `@Transactional` 注解，可以确保该方法即事务边界。我们建议在应用端点的边界这样做，比如REST端点的Controller。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JPA batches changes you make to your entities and sends changes (it's called flush) at the end of the transaction or before a query.  This is usually a good thing as it's more efficient.  But if you want to check optimistic locking failures, do object validation right away or generally want to get immediate feedback, you can force the flush operation by calling `entity.flush()` or even use `entity.persistAndFlush()` to make it a single method call. This will allow you to catch any `PersistenceException` that could occur when JPA send those changes to the database.  Remember, this is less efficient so don't abuse it.  And your transaction still has to be committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JPA将实体的变更进行批量处理，并在事务结束时或查询前发送批量变更（这被称为flush）。这通常更有效率。但是当你想检查乐观锁的失败，即时进行对象验证，或者想得到即时的反馈，你可以通过调用 `entity.flush()` 或 `entity.persistAndFlush()` 强制执行flush。JPA向数据库发送这些变更时可能会抛出 `PersistenceException` ，你可以捕捉这些异常。记住，这样做的效率较低，所以不要滥用它。而且你的事务仍然需要提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of the usage of the flush method to allow making a specific action in case of `PersistenceException`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是一个使用 flush 方法的例子，它在捕获到 `PersistenceException` 异常时执行指定操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lock management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>锁管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Panache provides direct support for database locking with your entity/repository, using `findById(Object, LockModeType)` or `find().withLock(LockModeType)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache支持在实体类/Repository类中直接使用数据库的锁，可使用 `findById(Object, LockModeType)` 或 `find().withLock(LockModeType)` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following examples are for the active record pattern, but the same can be used with repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子是针对Active Record模式的，但同样可以应用于Repository模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First: Locking using findById().</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一：通过findById()方法使用数据库锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second: Locking in a find().</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第二：通过find()方法使用数据库锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful that locks are released when the transaction ends, so the method that invokes the lock query must be annotated with the `@Transactional` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，事务结束时锁会被释放，所以调用了带锁查询的方法必须加上 `@Transactional` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IDs are often a touchy subject, and not everyone's up for letting them handled by the framework, once again we have you covered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ID往往是一个敏感的话题，并不是所有人都愿意让框架来处理，因此我们提供了相应的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify your own ID strategy by extending `PanacheEntityBase` instead of `PanacheEntity`. Then you just declare whatever ID you want as a public field:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过继承 `PanacheEntityBase` ，而非 `PanacheEntity` ，来指定你自己的ID策略。然后只要把你想要的ID字段声明为public字段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're using repositories, then you will want to extend `PanacheRepositoryBase` instead of `PanacheRepository` and specify your ID type as an extra type parameter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Repository模式，那么要继承 `PanacheRepositoryBase` ，而非 `PanacheRepository` ，并将ID字段类型作为额外的类型参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the active record pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Active Record模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the active record pattern you cannot use Mockito directly as it does not support mocking static methods, but you can use the `quarkus-panache-mock` module which allows you to use Mockito to mock all provided static methods, including your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用了Active Record模式，那么不能直接使用Mockito，因为它不支持Mock静态方法。你可以使用 `quarkus-panache-mock` 模块，它允许你使用Mockito来模拟所有静态方法，包括你自己编写的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to call your `verify` and `do*` methods on `PanacheMock` rather than `Mockito`, otherwise you won't know what mock object to pass.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请确保是在 `PanacheMock` 上调用 `verify` 和 `do*` 方法，而不是在 `Mockito` 上调用，否则无法传递mock对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mocking `EntityManager`, `Session` and entity instance methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>模拟 `EntityManager` , `Session` 及实体类的实例方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to mock entity instance methods, such as `persist()` you can do it by mocking the Hibernate ORM `Session` object:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要模拟实体类的实例方法，比如 `persist()` ，可以通过模拟Hibernate ORM的 `Session` 对象来实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How and why we simplify Hibernate ORM mappings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们为什么简化Hibernate ORM映射？怎么做到的？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it comes to writing Hibernate ORM entities, there are a number of annoying things that users have grown used to reluctantly deal with, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写Hibernate ORM实体类时，用户已经习惯了被迫处理许多烦人的事情，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate queries are super powerful, but overly verbose for common operations, requiring you to write queries even when you don't need all the parts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate查询功能很强大，但对于普通操作来说过于冗长，即使是简单操作也要求写完整的HQL语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate is very general-purpose, but does not make it trivial to do trivial operations that make up 90% of our model usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate很通用，但对于模型里90%的琐碎操作，编写起来并不简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make your entities extend `PanacheEntity`: it has an ID field that is auto-generated. If you require a custom ID strategy, you can extend `PanacheEntityBase` instead and handle the ID yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让你的实体类继承 `PanacheEntity` ：它有一个自动生成的ID字段。如果你需要自定义ID策略，可以继承 `PanacheEntityBase` ，而不用自己处理ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't write parts of the query that you don't need: write `Person.find("order by name")` or `Person.find("name = ?1 and status = ?2", "stef", Status.Alive)` or even better `Person.find("name", "stef")`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不要写多余的查询语句：可以写 `Person.find("order by name")` 或 `Person.find("name = ?1 and status = ?2", "stef", Status.Alive)` ，甚至更好的 `Person.find("name", "stef")` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all there is to it: with Panache, Hibernate ORM has never looked so trim and neat.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上就是它的全部内容：有了Panache，Hibernate ORM看起来变得如此轻量和整洁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM with Panache relies on compile-time bytecode enhancements to your entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM Panache依赖于编译时对实体类的字节码增强。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It attempts to identify archives with Panache entities (and consumers of Panache entities)  by the presence of the marker file `META-INF/panache-archive.marker`. Panache includes an annotation processor that will automatically create this file in archives that depend on Panache (even indirectly). If you have disabled annotation processors you may need to create this file manually in some cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache通过判断是否存在标记文件 `META-INF/panache-archive.marker` 来识别jar包是否包含 Panache 实体类（及 Panache 实体类的调用方）。Panache 包含一个注解处理器，它会自动在依赖 Panache（包括间接依赖Panache）的jar包中创建此文件。如果在某些情况下你禁用了注解处理器，可能需要手动创建此文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you include the jpa-modelgen annotation processor this will exclude the Panache annotation processor by default. If you do this you should either create the marker file yourself, or add the `quarkus-panache-common` as well, as shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的项目包含 jpa-modelgen 注解处理器，则默认情况下会排除 Panache 注解处理器。这种情况下，你应该自己创建标记文件，或者添加 `quarkus-panache-common` 插件，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shared broker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>共享的broker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started With Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Reactive_ is a set of principles to build robust, efficient, and concurrent applications and systems.  These principles let you handle more load than traditional approaches while using the resources (CPU and memory) more efficiently while also reacting to failures gracefully.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_Reactive_ 是一组用于构建健壮、高效且并发的应用程序和系统的原则。 这些原则使您可以处理比传统方法更多的负载，同时更有效地使用资源（CPU 和内存），同时还可以优雅地对故障做出反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is a _Reactive_ framework.  Since the beginning, _Reactive_ has been an essential tenet of the Quarkus architecture.  It includes many reactive features and offers a broad ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是一个 _Reactive_ 框架。 从一开始，_Reactive_ 就一直是Quarkus架构的基本原则。 它包括许多反应式功能，并提供广泛的生态系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is not an in-depth article about what _Reactive_ is and how Quarkus enables reactive architectures.  If you want to read more about these topics, refer to the xref:quarkus-reactive-architecture.adoc[Reactive Architecture guide], which provides an overview of the Quarkus reactive ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南不是一篇关于 _Reactive_ 是什么以及Quarkus如何实现响应式架构的深入文章。 如果你想阅读更多关于这些主题的信息，请参考 xref:quarkus-reactive-architecture.adoc[响应式架构指南]，它提供了Quarkus响应式生态系统的概述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will get you started with some reactive features of Quarkus.  We are going to implement a simple CRUD application.  Yet, unlike in the xref:hibernate-orm-panache.adoc[Hibernate with Panache guide], it uses the reactive features of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将带您开始了解Quarkus的一些响应式功能。 我们将实现一个简单的 CRUD 应用程序。 这部分与 xref:hibernate-orm-panache.adoc[Hibernate与Panache指南]不同，它使用了Quarkus的响应式功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will help you with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将帮助您：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping a reactive CRUD application with Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Quarkus 引导响应式 CRUD 应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Hibernate Reactive with Panache to interact with a database in a reactive fashion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 Hibernate Reactive 与 Panache 结合使用，以响应式方式与数据库进行交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RESTEasy Reactive to implement HTTP API while enforcing the reactive principle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RESTEasy Reactive 实现 HTTP API，同时强制执行响应式原则</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and Running the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包和运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java 11+ installed with `JAVA_HOME` configured appropriately.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 11+安装并适当配置了 `JAVA_HOME` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Verify that Maven is using the Java version you expect.  If you have multiple JDKs installed, make sure Maven is using the expected one.  You can verify which JDK Maven uses by running `mvn --version.`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>验证Maven正在使用您期望的Java版本。如果安装了多个JDK，请确保Maven使用的是适当的版本。你可以通过运行 `mvn --version` 来验证Maven使用的是哪个JDK</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative vs. Reactive: a question of threads</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式与响应式：线程的问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, in this guide, we are going to implement a reactive CRUD application.  But you may wonder what the differences and benefits are in comparison to the traditional and imperative model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，在本指南中，我们将实现一个响应式CRUD应用程序。但您可能想知道，与传统的、指令式的模式相比，它有什么不同和好处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand the contrast, we need to explain the difference between the reactive and imperative execution models.  It's essential to comprehend that _Reactive_ is not just a different execution model, but that distinction is necessary to understand this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了更好地理解这种对比，我们需要解释响应式执行模型和指令式执行模型之间的区别。理解 _Reactive_ 不仅仅是一种不同的执行模型是必要的，而且这一区别对于理解本指南是必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the traditional and imperative approach, frameworks assign a thread to handle the request.  So, the whole processing of the request runs on this worker thread.  This model does not scale very well.  Indeed, to handle multiple concurrent requests, you need multiple threads; and so your application concurrency is constrained by the number of threads.  In addition, these threads are blocked as soon as your code interacts with remote services.  So, it leads to inefficient usage of the resources, as you may need more threads, and each thread, as they are mapped to OS threads, has a cost in terms of memory and CPU.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在传统的指令式方法中，框架分配一个线程来处理请求。因此，请求的整个处理都运行在这个工作线程上。这个模型的扩展性不太好。事实上，要处理多个并发请求，你需要多个线程。因此，应用程序的并发性受到线程数量的限制。此外，只要您的代码与远程服务交互，这些线程就会被阻塞。因此，这会导致资源的低效使用，因为您可能需要更多的线程，而每个线程在映射到OS线程时，在内存和CPU方面都有成本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the other side, the reactive model relies on non-blocking I/Os and a different execution model.  Non-blocking I/O provides an efficient way to deal with concurrent I/O.  A minimal amount of threads called I/O threads, can handle many concurrent I/O.  With such a model, request processing is not delegated to a worker thread but uses these I/O threads directly.It saves memory and CPU as there is no need to create worker threads to handle the requests.  It also improves the concurrency as it removes the constraint on the number of threads.  Finally, it also improves response time as it reduces the number of thread switches.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一方面，响应式模型依赖于非阻塞 I/O和不同的执行模型。非阻塞I/O提供了一种处理并发I/O的有效方法。最小数量的线程称为I/O线程，可以处理许多并发I/O。使用这样的模型，请求处理不会委托给工作线程，而是直接使用这些I/O线程。它节省了内存和CPU，因为不需要创建工作线程来处理请求。它还改善了并发性，因为它消除了对线程数量的限制。最后，它还改善了响应时间，因为它减少了线程开关的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From sequential to continuation style</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从顺序到延续风格</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, with the reactive execution model, the requests are processed using I/O threads.  But that's not all.  An I/O thread can handle multiple concurrent requests.  How? Here is the trick and one of the most significant differences between reactive and imperative.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，使用响应式执行模型，请求是使用I/O线程处理的。但这还不是全部。一个I/O线程可以处理多个并发请求。如何实现？这是一个技巧，也是响应式和指令式之间最重要的区别之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When processing a request requires interacting with a remote service, like an HTTP API or a database, it does not block the execution while waiting for the response.  Instead, it schedules the I/O operation and attaches a continuation, i.e., the request processing remaining code.  This continuation can be passed as a callback (a function invoked with the I/O outcome), or use more advanced constructs such as reactive programming or co-routines.  Regardless of how the continuation is expressed, the essential aspect is the release of the I/O thread and, as a consequence, the fact that this thread can be used to process another request.  When the scheduled I/O completes, the I/O thread executes the continuation, and the processing of the pending request continues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当处理请求需要与远程服务(如HTTP API或数据库)交互时，它不会在等待响应时阻塞执行。相反，它调度I/O操作并附加一个延续，即请求处理剩余的代码。这种延续可以作为回调传递 (与I/O结果一起调用的函数)，或者使用更高级的结构，诸如响应式编程或协同程序。不管延续是如何表示的，最基本的方面是释放I/O线程，因此，这个线程可以用来处理另一个请求。当计划的I/O完成时，I/O线程执行延续，并继续处理挂起的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, unlike the imperative model, where I/O blocks the execution, reactive switches to a continuation-based design, where the I/O threads are released, and continuation invoked when the I/Os complete.  As a result, the I/O thread can handle multiple concurrent requests, improving the overall concurrency of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，与I/O阻塞执行的指令式模型不同，响应式切换到基于延续的设计，其中I/O线程被释放，而延续在I/O完成时被调用。因此，I/O线程可以处理多个并发请求，从而提高应用程序的整体并发性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, there is a catch.  We need a way to write continuation-passing code.  There are many ways of doing this.  In Quarkus, we propose:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，有一个问题。我们需要一种方法来编写延续传递代码。有很多方法可以做到这一点。在Quarkus，我们提出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will use Mutiny.  To know more about Mutiny, check the xref:mutiny-primer.adoc[Mutiny documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将使用Mutiny。想要了解更多关于Mutiny的信息，请查看 xref:mutiny-primer.adoc[Mutiny文档]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Loom is coming to the JDK soon and proposes a virtual thread-based model.  The Quarkus architecture is ready to support Loom as soon as it's become globally available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Loom项目很快就会加入到JDK中，它提出了一个基于虚拟线程的模型。一旦在全局范围内可用，Quarkus架构就可以支持Loom。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the Reactive Fruits application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动响应式水果应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this in mind, let's see how we can develop a CRUD application with Quarkus, which will use the I/O thread to handle the HTTP requests, interact with a database, process the result, and write the HTTP response; in other words: a reactive CRUD application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>考虑到这一点，让我们看看如何使用Quarkus开发一个CRUD应用程序，它将使用I/O线程处理HTTP请求，与数据库交互，处理结果，并编写HTTP响应，换句话说：一个响应式CRUD应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While we recommend you to follow the step-by-step instructions, you can find the final solution on https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-reactive-panache-quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们建议您按照步骤操作，但您可以在 https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-reactive-panache-quickstart上找到最终的解决方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, go to https://code.quarkus.io[code.quarkus.io] and select the following extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，访问 https://code.quarkus.io[code.quarkus.io] 并选择以下扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last extension is the reactive database driver for PostgreSQL.  Hibernate Reactive uses that driver to interact with the database without blocking the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一个扩展是PostgreSQL的响应式数据库驱动程序。Hibernate响应式使用该驱动程序与数据库交互，而不会阻塞调用线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once selected, click on "Generate your application", download the zip file, unzip it and open the code in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选中后，单击 "Generate your application"，下载压缩文件，解压缩并在您喜欢的IDE中打开代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Panache Entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式Panache实体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the `Fruit` entity.Create the `src/main/java/org/acme/hibernate/orm/panache/Fruit.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从 `Fruit` 实体开始。创建 `src/main/java/org/acme/hibernate/orm/panache/Fruit.java` 文件，内容如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you import the reactive variant of `PanacheEntity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>确保你导入了 `PanacheEntity` 的响应式类库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class represents `Fruits`.  It's a straightforward entity with a single field (`name`).  Note that it uses `io.quarkus.hibernate.reactive.panache.PanacheEntity`, the reactive variant of `PanacheEntity`.  So, behind the scenes, Hibernate uses the execution model we described above.  It interacts with the database without blocking the thread.  In addition, this reactive `PanacheEntity` proposes a reactive API.  We will use this API to implement the REST endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个类代表 `Fruits`。它是一个简单的实体，只有一个字段 (`name`)。注意，它使用的是 `io.quarkus.hibernate.reactive.panache.PanacheEntity`，是 `PanacheEntity` 的响应式类库。因此，Hibernate在幕后使用我们前面描述的执行模型。它与数据库交互而不阻塞线程。此外，这个响应式的 `PanacheEntity` 提出了一个响应式API。我们将使用这个API来实现REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, open the `src/main/resource/application.properties` file and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在继续之前，打开 `src/main/resource/application.properties` 文件并添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It instructs the application to use PostgreSQL for the database and to handle the database schema generation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它指示应用程序对数据库使用PostgreSQL，并处理数据库模式的生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the same directory, create an `import.sql` file, which inserts a few fruits, so we don't start with an empty database in dev mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在同一个目录中，创建一个 `import.sql` 文件，它插入了一些水果数据，所以我们不会在dev模式中面对一个空数据库开始：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a terminal, launch the application in dev mode using: `./mvnw quarkus:dev`.  Quarkus automatically starts a database instance for you and configure the application. Now we only need to implement the HTTP endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在终端中，使用：`./mvnw quarkus:dev`。Quarkus会自动为您启动一个数据库实例并配置应用程序。现在我们只需要实现HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because the interaction with the database is non-blocking and asynchronous, we need to use asynchronous constructs to implement our HTTP resource.  Quarkus uses Mutiny as its central reactive programming model.  So, it supports returning Mutiny types (`Uni` and `Multi`) from HTTP endpoints.  Also, our Fruit Panache entity exposes methods using these types, so we only need to implement the _glue_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于与数据库的交互是非阻塞的和异步的，我们需要使用异步构造来实现我们的HTTP资源。Quarkus使用Mutiny作为其核心响应式编程模型。因此，它支持从HTTP端点返回Mutiny类型 (`Uni` and `Multi`) 。此外，水果Panache实例使用这些类型公开方法，因此我们只需要实现 _glue_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/hibernate/orm/panache/FruitResource.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/hibernate/orm/panache/FruitResource.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the `getAll` method. The `getAll` method returns all the fruits stored in the database.  In the `FruitResource`, add the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们从 `getAll` 方法开始。 `getAll` 方法返回存储在数据库中的所有水果对象。在 `FruitResource` 中，添加以下代码：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open http://localhost:8080/fruits to invoke this method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开 http://localhost:8080/fruits 调用这个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We get the expected JSON array.  RESTEasy Reactive automatically maps the list into a JSON Array, except if instructed otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们得到了预期的JSON数组。RESTEasy Reactive自动将列表映射到JSON数组，除非另有指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look at the return type; it returns a `Uni` of `List&lt;Fruit&gt;`.  `Uni` is an asynchronous type.  It's a bit like a future.  It's a placeholder that will get its value (item) later.  When it receives the item (Mutiny says it _emits_ its item), you can attach some behavior.  That's how we express the continuation: get a uni, and when the uni emits its item, execute the rest of the processing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>看看返回类型，它返回 `List&lt;Fruit&gt;` 的 `Uni` 。`Uni` 是一个异步类型。这有点像未来。它是一个占位符，稍后将获得它的值条目 (item) 。当它接收条目(Mutiny说它 _输出_ 的条目)时，你可以附加一些行为。这就是我们表示延续的方式：获取一个uni，当uni输出它的条目时，执行其余的处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive developers may wonder why we can't return a stream of fruits directly.  It tends to be a bad idea when dealing with a database.  Relational databases do not handle streaming well.  It’s a problem of protocols not designed for this use case.  So, to stream rows from the database, you need to keep a connection (and sometimes a transaction) open until all the rows are consumed.  If you have slow consumers, you break the golden rule of databases: don’t hold connections for too long.  Indeed, the number of connections is rather low, and having consumers keeping them for too long will dramatically reduce the concurrency of your application.  So, when possible, use a `Uni&lt;List&lt;T&gt;&gt;` and load the content.  If you have a large set of results, implement pagination.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式程序开发者可能会想为什么我们不能直接返回水果流。在处理数据库时，这往往不是一个好主意。关系数据库不能很好地处理流。这是协议不是为这个用例设计的问题。因此，要从数据库流输出行，您需要保持一个连接（有时是一个事务）打开，直到所有行都被消耗掉。如果您的用户很慢，那么您就违反了数据库的黄金法则：不要保持连接太长时间。实际上，可用连接的数量相当少，并且让使用者保持这些连接太长时间将极大地降低应用程序的并发性。所以，如果可能的话，使用 `Uni&lt;List&lt;T&gt;&gt;` 并加载内容。如果有大量结果，则实现分页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's continue our API with `getSingle`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们用 `getSingle` 继续我们的API：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, we use `Fruit.findById` to retrieve the fruit.  It returns a `Uni`, which will complete when the database has retrieved the row.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本例中，我们使用 `Fruit.findById` 来检索水果。当数据库检索到该行时，它将返回一个 `Uni`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `create` method allows adding a new fruit to the database:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`create` 方法允许向数据库中添加新水果记录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is a bit more involved.  To write to a database, we need a transaction.  So we use `Panache.withTransaction` to get one (asynchronously) and call the `persist` method when we receive the transaction.  The `persist` method is also returning a `Uni`.  This `Uni` emits the result of the insertion of the fruit in the database.  Once the insertion completes (and that's our continuation), we create a `201 CREATED` response.  RESTEasy Reactive automatically reads the request body as JSON and creates the `Fruit` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码稍微复杂一些。要写入数据库，我们需要一个事务。所以我们用 `Panache.withTransaction` 来获取一个（异步），并在接收到事务时调用 `persist` 方法。 `persist` 方法也返回一个 `Uni`。这个 `Uni` 发出水果插入数据库的结果。一旦插入完成（这就是我们的延续），我们创建一个 `201 CREATED` 响应。RESTEasy Reactive会自动将请求体读取为JSON并创建 `Fruit` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `.onItem().transform(...)` can be replaced with `.map(...)`.  `map` is a shortcut.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.onItem().transform(...)`  可以用 `.map(...)` 取代。`map` 是它的快捷方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have https://curl.se/[curl] on your machine, you can try the endpoint using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果在您的机器安装了 https://curl.se/[curl]命令，便可以尝试使用端点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the same ideas, you can implement the other CRUD methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>遵循相同的思路，您可以实现其他CRUD方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing and Running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试和运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a reactive application is similar to testing a non-reactive one: use the HTTP endpoint and verify the HTTP responses.  The fact that the application is reactive does not change anything.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试响应式应用程序与测试非响应式应用程序类似：使用HTTP端点并验证HTTP响应。应用程序是响应式的这一事实并没有改变任何事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In https://github.com/quarkusio/quarkus-quickstarts/blob/main/hibernate-reactive-panache-quickstart/src/test/java/org/acme/hibernate/orm/panache/FruitsEndpointTest.java[FruitsEndpointTest.java] you can see how the test for the fruit application can be implemented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 https://github.com/quarkusio/quarkus-quickstarts/blob/main/hibernate-reactive-panache-quickstart/src/test/java/org/acme/hibernate/orm/panache/FruitsEndpointTest.java[FruitsEndpointTest.java]中，您可以看到如何实现水果应用程序的测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run the application, don’t forget to start a database and provide the configuration to your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要运行应用程序，不要忘记启动数据库并为应用程序提供配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you can use Docker to run your database:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，你可以使用Docker来运行你的数据库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, launch the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，使用以下命令启动应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, if you packaged your application as native executable, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，如果你将你的应用打包为原生可执行文件，使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters passed to the application are described in the datasource guide.  There are other ways to configure the application - please check the link:config-reference#configuration_sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传递给应用程序的参数在数据源指南中进行了描述。还有其他配置应用程序的方法 - 请查看 link:config-reference#configuration_sources[配置指南]来概览各种可能性（例如env变量，.env文件等等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a brief introduction to some reactive features offered by Quarkus.  Quarkus is a reactive framework, and so offers a lot of reactive features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南简要介绍了Quarkus提供的一些响应式特性。Quarkus是一个响应式框架，因此提供了许多响应式特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to continue on this topic check:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想继续这个话题，请检查：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize https://opentelemetry.io/[OpenTelemetry] to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南解释了您的Quarkus应用程序如何利用 link:https://opentelemetry.io/[OpenTelemetry] 来为交互式Web应用提供分布式跟踪服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward REST application to demonstrate distributed tracing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们创建了一个简单的REST应用程序来演示分布式跟踪服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can skip right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地创建应用程序。不过，您可以直接跳到已完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `opentelemetry-quickstart` {quickstarts-tree-url}/opentelemetry-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `opentelemetry-quickstart` {quickstarts-tree-url}/opentelemetry-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `quarkus-opentelemetry-exporter-otlp` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已经配置了您的Quarkus项目，您可以通过在您的项目根目录下运行以下命令，将 `quarkus-opentelemetry-exporter-otlp` 扩展添加到您的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the JAX-RS resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检查JAX-RS资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that there is no tracing specific code included in the application. By default, requests sent to this endpoint will be traced without any required code changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，应用程序中没有包含任何关于追踪的代码。默认情况下，不需要修改任何必要的代码就可以实现对发送到这个节点的请求进行追踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to configure the OTLP gRPC Exporter within the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有两种方法可以在应用程序中配置OTLP gRPC exporter。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first approach is by providing the properties within the `src/main/resources/application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一种方法是通过在 `src/main/resources/application.properties` 文件内提供配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All spans created from the application will include an OpenTelemetry `Resource` indicating the span was created by the `myservice` application. If not set, it will default to the artifact id.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有从应用程序创建的spans将包含一个OpenTelemetry `Resource` ，表明该span是由 `myservice` 应用程序创建。如果没有设置，它将默认为artifact id。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether OpenTelemetry is enabled or not. The default is `true`, but shown here to indicate how it can be disabled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry是否已启用。默认是 `true` ，但放在这里是用来展示如何禁用它</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC endpoint for sending spans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于发送spans的gRPC节点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional gRPC headers commonly used for authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可选的gRPC消息头，通常用于认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to configure and start the https://opentelemetry.io/docs/collector/[OpenTelemetry Collector] to receive, process and export telemetry data to https://www.jaegertracing.io/[Jaeger] that will display the captured traces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第一步是配置和启动 link:https://opentelemetry.io/docs/collector/[OpenTelemetry Collector] ，以接收、处理和输出勘测数据到 link:https://www.jaegertracing.io/[Jaeger] 来显示捕获的traces。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the OpenTelemetry Collector by creating an `otel-collector-config.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过创建一个 `otel-collector-config.yaml` 文件来配置OpenTelemetry Collector：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. If using `application.properties` to configure the tracer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们准备运行我们的应用程序。如果使用 `application.properties` 来配置tracer：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if configuring the OTLP gRPC endpoint via JVM arguments:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者如果通过JVM参数配置OTLP gRPC节点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the OpenTelemetry Collector, Jaeger system and application running, you can make a request to the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在OpenTelemetry Collector、Jaeger系统和应用程序运行的情况下，您可以向指定的节点发出请求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then visit the http://localhost:16686[Jaeger UI] to see the tracing information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后访问 link:http://localhost:16686[Jaeger界面] 来查看追踪信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其他配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some use cases will require custom configuration of OpenTelemetry.  These sections will outline what is necessary to properly configure it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些情况下需要对OpenTelemetry进行自定义配置。以下章节将展示如何对一些必要的属性进行正确配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenTelemetry extension will use by default a random https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#id-generators[ID Generator] when creating the trace and span identifier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry扩展将默认使用一个随机的 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#id-generators[ID发生器] 来创建trace和span标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some vendor-specific protocols need a custom ID Generator, you can override the default one by creating a producer.  The OpenTelemetry extension will detect the `IdGenerator` CDI bean and will use it when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些供应商特定协议需要一个自定义的ID生成器，您可以通过创建一个自定义生成器来覆盖默认的ID。OpenTelemetry扩展将检测 `IdGenerator` CDI Bean，并在配置tracer生成器时使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Propagators</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Propagators</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenTelemetry propagates cross-cutting concerns through https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] that will share an underlying `Context` for storing state and accesing data across the lifespan of a distributed transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetry通过 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] 来传播横切关注点(cross-cutting concerns)，这些 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md[propagators] 将共享一个底层 `Context` ，用于在分布式事务的生命周期内存储状态和访问数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the OpenTelemetry extension enables the https://www.w3.org/TR/trace-context/[W3C Trace Context] and the https://www.w3.org/TR/baggage/[W3C Baggage] propagators, you can however choose any of the supported OpenTelemetry propagators by setting the `propagators` config that is described in the &lt;&lt;configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，OpenTelemetry扩展启用了 link:https://www.w3.org/TR/trace-context/[W3C Trace Context] 和 link:https://www.w3.org/TR/baggage/[W3C Baggage] propagators，但是您可以通过设置 link:#configuration-reference[[参考配置]] 中描述的 `propagators` 配置来选择任何支持的OpenTelemetry propagators。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `b3`, `b3multi`, `jaeger` and `ottrace` propagators will need the https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/trace-propagators[trace-propagators] extension to be added as a dependency to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`b3` , `b3multi` , `jaeger` 和 `ottrace` propatagors 需要将 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/trace-propagators[trace-propagators] 扩展作为一个依赖添加到您的项目中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `xray` propagator will need the https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/aws[aws] extension to be added as a dependency to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`xray` propagator需要将 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/extensions/aws[aws] 扩展作为依赖添加到您的项目中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#resources[resource] is a representation of the entity that is producing telemetry, it adds attributes to the exported trace to characterize who is producing the trace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Opentelemetry link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#resources[资源] 是产生telemetry的实体的表示，它向输出的trace中添加属性，用以描述谁在产生trace。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add attributes by setting the `resource-attributes` tracer config that is described in the &lt;&lt;configuration-reference&gt;&gt;.  Since this property can be overridden at runtime, the OpenTelemetry extension will pick up its value following the order of precedence that is described in the xref:config-reference.adoc#configuration_sources[Quarkus Configuration Reference].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过设置 link:#configuration-reference[[参考设置]] 中的 `resource-attributes` tracer 配置来添加属性。由于这个属性可以在运行时被覆盖，OpenTelemetry扩展将按照 link:config-reference.html#configuration_sources[Quarkus参考配置] 中描述的优先顺序来获取其值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If by any means you need to use a custom resource or one that is provided by one of the https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK Extensions] you can create multiple resource producers. The OpenTelemetry extension will detect the `Resource` CDI beans and will merge them when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果通过您需要的任何方式来使用自定义的资源或由 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK扩展] 之一提供的资源，您可以创建多个资源生产者。OpenTelemetry扩展将检测 `Resource` CDI beans，并在配置tracer生成器时将其合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sampler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>采样器(Sampler)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#sampling[sampler] decides whether a trace should be sampled and exported, controlling noise and overhead by reducing the number of sample of traces collected and sent to the collector.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Opentelemetry link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#sampling[采样器] 决定了是否应该对一个trace进行采样和输出，通过减少收集和发送至exporter的trace样本数量来控制噪音和开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can set a https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#built-in-samplers[built-in sampler] simply by setting the desired sampler config described in the &lt;&lt;configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过设置 link:#configuration-reference[[参考配置]] 中提到的必要的采样器配置来简单地设置一个 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#built-in-samplers[内置采样器]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to use a custom sampler or to use one that is provided by one of the https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK Extensions] you can create a sampler producer. The OpenTelemetry extension will detect the `Sampler` CDI bean and will use it when configuring the tracer producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要使用一个自定义的采样器或使用一个由 link:https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions[OpenTelemetry SDK扩展] 提供的采样器，您可以创建一个采样器生成器。OpenTelemetry扩展将检测到 `Sampler` CDI bean，并在配置tracer生成器时使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional instrumentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其他的植入(instrumentation)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some Quarkus extensions will require additional code to ensure traces are propagated to subsequent execution.  These sections will outline what is necessary to propagate traces across process boundaries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些Quarkus扩展需要额外的代码来确保traces被传播到后续执行中。以下章节将展示跨越进程边界传播traces的必要条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instrumentation documented in this section has been tested with Quarkus and works in both standard and native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本节中用到的植入方式已经过Quarkus测试，并且在标准和本地模式下都能工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging - Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Reactive Messaging - Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the SmallRye Reactive Messaging extension for Kafka, we are able to propagate the span into the Kafka Record with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 SmallRye Reactive Messaging  的 Kafka 扩展时，我们可以向Kafka记录中传播span，通过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above creates a `Metadata` object we can add to the `Message` being produced, which retrieves the OpenTelemetry `Context` to extract the current span for propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上代码创建了一个 `Metadata` 对象，我们可以将该对象添加到生成的 `Message` 中，并且该对象可以获取OpenTelemetry的 `Context` 来抽取当前的span用以传播。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outgoing Attributes of the 'smallrye-kafka' connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>'smallrye-kafka' 连接器的传出属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. Accepted values are: 0, 1, all

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生产者要求领导者认为一个请求完成之前收到的确认的数量。这控制了发送记录的延续性。可接受的值是：0, 1, all

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A comma-separated list of host:port to use for establishing the initial connection to the Kafka cluster.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用逗号分隔的主机：端口列表，用于建立与Kafka集群的初始连接。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The total bytes of memory the producer can use to buffer records waiting to be sent to the server.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生产者可用于缓冲等待发送至服务器的记录的总字节数。

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The amount of milliseconds waiting for a graceful shutdown of the Kafka producer

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>等待Kafka生产者平滑关闭的毫秒数

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用（默认启用）或停用云事件支持。如果在 _传入_ 通道上启用，连接器会分析传入记录并尝试创建云事件元数据。如果在 _传出_ 通道上启用，并且如果消息包括云事件元数据，连接器会将传出的消息作为云事件发送。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `datacontenttype` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `datacontenttype` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `datacontenttype` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `datacontenttype` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `dataschema` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `dataschema` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `dataschema` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `dataschema` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>云事件模式（ `structured` 或 `binary` （默认））。表示如何在发出的记录中写入云事件

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `source` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `source` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `source` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `source` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `subject` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `subject` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `subject` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `subject` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `type` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `type` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置传出的云事件的默认 `type` 属性。要求 `cloud-events` 设置为 `true` 。如果消息本身没有配置 `type` 属性，则使用此值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether health reporting is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>健康报告是否被启用（默认启用）或禁用

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether readiness health reporting is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否启用（默认启用）或禁用就绪情况报告

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_deprecated_ - During the readiness health check, the connector connects to the broker and retrieves the list of topics. This attribute specifies the maximum duration (in ms) for the retrieval. If exceeded, the channel is considered not-ready. Deprecated: Use 'health-topic-verification-timeout' instead.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_已废弃_ - 在就绪状态健康检查期间，连接器会连接到broker并获取主题列表。这个属性指定了获取操作的最大耗时（ms）。如果超时，通道会被认为是没有就绪的。已废弃：使用'health-topic-verification-timeout'代替。

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_deprecated_ - Whether the readiness check should verify that topics exist on the broker. Default to false. Enabling it requires an admin connection. Deprecated: Use 'health-topic-verification-enabled' instead.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_已废弃_ - 就绪检查是否应该验证broker上是否存在主题。默认为false。启用它需要一个管理员连接。已废弃：请使用 'health-topic-verification-enabled' 代替。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the startup and readiness check should verify that topics exist on the broker. Default to false. Enabling it requires an admin client connection.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动和就绪检查是否要验证broker上存在主题。默认为false。启用它需要一个管理员客户端连接。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the startup and readiness health check, the connector connects to the broker and retrieves the list of topics. This attribute specifies the maximum duration (in ms) for the retrieval. If exceeded, the channel is considered not-ready.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在启动和就绪的健康检查期间，连接器会连接到broker并获取主题列表。这个属性指定了获取的最大耗时（ms）。如果超时，通道就被认为是没有就绪的。

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A key to used when writing the record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写入记录时使用的键值

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The serializer classname used to serialize the record's key

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用来序列化记录的键的序列化器类名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of messages to be written to Kafka concurrently. It limits the number of messages waiting to be written and acknowledged by the broker. You can set this attribute to `0` remove the limit

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并发写入Kafka的消息的最大数量。它限制了等待被写入和被broker确认的消息的数量。你设置为： `0` 以解除该限制

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The target partition id. -1 to let the client determine the partition

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目标分区的ID。设置为-1可以客户端自行确定分区

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Propagate incoming record key to the outgoing record

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否将传入的记录键添加到传出的记录中

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If set to a positive number, the connector will try to resend any record that was not delivered successfully (with a potentially transient error) until the number of retries is reached. If set to 0, retries are disabled. If not set, the connector tries to resend any record that failed to be delivered (because of a potentially transient error) during an amount of time configured by `delivery.timeout.ms`.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置为正数，连接器将尝试重新发送任何没有成功传递的记录（有可能是瞬时错误），直到达到重试的上限。如果设置为0，重试将被禁用。如果不设置，连接器会在 `delivery.timeout.ms` 配置的时间内，尝试重新发送任何未能交付的记录（由于潜在的瞬时错误）。

类型: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed / populated Kafka topic. If neither this property nor the `topics` properties are set, the channel name is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>被消费/生产消息的Kafka主题。如果这个属性和 `topics` 属性都没有设置，则使用通道名称。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The serializer classname used to serialize the payload

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于序列化payload的序列化器的类名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the client waits for Kafka to acknowledge the written record before acknowledging the message

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在确认消息之前，客户端是否会等待Kafka确认写入的记录

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>开发模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get it running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让它运行起来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以本机可执行文件运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用以下命令构建本机可执行文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Profiles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expressions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>表达式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading properties from Spring Cloud Config Server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 Spring Cloud 配置服务器中读取配置属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from the https://cloud.spring.io/spring-cloud-config[Spring Cloud Config Server].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南阐述了你的Quarkus应用程序如何在运行时从 link:https://cloud.spring.io/spring-cloud-config[Spring Cloud Config Server] 中读取配置属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照下面几节的说明逐步创建应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stand up a Config Server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立一个配置服务器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To stand up the Config Server required for this guide, please follow the instructions outlined https://github.com/spring-guides/gs-centralized-configuration#stand-up-a-config-server[here].  The end result of that process is a running Config Server that will provide the `Hello world` value for a configuration property named `message` when the application querying the server is named `a-bootiful-client`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建立该指南所需的 配置服务器 (Config Server)，请遵循 link:https://github.com/spring-guides/gs-centralized-configuration#stand-up-a-config-server[这里] 的说明。该过程的最终目的是创建一个正在运行的且应用程序查询名为 `a-bootiful-client` 的服务器时，会为名为 `message` 的配置属性提供值为 `Hello world` 的配置服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-cloud-config-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以通过在你的项目根目录下运行以下命令，将 `spring-cloud-config-client` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GreetingController</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GreetingController</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we want to use configuration properties obtained from the Config Server, we will update the `GreetingResource` to inject the `message` property. The updated code will look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们想使用从配置服务器(Config Server)中获取到的配置属性，我们将更新 `GreetingResource` 以注入 `message` 属性。更新后的代码将如下所示:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides various configuration knobs under the `quarkus.spring-cloud-config` root. For the purposes of this guide, our Quarkus application is going to be configured in `application.properties` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus在 `quarkus.spring-cloud-config` 根路径下提供了多种配置选项。就该指南而言，我们的Quarkus应用程序将在 `application.properties` 中配置以下内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result should be: `Hello world` as it is the value obtained from the Spring Cloud Config server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>结果应该是： `Hello world` ，因为这是从Spring Cloud 配置服务器(Config Server)上获取的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application as a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以本地可执行文件的方式运行该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://camel.apache.org/[Apache Camel] is the Swiss knife of integrating heterogeneous systems with more than a decade of history and a lively community of users and developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://camel.apache.org/[Apache Camel] 是集成异构系统的瑞士军刀，拥有十多年的历史以及活跃的用户和开发人员社区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to https://camel.apache.org/camel-quarkus/latest/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus上对Apache Camel的支持由 https://github.com/apache/camel-quarkus[Apache Camel Quarkus 项目] 提供。 有关更多信息，请参阅 https://camel.apache.org/camel-quarkus/latest/[他们的文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM, Docker or Podman installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想以本地模式运行，请确保已经安装GraalVM、Docker或Podman。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To let a user easily try out the service, we will implement an HTTP resource summing up the costs (`CostCollector`), and a simple web page to add new costs and watch the sum.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了让用户轻松试用该服务，我们将实现一个 HTTP 资源来汇总成本 ( `CostCollector` )，以及一个简单的网页来添加新的成本并查看总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Converter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>转换器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume messages from the `incoming-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 `incoming-costs` 流中消费消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dispatch returned values to the `outgoing-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送返回值到 `outgoing-costs` 流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's define the `Cost` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们定义 `Cost` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the next step, we will create configurations for both streams in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下一步，我们将在 `application.properties` 文件中为这两个流创建配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.{property}=value`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.{property}=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`channel-name` 片段必须与 `@Incoming` 和 `@Outgoing` 注解中设定的值相匹配:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CostCollector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>成本收集器（The CostCollector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To conveniently interact with the application, let's create a simple web page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了方便地与应用程序交互，让我们创建一个简单的网页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The page will provide a form to add costs, and an info of the current sum of costs.  The page periodically updates the sum by requesting the current sum from `/cost-collector`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该页面将提供一个表格用以添加成本，以及展示当前成本总和的信息。 该页面通过请求 `/cost-collector` 来定期更新当前成本的总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令运行应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/index.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在您的浏览器中打开 `http://localhost:8080/index.html`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension utilizes SmallRye Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此扩展利用 SmallRye 响应式消息来构建数据流应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想进一步了解文档 https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], 在Quarkus中使用的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see our entities remain simple.  There is, however, a slight difference from the Java version.  The Kotlin language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we must use a https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects[companion object]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如你所见，我们的实体仍然很简单。然而，与Java版本有一点不同。Kotlin语言并不像Java那样支持静态方法的概念。相反，我们必须使用一个 link:https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects[companion object（同伴对象）] ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The companion object holds all the methods not related to a specific instance allowing for general management and querying bound to a specific type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>companion object持有所有与特定实例无关的方法，允许进行一般管理和与特定类型绑定的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`] functionality to the `companion object`.  Apart from this slight change, we can then work with our types in ways that map easily from the Java side of world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Kotlin版本中，我们只是把大部分的功能 link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`] 转移到了 `companion object` 。除了这个细微的变化，我们还可以从 Java 方面轻松映射的方式来处理我们的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the addition of `-kotlin` on the end.  Generally you'll only need this version but if your project will be using both Java and Kotlin code, you can safely include both artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意最后添加了 `-kotlin` 。通常你只需要这个版本，但如果你的项目将同时使用 Java 和 Kotlin 代码，你可以安全地包含这两个工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified MongoDB with Panache and Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用Panache和Kotlin简化MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we saw in the MongoDB with Panache guide, it allows us to extend the functionality in our entities and repositories (also known as DAOs) with some automatically provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight change or two.  To Panache-enable your entity, you would define it something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如我们在MongoDB with Panache指南中所看到的，它允许我们用一些自动提供的功能来扩展我们实体和存储库（也称为DAO）中的功能。在使用Kotlin时，该方法与我们在Java版本中看到的非常相似，只是有一两个微小的变化。为了使你的实体具有Panache功能，你可以这样定义它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here there are options, but we've chosen the `lateinit` approach.  This allows us to declare these fields as non-null knowing they will be properly assigned either by the constructor (not shown) or by the MongoDB POJO codec loading data from the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里有一些选项，但我们选择了 `lateinit` 的方法。这允许我们将这些字段声明为非空，因为我们知道它们会被构造函数（未显示）或从数据库加载数据的MongoDB POJO编解码器正确分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These types differ from the Java types mentioned in those tutorials.  For Kotlin support, all the Panache types will be found in the `io.quarkus.mongodb.panache.kotlin` package.  This subpackage allows for the distinction between the Java and Kotlin variants and allows for both to be used unambiguously in a single project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些类型与那些教程中提到的Java类型不同。对于Kotlin支持，所有的Panache类型将在 `io.quarkus.mongodb.panache.kotlin` 包中都可以找到。这个子包允许区分Java和Kotlin变体，并允许在一个项目中明确地使用这两种类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the repository pattern, you can define your entities as regular POJO.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用存储库模式时，你可以将你的实体定义为普通的POJO。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository, by making them implement `PanacheMongoRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 Repositories 时，你可以得到与活动记录模式完全相同的方便方法，注入到你的 Repository 中，通过它们实现 `PanacheMongoRepository` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get started using MongoDB with Panache with Kotlin, you can, generally, follow the steps laid out in the Java tutorial.  The biggest change to configuring your project is the Quarkus artifact to include.  You can, of course, keep the Java version if you need but if all you need are the Kotlin APIs then include the following dependency instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要开始使用带有 Kotlin 的 Panache 的 MongoDB，您通常可以按照 Java 教程中列出的步骤进行操作。配置项目的最大变化是要包含的 Quarkus 工件。当然，如果需要，您可以保留 Java 版本，但如果您只需要 Kotlin API，那么请包含以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在另外一个终端中，运行:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application. In addition there are plugins and extensions to all major IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了一个工具链，支持开发人员从实时重新加载一直到部署Kubernetes应用程序。此外，所有主流IDE都有插件和扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will explore:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将探讨：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何在你的IDE中开发应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choosing your build tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>选择您的构建工具</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.  You can use Maven or Gradle as build tool.  And we offer a CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自带的工具链可以在各个开发阶段帮助你。你可以使用Maven或Gradle作为构建工具。我们还提供了一个方便使用的CLI（即将推出）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:cli-tooling[CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:cli-tooling[CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating Your First Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建你的第一个应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>学习如何创建一个Hello World Quarkus应用程序。本指南包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a JAX-RS endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个JAX-RS端点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入beans</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functional tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>功能测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging of the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序打包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Verify Maven is using the Java you expect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>验证Maven是否使用了你期望的Java版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你安装了多个JDK，那么Maven不一定能找到预期的java，你可能会得到意想不到的结果。你可以通过运行 `mvn --version` ，验证Maven使用哪个JDK。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们创建了一个简单的应用程序，为 `hello` 端点提供服务。为了演示依赖性注入，这个端点使用了一个 `greeting` bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide also covers the testing of the endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南还包括对终端的测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions from &lt;&lt;bootstrapping-the-project,Bootstrapping project&gt;&gt; and onwards to create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照从 link:#bootstrapping-the-project[构建项目] 开始的指示，一步一步地创建应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，你可以直接进入完成的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive] or clone the git repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下载一个 {quickstarts-archive-url}[存档] 或克隆git仓库：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` {quickstarts-tree-url}/getting-started[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `getting-started` {quickstarts-tree-url}/getting-started[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to create a new Quarkus project is to open a terminal and run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个新的Quarkus项目最简单的方法是打开终端并运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux &amp; MacOS users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>针对Linux和MacOS用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Windows users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Windows用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它在 `./getting-started` 中产生了以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例 `Dockerfile` 文件，用于 `native` 和 `jvm` 两种模式，在 `src/main/docker` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果我们把重点放在依赖关系部分，你可以看到允许开发REST应用程序的扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Differences with vanilla JAX-RS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与vanilla JAX-RS的区别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus，不需要创建一个 `Application` 类。它支持这么做，但不是必须的。此外，只有一个资源的实例被创建，而不是每个请求一个。你可以使用不同的 `*Scoped` 注解（ `ApplicationScoped` , `RequestScoped` , 等等）来配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once started, you can request the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦启动，你可以发送请求到提供服务的端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application, or keep it running and enjoy the blazing fast hot-reload.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `CTRL+C` ，停止应用程序，或保持运行，享受极快的热重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatically add newline with `curl -w "\n"`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自动添加换行符 `curl -w "\n"` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using `curl -w "\n"` in this example to avoid your terminal printing a '%' or put both result and next command prompt on the same line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们在这个例子中使用 `curl -w "\n"` ，以避免你的终端打印出'%'或把结果和下一个命令提示符放在同一行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注入法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `GreetingResource` class to inject the `GreetingService` and create a new endpoint using it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编辑 `GreetingResource` 类，注入 `GreetingService` ，并使用它创建一个新的端点:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you can pass `-Dsuspend` on the command line. If you don't want the debugger at all you can use `-Ddebug=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这也将在端口 `5005` 上监听调试器。如果你想在运行前等待调试器的连接，你可以在命令行中传递 `-Dsuspend` 。如果你根本不想要调试器，你可以使用 `-Ddebug=false` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All right, so far so good, but wouldn't it be better with a few tests, just in case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>好吧，到目前为止还不错。为了以防万一， 我们需要再做一些测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过使用 `QuarkusTest` runner，你指示JUnit在测试前启动应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the HTTP response status code and content</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检查HTTP回应状态代码和内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These tests use http://rest-assured.io/[RestAssured], but feel free to use your favorite library.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些测试使用 link:http://rest-assured.io/[RestAssured] ，但也可以随意使用你最喜欢的库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run these using Maven:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用Maven来运行这些：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run the test from your IDE directly (be sure you stopped the application first).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以直接从你的IDE中运行测试（要确保你先停止了应用程序）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests will run on port `8081` so as not to conflict with the running application. We automatically configure RestAssured to use this port. If you want to use a different client you should use the `@TestHTTPResource` annotation to directly inject the URL of the tested application into a field on the test class. This field can be of the type `String`, `URL` or `URI`. This annotation can also be given a value for the test path. For example, if I want to test a Servlet mapped to `/myservlet` I would just add the following to my test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，测试将在端口 `8081` 上运行，以便不与正在运行的应用程序冲突。我们自动将RestAssured配置为使用该端口。如果你想使用不同的客户端，你应该使用 `@TestHTTPResource` 注释，直接将测试应用程序的URL注入到测试类的一个字段中。这个字段的类型可以是 `String` , `URL` 或 `URI` 。这个注解也可以给测试路径一个值。例如，如果我想测试一个映射到 `/myservlet` 的Servlet，只需在测试中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>测试端口可以通过 `quarkus.http.test-port` 配置属性来控制。Quarkus还创建了一个名为 `test.url` 的系统属性，在不能使用注入的情况下被设置为基本测试URL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module project or external modules</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与多模块项目或外部模块一起工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus在构建时大量使用 link:https://github.com/wildfly/jandex[Jandex] ，以发现各种类或注解。其中一个应用就是可以发现并识别CDI Bean。因此，如果没有在构建时正确设置，大多数Quarkus扩展将无法正常工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This index is created by default on the project on which Quarkus is configured for, thanks to our Maven and Gradle plugins.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过使用Maven和Gradle插件，这个索引在Quarkus的项目上的默认配置是自动创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你计划使用外部模块（例如，一个用于你所有领域对象的外部库），你将需要通过添加Jandex插件（如果你能修改它们）或通过 `application.properties` 里的属性`quarkus.index-dependency` （在你不能修改模块的情况下很有用）使这些模块为索引过程所知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>应用程序打包和运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it's the regular artifact produced by the Maven build - it is *not* the runnable jar;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - 它只包含项目的类和资源，是Maven构建时产生的常规组件——它是不可运行的jar。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-app` 目录，其中包含 `quarkus-run.jar` jar文件--是一个可执行的 _jar_ 。请注意，它不是 _über-jar_ ，因为依赖项目被复制到 `quarkus-app/lib/` 的子目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用以下方式运行该应用程序。 `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application somewhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想把你的应用程序部署到某个地方（通常是在一个容器中），你需要部署整个 `quarkus-app` 目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running the application, don't forget to stop the hot reload mode (hit `CTRL+C`), or you will have a port conflict.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在运行应用程序之前，不要忘记停止热重载模式（使用 `CTRL+C` ），否则你会有一个端口冲突。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the banner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置banner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，当Quarkus应用程序启动时（在常规或开发模式下），它将显示一个ASCII。通过在 `application.properties` 中设置 `quarkus.banner.enabled=false` ，通过设置 `-Dquarkus.banner.enabled=false` Java系统属性，或者通过将 `QUARKUS_BANNER_ENABLED` 环境变量设置为 `false` ，可以禁用该横幅。此外，用户可以通过将横幅文件放在 `src/main/resources` ，并在 `application.properties` 中配置 `quarkus.banner.path=name-of-file` ，从而提供一个自定义的横幅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import the project in your favorite IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你喜欢的编辑器里面导入项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>计数器（Counters）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Redis Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can connect to a Redis server using the Redis Client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南演示了如何将你的Quarkus应用通过Redis客户端扩展连接到Redis服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A running Redis server, or Docker Compose to start one</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个正在运行的Redis服务，也可以使用Docker Compose启动一个Redis服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.  Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将开发一个简单的Rest API，其将使用 link:https://redis.io/commands/incrby[`INCRBY`] 命令来递增数字。在此过程中，我们将学会如何使用其他Redis命令，如 `GET` , `SET` , `DEL` 和 `KEYS` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll be using the Quarkus Redis Client extension to connect to our Redis Server. The extension is implemented on top of the https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis Client], providing an asynchronous and non-blocking way to connect to Redis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将使用Quarkus Redis客户端扩展来连接到Redis服务。该扩展是在 link:https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis客户端] 的基础上实现的，提供了一种异步和非阻塞的方式来连接Redis服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `redis-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了Quarkus项目，可以通过在项目根目录下运行以下命令，将 `redis-client` 扩展添加到你的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting the Redis server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动Redis服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we need to start a Redis instance (if you do not have one already) using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果还没有Redis服务实例，我们需要使用以下命令启动一个Redis实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use xref:redis-dev-services.adoc[Dev Services for Redis], launching the container manually is not necessary!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 link:redis-dev-services.html[Dev Services for Redis] ，则无需手动启动Redis服务容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Redis properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once we have the Redis server running, we need to configure the Redis connection properties.  This is done in the `application.properties` configuration file. Edit it to the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行Redis服务后，我们需要在 `application.properties` 配置文件中配置Redis连接属性，增加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置要连接的Redis主机。这里我们连接到上一节中启动的Redis服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is needed if you are not using xref:redis-dev-services.adoc[Dev Services for Redis]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在不使用 link:redis-dev-services.html[Dev Services for Redis] 的情况下需要配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment POJO</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Increment POJO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to model our increments using the `Increment` POJO.  Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将使用 `Increment` POJO来模拟递增操作。创建 `src/main/java/org/acme/redis/Increment.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The key that will be used as the Redis key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将被用作Redis的Key</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The value held by the Redis key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis的Key所持有的值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Increment服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to create an `IncrementService` class which will play the role of a Redis client.  With this class, we'll be able to perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将创建一个 `IncrementService` 类，它将扮演Redis客户端的角色。这个类能够执行 `SET` , `GET` , `DELET` , `KEYS` 和 `INCRBY` 等Redis命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/redis/IncrementService.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Redis synchronous client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入Redis同步客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Reactive Redis client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入Redis响应式客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment Resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Increment资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/redis/IncrementResource.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have the Redis server running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已按上文指引操作，则应该已经运行了Redis服务。然后需要用以下方法运行应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open another terminal and run the `curl http://localhost:8080/increments` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开另一个终端，运行 `curl http://localhost:8080/increments` 命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与应用程序进行交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen above, the API exposes five Rest endpoints.  In this section we are going to see how to initialise an increment, see the list of current increments, incrementing a value given its key, retrieving the current value of an increment, and finally deleting a key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从上文可以看到，该API服务暴露了五个Restful接口。在这一节中，我们将看到如何初始化一个增量，查看当前的增量列表，给指定键的值递增，查询一个增量的当前值，以及删除一个键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new increment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个新的增量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create the first increment, with the key `first` and an initial value of `10`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们创建第一个增量，键为 `first` ，初始值为 `10` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the above command should return the result below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行上述命令应返回以下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See current increments keys</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查看当前增量键的列表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the list of current increments keys, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要查看当前增量键的列表，请运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above command should return `["first"]` indicating that we have only one increment thus far.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面的命令应该返回 `["first"]` ，表明到目前为止我们只有一个增量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve a new increment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>查询增量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To retrieve an increment using its key, we will have to run the below command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用指定的键查询增量，我们须运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running this command, should return the following result:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行这个命令应返回以下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Increment a value given its key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>递增指定键的值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To increment a value, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要增加键的值，请运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Increment the `first` value by 27.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `first` 的值增加27。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments/first` should return the following result:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，运行命令 `curl http://localhost:8080/increments/first` 应返回以下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We see that the value of the `first` key is now `37` which is exactly the result of `10 + 27`, quick maths.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们看到，现在 `first` 键的值是 `37` ，这正是 `10 + 27` 的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deleting a key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>删除指定的键</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the command below, to delete an increment given its key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用下面的命令，删除一个键的增量：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the `first` increment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>删除 `first` 的增量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments` should return an empty list `[]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，运行命令 `curl http://localhost:8080/increments` 应该返回一个空列表 `[]` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and running in JVM mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包，并在JVM模式下运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application as a conventional jar file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以将应用打包为一个传统的jar文件，然后运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we will need to package it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，需要打包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will start a Redis instance to execute the tests. Thus your Redis containers need to be stopped.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下命令将启动一个Redis实例以执行测试。因此，需要停掉你的Redis容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create a native executable from this application without making any source code changes. A native executable removes the dependency on the JVM: everything needed to run the application on the target platform is included in the executable, allowing the application to run with minimal resource overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>无需对源代码做任何修改，就可以将应用程序构建为一个本地可执行文件。本地可执行文件消除了对JVM的依赖，它包含了在目标平台上运行应用程序所需的一切，使应用程序能够以最小的资源开销运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling a native executable takes a bit longer, as GraalVM performs additional steps to remove unnecessary codepaths. Use the `native` profile to compile a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编译一个本地可执行文件需要很长的时间，因为GraalVM会执行额外的步骤来删除不必要的代码路径。可使用 `native` profile来编译一个本地可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the build is finished, you can run the executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建完成后，可以用以下命令运行可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-vertx-redis` will automatically add a readiness health check to validate the connection to the Redis server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用了 `quarkus-smallrye-health` 扩展， `quarkus-vertx-redis` 将自动添加就绪健康检查，以验证与Redis服务的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.redis.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以通过在 `application.properties` 中设置 `quarkus.redis.health.enabled` 属性为 `false` 来禁用这个连接健康检查。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis extension allows you to configure multiple clients.  Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis扩展允许你配置多个客户端。使用多个客户端与使用一个客户端的方式相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `second` segment).  The syntax is as follows: `quarkus.redis.[optional name.][redis configuration property]`.  If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在第二个配置项中有额外的一段（ `second` 段）。具体语法： `quarkus.redis.[可选的配置名称][Redis配置属性名]` 。如果省略名称，则为默认客户端的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, you can select the client to inject using the `io.quarkus.redis.client.RedisClientName` qualifier.  Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用多个客户端时，可以使用 `io.quarkus.redis.client.RedisClientName` 注解，来选择要注入的客户端。使用上述属性来配置三个不同的客户端后，可以按以下方式来注入每个客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating Clients Programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以编程方式创建Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `RedisClient` and `ReactiveRedisClient` provide factory methods to create clients programmatically.  The client to be created are configured using the usual &lt;&lt;config-reference,Redis configuration&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisClient` 和 `ReactiveRedisClient` 提供工厂方法，以便用编程方式创建客户端。这样可以创建出使用常规 link:#config-reference[Redis配置] 的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The below code snippet shows how we can create dynamic clients using the configurations in &lt;&lt;multiple-clients-configuration&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的代码片段显示了我们如何使用 link:#multiple-clients-configuration[[多个Redis客户端]] 中的配置创建动态客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Glossary</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>词汇表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是文件和网站中首选术语的集合。为了保持一致性，请保持在这些术语范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Live coding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 实时编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>preferred term for the VM creating native executable. No space.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虚拟机创建原生可执行文件的首选术语。没有空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>non-preferred. Exclude.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非优先考虑的。不包括。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 容器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>imperative and reactive. 'Nuff said.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指令式和响应式。这就是最有名的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Best of breed frameworks and standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* 最好的类库和标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live reload</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实时重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Important Technical Note</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重要技术说明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://en.wikipedia.org/wiki/YAML[YAML] is a very popular format. Kubernetes relies heavily on the YAML format to write the various resource descriptors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://en.wikipedia.org/wiki/YAML[YAML] 是一种非常流行的格式。Kubernetes高度依赖YAML格式来编写各种资源描述符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers the possibility to use YAML in addition to the standard Java Properties file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了标准的 Java Properties 文件之外，Quarkus 还提供了使用 YAML 的能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling YAML Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用YAML配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also just add the following dependency into your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以直接将以下依赖添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the `src/main/resources/application.properties` and create a `src/main/resources/application.yaml` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>删除 `src/main/resources/application.properties` ，并创建一个 `src/main/resources/application.yaml` 文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If both are present, Quarkus prioritizes configuration properties from the YAML file first and then from the Properties file. However, to avoid confusion, we recommend removing the Properties file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果两者都存在，Quarkus会优先考虑YAML文件中的配置属性，接着是 Properties 文件中的配置属性。然而，为了避免混淆，我们建议删除 Properties 文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following snippets provide examples of YAML configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下代码段提供了YAML配置的示例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># With profiles
"%test":
   quarkus:
     oidc:
       enabled: false
     security:
        users:
            file:
              enabled: true
              realm-name: quarkus
              plain-text: true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 使用环境
"%test":
   quarkus:
     oidc:
       enabled: false
     security:
        users:
            file:
              enabled: true
              realm-name: quarkus
              plain-text: true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see in the previous snippet, you can use xref:config-reference.adoc#profiles[profiles] in YAML. The profile key requires double quotes: `"%test"`. This is because YAML does not support keys starting with `%`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如你在之前的代码片段中所看到的，你可以在YAML中使用 link:config-reference.html#profiles[profiles] 。该环境配置的key 需要使用双引号: `"%test"` 。这是因为YAML不支持以 `%` 开始的键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything under the `"%test"` key is only enabled when the `test` profile is active. For example, in the previous snippet it disables OIDC (`quarkus.oidc.enabled: false`), whereas without the `test` profile, it would be enabled.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>只有当 `test` 环境配置处于激活状态时， `"%test"` 键下的所有内容才会被启用。例如在前面的代码片段中，它禁用了OIDC ( `quarkus.oidc.enabled: false` )，反之，如果没有 `test` 环境配置，它将会被启用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for the Java Properties format, you can define your own profile:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>至于Java Properties 格式，你可以定义你自己的环境配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enable the `staging` profile, the HTTP port will be 8082, whereas it would be 8081 otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你启用了 `staging` 环境配置，HTTP 端口将会是 8082，反之，端口将会是 8081。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The YAML configuration also support profile aware files. In this case, properties for a specific profile may reside in an `application-{profile}.yaml` named file. The previous example may be expressed as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML 配置还支持环境配置文件的感知。在这种情况下，特定环境下的配置文件的属性可以书写在一个名为 `application-{profile}.yaml` 的文件中。前面的例子也可以表示为:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The YAML format also supports xref:config-reference.adoc#expressions[expressions], using the same format as Java Properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML格式同时也支持 link:config-reference.html#expressions[表达式] ，使用与Java Properties相同的格式:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you can reference nested properties using the `.` (dot) separator as in `{x.factor}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，你可以使用 `.` (点)分隔符来引用嵌套的属性，如 `{x.factor}` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>External application.yaml file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>外部application.yaml 文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `application.yaml` file may also be placed in `config/application.yaml` to specialize the runtime configuration. The file has to be present in the root of the working directoryrelative to the Quarkus application runner:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.yaml` 文件也可以放在 `config/application.yaml` 中，以专门实现运行时的配置。该文件必须存在于相对Quarkus应用运行程序的工作目录的根目录中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values from this file override any values from the regular `application.yaml` file if exists.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果存在的话，此文件中的值将覆盖常规 `application.yaml` 文件中的任何值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration key conflicts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置键冲突</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MicroProfile Config specification defines configuration keys as an arbitrary `.`-delimited string. However, structured formats like YAML only support a subset of the possible configuration namespace. For example, consider the two configuration properties `quarkus.http.cors` and `quarkus.http.cors.methods`. One property is the prefix of another, so it may not be immediately evident how to specify both keys in your YAML configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Config 规范将配置键定义为任意的 `.` - 分隔字符串。然而，像 YAML 这样的结构化格式可能只支持配置命名空间的一个子集。例如，考虑有两个配置属性 `quarkus.http.cors` 和 `quarkus.http.cors.methods` 的情况。一个属性是另一个属性的前缀，因此如何在 YAML 配置中指定这两个键可能不是很明确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is solved by using a `null` key (represented by `~`) for any YAML property which is a prefix of another one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这可以通过为任意YAML属性使用 `null` 键（以 `~` 为代表）来解决，该属性是另一个属性的前缀:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YAML `null` keys are not included in the assembly of the configuration property name, allowing them to be used in any level for disambiguating configuration keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YAML `null` 键不被包含在配置属性名称的程序集中，允许在任意级别使用它们来消除配置键的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some familiarity with the Spring Web extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对Spring Web扩展有一定的熟悉程度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>备注</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the Spring support in Quarkus does not start a Spring Application Context nor are any Spring infrastructure classes run.  Spring classes and annotations are only used for reading metadata and / or are used as user code method return types or parameter types.  What that means for end users, is that adding arbitrary Spring libraries will not have any effect. Moreover Spring infrastructure classes (like `org.springframework.beans.factory.config.BeanPostProcessor` for example) will not be executed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，Quarkus中的Spring支持并不会启动Spring应用上下文，也不会运行任何Spring基础结构类。Spring类和注解仅用于读取元数据和 / 或作为用户代码的方法返回类型或参数类型。对于最终用户来说，这意味着添加任意Spring库都不会对程序有任何影响。此外，Spring基础类（例如 `org.springframework.beans.factory.config.BeanPostProcessor` ）将不会被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Items</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can find a list of Build Items and the extension that provides them:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里，您可以找到构建项目的列表以及提供它们的扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how a Quarkus application can leverage the well known Spring Scheduled annotation to configure and schedule tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南解释了Quarkus应用程序如何利用众所周知的Spring Scheduled注解来配置和安排任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `spring-scheduled-quickstart` {quickstarts-tree-url}/spring-scheduled-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `spring-scheduled-quickstart` {quickstarts-tree-url}/spring-scheduled-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-scheduled` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以在你的项目根目录下运行以下命令，将 `spring-scheduled` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.spring.scheduler` package, create the `CounterBean` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `org.acme.spring.scheduler` 包中，使用以下内容创建 `CounterBean` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the bean in the _application_ scope. Spring only detects @Scheduled annotations in beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以 _application_ scope声明该Bean。Spring只检测Bean上的@Scheduled注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Spring `@Scheduled` annotation with a cron-like expression to instruct Quarkus to schedule this method run.  In this example we're scheduling a task to be executed at 10:15am every day.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用一个带有类似于cron表达式的Spring `@Scheduled` 注解来指示Quarkus安排这个方法的运行。在这个例子里，我们将会安排一个每天上午10:15都会被执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is pretty straightforward. Every day at 10:15am, the counter is incremented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代码非常简单明了。每天上午10点15分，计数器递增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a method to be executed at a fixed interval of time. The period is expressed in milliseconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定义一个以固定时间间隔执行的方法。周期以毫秒表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job to be executed at a fixed interval of time `fixedRate.expr` which is configurable in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `application.properties` 中定义一个以固定时间间隔执行的 `fixedRate.expr` 作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `application.properties` file and add the `cron.expr` and the `fixedRate.expr` configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编辑 `application.properties` 文件，添加 `cron.expr` 和 `fixedRate.expr` 配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observe the console to verify that the following messages has been displayed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>观察控制台，检查是否显示了以下信息:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Cron expression hardcoded`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Cron expression hardcoded` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Cron expression configured in application.properties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Cron expression configured in application.properties` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Fixed Rate expression`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Fixed Rate expression` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Fixed Rate expression configured in application.properties` These messages indicate that the executions of methods annotated with `@Scheduled` have been triggered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Fixed Rate expression configured in application.properties` 这些消息表明使用 `@Scheduled` 注解标注的方法执行都已经被触发了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Property Expressions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用属性表达式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of property expressions in the `application.properties` file so to externalize the configuration of the tasks you should store the properties in the `application.properties` file and use the `fixedRateString`, `initialDelayString` params respectively.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持在 `application.properties` 文件中使用属性表达式，因此为了使任务的配置外部化，你应该在 `application.properties` 文件中，分别使用 `fixedRateString` , `initialDelayString` 参数存储属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that this configuration is a build time configuration, the property expression will be resolved at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，这个配置是构建时的配置，属性表达将在构建时被解析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unsupported Spring Scheduled functionalities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不支持的Spring Scheduled功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus currently only supports a subset of the functionalities that Spring @Scheduled provides with more features being planned.  Currently, the `fixedDelay` and `fixedDelayString` parameters are not supported, in other words, `@Scheduled` methods are always executed independently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus目前只支持Spring @Scheduled所提供功能的一个子集，更多的功能正在计划当中。目前暂不支持 `fixedDelay` 和 `fixedDelayString` 参数，换句话说， `@Scheduled` 方法总是被独立地执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing JSON REST Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写JSON REST服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the _lingua franca_ between microservices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON现在是微服务之间的 _通用_ 语言。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将了解如何使用REST服务和生成有效的JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server are formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览器和服务器之间的所有信息都被格式化为JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To improve user experience, Quarkus registers the three Jackson https://github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you don't need to do it manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了提高用户体验，Quarkus注册了三个Jackson link:https://github.com/FasterXML/jackson-modules-java8[Java 8模块] ，所以你不需要手动操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现起来相当简单，你只需要使用JAX-RS注解来定义你的节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring JSON support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置JSON支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the default Jackson `ObjectMapper` obtained via CDI (and consumed by the Quarkus extensions) is configured to ignore unknown properties (by disabling the `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus中，通过CDI获得的默认Jackson `ObjectMapper` （并由Quarkus扩展使用）被配置为忽略未知属性（通过禁用 `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can restore the default behavior of Jackson by setting `quarkus.jackson.fail-on-unknown-properties=true` in your `application.properties` or on a per class basis via `@JsonIgnoreProperties(ignoreUnknown = false)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以通过在你的 `application.properties` ，或者通过 `@JsonIgnoreProperties(ignoreUnknown = false)` ，在每个类的基础上设置 `quarkus.jackson.fail-on-unknown-properties=true` ，恢复Jackson的默认行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the `ObjectMapper` is configured to format dates and time in ISO-8601 (by disabling the `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外， `ObjectMapper` 被配置为ISO-8601的日期和时间格式（通过禁用 `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` 功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default behaviour of Jackson can be restored by setting `quarkus.jackson.write-dates-as-timestamps=true` in your `application.properties`. If you want to change the format for a single field, you can use the `@JsonFormat` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jackson的默认行为可以通过在你的 `application.properties` 中设置 `quarkus.jackson.write-dates-as-timestamps=true` 来设置。如果你想改变单个字段的默认行为，你可以使用 `@JsonFormat` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, Quarkus makes it very easy to configure various Jackson settings via CDI beans.  The simplest (and suggested) approach is to define a CDI bean of type `io.quarkus.jackson.ObjectMapperCustomizer` inside of which any Jackson configuration can be applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另外，Quarkus使得通过CDI beans来配置各种Jackson设置变得非常容易。最简单的（也是建议的）方法是定义一个类型为 `io.quarkus.jackson.ObjectMapperCustomizer` 的CDI Bean，在其中可以使用任何Jackson配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example where a custom module needs to be registered would look like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注册自定义模块的示例如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can even provide their own `ObjectMapper` bean if they so choose.  If this is done, it is very important to manually inject and apply all `io.quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that produces `ObjectMapper`.  Failure to do so will prevent Jackson specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用户选择的话，他们甚至可以提供自己的 `ObjectMapper` bean。如果这样做，在产生 `ObjectMapper` 的CDI生产者中，手动注入和应用所有 `io.quarkus.jackson.ObjectMapperCustomizer` Bean是非常重要的。如果不这样做，就会阻止各种扩展所提供的Jackson特定的自定义功能被应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As stated above, Quarkus provides the option of using JSON-B instead of Jackson via the use of the `quarkus-resteasy-jsonb` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，Quarkus通过使用 `quarkus-resteasy-jsonb` 扩展提供了使用JSON-B而不是Jackson的选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the same approach as described in the previous section, JSON-B can be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>按照上一节所述的相同方法，JSON-B可以使用 `io.quarkus.jsonb.JsonbConfigCustomizer` bean进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for example a custom serializer named `FooSerializer` for type `com.example.Foo` needs to be registered with JSON-B, the addition of a bean like the following would suffice:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果需要使用 JSON-B 注册类型为 `com.example.Foo` 的名为 `FooSerializer` 的自定义序列化程序，则添加如下所示的 bean 就足够了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more advanced option would be to directly provide a bean of `javax.json.bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` scope).  If the latter approach is leveraged it is very important to manually inject and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI producer that produces `javax.json.bind.Jsonb`.  Failure to do so will prevent JSON-B specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个更高级的选择是直接提供一个 `javax.json.bind.JsonbConfig` 的bean（具有 `Dependent` 范围），或者在极端情况下，提供一个 `javax.json.bind.Jsonb` 的bean（具有 `Singleton` 范围）。如果采用后一种方法，那么在产成 `javax.json.bind.Jsonb` 的CDI生产者中手动注入和应用所有 `io.quarkus.jsonb.JsonbConfigCustomizer` Bean是非常重要的。如果不这样做，就会阻止由各种扩展提供的JSON-B特定的自定义功能被应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来与我们的 `FruitResource` 进行交互。Quarkus自动提供位于 `META-INF/resources` 目录下的静态资源。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `fruits.html` 文件，其中包含这个{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行它就像执行 `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner` 一样简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>About serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于序列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON serialization libraries use Java reflection to get the properties of an object and serialize them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON序列化库使用Java反射来获取一个对象的属性并将其序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native executables with GraalVM, all classes that will be used with reflection need to be registered.  The good news is that Quarkus does that work for you most of the time.  So far, we haven't registered any class, not even `Fruit`, for reflection usage and everything is working fine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用GraalVM的本地可执行文件时，需要注册所有将与反射一起使用的类。好消息是，Quarkus在大多数时候都会为你做这项工作。到目前为止，我们还没有注册任何类，甚至没有注册 `Fruit` ，并且一切正常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus performs some magic when it is capable of inferring the serialized types from the REST methods.  When you have the following REST method, Quarkus determines that `Fruit` will be serialized:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Quarkus能够从REST方法中推断出序列化的类型时，它会发挥一些作用。当你有以下的REST方法时，Quarkus确定 `Fruit` 将被序列化：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does that for you automatically by analyzing the REST methods at build time and that's why we didn't need any reflection registration in the first part of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过在构建时分析REST方法自动为你执行此操，这就是为什么我们在本指南的第一部分不需要任何反射注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another common pattern in the JAX-RS world is to use the `Response` object.  `Response` comes with some nice perks:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RS世界中另一个常见的模式是使用 `Response` 对象。 `Response` 有一些很好的好处：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can return different entity types depending on what happens in your method (a `Legume` or an `Error` for instance);</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以根据你的方法中发生的情况，返回不同的实体类型（例如， `Legume` 或 `Error` ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can set the attributes of the `Response` (the status comes to mind in the case of an error).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以设置 `Response` 的属性（在出现错误的情况下，会想到状态）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your REST method then looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的 REST 方法如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible for Quarkus to determine at build time the type included in the `Response` as the information is not available.  In this case, Quarkus won't be able to automatically register for reflection the required classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus不可能在构建时确定 `Response` 中包含的类型，因为该信息不可用。在这种情况下，Quarkus将无法自动注册反映所需的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This leads us to our next section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这将我们引向下一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Response</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create the `Legume` class which will be serialized as JSON, following the same model as for our `Fruit` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们创建一个将被序列化为 JSON 的 `Legume` 类，遵循与我们的 `Fruit` 类相同的模型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's create a `LegumeResource` REST service with only one method which returns the list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们创建一个 `LegumeResource` REST服务，它只有一个返回legumes类列表的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method returns a `Response` and not a list of `Legume`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该方法返回一个 `Response` ，而不是一个 `Legume` 列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to display our list of legumes.  In the `src/main/resources/META-INF/resources` directory, add a `legumes.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们添加一个简单的网页来显示我们的legumes列表。在 `src/main/resources/META-INF/resources` 目录中，添加一个 `legumes.html` 文件，其中包含这个{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] 文件的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a browser to http://localhost:8080/legumes.html and you will see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开浏览器访问 http://localhost:8080/legumes.html ，你会看到我们的legumes列表内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part starts when running the application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有趣的部分是在将应用程序作为本机可执行文件运行时开始的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>execute it with `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用以下方式执行它 `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>open a browser and go to http://localhost:8080/legumes.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打开浏览器，访问 http://localhost:8080/legumes.html </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No legumes there.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那里没有legumes。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the issue is that Quarkus was not able to determine the `Legume` class will require some reflection by analyzing the REST endpoints.  The JSON serialization library tries to get the list of fields of `Legume` and gets an empty list so it does not serialize the fields' data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如上所述，问题是Quarkus无法通过分析REST节点来确定 `Legume` 类将需要一些反射。JSON序列化库试图获取 `Legume` 的字段列表，但得到的是一个空列表，所以它没有序列化字段的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment, when JSON-B or Jackson tries to get the list of fields of a class, if the class is not registered for reflection, no exception will be thrown.  GraalVM will simply return an empty list of fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目前，当JSON-B或Jackson尝试获取一个类的字段列表时，如果该类没有注册反射，则不会抛出异常。GraalVM将简单地返回一个空的字段列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hopefully, this will change in the future and make the error more obvious.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>希望这在将来会有所改变，使错误更加明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can register `Legume` for reflection manually by adding the `@RegisterForReflection` annotation on our `Legume` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们可以通过在我们的 `Legume` 类上添加 `@RegisterForReflection` 注解来手动注册 `Legume` 进行反射：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's do that and follow the same steps as before:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们这样做，并遵循与之前相同的步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hit `Ctrl+C` to stop the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `Ctrl+C` ，停止应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time, you can see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这一次，你可以看到我们的legumes列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return _reactive types_ to handle asynchronous processing.  Quarkus recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write reactive and asynchronous code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以返回 _响应式类型_ 来处理异步处理。Quarkus推荐使用 link:https://smallrye.io/smallrye-mutiny[Mutiny] 来编写响应式和异步代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `Uni` when you have a single result.  Use `Multi` when you have multiple items that may be emitted asynchronously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当你有一个单一的结果时，使用 `Uni` 。当你有多个可能被异步发射的项目时，使用 `Multi` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Uni` and `Response` to return asynchronous HTTP responses: `Uni&lt;Response&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `Uni` 和 `Response` 返回异步 HTTP 响应：`Uni&lt;Response&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about Mutiny can be found in xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有关 Mutiny 的更多详细信息，请参见外部参考：xref:mutiny-primer.adoc[Mutiny - 一个直观的响应式编程库]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating JSON REST services with Quarkus is easy as it relies on proven and well known technologies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Quarkus 创建 JSON REST 服务很容易，因为它依赖于经过验证且众所周知的技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, Quarkus further simplifies things under the hood when running your application as a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>像往常一样，当您将应用程序作为本机可执行文件运行时，Quarkus 进一步简化了内部工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is only one thing to remember: if you use `Response` and Quarkus can't determine the beans that are serialized, you need to annotate them with `@RegisterForReflection`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>只有一件事要记住：如果您使用 `Response` 并且 Quarkus 无法确定被序列化的 bean，则需要使用 `@RegisterForReflection` 注解它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is developed by a third party and is part of the Quarkus Platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此扩展程序由第三方开发，是 Quarkus 平台的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Kafka-related extension is present (e.g. `quarkus-smallrye-reactive-messaging-kafka`), Dev Services for Kafka automatically starts a Kafka broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果有任何Kafka相关的扩展（如 `quarkus-smallrye-reactive-messaging-kafka` ），Kafka开发服务会在开发模式和运行测试时自动启动一个Kafka broker。所以您不需要手动启动broker。这是由应用程序是自动配置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because starting a Kafka broker can be long, Dev Services for Kafka uses https://vectorized.io/redpanda[Redpanda], a Kafka compatible broker which starts in ~1 second.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为启动Kafka broker的时间可能很长，所以Kafka开发服务使用了 link:https://vectorized.io/redpanda[Redpanda] ，这是一个与Kafka兼容的broker，而且启动时间仅为1秒左右。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用/禁用Kafka开发服务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka is automatically enabled unless:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的开发服务是自动启用的，除非：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `kafka.bootstrap.servers` is configured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置了 `kafka.bootstrap.servers` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker address using `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的开发服务依赖于Docker来启动broker。如果您的环境不支持Docker，您需要手动启动broker，或者连接到一个已经运行的broker。您可以使用 `kafka.bootstrap.servers` 来配置broker地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for Kafka implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大多数情况下，您需要在应用程序之间共享broker。Kafka的开发服务实现了一个 _服务发现(service discovery)_ 机制，可以让您的多个在 _开发_ 模式下运行的Quarkus应用程序共享一个broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka starts the container with the `quarkus-dev-service-kafka` label which is used to identify the container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka开发服务用 `quarkus-dev-service-kafka` 标签来启动容器，该标签用于识别容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.kafka.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `kafka`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要多个（共享的）broker，您可以配置 `quarkus.kafka.devservices.service-name` 属性并指明broker的名称。它会查询一个具有相同名称的容器，如果找不到的话就启动一个新的容器。默认的服务名称是 `kafka` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下，共享是默认启用的，但在测试模式下是禁用的。您可以用 `quarkus.kafka.devservices.shared=false` 停用共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Kafka picks a random port and configures the application.  You can set the port by configuring the `quarkus.kafka.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Kafka开发服务会随机挑选一个端口并配置应用程序。您可以通过配置 `quarkus.kafka.devservices.port` 属性来设置端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the Kafka advertised address is automatically configured with the chosen port.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，Kafka的广告地址(advertised address)会自动配置为所选择的端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Kafka topics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Kafka主题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Dev Services for Kafka to create topics once the broker is started.  Topics are created with given number of partitions and 1 replica.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以配置Kafka开发服务来在broker启动后创建主题。主题以给定的分区数量以及1个副本创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example creates a topic named `test` with 3 partitions, and a second topic named `messages` with 2 partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子创建了一个名为 `test` ，有3个分区的主题，以及另一个名为 `messages` ，有2个分区的主题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a topic already exists with the given name, the creation is skipped, without trying to re-partition the existing topic to a different number of partitions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果具有某个指定名称的主题已经存在，那么创建会被跳过，并且不会尝试对已经存在的主题重新分区到不同的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure timeout for Kafka admin client calls used in topic creation using `quarkus.kafka.devservices.topic-partitions-timeout`, it defaults to 2 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过 `quarkus.kafka.devservices.topic-partitions-timeout` 来配置在主题创建中所使用的Kafka管理员客户端调用的超时时间，默认为2秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Micrometer metrics library for runtime and application metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南展示了您的Quarkus应用程序如何利用Micrometer metrics库测量运行时和应用程序metrics。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apart from application-specific metrics, which are described in this guide, you may also utilize built-in metrics exposed by various Quarkus extensions. These are described in the guide for each particular extension that supports built-in metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了在本指南中所述的一些的应用特定的metrics之外，您也可以利用各种Quarkus扩展所暴露的内置metrics。这些将在支持内置metrics的每个特定扩展的指南中描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer is the recommended approach to metrics for Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer是Quarkus推荐的metrics度量库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer defines a core library providing a registration mechanism for Metrics, and core metric types (Counters, Gauges, Timers, Distribution Summaries, etc.). These core types provide an abstraction layer that can be adapted to different backend monitoring systems. In essence, your application (or a library) can `register` a `Counter`, `Gauge`, `Timer`, or `DistributionSummary` with a `MeterRegistry`. Micrometer will then delegate that registration to one or more implementations, where each implementation handles the unique considerations for the associated monitoring stack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer定义了一个核心库为Metrics提供注册机制，以及核心metric类型（Counters、Gauges、Timers、Distribution Summaries等）。这些核心类型提供了一个抽象层，以适应不同的后端监控系统。从本质上讲，您的应用程序（或一个库）可以向 `MeterRegistry` `注册` 一个 `Counter` ， `Gauge` ， `Timer` ，或 `DistributionSummary` 。Micrometer会将该注册委托给一个或多个实现，每个实现都会处理相关监控栈的特定考虑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer uses naming conventions to translate between registered Meters and the conventions used by various backend registries. Meter names, for example, should be created and named using dots to separate segments, `a.name.like.this`.  Micrometer then translates that name into the format that the selected registry prefers. Prometheus uses underscores, which means the previous name will appear as `a_name_like_this` in Prometheus-formatted metrics output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer使用了一套命名规范来翻译已注册的Meters和各种后端registries使用的规范。例如，Meters名称的创建和命名应使用点来分隔各段，如 `a.name.like.this` 。之后Micrometer会将该名称翻译成所选registries使用的格式。Prometheus使用的是下划线，这意味着之前的名称在Prometheus的格式的metrics输出中会显示为 `a_name_like_this` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  You can skip right to the solution if you prefer. Either:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议您按照下面几节的说明，一步一步地创建应用程序。您也可以直接跳到解决方案。或者：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the git repository: `git clone {quickstarts-clone-url}`, or</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>克隆git存储库。 `git clone {quickstarts-clone-url}` ，或</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下载这个 {quickstarts-archive-url}[档案] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Micrometer extensions are structured similarly to Micrometer itself: `quarkus-micrometer` provides core micrometer support and runtime integration and other Quarkus and Quarkiverse extensions bring in additional dependencies and requirements to support specific monitoring systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Micrometer扩展的结构与Micrometer本身类似： `quarkus-micrometer` 提供核心Micrometer支持和运行时集成，其他Quarkus和Quarkiverse扩展提供额外的依赖和需求，以支持相应的监控系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this example, we'll use the Prometheus registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个例子中，我们将使用Prometheus registry。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, that imports the `micrometer-registry-prometheus` extension as a dependency.  This extension will load the core `micrometer` extension as well as additional library dependencies required to support prometheus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven项目，将 `micrometer-registry-prometheus` 扩展作为一个依赖导入。该扩展将加载核心的 `micrometer` 扩展，以及支持Prometheus所需的其他依赖项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `micrometer-registry-prometheus` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您已有配置好的Quarkus项目，您可以通过在您的项目根目录下运行以下命令来将 `micrometer-registry-prometheus` 扩展添加到您的项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer provides an API that allows you to construct your own custom metrics. The most common types of meters supported by monitoring systems are gauges, counters, and summaries. The following sections build an example endpoint, and observes endpoint behavior using these basic meter types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer提供了一个API，允许您构建自己的自定义度量。监测系统支持的最常见的meters类型是gauges、counters和summaries。下面的章节构建了一个示例节点，并使用这些基本的meter类型观察节点行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To register meters, you need a reference to a `MeterRegistry`, which is configured and maintained by the Micrometer extension. The `MeterRegistry` can be injected into your application as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要注册meters，您需要一个对 `MeterRegistry` 的引用，该引用由Micrometer扩展配置和维护。 `MeterRegistry` 可以按以下方式注入到您的应用程序中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer maintains an internal mapping between unique metric identifier and tag combinations and specific meter instances. Using `register`, `counter`, or other methods to increment counters or record values does not create a new instance of a meter unless that combination of identifier and tag/label values hasn't been seen before.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer在唯一的metric标识和标签组合与对应的meter实例之间维护着一种内部映射关系。使用 `register` , `counter` , 或其他方法来增加counters或记录的数值并不会创建一个新的meter实例，除非该标识符和标记/标签值的组合以前未曾出现过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gauges measure a value that can increase or decrease over time, like the speedometer on a car. Gauges can be useful when monitoring the statistics for a cache or collection. Consider the following simple example that observes the size of a list:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gauges测量的是一个可以随时间增加或减少的数值，就像汽车上的车速表。Gauges在监控一个缓存或集合的统计数据时很有用。考虑下面这个观察列表大小的简单例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to note that gauges are sampled rather than set; there is no record of how the value associated with a gauge might have changed between measurements. In this example, the size of the list is observed when the Prometheus endpoint is visited.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注意的是，gauges是采样的，而不是设置的；因而与一个gauge相关的值在不同的测量之间可能会发生怎样的变化将无从记录。在本例中，列表的大小会在访问Prometheus节点时被观察到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer provides a few additional mechanisms for creating gauges. Note that Micrometer does not create strong references to the objects it observes by default. Depending on the registry, Micrometer either omits gauges that observe objects that have been garbage-collected entirely or uses `NaN` (not a number) as the observed value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer提供了一些额外的机制来创建gauges。请注意，Micrometer在默认情况下不会对它所观察的对象创建强引用。根据其所在的registry，Micrometer要么完全省略掉观察已经被垃圾收集的对象的gauge，要么使用 `NaN` （not a umber - 不是数字）作为观察值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When should you use a Gauge? Only if you can't use something else. Never gauge something you can count. Gauges can be less straight-forward to use than counters. If what you are measuring can be counted (because the value always increments), use a counter instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么时候应该使用Gauge？只有在您无法使用其他测量值的时候。不要对您可以计算的东西使用gauge。Gauges的使用可能没有counters那么直白。如果您要测量的东西可以计数（因为数值总是递增的），就用counter代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counters are used to measure values that only increase. In the example below, you will count the number of times you test a number to see if it is prime:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Counters是用来测量只增加的数值的。在下面的例子中，您将统计您测试一个数字是否是质数的次数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might be tempting to add a label or tag to the counter indicating what value was checked, but remember that each unique combination of metric name (`example.prime.number`) and label value produces a unique time series. Using an unbounded set of data as label values can lead to a "cardinality explosion", an exponential increase in the creation of new time series.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上代码打算给counter添加一个标签来表明是什么值被检查了，但是请记住，metric名称( `example.prime.number` )和标签值的每个独特组合只会产生一个唯一的时间序列。使用未绑定的数据集来作为标签值会导致 "基数爆炸(cardinality explosion)"，即新的时间序列的创建会呈指数级增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Label and tag can be used interchangably. You may also see "attribute" used in this context in some documentation.  The gist is each that each label or tag or attribute defines an additional bit of information associated with the single numerical measurement that helps you classify, group, or aggregate the measured value later. The Micrometer API uses `Tag` as the mechanism for specifying this additional data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Label和tag可以互换使用。您也可能在一些文档中看到 "属性 "在类似的上下文中使用。要点是每个标签，标记或属性都定义了与一个单一数字测量值相关的一组额外信息，以帮助您以后对测量值进行分类、分组或汇总。Micrometer API使用 `Tag` 作为指定这种额外数据的机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to add a tag that would convey a little more information, however. Let's adjust our code, and move the counter to add some tags to convey additional information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不过添加一个标签以传达更多的信息也是有可能的。让我们调整我们的代码，改动一下counter来添加一些标签以传达更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looking at the data produced by this counter, you can tell how often a negative number was checked, or the number one, or an even number, and so on. Try the following sequence and look for `example_prime_number_total` in the plain text output. Note that the `_total` suffix is added when Micrometer applies Prometheus naming conventions to `example.prime.number`, the originally specified counter name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>看一下这个counter产生的数据，您可以看到负数或者数字1被或者偶数等被检查的频率。尝试以下命令，并在文本输出中查找 `example_prime_number_total` 。请注意，当Micrometer将Prometheus命名规则应用于 `example.prime.number` ，即最初指定的counter名称时，会添加后缀 `_total` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When should you use a counter? Only if you are doing something that can not be either timed (or summarized).  Counters only record a count, which may be all that is needed. However, if you want to understand more about how a value is changing, a timer (when the base unit of measurement is time) or a distribution summary might be more appropriate.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么什么时候使用counter呢？只有当您正在做的事情不能被计时(timed）（或总结summarized）的时候。counter只记录一个计数值，而这个值可能就是所需的全部。但是，如果您想更多地了解一个值是如何变化的，那么timer（当基本的测量单位是时间时）或distribution summary可能更合适。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Timers and distribution summaries in Micrometer are very similar. Both allow you to record an observed value, which will be aggregated with other recorded values and stored as a sum. Micrometer also increments a counter to indicate the number of measurements that have been recorded and tracks the maximum observed value (within a decaying interval).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer中的Timers和distribution summaries非常相似。两者都允许您记录这样一种观察值，它将与其他记录值汇总并作为一个总和来被记录。Micrometer也会使用一个counter来表示已经记录的测量值的个数，并且跟踪最大的观察值（在一个衰减的区间内）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distribution summaries are populated by calling the `record` method to record observed values, while timers provide additional capabilities specific to working with time and measuring durations. For example, we can use a timer to measure how long it takes to calculate prime numbers using one of the `record` methods that wraps the invocation of a Supplier function:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Distribution summaries是通过调用 `record` 方法来记录观测值，而timers则提供了专门用于处理时间和测量持续时间的额外功能。例如，我们可以通过如下方式使用一个timer来测量计算素数所需的时间：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer will apply Prometheus conventions when emitting metrics for this timer. Prometheus measures time in seconds.  Micrometer converts measured durations into seconds and includes the unit in the metric name, per convention. After visiting the prime endpoint a few more times, look in the plain text output for the following three entries: `example_prime_number_test_seconds_count`, `example_prime_number_test_seconds_sum`, and `example_prime_number_test_seconds_max`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer在为这个timer发送metrics时将应用Prometheus规范。Prometheus测量时间的单位是秒。Micrometer会将测量的持续时间转换为秒，并按照规范在metric名称中包含单位。再访问几次prime节点后，在文本输出中寻找以下三个条目： `example_prime_number_test_seconds_count` , `example_prime_number_test_seconds_sum` , 和 `example_prime_number_test_seconds_max` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both timers and distribution summaries can be configured to emit additional statistics, like histogram data, precomputed percentiles, or service level objective (SLO) boundaries. Note that the count, sum, and histogram data can be re-aggregated across dimensions (or across a series of instances), while precomputed percentile values cannot.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Timers和distritution summaries都可以被配置为发送额外的统计数据，如hitogram数据、预计算的百分位数或service level object（SLO）的边界值。请注意，计数、总和和histogram数据可以跨维度（或跨一系列实例）重新汇总，而预计算的百分数则不能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Review automatically generated metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>审查自动生成的metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To view metrics, execute `curl localhost:8080/q/metrics/`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要查看metrics，请执行 `curl localhost:8080/q/metrics/`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Micrometer extension automatically times HTTP server requests. Following Prometheus naming conventions for timers, look for `http_server_requests_seconds_count`, `http_server_requests_seconds_sum`, and `http_server_requests_seconds_max`. Dimensional labels have been added for the requested uri, the HTTP method (GET, POST, etc.), the status code (200, 302, 404, etc.), and a more general outcome field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer扩展会自动为HTTP服务器请求计时。按照Prometheus对timers的命名惯例，查找 `http_server_requests_seconds_count` , `http_server_requests_seconds_sum` , 和 `http_server_requests_seconds_max` 。维度标签已经被添加到请求的URI、HTTP方法（GET、POST等）、状态代码（200、302、404等）和一个更通用的结果字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that metrics appear lazily, you often won't see any data for your endpoint until something tries to access it, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，metric是延迟出现的，您通常不会看到您的节点的任何数据，直到有请求试图访问它，等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ignoring endpoints</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>忽略节点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable measurement of HTTP endpoints using the `quarkus.micrometer.binder.http-server.ignore-patterns` property. This property accepts a comma-separated list of simple regex match patterns identifying URI paths that should be ignored. For example, setting `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` will ignore a request to `http://localhost:8080/example/prime/7919`. A request to `http://localhost:8080/example/gauge/7919` would still be measured.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以使用 `quarkus.micrometer.binder.http-server.ignore-patterns` 属性禁用对HTTP节点的测量。这个属性接受一个用逗号分隔的简单正则表达式匹配的列表来识别应被忽略的URI路径。例如， `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` 会忽略对 `&lt;a href="http://localhost:8080/example/prime/7919" class="bare"&gt;http://localhost:8080/example/prime/7919&lt;/a&gt;` 请求的监测。而一个对 `&lt;a href="http://localhost:8080/example/gauge/7919" class="bare"&gt;http://localhost:8080/example/gauge/7919&lt;/a&gt;` 的请求仍会被监测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The micrometer extension will make a best effort at representing URIs containing path parameters in templated form.  Using examples from above, a request to `http://localhost:8080/example/prime/7919` should appear as an attribute of `http_server_requests_seconds_*` metrics with a value of `uri=/example/prime/{number}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer扩展将尽最大努力以模板的形式表示包含路径参数的URI。使用上面的例子，一个对 `&lt;a href="http://localhost:8080/example/prime/7919" class="bare"&gt;http://localhost:8080/example/prime/7919&lt;/a&gt;` 的请求应该作为 `http_server_requests_seconds_*` metrics 的一个属性出现，其值为 `uri=/example/prime/{number}` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `quarkus.micrometer.binder.http-server.match-patterns` property if the correct URL can not be determined. This property accepts a comma-separated list defining an association between a simple regex match pattern and a replacement string. For example, setting `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` would use the value `/example/{jellybeans}` for the uri attribute any time the requested uri matches `/example/prime/[0-9]+`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果不能确定正确的URL，请使用 `quarkus.micrometer.binder.http-server.match-patterns` 属性。这个属性使用一个逗号分隔的列表来定义一个简单的正则匹配模式和对应的替换字符串之间的关联。例如，设置成 `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` ，则可以请求的URI与 `/example/prime/[0-9]+` 匹配时为URI属性使用 `/example/{jellybeans}` 的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using MeterFilter to configure metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用MeterFilter来配置metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer uses `MeterFilter` instances to customize the metrics emitted by `MeterRegistry` instances.  The Micrometer extension will detect `MeterFilter` CDI beans and use them when initializing `MeterRegistry` instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer使用 `MeterFilter` 实例来定制 `MeterRegistry` 实例发出的metrics。Micrometer扩展将检测 `MeterFilter` CDI beans，并在初始化 `MeterRegistry` 实例时使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, a singleton CDI bean will produce two different `MeterFilter` beans. One will be applied only to Prometheus `MeterRegistry` instances (using the `@MeterFilterConstraint` qualifier), and another will be applied to all `MeterRegistry` instances. An application configuration property is also injected and used as a tag value.  Additional examples of MeterFilters can be found in the link:https://micrometer.io/docs/concepts[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这个例子中，一个CDI bean单例将产生两个不同的 `MeterFilter` beans。一个将只用于Prometheus `MeterRegistry` 实例（使用 `@MeterFilterConstraint` 修饰符），另一个将用于所有 `MeterRegistry` 实例。一个应用配置属性也被注入并作为标签值使用。MeterFilters的其他例子可以在 link:https://micrometer.io/docs/concepts[官方文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does Micrometer support annotations?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer支持注解吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer does define two annotations, `@Counted` and `@Timed`, that can be added to methods. The `@Timed` annotation will wrap the execution of a method and will emit the following tags in addition to any tags defined on the annotation itself: class, method, and exception (either "none" or the simple class name of a detected exception).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometer确实也定义了两个注解， `@Counted` 和 `@Timed` ，它们可以被添加到方法中。 `@Timed` 注解将修饰一个方法的执行。除了注解本身定义的标签外，还将添加以下标签：类名、方法名和异常（"none "或检测到的异常的简单类名）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using annotations is limited, as you can't dynamically assign meaningful tag values. Also note that many methods, e.g.  REST endpoint methods or Vert.x Routes, are counted and timed by the micrometer extension out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用注解是被限制的，因为您不能动态地分配有意义的标签值。还要注意的是，许多方法的计数和计时，例如REST节点方法或Vert.x Routes，Micrometer扩展都支持开箱即用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using other Registry implementations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用其他Registry实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you aren't using Prometheus, you have a few options. Some Micrometer registry implementations have been wrapped in https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse extensions].  To use the Micrometer StackDriver MeterRegistry, for example, you would use the `quarkus-micrometer-registry-stackdriver` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您不使用Prometheus，您可以有其他选择。一些Micrometer registry的实现已经包含在 link:https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse扩展] 中了。例如，要使用Micrometer StackDriver MeterRegistry，您可以使用 `quarkus-micrometer-registry-stackdriver` 扩展：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the Micrometer registry you would like to use does not yet have an associated extension, use the `quarkus-micrometer` extension and bring in the packaged MeterRegistry dependency directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想使用的Micrometer registry还没有对应的扩展，请使用 `quarkus-micrometer` 扩展，并直接添加已打包的MeterRegistry依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will then need to specify your own provider to configure and initialize the MeterRegistry, as discussed in the next section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，您将需要指定自定义的provider来配置和初始化MeterRegistry，我们将在下一节讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a customized MeterRegistry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个自定义的MeterRegistry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a custom `@Produces` method to create and configure a customized `MeterRegistry` if you need to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果需要的话，请使用自定义的 `@Produces` 方法来创建和配置一个自定义的 `MeterRegistry` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example customizes the line format used for StatsD:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面的例子自定义了用于StatsD的行格式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This example corresponds to the following instructions in the Micrometer documentation: https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个例子对应于Micrometer文档中的以下说明 https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the method returns the specific type of `MeterRegistry` as a `@Singleton`. Use MicroProfile Config to inject any configuration attributes you need to configure the registry. Most Micrometer registry extensions, like `quarkus-micrometer-registry-statsd`, define a producer for registry-specific configuration objects that are integrated with the Quarkus configuration model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，该方法返回了一个特定类型的 `MeterRegistry` 的 `@Singleton` 。使用MicroProfile Config来注入任何您需要更改registry的配置属性。大多数Micrometer registry扩展，如 `quarkus-micrometer-registry-statsd` ，为registry特定的配置对象定义了一个用于与Quarkus配置模型集成的生产者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the MicroProfile Metrics API in your application, the Micrometer extension will create an adaptive layer to map those metrics into the Micrometer registry. Note that naming conventions between the two systems is different, so the metrics that are emitted when using MP Metrics with Micrometer will change.  You can use a `MeterFilter` to remap names or tags according to your conventions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您在您的应用程序中使用MicroProfile Metrics API，Micrometer扩展将创建一个自适应层l来把这些metrics映射到Micrometer registry中。注意，两个系统之间的命名规则是不同的，所以在Micrometer中使用MP Metrics时发出的metrics将发生变化。您可以使用 `MeterFilter` ，根据您的规范重新映射名称或标签。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MP Metrics API compatibility layer will be moved to a different extension in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MP Metrics API 的兼容层会在将来迁移至另外的扩展中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.vertx.ConsumeEvent;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.vertx.ConsumeEvent;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的例子使用了Mutiny响应式类型。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置地址</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@ConsumeEvent` annotation can be configured to set the address:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以配置 `@ConsumeEvent` 注解设置地址：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receive the messages sent to the `greeting` address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收发送到 `greeting` 地址的信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also return a `Uni&lt;T&gt;` or a `CompletionStage&lt;T&gt;` to handle asynchronous reply:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以返回一个 `Uni&lt;T&gt;` 或一个 `CompletionStage&lt;T&gt;` 来处理异步回复：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject an `executor` if you use the Context Propagation extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Context Propagation扩展，你可以注入一个 `executor` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing fire and forget interactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>实现即发即弃（fire and forget）交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dealing with messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling Failures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send a message to the address `greeting`. Message payload is `name`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送消息到地址 `greeting` 。消息的有效载荷是 `name` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `EventBus` object provides methods to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`EventBus` 对象提供了以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`send` a message to a specific address - one single consumer receives the message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`send` 一个消息到一个特定的地址 - 单个消费者收到该消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`publish` a message to a specific address - all consumers receive the messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`publish` 向一个特定的地址发送消息--所有的消费者都会收到这些消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand, let's detail how the HTTP request/response has been handled:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了更好地理解，让我们详细介绍一下HTTP request/response 是如何被处理的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another bean receives this message and computes the response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>另一个Bean收到这个消息，并计算出响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This response is sent back using the reply mechanism</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用回复机制发回此响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the reply is received by the sender, the content is written to the HTTP response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦发送方收到回复，会将内容写入 HTTP 响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using codecs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用编解码器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default codec for local delivery.  So you can exchange objects as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x事件总线] 使用编解码器来 _序列化_ 和 _反序列化_ 对象。Quarkus为本地交付提供了一个默认的编解码器。所以你可以按以下方式交换对象：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the name of the codec to use to send the message</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置用于发送消息的编解码器的名称</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the codec to use to receive the message</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>设置用于接收信息的编解码器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io[Vert.x] is a toolkit for building reactive applications.  As described in the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture], Quarkus uses Vert.x underneath.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io[Vert.x] 是一个用于构建响应式应用程序的工具集。正如 link:quarkus-reactive-architecture.html[Quarkus响应式架构] 中所描述的，下面，Quarkus将使用Vert.x。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the companion to the xref:vertx.adoc[Using Eclipse Vert.x API from a Quarkus Application] guide.  It provides more advanced details about the usage and the configuration of the Vert.x instance used by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是《 link:vertx.html[从Quarkus应用程序中使用Eclipse Vert.x API] 》指南的补充。它提供了关于Quarkus使用的Vert.x实例的使用和配置的更多高级细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问Vert.x实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To access the managed Vert.x instance, add the `quarkus-vertx` extension to your project.  Note that this dependency may already be installed (as a transitive dependency).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要访问管理的Vert.x实例，请在你的项目中添加 `quarkus-vertx` 扩展。注意，这个依赖可能已经安装了（作为一个过渡性依赖）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this extension, you can retrieve the managed instance of Vert.x using either field or constructor injection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过这个扩展，你可以使用字段或构造函数注入检索Vert.x的托管实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject either the:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以这样注入：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend using the Mutiny variant as it integrates with the other reactive APIs provided by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们推荐使用Mutiny变体，因为它可以与Quarkus提供的其他响应式API集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的响应式编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation about the Vert.x Mutiny variant is available on https://smallrye.io/smallrye-mutiny-vertx-bindings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于Vert.x Mutiny变体的文档可在 https://smallrye.io/smallrye-mutiny-vertx-bindings </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置Vert.x实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Vert.x instance from the `application.properties` file.  The following table lists the supported properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以从 `application.properties` 文件中配置Vert.x实例。下表列出了支持的属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 Vert.x 客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to Vert.x core, you can use most Vert.x ecosystem libraries.  Some Quarkus extension already wraps Vert.x libraries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了Vert.x核心，你可以使用大多数Vert.x生态系统库。一些Quarkus扩展已经包装了Vert.x库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Available APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可用的API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table lists the most used libraries from the Vert.x ecosystem.  To access these APIs, add the indicated extension or dependency to your project.  Refer to the associated documentation to learn how to use them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下表列出了Vert.x生态系统中最常用的库。要访问这些API，请在你的项目中添加指定的扩展或依赖性。请参考相关文档，了解如何使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension or Dependency</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展或依赖性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/amqp </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Circuit Breaker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>熔断器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/vertx-circuit-breaker/java/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://vertx.io/docs/vertx-circuit-breaker/java/ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/vertx-consul-client/java/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://vertx.io/docs/vertx-consul-client/java/ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/reactive-sql-clients </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/kafka </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mail Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>邮件客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/mailer </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/mqtt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/mqtt </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/vertx-rabbitmq-client/java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://vertx.io/docs/vertx-rabbitmq-client/java </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://quarkus.io/guides/redis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://cn.quarkus.io/guides/redis </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/vertx-web-client/java/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> https://vertx.io/docs/vertx-web-client/java/ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn more about the usage of the Vert.x Mutiny API, refer to https://smallrye.io/smallrye-mutiny-vertx-bindings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要了解更多关于Vert.x Mutiny API的用法，请参考 https://smallrye.io/smallrye-mutiny-vertx-bindings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example of usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, in your code, you can create an instance of `WebClient`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，在你的代码中，你可以创建一个 `WebClient` 的实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource creates a `WebClient` and, upon request, uses this client to invoke a remote HTTP API.  Depending on the result, the response is forwarded as received, or it creates a JSON object wrapping the error.  The `WebClient` is asynchronous (and non-blocking), to the endpoint returns a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该资源创建了一个 `WebClient` ，并在请求时使用该客户端来调用远程HTTP API。根据结果，响应被转发，或者创建一个包含错误的 JSON 对象。 `WebClient` 是异步的（和非阻塞的），端点返回一个 `Uni` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application can also run as a native executable.  But, first, we need to instruct Quarkus to enable _ssl_ (if the remote API uses HTTPS).  Open the `src/main/resources/application.properties` and add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该应用程序也可以作为一个本地可执行文件运行。但是，首先，我们需要指示Quarkus启用 _ssl_ （如果远程API使用HTTPS）。打开 `src/main/resources/application.properties` ，并添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，用以下方法创建本地可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x JSON</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x JSON</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x APIs often rely on JSON.  Vert.x provides two convenient classes to manipulate JSON document: `io.vertx.core.json.JsonObject` and `io.vertx.core.json.JsonArray`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x的API经常依赖JSON。Vert.x提供了两个方便的类来操作JSON文档： `io.vertx.core.json.JsonObject` 和 `io.vertx.core.json.JsonArray` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`JsonObject` can be used to map an object into its JSON representation and build an object from a JSON document:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`JsonObject` 可用于将一个对象映射到其JSON表示中，并从JSON文档中建立一个对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that these features use the mapper managed by the `quarkus-jackson` extension.  Refer to xref:rest-json.adoc#json[Jackson configuration] to customize the mapping.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，这些功能使用由 `quarkus-jackson` 扩展管理的映射器。请参考 link:rest-json.html#json[Jackson的配置] 来自定义映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Object and JSON Array are both supported as Quarkus HTTP endpoint requests and response bodies (using classic RESTEasy and RESTEasy Reactive).  Consider these endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON Object和JSON Array都支持作为Quarkus HTTP端点的请求和响应体（使用经典的RESTEasy和RESTEasy Reactive）。考虑一下这些端点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello/Quarkus/object returns:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> http://localhost:8080/hello/Quarkus/object 返回：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello/Quarkus/array returns:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> http://localhost:8080/hello/Quarkus/array 返回：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works equally well when the JSON content is a request body or is wrapped in a `Uni`, `Multi`, `CompletionStage` or `Publisher`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当JSON内容是一个请求体或被包裹在一个 `Uni` , `Multi` , `CompletionStage` 或 `Publisher` 中时，这同样适用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying verticles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署verticles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy _verticles_ in Quarkus.  It supports:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在Quarkus中部署 _verticles_ 。它支持：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_bare_ verticle - 延伸的Java类 `io.vertx.core.AbstractVerticle` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> _Mutiny_ verticle - 扩展的Java类 `io.smallrye.mutiny.vertx.core.AbstractVerticle` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example explaining how to deploy verticles during the initialization of the application will follow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接下来会有一个例子解释如何在应用程序的初始化过程中部署verticles：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package io.quarkus.vertx.verticles;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package io.quarkus.vertx.verticles;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @ConfigProperty(name = "address") String address;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @ConfigProperty(name = "address") String address;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, deploy the verticle instances with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，用以下方法部署verticle实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy every exposed `AbstractVerticle`, you can use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想部署每个暴露的 `AbstractVerticle` ，你可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x comes with a built-in https://vertx.io/docs/vertx-core/java/#event_bus[event bus] that you can use from your Quarkus application.  So, your application components (CDI beans, resources...) can interact using asynchronous events, thus promoting loose-coupling.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x有一个内置的 link:https://vertx.io/docs/vertx-core/java/#event_bus[事件总线] ，你可以从你的Quarkus应用程序中使用。因此，你的应用程序组件（CDI Bean、resources......）可以使用异步事件进行交互，从而促进松散耦合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the event bus, you send _messages_ to _virtual addresses_.  The event bus offers three types of delivery mechanisms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过事件总线，你可以向 _virtual addresses_ 发送 _messages_。事件总线提供三种类型的传递机制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round-robin is applied;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>point-to-point - 发送消息，一个消费者接收。如果有几个消费者监听该地址，则采用轮流的方式；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>publish/subscribe - publish a message; all the consumers listening to the address are receiving the message;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>publish/subscribe - 发布一个消息；所有监听该地址的消费者都在接收该消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous fashion.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>request/reply - 发送消息并期望得到响应。接收者可以以异步的方式对消息作出回应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All these delivery mechanisms are non-blocking and are providing one of the fundamental bricks to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有这些交付机制都是无阻塞的，并提供了构建响应式应用的基本砖块之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you can use the Vert.x API to register consumers, Quarkus comes with declarative support.  To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然你可以使用Vert.x的API来注册消费者，但Quarkus带有声明性支持。要消费事件，请使用 `io.quarkus.vertx.ConsumeEvent` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, the address is the fully qualified name of the bean; for instance, in this snippet, it's `org.acme.vertx.GreetingService`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置，地址是Bean的完全限定名称；例如，在这个片段中，它是 `org.acme.vertx.GreetingService` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter is the message body. If the method returns _something_, it's the message response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>方法参数是消息主体。如果该方法返回 _something_ ，那就是消息的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>异步处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous examples use synchronous processing.  Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的例子使用了同步处理。异步处理也可以通过返回一个 `io.smallrye.mutiny.Uni` 或一个 `java.util.concurrent.CompletionStage` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the code consuming the event must be _non-blocking_, as it's called on an I/O thread.  If your processing is blocking, use the `@io.smallrye.common.annotation.Blocking` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，消费该事件的代码必须是 _非阻塞的_ ，因为它是在一个I/O线程上调用的。如果你的处理是阻塞的，请使用 `@io.smallrye.common.annotation.Blocking` 注解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can use the `blocking` attribute from the `@ConsumeEvent` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，你可以使用 `@ConsumeEvent` 注解中的 `blocking` 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@Blocking`, it ignores the value of the `blocking` attribute of `@ConsumeEvent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `@Blocking` ，它忽略了 `blocking` 属性的值 `@ConsumeEvent` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replying to messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>回复信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _return_ value of a method annotated with `@ConsumeEvent` is used to respond to the incoming message.  For instance, in the following snippet, the returned `String` is the response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用 `@ConsumeEvent` 注解的方法的 _返回值_ 被用来响应传入的消息。例如，在下面的代码片段中，返回的 是 `String` 类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to reply to received messages.  Typically, for a _fire and forget_ interaction, the messages are consumed, and the sender does not need to know about it.  To implement this pattern, your consumer method returns `void`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不需要回复收到的消息。通常情况下，对于 _fire 和 forget_ 交互来说，消息被消耗掉了，发送者不需要知道这件事。为了实现这种模式，你的消费者方法返回 `void` 类型 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the previous example using the _payloads_ directly, you can also use `Message` directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与之前直接使用 _有效载荷_ 的例子不同，你也可以直接使用 `Message` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a method annotated with `@ConsumeEvent` throws an exception, then:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个用 `@ConsumeEvent` 注解的方法抛出一个异常，那么：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if a reply handler is set, then the failure is propagated back to the sender via an `io.vertx.core.eventbus.ReplyException` with code `ConsumeEvent#FAILURE_CODE` and the exception message,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置了一个回复处理程序，那么失败就会通过一个带有代码 `ConsumeEvent#FAILURE_CODE` 和异常消息的 `io.vertx.core.eventbus.ReplyException` 传播回发送者，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if no reply handler is set, then the exception is rethrown (and wrapped in a `RuntimeException` if necessary) and can be handled by the default exception handler, i.e. `io.vertx.core.Vertx#exceptionHandler()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置回复处理程序，那么异常会被重新抛出（如果需要的话，会被包裹在一个 `RuntimeException` ），并且可以由默认的异常处理程序来处理，即 `io.vertx.core.Vertx#exceptionHandler()` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending and publishing messages use the Vert.x event bus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>发送和发布消息使用Vert.x事件总线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use a specific codec, you need to set it on both ends explicitly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用一个特定的编解码器，你需要在两端明确地设置它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining HTTP and the event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>结合HTTP和事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.  It uses the request/reply dispatching mechanism.  Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.  Another bean consumes this message, and the response is sent using the _reply_ mechanism.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们重新访问一个响应的HTTP端点，并使用异步消息传递将调用委托给一个单独的bean。它使用了request/reply的调度机制。我们不是在JAX-RS端点内实现业务逻辑，而是发送一个消息。另一个Bean使用这个消息，并使用 _回复_ 机制发送响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your HTTP endpoint class, inject the event bus and uses the `request` method to send a message to the event bus and expect a response:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的HTTP端点类中，注入事件总线，并使用 `request` 方法向事件总线发送一个消息，并期待一个响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the HTTP method returns a `Uni`.  If you are using RESTEasy Reactive, `Uni` support is built-in.  If you are using _classic_ RESTEasy, you need to add the `quarkus resteasy-mutiny` extension to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP方法返回一个 `Uni` 。如果你使用的是RESTEasy Reactive， `Uni` 支持是内置的。如果你使用的是 _经典的_ RESTEasy，你需要在你的项目中添加 `quarkus resteasy-mutiny` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need a consumer listening on the `greeting` address.  This consumer can be in the same class or another bean such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要一个消费者监听 `greeting` 地址。这个消费者可以在同一个类中，也可以是另一个Bean，比如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean receives the name and returns the greeting message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个Bean接收名字并返回响应信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this in place, every HTTP request on `/bus/quarkus` sends a message to the event bus, waits for a reply, and when this one arrives, writes the HTTP response:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了这个， `/bus/quarkus` 上的每个HTTP请求都会向事件总线发送一个消息，等待回复，当这个回复到来时，就会写入HTTP响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request is received by the `greeting` method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该请求由 `greeting` 方法接收</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bi-directional communication with browsers using SockJS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用SockJS与浏览器进行双向通信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The SockJS bridge provided by Vert.x allows browser applications and Quarkus applications to communicate using the event bus.  It connects both sides.  So, both sides can send messages received on the other side.  It supports the three delivery mechanisms.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x提供的SockJS桥允许浏览器应用程序和Quarkus应用程序使用事件总线进行通信。它连接了双方。所以，双方都可以发送在另一方收到的消息。它支持三种传递机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SockJS negotiates the communication channel between the Quarkus application and the browser.  If WebSockets are supported, it uses them; otherwise, it degrades to SSE, long polling, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SockJS负责协商Quarkus应用程序和浏览器之间的通信渠道。如果支持WebSockets，它就使用它们；否则，它就退化为SSE、long polling等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So use SockJS, you need to configure the bridge, especially the addresses that will be used to communicate:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，使用SockJS，你需要配置桥梁，特别是将用于通信的地址：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This code configures the SockJS bridge to send all the messages targeting the `ticks` address to the connected browsers.  More detailled explanations about the configuration can be found on https://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge[the Vert.x SockJS Bridge documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这段代码配置了SockJS桥接器，以将所有针对 `ticks` 地址的信息发送到所连接的浏览器。更详细的配置说明可以在 https://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge[Vert.x SockJS Bridge文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The browser must use the `vertx-eventbus` JavaScript library to consume the message:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>浏览器必须使用 `vertx-eventbus` JavaScript库来消费该信：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地运输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native transports are not supported in GraalVM produced binaries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM生产的二进制文件中不支持本地传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x is capable of using https://netty.io/wiki/native-transports.html[Netty's native transports], which offers performance improvements on specific platforms.To enable them, you must include the appropriate dependency for your platform. It's usually a good idea to have both to keep your application platform agnostic. Netty is smart enough to use the correct one, that includes none at all on unsupported platforms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x能够使用 https://netty.io/wiki/native-transports.html[Netty的本地传输] ，在特定的平台上提供性能改进。要启用它们，你必须为你的平台包含适当的依赖。通常，为了保持你的应用程序与平台无关，这是个好主意。Netty很聪明，会使用正确的依赖，包括在不支持的平台上根本不使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will also have to explicitly configure Vert.x to use the native transport.  In `application.properties` add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你还必须明确地配置Vert.x来使用本地传输。在 `application.properties` 中添加：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or in `application.yml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者在 `application.yml` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If all is well quarkus will log:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一切顺利的话，quarkus 会输出以下日志：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Linux Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地Linux传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux you can enable the following socket options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Linux上，你可以启用以下socket选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native MacOS Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本地MacOS传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MacOS Sierra and above you can enable the following socket options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在MacOS Sierra及以上版本，你可以启用以下socket选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening to a Unix Domain Socket</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>监听Unix Domain Socket</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening on a Unix domain socket allows us to dispense with the overhead of TCP if the connection to the quarkus service is established from the same host. This can happen if access to the service goes through a proxy which is often the case if you're setting up a service mesh with a proxy like Envoy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果与 quarkus 服务的连接是从同一主机建立的，那么侦听 Unix 域套接字允许我们免除 TCP 的开销。如果通过代理访问服务可能会发生这种情况，如果您使用 Envoy 等代理设置服务网格，通常会出现这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will only work on platforms that support &lt;&lt;native-transport&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这仅适用于支持 link:#native-transport[[native-transport]] 的平台。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the appropriate &lt;&lt;native-transport&gt;&gt; and set the following environment property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用适当的 link:#native-transport[[native-transport]] 并设置以下环境属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By itself this will not disable the tcp socket which by default will open on `0.0.0.0:8080`. It can be explicitly disabled:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>就其本身而言，这不会禁用默认情况下将在 0.0.0.0:8080 上打开的 tcp socket（套接字）。可以明确禁用它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These properties can be set through Java's `-D` command line parameter or on `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些属性可以通过 Java 的 `-D` 命令行参数或在 `application.properties` 上设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read only deployment environments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>只读部署环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In environments with read only file systems you may receive errors of the form:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在具有只读文件系统的环境中，您可能会收到以下形式的错误：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assuming `/tmp/` is writable this can be fixed by setting the `vertx.cacheDirBase` property to point to a directory in `/tmp/` for instance in OpenShift by creating an environment variable `JAVA_OPTS` with the value `-Dvertx.cacheDirBase=/tmp/vertx`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>假设 `/tmp/` 是可写的，可以通过将 `vertx.cacheDirBase` 属性设置为指向 `/tmp/` 中的目录来修复此问题，例如在OpenShift中，通过创建一个值为 `-Dvertx.cacheDirBase=/tmp/vertx` ,名为 `JAVA_OPTS` 的环境变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kotlinlang.org/[Kotlin] is a very popular programming language that targets the JVM (amongst other environments). Kotlin has experienced a surge in popularity the last few years making it the most popular JVM language, except for Java of course.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://kotlinlang.org/[Kotlin] 是一种非常流行的基于JVM的编程语言（在其他环境中）。在过去的几年里，Kotlin的受欢迎程度激增，使其成为最受欢迎的JVM语言，当然，除了Java之外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Kotlin as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus为使用Kotlin提供了一流的支持，本指南将对此进行讲解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new Kotlin project. This can be done using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要一个新的Kotlin项目。这可以通过以下命令来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to show a more practical example of Kotlin usage we will add a simple link:https://kotlinlang.org/docs/reference/data-classes.html[data class] called `Greeting.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了展示一个更实际的Kotlin使用例子，我们将像这样添加一个简单的 link:https://kotlinlang.org/docs/reference/data-classes.html[数据类] ，叫做 `Greeting.kt` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated `pom.xml` contains the following modifications compared to its counterpart when Kotlin is not selected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与不选择Kotlin时的对应内容相比，这次生成的 `pom.xml` 包含以下修改：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-kotlin` artifact is added to the dependencies. This artifact provides support for Kotlin in the live reload mode (more about this later on)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-kotlin` 会被添加到依赖项中。这个依赖提供了对实时重载模式下的Kotlin的支持（后面会有更多关于这个的介绍）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `kotlin-stdlib-jdk8` is also added as a dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin-stdlib-jdk8` 也作为依赖被添加进来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `kotlin-maven-plugin` is configured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin-maven-plugin` ，其配置如下。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The important thing to note is the use of the https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] Kotlin compiler plugin.  In order to understand why this plugin is needed, first we need to note that by default all the classes generated from the Kotlin compiler are marked as `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要注意的是，这里使用了 link:https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] 的Kotlin编译器插件。为了理解为什么需要这个插件，首先我们需要注意：在默认情况下，所有从Kotlin编译器生成的类都被标记为 `final` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having `final` classes however does not work well with various frameworks that need to create https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[Dynamic Proxies].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然而，拥有 `final` 类并不能很好地与需要创建 link:https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[动态代理] 的各种框架配合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the `all-open` Kotlin compiler plugin allows us to configure the compiler to *not* mark as `final` classes that have certain annotations. In the snippet above, we have specified that classes annotated with `javax.ws.rs.Path` should not be `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此， `all-open` Kotlin编译器插件允许我们对编译器进行配置，使其 *不* 将有某些注解的类标记为 `final` 。在上面的片段中，我们已经指定了带有 `javax.ws.rs.Path` 注解的类不应该是 `final` 的 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application contains classes annotated with `javax.enterprise.context.ApplicationScoped` for example, then `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` needs to be added as well. Same goes for any class that needs to have a dynamic proxy created at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，如果您的应用程序包含了带有 `javax.enterprise.context.ApplicationScoped` 注解的类，那么也需要添加 `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` 。任何需要在运行时创建动态代理的类也是如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Future versions of Quarkus will configure the Kotlin compiler plugin in a way that will make it unnecessary to alter this configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus的未来版本将以无需更改此配置文件的方式来配置Kotlin编译器插件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to the Maven configuration, when using Gradle, the following modifications are required when Kotlin is selected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与Maven的配置类似，在使用Gradle时，如果选择了Kotlin，则需要做以下修改：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The all-open Kotlin plugin tells the compiler not to mark as final, those classes with the annotations highlighted (customize as required)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>all-open Kotlin插件告诉编译器不要把那些有注解的类标记为final类（可以按需自定义） </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native-image, the use of http (or https) protocol(s) must be declared</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用native-image时，必须声明使用http（或https）协议</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example configuration follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是一个配置实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kotlin plugin version needs to be specified.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>需要指定Kotlin插件的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The all-open configuration required, as per Maven guide above</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>按照上面的Maven指南，需要配置all-open插件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for live reloading changes made to source code. This support is also available to Kotlin, meaning that developers can update their Kotlin source code and immediately see their changes reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了对源代码的实时重载修改的支持。这种支持也适用于Kotlin，这意味着开发者可以更新他们的Kotlin源代码，并立即看到代码更改带来的反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing to note is that the live reload feature is not available when making changes to both Java and Kotlin source that have dependencies on each other. We hope to alleviate this limitation in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一点需要注意的是，当对相互有依赖关系的Java和Kotlin源代码进行修改时，实时重载功能是不可用的。我们希望在未来能缓解这一限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Kotlin data classes with `native-image` you may experience serialization errors that do not occur with the `JVM` version, despite the Kotlin Jackson Module being registered. This is especially so if you have a more complex JSON hierarchy, where an issue on a lower node causes a serialization failure. The error message displayed is a catch-all and typically displays an issue with the root object, which may not necessarily be the case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用Kotlin数据类与 `native-image`  时，尽管Kotlin Jackson模块已被注册，但您可能会遇到JVM版本中不会出现的序列化错误。特别是如果您有一个更复杂的JSON层次结构，低层节点上的问题导致序列化失败。显示的错误消息是一条全面的错误消息，其通常会显示根对象引发了这个问题，但情况可能并非如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ensure full-compability with `native-image`, it is recommended to apply the Jackson `@field:JsonProperty("fieldName")` annotation, and set a nullable default, as illustrated below. You can automate the generation of Kotlin data classes for your sample JSON using Intellij plugins (such as JSON to Kotlin Class), and easily enable the Jackson annotation and select nullable parameters as part of the auto-code generation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了确保与 `native-image` 的完全兼容性，建议使用Jackson `@field:JsonProperty("fieldName")` 注解，并设置一个空默认值，如下图所示。您可以使用Intellij插件（如JSON to Kotlin Class）为您的样例JSON自动生成Kotlin数据类，并轻松启用Jackson注解和选择并选择可为空的参数，作为自动代码生成的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI @Inject with Kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kotlin的CDI @Inject</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin reflection annotation processing differs from Java.  You may experience an error when using CDI @Inject such as: "kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin的反射注解处理与Java不同。在使用CDI @Inject时，您可能会遇到错误，比如。"kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the example below, this can be easily solved by adapting the annotation, adding @field: Default, to handle the lack of a @Target on the Kotlin reflection annotation definition.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在下面的示例中，通过调整注解，添加@field:Default来处理Kotlin反射注解定义中缺少@Target，就可以很容易地解决这一问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin requires a @field: xxx qualifier as it has no @Target on the annotation definition. Add @field: xxx in this example. @Default is used as the qualifier, explicitly specifying the use of the default bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin需要一个@field:xxx 限定符，因为它在注解定义上没有@Target。在此示例中添加@field: xxx 。@Default作为限定符，显式指定使用默认bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing application properties with Spring Boot properties API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Spring Boot属性API访问应用程序属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Spring Boot `@ConfigurationProperties` annotated class to access application properties instead of a Quarkus native `@ConfigProperties` or a MicroProfile `@ConfigProperty` approach, you can do that with this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你更喜欢使用Spring Boot `@ConfigurationProperties` 注解类来访问应用程序的属性，而不是Quarkus本地的 `@ConfigProperties` 或MicroProfile `@ConfigProperty` 的注解方式，你可以通过使用该扩展来做到这一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `spring-boot-properties-quickstart` {quickstarts-tree-url}/spring-boot-properties-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `spring-boot-properties-quickstart` {quickstarts-tree-url}/spring-boot-properties-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-boot-properties` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你已经配置了你的Quarkus项目，你可以在项目的根目录下运行以下命令，并将 `spring-boot-properties` 扩展添加到你的项目中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new class `src/main/java/org/acme/spring/boot/properties/GreetingProperties.java` with a message field:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个包含消息字段的 `src/main/java/org/acme/spring/boot/properties/GreetingProperties.java` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here `text` field is public, but it could also be a private field with getter and setter or just a public getter in an interface.  Because `text` does not have a default value it is considered required and unless it is defined in a configuration file (`application.properties` by default)  your application will fail to start.  Define this property in your `src/main/resources/application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这里 `text` 字段是公共的，但它也可以是一个带有getter和setter的私有字段，或者只是一个接口中的公共getter。因为 `text` 没有默认值，所以它被认为是必需的，除非它被定义在一个配置文件中（默认为 `application.properties` ），否则你的应用程序将无法启动。在你的 `src/main/resources/application.properties` 文件中定义该属性:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Your configuration properties
greeting.text = hello
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 你的属性配置
greeting.text = hello
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now modify `GreetingResource` to start using the `GreetingProperties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，修改 `GreetingResource` 以使用 `GreetingProperties` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the tests to verify that application still functions correctly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行测试以验证应用程序是否仍能正常运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the configuration file is immediately reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更改配置文件的内容将会立即得到反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default values</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a suffix for a greeting for which we'll set a default value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们为greeting 添加一个后缀，我们将为其设置一个默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties with default values can be configured in a configuration file just like any other property.  However, the default value will be used if the property was not defined in a configuration file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>具有默认值的属性可以像其他属性一样在配置文件中被配置。然而，如果该属性没有在配置文件中被定义，则将使用默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go ahead and add the new field to the `GreetingProperties` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>继续在 `GreetingProperties` 类中添加新的字段:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And update the `GreetingResource` and its test `GreetingResourceTest`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并更新 `GreetingResource` 及其对应的 `GreetingResourceTest` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the tests to verify the change.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行该测试以验证更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional values</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可选值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties with optional values are the middle-ground between standard and properties with default values.  While a missing property in a configuration file will not cause your application to fail, it will nevertheless not have a value set.  We use `java.util.Optional` type to define such properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>具有可选值的属性处于标准属性和具有默认值属性之间的中间地带。尽管在配置文件中缺少一个属性不会导致你的应用程序启动失败，但它还是没有被设置一个值。我们使用 `java.util.Optional` 类型来定义这种属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add an optional `name` property to the `GreetingProperties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `GreetingProperties` 中添加一个可选的 `name` 属性:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grouping properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分组属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have three properties in our `GreetingProperties` class.  While `name` could be considered more of a runtime property (and maybe could be passed as an HTTP query parameter in the future), `text` and `suffix` are used to define a message template.  Let's group these two properties in a separate inner class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，在我们的 `GreetingProperties` 类中有三个属性。虽然 `name` 可以更多地被认为是运行时属性（也许在将来可以被作为HTTP查询参数进行传递），而 `text` 和 `suffix` 被用于定义一个消息模板。让我们将这两个属性作为一组放在一个独立的内部类中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here `Message` properties class is defined as an inner class, but it could also be a top level class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里 `Message` 属性类被定义为一个内部类，但它也可以作为一个顶层类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having such property groups brings more structure to your configuration.  This is especially useful when then number of properties grows.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样的属性分组可以为你的配置带来更加丰富的结构。当属性的数量增加时，这尤其有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of the additional class, our property names have changed.  Let's update the properties file and the `GreetingResource` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为有了额外的类，我们的属性名也发生了改变。让我们更新一下属性配置文件和 `GreetingResource` 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Your configuration properties
greeting.message.text = hello
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 你的属性配置
greeting.message.text = hello
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incoming Attributes of the 'smallrye-kafka' connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>'smallrye-kafka' 连接器的传入属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that the `topic` property is a regular expression. Must be used with the `topic` property. Cannot be used with the `topics` property

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>表示 `topic` 属性是一个正则表达式。必须与 `topic` 属性一起使用。不能与 `topics` 属性一起使用

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deserializer classname used to deserialize the record's key

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于反序列化记录的键值的反序列化器的类名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deserializer classname used to deserialize the record's value

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于反序列化记录的值的反序列化器的类名

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The minimum amount of data the server should return for a fetch request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>针对一个获取请求，服务器所应该返回的最小数据量。默认设置为1个字节，意味着在等待数据到达的同时，一旦有一个字节的数据可用，那么获取请求就会被响应，或者直至获取请求超时。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A unique string that identifies the consumer group the application belongs to.

If not set, defaults to the application name as set by the `quarkus.application.name` configuration property.

If that is not set either, a unique, generated id is used.

It is recommended to always define a `group.id`, the automatic generation is only a convenient feature for development.
You can explicitly ask for automatically generated unique id by setting this property to `${quarkus.uuid}`.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个唯一的字符串，用于识别应用程序所属的消费者组。

如果未设置, 那么默认为通过 `quarkus.application.name` 所设定的应用程序名称。

如果这个属性也没有设置，那么会使用一个生成的唯一的id。

建议总是设置一个 `group.id`，因为自动生成只是一个方便在开发模式中使用的特性。
你可以通过将该属性设置为 `${quarkus.uuid}` 来显示的获取自动生成的唯一的id。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If enabled, consumer's offset will be periodically committed in the background by the underlying Kafka client, ignoring the actual processing outcome of the records. It is recommended to NOT enable this setting and let Reactive Messaging handles the commit.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果启用，消费者的偏移量将由底层Kafka客户端在后台定期提交，并忽略记录的实际处理结果。建议不要启用这个设置，而是由Reactive Messaging来处理提交。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not the connection to the broker is re-attempted in case of failure

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在失败的情况下，是否重新尝试与broker的连接

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of reconnection before failing. -1 means infinite retry

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>失败前的最大重连次数。-1表示无限重试

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The max delay (in seconds) between 2 reconnects

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>两次重新连接之间的最大延迟（秒）

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What to do when there is no initial offset in Kafka.Accepted values are earliest, latest and none

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当Kafka没有初始偏移量时的处理策略。可接受的值是earliest, latest 和 none

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the failure strategy to apply when a message produced from a record is acknowledged negatively (nack). Values can be `fail` (default), `ignore`, or `dead-letter-queue`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当记录产生的消息未被确认（nack）时要应用的失败策略。值可以是 `fail` （默认）， `ignore` ，或 `dead-letter-queue` 

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the commit strategy to apply when a message produced from a record is acknowledged. Values can be `latest`, `ignore` or `throttled`. If `enable.auto.commit` is true then the default is `ignore` otherwise it is `throttled`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>记录产生的消息被确认时的提交策略。值可以是 `latest` , `ignore` 或 `throttled` 。如果 `enable.auto.commit` 为真，则默认为 `ignore` ，否则为 `throttled` 

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates on which topic the record is sent. Defaults is `dead-letter-topic-$channel`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `failure-strategy` 被设置为 `dead-letter-queue` ，用来指明记录会发送到哪个主题的。默认值是 `dead-letter-topic-$channel` 

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates the key serializer to use. If not set the serializer associated to the key deserializer is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `failure-strategy` 被设置为 `dead-letter-queue` 时，表示要使用的键值的序列化器。如果没有设置则使用与键值反序列化器相关的序列化器

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates the value serializer to use. If not set the serializer associated to the value deserializer is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `failure-strategy` 被设置为 `dead-letter-queue` ，表示要使用的值的序列化器。如果没有设置，则使用与值反序列化器相关的序列化器n

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The number of partitions to be consumed concurrently. The connector creates the specified amount of Kafka consumers. It should match the number of partition of the targeted topic

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并发消费的分区的数量。连接器会创建指定数量的Kafka消费者。它应该与目标主题的分区数量相匹配

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener`. If set, this rebalance listener is applied to the consumer.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` 的bean的名称。如果被设置，那么这个再均衡监听器就会应用到消费者上。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not a graceful shutdown should be attempted when the application terminates.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当应用程序终止时，是否应该尝试平滑关闭。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The polling timeout in milliseconds. When polling records, the poll will wait at most that duration before returning records. Default is 1000ms

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以毫秒为单位的轮询超时时间。当轮询记录时，轮询将在返回记录之前最多等待该时间段。默认是1000ms

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the polling must be paused when the application does not request items and resume when it does. This allows implementing back-pressure based on the application capacity. Note that polling is not stopped, but will not retrieve any records when paused.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当应用程序不请求记录时，轮询是否必须被暂停，或应用程序开始请求记录时轮询是否要恢复。该属性允许实现基于应用容量的背压。需要注意轮询不会停止，但当暂停时不会获取任何记录。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Eclipse Vert.x API from a Quarkus Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus应用程序中使用Eclipse Vert.x API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications can access and use the Vert.x APIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus应用程序能够访问和使用Vert.x APIs。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide presents how you can build a Quarkus application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南介绍如何使用以下方法构建 Quarkus 应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Vert.x event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 事件总线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Vert.x Web Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 网络客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's an introductory guide.  The xref:vertx-reference.adoc[Vert.x reference guide] covers more advanced features such as verticles, and native transports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一项介绍性的指南。 link:vertx-reference.html[Vert.x参考指南] 涵盖了更多的高级功能，例如 verticles 和 本地传输 (native transports) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to build a simple application exposing four HTTP endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们将构建一个简单应用程序 它包含四个暴露出的端点:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/vertx/book` returns the content from a large file (a book)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/vertx/book` 返回一个大文件的内容（一本书）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the following sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议你按照下一节的说明逐步创建应用程序。然而，你也可以直接转到已完成的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `vertx-quickstart` {quickstarts-tree-url}/vertx-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `vertx-quickstart` {quickstarts-tree-url}/vertx-quickstart[目录]中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide uses the Mutiny API.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive, reactive programming library].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该指南使用Mutiny API。如果你不熟悉Mutiny，请查看 link:mutiny-primer.html[Mutiny - 一个直观的、响应式的编程库] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引导启动该应用程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on https://code.quarkus.io/?a=quarkus-getting-started-vertx&amp;nc=true&amp;e=resteasy-reactive-jackson&amp;e=vertx[this link] to configure your application.  It selected a few extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 link:https://code.quarkus.io/?a=quarkus-getting-started-vertx&amp;nc=true&amp;e=resteasy-reactive-jackson&amp;e=vertx[这个链接] 来配置你的应用程序。它选择了几个扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`vertx`, which provides access to the underlying managed Vert.x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`vertx` ，它提供了对底层管理的Vert.x的访问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on the `Generate your application` button, download the zip file and unzip it.  Then, open the project in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>点击 `生成你的应用程序` 按钮，下载压缩文件并解压。然后，在你喜欢的编辑器中打开该项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the Vert.x Web Client, which we will be using to implement the `/web` endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该依赖项提供了Vert.x Web客户端，我们将用它来实现 `/web` 端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>访问被管理的Vert.x实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/VertxResource.java` file.  It will contain our HTTP endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/VertxResource.java` 文件。它将包含我们的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this file, copy the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在该文件中，拷贝以下代码:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the root HTTP path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>声明HTTP根路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use constructor injection to receive the managed Vert.x instance. Field injection works too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用构造函数注入的方式来接收被管理的Vert.x实例。当然 字段注入也被允许。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receives the Vert.x instance as a constructor parameter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收Vert.x实例作为构造函数的参数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Store the managed Vert.x instance into a field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将被管理的Vert.x实例存储到一个字段当中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, we can start implementing the endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了这些，我们就可以开始实现端点了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x Core API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x核心API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance provides a set of APIs you can use.  The one we are going to use in this section is the Vert.x File System.  It provides a non-blocking API to access files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>被注入的Vert.x实例提供了一组你可以使用的API。我们在本节中要使用的是Vert.x文件系统。它提供了一个非阻塞的API来访问文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `src/main/resource` directory, create a `lorem.txt` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `src/main/resource` 目录中，创建一个包含以下内容的 `lorem.txt` 文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, in the `VertxResource` file add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，在 `VertxResource` 文件中添加以下方法:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint handles HTTP `GET` request on path `/lorem` (so the full path will be `vertx/lorem`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该端点处理路径 `/lorem` 上的 HTTP `GET` 请求（因此完整路径是 `vertx/lorem` ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the Vert.x API is asynchronous, our method returns a `Uni`. The content is written into the HTTP response when the asynchronous operation represented by the Uni completes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于Vert.x API是异步的，我们的方法返回一个 `Uni` 对象 。当Uni所代表的异步操作完成后，内容将会被写入HTTP响应中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the Vert.x file system API to read the created file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用Vert.x文件系统API来读取创建的文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the file is read, the content is stored in an in-memory buffer.  We transform this buffer into a String.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦文件被读取，其内容就被存储在一个内存缓冲区内。我们将这个缓冲区的内容转换为一个字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a terminal, navigate to the root of the project and run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在终端中，切换到项目根目录下 运行以下命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see the content of the file printed in the console.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你应该会在控制台中看到打印的文件内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides other ways to serve static files. This is an example made for the guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus提供了其他方式来处理静态文件。这是专为该指南制作的一个例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x stream capability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x流的功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading a file and storing the content in memory works for small files, but not big ones.  In this section, we will see how you can use Vert.x streaming capability.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>读取文件并将内容存储在内存中适用于小文件，但不适用于大文件。在本节中，我们将带领你了解如何使用 Vert.x 流功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, download https://www.gutenberg.org/files/2600/2600-0.txt[War and Peace] and store it in `src/main/resources/book.txt`.  It's a 3.2 Mb file, which, while not being huge, illustrates the purpose of streams.  This time, we will not accumulate the file's content in memory and write it in one batch, but read it chunk by chunk and write these chunks into the HTTP response one by one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，下载 link:https://www.gutenberg.org/files/2600/2600-0.txt[《战争与和平] 》，并将其存储在 `src/main/resources/book.txt` 。这是一个3.2Mb的文件，虽然不是很大，但说明了流的用途。这一次，我们将不会把文件的内容堆积在内存中并一次性写入，而是逐块读取，并把这些块逐一写入到HTTP响应中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, you should have the following files in your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，你的项目中应该包含以下文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following method to the `VertxResource` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将以下方法添加到 `VertxResource` 类中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time, we return a Multi as we want to stream the chunks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这一次，我们返回一个Multi类型的对象，因为我们想要流式地处理这些块</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We open the file using the `open` method. It returns a `Uni&lt;AsyncFile&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们使用 `open` 方法打开该文件。它返回一个 `Uni&lt;AsyncFile&gt;` 类型的对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the file is opened, we retrieve a `Multi` which will contain the chunks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当文件被打开时，我们获得到一个 `Multi` ，它包含了块的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each chunk, we produce a String</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于每个块，我们生成一个字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To visually see the chunks in the response, we append a separator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了直观地看到响应中的分块，我们添加了一个分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, in a terminal, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，在终端中，运行以下命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should retrieve the book content.  In the output you should see the separator like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它应该获取到书籍的内容。在输出中，你应该会看到像这样包含分隔符的内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the core features of Vert.x is the https://vertx.io/docs/vertx-core/java/#event_bus[event bus].  It provides a message-based backbone to your application.  So, you can have components interacting using asynchronous message passing, and so decouple your components.  You can send a message to a single consumer, or dispatch to multiple consumers, or implement a request-reply interaction, where you send a message (request) and expect a response.  This is what we are going to use in this section.  Our `VertxResource` will send a message containing a name to the `greetings` address.  Another component will receive the message and produce the "hello $name" response.  The `VertxResource` will receive the response and return it as the HTTP response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 的核心特点之一是 https://vertx.io/docs/vertx-core/java/#event_bus[事件总线]。它为你的应用程序提供了基于消息的主干。因此，你可以使用异步消息传递的方式在组件之间进行交互，并且将你的组件解耦。您可以向单个消费者发送消息，或分派给多个消费者，亦或是实现请求-响应的交互，在其中发送消息（请求）并期许响应。这是我们将在本节中使用的内容。我们的 `VertxResource`  将向问候地址发送一条包含姓名的消息。另一个组件将会接收到这条消息并生成 "hello $name" 的响应。 `VertxResource` 将收到响应并将其作为 HTTP 响应进行返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, first, let's extend our `VertxResource` class with the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，首先，让我们使用以下代码来扩展我们的 `VertxResource` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we need the other side: the component receiving the name and replying.
Create the `src/main/java/org/acme/GreetingService.java` file with the following content:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，我们需要另一侧: 接收姓名并回复的组件。
使用以下内容创建 `src/main/java/org/acme/GreetingService.java` 文件:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try this.
In a terminal, run:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们试试这个。
在终端中，运行以下命令:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should get the expected `Hello bob` message back.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你应该会收到预期的 `Hello bob` 消息。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vert.x Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Vert.x客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we have used the Vert.x Core API.  Vert.x offers much more.  It provides a vast ecosystem.  In this section, we will see how you can use the Vert.x Web Client, a reactive HTTP client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们已经使用了 Vert.x 核心 API。 Vert.x 提供的不仅仅是这些。它提供了一个广阔的生态系统。在本节中，我们将会带你了解如何使用 Vert.x Web 客户端 - 一个响应式 HTTP 客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that some Quarkus extensions are wrapping Vert.x clients and manage them for you.  That's the case for the reactive data sources, Redis, mail...  That's not the case with the Web Client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，部分 Quarkus 扩展正在封装 Vert.x 客户端并为您管理它们。如响应式数据源、Redis、邮件等...  但Web 客户端，并不在此行列之内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, at the beginning of the guide, we added the `smallrye-mutiny-vertx-web-client` dependency to our `pom.xml` file.  It's now time to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请记住，在本指南的开头，我们将 `smallrye-mutiny-vertx-web-client` 作为依赖项添加到了我们的 pom.xml 文件中。现在，是时候使用它了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create an instance of `WebClient`.  Extend the `VertxResource` class with the `client` field and the creation of the web client in the constructor:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，我们需要创建一个 `WebClient` 的实例。使用 client 字段扩展 `VertxResource` 类并在构造函数中创建 Web 客户端:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now implement a new HTTP endpoint that queries the Wikipedia API to retrieve the pages about Quarkus in the different languages.
Add the following method to the `VertxResource` class:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们实现一个新的 HTTP 端点，它通过查询 Wikipedia API 以检索不同语言有关 Quarkus 的页面。
将以下方法添加到 `VertxResource` 类中:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, invoke the endpoint using:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接着，使用以下命令请求该端点:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response indicates that, in addition to the English page, there are a German and a French page about Quarkus on wikipedia.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该响应表明，除了英文页面，维基百科上还有关于 Quarkus 的德文和法文页面。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide introduced how you can use Vert.x APIs from a Quarkus application.  It's just a brief overview.  If you want to know more, check the xref:vertx-reference.adoc[reference guide about Vert.x in Quarkus].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南介绍了如何在 Quarkus 应用程序中使用 Vert.x API。这只是一个简短的概述。如果你想了解更多信息，请查看 xref:vertx-reference.adoc[Quarkus 中有关 Vert.x 的参考指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tips for writing native applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编写原生应用程序的提示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide contains various tips and tricks for getting around problems that might arise when attempting to run Java applications as native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南包含各种提示和技巧，以解决在尝试以原生可执行文件形式运行Java应用程序时可能出现的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we differentiate two contexts where the solution applied might be different:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，我们区分了两种情况，适用的解决方案可能是不同的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the context of an application, you will rely on configuring the `native-image` configuration by tweaking your `pom.xml`;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在一个应用程序的背景下，你将依靠配置 `native-image` ，通过调整你的 `pom.xml` ；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the context of an extension, Quarkus offers a lot of infrastructure to simplify all of this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在扩展的背景下，Quarkus提供了很多基础设施来简化这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please refer to the appropriate section depending on your context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请根据你的情况，参考适当的章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in your application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的应用程序中支持原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM imposes a number of constraints and making your application a native executable might require a few tweaks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM施加了一些限制，使你的应用程序成为原生可执行文件可能需要进行一些调整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when building a native executable, GraalVM will not include any of the resources that are on the classpath into the native executable it creates.  Resources that are meant to be part of the native executable need to be configured explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，在构建本地可执行文件时，GraalVM不会将classpath上的任何资源纳入其创建的原生可执行文件。要成为原生可执行文件一部分的资源，需要明确地进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus automatically includes the resources present in `META-INF/resources` (the web resources) but, outside of this directory, you are on your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自动包括存在于 `META-INF/resources` (网络资源）的资源，但是，在这个目录之外，你就得靠自己了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you need to be extremely careful here as anything in `META-INF/resources` will be exposed as static web resources.  So this directory is not a shortcut for "let's automatically include these resources in the native executable" and should only be used for static web resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，你在这里需要非常小心，因为 `META-INF/resources` 中的任何东西都会作为静态网络资源暴露出来。所以这个目录不是 "让我们自动把这些资源包含在本地可执行文件中 "的捷径，而应该只用于静态网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other resources should be declared explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>其他资源应明确声明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To include more resources in the native executable, the easiest way is to use the `quarkus.native.resources.includes` configuration property, and its counterpart to exclude resources `quarkus.native.resources.excludes`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要在原生可执行文件中包含更多的资源，最简单的方法是使用 `quarkus.native.resources.includes` 配置属性，及其对应的排除资源 `quarkus.native.resources.excludes`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both configuration properties support glob patterns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这两个配置属性都支持glob模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, having the following properties in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，在你的 `application.properties`中有以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will include:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all files in the `foo/` directory and its subdirectories except for files in `foo/private/` and its subdirectories,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `foo/` 目录及其子目录中的所有文件，但 `foo/private/` 及其子目录中的文件除外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all text files in the `bar/` directory and its subdirectories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `bar/` 目录及其子目录下的所有文本文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If globs are not sufficiently precise for your use case and you need to rely on regular expressions or if you prefer relying on the GraalVM infrastructure, you can also create a `resources-config.json` (the most common location is within `src/main/resources`) JSON file defining which resources should be included:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果globs对于你的使用情况来说不够精确，你需要依靠正则表达式，或者你更喜欢依靠GraalVM的基础设施，你也可以创建一个 `resources-config.json` (最常见的位置是在`src/main/resources`) JSON文件，定义哪些资源应该被包含：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The patterns are valid Java regexps.  Here we include all the XML files and JSON files into the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些模式都是有效的Java重组函数。在这里，我们将所有的XML文件和JSON文件纳入原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this topic in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[GraalVM文档]中找到更多关于这个主题的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final order of business is to make the configuration file known to the `native-image` executable by adding the proper configuration to `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后一项工作是通过向 `application.properties`添加适当的配置，使配置文件为 `native-image` 可执行文件所知：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `resources-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.  If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面的片段中，我们能够简单地使用 `resources-config.json` ，而不是指定文件的整个路径，只是因为它被添加到了 `src/main/resources` 。如果该文件被添加到了另一个目录，就必须手动指定适当的文件路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple options may be separated by a comma. For example, one could use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多个选项可以用逗号隔开。例如，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in order to ensure that various resources are included and additional reflection is registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以确保各种资源被包括在内，并登记了额外的反射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for some reason adding the aforementioned configuration to `application.properties` is not desirable, it is possible to configure the build tool to effectively perform the same operation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果由于某种原因，将上述配置添加到 `application.properties` ，是不可取的，可以通过配置构建工具来有效地执行相同的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Maven, we could use the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Maven时，我们可以使用以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering for reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>登记反射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building a native executable, GraalVM operates with a closed world assumption.  It analyzes the call tree and removes all the classes/methods/fields that are not used directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在构建本地可执行文件时，GraalVM以封闭世界的假设进行操作。它分析调用树并删除所有不直接使用的类/方法/字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements used via reflection are not part of the call tree so they are dead code eliminated (if not called directly in other cases).  To include these elements in your native executable, you need to register them for reflection explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过反射使用的元素不是调用树的一部分，所以它们是被消除的死代码（如果不是在其他情况下直接调用）。要在你的本地可执行文件中包含这些元素，你需要为反射明确地注册它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a very common case as JSON libraries typically use reflection to serialize the objects to JSON:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常常见的情况，因为JSON库通常使用反射来将对象序列化为JSON：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we were to use the code above, we would get an exception like the following when using the native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果我们使用上面的代码，在使用原生可执行文件时，我们会得到一个类似下面的异常：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you are using Jackson:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或如果你在使用Jackson：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An even nastier possible outcome could be for no exception to be thrown, but instead the JSON result would be completely empty.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个更糟糕的结果是没有抛出异常，而JSON的结果是完全空的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two different ways to fix this type of issues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有两种不同的方法来解决这种类型的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the @RegisterForReflection annotation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用@RegisterForReflection注解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to register a class for reflection is to use the `@RegisterForReflection` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为反射注册一个类的最简单方法是使用 `@RegisterForReflection` 注解：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your class is in a third-party jar, you can do it by using an empty class that will host the `@RegisterForReflection` for it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的类在第三方的jar中，你可以通过使用一个空的类来做，这个空的类将为它托管 `@RegisterForReflection` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `MyClassRequiringReflection` and `MySecondClassRequiringReflection` will be registered for reflection but not `MyReflectionConfiguration`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意， `MyClassRequiringReflection` 和 `MySecondClassRequiringReflection` 将被注册为反射，但不包括 `MyReflectionConfiguration` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This feature is handy when using third-party libraries using object mapping features (such as Jackson or GSON):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在运用使用对象映射功能的第三方库（如Jackson或GSON）时，这个功能很方便：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用一个配置文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a configuration file to register classes for reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用一个配置文件来为反射注册类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, in order to register all methods of class `com.acme.MyClass` for reflection, we create `reflection-config.json` (the most common location is within `src/main/resources`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作为一个例子，为了注册类 `com.acme.MyClass` 的所有方法进行反射，我们创建 `reflection-config.json` （最常见的位置是在 `src/main/resources` 内）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details on the format of this file, please refer to https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于该文件格式的更多细节，请参考 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `reflection-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.  If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面的片段中，我们能够简单地使用 `reflection-config.json` ，而不是指定文件的整个路径，只是因为它被添加到了 `src/main/resources` 。如果该文件被添加到了另一个目录，就必须手动指定适当的文件路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delaying class initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>推迟类的初始化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus initializes all classes at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus在构建时初始化所有类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases where the initialization of certain classes is done in a static block needs to be postponed to runtime.  Typically omitting such configuration would result in a runtime exception like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有些情况下，某些类的初始化是在静态块中完成的，需要推迟到运行时。通常情况下，省略这样的配置会导致运行时的异常，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to delay the initialization of a class, you can use the `--initialize-at-run-time=&lt;package or class&gt;` configuration knob.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要延迟一个类的初始化，你可以使用 `--initialize-at-run-time=&lt;package or class&gt;` 配置旋钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should be added to the `native-image` configuration using the `quarkus.native.additional-build-args` configuration property as shown in the examples above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它应该使用 `quarkus.native.additional-build-args` 配置属性添加到 `native-image` 配置中，如上面的例子所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about all this in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[GraalVM的文档]中找到更多关于这一切的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes or packages need to be specified via the `quarkus.native.additional-build-args` configuration property, the `,` symbol needs to be escaped.  An example of this is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当需要通过 `quarkus.native.additional-build-args` 配置属性指定多个类或包时，需要对 `,` 符号进行转义。这方面的一个例子如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and in the case of using the Maven configuration instead of `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以及在使用Maven配置而不是 `application.properties` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing Proxy Classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理代理类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While writing native application you'll need to define proxy classes at image build time by specifying the list of interfaces that they implement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在编写本地应用程序时，你需要在图像构建时通过指定它们实现的接口列表来定义代理类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such a situation, the error you might encounter is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，你可能遇到的错误是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solving this issue requires adding the `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` option and to provide a dynamic proxy configuration file.  You can find all the information about the format of this file in https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md#manual-configuration[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决这个问题需要添加 `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` 选项，并提供一个动态代理配置文件。你可以在 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md#manual-configuration[GraalVM文档]中找到关于这个文件格式的所有信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in a Quarkus extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus扩展中支持原生</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in a Quarkus extension is even easier as Quarkus provides a lot of tools to simplify all this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Quarkus扩展中支持本机更容易，因为Quarkus提供了很多工具来简化这一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything described here will only work in the context of Quarkus extensions, it won't work in an application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这里描述的一切只在Quarkus扩展的范围内起作用，在应用程序中不会起作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>登记反射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes registration of reflection in an extension a breeze by using `ReflectiveClassBuildItem`, thus eliminating the need for a JSON configuration file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过使用 `ReflectiveClassBuildItem` ，使得在扩展中注册反射变得轻而易举，从而消除了对JSON配置文件的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To register a class for reflection, one would need to create a Quarkus processor class and add a build step that registers reflection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要为反射注册一个类，需要创建一个Quarkus处理器类并添加一个注册反射的构建步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information about reflection in GraalVM can be found https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于GraalVM中反射的更多信息可以 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Reflection.md[在这里] 找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the context of an extension, Quarkus eliminates the need for a JSON configuration file by allowing extension authors to specify a `NativeImageResourceBuildItem`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在扩展的背景下，Quarkus通过允许扩展的作者指定一个 `NativeImageResourceBuildItem` 来消除对JSON配置文件的需求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about GraalVM resource handling in native executables please refer to https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于本地可执行文件中GraalVM资源处理的更多信息，请参考 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/Resources.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delay class initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>延迟类的初始化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus simplifies things by allowing extensions authors to simply register a `RuntimeInitializedClassBuildItem`. A simple example of doing so could be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus通过允许扩展作者简单地注册一个 `RuntimeInitializedClassBuildItem` 来简化操作。这样做的一个简单例子是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a construct means that a `--initialize-at-run-time` option will automatically be added to the `native-image` command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用这样的结构意味着 `--initialize-at-run-time` 选项将被自动添加到 `native-image` 命令行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about `--initialize-at-run-time`, please read https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于 `--initialize-at-run-time` 的更多信息，请阅读 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/ClassInitialization.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very similarly, Quarkus allows extensions authors to register a `NativeImageProxyDefinitionBuildItem`. An example of doing so is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非常相似的是，Quarkus允许扩展作者注册一个 `NativeImageProxyDefinitionBuildItem` 。这样做的一个例子是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a construct means that a `-H:DynamicProxyConfigurationResources` option will automatically be added to the `native-image` command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用这样的结构意味着 `-H:DynamicProxyConfigurationResources` 选项将被自动添加到 `native-image` 命令行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about Proxy Classes you can read https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于代理类的更多信息，你可以阅读 https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DynamicProxy.md[GraalVM文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging with Native Image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用原生镜像日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using dependencies that require logging components such as Apache Commons Logging or Log4j and are experiencing a `ClassNotFoundException` when building the native executable, you can resolve this by excluding the logging library and adding the corresponding JBoss Logging adapter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你正在使用需要日志组件（如Apache Commons logging或Log4j）的依赖，并且在构建原生可执行文件时遇到了' ClassNotFoundException '，你可以通过排除日志库并添加相应的JBoss日志适配器来解决这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All configuration options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有配置选项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will implement a service, namely `CostConverter` that consumes HTTP messages with costs in multiple currencies and converts each cost to its value in Euro.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中我们将实现一项服务，名为 `CostConverter` ，它将以多种货币成本的方式消费 HTTP 消息，并将每个成本转换为其以欧元为单位的价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该解决方案位于 `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[目录] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and HTTP connector extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven项目，导入Reactive Messaging和HTTP 连接扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/reactivehttp/CostConverter.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/java/org/acme/reactivehttp/CostConverter.java` 文件，内容如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume an event with payload of type `Cost` and produce a `double`.  In the case of consuming an arbitrary object, the reactive-messaging-http extension will attempt to deserialize the request body as a JSON object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费一个具有 `Cost` 类型的有效载荷的事件，并生成一个 `double` 。在消费任意一个对象的情况下，reactive-messaging-http 扩展将尝试把请求体反序列化为一个JSON对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the HTTP connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置HTTP连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the HTTP connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要配置HTTP连接器。这是在 `application.properties` 文件中完成的。 键的结构如下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To illustrate that converting messages and passing them through works, let's add an endpoint that will receive the outgoing costs and sum them up.  This is a usual JAX-RS endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了说明转换消息和传递消息是可行的，让我们添加一个端点来接收传出成本并将它们相加。 这是一个常见的 JAX-RS 端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/index.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/main/resources/META-INF/resources/index.html` 文件, 包含以下内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `quarkus-http` connector options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所有 `quarkus-http` 连接器选项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Message payload serializer, optional, implementation of `io.quarkus.reactivemessaging.http.runtime.serializers.Serializer`
mp.messaging.outgoing.&lt;channelName&gt;.serializer=com.example.MySerializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 消息负载序列化器，可选的， `io.quarkus.reactivemessaging.http.runtime.serializers.Serializer` 的实现
mp.messaging.outgoing.&lt;channelName&gt;.serializer=com.example.MySerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># The number of attempts to make for sending a request to a remote endpoint. Must not be less than zero
# Zero by default
mp.messaging.outgoing.&lt;channelName&gt;.maxRetries=3
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 尝试向远程端点发送请求的次数。不得小于零
# 默认为0
mp.messaging.outgoing.&lt;channelName&gt;.maxRetries=3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configures the random factor when using back-off with maxRetries &gt; 0. 0.5 by default
mp.messaging.outgoing.&lt;channelName&gt;.jitter=0.3
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 配置当使用回退且maxRetries &gt; 0时使用的随机因子。 默认为0.5
mp.messaging.outgoing.&lt;channelName&gt;.jitter=0.3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configures a back-off delay between attempts to send a request.
# A random factor (jitter) is applied to increase the delay when several failures happen.
mp.messaging.outgoing.&lt;channelName&gt;.delay=1s
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 配置尝试发送请求之间的回退延迟。
# 当发生多个故障时，随机因子（抖动）被使用来增加延迟。
mp.messaging.outgoing.&lt;channelName&gt;.delay=1s
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#The HTTP method (either `POST` or `PUT`), `POST` by default
mp.messaging.outgoing.&lt;channelName&gt;.method=PUT
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>#HTTP 请求方式 ( `POST` 或 `PUT` ),默认为 `POST` 
mp.messaging.outgoing.&lt;channelName&gt;.method=PUT
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#INCOMING
# The HTTP method (either `POST` or `PUT`, `POST` by default
mp.messaging.incoming.&lt;channelName&gt;.method=POST
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>#INCOMING
# HTTP 请求方式 ( `POST` 或 `PUT` ,默认为 `POST` 
mp.messaging.incoming.&lt;channelName&gt;.method=POST
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel目前只推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着Mandrel用户应该使用容器来构建他们的原生可执行文件。如果你正在为macOS或Windows目标平台构建原生可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前并不针对这些平台。直接在裸金属Linux上构建原生可执行文件是可能的，详细信息请参见 https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel releases]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会等待60秒，等待原生镜像启动，然后原生测试自动失败。这个持续时间可以通过 `quarkus.test.native-image-wait-time` 系统属性来改变。例如，要将持续时间增加到300秒，可以使用： `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in tiny Docker images, check the {quarkus-images-url}/master/distroless[distroless] version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您对小型Docker镜像感兴趣，请查看 {quarkus-images-url}/master/distroless[无发行版]版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven, but implicitly required that the proper GraalVM version be installed on the building machine (be it your local machine or your CI/CD infrastructure).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上一节向您展示了如何使用Maven构建原生可执行文件，但隐式地要求在构建机器上安装适当的GraalVM版本(无论是您的本地机器还是CI/CD基础设施)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In cases where the GraalVM requirement cannot be met, you can use Docker to perform the Maven or Gradle build by using a multi-stage Docker build. A multi-stage Docker build is like two Dockerfile files combined in one, the first is used to build the artifact used by the second.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在GraalVM的需求不能满足的情况下，你可以使用Docker通过使用多阶段Docker构建来执行Maven或Gradle构建。一个多阶段的Docker构建就像两个Dockerfile文件合并在一起，第一个用来构建，第二个使用工件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will use the first stage to generate the native executable and the second stage to create our runtime image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在本指南中，我们将使用第一阶段生成原生可执行文件，第二阶段创建运行时镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory and as we plan to build inside a container we need to be able to copy the `src` directory. So edit your `.dockerignore` and remove or comment its content.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在启动我们的Docker构建之前，我们需要更新默认的 `.dockerignore` 文件，因为它过滤了除 `target` 目录之外的所有内容，而我们计划在容器中构建时，我们需要能够复制 `src` 目录。所以编辑你的 `.dockerignore` 并删除或注释其内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用Quarkus创建响应式应用程序，并探索Quarkus提供的不同响应式功能。 本指南涵盖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quick glance at the Quarkus engine and how it enables reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>快速浏览一下Quarkus引擎和它如何实现响应式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bootstrap of a reactive application using RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RESTEasy Reactive 的响应式应用程序的引导</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建响应式 JAX-RS 端点（异步、流等）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式数据库访问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与其他响应式API交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solutions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解决方案位于 `getting-started-reactive` 和 `getting-started-reactive-crud` 目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus是响应式的。如果您仔细观察，就会发现一个为Quarkus应用程序提供动力的响应式引擎。这个引擎就是Eclipse Vert.x (https://vertx.io)。所有网络I/O都通过非阻塞和响应性的 Vert.x 引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们举两个例子来解释它是如何工作的。想象一个传入的HTTP请求。嵌入在Quarkus中的 (Vert.x) HTTP服务器接收请求，然后将其路由到应用程序。如果请求的目标是一个 _imperative_ 方法（传统的JAX-RS，代码注释为 `@Blocking`…），路由层在 _worker_ 线程中调用资源方法，并在数据可用时写入响应。到目前为止，还没有什么新的或突出的。下图描述了这种行为。在这种情况下，应用程序代码是在工作线程上调用的，而业务逻辑会阻塞该线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，如果HTTP请求的目标是一个响应式方法（JAX-RS使用RESTEasy响应式，响应式路由， `@Incoming` 方法没有注释 `@Blocking`…），路由层会在I/O线程上调用路由，这会带来很多好处，比如更高的并发性和性能：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因为Quarkus使用I/O线程来调用代码，所以我们节省了上下文切换，避免了大型线程池管理，从而提高了资源利用率。但是，代码必须 **NOT** 阻塞该线程。为什么？因为，I/O线程用于处理多个并发请求。一旦一个请求的处理因为需要执行一些I/O而无法进行，它就会调度这些I/O，并传递一个延续。它释放可以处理另一个请求的线程。当计划的I/O完成时，继续执行，返回到I/O线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，许多Quarkus组件在设计时都考虑了响应式，比如数据库访问（PostgreSQL, MySQL, Mongo等），应用服务（邮件，模板引擎等），消息传递（Kafka, AMQP等）等等。但是，要完全受益于此模型，应用程序代码应该以非阻塞的方式编写。这就是运用一个响应式API这个终极武器的地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny]是一个响应式编程库，允许表达和组合异步动作。它提供两种类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.mutiny.Multi` - 用于多条目(回压)流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这两种类型都是惰性的，并且遵循订阅模式。计算只在有实际需要时才开始（即订阅者登记）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Uni` 和 `Multi` 都公开了事件驱动的API：你表达了在给定事件上你想做什么(成功，失败等)。这些API被分成组（操作类型），以使其更具表达性，并避免将100个方法附加到单个类上。主要的操作类型是对失败、完成、操作项、提取或收集它们作出反应。它提供了一种流畅的编码体验，具有可导航的API，并且结果不需要太多关于响应式的知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能想知道响应流 (https://www.reactive-streams.org/)。  `Multi` 实现了响应流 `Publisher`，因此实现了响应流回压机制。  `Uni` 没有实现 `Publisher` ，因为' Uni '的订阅足以表明你对结果感兴趣。由于响应流的订阅/请求仪式更加复杂，所以它再次考虑了更简单、更流畅的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拥抱来自Quarkus的响应和指令支柱的统一， `Uni` 和 `Multi` 都为指令式结构提供了桥梁。例如，你可以将 `Multi` 转换为 `Iterable` ，或者 _await_ `Uni` 生成元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这一点上，如果你是RxJava或Reactor的用户，你可能想知道如何使用你熟悉的 `Flowable`，`Single`，`Flux`，`Mono`… Mutiny允许从 `Unis` 和 `Multis` 到RX Java和Reactor类型的转换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>但是，Vert.x呢？Vert.x API也可以使用Mutiny类型。下面的代码片段展示了Vert.x Web 客户端的用法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最后但并非最不重要的是，Mutiny内置了与MicroProfile上下文传播的集成，因此您可以在响应管道中传播事务、跟踪数据等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But enough talking, let's get our hands dirty!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>说得够多了，我们动手吧！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus实现响应式应用程序有几种方法。在本指南中，我们将使用RESTEasy Reactive，一个受益于Quarkus Reactive引擎的RESTEasy的实现。默认情况下，它调用I/O线程上的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然可以使用_traditional_ RESTEasy，但需要添加 `quarkus-resteasy-mutiny` 扩展，该方法仍然会在 _worker_ 线程上调用。因此，虽然它将使用响应式编程，但仍然需要工作线程，这与目的不符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux and macOS users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Linux和macOS用户</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd, (don't use forward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用cmd，（不要使用正斜杠 `\`）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell, wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用Powershell，请将 `-D` 参数用双引号括起来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started-reactive`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它会在 `./getting-started-reactive`中生成如下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive JAX-RS resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>响应式 JAX-RS 资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在项目创建过程中， `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` 文件已经创建了以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello RESTEasy Reactive" to requests on "/hello".  As it uses RESTEAsy Reactive, this method is called on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常简单的REST端点，在 "/hello"上返回 "Hello RESTEasy Reactive" 请求。当它使用RESTEAsy响应式时，这个方法在I/O线程上被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要让Quarkus在_worker_线程上调用这个方法，请使用 `io.smallrye.common.annotation.Blocking` 注释它。你可以在一个方法、类上使用 ' @Blocking '，或者在整个应用中通过注释一个 `Application` 类来启用它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create a `ReactiveGreetingService` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在让我们创建一个 `ReactiveGreetingService` 类，包含以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, edit the `ReactiveGreetingResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，编辑 `ReactiveGreetingResource` 类，以匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingService` 类包含一个生成 `Uni` 的简单方法。虽然在这个例子中，产生的条目是立即发出的，你可以想象任何异步API产生一个 `Uni`。我们将在本指南的后面讨论这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, start the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，使用以下命令启动应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行后，通过打开 http://localhost:8080/hello/greeting/neo 检查您是否得到了预期的问候信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>到目前为止，我们只返回一个异步结果。在本节中，我们使用传输多个条目的流来扩展应用程序。这些数据流可以来自Kafka或任何其他数据源，但为了简单起见，我们只生成周期性的问候消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingService`, add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `ReactiveGreetingService` 中，添加以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能需要添加 `import io.smallrye.mutiny.Multi;` 和 `import java.time.Duration;` 语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates a greeting message every second and stops after `count` messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它每秒钟生成一条问候信息，并在 `count` 信息后停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingResource` add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `ReactiveGreetingResource` 中添加以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个端点将项目以JSON数组的形式发送给客户端。消息的名称和数量用路径参数进行参数化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So calling the endpoint produces something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>所以调用端点会产生如下结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can also generate Server-Sent Event responses by returning a `Multi`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们也可以通过返回一个 `Multi` 来生成服务器发送的事件响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与前面代码片段唯一的区别是生成的类型和指示每个事件类型的 `@RestSseElementType` 注解。由于 `@Produces` 注解定义了 `SERVER_SENT_EVENTS`，JAX-RS需要它知道每个（嵌套）事件的内容类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可能需要添加 `import org.jboss.resteasy.reactive.RestSseElementType;` 语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the result using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用以下命令看到结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用响应式 API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Quarkus reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Quarkus响应式API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus使用Mutiny模型提供了许多响应式API。在本节中，我们将看到如何使用响应式PostgreSQL驱动程序以一种非阻塞和响应式的方式与数据库交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new project using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令创建一个新项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application is interacting with a PostgreSQL database, so you need one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个应用程序与一个PostgreSQL数据库交互，所以你需要一个：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，让我们配置数据源。打开 `src/main/resources/application.properties` 并添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第3行定义数据源。最后一行将在应用程序中用于指示在应用程序初始化时是否插入一些条目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，让我们创建 _entity_。创建 `org.acme.reactive.crud.Fruit` 类具有以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个 _entity_ 包含一些字段和方法，用于从数据库中查找、更新和删除行。当检索到结果时，所生成的项被异步触发，这些方法返回 `Unis` 或 `Multis` 。注意，响应式PostgreSQL客户端已经提供了 `Uni` 和 `Multi` 实例。因此，您只需将来自数据库的结果转换为 _business-friendly_ 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了在应用程序启动时初始化数据库，我们将创建一个名为 `DBInit` 的类，其内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，让我们在 `FruitResource` 中使用这个 `Fruit` 类。编辑 `FruitResource` 类，匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个资源根据 `Fruit` 类产生的结果返回 `Uni` 和 `Multi` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前面的示例使用了Quarkus提供的_service_。同样，你也可以直接使用Vert.x客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，确保存在 `quarkus-vertx` 扩展。如果没有激活扩展，请执行如下命令来激活：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or add `quarkus-vertx` into your dependencies manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者手动将 `quarkus-vertx` 添加到依赖项中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有一个Mutiny 版本的Vert.x的API。这个API被分为几个可以独立导入的工件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您还可以在 http://smallrye.io/smallrye-reactive-utils/apidocs/ 上查看可用的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example.  Add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们举个例子。添加以下依赖到你的应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它提供了Vert.x Web客户端的Mutiny API。然后，您可以使用如下web客户端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 important points:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有两点很重要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入的 Vert.x 实例是 `io.vertx.mutiny.core.Vertx` 类型，它是 Vert.x 的 Mutiny 变量；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Web客户端是从 `io.vertx.mutiny.ext.web.client.WebClient` 创建的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny version of the Vert.x APIs also offers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny 版本的 Vert.x API 还提供：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`andAwait` 方法，例如 `sendAndAwait`。 `andAwait` 表示调用方线程被阻塞，直到结果可用。注意不要用这种方式阻塞事件循环/ IO线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`andForget` 方法，如 `writeAndForget`。 `andForget` 可用于返回 `Uni` 的方法。  `andForget` 表示你不需要结果的 `Uni` 来表示操作的成功或失败。但是请记住，如果您不订阅，操作将不会被触发。  `andForget` 为您管理这个和管理订阅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using RxJava or Reactor APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 RxJava 或 Reactor API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny提供工具来将 RxJava 2 和 Project Reactor 类型转换为 `Uni` 和 `Multi`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RxJava 2 converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RxJava 2转换器有以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，如果你有一个返回RxJava 2类型 (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`) 的API，你可以创建 `Unis` 和 `Multis` ，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into RxJava types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以将 `Unis` 和 `Multis` 转换成 RxJava 类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Reactor converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>项目 Reactor 转换器在以下依赖项中可用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>那么如果你有一个API返回 Reactor 类型 (`Mono`, `Flux`)，你可以创建 `Unis` 和 `Multis` 如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into Reactor types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以将 `Unis` 和 `Multis` 转换为 Reactor 类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using CompletionStages or Publisher API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用CompletionStages或Publisher API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier&lt;CompletionStage&gt;`. For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你面对的是使用 `CompletionStage`, `CompletableFuture` 或 `Publisher` 的API，你可以来回转换。首先， `Uni` 和 `Multi` 都可以从 `CompletionStage` 或 `Supplier&lt;CompletionStage&gt;`创建。例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `Uni` 上，你也可以使用 `subscribeAsCompletionStage()` 来产生一个 `CompletionStage` 。 `CompletionStage` 会获得由 `Uni` 发出的条目或失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以使用 `createFrom().publisher(Publisher)` 从 `Publisher` 的实例中创建 `Unis` 和 `Multis` 。你可以使用 `toMulti` 将 `Uni` 转换为 `Publisher` 。事实上， `Multi` 实现了 `Publisher`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南是关于Quarkus响应式的介绍。Quarkus 的许多特性已经具有了响应式风格。下面列出了一些例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mailer[Sending email]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mailer[发送电邮件]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:reactive-routes[Using reactive routes]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:reactive-routes[使用响应式路由]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use the CLI for your toolchain (coming soon)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何为你的工具链使用CLI（即将到来）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下命令运行该应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这会将以下内容添加到你的构建文件中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pom.xml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>build.gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>build.gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>像往常一样，该应用程序能够使用以下方式进行打包:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also generate the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你也可以通过以下命令生成本地可执行文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy Reactive Jackson and MongoDB Client extensions.  After this, the `quarkus-mongodb-client` extension has been added to your build file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个导入RESTEasy Reactive Jackson和MongoDB客户端扩展的Maven结构。在此之后， `quarkus-mongodb-client` 扩展已被添加到您的构建文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, create the `org.acme.mongodb.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，创建 `org.acme.mongodb.FruitResource` 类，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus will restrict the use of JNDI within an application, as a precaution to try and mitigate any future vulnerabilities similar to log4shell.  Because the `mongo+srv` protocol often used to connect to MongoDB requires JNDI, this protection is automatically disabled when using the MongoDB client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Quarkus会限制在应用程序中使用JNDI，作为一种预防措施，以尝试缓解所有将来类似于 log4shell 的漏洞。因为通常用于连接MongoDB的 `mongo+srv` 协议需要JNDI，所以在使用MongoDB客户端扩展时，这种保护会自动关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start Quarkus with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启动Quarkus：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus takes care of registering the `CodecProvider` for you as a CDI bean of `@Singleton` scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus负责为你注册 `CodecProvider` ，作为 `@Singleton` 范围的CDI bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The POJO Codec have enhanced generic support via `PropertyCodecProvider`, Quarkus will automatically register any `PropertyCodecProvider` with the POJO Codec (these classes are automatically made CDI beans of `@Singleton` scope).  When building native executables and using generic types, you might need to register the type arguments for reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POJO Codec通过 `PropertyCodecProvider` 增强了对泛型的支持，Quarkus会自动在POJO Codec中注册任何 `PropertyCodecProvider` （这些类会自动成为 `@Singleton` 范围的CDI bean）。当构建本地可执行文件和使用用泛型类型时，你可能需要用反射来注册类型参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The xref:mongodb-panache.adoc[MongoDB with Panache] extension facilitates the usage of MongoDB by providing active record style entities (and repositories) like you have in xref:hibernate-orm-panache.adoc[Hibernate ORM with Panache] and focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mongodb-panache.html[MongoDB with Panache] 扩展通过提供活动记录样式实体（和存储库）来促进 MongoDB 的使用，就像您在 link:hibernate-orm-panache.html[Hibernate ORM with Panache] 中所拥有的一样，并关注让你的实体在 Quarkus 中编写变得简单而有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/metrics` endpoint of your application you will have information about the connection pool status.  When using xref:smallrye-metrics.adoc[SmallRye Metrics], connection pool metrics will be available under the `vendor` scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>因此，当你访问你的应用程序的 `/q/metrics` 端点时，你将得到有关连接池状态的信息。当使用 link:smallrye-metrics.html[SmallRye Metrics] 时，连接池指标将在 `vendor` 范围内可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-opentracing` extension, `quarkus-mongodb-client` can register traces about the commands executed.  This behavior must be enabled by setting the `quarkus.mongodb.tracing.enabled` property to `true` in your `application.properties` and adding the dependency `io.opentracing.contrib:opentracing-mongo-common` to your pom.xml (for more info read the xref:opentracing.adoc#mongodb-client[OpenTracing - MongoDB client] section).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用 `quarkus-smallrye-opentracing` 扩展， `quarkus-mongodb-client` 可以注册关于所执行命令的跟踪。必须通过在你的 `application.properties` 中将 `quarkus.mongodb.tracing.enabled` 属性设置为 `true` 并在你的 pom.xml 中添加依赖性 `io.opentracing.contrib:opentracing-mongo-common` 来启用这一行为（更多信息请阅读 link:opentracing.html#mongodb-client[OpenTracing - MongoDB 客户端] 部分）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read the xref:opentracing.adoc[OpenTracing] guide, for how to configure OpenTracing and how to use the Jaeger tracer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>阅读 link:opentracing.html[OpenTracing] 指南，了解如何配置OpenTracing以及如何使用Jaeger追踪器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about the usage of a `QuarkusTestResourceLifecycleManager` please read xref:getting-started-testing.adoc#quarkus-test-resource[Quarkus test resource].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有关 `QuarkusTestResourceLifecycleManager` 的更多信息，请阅读 link:getting-started-testing.html#quarkus-test-resource[Quarkus测试资源] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the legacy API, you need to add the following dependency to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想使用旧的API，你需要在你的构建文件中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then build a native executable with the usual command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后你可以用常用的命令构建一个本地可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, Quarkus doesn't support link:https://docs.mongodb.com/manual/core/security-client-side-encryption/[Client-Side Field Level Encryption] in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目前，Quarkus在本地模式下不支持 link:https://docs.mongodb.com/manual/core/security-client-side-encryption/[客户端字段级加密] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using mongo+srv:// urls</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用mongo+srv:// urls</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mongo+srv://` urls are supported out of the box in JVM mode.  However, in native, the default DNS resolver, provided by the MongoDB client, uses JNDI and does not work in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mongo+srv://` urls在JVM模式下支持开箱即用。然而，在本地模式下，MongoDB客户端提供的默认DNS解析器使用的是JNDI，在本地模式下无法工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to use `mongo+srv://` in native mode, you can configure an alternative DNS resolver.  This feature is **experimental** and may introduce a difference between JVM applications and native applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要在原生模式下使用 `mongo+srv:` ，你可以配置一个备用的DNS解析器。此功能是**实验性**的，可能会在 JVM 应用程序和本机应用程序之间产生差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable the alternative DNS resolver, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要启用备用 DNS 解析器，请使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As indicated in the property name, it uses Vert.x to retrieve the DNS records.  By default, it tries to read the first `nameserver` from `/etc/resolv.conf`, if this file exists.  You can also configure your DNS server:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如属性名称所示，它使用 Vert.x 检索 DNS 记录。默认情况下，如果此文件存在，它会尝试从 `etcresolv.conf` 中读取第一个 `nameserver`。您还可以这样配置 DNS 服务器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, you can configure the lookup timeout using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，您可以使用以下方法配置来查找超时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南将 xref:getting-started.adoc[入门指南]中开发的应用程序作为输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is recommended for building native executables that target Linux containerized environments.  This means that Mandrel users are encouraged to use containers to build their native executables.  If you are building native executables for macOS, you should consider using Oracle GraalVM instead, because Mandrel does not currently target this platform.  Building native executables directly on bare metal Linux or Windows is possible, with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel被推荐用于构建针对Linux容器化环境的原生可执行文件。这意味着，我们鼓励Mandrel用户使用容器来构建他们的原生可执行文件。如果你要为macOS构建本地可执行文件，你应该考虑使用Oracle GraalVM，因为Mandrel目前不针对这个平台。直接在裸机Linux或Windows上构建原生可执行文件是可能的，详情可参见 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] 和 https://github.com/graalvm/mandrel/releases[Mandrel发行版] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the xref:getting-started.adoc[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 xref:getting-started.adoc[入门指南] 中开发的应用程序代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你还没有安装 GraalVM。那么你有几个选择：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate archive from &lt;https://github.com/graalvm/mandrel/releases&gt; or &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从 &lt;https://github.com/graalvm/mandrel/releases&gt; 或 &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt; 下载相应的归档文件，然后像对待其他 JDK 一样将其解压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://sdkman.io/jdks#Oracle[sdkman], https://github.com/graalvm/homebrew-tap[homebrew], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用特定平台的安装工具，如 https://sdkman.io/jdks#Oracle[sdkman] 、https://github.com/graalvm/homebrew-tap[homebrew] 或 https://github.com/ScoopInstaller/Java[scoop] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS (not supported by Mandrel), point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在macOS上（Mandrel不支持），将该变量指向 `Home` 子目录：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Only for Oracle GraalVM CE/EE) Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(仅适用于Oracle GraalVM CE/EE）使用 `gu install` 安装 `native-image` 工具：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用以下方法创建一个原生可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.  To produce a native executable, this means that the `--enable-preview` flag needs to be passed to the underlying native image invocation.  You can do so by prepending the flag with `-J` and passing it as additional native build argument: `-Dquarkus.native.additional-build-args=-J--enable-preview`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依赖于预览功能的Java代码需要特别注意。为了产生一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给底层的原生镜像调用。你可以这样做，用 `-J` 作为标志的前缀，并将其作为额外的原生构建参数传递：`-Dquarkus.native.additional-build-args=-J--enable-preview`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the future, `@NativeImageTest` will be deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在未来， `@NativeImageTest` 将被弃用，取而代之的是`@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 xref:getting-started-testing.adoc#quarkus-integration-test[测试指南]中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.  To test a native executable, this means that the `--enable-preview` flag needs to be passed to the Surefire plugin.  Adding `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` to its `configuration` section is one way to do so.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依赖于预览功能的Java代码需要特别注意。为了测试一个原生可执行文件，这意味着需要将 `--enable-preview` 标志传递给Surefire插件。将 `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` 添加到其 `configuration` 片段是一种可行方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Docker:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Docker：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For podman:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于podman：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the xref:container-image.adoc[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节见 xref:container-image.adoc[容器镜像指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually using the micro base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手动使用微基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native-micro` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>产生的可执行文件将是一个64位的Linux可执行文件，所以取决于您的操作系统，它可能不再能够运行。然而，这不是一个问题，因为我们要把它复制到一个容器中。生成的项目在 `src/main/docker` 目录中提供了一个 `Dockerfile.native-micro` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Micro Image?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>什么是Quarkus微镜像？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Micro Image is a small container image providing the right set of dependencies to run your native application.  It is based on https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro].  This base image has been tailored to work perfectly in containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 微镜像是一个小型的容器镜像，为运行你的原生应用程序提供了正确的依赖性集合。它是基于 https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro] 的。这个基础镜像已经被定制为在容器中完美运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI images on:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以在这里阅读更多关于UBI镜像的内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UBI images can be used without any limitations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UBI镜像可以不受任何限制地使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:quarkus-runtime-base-image.adoc[This page] explains how to extend the `quarkus-micro` image when your application has specific requirements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:quarkus-runtime-base-image.adoc[此页] 解释了当你的应用有特殊要求时，如何扩展 `quarkus-micro` 镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually using the minimal base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手工使用最小基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project generation has also provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目也在 `src/main/docker` 目录中提供了一个 `Dockerfile.native` ，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The UBI minimal image is bigger than the micro one mentioned above.  It contains more utilities such as the `microdnf` package manager.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UBI最小镜像比上面提到的微镜像要大。它包含更多的实用程序，如 `microdnf` 软件包管理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This multi-stage Docker build copies the Maven wrapper from the host machine.  The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.  It avoids having to create a base image with Maven and Gradle.  To provision the Maven Wrapper in your project, use: `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.0:wrapper`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这种多阶段Docker构建从主机上复制Maven包装器。Maven包装器（或Gradle包装器）是提供特定版本Maven/Gradle的一种便捷方式。它避免了用Maven和Gradle创建一个基础镜像。要在项目中配置Maven包装器，请使用： `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.0:wrapper` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see xref:native-and-ssl.adoc#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多信息请参见 xref:native-and-ssl.adoc#working-with-containers[我们的使用SSL与原生可执行文件指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a Distroless base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用无发行版基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distroless image support is experimental.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>无发行版支持是试验性的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distroless images should not be used in production without rigorous testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在没有经过严格测试的情况下，不应该在生产中使用无发行版镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable compression</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>原生可执行文件压缩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus can compress the produced native executable using UPX.  More details on xref:./upx.adoc[UPX Compression documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus可以使用UPX压缩产生的原生可执行文件。更多细节见 xref:./upx.adoc[UPX压缩文档] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development, macOS is not supported).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>从Oracle GraalVM 20.2或Mandrel 20.1开始，可以为Linux环境生成原生可执行文件的调试符号（Windows支持仍在开发中，不支持macOS）。这些符号可用于用工具调试原生可执行文件，如 `gdb` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.debug` 文件的生成取决于 `objcopy` 。在常见的Linux发行版上，你将需要安装 `binutils` 包：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a more detailed guide about debugging native images please refer to the xref:native-reference.adoc[Native Reference Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于调试原生镜像的更详细指南，请参考 xref:native-reference.adoc[原生参考指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the xref:deploying-to-kubernetes.adoc[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们建议继续阅读 xref:deploying-to-kubernetes.adoc[部署到Kubernetes和OpenShift]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension includes `kafka-clients` version 3.1.0 as a transitive dependency and is compatible with Kafka brokers version 2.x.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该扩展包括 `kafka-clients` 3.1.0版本的传递依赖，而且与Kafka broker 2.x版本兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.incoming.$channel.bootstrap.servers` property.  In dev mode and when running tests, &lt;&lt;kafka-dev-services&gt;&gt; automatically starts a Kafka broker.  When not provided this property defaults to `localhost:9092`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请务必为生产环境配置broker地址。您可以在全局环境配置或使用 `mp.messaging.incoming.$channel.bootstrap.servers` 属性来针对特定channel配置。在开发模式和运行测试时， &lt;&lt;kafka-dev-services&gt;&gt;会自动启动一个Kafka broker。如果没有提供这个属性，则默认为 `localhost:9092` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connector auto-attachment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Connector auto-attachment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a single connector on your classpath, you can omit the `connector` attribute configuration.  Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.  _Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的classpath上只有一个connector，您可以省略 `connector` 属性配置。Quarkus会自动将 _orphan_  channel 与classpath上找到的(唯一的)connector连接。 _Orphans_  channels 是没有下游消费者的发送 channels 或没有上游生产者的接收 channels 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This auto-attachment can be disabled using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以用以下方法禁用这种auto-attachment功能：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Detailed information on the usage of `@Blocking` annotation can be found in https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging – Handling blocking execution].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于 `@Blocking` 注解的详细信息，可以在 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging – 阻塞处理] 找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的方法加了 `@Transactional` 注解，那么它即使没有添加 `@Blocking` 注解也将被自动视为 _阻塞_ 方法 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ignore` performs no commit. This strategy is the default strategy when the consumer is explicitly configured with `enable.auto.commit` to true.  It delegates the offset commit to the underlying Kafka client.  When `enable.auto.commit` is `true` this strategy **DOES NOT** guarantee at-least-once delivery.  SmallRye Reactive Messaging processes records asynchronously, so offsets may be committed for records that have been polled but not yet processed.  In case of a failure, only records that were not committed yet will be re-processed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ignore` 不执行任何提交。当消费者的 `enable.auto.commit` 属性被明确配置为true时，该策略将是默认策略。它将偏移量的提交委托给底层Kafka client负责。当 `enable.auto.commit` 为true的时候 ，该策略 *不* 保证至少会有一次提交。SmallRye Reactive Messaging是异步处理记录的，所以那些已经被轮询但尚未处理的record的偏移量有可能会被提交。如果提交失败，只有那些尚未被提交的record才会被重新处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling Deserialization Failures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反序列化失败的处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a deserialization failure occurs, you can intercept it and provide a failure strategy.  To achieve this, you need to create a bean implementing `DeserializationFailureHandler&lt;T&gt;` interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当反序列化失败发生时，您可以对其进行拦截并提供一个失败处理策略。为了实现这一点，您需要创建一个实现 `DeserializationFailureHandler&lt;T&gt;` 接口的bean：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (for key or value deserializers).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用这个故障处理的handler，Bean必须使用 `@Identifier` 限定符来暴露，并且connector配置必须指定属性 `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (对于键或值的反序列化器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The handler is called with details of the deserialization, including the action represented as `Uni&lt;T&gt;`.  On the deserialization `Uni` failure strategies like retry, providing a fallback value or applying timeout can be implemented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个handler在被调用提供反序列化的细节，包括以 `Uni&lt;T&gt;` 所表示的操作(action)。在 `Uni` 提供的反序列化错误处理策略中，可以实现例如重试，提供回调(fallback)值或超时处理等等方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receiving Kafka Records in Batches</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>批量接收Kafka记录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, incoming methods receive each Kafka record individually.  Under the hood, Kafka consumer clients poll the broker constantly and receive records in batches, presented inside the `ConsumerRecords` container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，接收方法会单独接收每条Kafka记录。在后台，Kafka消费者client会不断地轮询broker，并批量接收记录然后放入 `ConsumerRecords` 容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In *batch* mode, your application can receive all the records returned by the consumer *poll* in one go.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 *批量* 模式下，您的程序可以一次性接收消费者 *轮询* 返回的所有记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To achieve this you need to specify a compatible container type to receive all the data:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了达到这一点，您需要指定一个兼容的容器类型来接收所有数据：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The incoming method can also receive `Message&lt;List&lt;Payload&gt;&gt;`, `KafkaRecordBatch&lt;Key, Payload&gt;` `ConsumerRecords&lt;Key, Payload&gt;` types.  They give access to record details such as offset or timestamp:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接收方法也可以接收 `Message&lt;List&lt;Payload&gt;&gt;` , `KafkaRecordBatch&lt;Key, Payload&gt;` `ConsumerRecords&lt;Key, Payload&gt;` 等类型。这些类型可以访问记录的细节，如偏移量或时间戳：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the successful processing of the incoming record batch will commit the latest offsets for each partition received inside the batch.  The configured commit strategy will be applied for these records only.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意，对于接收到的记录批次的成功处理会提交所收到批次内每个分区的最新偏移量。所配置的提交策略将只应用于这些记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conversely, if the processing throws an exception, all messages are _nacked_, applying the failure strategy for all the records inside the batch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反之，如果处理过程抛出一个异常，所有的消息都_不会被确认(nacked)_ ，并且对批次中的所有记录应用失败策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus autodetects batch types for incoming channels and sets batch configuration automatically.  You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batch` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus自动检测incoming channels 的批处理类型并自动设置批处理配置。您可以用 `mp.messaging.incoming.$channel.batch` 配置批处理模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.outgoing.$channel.bootstrap.servers` property.  In dev mode and when running tests, &lt;&lt;kafka-dev-services&gt;&gt; automatically starts a Kafka broker.  When not provided, this property defaults to `localhost:9092`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请配置生产环境的broker位置。您可以在全局配置，或使用 `mp.messaging.outgoing.$channel.bootstrap.servers` 来针对特定channel配置它。在开发模式和运行测试时， &lt;&lt;kafka-dev-services&gt;&gt;会自动启动一个Kafka broker。如果该属性未提供，它将默认为 `localhost:9092` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on how to use `Emitter` can be found in https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/emitter/emitter.html#_emitter_and_channel[SmallRye Reactive Messaging – Emitters and Channels]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于如何使用 `Emitter` ，可在 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/emitter/emitter.html#_emitter_and_channel[SmallRye Reactive Messaging – Emitters and Channels] 中找到更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling Serialization Failures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理序列化失败</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Kafka producer client serialization failures are not recoverable, thus the message dispatch is not retried. In these cases you may need to apply a failure strategy for the serializer.  To achieve this, you need to create a bean implementing `SerializationFailureHandler&lt;T&gt;` interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Kafka生产者客户端来说序列化失败是不可恢复的，因此消息发送不会被重试。在这些情况下，您可能需要为序列化器设置一个失败策略。为了实现这一点，您需要一个实现了 `SerializationFailureHandler&lt;T&gt;` 接口的bean：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (for key or value serializers).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用该故障处理，Bean必须用 `@Identifier` 限定符修饰，并且connector的配置必须指定属性 `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (对于键或值序列化器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The handler is called with details of the serialization, including the action represented as `Uni&lt;byte[]&gt;`.  Note that the method must await on the result and return the serialized byte array.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>处理器被调用，并被提供序列化的细节，包括以 `Uni&lt;byte[]&gt;` 表示的操作。注意，该方法必须对在结果处进行等待，并返回序列化后的字节数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `default-kafka-broker` configuration map contains all application properties prefixed with `kafka.` or `KAFKA_`.  For more configuration options check out &lt;&lt;kafka-configuration-resolution&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`default-kafka-broker` 配置map包含所有以 `kafka.` 或 `KAFKA_` 为前缀的应用属性。更多的配置选项，请查看 link:#kafka-configuration-resolution[[kafka配置方案]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in support for JSON serialization and deserialization based on Jackson.  It will also &lt;&lt;serialization-generation, generate&gt;&gt; the serializer and deserializer for you, so you do not have to configure anything.  When generation is disabled, you can use the provided `ObjectMapperSerializer` and `ObjectMapperDeserializer` as explained below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus内置了对基于Jackson的JSON序列化和反序列化的支持。它也会为您 link:#serialization-generation[生成] 序列化器和反序列化器，所以您不需要配置任何东西。当生成器被禁用时，您可以提供 `ObjectMapperSerializer` 和 `ObjectMapperDeserializer` ，如下所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `ObjectMapperSerializer` serializes null as the `"null"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `ObjectMapperSerializer` 将null序列化为 `"null"` 字符串，这可以通过设置Kafka配置属性 `json.serialize.null-as-null=true` ，将null序列化为 `null` 。这在使用压缩的topic时很方便，因为 `null` 被用作标记来表示在压缩阶段哪些消息被删除了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deserialize a list of fruits, you need to create a deserializer with a Jackson `TypeReference` denoted the generic collection used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想反序列化一个fruit对象列表，您需要创建一个反序列化器，它会用Jackson `TypeReference` 表示所用到的通用集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `JsonbSerializer` serializes null as the `"null"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下， `JsonbSerializer` 将null序列化为 `"null"` 字符串，这可以通过设置Kafka配置属性 `json.serialize.null-as-null=true` 来将null序列化为 `null` 。这在使用压缩的topic时很方便，因为 `null` 被用作标记来表示在压缩阶段哪些消息被删除了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deserialize a list of fruits, you need to create a deserializer with a `Type` denoted the generic collection used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想反序列化一个fruit对象列表，您需要创建一个反序列化器，它会用一个 `Type` 表示所用到的通用集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is described in a dedicated guide: xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这部分在一个专门的指南中有所描述。 link:kafka-schema-registry-avro.html[使用Apache Kafka与Schema Registry和Avro协同工作] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using SmallRye Reactive Messaging with Kafka (`io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), Quarkus can often automatically detect the correct serializer and deserializer class.  This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用SmallRye Reactive Messaging with Kafka ( `io.quarkus:quarkus-smallrye-reactive-messaging-kafka` )时，Quarkus通常可以自动检测可用的序列化器和反序列化器类。这种自动检测是基于 `@Incoming` 和 `@Outgoing` 方法的声明，以及注入的 `@Channel` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus automatically generates serializers and deserializers for channels where:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下情况下，Quarkus会自动为 channels 生成序列化器和反序列化器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It uses Jackson underneath.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它的底层使用了Jackson。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This generation can be disabled using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以用以下方法禁用这种生成机制：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generation does not support collections such as `List&lt;Fruit&gt;`.  Refer to &lt;&lt;jackson-serialization&gt;&gt; to write your own serializer/deserializer for this case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成机制不支持诸如 `List&lt;Fruit&gt;` 这样的集合。请参考 link:#jackson-serialization[[jackson序列化]] 为这种情况编写您自己的序列化器/反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is described in a dedicated guide: xref:kafka-streams.adoc[Using Apache Kafka Streams].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这部分在专门的指南中有所描述：link:kafka-streams.html[使用Apache Kafka流] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's say we want to test the following processor application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>假设我们想测试以下的处理器应用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add the following test dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在您的应用程序中添加以下测试依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the incoming channel `orders` (expecting messages from Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将传入 channel  `orders` (等待来自Kafka的消息)切换到内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the outgoing channel `beverages` (writing messages to Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将出站 channel `beverages`(向Kafka写消息)切换到内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the outgoing channel (`beverages`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>检索传出 channel  ( `beverages` ) - 该 channel 必须在测试资源中被切换到内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `send` method to send a message to the `orders` channel.  The application will process this message and send a message to `beverages` channel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `send` 方法向 `orders`  channel 发送一个消息。应用程序将处理这个消息并向 `beverages`  channel 发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `received` method on `beverages` channel to check the messages produced by the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `beverages`  channel 上使用 `received` 方法来检查应用程序产生的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With in-memory channels we were able to test application code processing messages without starting a Kafka broker.  Note that different in-memory channels are independent, and switching channel connector to in-memory does not simulate message delivery between channels configured to the same Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有了内存 channels ，我们就可以测试应用程序代码的消息方法，而无需启动Kafka broker。请注意，不同的内存 channel 是独立的，将 channel 连接器切换到内存中并不能模拟配置到同一Kafka topic的 channel 之间的消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Kafka extension supports xref:deploying-to-kubernetes.adoc[Service Binding Specification for Kubernetes].  You can enable this by adding the `quarkus-kubernetes-service-binding` extension to your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Kafka扩展支持 link:deploying-to-kubernetes.html[Kubernetes服务绑定规范] 。您可以通过添加 `quarkus-kubernetes-service-binding` 扩展来启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于SmallRye Reactive Messaging配置的更多细节可以在 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector文档] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most important attributes are listed in the tables below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下表格中列出了最重要的属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#consumerconfigs[Kafka consumer].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以传递底层 link:https://kafka.apache.org/documentation/#consumerconfigs[Kafka消费者] 支持的任何属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to configure the `max.poll.records` property, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，要配置 `max.poll.records` 属性，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some consumer client properties are configured to sensible default values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些消费者客户端属性被配置为相对合理的默认值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, `reconnect.backoff.max.ms` is set to `10000` to avoid high load on disconnection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置， `reconnect.backoff.max.ms` 则会被配置为 `10000` ，以避免断开时导致的高负载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, `key.deserializer` is set to `org.apache.kafka.common.serialization.StringDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置， `key.deserializer` 则会被设置为 `org.apache.kafka.common.serialization.StringDeserializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumer `client.id` is configured according to the number of clients to create using `mp.messaging.incoming.[channel].partitions` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费者 `client.id` 会根据使用 `mp.messaging.incoming.[channel].partitions` 属性创建的客户端数量进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a `client.id` is provided, it is used as-is or suffixed with client index if `partitions` property is set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果提供了一个 `client.id` ，它将直接被使用， 或者如果 `partitions` 属性被设置的话，则会被加上客户端索引的后缀。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a `client.id` is not provided, it is generated as `kafka-consumer-[channel][-index]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有提供 `client.id` ，则使用 `kafka-consumer-[channel][-index]` 来生成 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some producer client properties are configured to sensible default values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一些生产者客户端属性被配置为合理的默认值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, `key.serializer` is set to `org.apache.kafka.common.serialization.StringSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置， `key.serializer` 则会被设置为 `org.apache.kafka.common.serialization.StringSerializer` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, producer `client.id` is generated as `kafka-producer-[channel]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置，生产者 `client.id` 则会按照 `kafka-producer-[channel]` 来生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus exposes all Kafka related application properties, prefixed with `kafka.` or `KAFKA_` inside a configuration map with `default-kafka-broker` name.  This configuration is used to establish the connection with the Kafka broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus公开了所有与Kafka相关的应用属性，这些属性使用 `default-kafka-broker` 名称加 `kafka.` 或 `KAFKA_` 的前缀 。这个配置被用来建立与Kafka broker的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to this default configuration, you can configure the name of the `Map` producer using the `kafka-configuration` attribute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了这个默认配置外，您还可以使用 `kafka-configuration` 属性配置 `Map` 生产者的名称：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the connector looks for the `Map` associated with the `my-configuration` name.  If `kafka-configuration` is not set, an optional lookup for a `Map` exposed with the channel name (`my-channel` in the previous example) is done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，连接器会查询与 `my-configuration` 名称相关的 `Map` 。如果没有设置 `kafka-configuration` ，就会进行额外的查询来寻找与 channel 名称相关的 `Map` (在前面的例子中是 `my-channel` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `kafka-configuration` is set and no `Map` can be found, the deployment fails.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果设置了 `kafka-configuration` ，但没有找到 `Map` ，则部署会失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute values are resolved as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性值的解决方式如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the attribute is set directly on the channel configuration (`mp.messaging.incoming.my-channel.attribute=value`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性是直接在 channel 配置上设置的( `mp.messaging.incoming.my-channel.attribute=value` ),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if not set, the connector looks for a `Map` with the channel name or the configured `kafka-configuration` (if set) and the value is retrieved from that `Map`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有设置，连接器会使用 channel 名称或 `kafka-configuration` (如果设置了)来查找查找一个 `Map` ，并从 `Map` 中取值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the resolved `Map` does not contain the value the default `Map` is used (exposed with the `default-kafka-broker` name)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `Map` 不包含该值，则使用默认的 `Map` (通过 `default-kafka-broker` 名称暴露)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we are writing in a database, we must be in a transaction. This annotation starts a new transaction and commits it when the method returns.  Quarkus automatically considers the method as _blocking_. Indeed, writing to a database using classic Hibernate is blocking. So, Quarkus calls the method on a worker thread you can block (and not an I/O thread).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于我们是往数据库中写入数据，所以必须使用事务。这个注解启动了一个新的事务，并在方法返回时提交它。Quarkus会自动认为这个方法是 _阻塞的_ 。事实上，使用常规的Hibernate方法向数据库写入是阻塞操作。所以，Quarkus会在一个可阻塞的工作线程中调用这个方法(而不是在I/O线程中)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To reduce the amount of log written by the Kafka client, Quarkus sets the level of the following log categories to `WARNING`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了减少Kafka客户端的日志量，Quarkus将以下日志类别的级别设置为 `WARNING`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.clients`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.clients`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.common.utils`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.common.utils`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.common.metrics`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.common.metrics`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the configuration by adding the following lines to the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过在 `application.properties` 中添加以下属性来覆盖配配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_For more information about how to install the Quarkus CLI and use it, please refer to xref:cli-tooling.adoc[the Quarkus CLI guide]._</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_关于如何安装并使用Quarkus CLI并的更多信息，请参考xref:cli-tooling.adoc[Quarkus CLI指南]。_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, run `curl localhost:8080/count` to check the counter value.  After a few seconds, re-run `curl localhost:8080/count` to verify the counter has been incremented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在另一个终端，运行 `curl localhost:8080/count` 检查计数器的值。几秒钟后，重新运行 `curl localhost:8080/count` ，以验证计数器已被递增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might need to add it as a dependency explicitly if you are using transactions directly without Hibernate ORM for example.  Add the following to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不使用Hibernate ORM而直接使用事务，你可能需要明确地将其作为一个依赖项加入，例如。在你的构建文件中添加以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to propagate your transaction context across your reactive pipeline, please see the xref:context-propagation.adoc[Context Propagation guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要在你的响应式管道中传播你的事务上下文，请看 link:context-propagation.html[上下文传播指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not the connector should insert automatically the `time` attribute into the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `time` attribute itself

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接器是否应将 `time` 属性自动添加到发出的云事件中。要求 `cloud-events` 被设置为 `true` 。如果消息本身没有配置 `time` 属性，则使用此值

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open your browser to http://localhost:8080/greeting.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的浏览器中打开 http://localhost:8080/greeting 网页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache provides active record style entities (and repositories) like you have in xref:hibernate-orm-panache.adoc[Hibernate ORM with Panache] and focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB提供了活跃的记录风格的实体（和存储库），就像你在 link:hibernate-orm-panache.html[带有Panache的Hibernate ORM] 中所拥有的那样，并专注于使你的实体在Quarkus中编写起来既简单又有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is built on top of the xref:mongodb.adoc[MongoDB Client] extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它是建立在 link:mongodb.html[MongoDB客户端] 扩展之上的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy Reactive Jackson and MongoDB with Panache extensions.  After this, the `quarkus-mongodb-panache` extension has been added to your build file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个Maven结构，导入RESTEasy Reactive Jackson和MongoDB with Panache扩展。在此之后， `quarkus-mongodb-panache` 扩展已被添加到您的构建文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to generate a new project, add the dependency in your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你不想生成一个新的项目，可以在你的构建文件中添加该依赖关系：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the name of the client for multi-tenant application, see xref:mongodb.adoc#multiple-mongodb-clients[Multiple MongoDB Clients]. Otherwise, the default client will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多租户应用程序的客户端名称，见 link:mongodb.html#multiple-mongodb-clients[多个MongoDB客户端] 。否则，将使用默认客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For advanced configuration of the MongoDB client, you can follow the xref:mongodb.adoc#configuring-the-mongodb-database[Configuring the MongoDB database guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于MongoDB客户端的高级配置，你可以遵循配置 link:mongodb.html#configuring-the-mongodb-database[MongoDB数据库指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, include one of the RESTEasy extensions to enable JAX-RS endpoints, for example, add the `io.quarkus:quarkus-resteasy-reactive-jackson` dependency for JAX-RS and JSON support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，包括RESTEasy的一个扩展，以启用JAX-RS端点，例如，添加 `io.quarkus:quarkus-resteasy-reactive-jackson` 依赖来支持JAX-RS和JSON。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache uses the link:{mongodb-doc-root-url}/bson/pojos[PojoCodecProvider], with link:{mongodb-doc-root-url}/pojos/#pojo-support[automatic POJO support], to automatically convert your object to a BSON document.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache的MongoDB使用 link:{mongodb-doc-root-url}/bson/pojos[PojoCodecProvider] ， link:{mongodb-doc-root-url}/pojos/#pojo-support[自动支持POJO] ，自动将你的对象转换为BSON文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your class doesn't obey these rules (for example by including a method that starts with `get` but is not a setter), you could provide a custom codec for it.  Your custom codec will be automatically discovered and registered inside the codec registry.  See xref:mongodb.adoc#simplifying-mongodb-client-usage-using-bson-codec[Using BSON codec].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的类不遵守这些规则（例如，包括一个以 `get` 开始但不是setter的方法），你可以为它提供一个自定义的编解码器。你的自定义编解码器将被自动发现并在编解码器注册表内注册。参见 link:mongodb.html#simplifying-mongodb-client-usage-using-bson-codec[使用BSON编解码器] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you can create a BSON Codec which will be automatically registered by Quarkus and will be used instead of the `PojoCodecProvider`.  See this part of the documentation: xref:mongodb.adoc#simplifying-mongodb-client-usage-using-bson-codec[Using BSON codec].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，你可以创建一个BSON编解码器，它将被Quarkus自动注册，并代替 `PojoCodecProvider` 。见这部分文档。 link:mongodb.html#simplifying-mongodb-client-usage-using-bson-codec[使用BSON编解码器] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _preview_, backward compatibility and presence in the ecosystem is not guaranteed.  Specific improvements might require changing configuration or APIs, and plans to become _stable_ are under way.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 _preview(预览)_ 中，不保证向后兼容和在生态系统中的存在。具体的改进可能需要改变配置或API，并且正在计划变得 _稳定_ 。欢迎在我们的 link:https://groups.google.com/d/forum/quarkus-dev[邮件列表] 中提供反馈，或在我们的 link:https://github.com/quarkusio/quarkus/issues[GitHub问题列表] 中提出问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a full list of possible statuses, check our https://quarkus.io/faq/#extension-status[FAQ entry].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>想要了解完整的扩展状态信息，请查看 https://quarkus.io/faq/#extension-status[常见问题入口] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What we're doing in Panache is to allow you to write your Hibernate ORM entities like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panache允许这样编写Hibernate ORM实体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the xref:hibernate-orm.adoc#setting-up-and-configuring-hibernate-orm[Hibernate set-up guide for all configuration].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>按照 link:hibernate-orm.html#setting-up-and-configuring-hibernate-orm[Hibernate 设置指南] 进行其他配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your build file, add the following dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的项目构建文件中，添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Hibernate ORM with Panache extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM with Panache扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can reference a named query instead of a (simplified) HQL query by prefixing its name with the '#' character. You can also use named queries for count, update and delete queries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>除了上述的简化HQL查询以外，你还可以定义一个命名查询，然后通过'#'字符加命名来（在HQL中）引用它。在计数、更新和删除查询中也可以使用命名查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation of the `project(Class)` method uses the constructor's parameter names to build the select clause of the query, so the compiler must be configured to store parameter names inside the compiled class.  This is enabled by default if you are using the Quarkus Maven archetype. If you are not using it, add the property `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `project(Class)` 方法的实现中，使用构造函数的参数名来构建查询的select子句，所以编译器必须配置为在编译的类中保留参数名。如果是使用Quarkus Maven archetype创建的项目，该功能默认是启用的。如果你没有使用，请在你的 `pom.xml` 中添加该属性 `&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for multiple persistence units is described in detail in xref:hibernate-orm.adoc#multiple-persistence-units[the Hibernate ORM guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 link:hibernate-orm.html#multiple-persistence-units[Hibernate ORM指南] 中对多个持久化单元的支持有详细描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional EE patterns advise to split entity definition (the model) from the operations you can do on them (DAOs, Repositories), but really that requires a split between the state and its operations even though we would never do something like that for regular objects in the Object Oriented architecture, where state and methods are in the same class. Moreover, this requires two classes per entity, and requires injection of the DAO or Repository where you need to do entity operations, which breaks your edit flow and requires you to get out of the code you're writing to set up an injection point before coming back to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的EE模式建议将实体定义（模型）与它可以进行的操作（DAO、Repository）分开，但实际上这需要将实体状态及其操作分开；但在面向对象的架构里我们不会对普通对象这样做，因为普通对象的状态和方法在同一个类中。此外，这样需要每个实体对应两个类，并且要在需要进行实体操作的地方注入DAO或Repository，这就破坏了你的开发流程，需要你从正在编写的代码中跳出来，建立一个注入点，然后再回来使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use public fields. Get rid of dumb getter and setters. Hibernate ORM w/o Panache also doesn't require you to use getters and setters, but Panache will additionally generate all getters and setters that are missing, and rewrite every access to these fields to use the accessor methods. This way you can still write _useful_ accessors when you need them, which will be used even though your entity users still use field accesses. This implies that from the Hibernate perspective you're using accessors via getters and setters even while it looks like field accessors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用public字段，抛开愚蠢的getter和setter方法。Hibernate ORM Panache不要求你使用getter和setter方法，但Panache会额外生成所有缺失的getter和setter方法，并将所有对这些字段的访问重写为getter/setter方法的调用。这样，当你需要的时候，仍可以编写 _有用的_ 访问器，即使实体类的调用者仍然使用字段访问，实际也会使用这些访问器。这意味着从Hibernate的角度来看，你正在通过getter和setter方法使用访问器，即使代码看起来像字段访问器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and running the application does not change either.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>打包和运行应用程序也不会改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the following command as usual:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以像往常一样使用以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or to build a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者构建一个原生可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also package the application in a container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>还可以将应用程序打包在容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters passed to the application are described in the datasource guide.  There are other ways to configure the application - please check the xref:config-reference.adoc#configuration_sources[configuration guide] to have an overview of the possibilities (such as env variable, .env files and so on).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传递给应用程序的参数在数据源指南中进行了描述。还有其他配置应用程序的方法 - 请查看 xref:config-reference.adoc#configuration_sources[配置指南]来概览各种可能性（例如env变量，.env文件等等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project and imports the `quarkus-opentelemetry-exporter-otlp` extension, which includes the OpenTelemetry support, and a gRPC span exporter for https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md[OTLP].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成Maven项目并导入 `quarkus-opentelemetry-exporter-otlp` 扩展，其中包括OpenTelemetry支持，以及 link:https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md[OTLP] 的gRPC span exporter。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `src/main/java/org/acme/opentelemetry/TracedResource.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建一个 `src/main/java/org/acme/opentelemetry/TracedResource.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start the OpenTelemetry Collector and Jaeger system via the following `docker-compose.yml` file that you can launch via `docker-compose up -d`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您可以通过 `docker-compose up -d` 命令和下面的 `docker-compose.yml` 文件来启动OpenTelemetry Collector和Jaeger系统：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identifier of a CDI bean that provides the default Kafka consumer/producer configuration for this channel. The channel configuration can still override any attribute. The bean must have a type of Map&lt;String, Object&gt; and must use the @io.smallrye.common.annotation.Identifier qualifier to set the identifier.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为通道提供默认Kafka消费者/生产者配置的CDI bean的标识符。通道自身的配置仍可以覆盖任何属性。该bean必须有一个Map&lt;String, Object&gt;的类型，并且必须使用@io.smallrye.common.annotation.Identifier限定符来设置标识符。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler`. If set, serialization failure happening when serializing keys are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler` 的bean的名称。如果被设置，那么在序列化键时发生的序列化失败将被委托给这个处理程序，它会重试或提供一个回退值。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler`. If set, serialization failure happening when serializing values are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler` 的bean的名称。如果被设置，那么在序列化值时发生的序列化失败将被委托给这个处理程序，它会重试或提供一个回退值。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用常用命令构建本机可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `--gradle` or `--gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Grade项目，请添加 `--gradle` 或者 `--gradle-kotlin-dsl` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `-DbuildTool=gradle` or `-DbuildTool=gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Grade项目，请添加 `-DbuildTool=gradle` 或者 `-DbuildTool=gradle-kotlin-dsl` 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roughly {prerequisites-time}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大概{prerequisites-time}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roughly 15 minutes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>大概15分钟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编辑器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker or Podman)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以工作的容器 (Docker或者Podman)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally the xref:cli-tooling.adoc[Quarkus CLI] if you want to use it</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你愿意的话，还可以选择使用xref:cli-tooling.adoc[Quarkus CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally Mandrel or GraalVM installed and xref:building-native-image.adoc#configuring-graalvm[configured appropriately] if you want to build a native executable (or Docker if you use a native container build)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你想构建原生可执行程序，可以选择安装Mandrel或者GraalVM，并xref:building-native-image.adoc#configuring-graalvm[正确配置](或者使用Docker在容器中进行构建)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel or GraalVM installed and xref:building-native-image.adoc#configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以安装Mandrel或者GraalVM，并xref:building-native-image.adoc#configuring-graalvm[正确配置]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ease the containerization of native executables, Quarkus provides a base image providing the requirements to run these executables.  The `quarkus-micro-image:1.0` image is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了简化本地可执行文件的容器化步骤，Quarkus提供了一个包含运行这些可执行文件依赖的基础镜像。 `quarkus-micro-image:1.0` 镜像是:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>small (based on `ubi8-micro`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>小的 (基于 `ubi8-micro` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>contains the right set of dependencies (glibc, libstdc++, zlib)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>包含正确的依赖项（glibc、libstdc++、zlib）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>support upx-compressed executables (more details on the xref:upx.adoc[enabling compression documentation])</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持upx压缩的可执行文件（更多相关细节在 link:upx.html[启用压缩文档] 中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the base image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用此基础镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `Dockerfile`, just use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的 `Dockerfile` 中，只需使用:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending the image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展该镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your application may have additional requirements.  For example, if you have an application that requires `libfreetype.so`, you need to copy the native libraries to the container.  In this case, you need to use a multi-stage `dockerfile` to copy the required libraries:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的应用程序可能有其他的额外要求。例如，如果你有一个依赖于 `libfreetype.so` 的应用程序，你需要将本地库拷贝到容器当中。在这种情况下，你需要使用一个多阶段的 `dockerfile` 来拷贝所需要的依赖库:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Second stage - copy the dependencies
FROM quay.io/quarkus/quarkus-micro-image:1.0
COPY --from=BUILD \
   /lib64/libfreetype.so.6 \
   /lib64/libbz2.so.1 \
   /lib64/libpng16.so.16 \
   /lib64/
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 第二阶段 - 拷贝依赖库
FROM quay.io/quarkus/quarkus-micro-image:1.0
COPY --from=BUILD \
   /lib64/libfreetype.so.6 \
   /lib64/libbz2.so.1 \
   /lib64/libpng16.so.16 \
   /lib64/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to have access to the full AWT support, you need more than just `libfreetype.so`, but also the font and font configurations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要获得对AWT的完整支持，你需要的不仅仅是 `libfreetype.so` ，同时还需要字体和字体配置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Second stage - copy the dependencies
FROM quay.io/quarkus/quarkus-micro-image:1.0
COPY --from=BUILD \
   /lib64/libfreetype.so.6 \
   /lib64/libgcc_s.so.1 \
   /lib64/libbz2.so.1 \
   /lib64/libpng16.so.16 \
   /lib64/libm.so.6 \
   /lib64/libbz2.so.1 \
   /lib64/libexpat.so.1 \
   /lib64/libuuid.so.1 \
   /lib64/
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># 第二阶段 - 拷贝依赖库
FROM quay.io/quarkus/quarkus-micro-image:1.0
COPY --from=BUILD \
   /lib64/libfreetype.so.6 \
   /lib64/libgcc_s.so.1 \
   /lib64/libbz2.so.1 \
   /lib64/libpng16.so.16 \
   /lib64/libm.so.6 \
   /lib64/libbz2.so.1 \
   /lib64/libexpat.so.1 \
   /lib64/libuuid.so.1 \
   /lib64/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative - Using ubi-minimal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>替代方案 - 使用 ubi-minimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the micro image does not suit your requirements, you can use https://catalog.redhat.com/software/containers/ubi8/ubi-minimal/5c359a62bed8bd75a2c3fba8[UBI- Minimal].  It's a bigger image, but contains more utilities and is closer to a full Linux distribution.  Typically, it contains a package manager (`microdnf`), so you can install packages more easily.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果微镜像不符合你的要求，你可以使用 https://catalog.redhat.com/software/containers/ubi8/ubi-minimal/5c359a62bed8bd75a2c3fba8[UBI- Minimal]。这是一个更大的镜像，但包含了更多实用程序 且更接近于完整的 Linux 发行版。通常，它包含一个包管理器 (`microdnf`)，因此你可以利用它更方便地安装软件包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this base image, use the following `Dockerfile`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要使用该基础镜像，使用以下 `Dockerfile`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a project which imports the `spring-cloud-config-client` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个已导入 `spring-cloud-config-client` 扩展的项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a simple `GreetingResource` JAX-RS resource in the `src/main/java/org/acme/spring/cloud/config/client/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在 `src/main/java/org/acme/spring/cloud/config/client/GreetingResource.java` 文件中创建一个简单的包含以下内容的 `GreetingResource` JAX-RS资源:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can of course create a native image using the instructions of the xref:building-native-image.adoc[Building a native executable guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当然，你也可以使用 link:building-native-image.html[构建本地可执行文件指南] 的说明来创建一个本地镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used. MongoDB with Panache offers a new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already covered in the xref:mongodb-panache.adoc[MongoDB with Panache guide].  In this guide, we'll cover the Kotlin specific changes needed to use MongoDB with Panache in your Kotlin-based Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB是一个众所周知的NoSQL数据库，被广泛使用。MongoDB与Panache在这个熟悉的框架之上提供了一个新的层次。本指南将不深入讨论这两者的具体细节，因为这些内容已经在 link:mongodb-panache.html[MongoDB with Panache指南] 中涵盖。在本指南中，我们将介绍在基于Kotlin的Quarkus应用程序中使用MongoDB with Panache所需的Kotlin特定变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more examples, please consult the xref:mongodb-panache.adoc[Java version] for complete details.  Both APIs are the same and work identically except for some Kotlin-specific tweaks to make things feel more natural to Kotlin developers.  These tweaks include things like better use of nullability and the lack of `Optional` on API methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>关于更多的例子，请参考 link:mongodb-panache.html[Java版本] 以获取完整详细信息。除了一些针对Kotlin的调整以使Kotlin开发者感觉更自然外，两个API都是一样的，工作方式也是一样的。这些调整包括更好地使用nullability和API方法上缺乏 `Optional` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also build the native executable using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以用以下方法构建原生(native)可执行文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:maven-tooling.adoc[Maven]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:maven-tooling.adoc[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:gradle-tooling.adoc[Gradle]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:gradle-tooling.adoc[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:cli-tooling.adoc[CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:cli-tooling.adoc[CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:ide-tooling.adoc[IDE]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:ide-tooling.adoc[IDE]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd , (don't use backward slash `\` and put everything on the same line)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用cmd ，（不要使用反斜线 `\` ，并将所有内容放在同一行）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes e.g. `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果使用Powershell，用双引号包住 `-D` 参数，例如： `"-DprojectArtifactId=getting-started"` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version of the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一旦生成，请看 `pom.xml` 。你会发现Quarkus BOM的导入，允许你省略不同Quarkus依赖的版本。此外，你可以看到 `quarkus-maven-plugin` ，负责应用程序的打包，也提供开发模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a Gradle project, you would find a similar setup:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在Gradle项目中，你会发现一个类似的设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Quarkus Gradle plugin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Gradle插件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `enforcedPlatform` directive for the Quarkus BOM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`enforcedPlatform` ，用于指示Quarkus BOM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/GreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在项目创建过程中， `src/main/java/org/acme/GreetingResource.java` 文件已被创建，其内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在我们已经准备好运行我们的应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus中的依赖注入是基于ArC的，ArC是一个基于CDI的依赖注入解决方案，。如果你是CDI的新手，那么我们推荐你阅读 link:cdi.html[CDI简介] 指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus only implements a subset of the CDI features and comes with non-standard features and specific APIS, you can learn more about it in the xref:cdi-reference.adoc[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus只实现了CDI功能的一个子集，并且带有非标准的功能和特定的APIS，你可以在 link:cdi-reference.html[Contexts和依赖注入指南] 中了解更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>让我们修改应用程序并添加一个bean。创建 `src/main/java/org/acme/GreetingService.java` 文件，内容如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you stopped the application (keep in mind you don't have to do it, changes will be automatically deployed by our live reload feature), restart the application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你停止了应用程序（请记住，你不必这样做，变化将由我们的实时重载功能自动部署），用以下方法重新启动应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then check that the endpoint returns `hello quarkus` as expected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后检查端点是否按预期返回 `hello quarkus` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus:dev` 在开发模式下运行Quarkus。这使得后台编译的实时重载成为可能，这意味着当你修改你的Java文件或者资源文件并刷新你的浏览器时，这些变化将自动生效。这也适用于资源文件，如配置属性文件。刷新浏览器会触发对工作区的扫描，如果检测到任何变化，Java文件会被重新编译，应用程序会被重新部署；然后你的请求会被重新部署的应用程序提供服务。如果编译或部署有任何问题，错误页面会让你知道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the generated build file, you can see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在生成的构建文件中，你可以看到2个测试依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[JUnit 5] tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus支持 link:https://junit.org/junit5/[JUnit 5] 测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of this, in the case of Maven, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support JUnit 5:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正因为如此，就Maven而言，必须设置 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] 的版本，因为默认版本不支持JUnit 5：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging` system property to make sure tests will use the correct log manager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还设置了 `java.util.logging` 系统属性，以确保测试将使用正确的日志管理器和 `maven.home` ，以确保应用 `${maven.home}/conf/settings.xml` 的自定义配置（如果有的话）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成的项目包含一个简单的测试。编辑 `src/test/java/org/acme/GreetingResourceTest.java` ，以匹配以下内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the xref:maven-tooling.adoc#multi-module-maven[Maven] or xref:gradle-tooling.adoc#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不过，在处理多模块项目时，请务必阅读 link:maven-tooling.html#multi-module-maven[Maven] 或 link:gradle-tooling.html#multi-module-maven[Gradle] 指南中的 `多模块项目` 部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to read the xref:cdi-reference.adoc#bean_discovery[Bean Discovery] section of the CDI guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请务必阅读CDI指南中的 link:cdi-reference.html#bean_discovery[Bean发现] 部分以了解更多信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is packaged using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该应用程序是用以下方式打包的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It produces several outputs in `/target`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它在 `/target` ，产生几个输出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the xref:building-native-image.adoc[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the xref:getting-started-reactive.adoc[Getting Started with Reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本指南涵盖了使用 Quarkus 创建应用程序的内容。 然而，下面还有更多内容。 我们建议您继续学习 xref:building-native-image.adoc[构建本地可执行文件指南]，您可以在其中了解如何创建本地可执行文件并将其打包到容器中。 如果您对响应式感兴趣，我们推荐 xref:getting-started-reactive.adoc[响应式入门指南]，您可以在其中了解如何使用 Quarkus 实现响应式应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the xref:tooling.adoc[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>此外，xref:tooling.adoc[工具指南] 文档解释了如何做到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And executed using `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并使用 `java -jar target/quarkus-app/quarkus-run.jar` 命令运行该应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a new project, importing the Redis extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令可生成一个新项目，并导入Redis扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the test class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建测试类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/test/java/org/acme/redis/IncrementResourceTest.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建 `src/test/java/org/acme/redis/IncrementResourceTest.java` 文件，内容如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Redis Client Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入有命名的Redis客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing Redis Hosts Programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以编程方式设定Redis主机</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `RedisHostsProvider` programmatically provides redis hosts. This allows for configuration of properties like redis connection password coming from other sources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisHostsProvider` 接口支持以编程方式设定Redis主机。这个机制支持了从其他来源获取Redis连接属性进行配置，如Redis连接密码等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful as it removes the need to store sensitive data in application.properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这样可以避免在application.properties中存储敏感数据，很实用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The host provider can be used to configure the redis client like shown below</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RedisHostsProvider` 可用于配置Redis客户端，如下图所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful to create a client dynamically in a non-CDI bean e.g a xref:hibernate-orm-panache.adoc[Panache entity].  Or to create a different client when running in pub/sub mode. This mode requires two different connections because once a connection invokes a subscriber mode then it cannot be used for running other commands than the command to leave that mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这对于在非CDI bean中动态地创建客户端非常有用，例如在 link:hibernate-orm-panache.html[Panache 实体类] 中使用Redis客户端，或者在pub/sub模式下运行时创建一个不同的客户端。这种模式需要两个不同的客户端连接，因为如果某个连接使用了订阅者模式，那么它就不能用于运行其他命令，直到退出订阅者模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see also &lt;&lt;redis-reference.adoc#custom_redis_commands,How to use custom Redis Commands&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参考 &lt;&lt;redis-reference.adoc#custom_redis_commands,如何使用自定义Redis命令&gt;&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable YAML configuration, add the `quarkus-config-yaml` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要启用YAML配置，添加以下 `quarkus-config-yaml` 扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports both the `yml` and `yaml` file extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus同时支持 `yml` 和 `yaml` 文件扩展名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While users are encouraged to use xref:scheduler.adoc#standard-scheduling[regular Quarkus scheduler], Quarkus provides a compatibility layer for Spring Scheduled in the form of the `spring-scheduled` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然我们鼓励用户使用 link:scheduler.html#standard-scheduling[常规 Quarkus调度器] ，但Quarkus以 `spring-scheduled` 扩展的形式为Spring Scheduled提供了一个兼容层。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the resource and the test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建资源和测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `CountResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建包含以下内容的 `CountResource` 类:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, create the `org.acme.rest.json.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在，创建 `org.acme.rest.json.FruitResource` 类，如下所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Fruit` objects will be automatically serialized/deserialized by https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] or https://github.com/FasterXML/jackson[Jackson], depending on the extension you chose when initializing the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Fruit` 对象将被 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] 或 link:https://github.com/FasterXML/jackson[Jackson] 自动序列化/反序列化，这取决于你在初始化项目时选择的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建本地可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to use custom Redis Commands</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如何使用自定义Redis命令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the list of commands which are supported out-of-box by both https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] and https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] depends on what is available in https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`], then there might be case when you need a command which is not (yet) available via https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] 和 https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] 开箱即支持的命令列表取决于 https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] 所支持的命令，那么可能会出现你需要用的命令 https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] （还）不支持的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such case (if you don't want to wait for the new command to be supported in https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`]), you can implement it in either https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] or https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`].  In order to do so, you will need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在这种情况下，如果你不想等到未来版本的 link:https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] 支持这些命令，可以在 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] 或 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] 中实现它们。实现自定义的Redis命令需要：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate a new `Command` based on the nodejs code available in https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 link:https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] 仓库中的Nodejs代码，生成一个新的 `Command`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't have a Redis service running locally, you can run Redis in a Docker container:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你没有本地运行的Redis服务，可以在Docker容器中运行Redis：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, while being in https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] root folder execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，在 link:https://github.com/vert-x3/vertx-redis-client[`vertx-redis-client`] 的根目录下执行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above sequence of commands should update the https://github.com/vert-x3/vertx-redis-client/blob/master/src/main/java/io/vertx/redis/client/Command.java[`Command.java`] file, so it includes all the possible commands supported by a particular Redis version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上的几行命令会更新 link:https://github.com/vert-x3/vertx-redis-client/blob/master/src/main/java/io/vertx/redis/client/Command.java[`Command.java`] 文件，使其包含指定版本的 Redis 的所有支持的命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This definition is very important as we will have to use it in the service.  Once we have this `Command` we can start to update the redis-client extension by:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们需要在服务中使用这个Redis命令，因此这个定义非常重要。有了这个 `Command` 定义后，我们就可以开始更新redis-client扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] interface, i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/RedisClient.java[`RedisClient`] 接口，即：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisClientImpl.java[`RedisClientImpl`], i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisClientImpl.java[`RedisClientImpl`] ，即：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] interface, i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/reactive/ReactiveRedisClient.java[`ReactiveRedisClient`] 接口，即：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/ReactiveRedisClientImpl.java[`ReactiveRedisClientImpl`], i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新 link:https://github.com/quarkusio/quarkus/blob/main/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/ReactiveRedisClientImpl.java[`ReactiveRedisClientImpl`] ，即：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that it's using the `MutinyRedis` class which does asynchronous calls to Redis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，上述代码使用 `MutinyRedis` 类异步调用Redis命令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>启用事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Red Panda broker does not act as a transaction coordinator.  To enable transactions, set:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，Red Panda broker不会作为一个事务协调器来运行。如果想启用事务，请设置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also enables producer idempotence support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这同样会启用生产者幂等性支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that even numbers are added to the list, and odd numbers remove an element from the list.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在这里偶数被添加到列表中，而到奇数时列表将删除一个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start your application in dev mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下启动您的应用程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then try the following sequence and look for `example_list_size` in the plain text output:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后尝试以下命令并在文本输出中找出 `example_list_size` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did not leave Quarkus running in dev mode, start it again:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您的Quarkus从之前的开发模式下退出了，那么请再次启动它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then execute the following sequence:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后执行以下命令序列：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure the following dependency is present in your build file if you require the MicroProfile Metrics API:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要使用MicroProfile Metrics API，请确保您的构建文件中存在以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using verticles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用verticles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is "a simple, scalable, actor-like deployment and concurrency model" provided by _Vert.x_.  This model does not claim to be a strict actor-model implementation, but it shares similarities, especially concerning concurrency, scaling, and deployment.  To use this model, you write and _deploy_ verticles, communicating by sending messages on the event bus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/vertx-core/java/#&lt;em&gt;verticles[Verticles] 是_Vert.x提供的 "一个简单的、可扩展的、类似于演员的部署和并发模型"。这个模型并不声称是一个严格的actor-model实现，但它有相似之处，特别是关于并发、扩展和部署。为了使用这个模型，你编写和 _部署_ 顶点，通过在事件总线上发送消息进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy verticles, use the `deployVerticle` method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要部署verticles，使用 `deployVerticle` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the Mutiny-variant of Vert.x, be aware that the `deployVerticle` method returns a `Uni`, and you would need to trigger a subscription to make the actual deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你使用Vert.x的Mutiny-variant，请注意 `deployVerticle` 方法返回一个 `Uni` ，你需要触发一个订阅来进行实际部署。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using @ApplicationScoped Beans as Verticle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用@ApplicationScoped Beans作为Verticle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, Vert.x verticles are not CDI beans.  And so cannot use injection.  However, in Quarkus, you can deploy verticles as beans.  Note that in this case, CDI (Arc in Quarkus) is responsible for creating the instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般来说，Vert.x的verticles不是CDI beans。所以不能使用注入。然而，在Quarkus中，你可以把verticle部署为Bean。注意，在这种情况下，CDI（Quarkus中的Arc）负责创建实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following snippet provides an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下代码段提供了一个示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to inject the `vertx` instance; instead, leverage the protected field from `AbstractVerticle`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你不需要注入 `vertx` 实例；相反，你可以利用 `AbstractVerticle` 的受保护字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using multiple verticles instances</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用多个verticles的实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@ApplicationScoped`, you will get a single instance for your verticle.  Having multiple instances of verticles can be helpful to share the load among them.  Each of them will be associated with a different I/O thread (Vert.x event loop).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `@ApplicationScoped` ，你将为你的verticle获得一个实例。拥有多个verticles的实例可以帮助他们分担负载。它们中的每一个都将与不同的I/O线程相关联（Vert.x事件循环）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy multiple instances of your verticle, use the `@Dependent` scope instead of `@ApplicationScoped`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要部署 Verticle 的多个实例，请使用 `@Dependent` 范围而不是 `@ApplicationScoped` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, deploy your verticle as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，按以下方式部署你的verticle：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `init` method receives an `Instance&lt;MyVerticle&gt;`.  Then, you pass a supplier to the `deployVerticle` method.  The supplier is just calling the `get()` method.  Thanks to the `@Dependent` scope, it returns a new instance on every call.  Finally, you pass the desired number of instances to the `DeploymentOptions`, such as two in the previous example.  It will call the supplier twice, which will create two instances of your verticle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`init` 方法接收一个 `Instance&lt;MyVerticle&gt;` 。然后，你将提供者传递给 `deployVerticle` 方法。该提供者只是在调用 `get()` 方法。由于 `@Dependent` 范围，它每次调用都会返回一个新的实例。最后，你向 `DeploymentOptions` 传递所需的实例数量，比如在前面的例子中是两个。它将调用提供者两次，这将为你的verticle创建两个实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NB: For Gradle project setup please see below, and for further reference consult the guide in the xref:gradle-tooling.adoc[Gradle setup page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意：关于Gradle项目的设置，请见下文，如需进一步参考，请查阅 link:gradle-tooling.html[Gradle设置页面] 的指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When adding `kotlin` to the extensions list, the Maven plugin will generate a project that is properly configured to work with Kotlin. Furthermore the `org.acme.ReactiveGreetingResource` class is implemented as Kotlin source code (as is the case with the generated tests).  The addition of `resteasy-reactive-jackson` in the extension list results in importing the RESTEasy Reactive and Jackson extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 `kotlin` 添加到扩展列表后，Maven插件将生成一个经过正确配置的项目，以便与Kotlin一起工作。此外， `org.acme.ReactiveGreetingResource` 类会通过kotlin代码来进行实现（与生成的测试一样）。在扩展列表中添加 `resteasy-reactive-jackson` ，就会导入RESTEasy Reactive和Jackson扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ReactiveGreetingResource.kt` looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingResource.kt` 看起来像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also update the `ReactiveGreetingResource.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们还要这样更新 `ReactiveGreetingResource.kt` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With these changes in place the `/hello` endpoint will reply with a JSON object instead of a simple String.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>经过这些更改， `/hello` 端点将用一个JSON对象而不是一个简单的字符串来响应请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the test pass, we also need to update `ReactiveGreetingResourceTest.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了使测试通过，我们还需要像这样更新 `ReactiveGreetingResourceTest.kt` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see this feature in action, first execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要体验到这个功能的作用，首先要执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When executing an HTTP GET request against `http://localhost:8080/hello`, you see a JSON message with the value `hello` as its `message` field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当执行一个对 `http://localhost:8080/hello`  的HTTP GET请求时，您会看到一个JSON消息，其 `message` 字段的值是 `hello` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now using your favorite editor or IDE, update `ReactiveGreetingResource.kt` and change the `hello` method to the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在使用您喜欢的编辑器或IDE，更新 `ReactiveGreetingResource.kt` ，并将 `hello` 方法改为如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now execute an HTTP GET request against `http://localhost:8080/hello`, you should see a JSON message with the value `hi` as its `message` field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当您现在执行一个对 `http://localhost:8080/hello` 的HTTP GET请求时，您应该会看到一个JSON消息，其 `message` 字段的值是 `hi` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and executed with `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>并可以使用 `java -jar target/quarkus-app/quarkus-run.jar`  来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `com.fasterxml.jackson.module:jackson-module-kotlin` dependency and the `quarkus-jackson` extension (or one of the `quarkus-resteasy-jackson` or `quarkus-resteasy-reactive-jackson` extensions) have been added to the project, then Quarkus automatically registers the `KotlinModule` to the `ObjectMapper` bean (see xref:rest-json.adoc#jackson[this] guide for more details).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果 `com.fasterxml.jackson.module:jackson-module-kotlin` 依赖和 `quarkus-jackson` 扩展（或 `quarkus-resteasy-jackson` 或 `quarkus-resteasy-reactive-jackson` 其中之一）已经被添加到项目中，那么 Quarkus 会自动将 `KotlinModule` 注册到 `ObjectMapper` Bean 中（更多细节请参见 link:rest-json.html#jackson[这篇指南] ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When working with the `quarkus-kubernetes` extension and have Kotlin classes bound to CustomResource definitions (like you do for building operators), you need to be aware that the underlying Fabric8 Kubernetes Client uses its own static Jackson `ObjectMapper` s, which can be configured as follows with the `KotlinModule`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `quarkus-kubernetes` 扩展并让Kotlin类绑定到CustomResource定义时（就像您在构建operator时一样），您需要注意底层的Fabric8 Kubernetes客户端使用它自己的静态Jackson `ObjectMapper` 对象，您可以这样为其配置 `KotlinModule` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Please test this carefully on compilation to native images and fallback to Java-compatible Jackson bindings if you experience problems._</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_请在编译到native-image时仔细测试，如果遇到问题，请退回到与Java兼容的Jackson binding。_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, prefer the use of constructor injection which works without modification of the Java examples, increases testability and complies best to a Kotlin programming style.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，更喜欢使用构造函数注入，它可以在不修改Java示例的情况下工作，提高可测试性，并且最符合Kotlin编程风格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Boot `@ConfigurationProperties` has a few limitations. For instance, `Map` injection is not supported. Consider using xref:config-mappings.adoc[Mapping configuration to objects].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Boot `@ConfigurationProperties` 有一些限制。例如，不支持 `Map` 注入。你可以考虑使用 link:config-mappings.html[将配置映射到对象] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a project and imports the `spring-boot-properties` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成一个项目并导入了 `spring-boot-properties` 扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a `GreetingResource` JAX-RS resource in the `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，在 `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` 文件中创建一个包含如下内容的 `GreetingResource` JAX-RS资源:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application in dev mode with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在开发模式下运行该应用程序:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While using the `throttled` commit-strategy, specify the max age in milliseconds that an unprocessed message can be before the connector is marked as unhealthy. Setting this attribute to 0 disables this monitoring.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在使用 `throttled` 提交策略时，指定未处理的消息在连接器被标记为不健康之前的可存续的最大时间（毫秒）。将此属性设置为0可以禁用该监控。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `partitions` is greater than 1, this attribute allows configuring how many records are requested by each consumers every time.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当 `partitions` 大于1时，这个属性配置每个消费者每次允许请求多少条记录。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing keys are delegated to this handler which may retry or provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler` 的bean的名称。如果被设置，那么在反序列化键时发生的反序列化失败将被委托给这个处理程序，它可以重试或提供一个回退值。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing values are delegated to this handler which may retry or provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在 `@Identifier` 中设置的实现了 `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler` 的bean的名称。如果被设置，那么在反序列化值时发生的反序列化失败将被委托给这个处理程序，它可以重试或提供一个回退值。

类型: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When no deserialization failure handler is set and a deserialization failure happens, report the failure and mark the application as unhealthy. If set to `false` and a deserialization failure happens, a `null` value is forwarded.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当没有设置反序列化失败处理程序而反序列化失败发生时，报告该失败并将应用程序标记为不健康。如果设置为 `false` 并且发生了反序列化失败，会发送一个 `null` 。

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the Kafka records are consumed in batch. The channel injection point must consume a compatible type, such as `List&lt;Payload&gt;` or `KafkaRecordBatch&lt;Payload&gt;`.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>是否启用Kafka记录的批处理。通道的注入点必须消费一个兼容的类型，例如 `List&lt;Payload&gt;` 或 `KafkaRecordBatch&lt;Payload&gt;`.

类型: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiplier factor to determine maximum number of records queued for processing, using `max.poll.records` * `max-queue-size-factor`. Defaults to 2. In `batch` mode `max.poll.records` is considered `1`.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用于决定队列中待处理的记录的最大值的乘数因子，使用 `max.poll.records` * `max-queue-size-factor` 来决定。默认为2。在 `batch` 模式下 `max.poll.records` 为 `1`。

类型: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`resteasy-reactive-jackson`, which also brings `resteasy-reactive`. We are going to use it to expose our HTTP endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`resteasy-reactive-jackson` ，它也带来了 `resteasy-reactive` 。我们将使用它来暴露出我们的HTTP端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you open the generated build file, you can see the selected extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你打开生成的构建文件，你可以看到以下选定的扩展:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are in your build file, add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你的构建文件中，添加以下依赖项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Inject the event bus. Alternatively you can use `vertx.eventBus()`.
&lt;2&gt; We receive a _name_ as a query parameter
&lt;3&gt; We use the `request` method to initiate the request-reply interaction. We send the name to the "greetings" address.
&lt;4&gt; When the response is received, we extract the body and return it as the HTTP response
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 注入事件总线。或者你可以使用 `vertx.eventBus()` 
&lt;2&gt; 我们接收到一个姓名作为查询参数 
&lt;3&gt; 我们使用 `request` 方法来发起请求-回复的交互。我们将姓名发送到 "greetings" 地址 
&lt;4&gt; 收到响应后，我们提取正文并将其作为 HTTP 响应进行返回 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Declaring a CDI Bean in the Application scope. Quarkus will create a single instance of this class.
&lt;2&gt; Use the `@ConsumeEvent` annotation to declare a consumer. It is possible to use the Vert.x API https://vertx.io/docs/vertx-core/java/#_acknowledging_messages_sending_replies[directly] too.
&lt;3&gt; Receive the message payload as a method parameter. The returned object will be the reply.
&lt;4&gt; Return the response. This response is sent back to the `VertxResource` class
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 以 Application scope 声明一个 CDI Bean。 Quarkus 将会为此类创建一个单实例对象。
&lt;2&gt; 使用 `@ConsumeEvent` 注解声明一个消费者. 你也可以直接使用 Vert.x API https://vertx.io/docs/vertx-core/java/#_acknowledging_messages_sending_replies[directly] 。
&lt;3&gt; 接收消息负载作为方法的参数。返回的对象将会被作为回复。
&lt;4&gt; 返回该响应。该响应将会被发送回 `VertxResource` 类
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; Store the `WebClient`, so we will be able to use it in our HTTP endpoint
&lt;2&gt; Create the `WebClient`. Be sure to use the `io.vertx.mutiny.ext.web.client.WebClient` class
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 存储 `WebClient`，以便我们在 HTTP 端点中使用它
&lt;2&gt; 创建 `WebClient`。确保使用 `io.vertx.mutiny.ext.web.client.WebClient` 类
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;1&gt; This endpoint returns a JSON Array. Vert.x provides a convenient way to manipulate JSON Object and Array. More details about these in xref:vertx-reference.adoc#using-vert-x-json[the reference guide].
&lt;2&gt; Send a `GET` request to the Wikipedia API
&lt;3&gt; Once the response is received, extract it as a JSON Object
&lt;4&gt; Extract the `langlinks` array from the response.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;1&gt; 该端点返回一个 JSON 数组。Vert.x 提供了一种便捷的方式来操作 JSON 对象和数组。 有关这些的更多详细信息，请参阅 xref:vertx-reference.adoc#using-vert-x-json[参考指南] 
&lt;2&gt; 向 Wikipedia API 发送 `GET` 请求 
&lt;3&gt; 收到响应后，将其提取为 JSON 对象 
&lt;4&gt; 从响应中提取 `langlinks` 数组 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen, the event bus is the connecting tissue of Vert.x applications.  Quarkus integrates it so different beans can interact with asynchronous messages.  This part is covered in the xref:reactive-event-bus.adoc[event bus documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如我们所见，事件总线是 Vert.x 应用程序之间的连接桥梁。 Quarkus 集成了它，因此不同的bean之间能够以异步消息的方式进行交互。这部分内容包含在 xref:reactive-event-bus.adoc[事件总线文档] 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to implement highly performant, low-overhead database applications on Quarkus with the xref:reactive-sql-clients.adoc[Reactive SQL Clients].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>了解如何使用 xref:reactive-sql-clients.adoc[响应式SQL客户端] 在 Quarkus 上实现高性能、低开销的数据库应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details please refer to the xref:logging.adoc#logging-adapters[Logging guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更多细节请参考 xref:logging.adoc#logging-adapters[日志指南]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `GreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要看到 `GreetingResourceIT` 面向原生可执行文件运行，使用 `./mvnw verify -Pnative` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This procedure was formerly accomplished using the `@NativeImageTest` annotation. `@NativeImageTest` is considered deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个过程以前是用 `@NativeImageTest` 注释来完成的。 `@NativeImageTest` 正考虑被废弃掉，而采用 `@QuarkusIntegrationTest` ，它提供了 `@NativeImageTest` 的测试能力的超集。关于 `@QuarkusIntegrationTest` 的更多信息可以在 xref:getting-started-testing.adoc#quarkus-integration-test[测试指南] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, integration tests both *build* and *run* the native executable using the `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>默认情况下，集成测试使用 `prod` 配置文件 *build* 和 *run* 原生可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable *runs* with during the test using the `quarkus.test.native-image-profile` property.  Either by adding it to `application.properties` or by appending it to the command line: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  Your `%test.` prefixed properties will be used at the test runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以在可执行文件 *runs* 测试期间覆盖配置文件的 `quarkus.test.native-image-profile` 属性。添加到 `application.properties` 或将其附加到命令行： `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`。您的 `%test.` 前缀属性将在测试运行时使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable is *built* with and *runs* with using the `quarkus-profile=test` property, e.g.  `./mvnw clean verify -Pnative -Dquarkus-profile=test`. This might come handy if there are test specific resources to be processed, such as importing test data into the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可以使用 `quarkus-profile=test` 属性覆盖可执行文件 *built* 和 *runs* 的配置文件。例如 `./mvnw clean verify -Pnative -Dquarkus-profile=test`。如果要处理特定于测试的资源，例如将测试数据导入数据库，那么这可能会很方便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the aforementioned example in your `application.properties`, your Hibernate ORM managed database will be populated with test data both during the JVM mode test run and during the native mode test run. The production executable will contain only the `version.txt` resource, no superfluous test data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在前面提到的 `application.properties` 例子中。在JVM模式测试运行期间和原生模式测试运行期间，Hibernate ORM管理的数据库将填充测试数据。生产可执行文件将只包含 `version.txt` 资源，没有多余的测试数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable built with `-Dquarkus-profile=test` is not suitable for production deployment.  It contains your test resources files and settings. Once the testing is done, the executable would have to be built again, using the default, `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `-Dquarkus-profile=test` 构建的可执行文件不适合生产部署。它包含您的测试资源文件和设置。一旦测试完成，就必须使用默认的 `prod` 配置文件再次构建可执行文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnIntegrationTest` annotation in order to skip them when testing against a native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您像我们上面建议的那样在JVM和原生执行之间共享测试类，您可以使用 `@DisabledOnIntegrationTest` 注解标记某些测试，以便在针对原生镜像进行测试时跳过它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@DisabledOnIntegrationTest` will also disable the test in all integration test instances, including testing the application in JVM mode, in a container image, and native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `@DisabledOnIntegrationTest` 还将禁用所有集成测试实例中的测试，包括在JVM模式、容器镜像和原生镜像中测试应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test -Pnative`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>也可以针对已经建立的原生可执行文件重新运行测试。要做到这一点，运行 `./mvnw test-compile failsafe:integration-test -Pnative`。这将发现现有的原生镜像，并使用failsafe对其运行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When consuming messages with `@Channel`, the application code is responsible for the subscription.  In the example above, the RESTEasy Reactive endpoint handles that for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用 `@Channel` 消费消息时，代码需要负责消息订阅。在上面的例子中，RESTEasy Reactive endpoint 已负责为您处理了这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During normal operation, a Kafka consumer preserves the order of records inside each partition assigned to it.  Smallrye Reactive Messaging keeps this order for processing, unless `@Blocking(ordered = false)` is used (see &lt;&lt;blocking-processing&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正常操作中，Kafka消费者会保留分配给它的每个分区里面的records的顺序。Smallrye Reactive Messaging会使用这个顺序进行处理，除非设置了 `@Blocking(ordered = false)` (参见&lt;&lt;blocking-processing&gt;&gt; )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that due to consumer rebalances, Kafka consumers only guarantee at-least-once processing of single records, meaning that uncommitted records _can_ be processed again by consumers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，由于消费者之间的再平衡(rebalances)，Kafka消费者只保证对单一records的至少一次(at-least-once)处理，这意味着未提交的records _可以_ 被消费者再次处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka transactions enable atomic writes to multiple Kafka topics and partitions.  The Kafka connector provides `KafkaTransactions` custom emitter for writing Kafka records inside a transaction.  It can be injected as a regular emitter `@Channel`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务支持对多个 Kafka 主题和分区进行原子写入。 Kafka 连接器提供了 `KafkaTransactions` 自定义emitter，用于在事务中写入 Kafka 记录。 它可以作为常规emitter `@Channel` 注入：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function given to the `withTransaction` method receives a `TransactionalEmitter` for producing records, and returns a `Uni` that provides the result of the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传入 `withTransaction` 方法的函数参数会使用 `TransactionalEmitter` 来产生记录，并返回 `Uni` 做为事务结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the processing completes successfully, the producer is flushed and the transaction is committed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果处理成功完成，则刷新生产者并提交事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the processing throws an exception, returns a failing `Uni`, or marks the `TransactionalEmitter` for abort, the transaction is aborted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果处理过程抛出异常，会返回失败的 `Uni`，或将 `TransactionalEmitter` 标记为中止，然后事务会被中止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka transactional producers require configuring `acks=all` client property, and a unique id for `transactional.id`, which implies `enable.idempotence=true`.  When Quarkus detects the use of `KafkaTransactions` for an outgoing channel it configures these properties on the channel, providing a default value of `"${quarkus.application.name}-${channelName}"` for `transactional.id` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务生产者需要配置 `acks=all` 客户端属性，以及 `transactional.id` 的唯一 id，这意味着 `enable.idempotence=true` 。 当 Quarkus 检测到传出通道使用 `KafkaTransactions` 时，它会在通道上配置这些属性，为 `transactional.id` 属性提供默认值 `"${quarkus.application.name}-${channelName}"` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that for production use the `transactional.id` must be unique across all application instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，要在生产环境使用，必须确保 `transactional.id` 在所有应用实例中是唯一的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While a normal message emitter would support concurrent calls to `send` methods and consequently queues outgoing messages to be written to Kafka, a `KafkaTransactions` emitter only supports one transaction at a time.  A transaction is considered in progress from the call to the `withTransaction` until the returned `Uni` results in success or failure.  While a transaction is in progress, subsequent calls to the `withTransaction`, including nested ones inside the given function, will throw `IllegalStateException`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然普通的消息emitter支持并发调用 `send` 方法并将要写入 Kafka 的传出消息顺序排队，但 `KafkaTransactions` emitter每次只支持一个事务。 从调用 `withTransaction` 直到返回的 `Uni` 导致成功或失败，事务被视为正在进行中。 当事务正在进行时，对 `withTransaction` 的后续调用，包括给定函数内的嵌套调用，都将抛出 `IllegalStateException` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in Reactive Messaging, the execution of processing methods, is already serialized, unless `@Blocking(ordered = false)` is used.  If `withTransaction` can be called concurrently, for example from a REST endpoint, it is recommended to limit the concurrency of the execution.  This can be done using the `@Bulkhead` annotation from link:https://quarkus.io/guides/smallrye-fault-tolerance[_Microprofile Fault Tolerance_].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，在 Reactive Messaging 中，处理方法的执行已经被序列化，除非使用了 `@Blocking(ordered = false)` 。 如果可以同时调用 `withTransaction` ，例如从 REST 节点，建议限制执行的并发性。 这可以使用后面链接中的 `@Bulkhead` 注释来完成：link:https://quarkus.io/guides/smallrye-fault-tolerance[_Microprofile Fault Tolerance_]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example usage can be found in &lt;&lt;chaining-kafka-transactions-with-hibernate-reactive-transactions&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>示例用法可以在 &lt;&lt;chaining-kafka-transactions-with-hibernate-reactive-transactions&gt;&gt; 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction-aware consumers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事务感知型消费者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you'd like to consume records only written and committed inside a Kafka transaction you need to configure the `isolation.level` property on the incoming channel as such:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想使用仅在 Kafka 事务中写入和提交的记录，您需要在传入通道上配置 `isolation.level` 属性，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Dev Services for Kafka using Redpanda, you need to &lt;&lt;kafka-dev-services.adoc#redpanda-enabling-transactions, enable transactions&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用 Redpanda 为 Kafka 使用 Dev Services，您需要 &lt;&lt;kafka-dev-services.adoc#redpanda-enabling-transactions, enable transactions&gt;&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exactly-Once Processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>（Exactly-Once Processing）精确一次处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Transactions allows managing consumer offsets inside a transaction, together with produced messages.  This enables coupling a consumer with a transactional producer in a _consume-transform-produce_ pattern, also known as *exactly-once processing*.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka 事务可以同时管理其中的消费端和生产端的消息偏移量。 这使得消费端能够以 _consume-transform-produce_ 模式与生产端耦合，也称为 *exactly-once 精确一次性处理*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KafkaTransactions` custom emitter provides a way to apply exactly-once processing to an incoming Kafka message inside a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KafkaTransactions` 定制emitter可以提供一种对事务中传入的 Kafka 消息进行一次性处理的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example includes a batch of Kafka records inside a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下示例包括在事务中进行 Kafka 记录的批处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended to use exactly-once processing along with the batch consumption mode.  While it is possible to use it with a single Kafka message, it'll have a significant performance impact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>建议在消费端批处理模式中采用exactly-once。 虽然可以将它与单个 Kafka 消息一起使用，但这样会对性能产生重大影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed `KafkaRecordBatch` message is passed to the `KafkaTransactions#withTransactionAndAck` in order to handle the offset commits and message acks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消费的 `KafkaRecordBatch` 消息被传递给 `KafkaTransactions#withTransactionAndAck` ，以处理偏移提交和消息确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `send` method writes records to Kafka inside the transaction, without waiting for send receipt from the broker.  Messages pending to be written to Kafka will be buffered, and flushed before committing the transaction.  It is therefore recommended configuring the `@OnOverflow` `bufferSize` in order to fit enough messages, for example the `max.poll.records`, maximum amount of records returned in a batch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`send` 方法将记录通过事务写入 Kafka，而无需等待来自代理的发送回执。 等待写入 Kafka 的消息将被缓冲，并在提交事务之前刷新。 因此，建议配置 `@OnOverflow` `bufferSize` 以适应足够的消息，例如 `max.poll.records`，即批处理中返回的最大记录数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the processing completes successfully, _before committing the transaction_, the topic partition offsets of the given batch message will be committed to the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果处理成功完成，_在提交事务之前_ ，给定批处理消息的主题分区偏移量将提交给事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the processing needs to abort, _after aborting the transaction_, the consumer's position is reset to the last committed offset, effectively resuming the consumption from that offset. If no consumer offset has been committed to a topic-partition, the consumer's position is reset to the beginning of the topic-partition, _even if the offset reset policy is `latest`_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果处理需要中止，_在中止事务后_ ，消费者的位置将重置为最后提交的偏移量，能有效地从该偏移量恢复消费。 如果没有消费者偏移量被提交到主题分区，消费者的位置将被重置到主题分区的开头，_即使把 `latest` 做为偏移量重置策略_ 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using exactly-once processing, consumed message offset commits are handled by the transaction and therefore the application should not commit offsets through other means.  The consumer should have `enable.auto.commit=false` (the default) and set explicitly `commit-strategy=ignore`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用（exactly-once）精确一次处理时，消耗的消息偏移量提交由事务处理，因此应用程序不应通过其他方式提交偏移量。 消费者应该有 `enable.auto.commit=false` （默认）并明确设置 `commit-strategy=ignore` ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error handling for the exactly-once processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>（exactly-once）精确一次处理的错误处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Uni` returned from the `KafkaTransactions#withTransaction` will yield a failure if the transaction fails and is aborted.  The application can choose to handle the error case, but if a failing `Uni` is returned from the `@Incoming` method, the incoming channel will effectively fail and stop the reactive stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果事务失败并被中止，则从 KafkaTransactions#withTransaction 返回的 `Uni` 将产生失败。 应用程序可以选择处理错误情况，但如果从 `@Incoming` 方法返回失败的 `Uni` ，则传入通道将有效地失败并停止响应流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `KafkaTransactions#withTransactionAndAck` method acks and nacks the message but will *not* return a failing `Uni`.  Nacked messages will be handled by the failure strategy of the incoming channel, (see &lt;&lt;error-handling&gt;&gt;).  Configuring `failure-strategy=ignore` simply resets the Kafka consumer to the last committed offsets and resumes the consumption from there.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KafkaTransactions#withTransactionAndAck` 方法确认和确认消息，但 *不会* 返回失败的 `Uni` 。 Nacked 消息将由传入通道的故障策略处理，（参见&lt;&lt;error-handling&gt;&gt;）。 配置 `failure-strategy=ignore` 只是将 Kafka 消费者重置为最后提交的偏移量并从那里恢复消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redpanda does not yet support link:https://github.com/redpanda-data/redpanda/issues/3279[producer scalability for exactly-once processing].  In order to use Kafka exactly-once processing with Quarkus you can configure Dev Services for Kafka to &lt;&lt;kafka-dev-services#configuring-the-image, use Strimzi images instead of Redpanda&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redpanda 尚不支持 link:https://github.com/redpanda-data/redpanda/issues/3279[producer scaling for exactly-once processing]。 为了在 Quarkus 中使用 Kafka 一次性处理，您可以将 Dev Services for Kafka 配置为 &lt;&lt;kafka-dev-services#configuring-the-image, use Strimzi images instead of Redpanda&gt;&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>classes for which a direct implementation of `org.apache.kafka.common.serialization.Serializer&lt;T&gt;` / `org.apache.kafka.common.serialization.Deserializer&lt;T&gt;` is present.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>直接实现了 `org.apache.kafka.common.serialization.Serializer&lt;T&gt;` / `org.apache.kafka.common.serialization.Deserializer&lt;T&gt;` 的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the implementation needs to specify the type argument `T` as the (de-)serialized type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些实现类需要指定类型参数 `T` 作为(反)序列化的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing using a Kafka broker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用Kafka broker的测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using &lt;&lt;kafka-dev-services&gt;&gt;, a Kafka broker will be started and available throughout the tests, unless it is disabled in `%test` profile.  While it is possible to connect to this broker using Kafka Clients API, https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] proposes an easier way of interacting with a Kafka broker and, creating consumer, producer and admin actions inside tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您使用 link:#kafka-dev-services[[kafka-dev-services]] ，Kafka broker将被启动并在整个测试中可用，除非它在 `%test` profile中被禁用。虽然可以使用Kafka客户端API连接到这个broker，但 link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] 提出了一种更简单的方式来与Kafka broker通信，并在测试中创建消费者、生产者和管理操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For using `KafkaCompanion` API in tests, start by adding the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了在测试中使用 `KafkaCompanion` API，首先要添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which provides `io.quarkus.test.kafka.KafkaCompanionResource` - an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它提供了 `io.quarkus.test.kafka.KafkaCompanionResource` -- `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` 的一种实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then use `@QuarkusTestResource` to configure the Kafka Companion in tests, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后使用 `@QuarkusTestResource` 在测试中配置Kafka Companion，比如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@InjectKafkaCompanion` injects the `KafkaCompanion` instance, configured to access the Kafka broker created for tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@InjectKafkaCompanion` 注入了 `KafkaCompanion` 实例，并被配置为可访问为测试目的而创建的Kafka broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `KafkaCompanion` to create producer task which writes 10 records to 'orders' topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用 `KafkaCompanion` 来创建生产者任务，用于向 'orders' topic写入10条记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create consumer task which subscribes to 'orders-processed' topic and consumes 10 records.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建消费者任务，用来订阅'orders-processed'topic并消费10条记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Await completion of the consumer task.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>等待消费者任务的完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the Kafka Dev Service is available during tests, `KafkaCompanionResource` uses the created Kafka broker, otherwise it creates a Kafka broker using https://github.com/strimzi/test-container[Strimzi Test Container].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果Kafka Dev Service在测试期间是可用的， `KafkaCompanionResource` 则会使用创建的Kafka broker，否则就使用 link:https://github.com/strimzi/test-container[Strimzi测试容器]创建一个Kafka broker。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration of the created Kafka broker can be customized using `@ResourceArg`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>创建Kafka broker的配置可以通过使用 `@ResourceArg` 来自定义，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom test resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自定义测试资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each channel can be disabled via configuration using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>每个 channel 都可以通过配置来禁用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#producerconfigs[Kafka producer].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您也可以传递底层 link:https://kafka.apache.org/documentation/#producerconfigs[Kafka生产者] 支持的任何属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to configure the `max.block.ms` property, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例如，要配置 `max.block.ms` 属性，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connecting to Managed Kafka clusters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>连接到受管理的Kafka集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section explains how to connect to notorious Kafka Cloud Services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本节解释了如何连接到臭名昭著的Kafka云服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Event Hub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Event Hub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] provides an endpoint compatible with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] 提供了一个与Apache Kafka兼容的节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Event Hubs for Kafka is not available in the _basic_ tier.  You need at least the _standard_ tier to use Kafka.  See https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs Pricing] to see the other options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Event Hubs for Kafka在 _基础(basic)_ 层中不可用。您至少需要 _标准(standard)_ 层才能使用Kafka。请参阅 link:https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs定价] 查看其他选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To connect to Azure Event Hub, using the Kafka protocol with TLS, you need the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用带有TLS的Kafka协议连接到Azure Event Hub的话，您需要以下配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The port is `9093`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该端口为 `9093` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to use the JAAS `PlainLoginModule`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>您需要使用JAAS `PlainLoginModule` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The username is the `$ConnectionString` string.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用户名是 `$ConnectionString` 字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Event Hub connection string given by Azure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由Azure提供的Event Hub连接字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace `&lt;YOUR.EVENTHUBS.CONNECTION.STRING&gt;` with the connection string for your Event Hubs namespace.  For instructions on getting the connection string, see https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Get an Event Hubs connection string].  The result would be something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用您的Event Hubs命名空间的连接字符串替换 `&lt;YOUR.EVENTHUBS.CONNECTION.STRING&gt;` 。有关获取连接字符串的说明，请参阅 link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[获取Event Hubs连接字符串] 。结果会类似这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configuration can be global (as above), or set in the channel configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这个配置可以是全局的(如上)，也可以在 channel 配置中设置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Red Hat OpenShift Streams for Apache Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>红帽OpenShift Streams for Apache Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloud.redhat.com/[Red Hat OpenShift Streams for Apache Kafka] provides managed Kafka brokers.  First, follow the instructions from https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the `rhoas` CLI for Red Hat OpenShift Streams for Apache Kafka] to create your Kafka broker instance.  Make sure you copied the client id and client secret associated with the _ServiceAccount_ you created.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://cloud.redhat.com/[红帽OpenShift Streams for Apache Kafka] 提供了受管理的Kafka brokers。首先，按照 link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[红帽OpenShift Streams for Apache Kafka的 `rhoas` 命令行入门] 的说明，创建您的Kafka broker实例。请确保您复制了与您创建的 _ServiceAccount_ 相关的客户ID和客户密码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you can configure the Quarkus application to connect to the broker as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，您可以配置Quarkus应用程序以连接到broker，如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connection string, given on the admin console, such as `demo-c--bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在管理控制台所给出的连接字符串，例如 `demo-c—​bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The kafka username (the client id from the service account)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka的用户名(来自service account的客户端ID)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, these properties are prefixed using `%prod` to enable them only when running in production mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般来说，这些属性的前缀使用 `%prod` ，以便只在生产模式下运行时启用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As explained in https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the rhoas CLI for Red Hat OpenShift Streams for Apache Kafka], to use Red Hat OpenShift Streams for Apache Kafka, you must create the topic beforehand, create a _Service Account_, and provide permissions to read and write to your topic from that service account.  The authentication data (client id and secret) relates to the service account, which means you can implement fine-grain permissions and restrict access to the topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正如在《 link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[红帽OpenShift Streams for Apache Kafka的 `rhoas` 命令行入门] 》中所解释的那样，要使用红帽OpenShift Streams for Apache Kafka，您必须事先创建topic，创建一个 _Service Account_ ，并提供从该服务账户读取和写入topic的权限。认证数据(客户端ID和密码)与服务账户有关，这意味着您可以实现细粒度的权限，并限制对topic的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Kubernetes, it is recommended to set the client id and secret in a Kubernetes secret:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当使用Kubernetes时，建议在Kubernetes secret中设置客户端ID和secret：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To allow your Quarkus application to use that secret, add the following line to the `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为了允许您的Quarkus应用程序使用该secret，请在 `application.properties` 文件中添加下面一行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatic Approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>编程实现方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use static methods on `QuarkusTransaction` to define transaction boundaries. This provides two different options, a functional approach that allows you to run a lambda within the scope of a transaction, or by using explicit `begin`, `commit` and `rollback` methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用 `QuarkusTransaction` 上的静态方法来定义事务边界。这提供了两种不同的选择，一种是允许你在事务范围内运行lambda的函数式方法，或者通过使用显式的 `begin` 、 `commit` 和 `rollback` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above example shows a few different ways the API can be used. The first method simply calls begin, does some work and commits it.  This created transaction is tied to the CDI request scope, so if it is still active when the request scope is destroyed then it will be automatically rolled back. This removes the need to explicitly catch exceptions and call `rollback`, and acts as a safety net against inadvertent transaction leaks, however it does mean that this can only be used when the request scope is active. The second example in the method calls begin with a timeout option, and then rolls back the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上面的例子显示了几种不同的API使用方法。第一个方法是简单地调用begin，做一些工作并提交。这个创建的事务是与CDI请求范围相联系的，所以如果它在请求范围被破坏时仍处于活动状态，那么它将被自动回滚。这样就不需要明确地捕捉异常和调用 `rollback` ，并作为一个安全措施来防止无意中的事务泄露，然而这也意味着这只能在请求范围处于活动状态时使用。方法调用中的第二个例子以一个超时选项开始，然后回滚事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second example shows the use of lambda scoped transactions, the first just runs a `Runnable` within a transaction, the second, runs `Callable` with some specific options. In particular the `exceptionHandler` method can be used to control if the transaction is rolled back or not on exception, and the `semantic` method controls the behaviour if an existing transaction is already started.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第二个例子展示了lambda范围内事务的使用，第一个例子只是在一个事务中运行 `Runnable` ，第二个例子，运行 `Callable` ，并带有一些特定的选项。特别是 `exceptionHandler` 方法可以用来控制事务是否在异常情况下回滚，而 `semantic` 方法可以控制现有事务已经开始时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following semantics are supported:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>支持以下语义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a transaction is already associated with the current thread a `QuarkusTransactionException` will be thrown, otherwise a new transaction is started, and follows all the normal lifecycle rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果一个事务已经与当前线程相关联，将抛出一个 `QuarkusTransactionException` ，否则将启动一个新的事务，并遵循所有正常的生命周期规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no transaction is active then a new transaction will be started, and committed when the method ends.  If an exception is thrown the exception handler registered by `#exceptionHandler(Function)` will be called to decide if the TX should be committed or rolled back.  If an existing transaction is active then the method is run in the context of the existing transaction. If an exception is thrown the exception handler will be called, however a result of `ExceptionResult#ROLLBACK` will result in the TX marked as rollback only, while a result of `ExceptionResult#COMMIT` will result in no action being taken.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有活动的事务，那么一个新的事务将被启动，并在方法结束时提交。如果一个异常被抛出，由 `#exceptionHandler(Function)` 注册的异常处理程序将被调用，以决定TX是否应该被提交或回滚。如果一个现有的事务处于活动状态，那么该方法将在现有事务的背景下运行。如果抛出一个异常，将调用异常处理程序，但是 `ExceptionResult#ROLLBACK` 的结果将导致TX被标记为回滚，而 `ExceptionResult#COMMIT` 的结果将导致不采取任何行动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the default semantic.  If an existing transaction is already associated with the current thread then the transaction is suspended, and resumed once the current transaction is complete.  A new transaction is started after the existing transaction is suspended, and follows all the normal lifecycle rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是默认的语义。如果一个现有的事务已经与当前线程相关联，那么该事务将被暂停，并在当前事务完成后恢复。一个新的事务在现有事务被暂停后开始，并遵循所有正常的生命周期规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no transaction is active then this semantic is basically a no-op.  If a transaction is active then it is suspended, and resumed after the task is run.  The exception handler will never be consulted when this semantic is in use, specifying both an exception handler and this semantic is considered an error.  This semantic allows for code to easily be run outside the scope of a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果没有事务处于活动状态，那么这个语义基本上就是一个无用功。如果一个事务处于活动状态，那么它就会被暂停，并在任务运行之后恢复。在使用这种语义的时候，将永远不会查询异常处理程序，同时指定异常处理程序和这种语义被认为是一个错误。这种语义允许在事务的范围之外轻松地运行代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Legacy API approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>传统的API方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache also supports extended MongoDB queries by providing a `Document` query, this is supported by the find/list/stream/count/delete/update methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>带有Panache的MongoDB还支持扩展的MongoDB查询，提供了一个 `Document` 查询，这被find/list/stream/count/delete/update方法所支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ObjectId` can be difficult to use if you want to expose its value in your REST service.  So we created Jackson and JSON-B providers to serialize/deserialize them as a `String` which are automatically registered if your project depends on either the RESTEasy Reactive Jackson extension or the RESTEasy Reactive JSON-B extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您想在 REST 服务中公开它的值，则 `ObjectId` 可能很难使用。因此，我们创建了 Jackson 和 JSON-B 提供程序，将它们序列化为 `String` ，如果您的项目依赖于 RESTEasy Reactive Jackson 扩展或 RESTEasy Reactive JSON-B 扩展，则会自动注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use MongoDB with Panache in conjunction with RESTEasy Reactive, you can directly return a reactive type inside your JAX-RS resource endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您将MongoDB和Panache和RESTEasy Reactive结合使用，您可以直接在JAX-RS资源端点内返回一个响应式类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It allows more advanced reactive use cases, for example, you can use it to send server-sent events (SSE) via RESTEasy Reactive:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>它允许更高级的响应式用例，例如，你可以用它来通过RESTEasy Reactive发送服务器发送的事件（SSE）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@RestStreamElementType(MediaType.APPLICATION_JSON)` tells RESTEasy Reactive to serialize the object in JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RestStreamElementType(MediaType.APPLICATION_JSON)` 告诉RESTEasy Reactive将对象序列化为JSON格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/GreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>然后，打开 `src/test/java/org/acme/quickstart/GreetingResourceIT.java` 。它包含了：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, include one of the RESTEasy Reactive extensions to enable JAX-RS endpoints, for example, add the `io.quarkus:quarkus-resteasy-reactive-jackson` dependency for JAX-RS and JSON support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>首先，请添加任意一个RESTEasy Reactive扩展的依赖，以启用JAX-RS端点，例如，添加支持JAX-RS和JSON的 `io.quarkus:quarkus-resteasy-reactive-jackson` 依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/jdbc/library[JDBC instrumentation] will add a span for each JDBC queries done by your application, to enable it, add the following dependency to your build file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过link:https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/jdbc/library[JDBC instrumentation] 可以为您的应用程序的每个JDBC查询添加一个span。要启用它，请在您的构建文件中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As it uses a dedicated JDBC driver, you must configure your datasource and Hibernate ORM to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>由于它使用专用的JDBC驱动，您必须配置您的数据源和Hibernate ORM来使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotating a method in any CDI aware bean with the `io.opentelemetry.extension.annotations.WithSpan` annotation will create a new Span and establish any required relationships with the current Trace context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在任何CDI可感知的Bean中用 `io.opentelemetry.extension.annotations.WithSpan` 注解来注释一个方法将会创建一个新的Span，并与当前Trace上下文建立所需要的任何关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method parameters can be annotated with the `io.opentelemetry.extension.annotations.SpanAttribute` annotation to indicate which method parameters should be part of the Trace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>方法参数可以使用 `io.opentelemetry.extension.annotations.SpanAttribute` 注解进行注释，来表示哪些方法参数是包含在Trace中的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello from RESTEasy Reactive" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个非常简单的REST端点，对"/hello "上的请求返回 "Hello from RESTEasy Reactive"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC comes as a dependency of `quarkus-resteasy-reactive` so you already have it handy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ArC作为 `quarkus-resteasy-reactive` 的一个依赖项，所以你已经有了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with Binary Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用二进制数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While `RedisClient` and `ReactiveRedisClient` expose convenient `String`-based methods that mirror the commands available in Redis, they do not handle binary data.  In order to store binary data in Redis, you can inject an instance of the lower-level `MutinyRedis` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然 `RedisClient` 和 `ReactiveRedisClient` 提供了基于 `字符串` 的方法，这些方法与 Redis 中可用的命令一一对应，但它们不能处理二进制数据。为了在Redis中存储二进制数据，你可以注入底层的 `MutinyRedis` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `MutinyRedis` instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入 `MutinyRedis` 实例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the https://smallrye.io/smallrye-mutiny-vertx-bindings/2.20.0/apidocs/io/vertx/mutiny/redis/client/Redis.html#send(io.vertx.mutiny.redis.client.Request)[`send`] method to send a command</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用该 link:https://smallrye.io/smallrye-mutiny-vertx-bindings/2.20.0/apidocs/io/vertx/mutiny/redis/client/Redis.html#send(io.vertx.mutiny.redis.client.Request)[`send`] 方法来发送一个命令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Request#arg` has overloads to support various types including `byte[]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Request#arg` 有重载支持各种类型，包括 `byte[]` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a bulk response into a byte array</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将批量响应转换为字节数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project with the `spring-scheduled` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个包含 `spring-scheduled` 扩展项的Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is another guide if you need a xref:rest-client-reactive.adoc[REST client] (including support for JSON).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你需要一个 link:rest-client-reactive.html[REST客户端] （包括对JSON的支持），还有另一个指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an introduction to writing JSON REST services with Quarkus.  A more detailed guide about RESTEasy Reactive is available xref:resteasy-reactive.adoc[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这是一个关于用Quarkus编写JSON REST服务的介绍。 link:resteasy-reactive.html[这里] 有关于RESTEasy Reactive的更详细的指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a new project importing the RESTEasy Reactive/JAX-RS and https://github.com/FasterXML/jackson[Jackson] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个导入RESTEasy Reactive/JAX-RS和 link:https://github.com/FasterXML/jackson[Jackson] 扩展的新项目，特别是添加了以下依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] so, if you prefer JSON-B over Jackson, you can create a project relying on the RESTEasy Reactive JSON-B extension instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus也支持 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] ，因此，如果你喜欢JSON-B而不是Jackson，你可以创建一个依赖RESTEasy Reactive JSON-B扩展的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a new project importing the RESTEasy Reactive/JAX-RS and https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>该命令生成了一个导入RESTEasy Reactive/JAX-RS和 link:https://eclipse-ee4j.github.io/jsonb-api/[JSON-B] 扩展的新项目，特别是添加了以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While named "reactive", RESTEasy Reactive supports equally well both traditional blocking patterns and reactive patterns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>虽然名为 "响应式"，但RESTEasy Reactive同样支持传统的阻塞模式和响应式模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about RESTEasy Reactive, please refer to the xref:resteasy-reactive.adoc[dedicated guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有关RESTEasy Reactive的更多信息，请参考 link:resteasy-reactive.html[专用指南] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-resteasy-reactive-jackson` or `quarkus-resteasy-reactive-jsonb`, Quarkus will use the `application/json` media type by default for most return values, unless the media type is explicitly set via `@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream` respectively).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当安装了一个JSON扩展，如 `quarkus-resteasy-reactive-jackson` 或 `quarkus-resteasy-reactive-jsonb` ，Quarkus将对大多数返回值默认使用 `application/json` 媒体类型，除非通过 `@Produces` 或 `@Consumes` 注解明确设置媒体类型（对于众所周知的类型有一些例外，如 `String` 和 `File` ，它们分别默认为 `text/plain` 和 `application/octet-stream` ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is naturally integrated with Mutiny.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive与Mutiny集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your endpoints can return `Uni` or `Multi` instances:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你的节点可以返回 `Uni` 或 `Multi` 实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka supports https://redpanda.com[Redpanda] and https://strimzi.io[Strimzi] (in https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] mode).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka开发服务支持 link:https://redpanda.com[Redpanda] 和 link:https://strimzi.io[Strimzi] （在 link:https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] 模式下）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redpanda is a Kafka compatible event streaming platform.  Because it provides a faster startup time dev services defaults to `vectorized/redpanda` images.  You can select any version from https://hub.docker.com/r/vectorized/redpanda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redpanda是一个兼容Kafka的事件流平台。因为它在dev服务默的 `vectorized/redpanda` 镜像中提供了更快的启动时间。您可以从 https://hub.docker.com/r/vectorized/redpanda  中选择任何版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strimzi provides container images and Operators for running Apache Kafka on Kubernetes.  While Strimzi is optimized for Kubernetes, the images work perfectly in classic container environments.  Strimzi container images run "genuine" Kafka broker on JVM, which is slower to start.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Strimzi为在Kubernetes上运行Apache Kafka提供了容器镜像和Operator。虽然Strimzi针对Kubernetes进行了优化，但这些镜像在经典的容器环境中也能完美运行。Strimzi容器镜像在JVM上运行 "真实的 "Kafka broker，其启动速度较慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Strimzi, you can select any image with a Kafka version which has Kraft support (2.8.1 and higher) from https://quay.io/repository/strimzi-test-container/test-container?tab=tags</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对于Strimzi，您可以从 https://quay.io/repository/strimzi-test-container/test-container?tab=tags ，选择任何可以获得Kraft支持的Kafka版本（2.8.1及以上）的镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section gives an example using the Vert.x `WebClient` in the context of a RESTEasy Reactive application.  As indicated in the table above, add the following dependency to your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本节给出一个在RESTEasy Reactive应用程序中使用Vert.x `WebClient` 的例子。如上表所示，在你的项目中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If building with Mandrel, make sure to use version Mandrel 22.1 or above, for example `ubi-quarkus-mandrel:22.1-java17`.  With older versions, you might encounter errors when trying to deserialize JSON documents that have null or missing fields, similar to the errors mentioned in the &lt;&lt;kotlin-jackson&gt;&gt; section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果用Mandrel构建，确保使用Mandrel 22.1或以上的版本，例如 `ubi-quarkus-mandrel:22.1-java17` 。对于旧版本，当您试图反序列化有空字段或缺失字段的JSON文档时，可能会遇到错误，类似于 link:#kotlin-jackson&lt;&lt;kotlin-jackson&gt;&gt; 部分提到的错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring live reload compiler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配置实时重载编译器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to customize the compiler flags used by `kotlinc` in development mode, you can configure them in the quarkus plugin:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果您需要定制 `kotlinc` 在开发模式下使用的编译标志（compiler flags），您可以在quarkus插件中配置它们。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle (Groovy DSL)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle (Groovy DSL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle (Kotlin DSL)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>或者，如果您使用Gradle Kotlin DSL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following extensions provide support for Kotlin Coroutines by allowing the use of Kotlin's `suspend` keyword on method signatures.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下扩展通过允许在方法签名上使用Kotlin的 `suspend` 关键字，为Kotlin Coroutines提供支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-resteasy-reactive`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-resteasy-reactive`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for JAX-RS Resource Methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为JAX-RS Resource方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-rest-client-reactive`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-rest-client-reactive`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for REST Client interface methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为REST客户端接口方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-reactive-messaging`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-reactive-messaging`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for Reactive messaging methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供对响应式信息传递方法的支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-scheduler`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-scheduler`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for scheduler methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>为调度器方法提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-fault-tolerance`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-fault-tolerance`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support is provided for the declarative annotation-based API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>对基于声明性注解的API提供支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin coroutines provide an imperative programming model that actually gets executed in an asynchronous, reactive manner.  To simplify the interoperability between Mutiny and Kotlin there is the module `io.smallrye.reactive:mutiny-kotlin`, described link:https://smallrye.io/smallrye-mutiny/guides/kotlin[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin coroutines提供了一个命令式的编程模型，实际上是以异步、响应式的方式执行。这里提供了一个模块 `io.smallrye.reactive:mutiny-kotlin` ，以简化Mutiny和Kotlin之间的互操作性 ，link:https://smallrye.io/smallrye-mutiny/guides/kotlin[在此] 描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been honored to receive multiple awards and recognition. We feel these are an affirmation of the great work being done by our dedicated community. We’ve started a trophy case to share the kudos with everyone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus有幸获得多个奖项和认可。我们认为这些都是对我们的社区所做的伟大工作的肯定。我们设立了奖杯陈列柜，与大家分享荣誉。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Awards and Recognition</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>奖项及表彰</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`throttled` keeps track of received messages and commits an offset of the latest acked message in sequence (meaning, all previous messages were also acked).  This strategy guarantees at-least-once delivery even if the channel performs asynchronous processing.  The connector tracks the received records and periodically (period specified by `auto.commit.interval.ms`, default: 5000 ms) commits the highest consecutive offset.  The connector will be marked as unhealthy if a message associated with a record is not acknowledged in `throttled.unprocessed-record-max-age.ms` (default: 60000 ms).  Indeed, this strategy cannot commit the offset as soon as a single record processing fails (see &lt;&lt;error-handling&gt;&gt; to configure what happens on failing processing).  If `throttled.unprocessed-record-max-age.ms` is set to less than or equal to `0`, it does not perform any health check verification.  Such a setting might lead to running out of memory if there are "poison pill" messages (that are never acked).  This strategy is the default if `enable.auto.commit` is not explicitly set to true.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`throttled` 追踪接收到的消息并顺序的提交最新的被确认消息的偏移量(也就是说所有之前的消息也都被确认了)。这种策略会保证至少一次的发送(delivery)，即使channel使用了异步处理。Connector会跟踪接收到的记录，并定期(周期由 `auto.commit.interval.ms` 指定，默认为5000ms)提交最高的连续偏移量。如果一个与记录相关的消息在 `throttled.unprocessed-record-max-age.ms` (默认：60000 ms)时间内没有被确认，connector将被标记为不健康。事实上，这个策略不能在单条记录处理失败后立即提交偏移量(参考 &lt;&lt;error-handling&gt;&gt; 来配置失败处理策略)。如果 `throttled.unprocessed-record-max-age.ms` 被设置为小于或等于 `0` ，它就不执行任何健康检查。如果有(从未被确认的) "毒丸(poison pill) "信息，如此设置可能会导致内存耗尽。如果 `enable.auto.commit` 没有明确地设置为 "true"，这个将是默认策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A common business requirement is to consume and process Kafka records in order.  The Kafka broker preserves order of records inside a partition and not inside a topic.  Therefore it is important to think about how records are partitioned inside a topic.  The default partitioner uses record key hash to compute the partition for a record, or when the key is not defined, chooses a partition randomly per batch or records.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一个常见的业务需求是按顺序消费和处理Kafka records。Kafka broker将records的顺序保存在了分区内而不是topic内。因此，如何将records在topic内的分区中分配是需要着重考虑的。默认的分区器使用record key的哈希值计算record的分区，或者当key没有被定义时，会根据批次或records随机的选择分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your transaction boundaries either declarativly with `@Transactional` or programmatically with `QuarkusTransaction`. You can also use the JTA `UserTransaction` API directly, however this is less user friendly than `QuarkusTransaction`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以用 `@Transactional` ，或者用 `QuarkusTransaction` ，以编程方式定义你的事务边界。你也可以直接使用JTA的 `UserTransaction` API，但是没有 `QuarkusTransaction` 好用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Guides - Latest</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最新指南</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} - Publications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} - 发表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below is a list of articles, blogs, podcast and other tidbits published online around {project-name}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下面是网上发布的文章、博客、播客和其他趣闻 {project-name}。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you believe we are missing an article, blog or video https://github.com/quarkusio/quarkusio.github.io[submit an issue].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你认为我们少了一篇文章，博客或视频 https://github.com/quarkusio/quarkusio.github.io[提交一个议题]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support When You Need It.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>在你需要的时候给予支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ways to connect with others via forum, stack, chat, or email groups.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通过论坛、Stack、聊天或电子邮件组多种方式同我们保持联系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discussion about Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>讨论Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These instructions will get you a copy of the Quarkus.io website up and running on your local machine for development and testing purposes.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>这些指令会给你一份Quarkus.io网站的副本，启动并运行在本地机器上，用于开发和测试。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install a full [Ruby development environment](https://jekyllrb.com/docs/installation/). If you use `rvm`, run: `rvm use 2.7.1`.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装完整的 [Ruby开发环境](https://jekyllrb.com/docs/installation/)。如果你使用 `rvm`, 运行: `rvm use 2.7.1`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install [bundler](https://jekyllrb.com/docs/ruby-101/#bundler)  [gems](https://jekyllrb.com/docs/ruby-101/#gems)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装 [bundler](https://jekyllrb.com/docs/ruby-101/#bundler)  [gems](https://jekyllrb.com/docs/ruby-101/#gems)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fork the [project repository](https://github.com/quarkusio/quarkusio.github.io), then clone your fork.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将 [项目 repository](https://github.com/quarkusio/quarkusio.github.io)打分支，然后克隆您的 fork.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change into the project directory:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>切换到工程目录：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use bundler to fetch all required gems in their respective versions
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用bundler获取各自版本中所需的所有gems
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the site and make it available on a local server
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>构建站点并使其在本地服务器上可用
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now browse to http://localhost:4000
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>现在用浏览器访问 http://localhost:4000
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt; If you encounter any unexpected errors during the above, please refer to the [troubleshooting](https://jekyllrb.com/docs/troubleshooting/#configuration-problems) page or the [requirements](https://jekyllrb.com/docs/installation/#requirements) page, as you might be missing development headers or other prerequisites.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&gt; 如果您在上述过程中遇到任何意外错误，请参阅 [排错](https://jekyllrb.com/docs/troubleshooting/#configuration-problems) 页面或者 [需求](https://jekyllrb.com/docs/installation/#requirements) 页面，因为您可能会错过开发headers或其他先决条件。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**For more regarding the use of Jekyll, please refer to the [Jekyll Step by Step Tutorial](https://jekyllrb.com/docs/step-by-step/01-setup/).**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**更多关于使用Jekyll，请参考 [Jekyll循序渐进教程](https://jekyllrb.com/docs/step-by-step/01-setup/).**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to GitHub Pages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>部署到GitHub页面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The website deployment is automatically performed by GitHub Actions (when commits are pushed to the `develop` branch).
If for some reason you need to deploy from your local machine, follow these instructions:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>网站部署由GitHub Actions自动执行(当提交被推送到 `develop` 分支时)。
如果由于某些原因需要从本地机器进行部署，请遵循以下说明：

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the [act](https://github.com/nektos/act#installation) executable to run GitHub Actions locally
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>安装 [act](https://github.com/nektos/act#installation) 可执行文件本地运行GitHub Actions
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run `act -s GITHUB_TOKEN=&lt;GITHUB_TOKEN&gt;`, where *&lt;GITHUB_TOKEN&gt;* needs to be replaced with a token that allows you to push to the https://github.com/quarkusio/quarkusio.github.io repository.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>运行 `act -s GITHUB_TOKEN=&lt;GITHUB_TOKEN&gt;`，其中 *&lt;GITHUB_TOKEN&gt;* 需要替换为允许您推送到 https://github.com/quarkusio/quarkusio.github.io repository 的令牌。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a blog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写博客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write a blog:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>写博客：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`emailhash` you can get by running `echo -n your@email.org | md5sum` on Linux or `echo -n your@email.org | md5` on macOS using an email you have registered from the [Gravatar service](https://gravatar.com),
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>你可以使用您已经在 [Gravatar service](https://gravatar.com) 注册的电子邮件，在Linux运行 `echo -n your@email.org | md5sum` 或在macOS运行 `echo -n your@email.org | md5` 获得`emailhash` 。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`tags` should be used with some care as an archive page is created for of them. Below are some basic rules to try follow:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`tags` 应该谨慎使用，因为存档页面是为它们创建的。以下是一些你可以尝试遵循的基本规则：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`announcement` used for general announcement with some impact.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`announcement` 用于具有一定影响的一般公告。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`extension` used for blogs related to a specific extension.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`extension` 用于与特定扩展相关的博客。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`user-story` used for stories from users/companies adopting Quarkus.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`user-story` 用于用户/公司采用Quarkus的故事。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`development-tips` used for blogs with tips to develop using Quarkus or Quarkus itself. 
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`development-tips` 用于带有使用Quarkus或Quarkus本身开发提示的博客。 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add a tech specific, like `kafka`, if your post has a significant mention/relevance to that technology.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>如果你的帖子与该技术有显著的相关性，可以添加一个技术细节，比如 `kafka`。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be aware that the `date` attribute in the asciidoc preamble defines when the article will be published. Use a present date while writing your article to test locally, then switch to the actual target date before submitting. 
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请注意，asciidoc序言中的 `date` 属性定义了文章将于何时发布。在写文章时使用当前日期进行本地测试，然后在提交之前切换到实际的目标日期。 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please read [CONTRIBUTING.md](https://github.com/quarkusio/quarkusio.github.io/blob/master/CONTRIBUTING.md) for details on our code of conduct, and the process for submitting pull requests to us.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>请参考 [CONTRIBUTING.md](https://github.com/quarkusio/quarkusio.github.io/blob/master/CONTRIBUTING.md) 关于我们的行为准则的细节，以及提交合并请求给我们的过程。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This website is licensed under the [Creative Commons Attribution 3.0](https://creativecommons.org/licenses/by/3.0/).
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本网站是根据 [知识共享署名许可协议 3.0](https://creativecommons.org/licenses/by/3.0/) 维护。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our monthly newsletters bring together articles, videos and perspectives from across the Quarkus community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我们的每月通讯汇集了来自整个Quarkus社区的文章、视频和观点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>World Tour - Abstracts and Support materials.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>世界巡回-摘要和支持材料。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
